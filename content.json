{"meta":{"title":"笔友🍉の知识库","subtitle":"","description":"Self-Discipline","author":"笔友🍉","url":"https://biyouqiuqiu.com","root":"/"},"pages":[{"title":"","date":"2023-05-31T23:45:14.074Z","updated":"2023-05-31T23:45:14.074Z","comments":true,"path":"about/index.html","permalink":"https://biyouqiuqiu.com/about/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2023-05-31T23:46:33.843Z","updated":"2023-05-31T23:46:33.843Z","comments":true,"path":"friends/index.html","permalink":"https://biyouqiuqiu.com/friends/index.html","excerpt":"这里写友链上方的内容。","text":"这里写友链上方的内容。 这里可以写友链页面下方的文字备注，例如自己的友链规范、示例等。"},{"title":"随笔","date":"2023-06-01T05:02:23.175Z","updated":"2023-06-01T05:02:23.175Z","comments":true,"path":"informal essay/index.html","permalink":"https://biyouqiuqiu.com/informal%20essay/index.html","excerpt":"","text":""},{"title":"好文收集","date":"2023-06-01T04:58:09.833Z","updated":"2023-06-01T04:58:09.833Z","comments":true,"path":"collectings/index.html","permalink":"https://biyouqiuqiu.com/collectings/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2023-05-31T23:45:51.441Z","updated":"2023-05-31T23:45:51.441Z","comments":true,"path":"categories/index.html","permalink":"https://biyouqiuqiu.com/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2023-06-01T04:44:20.604Z","updated":"2023-06-01T04:44:20.604Z","comments":true,"path":"tags/index.html","permalink":"https://biyouqiuqiu.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"temp","slug":"temp","date":"2023-06-01T00:06:54.000Z","updated":"2023-06-01T00:06:54.000Z","comments":true,"path":"post/undefined/","link":"","permalink":"https://biyouqiuqiu.com/post/undefined/","excerpt":"","text":"1、 hexo new page &#x2F; “文件名” 2、hexo new [&#x2F;about] “文件名” 3、给文章加密 1npm install hexo-blog-encrypt safdafa eaf djfdfaf zheli shi yin yong fjdasp fadp","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2023-05-31T15:46:24.322Z","updated":"2023-05-31T15:46:24.322Z","comments":true,"path":"post/undefined/","link":"","permalink":"https://biyouqiuqiu.com/post/undefined/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"ethersjs_self","slug":"Ethersjs/Basic_Knowledge/ethersjs_self","date":"2023-05-12T02:47:10.000Z","updated":"2023-05-12T02:47:10.000Z","comments":true,"path":"post/undefined/","link":"","permalink":"https://biyouqiuqiu.com/post/undefined/","excerpt":"","text":"ethers.js_day011. ethers.js的安装 参考文档 在终端执行命令： 1npm install --save ethers 出现的问题: a. 按照 B站教程来的话，需要修改package.js中的配置，如： 123456&#123; &quot;type&quot;: &quot;module&quot;, &quot;dependencies&quot;: &#123; &quot;ethers&quot;: &quot;^5.6.9&quot; &#125;&#125; 在这里：加入了 &#39;&#39;type&quot;: &quot;module&quot;之后，require()这种引包的方式就不能使用了，网上搜了一下说是 ES6模块（没系统学过JavaScript，不是很懂，只是记录一下，避免继续犯错），得需要使用 import的方式导入 ethers包 1const &#123; ethers &#125; = require(&quot;ethers&quot;); 1import &#123; ethers &#125; from &quot;ethers&quot;; b. B站视频中在vscode上安装的ethers包的命令为： 1npm install ethers@5.6.9 这行代码会让代码无法运行，报错如下： 2. 编写 Hello Vitalik2.1 编译器： 在线编译器 —– playcode 本地编译器 —– VSCode 2.2 第一段代码 示例代码： 1234567import &#123; ethers &#125; from &quot;ethers&quot;;const provider = ethers.getDefaultProvider();const main = async () =&gt; &#123; const balance = await provider.getBalance(`vitalik.eth`); console.log(`ETH Balance of vitalik: $&#123;ethers.utils.formatEther(balance)&#125; ETH`);&#125;main() 解读代码 1234const main = async () =&gt; &#123; const balance = await provider.getBalance(`vitalik.eth`); console.log(`ETH Balance of vitalik: $&#123;ethers.utils.formatEther(balance)&#125; ETH`);&#125; 代码的意思： 这是一段使用 JavaScript 编写的代码，使用了 ethers.js 库与以太坊节点进行交互。 这段代码定义了一个异步函数 main()，在函数中： 使用 provider.getBalance() 函数获取 vitalik.eth 地址上的以太币余额，并将结果存储在 balance 变量中。这里的 provider 是一个 ethers.js 库中提供的以太坊节点对象，它用于与以太坊网络进行通信。 使用 ethers.utils.formatEther() 函数将以太币余额从 wei 单位转换为以太币单位，并将结果打印到控制台中。 因为 getBalance() 函数是异步函数，它会从以太坊网络中读取数据，因此需要使用 await 关键字等待它完成读取操作。在等待 getBalance() 函数完成后，balance 变量将包含返回的余额值，可以对其进行处理并打印到控制台中。 ethers.js_day023. Provider 提供器3.1 运行如下代码报错：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// 导入ethers包import &#123; ethers &#125; from &quot;ethers&quot;;// playcode免费版不能安装ethers，用这条命令，需要从网络上import包（把上面这行注释掉）// import &#123; ethers &#125; from &quot;https://cdn-cors.ethers.io/lib/ethers-5.6.9.esm.min.js&quot;;// 利用Alchemy的rpc节点连接以太坊网络// 准备 alchemy API 可以参考https://github.com/AmazingAng/WTFSolidity/blob/main/Topics/Tools/TOOL04_Alchemy/readme.md const ALCHEMY_MAINNET_URL = &#x27;https://eth-mainnet.g.alchemy.com/v2/oKmOQKbneVkxgHZfibs-iFhIlIAl6HDN&#x27;;const ALCHEMY_GOERLI_URL = &#x27;https://eth-goerli.alchemyapi.io/v2/GlaeWuylnNM3uuOo-SAwJxuwTdqHaY5l&#x27;;// 连接以太坊主网const providerETH = new ethers.JsonRpcProvider(ALCHEMY_MAINNET_URL)// 连接Goerli测试网const providerGoerli = new ethers.JsonRpcProvider(ALCHEMY_GOERLI_URL)const main = async () =&gt; &#123; // 利用provider读取链上信息 // 1. 查询vitalik在主网和Goerli测试网的ETH余额 console.log(&quot;1. 查询vitalik在主网和Goerli测试网的ETH余额&quot;); const balance = await providerETH.getBalance(`vitalik.eth`); const balanceGoerli = await providerGoerli.getBalance(`vitalik.eth`); // 将余额输出在console（主网） console.log(`ETH Balance of vitalik: $&#123;ethers.formatEther(balance)&#125; ETH`); // 输出Goerli测试网ETH余额 console.log(`Goerli ETH Balance of vitalik: $&#123;ethers.formatEther(balanceGoerli)&#125; ETH`); // 2. 查询provider连接到了哪条链 console.log(&quot;\\n2. 查询provider连接到了哪条链&quot;) const network = await providerETH.getNetwork(); console.log(network.toJSON()); // 3. 查询区块高度 console.log(&quot;\\n3. 查询区块高度&quot;) const blockNumber = await providerETH.getBlockNumber(); console.log(blockNumber); // 4. 查询 vitalik 钱包历史交易次数 console.log(&quot;\\n4. 查询 vitalik 钱包历史交易次数&quot;) const txCount = await providerETH.getTransactionCount(&quot;vitalik.eth&quot;); console.log(txCount); // 5. 查询当前建议的gas设置 console.log(&quot;\\n5. 查询当前建议的gas设置&quot;) const feeData = await providerETH.getFeeData(); console.log(feeData); // 6. 查询区块信息 console.log(&quot;\\n6. 查询区块信息&quot;) const block = await providerETH.getBlock(0); console.log(block); // 7. 给定合约地址查询合约bytecode，例子用的WETH地址 console.log(&quot;\\n7. 给定合约地址查询合约bytecode，例子用的WETH地址&quot;) const code = await providerETH.getCode(&quot;0xc778417e063141139fce010982780140aa0cd5ab&quot;); console.log(code);&#125;main() 报错结果如下： 报错原因是说 JsonRpcProvider 不是一个构造器，到官方文档上查看，JsonRpcProvider的用法是： 1234// 连接以太坊主网const providerETH = new ethers.providers.JsonRpcProvider(ALCHEMY_MAINNET_URL)// 连接Goerli测试网const providerGoerli = new ethers.providers.JsonRpcProvider(ALCHEMY_GOERLI_URL) RPC的连接 3.2 与本地的ganache获取连接 代码： 123456789import &#123; ethers &#125; from &quot;ethers&quot;;const provider = ethers.getDefaultProvider(&quot;HTTP://127.0.0.1:8545&quot;);// 我设置的端口号为8545const address = &#x27;&#x27;; // 替换为需要查询余额的账户地址provider.getBalance(address).then((balance) =&gt; &#123; console.log(`Account balance: $&#123;ethers.utils.formatEther(balance)&#125; ETH`);&#125;).catch((err) =&gt; &#123; console.error(&#x27;Error:&#x27;, err);&#125;); ​ 3.3 与 metamask（小狐狸🦊钱包）建立连接 3.3.1 需要到 Alchemy 上获取RPC 的节点 12345678const provider = ethers.getDefaultProvider(&quot;&quot;); // 从Alchemy获取const address = &#x27;&#x27;; // 替换为需要查询余额的账户地址provider.getBalance(address).then((balance) =&gt; &#123; console.log(`Account balance: $&#123;ethers.utils.formatEther(balance)&#125; ETH`);&#125;).catch((err) =&gt; &#123; console.error(&#x27;Error:&#x27;, err);&#125;); 3.4 利用Provider读取链上数据tips：const provider = new ethers.providers.JsonRpcProvider(&quot;HTTP://127.0.0.1:8545&quot;); 这个的连接速度要比const provider = ethers.getDefaultProvider(&quot;HTTP://127.0.0.1:8545&quot;);的连接速度更快 3.5 获取指定地址的余额 – provider.getBalance(address) 代码： 12345&gt;provider.getBalance(address).then((balance) =&gt; &#123; console.log(`Account balance: $&#123;ethers.utils.formatEther(balance)&#125; ETH`);&gt;&#125;).catch((err) =&gt; &#123; console.error(&#x27;Error:&#x27;, err);&gt;&#125;); 解释： 这段代码是使用以太坊 JavaScript 库 Ethers.js 来查询指定以太坊地址的余额，并将其以以太币（ETH）的形式打印到控制台上。 具体来说，这段代码执行了以下步骤： 调用 provider.getBalance(address) 方法，其中 provider 是一个以太坊节点提供商，address 是要查询的以太坊地址。 getBalance() 方法返回一个 Promise，该 Promise 在查询完成后返回以太坊地址的余额。 当 Promise 被解析时，then() 方法中的回调函数会被执行。该回调函数使用 ethers.utils.formatEther() 方法将余额从 wei 转换为以太，并将结果打印到控制台上。 如果 Promise 被拒绝（即查询失败），则 catch() 方法中的回调函数会被执行，该回调函数将错误信息打印到控制台上 3.6 查询provider连接到那条链 – provider.getNetwork() 代码： 1const netWork = await provider.getNetwork(); 查询结果： 3.7 查询当前 gas price — provider.getGasPrice() tips:返回的数据格式为BigNumber，可以用BigNumber类的toNumber()或toString() 方法转换成数字或者字符串 代码： 12&gt;const gas_price = await provider.getGasPrice();&gt;console.log(gas_price.toString()); 运行结果： 3.8 查询区块信息 – provider.getBlock() 代码： 1const block = await provider.getBlock(2); 查询结果： 3.9 查询地址的合约bytecode — provider.getCode(address) 代码： 12const address = &quot;0x44f2A5d2CFf45111E5FdcBE600CfA62Ea0386E7f&quot;; //合约地址const code = await providerETH.getCode(address); 查询结果： 4.读取合约信息4.1 创建Contract变量4.1.1 只读Contract tips：参数分别是合约地址，合约的abi和provider变量（只读） 代码： 1const contract = new ethers.Contract(`address`,`abi`,`provider`) 4.1.2 可读写 Contract tips: 参数分别是合约地址，合约的abi和singer变量。Singer签名者是ethers中另一个类，用于签名交易。 代码： 1const contract = new ethers.Contract(`address`, `abi`, `signer`); 4.2 创建只读 Contract实例tips：创建Contract实例需要填入三个参数，分别是合约地址，合约abi和provider变量。 tips:ehters支持两种abi填法 方法一：直接输出合约的abi。也可以像之前web3中那样使用 fs包读取 .abi文件，我觉得这种可读性更强一些。 1234var fs = require(&quot;fs&quot;);var path = &quot;&quot;;//这里是你本地abi的文件地址var contractABI = JSON.parse(fs.readFileSync(path),toString()); 参考代码： 123456789101112131415// SPDX-License-Identifier: MITpragma solidity ^0.4.21;contract CallMeChallenge &#123; int public value = 5; bool public isComplete = false; function callme() public &#123; isComplete = true; &#125; function getValue() external view returns(int) &#123; return value; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334import &#123; Contract, ethers &#125; from &quot;ethers&quot;; // ES6模块下引入ethers包// var fs = require(&quot;fs&quot;)import fs from &quot;fs&quot;; // ES6模块下引入fs包const provider = new ethers.providers.JsonRpcProvider(&quot;HTTP://127.0.0.1:8545&quot;);// 读取文件的abilet con_ABI = JSON.parse(fs.readFileSync(&quot;D:\\\\VSCode\\\\VSCode_Data\\\\ethersjsWorkspace\\\\LearningSelf\\\\abi\\\\CallMeChallenge.abi&quot;).toString())// 合约地址let con_Address = &quot;0xCfD32B1C6C1b2Fb425F3d6a86F8E2ebB363b5d96&quot;;// 创建合约let contract = new ethers.Contract(con_Address,con_ABI,provider);async function main() &#123; let slot0 = await provider.getStorageAt(con_Address,0); console.log(&quot;slot0 = &gt;&quot; + slot0); let slot1 = await provider.getStorageAt(con_Address,0); console.log(&quot;slot1 = &gt;&quot; + slot1);&#125; // 调用函数main()// 调用合约的只读函数let value = await contract.getValue();console.log(&quot;value =&gt; &quot; + value);let address = &quot;0xfDc84b042c01F01C7cC6eF08452BA156844c3A5C&quot;;provider.getBalance(address).then((balance)=&gt;&#123; console.log(`Account balance: $&#123;ethers.utils.formatEther(balance)&#125; ETH`);&#125;) 运行结果： 注: 在Solidity中，布尔类型(bool)的默认值是false。在你的智能合约中，存储槽(slot)的位置为0，存储的变量是布尔类型(isComplete)，因此默认值为false。 当你部署合约时，存储槽的初始值会被设置为false。如果在之后合约的执行过程中，调用了callme()函数，isComplete变量的值会被设置为true，存储槽的值也会相应地被更新为true。 在使用ethers查询存储槽的值时，如果存储槽的值为false，查询结果会显示为0x0。如果存储槽的值为true，查询结果会显示为0x1。 因此，如果你在查询智能合约的存储槽时得到的结果是0x0，这意味着存储槽的值为false，即isComplete变量还没有被设置为true。如果你想要获取存储槽的实际值，可以将查询结果转换为布尔类型，如下所示: 123const slot0 = await provider.getStorageAt(contractAddress, 0);const isComplete = ethers.utils.bigNumberify(slot0).toNumber() !== 0;console.log(`isComplete: $&#123;isComplete&#125;`); 这段代码将查询结果转换为BigNumber类型，并将其转换为数字类型。如果数字不为0，isComplete变量的值为true，否则为false。 方法二：由于abi可读性太差，ethers创新的引入了人类可读ABI。开发者可以通过function signature和event signature来写ABI。 参考代码： 123456789101112131415161718192021222324252627import &#123; Contract, ethers &#125; from &quot;ethers&quot;; // ES6模块下引入ethers包// var fs = require(&quot;fs&quot;)import fs from &quot;fs&quot;; // ES6模块下引入fs包const provider = new ethers.providers.JsonRpcProvider(&quot;HTTP://127.0.0.1:8545&quot;);// 读取文件的abilet con_ABI = JSON.parse(fs.readFileSync(&quot;D:\\\\VSCode\\\\VSCode_Data\\\\ethersjsWorkspace\\\\LearningSelf\\\\abi\\\\CallMeChallenge.abi&quot;).toString())// 合约地址let con_Address = &quot;0xCfD32B1C6C1b2Fb425F3d6a86F8E2ebB363b5d96&quot;;// 创建合约let contract = new ethers.Contract(con_Address,con_ABI,provider);let abi = [ &quot;function callme() public&quot;, &quot;function getValue() external view returns(int)&quot;,]let contract1 = new ethers.Contract(con_Address,abi,provider);async function demo1()&#123; // 调用合约的只读函数 let value = await contract1.getValue(); console.log(&quot;demo1&#x27;s value =&gt; &quot; + value);&#125;demo1() 运行结果： 4.3 更多的读取合约信息可到 官方文档 查看5.发送ETH5.1 Signer签名类在ethers中，Signer签名者类是以太坊账户的抽象类，可用于对消息和交易进行签名，并将签名的交易发送到以太坊网络，并更改区块链状态。Signer类是抽象类，不能直接实例化，我们需要使用它的子类：Wallet钱包类。 5.2 Wallet钱包类Wallet类继承了Signe类，并且开发者可以像包含私钥的外部拥有者账户（EOA）一样，用它对交易和消息进行签名。 5.2.1方法一：创建随机的wallet对象我们可以使用 ethers.Wallet.createRandom()函数创建带有随机私钥的Wallet对象。对该私钥由加密安全的熵源生成，如果当前环境没有安全的熵源，则会引发错误。 tips：在密码学中，熵（entropy）是指随机性的度量。在智能合约中，熵源（entropy source）是指用于生成随机数或随机种子的源头。 在智能合约中，为了确保随机数的安全性和不可预测性，需要使用熵源来生成随机数或随机种子。通常情况下，熵源可以是外部的数据源，例如区块哈希或者时间戳等，也可以是合约内部的数据源，例如合约的存储槽或者合约的执行结果等。 需要注意的是，熵源的质量和安全性对于密码学应用非常重要。如果熵源不够随机或者不够安全，可能会导致随机数的可预测性，从而破坏密码学应用的安全性。因此，在使用熵源生成随机数或随机种子时，需要选择合适的熵源，并对其进行充分的测试和验证，以确保其安全性和不可预测性。 12// 创建随机的wallet对象const wallet1 = new ethers.Wallet.createRandom() 5.2.2方法二：用私钥创建wallet对象我们已知私钥的情况下，可以利用ethers.Wallet() 函数创建 Wallet对象。 从Ganache中获取privateKey 123// 利用私钥和provider创建wallet对象const privateKey = &#x27;&#x27; // 填入你的私钥const wallet2 = new ethers.Wallet(privateKey, provider) 5.2.3方法三：从助记词创建wallet对象我们已知助记词的情况下，可以利用 ethers.Wallet.fromMnemonic() 函数创建Wallet对象。 12// 从助记词创建wallet对象const wallet3 = new ethers.Wallet.fromMnemonic(mnemonic.phrase) 5.2.4 其他方法：通过JSON文件创建wallet对象通过ethers.Wallet.fromEncryptedJson解密一个JSON钱包文件创建钱包实例，JSON文件即keystore文件，通常来自Geth, Parity等钱包 5.3 发送ETH我们可以利用Wallet实例来发送ETH。首先，我们需要构造一个交易请求，在里面声明接收地址to和发送的ETH数额value。交易请求TransactionRequest类型可以包含发送方 from，nonce值 nounce，请求数据data等信息。 12345// 创建交易请求，参数：to为接收地址，value为ETH数额const tx = &#123; to: address1, value: ethers.utils.parseEther(&quot;0.001&quot;)&#125; 然后，我们就可以利用Wallet类的sendTransaction来发送交易，等待交易上链，并获得交易的数据。 1234//发送交易，获得收据const receipt = await wallet2.sendTransaction(tx)await receipt.wait() // 等待链上确认交易console.log(receipt) // 打印交易详情 5.4 代码实例5.4.1创建Wallet实例三种方法的示例代码： 1234567891011121314151617181920212223242526272829303132333435363738import &#123; ethers &#125; from &quot;ethers&quot;;const netWork = &quot;HTTP://127.0.0.1:8545&quot;;const provider = new ethers.providers.JsonRpcProvider(netWork);// let balance = await provider.getBalance(&quot;0xfDc84b042c01F01C7cC6eF08452BA156844c3A5C&quot;);// console.log(`Account balance: $&#123;ethers.utils.formatEther(balance)&#125; ETH`);/** 方法一：创建随机私钥的Wallet对象。 这种方法创建的钱包是单机的，我们需要用connect(provider)函数，连接到以太坊节点。这种方法创建的钱包可以用mnemonic获取助记词 */const wallet1 = ethers.Wallet.createRandom();console.log(&quot;wallet1 =&gt;\\n&quot;,wallet1);const wallet1WithProvider = wallet1.connect(provider);const mnemonic = wallet1.mnemonic;console.log(&quot;助记词：\\n&quot; , mnemonic);/** * 方法二：利用私钥和provider实例创建Wallet对象 * 这种方法不能获取助记词 */const privateKey = &quot;0x9b139483dc6f6c8782fda2301e9b65a75b3d084d79e79e04c64683bebfa1741d&quot;;const wallet2 = new ethers.Wallet(privateKey, provider);console.log(&quot;wallet2 =&gt;\\n&quot;,wallet2);/** * 方法三：利用助记词创建Wallet对象 */// 从助记词创建wallet对象const wallet3 = ethers.Wallet.fromMnemonic(mnemonic.phrase);console.log(&quot;wallet3 =&gt; &quot;,wallet3); 运行结果： 5.4.2 获取钱包地址 代码： 123456789101112/** * 获取钱包地址 */const address1 = await wallet1.getAddress()const address2 = await wallet2.getAddress() const address3 = await wallet3.getAddress() // 获取地址console.log(`1. 获取钱包地址`);console.log(`钱包1地址: $&#123;address1&#125;`);console.log(`钱包2地址: $&#123;address2&#125;`);console.log(`钱包3地址: $&#123;address3&#125;`);console.log(`钱包1和钱包3的地址是否相同: $&#123;address1 === address3&#125;`); 运行结果： 5.4.3 获取助记词利用钱包对象的mnemonic成员获取助记词： 1console.log(`钱包1助记词: $&#123;wallet1.mnemonic.phrase&#125;`) 结果： 5.4.4 利用钱包对象的 privateKey 成员获取私钥：1console.log(`钱包2私钥: $&#123;wallet2.privateKey&#125;`) 运行结果： 到ganache上查看： 结果是相同的。 5.4.5 获取钱包在链上的交互次数利用 getTransactionCount()函数获取钱包在链上的交互次数 1234const txCount1 = await wallet1WithProvider.getTransactionCount()const txCount2 = await wallet2.getTransactionCount()console.log(`钱包1发送交易次数: $&#123;txCount1&#125;`)console.log(`钱包2发送交易次数: $&#123;txCount2&#125;`) 运行结果： 到ganache上查看： 5.4.6 发送ETH我们用wallet2给wallet1发送0.001 ETH，并打印交易前后的钱包余额。由于wallet1是新建的随机私钥钱包，因此交易前余额为0，而交易后余额为0.001 ETH。 1234567891011121314151617181920212223242526272829303132333435363738const wallet1 = ethers.Wallet.createRandom();const wallet1WithProvider = wallet1.connect(provider);const mnemonic = wallet1.mnemonic;const privateKey = &quot;0x9b139483dc6f6c8782fda2301e9b65a75b3d084d79e79e04c64683bebfa1741d&quot;;const wallet2 = new ethers.Wallet(privateKey, provider);/** * 获取钱包地址 */const address1 = await wallet1.getAddress()const address2 = await wallet2.getAddress() /** * 发送ETH */console.log(&quot; wallet2 给 wallet1 转账0.01ETH&quot;);//交易前余额console.log(`钱包1: $&#123;ethers.utils.formatEther(await wallet1WithProvider.getBalance())&#125; ETH`);console.log(`钱包2: $&#123;ethers.utils.formatEther(await wallet2.getBalance())&#125; ETH`);// 构建交易请求；to为接收地址，value为ETH数额const TX = &#123; to: address1, value: ethers.utils.parseEther(&quot;0.001&quot;)&#125;// 发送交易，获得收据const recepit = await wallet2.sendTransaction(TX);await recepit.wait();console.log(&quot;receipt =&gt; &quot;,recepit);console.log(&quot;发送后的账户余额&quot;);console.log(`钱包1: $&#123;ethers.utils.formatEther(await wallet1WithProvider.getBalance())&#125; ETH`);console.log(`钱包2: $&#123;ethers.utils.formatEther(await wallet2.getBalance())&#125; ETH`); 运行结果： ethers.js_day036. 合约交互6.1 创建可写Contract变量 声明可写的Contract变量的规则： 1const contract = new ethers.Contract(address, abi, signer) 解读：其中 address 是合约地址，abi是合约的abi接口，singer是wallet对象。声明可写contract需要提供signer，声明可读contract只需要provider 将可读合约转换为可写合约： 1const contract2 = contract.connect(signer) 6.2 合约交互 读合约信息不需要gas。写入合约需要接入合约信息，构建交易，并支付gas。该交易将由整个网络的每个节点以及矿工验证，并改变区块链状态。 合约交互的方法如下： 1234// 发送交易const tx = await contract.METHOD_NAME(args [, overrides])// 等待链上确认交易await tx.wait() 解读代码：其中METHOD_NAME为调用的函数名，args为函数参数，[, overrides]是可以选择传入的数据，包括： gasPrice：gas价格 gasLimit：gas上限 value：调用时传入的ether（单位是wei） nonce：nonce（随机数？） 注：此方法不能获取合约运行的返回值，如若需要获取合约运行你的返回值，要使用Solidity事件记录，然后利用交易收据去查询。 6.3 例子：与本地ganache合约交互 创建provider，wallet变量 123456789&gt;import &#123; ethers &#125; from &quot;ethers&quot;;&gt;// 获取本地的provider&gt;const provider = new ethers.providers.JsonRpcProvider(&quot;HTTP://127.0.0.1:8545&quot;);&gt;// 根据私钥创建 wallet对象&gt;const privateKey = &quot;0x9b139483dc6f6c8782fda2301e9b65a75b3d084d79e79e04c64683bebfa1741d&quot;;&gt;const wallet = new ethers.Wallet(privateKey, provider); 创建可写合约变量，在我自己 domo1.sol中调用4个函数 getSlot0():查找插槽0位置的值； getSlot1():查找插槽1位置的值； getSlot2():查找插槽2位置的值； depoist():转账； balanceOf():查询地址余额。 tips：这里我使用的是方法是传入remix上获取的abi 12345678910111213/** * 创建可写的合约变量 */ // 读取文件的abiconst ABI = JSON.parse(fs.readFileSync(&quot;LearningSelf\\\\day03\\\\demo1.abi&quot;).toString());// 在remix上部署的合约地址const contractAddress = &quot;0x5B1557A5AD3cfAC88F3624743BF67baB28723899&quot;;// 声明可写合约const constract = new ethers.Contract(contractAddress,ABI,wallet); 3.调用getSlot0、1、2()三个函数，查看其值 12345678910// let slot0 = await provider.getStorageAt(contractAddress,0);let slot0 = await constract.getSlot0();// console.log(slot0);console.log(`slot0&#x27;s value is =&gt; $&#123;slot0&#125;`);let slot1 = await constract.getSlot1();// console.log(slot1);console.log(`slot1&#x27;s value is =&gt; $&#123;slot1&#125;`);let slot2 = await constract.getSlot2();// console.log(slot2);console.log(`slot2&#x27;s value is =&gt; $&#123;slot2&#125;`) 运行结果： 4.查询账户的余额 123456// 需要查询余额的账户let test_address = &quot;0x753f06cD09C531Ef83b84C5147E812519BB65efd&quot;;let balance = await constract.balanceOf(test_address);console.log(`ETH balance is =&gt; $&#123;ethers.utils.formatEther(balance)&#125;`) 运行结果： 5.转账操作，打印交易详情和余额。 123456//转账let balance1 = await provider.getBalance(test_address);console.log(`转账前的余额为：=&gt; $&#123;ethers.utils.formatEther(balance1)&#125;`)constract.depoist(1, test_address);console.log(`转账后的余额为：=&gt; $&#123;ethers.utils.formatEther(balance1)&#125;`) 运行结果： 由于vscode显示数位的问题，使用在remix上查询显示的位数更多 注：对于非pure&#x2F;view函数的调用，会返回交易的信息。如果想知道函数执行过程中合约变量的变化，可以在合约中使用emit输出事件，并在返回的transaction信息中读取事件信息来获取对应的值 完整的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import &#123; ethers &#125; from &quot;ethers&quot;;import fs from &quot;fs&quot;;// 获取本地的providerconst provider = new ethers.providers.JsonRpcProvider(&quot;HTTP://127.0.0.1:8545&quot;);// 根据私钥创建 wallet对象const privateKey = &quot;0x9b139483dc6f6c8782fda2301e9b65a75b3d084d79e79e04c64683bebfa1741d&quot;;const wallet = new ethers.Wallet(privateKey, provider);/** * 创建可写的合约变量 */ // 读取文件的abiconst ABI = JSON.parse(fs.readFileSync(&quot;LearningSelf\\\\day03\\\\demo1.abi&quot;).toString());// 在remix上部署的合约地址const contractAddress = &quot;0xf8fe22cA93bD2416a106dFB62168C0D7eBF557FE&quot;;// 声明可写合约const constract = new ethers.Contract(contractAddress,ABI,wallet);/** * 调用合约的函数 */// let slot0 = await provider.getStorageAt(contractAddress,0);let slot0 = await constract.getSlot0();// console.log(slot0);console.log(`slot0&#x27;s value is =&gt; $&#123;slot0&#125;`);let slot1 = await constract.getSlot1();// console.log(slot1);console.log(`slot1&#x27;s value is =&gt; $&#123;slot1&#125;`);let slot2 = await constract.getSlot2();// console.log(slot2);console.log(`slot2&#x27;s value is =&gt; $&#123;slot2&#125;`);// 需要查询余额的账户let test_address = &quot;0x753f06cD09C531Ef83b84C5147E812519BB65efd&quot;;let balance = await constract.balanceOf(test_address);console.log(`ETH balance is =&gt; $&#123;ethers.utils.formatEther(balance)&#125;`)//转账let balance1 = await provider.getBalance(test_address);console.log(`转账前的余额为：=&gt; $&#123;ethers.utils.formatEther(balance1)&#125;`)constract.depoist(1, test_address);console.log(`转账后的余额为：=&gt; $&#123;ethers.utils.formatEther(balance1)&#125;`) 7.部署合约7.1 合约工厂 ethers.js 创造了合约工厂 ContractFactory类型，方便开发者部署合约。你可以利用合约abi，编译得到的字节码bytecode和签名者变量 singer 来创建合约工厂实例，为部署合约做准备。 1const contractFactory = new ethers.ContractFactory(abi, bytecode, signer); 注：如果合约的构造函数有参数，那么在abi中必须包含构造函数。 在创建好合约工厂之后，可以调用它的deploy函数，并传入合约构造函数的参数args来部署并得到合约实例： 1const contract = await contractFactory.deploy(args) 可以使用两种命令，等待合约部署在链上确认，然后再进行交互 12await contractERC20.deployed()//或者 await contract.deployTransaction.wait() 7.2 例子：部署我自己编写的demo1.sol合约 demo2.sol 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract demo2 &#123; uint slot0; address slot1; string public slot2; // 初始化一些变量 constructor(uint _slot0, address _slot1, string memory _slot2) payable&#123; slot0 = _slot0; slot1 = _slot1; slot2 = _slot2; &#125; function setSlot0(uint num) public &#123; slot0 = num; &#125; function getSlot0() external view returns(uint)&#123; return slot0; &#125; function setSlot1(address _address) public &#123; slot1 = _address; &#125; function getSlot1() external view returns(address)&#123; return slot1; &#125; function setSlot2(string memory _str) public &#123; slot2 = _str; &#125; function getSlot2() external view returns(string memory)&#123; return slot2; &#125; function depoist(uint _amount, address payable _to) external &#123; uint balance = address(this).balance; require(balance &gt; _amount, &quot;You balance is less than your address(this).balance&quot;); _to.transfer(_amount); &#125; function balanceOf(address _address) external view returns(uint) &#123; return address(_address).balance; &#125;&#125; 创建provider和wallet变量 123456789import &#123; ethers &#125; from &quot;ethers&quot;;import fs from &quot;fs&quot;;// 获取本地的providerconst provider = new ethers.providers.JsonRpcProvider(&quot;HTTP://127.0.0.1:8545&quot;);// 根据私钥创建 wallet对象const privateKey = &quot;0x9b139483dc6f6c8782fda2301e9b65a75b3d084d79e79e04c64683bebfa1741d&quot;;const wallet = new ethers.Wallet(privateKey, provider); 准备demo1合约的字节码和ABI(这里我使用remix生成的ABI)。因为demo2的构造函数含有参数，因此我们需要把它包含再ABI中。合约的字节码可以从remix的编译面板中点击bytecode按钮拷贝下来(为了代码的可读性，将拷贝的字节码新建一个 .code文件存放，获取的时候 使用 fs来读取)，其中”object”字段对应的数据就是字节码。如果部署在链上的合约，你可以在etherscan的Contract页面的Contract Creation Code中找到。 123456789101112131415161718192021222324252627282930313233343536373839 // demo2人类可读abi /** const demo2ABI = [ &quot;constructor(uint _slot0, address _slot1, string memory _slot2) payable&quot;, ....... ] */ // 读取文件的abi const ABI = JSON.parse(fs.readFileSync(&quot;LearningSelf\\\\day03\\\\demo2.abi&quot;).toString()); // 读取文件的bytecode const byteCode = fs.readFileSync(&quot;LearningSelf\\\\day03\\\\demo2.code&quot;).toString(); 3. 创建合约工厂ContractFactory实例 ```js // 创建合约工厂 ContractFactory 实例 const factoryDemo2 = new ethers.ContractFactory(ABI, byteCode, wallet); 4. 调用工厂合约的deploy() 函数并填入构造函数的参数，部署demo2合约并获取合约实例。有写常用方法： - `contract.address`获取合约地址， - `contract.deployTransaction`获取部署详情， - `contractERC20.deployed()`等待合约部署在链上确认。 ```js // 利用 factoryDemo2 部署demo2 合约 const gasPrice = await provider.getGasPrice(); const transaction = &#123; value: ethers.utils.parseEther(&#x27;1&#x27;), gasPrice &#125;; const constract = await factoryDemo2.deploy(9,&quot;0xfDc84b042c01F01C7cC6eF08452BA156844c3A5C&quot;,&quot;biyou&quot;,transaction); console.log(`部署得到的合约地址：$&#123;constract.address&#125;`); console.log(&quot;部署合约的交易详情&quot;); console.log(constract.deployTransaction); 调用合约函数 12345678910111213/** * 调用合约的函数 */let slot0 = await constract.getSlot0();console.log(`slot0&#x27;s value is =&gt; $&#123;slot0&#125;`);let slot1 = await constract.getSlot1();console.log(`slot1&#x27;s value is =&gt; $&#123;slot1&#125;`);let slot2 = await constract.getSlot2();console.log(`slot2&#x27;s value is =&gt; $&#123;slot2&#125;`); let balance = await constract.balanceOf(&quot;0x643bB521371F66E271937C6365F5812118e58a6D&quot;);console.log(`ETH balance is =&gt; $&#123;balance&#125;`); 执行结果： 完整的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041import &#123; ethers &#125; from &quot;ethers&quot;;import fs from &quot;fs&quot;;// 获取本地的providerconst provider = new ethers.providers.JsonRpcProvider(&quot;HTTP://127.0.0.1:8545&quot;);// 根据私钥创建 wallet对象const privateKey = &quot;0x9b139483dc6f6c8782fda2301e9b65a75b3d084d79e79e04c64683bebfa1741d&quot;;const wallet = new ethers.Wallet(privateKey, provider);// 读取文件的abiconst ABI = JSON.parse(fs.readFileSync(&quot;LearningSelf\\\\day03\\\\demo2.abi&quot;).toString());// 读取文件的bytecodeconst byteCode = fs.readFileSync(&quot;LearningSelf\\\\day03\\\\demo2.code&quot;).toString();// 创建合约工厂 ContractFactory 实例const factoryDemo2 = new ethers.ContractFactory(ABI, byteCode, wallet);// 利用 factoryDemo2 部署demo2 合约const gasPrice = await provider.getGasPrice();const transaction = &#123; value: ethers.utils.parseEther(&#x27;1&#x27;), gasPrice &#125;;const constract = await factoryDemo2.deploy(9,&quot;0xfDc84b042c01F01C7cC6eF08452BA156844c3A5C&quot;,&quot;biyou&quot;,transaction);console.log(`部署得到的合约地址：$&#123;constract.address&#125;`);console.log(&quot;部署合约的交易详情&quot;);console.log(constract.deployTransaction);/** * 调用合约的函数 */let slot0 = await constract.getSlot0();console.log(`slot0&#x27;s value is =&gt; $&#123;slot0&#125;`);let slot1 = await constract.getSlot1();console.log(`slot1&#x27;s value is =&gt; $&#123;slot1&#125;`);let slot2 = await constract.getSlot2();console.log(`slot2&#x27;s value is =&gt; $&#123;slot2&#125;`);let balance = await constract.balanceOf(&quot;0x643bB521371F66E271937C6365F5812118e58a6D&quot;);console.log(`ETH balance is =&gt; $&#123;balance&#125;`); 8.检索事件 — 很有用8.1 参考博客：请移步 这里8.2 检索事件 可以利用Ethers中合约类型的queryFilter()函数读取合约释放的事件 1const transferEvents = await contract.queryFilter(&#x27;事件名&#x27;,起始区块，结束区块) queryFilter() 包含3个参数，分别是事件名（必填），起始区块（选填），和结束区块（选填）。检索结果会以数组的形式返回。 注：要检索的事件必须包含在合约的abi中。 9. 监听合约事件9.1 监听合约事件 contract.on 在ethersjs中，合约对象有一个contract.on 的监听方法，让我们持续监听合约的事件： 1contract.on(&quot;eventName&quot;, function) contract.on 有两个参数，一个是要监听的事件名称”eventName”，需要包含合约abi中；另一个是我们在事件发生时调用的函数 contract.once 合约对象有一个contract.once的监听方法，让我们只监听一次合约释放事件，它的参数与contract.on一样： 1contract.once(&quot;eventName&quot;,function) 9.2 监听合约示例在这里 —-&gt; here ………………… 10. 事件过滤现阶段的我还不适合考虑这些，日后再学 博客链接 ………………… 11. BigNumber 和 单位转换11.1 BigNumber 在以太坊中，许多计算都对JavaScript整数的安全值（js中最大安全数为9007199254740991）。因此，ethers.js使用BigNumber 类安全地对任何数量级的数字进行数学运算。在ethers.js中，大多数需要返回值的操作将返回BigNumber，而接受值的参数也会接受他们。 BigNumber官方文档 11.2 创建BigNumber实例 可以利用 ethers.BigNumber.from() 函数将string，number，BigNumber等类型转换为BigNumber。 注：超过js最大安全整数的数值将不能转换 1234567const oneGwei = ethers.BigNumber.from(&quot;1000000000&quot;); // 从十进制字符串生成console.log(oneGwei)console.log(ethers.BigNumber.from(&quot;0x3b9aca00&quot;)) // 从hex字符串生成console.log(ethers.BigNumber.from(1000000000)) // 从数字生成// 不能从js最大的安全整数之外的数字生成BigNumber，下面代码会报错// ethers.BigNumber.from(Number.MAX_SAFE_INTEGER);console.log(&quot;js中最大安全整数：&quot;, Number.MAX_SAFE_INTEGER) 运行结果： 11.3 BigNumber运算 BigNumber支持很多运算，例如加减乘除、取模mod，幂运算pow，绝对值abs等运算： 1234567// 运算console.log(&quot;加法：&quot;, oneGwei.add(1).toString())console.log(&quot;减法：&quot;, oneGwei.sub(1).toString())console.log(&quot;乘法：&quot;, oneGwei.mul(2).toString())console.log(&quot;除法：&quot;, oneGwei.div(2).toString())// 比较console.log(&quot;是否相等：&quot;, oneGwei.eq(&quot;1000000000&quot;)) 运行结果： 11. 4 单位转换 以太坊中，1 ethers 等于 10^18wei。下面是一些常用的单位： 在应用中，我们经常将数值在用户可读的字符串（以ether为单位）和机器可读的数值（以wei为单位）之间转换。例如，钱包可以为用户界面指定余额（以ether为单位）和gas价格（以gwei为单位），但是在发送交易时，两者都必须转换成以wei为单位的数值。ethers.js提供了一些功能函数，方便这类转换。 formatUnits(变量, 单位)：格式化，小单位转大单位，比如wei -&gt; ether，在显示余额时很有用。参数中，单位填位数（数字）或指定的单位（字符串）。 123456789101112131415//代码参考：https://docs.ethers.io/v5/api/utils/display-logic/#utils-parseUnitsconsole.group(&#x27;\\n2. 格式化：小单位转大单位，formatUnits&#x27;);console.log(ethers.utils.formatUnits(oneGwei, 0));// &#x27;1000000000&#x27;console.log(ethers.utils.formatUnits(oneGwei, &quot;gwei&quot;));// &#x27;1.0&#x27;console.log(ethers.utils.formatUnits(oneGwei, 9));// &#x27;1.0&#x27;console.log(ethers.utils.formatUnits(oneGwei, &quot;ether&quot;));// `0.000000001`console.log(ethers.utils.formatUnits(1000000000, &quot;gwei&quot;));// &#x27;1.0&#x27;console.log(ethers.utils.formatEther(oneGwei));// `0.000000001` 等同于formatUnits(value, &quot;ether&quot;)console.groupEnd(); 运行结果： parseUnits：解析，大单位转小单位，比如ether -&gt; wei，在将用户输入的值转为wei为单位的数值很有用。参数中，单位填位数（数字）或指定的单位（字符串）。 1234567891011121314151617// 3. 解析：大单位转小单位// 例如将ether转换为wei：parseUnits(变量, 单位),parseUnits默认单位是 ether// 代码参考：https://docs.ethers.io/v5/api/utils/display-logic/#utils-parseUnitsconsole.group(&#x27;\\n3. 解析：大单位转小单位，parseUnits&#x27;);console.log(ethers.utils.parseUnits(&quot;1.0&quot;).toString());// &#123; BigNumber: &quot;1000000000000000000&quot; &#125;console.log(ethers.utils.parseUnits(&quot;1.0&quot;, &quot;ether&quot;).toString());// &#123; BigNumber: &quot;1000000000000000000&quot; &#125;console.log(ethers.utils.parseUnits(&quot;1.0&quot;, 18).toString());// &#123; BigNumber: &quot;1000000000000000000&quot; &#125;console.log(ethers.utils.parseUnits(&quot;1.0&quot;, &quot;gwei&quot;).toString());// &#123; BigNumber: &quot;1000000000&quot; &#125;console.log(ethers.utils.parseUnits(&quot;1.0&quot;, 9).toString());// &#123; BigNumber: &quot;1000000000&quot; &#125;console.log(ethers.utils.parseEther(&quot;1.0&quot;).toString());// &#123; BigNumber: &quot;1000000000000000000&quot; &#125; 等同于parseUnits(value, &quot;ether&quot;)console.groupEnd(); 运行结果： 12. CallStaticcallStatic方法是属于ethers.Contract类的编写方法分析，同类的还有populateTransaction和estimateGas方法 12.1 可能失败的交易 在以太坊上交易需要支付昂贵的gas，并且有失败的风险，发送失败的交易并不会把gas返还给你。因此，在发送交易前知道哪些交易可能会失败非常重要。以小狐狸钱包（metamask）为例。 如果交易将失败，小狐狸会告诉你 this transaction may fail，翻译过来就是”这笔交易可能会失败”。当用户看到提示的时候，就可以取消交易了。 实现的原理：以太坊节点有一个eth_call方法，让用户可以模拟一笔交易，并返回可能的交易结果，但不是真正的在区块链上执行（交易不上链）。 12.2 callStatic 在ethers.js中你可以利用contract对象的callStatic()来调用以太坊节点的eth_call。如果调用成功，则返回ture；如果失败，则报错并返回失败原因。方法： 12const tx = await contract.callStatic.函数名( 参数, &#123;override&#125;)console.log(`交易会成功吗？：`, tx) 函数名：为模拟调用的函数名。 参数：调用函数的参数。 {override}：选填，可包含一下参数： from：执行时的msg.sender，也就是你可以模拟任何一个人的调用，比如V神。 value：执行时的msg.value。 blockTag：执行时的区块高度。 gasPrice gasLimit nonce 12.3 用callStatic 模拟DAI转账演示过程—-》博客 13. 编码 calldata13.1 接口类Interface ethers.js 的接口类抽象了与以太坊网络的合约交互所需的ABI编码和解码。ABI与API类似，是一格式，用于对合约可以处理的各种类型的数据进行编码，以便它们可以交互。 可以利用abi生成或者直接从合约中获取interface变量： 1234// 利用abi生成const interface = new ethers.utils.Interface(abi)// 直接从contract中获取const interface2 = contract.interface 接口类封装了一些编码解码的方法。与一些特殊的合约交互时（比如代理 合约），你需要编码参数、解码返回值： 注：相关函数必须包含在abi中。 getSighash():获取函数选择器（function selector），参数为函数名或函数签名。 至于函数签名如何获取，在remix上使用keccak256()或的和ethersjs使用keccak256()获取的结果完全不一样，日后空闲了再仔细深入学习 12interface.getSighash(&quot;balanceOf&quot;);// &#x27;0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef&#x27; encodeDeploy()：编码构造器的参数，然后可以附在合约字节码的后面。 1interface.encodeDeploy(&quot;Wrapped ETH&quot;, &quot;WETH&quot;); encodeFunctionData()：编码函数的calldata。 1interface.encodeFunctionData(&quot;balanceOf&quot;, [&quot;0xc778417e063141139fce010982780140aa0cd5ab&quot;]); decodeFunctionResult()：解码函数的返回值。 1interface.decodeFunctionResult(&quot;balanceOf&quot;, resultData)","categories":[{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/categories/Solidity/"},{"name":"ethers.js","slug":"Solidity/ethers-js","permalink":"https://biyouqiuqiu.com/categories/Solidity/ethers-js/"}],"tags":[{"name":"ethers.js","slug":"ethers-js","permalink":"https://biyouqiuqiu.com/tags/ethers-js/"}]}],"categories":[{"name":"Solidity","slug":"Solidity","permalink":"https://biyouqiuqiu.com/categories/Solidity/"},{"name":"ethers.js","slug":"Solidity/ethers-js","permalink":"https://biyouqiuqiu.com/categories/Solidity/ethers-js/"}],"tags":[{"name":"ethers.js","slug":"ethers-js","permalink":"https://biyouqiuqiu.com/tags/ethers-js/"}]}